
991_AI_People_Detection_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002999c  34000750  34000750  00000750  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00017278  3402a0f0  3402a0f0  0002a0f0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .version      0000000c  34041368  34041368  00041368  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  34041374  34041374  00041680  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  34041374  34041374  00041374  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  3404137c  34041680  00041680  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  3404137c  3404137c  0004137c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  34041380  34041380  00041380  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         000002dc  34041384  34041384  00041384  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000000  34041660  34041660  00041680  2**0
                  CONTENTS
 11 .gnu.sgstubs  00000020  34041660  34041660  00041660  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          00015178  34041680  34041680  00041680  2**5
                  ALLOC
 13 ._user_heap_stack 00000a00  340567f8  340567f8  00041680  2**0
                  ALLOC
 14 .EXTRAM       003f3000  91000000  91000000  00042000  2**5
                  ALLOC
 15 .ARM.attributes 0000003a  00000000  00000000  00041680  2**0
                  CONTENTS, READONLY
 16 .debug_info   00068f2e  00000000  00000000  000416ba  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 0000cfb5  00000000  00000000  000aa5e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00004330  00000000  00000000  000b75a0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 0000325b  00000000  00000000  000bb8d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  000973b1  00000000  00000000  000beb2b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0006d0a8  00000000  00000000  00155edc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    003ac8da  00000000  00000000  001c2f84  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000086  00000000  00000000  0056f85e  2**0
                  CONTENTS, READONLY
 24 .debug_frame  000126a8  00000000  00000000  0056f8e4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 00000187  00000000  00000000  00581f8c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

34000750 <__do_global_dtors_aux>:
34000750:	b510      	push	{r4, lr}
34000752:	4c05      	ldr	r4, [pc, #20]	@ (34000768 <__do_global_dtors_aux+0x18>)
34000754:	7823      	ldrb	r3, [r4, #0]
34000756:	b933      	cbnz	r3, 34000766 <__do_global_dtors_aux+0x16>
34000758:	4b04      	ldr	r3, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x1c>)
3400075a:	b113      	cbz	r3, 34000762 <__do_global_dtors_aux+0x12>
3400075c:	4804      	ldr	r0, [pc, #16]	@ (34000770 <__do_global_dtors_aux+0x20>)
3400075e:	f3af 8000 	nop.w
34000762:	2301      	movs	r3, #1
34000764:	7023      	strb	r3, [r4, #0]
34000766:	bd10      	pop	{r4, pc}
34000768:	34041680 	.word	0x34041680
3400076c:	00000000 	.word	0x00000000
34000770:	3402a0d4 	.word	0x3402a0d4

34000774 <frame_dummy>:
34000774:	b508      	push	{r3, lr}
34000776:	4b03      	ldr	r3, [pc, #12]	@ (34000784 <frame_dummy+0x10>)
34000778:	b11b      	cbz	r3, 34000782 <frame_dummy+0xe>
3400077a:	4903      	ldr	r1, [pc, #12]	@ (34000788 <frame_dummy+0x14>)
3400077c:	4803      	ldr	r0, [pc, #12]	@ (3400078c <frame_dummy+0x18>)
3400077e:	f3af 8000 	nop.w
34000782:	bd08      	pop	{r3, pc}
34000784:	00000000 	.word	0x00000000
34000788:	34041684 	.word	0x34041684
3400078c:	3402a0d4 	.word	0x3402a0d4

34000790 <_tx_initialize_low_level>:
    .thumb_func
.type _tx_initialize_low_level, function
_tx_initialize_low_level:

    /* Disable interrupts during ThreadX initialization.  */
    CPSID   i
34000790:	b672      	cpsid	i
    ADD     r1, r1, #4                              //
    STR     r1, [r0]                                // Setup first unused memory pointer
#endif

    /* Setup Vector Table Offset Register.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
34000792:	f04f 20e0 	mov.w	r0, #3758153728	@ 0xe000e000
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
34000796:	491b      	ldr	r1, [pc, #108]	@ (34000804 <__tx_DBGHandler+0x4>)
    STR     r1, [r0, #0xD08]                        // Set vector table address
34000798:	f8c0 1d08 	str.w	r1, [r0, #3336]	@ 0xd08

    /* Enable the cycle count register.  */
    LDR     r0, =0xE0001000                         // Build address of DWT register
3400079c:	481a      	ldr	r0, [pc, #104]	@ (34000808 <__tx_DBGHandler+0x8>)
    LDR     r1, [r0]                                // Pickup the current value
3400079e:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              // Set the CYCCNTENA bit
340007a0:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                // Enable the cycle count register
340007a4:	6001      	str	r1, [r0, #0]

    /* Set system stack pointer from vector value.  */
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
340007a6:	4819      	ldr	r0, [pc, #100]	@ (3400080c <__tx_DBGHandler+0xc>)
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
340007a8:	4916      	ldr	r1, [pc, #88]	@ (34000804 <__tx_DBGHandler+0x4>)
    LDR     r1, [r1]                                // Pickup reset stack pointer
340007aa:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                // Save system stack pointer
340007ac:	6001      	str	r1, [r0, #0]

    /* Configure SysTick.  */
    MOV     r0, #0xE000E000                         // Build address of NVIC registers
340007ae:	f04f 20e0 	mov.w	r0, #3758153728	@ 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
340007b2:	4917      	ldr	r1, [pc, #92]	@ (34000810 <__tx_DBGHandler+0x10>)
    STR     r1, [r0, #0x14]                         // Setup SysTick Reload Value
340007b4:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                // Build SysTick Control Enable Value
340007b6:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         // Setup SysTick Control
340007ba:	6101      	str	r1, [r0, #16]

    /* Configure handler priorities.  */
    LDR     r1, =0x00000000                         // Rsrv, UsgF, BusF, MemM
340007bc:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        // Setup System Handlers 4-7 Priority Registers
340007c0:	f8c0 1d18 	str.w	r1, [r0, #3352]	@ 0xd18
    LDR     r1, =0xFF000000                         // SVCl, Rsrv, Rsrv, Rsrv
340007c4:	f04f 417f 	mov.w	r1, #4278190080	@ 0xff000000
    STR     r1, [r0, #0xD1C]                        // Setup System Handlers 8-11 Priority Registers
340007c8:	f8c0 1d1c 	str.w	r1, [r0, #3356]	@ 0xd1c
                                                    // Note: SVC must be lowest priority, which is 0xFF
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
340007cc:	4911      	ldr	r1, [pc, #68]	@ (34000814 <__tx_DBGHandler+0x14>)
    STR     r1, [r0, #0xD20]                        // Setup System Handlers 12-15 Priority Registers
340007ce:	f8c0 1d20 	str.w	r1, [r0, #3360]	@ 0xd20
                                                    // Note: PnSV must be lowest priority, which is 0xFF

    /* Return to caller.  */
    BX      lr
340007d2:	4770      	bx	lr

340007d4 <__tx_BadHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_BadHandler
    .thumb_func
.type __tx_BadHandler, function
__tx_BadHandler:
    B       __tx_BadHandler
340007d4:	f7ff bffe 	b.w	340007d4 <__tx_BadHandler>

340007d8 <__tx_IntHandler>:
    .thumb_func
.type __tx_IntHandler, function
__tx_IntHandler:
// VOID InterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
340007d8:	b501      	push	{r0, lr}
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_enter             // Call the ISR enter function
340007da:	f023 faf5 	bl	34023dc8 <_tx_execution_isr_enter>
#endif
    /* Do interrupt handler work here */
    /* .... */
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
340007de:	f023 fbcd 	bl	34023f7c <_tx_execution_isr_exit>
#endif
    POP     {r0,lr}
340007e2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
340007e6:	4770      	bx	lr

340007e8 <SysTick_Handler>:
    .thumb_func
.type SysTick_Handler, function
SysTick_Handler:
// VOID TimerInterruptHandler (VOID)
// {
    PUSH    {r0,lr}     // Save LR (and dummy r0 to maintain stack alignment)
340007e8:	b501      	push	{r0, lr}
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_enter             // Call the ISR enter function
340007ea:	f023 faed 	bl	34023dc8 <_tx_execution_isr_enter>
#endif
    BL      _tx_timer_interrupt
340007ee:	f000 f8a3 	bl	34000938 <_tx_timer_interrupt>
#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    BL      _tx_execution_isr_exit              // Call the ISR exit function
340007f2:	f023 fbc3 	bl	34023f7c <_tx_execution_isr_exit>
#endif
    POP     {r0,lr}
340007f6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      lr
340007fa:	4770      	bx	lr

340007fc <__tx_NMIHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_NMIHandler
    .thumb_func
.type __tx_NMIHandler, function
__tx_NMIHandler:
    B       __tx_NMIHandler
340007fc:	f7ff bffe 	b.w	340007fc <__tx_NMIHandler>

34000800 <__tx_DBGHandler>:
    .eabi_attribute Tag_ABI_align_preserved, 1
    .global  __tx_DBGHandler
    .thumb_func
.type __tx_DBGHandler, function
__tx_DBGHandler:
    B       __tx_DBGHandler
34000800:	f7ff bffe 	b.w	34000800 <__tx_DBGHandler>
    LDR     r1, =g_pfnVectors                       // Pickup address of vector table
34000804:	34000400 	.word	0x34000400
    LDR     r0, =0xE0001000                         // Build address of DWT register
34000808:	e0001000 	.word	0xe0001000
    LDR     r0, =_tx_thread_system_stack_ptr        // Build address of system stack pointer
3400080c:	3404aaec 	.word	0x3404aaec
    LDR     r1, =SYSTICK_CYCLES
34000810:	000c34ff 	.word	0x000c34ff
    LDR     r1, =0x40FF0000                         // SysT, PnSV, Rsrv, DbgM
34000814:	40ff0000 	.word	0x40ff0000

34000818 <_tx_thread_schedule>:
    /* This function should only ever be called on Cortex-M
       from the first schedule request. Subsequent scheduling occurs
       from the PendSV handling routine below. */

    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */
    MOV     r0, #0                                  // Build value for TX_FALSE
34000818:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
3400081c:	4a32      	ldr	r2, [pc, #200]	@ (340008e8 <_tx_vfp_access+0x4>)
    STR     r0, [r2, #0]                            // Clear preempt disable flag
3400081e:	6010      	str	r0, [r2, #0]

#ifdef __ARM_FP
    /* Clear CONTROL.FPCA bit so VFP registers aren't unnecessarily stacked.  */
    MRS     r0, CONTROL                             // Pickup current CONTROL register
34000820:	f3ef 8014 	mrs	r0, CONTROL
    BIC     r0, r0, #4                              // Clear the FPCA bit
34000824:	f020 0004 	bic.w	r0, r0, #4
    MSR     CONTROL, r0                             // Setup new CONTROL register
34000828:	f380 8814 	msr	CONTROL, r0
#endif

    /* Enable interrupts */
    CPSIE   i
3400082c:	b662      	cpsie	i

    /* Enter the scheduler for the first time.  */
    MOV     r0, #0x10000000                         // Load PENDSVSET bit
3400082e:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
    MOV     r1, #0xE000E000                         // Load NVIC base
34000832:	f04f 21e0 	mov.w	r1, #3758153728	@ 0xe000e000
    STR     r0, [r1, #0xD04]                        // Set PENDSVBIT in ICSR
34000836:	f8c1 0d04 	str.w	r0, [r1, #3332]	@ 0xd04
    DSB                                             // Complete all memory accesses
3400083a:	f3bf 8f4f 	dsb	sy
    ISB                                             // Flush pipeline
3400083e:	f3bf 8f6f 	isb	sy

34000842 <__tx_wait_here>:

    /* Wait here for the PendSV to take place.  */

__tx_wait_here:
    B       __tx_wait_here                          // Wait for the PendSV to happen
34000842:	e7fe      	b.n	34000842 <__tx_wait_here>

34000844 <PendSV_Handler>:
    /* Call the thread exit function to indicate the thread is no longer executing.  */
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
34000844:	b672      	cpsid	i
#endif  /* TX_PORT_USE_BASEPRI */
    PUSH    {r0, lr}                                // Save LR (and r0 just for alignment)
34000846:	b501      	push	{r0, lr}
    BL      _tx_execution_thread_exit               // Call the thread exit function
34000848:	f023 fa34 	bl	34023cb4 <_tx_execution_thread_exit>
    POP     {r0, lr}                                // Recover LR
3400084c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#ifdef TX_PORT_USE_BASEPRI
    MOV     r0, 0                                   // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r0
#else
    CPSIE   i                                       // Enable interrupts
34000850:	b662      	cpsie	i
#endif  /* TX_PORT_USE_BASEPRI */
#endif  /* EXECUTION PROFILE */

    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
34000852:	4826      	ldr	r0, [pc, #152]	@ (340008ec <_tx_vfp_access+0x8>)
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
34000854:	4a26      	ldr	r2, [pc, #152]	@ (340008f0 <_tx_vfp_access+0xc>)
    MOV     r3, #0                                  // Build NULL value
34000856:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                // Pickup current thread pointer
3400085a:	6801      	ldr	r1, [r0, #0]

    /* Determine if there is a current thread to finish preserving.  */

    CBZ     r1, __tx_ts_new                         // If NULL, skip preservation
3400085c:	b191      	cbz	r1, 34000884 <__tx_ts_new>

    /* Recover PSP and preserve current thread context.  */

    STR     r3, [r0]                                // Set _tx_thread_current_ptr to NULL
3400085e:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                // Pickup PSP pointer (thread's stack pointer)
34000860:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          // Save its remaining registers
34000864:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
34000868:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_save
3400086c:	d101      	bne.n	34000872 <_skip_vfp_save>
    VSTMDB  r12!,{s16-s31}                          // Yes, save additional VFP registers
3400086e:	ed2c 8a10 	vstmdb	ip!, {s16-s31}

34000872 <_skip_vfp_save>:
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
34000872:	4c20      	ldr	r4, [pc, #128]	@ (340008f4 <_tx_vfp_access+0x10>)
    STMDB   r12!, {LR}                              // Save LR on the stack
34000874:	f84c ed04 	str.w	lr, [ip, #-4]!
    STR     r12, [r1, #8]                           // Save the thread stack pointer
34000878:	f8c1 c008 	str.w	ip, [r1, #8]
_skip_secure_save:
#endif

    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */

    LDR     r5, [r4]                                // Pickup current time-slice
3400087c:	6825      	ldr	r5, [r4, #0]
    CBZ     r5, __tx_ts_new                         // If not active, skip processing
3400087e:	b10d      	cbz	r5, 34000884 <__tx_ts_new>

    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */

    STR     r5, [r1, #24]                           // Save current time-slice
34000880:	618d      	str	r5, [r1, #24]

    /* Clear the global time-slice.  */

    STR     r3, [r4]                                // Clear time-slice
34000882:	6023      	str	r3, [r4, #0]

34000884 <__tx_ts_new>:

#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
34000884:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Is there another thread ready to execute?
34000886:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        // No, skip to the wait processing
34000888:	b1f1      	cbz	r1, 340008c8 <__tx_ts_wait>

    /* Yes, another thread is ready for else, make the current thread the new thread.  */

    STR     r1, [r0]                                // Setup the current thread pointer to the new thread
3400088a:	6001      	str	r1, [r0, #0]
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
3400088c:	b662      	cpsie	i

3400088e <__tx_ts_restore>:
#endif

    /* Increment the thread run count.  */

__tx_ts_restore:
    LDR     r7, [r1, #4]                            // Pickup the current thread run count
3400088e:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
34000890:	4c18      	ldr	r4, [pc, #96]	@ (340008f4 <_tx_vfp_access+0x10>)
    LDR     r5, [r1, #24]                           // Pickup thread's current time-slice
34000892:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              // Increment the thread run count
34000894:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            // Store the new run count
34000898:	604f      	str	r7, [r1, #4]

    /* Setup global time-slice with thread's current time-slice.  */

    STR     r5, [r4]                                // Setup global time-slice
3400089a:	6025      	str	r5, [r4, #0]

#if (defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE))
    /* Call the thread entry function to indicate the thread is executing.  */
    PUSH    {r0, r1}                                // Save r0 and r1
3400089c:	b403      	push	{r0, r1}
    BL      _tx_execution_thread_enter              // Call the thread execution enter function
3400089e:	f023 f9ab 	bl	34023bf8 <_tx_execution_thread_enter>
    POP     {r0, r1}                                // Recover r0 and r1
340008a2:	bc03      	pop	{r0, r1}
    POP     {r0,r1}                                 // Restore r1 (and dummy r0)
_skip_secure_restore:
#endif

    /* Restore the thread context and PSP.  */
    LDR     r12, [r1, #12]                          // Get stack start
340008a4:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    MSR     PSPLIM, r12                             // Set stack limit
340008a8:	f38c 880b 	msr	PSPLIM, ip
    LDR     r12, [r1, #8]                           // Pickup thread's stack pointer
340008ac:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              // Pickup LR
340008b0:	f85c eb04 	ldr.w	lr, [ip], #4
#ifdef __ARM_FP
    TST     LR, #0x10                               // Determine if the VFP extended frame is present
340008b4:	f01e 0f10 	tst.w	lr, #16
    BNE     _skip_vfp_restore                       // If not, skip VFP restore
340008b8:	d101      	bne.n	340008be <_skip_vfp_restore>
    VLDMIA  r12!, {s16-s31}                         // Yes, restore additional VFP registers
340008ba:	ecbc 8a10 	vldmia	ip!, {s16-s31}

340008be <_skip_vfp_restore>:
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          // Recover thread's registers
340008be:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                // Setup the thread's stack pointer
340008c2:	f38c 8809 	msr	PSP, ip

    BX      lr                                      // Return to thread!
340008c6:	4770      	bx	lr

340008c8 <__tx_ts_wait>:
__tx_ts_wait:
#ifdef TX_PORT_USE_BASEPRI
    LDR     r1, =TX_PORT_BASEPRI                    // Mask interrupt priorities =< TX_PORT_BASEPRI
    MSR     BASEPRI, r1
#else
    CPSID   i                                       // Disable interrupts
340008c8:	b672      	cpsid	i
#endif
    LDR     r1, [r2]                                // Pickup the next thread to execute pointer
340008ca:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                // Store it in the current pointer
340008cc:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       // If non-NULL, a new thread is ready!
340008ce:	b909      	cbnz	r1, 340008d4 <__tx_ts_ready>

#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
340008d0:	b662      	cpsie	i
#endif
    B       __tx_ts_wait                            // Loop to continue waiting
340008d2:	e7f9      	b.n	340008c8 <__tx_ts_wait>

340008d4 <__tx_ts_ready>:

    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are
       already in the handler!  */
__tx_ts_ready:
    MOV     r7, #0x08000000                         // Build clear PendSV value
340008d4:	f04f 6700 	mov.w	r7, #134217728	@ 0x8000000
    MOV     r8, #0xE000E000                         // Build base NVIC address
340008d8:	f04f 28e0 	mov.w	r8, #3758153728	@ 0xe000e000
    STR     r7, [r8, #0xD04]                        // Clear any PendSV
340008dc:	f8c8 7d04 	str.w	r7, [r8, #3332]	@ 0xd04
    /* Re-enable interrupts and restore new thread.  */
#ifdef TX_PORT_USE_BASEPRI
    MOV     r4, #0                                  // Disable BASEPRI masking (enable interrupts)
    MSR     BASEPRI, r4
#else
    CPSIE   i                                       // Enable interrupts
340008e0:	b662      	cpsie	i
#endif
    B       __tx_ts_restore                         // Restore the thread
340008e2:	e7d4      	b.n	3400088e <__tx_ts_restore>

340008e4 <_tx_vfp_access>:
.type _tx_vfp_access, function
_tx_vfp_access:
#if TX_ENABLE_FPU_SUPPORT
    VMOV.F32 s0, s0                                 // Simply access the VFP
#endif
    BX       lr                                     // Return to caller
340008e4:	4770      	bx	lr
340008e6:	0000      	.short	0x0000
    LDR     r2, =_tx_thread_preempt_disable         // Build address of preempt disable flag
340008e8:	3404ab8c 	.word	0x3404ab8c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
340008ec:	3404aaf0 	.word	0x3404aaf0
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
340008f0:	3404aaf4 	.word	0x3404aaf4
    LDR     r4, =_tx_timer_time_slice               // Build address of time-slice variable
340008f4:	3404b10c 	.word	0x3404b10c

340008f8 <_tx_thread_stack_build>:
                       pc          Initial value for pc
                       xPSR        Initial value for xPSR

    Stack Bottom: (higher memory address)  */

    LDR     r2, [r0, #16]                           // Pickup end of stack area
340008f8:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            // Align frame for 8-byte alignment
340008fa:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             // Subtract frame size
340008fe:	f1a2 0244 	sub.w	r2, r2, #68	@ 0x44
#ifdef TX_SINGLE_MODE_SECURE
    LDR     r3, =0xFFFFFFFD                         // Build initial LR value for secure mode
34000902:	f06f 0302 	mvn.w	r3, #2
#else
    LDR     r3, =0xFFFFFFBC                         // Build initial LR value to return to non-secure PSP
#endif
    STR     r3, [r2, #0]                            // Save on the stack
34000906:	6013      	str	r3, [r2, #0]

    /* Actually build the stack frame.  */

    MOV     r3, #0                                  // Build initial register value
34000908:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            // Store initial r4
3400090c:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            // Store initial r5
3400090e:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           // Store initial r6
34000910:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           // Store initial r7
34000912:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           // Store initial r8
34000914:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           // Store initial r9
34000916:	6193      	str	r3, [r2, #24]
    STR     r3, [r2, #28]                           // Store initial r10
34000918:	61d3      	str	r3, [r2, #28]
    STR     r3, [r2, #32]                           // Store initial r11
3400091a:	6213      	str	r3, [r2, #32]

    /* Hardware stack follows.  */

    STR     r3, [r2, #36]                           // Store initial r0
3400091c:	6253      	str	r3, [r2, #36]	@ 0x24
    STR     r3, [r2, #40]                           // Store initial r1
3400091e:	6293      	str	r3, [r2, #40]	@ 0x28
    STR     r3, [r2, #44]                           // Store initial r2
34000920:	62d3      	str	r3, [r2, #44]	@ 0x2c
    STR     r3, [r2, #48]                           // Store initial r3
34000922:	6313      	str	r3, [r2, #48]	@ 0x30
    STR     r3, [r2, #52]                           // Store initial r12
34000924:	6353      	str	r3, [r2, #52]	@ 0x34
    MOV     r3, #0xFFFFFFFF                         // Poison EXC_RETURN value
34000926:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           // Store initial lr
3400092a:	6393      	str	r3, [r2, #56]	@ 0x38
    STR     r1, [r2, #60]                           // Store initial pc
3400092c:	63d1      	str	r1, [r2, #60]	@ 0x3c
    MOV     r3, #0x01000000                         // Only T-bit need be set
3400092e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
    STR     r3, [r2, #64]                           // Store initial xPSR
34000932:	6413      	str	r3, [r2, #64]	@ 0x40

    /* Setup stack pointer.  */
    // thread_ptr -> tx_thread_stack_ptr =  r2;

    STR     r2, [r0, #8]                            // Save stack pointer in thread's
34000934:	6082      	str	r2, [r0, #8]
                                                    //   control block
    BX      lr                                      // Return to caller
34000936:	4770      	bx	lr

34000938 <_tx_timer_interrupt>:
       for use.  */

    /* Increment the system clock.  */
    // _tx_timer_system_clock++;

    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
34000938:	4922      	ldr	r1, [pc, #136]	@ (340009c4 <__tx_timer_nothing_expired+0x8>)
    LDR     r0, [r1, #0]                            // Pickup system clock
3400093a:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              // Increment system clock
3400093c:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            // Store new system clock
34000940:	6008      	str	r0, [r1, #0]

    /* Test for time-slice expiration.  */
    // if (_tx_timer_time_slice)
    // {

    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
34000942:	4b21      	ldr	r3, [pc, #132]	@ (340009c8 <__tx_timer_nothing_expired+0xc>)
    LDR     r2, [r3, #0]                            // Pickup time-slice
34000944:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_no_time_slice            // Is it non-active?
34000946:	b13a      	cbz	r2, 34000958 <__tx_timer_no_time_slice>
                                                    // Yes, skip time-slice processing

       /* Decrement the time_slice.  */
       // _tx_timer_time_slice--;

    SUB     r2, r2, #1                              // Decrement the time-slice
34000948:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            // Store new time-slice value
3400094c:	601a      	str	r2, [r3, #0]

       /* Check for expiration.  */
       // if (__tx_timer_time_slice == 0)

    CBNZ    r2, __tx_timer_no_time_slice            // Has it expired?
3400094e:	b91a      	cbnz	r2, 34000958 <__tx_timer_no_time_slice>
                                                    // No, skip expiration processing

       /* Set the time-slice expired flag.  */
       // _tx_timer_expired_time_slice =  TX_TRUE;

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
34000950:	4b1e      	ldr	r3, [pc, #120]	@ (340009cc <__tx_timer_nothing_expired+0x10>)
    MOV     r0, #1                                  // Build expired value
34000952:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            // Set time-slice expiration flag
34000956:	6018      	str	r0, [r3, #0]

34000958 <__tx_timer_no_time_slice>:

    /* Test for timer expiration.  */
    // if (*_tx_timer_current_ptr)
    // {

    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
34000958:	491d      	ldr	r1, [pc, #116]	@ (340009d0 <__tx_timer_nothing_expired+0x14>)
    LDR     r0, [r1, #0]                            // Pickup current timer
3400095a:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            // Pickup timer list entry
3400095c:	6802      	ldr	r2, [r0, #0]
    CBZ     r2, __tx_timer_no_timer                 // Is there anything in the list?
3400095e:	b122      	cbz	r2, 3400096a <__tx_timer_no_timer>
                                                    // No, just increment the timer

        /* Set expiration flag.  */
        // _tx_timer_expired =  TX_TRUE;

    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
34000960:	4b1c      	ldr	r3, [pc, #112]	@ (340009d4 <__tx_timer_nothing_expired+0x18>)
    MOV     r2, #1                                  // Build expired value
34000962:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            // Set expired flag
34000966:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         // Finished timer processing
34000968:	e008      	b.n	3400097c <__tx_timer_done>

3400096a <__tx_timer_no_timer>:
__tx_timer_no_timer:

        /* No timer expired, increment the timer pointer.  */
        // _tx_timer_current_ptr++;

    ADD     r0, r0, #4                              // Move to next timer
3400096a:	f100 0004 	add.w	r0, r0, #4

        /* Check for wrap-around.  */
        // if (_tx_timer_current_ptr == _tx_timer_list_end)

    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
3400096e:	4b1a      	ldr	r3, [pc, #104]	@ (340009d8 <__tx_timer_nothing_expired+0x1c>)
    LDR     r2, [r3, #0]                            // Pickup list end
34000970:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  // Are we at list end?
34000972:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    // No, skip wrap-around logic
34000974:	d101      	bne.n	3400097a <__tx_timer_skip_wrap>

            /* Wrap to beginning of list.  */
            // _tx_timer_current_ptr =  _tx_timer_list_start;

    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
34000976:	4b19      	ldr	r3, [pc, #100]	@ (340009dc <__tx_timer_nothing_expired+0x20>)
    LDR     r0, [r3, #0]                            // Set current pointer to list start
34000978:	6818      	ldr	r0, [r3, #0]

3400097a <__tx_timer_skip_wrap>:

__tx_timer_skip_wrap:

    STR     r0, [r1, #0]                            // Store new current timer pointer
3400097a:	6008      	str	r0, [r1, #0]

3400097c <__tx_timer_done>:

    /* See if anything has expired.  */
    // if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of expired flag
3400097c:	4b13      	ldr	r3, [pc, #76]	@ (340009cc <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup time-slice expired flag
3400097e:	681a      	ldr	r2, [r3, #0]
    CBNZ    r2, __tx_something_expired              // Did a time-slice expire?
34000980:	b912      	cbnz	r2, 34000988 <__tx_something_expired>
                                                    // If non-zero, time-slice expired
    LDR     r1, =_tx_timer_expired                  // Pickup addr of other expired flag
34000982:	4914      	ldr	r1, [pc, #80]	@ (340009d4 <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
34000984:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_nothing_expired          // Did a timer expire?
34000986:	b1c8      	cbz	r0, 340009bc <__tx_timer_nothing_expired>

34000988 <__tx_something_expired>:
                                                    // No, nothing expired

__tx_something_expired:

    PUSH    {r0, lr}                                // Save the lr register on the stack
34000988:	b501      	push	{r0, lr}

    /* Did a timer expire?  */
    // if (_tx_timer_expired)
    // {

    LDR     r1, =_tx_timer_expired                  // Pickup addr of expired flag
3400098a:	4912      	ldr	r1, [pc, #72]	@ (340009d4 <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            // Pickup timer expired flag
3400098c:	6808      	ldr	r0, [r1, #0]
    CBZ     r0, __tx_timer_dont_activate            // Check for timer expiration
3400098e:	b108      	cbz	r0, 34000994 <__tx_timer_dont_activate>
                                                    // If not set, skip timer activation

        /* Process timer expiration.  */
        // _tx_timer_expiration_process();

    BL      _tx_timer_expiration_process            // Call the timer expiration handling routine
34000990:	f022 fb2c 	bl	34022fec <_tx_timer_expiration_process>

34000994 <__tx_timer_dont_activate>:

    /* Did time slice expire?  */
    // if (_tx_timer_expired_time_slice)
    // {

    LDR     r3, =_tx_timer_expired_time_slice       // Pickup addr of time-slice expired
34000994:	4b0d      	ldr	r3, [pc, #52]	@ (340009cc <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            // Pickup the actual flag
34000996:	681a      	ldr	r2, [r3, #0]
    CBZ     r2, __tx_timer_not_ts_expiration        // See if the flag is set
34000998:	b172      	cbz	r2, 340009b8 <__tx_timer_not_ts_expiration>
                                                    // No, skip time-slice processing

        /* Time slice interrupted thread.  */
        // _tx_thread_time_slice();

    BL      _tx_thread_time_slice                   // Call time-slice processing
3400099a:	f022 fa7b 	bl	34022e94 <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
3400099e:	4810      	ldr	r0, [pc, #64]	@ (340009e0 <__tx_timer_nothing_expired+0x24>)
    LDR     r1, [r0]                                // Is the preempt disable flag set?
340009a0:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          // Yes, skip the PendSV logic
340009a2:	b949      	cbnz	r1, 340009b8 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
340009a4:	480f      	ldr	r0, [pc, #60]	@ (340009e4 <__tx_timer_nothing_expired+0x28>)
    LDR     r1, [r0]                                // Pickup the current thread pointer
340009a6:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
340009a8:	4a0f      	ldr	r2, [pc, #60]	@ (340009e8 <__tx_timer_nothing_expired+0x2c>)
    LDR     r3, [r2]                                // Pickup the execute thread pointer
340009aa:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         // Build address of control register
340009ac:	480f      	ldr	r0, [pc, #60]	@ (340009ec <__tx_timer_nothing_expired+0x30>)
    LDR     r2, =0x10000000                         // Build value for PendSV bit
340009ae:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    CMP     r1, r3                                  // Are they the same?
340009b2:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              // If the same, there was no time-slice performed
340009b4:	d000      	beq.n	340009b8 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                // Not the same, issue the PendSV for preemption
340009b6:	6002      	str	r2, [r0, #0]

340009b8 <__tx_timer_not_ts_expiration>:
__tx_timer_skip_time_slice:
    // }

__tx_timer_not_ts_expiration:

    POP     {r0, lr}                                // Recover lr register (r0 is just there for
340009b8:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

340009bc <__tx_timer_nothing_expired>:

    // }

__tx_timer_nothing_expired:

    DSB                                             // Complete all memory access
340009bc:	f3bf 8f4f 	dsb	sy
    BX      lr                                      // Return to caller
340009c0:	4770      	bx	lr
340009c2:	0000      	.short	0x0000
    LDR     r1, =_tx_timer_system_clock             // Pickup address of system clock
340009c4:	3404ab98 	.word	0x3404ab98
    LDR     r3, =_tx_timer_time_slice               // Pickup address of time-slice
340009c8:	3404b10c 	.word	0x3404b10c
    LDR     r3, =_tx_timer_expired_time_slice       // Pickup address of expired flag
340009cc:	3404ab9c 	.word	0x3404ab9c
    LDR     r1, =_tx_timer_current_ptr              // Pickup current timer pointer address
340009d0:	3404ac28 	.word	0x3404ac28
    LDR     r3, =_tx_timer_expired                  // Pickup expiration flag address
340009d4:	3404ac2c 	.word	0x3404ac2c
    LDR     r3, =_tx_timer_list_end                 // Pickup addr of timer list end
340009d8:	3404ac24 	.word	0x3404ac24
    LDR     r3, =_tx_timer_list_start               // Pickup addr of timer list start
340009dc:	3404ac20 	.word	0x3404ac20
    LDR     r0, =_tx_thread_preempt_disable         // Build address of preempt disable flag
340009e0:	3404ab8c 	.word	0x3404ab8c
    LDR     r0, =_tx_thread_current_ptr             // Build current thread pointer address
340009e4:	3404aaf0 	.word	0x3404aaf0
    LDR     r2, =_tx_thread_execute_ptr             // Build execute thread pointer address
340009e8:	3404aaf4 	.word	0x3404aaf4
    LDR     r0, =0xE000ED04                         // Build address of control register
340009ec:	e000ed04 	.word	0xe000ed04

340009f0 <vsvAKZpqpB>:
340009f0:	ed90 6aad 	vldr	s12, [r0, #692]	@ 0x2b4
340009f4:	b530      	push	{r4, r5, lr}
340009f6:	ed2d 8b10 	vpush	{d8-d15}
340009fa:	ed90 7ba8 	vldr	d7, [r0, #672]	@ 0x2a0
340009fe:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
34000a02:	b087      	sub	sp, #28
34000a04:	ed8d 7b02 	vstr	d7, [sp, #8]
34000a08:	2300      	movs	r3, #0
34000a0a:	ed90 7ba4 	vldr	d7, [r0, #656]	@ 0x290
34000a0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a12:	ed91 5a01 	vldr	s10, [r1, #4]
34000a16:	ed91 4a00 	vldr	s8, [r1]
34000a1a:	ed91 fb02 	vldr	d15, [r1, #8]
34000a1e:	ed91 eb04 	vldr	d14, [r1, #16]
34000a22:	4604      	mov	r4, r0
34000a24:	ed90 3b12 	vldr	d3, [r0, #72]	@ 0x48
34000a28:	ed90 cbaa 	vldr	d12, [r0, #680]	@ 0x2a8
34000a2c:	ed90 ab16 	vldr	d10, [r0, #88]	@ 0x58
34000a30:	ed8d 7b04 	vstr	d7, [sp, #16]
34000a34:	ed90 bba6 	vldr	d11, [r0, #664]	@ 0x298
34000a38:	f880 3060 	strb.w	r3, [r0, #96]	@ 0x60
34000a3c:	dc09      	bgt.n	34000a52 <vsvAKZpqpB+0x62>
34000a3e:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
34000a42:	48d1      	ldr	r0, [pc, #836]	@ (34000d88 <vsvAKZpqpB+0x398>)
34000a44:	4798      	blx	r3
34000a46:	f04f 30ff 	mov.w	r0, #4294967295
34000a4a:	b007      	add	sp, #28
34000a4c:	ecbd 8b10 	vpop	{d8-d15}
34000a50:	bd30      	pop	{r4, r5, pc}
34000a52:	eeb8 5b45 	vcvt.f64.u32	d5, s10
34000a56:	ed9f 7bbe 	vldr	d7, [pc, #760]	@ 34000d50 <vsvAKZpqpB+0x360>
34000a5a:	eeb8 4b44 	vcvt.f64.u32	d4, s8
34000a5e:	ee25 7b07 	vmul.f64	d7, d5, d7
34000a62:	eeb4 7bc4 	vcmpe.f64	d7, d4
34000a66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a6a:	dd0f      	ble.n	34000a8c <vsvAKZpqpB+0x9c>
34000a6c:	ed90 7b1c 	vldr	d7, [r0, #112]	@ 0x70
34000a70:	ed9f 2bb9 	vldr	d2, [pc, #740]	@ 34000d58 <vsvAKZpqpB+0x368>
34000a74:	ee37 2b02 	vadd.f64	d2, d7, d2
34000a78:	ed9f 7bb9 	vldr	d7, [pc, #740]	@ 34000d60 <vsvAKZpqpB+0x370>
34000a7c:	eeb4 2bc7 	vcmpe.f64	d2, d7
34000a80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a84:	fe37 7b02 	vselgt.f64	d7, d7, d2
34000a88:	ed80 7b1c 	vstr	d7, [r0, #112]	@ 0x70
34000a8c:	ed9f 7bb6 	vldr	d7, [pc, #728]	@ 34000d68 <vsvAKZpqpB+0x378>
34000a90:	ee25 5b07 	vmul.f64	d5, d5, d7
34000a94:	eeb4 5bc4 	vcmpe.f64	d5, d4
34000a98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000a9c:	d510      	bpl.n	34000ac0 <vsvAKZpqpB+0xd0>
34000a9e:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
34000aa2:	ed9f 5bad 	vldr	d5, [pc, #692]	@ 34000d58 <vsvAKZpqpB+0x368>
34000aa6:	ee37 7b45 	vsub.f64	d7, d7, d5
34000aaa:	ed9f 5bb1 	vldr	d5, [pc, #708]	@ 34000d70 <vsvAKZpqpB+0x380>
34000aae:	eeb4 7bc5 	vcmpe.f64	d7, d5
34000ab2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ab6:	bf58      	it	pl
34000ab8:	eeb0 5b47 	vmovpl.f64	d5, d7
34000abc:	ed84 5b1c 	vstr	d5, [r4, #112]	@ 0x70
34000ac0:	ee83 8b0c 	vdiv.f64	d8, d3, d12
34000ac4:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000ac8:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000acc:	f894 5050 	ldrb.w	r5, [r4, #80]	@ 0x50
34000ad0:	ee28 8b0c 	vmul.f64	d8, d8, d12
34000ad4:	2d01      	cmp	r5, #1
34000ad6:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000ada:	f040 80ac 	bne.w	34000c36 <vsvAKZpqpB+0x246>
34000ade:	ed9f 7ba6 	vldr	d7, [pc, #664]	@ 34000d78 <vsvAKZpqpB+0x388>
34000ae2:	ee3f 5b4e 	vsub.f64	d5, d15, d14
34000ae6:	ee85 db07 	vdiv.f64	d13, d5, d7
34000aea:	ee3f 5b0e 	vadd.f64	d5, d15, d14
34000aee:	ee85 9b07 	vdiv.f64	d9, d5, d7
34000af2:	eeb0 7bcd 	vabs.f64	d7, d13
34000af6:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000afa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000afe:	eeb0 5bc9 	vabs.f64	d5, d9
34000b02:	db1f      	blt.n	34000b44 <vsvAKZpqpB+0x154>
34000b04:	eeb4 6bc5 	vcmpe.f64	d6, d5
34000b08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b0c:	db1a      	blt.n	34000b44 <vsvAKZpqpB+0x154>
34000b0e:	2300      	movs	r3, #0
34000b10:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34000b14:	ed94 7b1a 	vldr	d7, [r4, #104]	@ 0x68
34000b18:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
34000b1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b20:	f340 8134 	ble.w	34000d8c <vsvAKZpqpB+0x39c>
34000b24:	2301      	movs	r3, #1
34000b26:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000b2a:	ed9d 7b02 	vldr	d7, [sp, #8]
34000b2e:	eeb4 abc7 	vcmpe.f64	d10, d7
34000b32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b36:	f140 813c 	bpl.w	34000db2 <vsvAKZpqpB+0x3c2>
34000b3a:	ed9d 7b04 	vldr	d7, [sp, #16]
34000b3e:	ee3a bb07 	vadd.f64	d11, d10, d7
34000b42:	e128      	b.n	34000d96 <vsvAKZpqpB+0x3a6>
34000b44:	eeb4 6bc5 	vcmpe.f64	d6, d5
34000b48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b4c:	d50c      	bpl.n	34000b68 <vsvAKZpqpB+0x178>
34000b4e:	ee89 5b0d 	vdiv.f64	d5, d9, d13
34000b52:	ed94 6aae 	vldr	s12, [r4, #696]	@ 0x2b8
34000b56:	eeb0 5bc5 	vabs.f64	d5, d5
34000b5a:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000b5e:	eeb4 5bc6 	vcmpe.f64	d5, d6
34000b62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b66:	dad5      	bge.n	34000b14 <vsvAKZpqpB+0x124>
34000b68:	eef7 0bca 	vcvt.f32.f64	s1, d10
34000b6c:	eeb7 0bc7 	vcvt.f32.f64	s0, d7
34000b70:	f029 f892 	bl	34029c98 <powf>
34000b74:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34000b78:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34000b7c:	ee20 0b07 	vmul.f64	d0, d0, d7
34000b80:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34000b84:	eeb0 6bce 	vabs.f64	d6, d14
34000b88:	edcd 7a01 	vstr	s15, [sp, #4]
34000b8c:	eeb0 7bcf 	vabs.f64	d7, d15
34000b90:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000b94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000b98:	dc62      	bgt.n	34000c60 <vsvAKZpqpB+0x270>
34000b9a:	eeb5 ebc0 	vcmpe.f64	d14, #0.0
34000b9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ba2:	d562      	bpl.n	34000c6a <vsvAKZpqpB+0x27a>
34000ba4:	ee38 0b00 	vadd.f64	d0, d8, d0
34000ba8:	ed94 7b3c 	vldr	d7, [r4, #240]	@ 0xf0
34000bac:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000bb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bb4:	d503      	bpl.n	34000bbe <vsvAKZpqpB+0x1ce>
34000bb6:	eeb0 ab4b 	vmov.f64	d10, d11
34000bba:	eeb0 0b47 	vmov.f64	d0, d7
34000bbe:	ed94 7b3a 	vldr	d7, [r4, #232]	@ 0xe8
34000bc2:	eeb4 7bc0 	vcmpe.f64	d7, d0
34000bc6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000bca:	dd03      	ble.n	34000bd4 <vsvAKZpqpB+0x1e4>
34000bcc:	eeb0 ab4b 	vmov.f64	d10, d11
34000bd0:	eeb0 0b47 	vmov.f64	d0, d7
34000bd4:	ee80 8b0c 	vdiv.f64	d8, d0, d12
34000bd8:	eebc 8bc8 	vcvt.u32.f64	s16, d8
34000bdc:	eeb8 8b48 	vcvt.f64.u32	d8, s16
34000be0:	2d01      	cmp	r5, #1
34000be2:	ee2c 8b08 	vmul.f64	d8, d12, d8
34000be6:	d116      	bne.n	34000c16 <vsvAKZpqpB+0x226>
34000be8:	f8b4 30e0 	ldrh.w	r3, [r4, #224]	@ 0xe0
34000bec:	2b02      	cmp	r3, #2
34000bee:	d83f      	bhi.n	34000c70 <vsvAKZpqpB+0x280>
34000bf0:	eddd 7a01 	vldr	s15, [sp, #4]
34000bf4:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000bf8:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
34000bfc:	ed82 7b20 	vstr	d7, [r2, #128]	@ 0x80
34000c00:	ed82 8b26 	vstr	d8, [r2, #152]	@ 0x98
34000c04:	eb04 1203 	add.w	r2, r4, r3, lsl #4
34000c08:	3301      	adds	r3, #1
34000c0a:	ed82 db2c 	vstr	d13, [r2, #176]	@ 0xb0
34000c0e:	ed82 9b2e 	vstr	d9, [r2, #184]	@ 0xb8
34000c12:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34000c16:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000c1a:	2b01      	cmp	r3, #1
34000c1c:	d007      	beq.n	34000c2e <vsvAKZpqpB+0x23e>
34000c1e:	eefc 7bc8 	vcvt.u32.f64	s15, d8
34000c22:	ee17 3a90 	vmov	r3, s15
34000c26:	9a01      	ldr	r2, [sp, #4]
34000c28:	4293      	cmp	r3, r2
34000c2a:	f43f af73 	beq.w	34000b14 <vsvAKZpqpB+0x124>
34000c2e:	2301      	movs	r3, #1
34000c30:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000c34:	e76e      	b.n	34000b14 <vsvAKZpqpB+0x124>
34000c36:	eeb0 7bcf 	vabs.f64	d7, d15
34000c3a:	eeb0 5bce 	vabs.f64	d5, d14
34000c3e:	eeb4 5b47 	vcmp.f64	d5, d7
34000c42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c46:	fe35 7b07 	vselgt.f64	d7, d5, d7
34000c4a:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000c4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c52:	f67f af5f 	bls.w	34000b14 <vsvAKZpqpB+0x124>
34000c56:	ed9f 9b4a 	vldr	d9, [pc, #296]	@ 34000d80 <vsvAKZpqpB+0x390>
34000c5a:	eeb0 db49 	vmov.f64	d13, d9
34000c5e:	e783      	b.n	34000b68 <vsvAKZpqpB+0x178>
34000c60:	eeb5 fbc0 	vcmpe.f64	d15, #0.0
34000c64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c68:	d59c      	bpl.n	34000ba4 <vsvAKZpqpB+0x1b4>
34000c6a:	ee38 0b40 	vsub.f64	d0, d8, d0
34000c6e:	e79b      	b.n	34000ba8 <vsvAKZpqpB+0x1b8>
34000c70:	ed94 7b2a 	vldr	d7, [r4, #168]	@ 0xa8
34000c74:	ed94 6aaf 	vldr	s12, [r4, #700]	@ 0x2bc
34000c78:	ee38 7b47 	vsub.f64	d7, d8, d7
34000c7c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34000c80:	eeb0 7bc7 	vabs.f64	d7, d7
34000c84:	eeb4 7bc6 	vcmpe.f64	d7, d6
34000c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000c8c:	db56      	blt.n	34000d3c <vsvAKZpqpB+0x34c>
34000c8e:	ed94 7b28 	vldr	d7, [r4, #160]	@ 0xa0
34000c92:	ee38 7b47 	vsub.f64	d7, d8, d7
34000c96:	eeb0 7bc7 	vabs.f64	d7, d7
34000c9a:	eeb4 6bc7 	vcmpe.f64	d6, d7
34000c9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000ca2:	dd4b      	ble.n	34000d3c <vsvAKZpqpB+0x34c>
34000ca4:	ed94 0b32 	vldr	d0, [r4, #200]	@ 0xc8
34000ca8:	ed94 7b30 	vldr	d7, [r4, #192]	@ 0xc0
34000cac:	ee39 0b40 	vsub.f64	d0, d9, d0
34000cb0:	ee3d 7b47 	vsub.f64	d7, d13, d7
34000cb4:	ee20 0b00 	vmul.f64	d0, d0, d0
34000cb8:	eea7 0b07 	vfma.f64	d0, d7, d7
34000cbc:	f028 fb44 	bl	34029348 <sqrt>
34000cc0:	ed94 7ab0 	vldr	s14, [r4, #704]	@ 0x2c0
34000cc4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000cc8:	eeb4 0bc7 	vcmpe.f64	d0, d7
34000ccc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000cd0:	d534      	bpl.n	34000d3c <vsvAKZpqpB+0x34c>
34000cd2:	eddd 7a01 	vldr	s15, [sp, #4]
34000cd6:	eeb8 8b67 	vcvt.f64.u32	d8, s15
34000cda:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
34000cde:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000ce2:	2b00      	cmp	r3, #0
34000ce4:	d197      	bne.n	34000c16 <vsvAKZpqpB+0x226>
34000ce6:	2210      	movs	r2, #16
34000ce8:	f104 0188 	add.w	r1, r4, #136	@ 0x88
34000cec:	f104 0080 	add.w	r0, r4, #128	@ 0x80
34000cf0:	f026 fa36 	bl	34027160 <memmove>
34000cf4:	2210      	movs	r2, #16
34000cf6:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
34000cfa:	f104 0098 	add.w	r0, r4, #152	@ 0x98
34000cfe:	f026 fa2f 	bl	34027160 <memmove>
34000d02:	e9d4 2330 	ldrd	r2, r3, [r4, #192]	@ 0xc0
34000d06:	eddd 7a01 	vldr	s15, [sp, #4]
34000d0a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34000d0e:	e9c4 232c 	strd	r2, r3, [r4, #176]	@ 0xb0
34000d12:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	@ 0xc8
34000d16:	ed84 7b24 	vstr	d7, [r4, #144]	@ 0x90
34000d1a:	e9c4 232e 	strd	r2, r3, [r4, #184]	@ 0xb8
34000d1e:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	@ 0xd0
34000d22:	ed84 8b2a 	vstr	d8, [r4, #168]	@ 0xa8
34000d26:	e9c4 2330 	strd	r2, r3, [r4, #192]	@ 0xc0
34000d2a:	e9d4 2336 	ldrd	r2, r3, [r4, #216]	@ 0xd8
34000d2e:	ed84 db34 	vstr	d13, [r4, #208]	@ 0xd0
34000d32:	ed84 9b36 	vstr	d9, [r4, #216]	@ 0xd8
34000d36:	e9c4 2332 	strd	r2, r3, [r4, #200]	@ 0xc8
34000d3a:	e76c      	b.n	34000c16 <vsvAKZpqpB+0x226>
34000d3c:	f894 3078 	ldrb.w	r3, [r4, #120]	@ 0x78
34000d40:	2b01      	cmp	r3, #1
34000d42:	bf04      	itt	eq
34000d44:	2300      	moveq	r3, #0
34000d46:	f884 3078 	strbeq.w	r3, [r4, #120]	@ 0x78
34000d4a:	e7c8      	b.n	34000cde <vsvAKZpqpB+0x2ee>
34000d4c:	f3af 8000 	nop.w
34000d50:	9999999a 	.word	0x9999999a
34000d54:	3fa99999 	.word	0x3fa99999
34000d58:	47ae147b 	.word	0x47ae147b
34000d5c:	3f847ae1 	.word	0x3f847ae1
34000d60:	33333334 	.word	0x33333334
34000d64:	3fc33333 	.word	0x3fc33333
34000d68:	33333333 	.word	0x33333333
34000d6c:	3fc33333 	.word	0x3fc33333
34000d70:	11111111 	.word	0x11111111
34000d74:	3fb11111 	.word	0x3fb11111
34000d78:	667f3bcd 	.word	0x667f3bcd
34000d7c:	3ff6a09e 	.word	0x3ff6a09e
	...
34000d88:	3403df00 	.word	0x3403df00
34000d8c:	f894 3060 	ldrb.w	r3, [r4, #96]	@ 0x60
34000d90:	2b00      	cmp	r3, #0
34000d92:	f47f aeca 	bne.w	34000b2a <vsvAKZpqpB+0x13a>
34000d96:	ee88 7b0c 	vdiv.f64	d7, d8, d12
34000d9a:	eebc 7bc7 	vcvt.u32.f64	s14, d7
34000d9e:	eeb8 7b47 	vcvt.f64.u32	d7, s14
34000da2:	ee27 7b0c 	vmul.f64	d7, d7, d12
34000da6:	ed84 bb16 	vstr	d11, [r4, #88]	@ 0x58
34000daa:	ed84 7b12 	vstr	d7, [r4, #72]	@ 0x48
34000dae:	2001      	movs	r0, #1
34000db0:	e64b      	b.n	34000a4a <vsvAKZpqpB+0x5a>
34000db2:	ed9d bb02 	vldr	d11, [sp, #8]
34000db6:	e7ee      	b.n	34000d96 <vsvAKZpqpB+0x3a6>

34000db8 <JxZhqVLLqu>:
34000db8:	ed90 6b1a 	vldr	d6, [r0, #104]	@ 0x68
34000dbc:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000dc0:	ed90 4b12 	vldr	d4, [r0, #72]	@ 0x48
34000dc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000dc8:	ed90 5baa 	vldr	d5, [r0, #680]	@ 0x2a8
34000dcc:	eeb0 7b46 	vmov.f64	d7, d6
34000dd0:	bfdf      	itttt	le
34000dd2:	ee84 7b05 	vdivle.f64	d7, d4, d5
34000dd6:	eebc 7bc7 	vcvtle.u32.f64	s14, d7
34000dda:	eeb8 7b47 	vcvtle.f64.u32	d7, s14
34000dde:	ee27 7b05 	vmulle.f64	d7, d7, d5
34000de2:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
34000de6:	ed90 5b3c 	vldr	d5, [r0, #240]	@ 0xf0
34000dea:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000dee:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000df2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000df6:	bfc8      	it	gt
34000df8:	eeb7 7bc5 	vcvtgt.f32.f64	s14, d5
34000dfc:	ed90 5b3a 	vldr	d5, [r0, #232]	@ 0xe8
34000e00:	eeb7 4ac7 	vcvt.f64.f32	d4, s14
34000e04:	eeb4 4bc5 	vcmpe.f64	d4, d5
34000e08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e0c:	bf48      	it	mi
34000e0e:	eeb7 7bc5 	vcvtmi.f32.f64	s14, d5
34000e12:	eeb7 5ac7 	vcvt.f64.f32	d5, s14
34000e16:	f8d0 3274 	ldr.w	r3, [r0, #628]	@ 0x274
34000e1a:	b530      	push	{r4, r5, lr}
34000e1c:	ed80 5b12 	vstr	d5, [r0, #72]	@ 0x48
34000e20:	ed93 5a00 	vldr	s10, [r3]
34000e24:	edd0 7aac 	vldr	s15, [r0, #688]	@ 0x2b0
34000e28:	eeb4 5ac7 	vcmpe.f32	s10, s14
34000e2c:	eef1 5a67 	vneg.f32	s11, s15
34000e30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e34:	f04f 0100 	mov.w	r1, #0
34000e38:	f8b0 30f8 	ldrh.w	r3, [r0, #248]	@ 0xf8
34000e3c:	fe75 7aa7 	vselgt.f32	s15, s11, s15
34000e40:	3b01      	subs	r3, #1
34000e42:	b28a      	uxth	r2, r1
34000e44:	4293      	cmp	r3, r2
34000e46:	d805      	bhi.n	34000e54 <JxZhqVLLqu+0x9c>
34000e48:	2244      	movs	r2, #68	@ 0x44
34000e4a:	fb02 0303 	mla	r3, r2, r3, r0
34000e4e:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34000e52:	e011      	b.n	34000e78 <JxZhqVLLqu+0xc0>
34000e54:	eb00 0482 	add.w	r4, r0, r2, lsl #2
34000e58:	edd4 5a44 	vldr	s11, [r4, #272]	@ 0x110
34000e5c:	ee77 5aa5 	vadd.f32	s11, s15, s11
34000e60:	eef4 5ac7 	vcmpe.f32	s11, s14
34000e64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e68:	f101 0101 	add.w	r1, r1, #1
34000e6c:	dbe9      	blt.n	34000e42 <JxZhqVLLqu+0x8a>
34000e6e:	2344      	movs	r3, #68	@ 0x44
34000e70:	fb03 0202 	mla	r2, r3, r2, r0
34000e74:	f502 7390 	add.w	r3, r2, #288	@ 0x120
34000e78:	eeb5 6bc0 	vcmpe.f64	d6, #0.0
34000e7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34000e80:	f8c0 3274 	str.w	r3, [r0, #628]	@ 0x274
34000e84:	dc05      	bgt.n	34000e92 <JxZhqVLLqu+0xda>
34000e86:	ed93 7a00 	vldr	s14, [r3]
34000e8a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34000e8e:	ed80 7b12 	vstr	d7, [r0, #72]	@ 0x48
34000e92:	685a      	ldr	r2, [r3, #4]
34000e94:	f103 0138 	add.w	r1, r3, #56	@ 0x38
34000e98:	6042      	str	r2, [r0, #4]
34000e9a:	689a      	ldr	r2, [r3, #8]
34000e9c:	f103 0424 	add.w	r4, r3, #36	@ 0x24
34000ea0:	6082      	str	r2, [r0, #8]
34000ea2:	68da      	ldr	r2, [r3, #12]
34000ea4:	60c2      	str	r2, [r0, #12]
34000ea6:	691a      	ldr	r2, [r3, #16]
34000ea8:	6102      	str	r2, [r0, #16]
34000eaa:	f100 0238 	add.w	r2, r0, #56	@ 0x38
34000eae:	695d      	ldr	r5, [r3, #20]
34000eb0:	330c      	adds	r3, #12
34000eb2:	6145      	str	r5, [r0, #20]
34000eb4:	68dd      	ldr	r5, [r3, #12]
34000eb6:	300c      	adds	r0, #12
34000eb8:	60c5      	str	r5, [r0, #12]
34000eba:	691d      	ldr	r5, [r3, #16]
34000ebc:	42a3      	cmp	r3, r4
34000ebe:	6105      	str	r5, [r0, #16]
34000ec0:	f851 5b04 	ldr.w	r5, [r1], #4
34000ec4:	f842 5b04 	str.w	r5, [r2], #4
34000ec8:	d1f1      	bne.n	34000eae <JxZhqVLLqu+0xf6>
34000eca:	2001      	movs	r0, #1
34000ecc:	bd30      	pop	{r4, r5, pc}

34000ece <evision_api_awb_new>:
34000ece:	b510      	push	{r4, lr}
34000ed0:	4604      	mov	r4, r0
34000ed2:	b090      	sub	sp, #64	@ 0x40
34000ed4:	b170      	cbz	r0, 34000ef4 <evision_api_awb_new+0x26>
34000ed6:	2300      	movs	r3, #0
34000ed8:	4c08      	ldr	r4, [pc, #32]	@ (34000efc <evision_api_awb_new+0x2e>)
34000eda:	2140      	movs	r1, #64	@ 0x40
34000edc:	7023      	strb	r3, [r4, #0]
34000ede:	f8c4 02c8 	str.w	r0, [r4, #712]	@ 0x2c8
34000ee2:	4b07      	ldr	r3, [pc, #28]	@ (34000f00 <evision_api_awb_new+0x32>)
34000ee4:	4668      	mov	r0, sp
34000ee6:	4a07      	ldr	r2, [pc, #28]	@ (34000f04 <evision_api_awb_new+0x36>)
34000ee8:	f025 fff0 	bl	34026ecc <sniprintf>
34000eec:	4668      	mov	r0, sp
34000eee:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
34000ef2:	4798      	blx	r3
34000ef4:	4620      	mov	r0, r4
34000ef6:	b010      	add	sp, #64	@ 0x40
34000ef8:	bd10      	pop	{r4, pc}
34000efa:	bf00      	nop
34000efc:	340416a0 	.word	0x340416a0
34000f00:	34041368 	.word	0x34041368
34000f04:	3403df40 	.word	0x3403df40

34000f08 <evision_api_awb_delete>:
34000f08:	2800      	cmp	r0, #0
34000f0a:	bf14      	ite	ne
34000f0c:	2001      	movne	r0, #1
34000f0e:	f04f 30ff 	moveq.w	r0, #4294967295
34000f12:	4770      	bx	lr

34000f14 <evision_api_awb_set_profile>:
34000f14:	ed80 0a00 	vstr	s0, [r0]
34000f18:	b530      	push	{r4, r5, lr}
34000f1a:	680c      	ldr	r4, [r1, #0]
34000f1c:	6044      	str	r4, [r0, #4]
34000f1e:	684c      	ldr	r4, [r1, #4]
34000f20:	6084      	str	r4, [r0, #8]
34000f22:	688c      	ldr	r4, [r1, #8]
34000f24:	60c4      	str	r4, [r0, #12]
34000f26:	68c9      	ldr	r1, [r1, #12]
34000f28:	f102 0424 	add.w	r4, r2, #36	@ 0x24
34000f2c:	6101      	str	r1, [r0, #16]
34000f2e:	f100 0138 	add.w	r1, r0, #56	@ 0x38
34000f32:	6815      	ldr	r5, [r2, #0]
34000f34:	320c      	adds	r2, #12
34000f36:	6145      	str	r5, [r0, #20]
34000f38:	f852 5c08 	ldr.w	r5, [r2, #-8]
34000f3c:	300c      	adds	r0, #12
34000f3e:	60c5      	str	r5, [r0, #12]
34000f40:	f852 5c04 	ldr.w	r5, [r2, #-4]
34000f44:	42a2      	cmp	r2, r4
34000f46:	6105      	str	r5, [r0, #16]
34000f48:	f853 5b04 	ldr.w	r5, [r3], #4
34000f4c:	f841 5b04 	str.w	r5, [r1], #4
34000f50:	d1ef      	bne.n	34000f32 <evision_api_awb_set_profile+0x1e>
34000f52:	bd30      	pop	{r4, r5, pc}

34000f54 <evision_api_awb_init_profiles>:
34000f54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34000f58:	ed2d 8b06 	vpush	{d8-d10}
34000f5c:	460e      	mov	r6, r1
34000f5e:	eeb0 9b40 	vmov.f64	d9, d0
34000f62:	eeb0 8b41 	vmov.f64	d8, d1
34000f66:	461d      	mov	r5, r3
34000f68:	4604      	mov	r4, r0
34000f6a:	b0c7      	sub	sp, #284	@ 0x11c
34000f6c:	2800      	cmp	r0, #0
34000f6e:	f000 818f 	beq.w	34001290 <evision_api_awb_init_profiles+0x33c>
34000f72:	ed9f abcb 	vldr	d10, [pc, #812]	@ 340012a0 <evision_api_awb_init_profiles+0x34c>
34000f76:	ed80 ab12 	vstr	d10, [r0, #72]	@ 0x48
34000f7a:	2000      	movs	r0, #0
34000f7c:	49ce      	ldr	r1, [pc, #824]	@ (340012b8 <evision_api_awb_init_profiles+0x364>)
34000f7e:	f04f 0800 	mov.w	r8, #0
34000f82:	e9c4 0116 	strd	r0, r1, [r4, #88]	@ 0x58
34000f86:	e9c4 01a6 	strd	r0, r1, [r4, #664]	@ 0x298
34000f8a:	e9c4 01aa 	strd	r0, r1, [r4, #680]	@ 0x2a8
34000f8e:	49cb      	ldr	r1, [pc, #812]	@ (340012bc <evision_api_awb_init_profiles+0x368>)
34000f90:	f8df 935c 	ldr.w	r9, [pc, #860]	@ 340012f0 <evision_api_awb_init_profiles+0x39c>
34000f94:	f8c4 12b0 	str.w	r1, [r4, #688]	@ 0x2b0
34000f98:	f04f 517e 	mov.w	r1, #1065353216	@ 0x3f800000
34000f9c:	f8c4 12b4 	str.w	r1, [r4, #692]	@ 0x2b4
34000fa0:	f04f 517c 	mov.w	r1, #1056964608	@ 0x3f000000
34000fa4:	e9c4 891a 	strd	r8, r9, [r4, #104]	@ 0x68
34000fa8:	f20f 29fc 	addw	r9, pc, #764	@ 0x2fc
34000fac:	e9d9 8900 	ldrd	r8, r9, [r9]
34000fb0:	e9c4 891c 	strd	r8, r9, [r4, #112]	@ 0x70
34000fb4:	e9c4 89a4 	strd	r8, r9, [r4, #656]	@ 0x290
34000fb8:	f04f 0800 	mov.w	r8, #0
34000fbc:	f8c4 12b8 	str.w	r1, [r4, #696]	@ 0x2b8
34000fc0:	49bf      	ldr	r1, [pc, #764]	@ (340012c0 <evision_api_awb_init_profiles+0x36c>)
34000fc2:	f8df 9330 	ldr.w	r9, [pc, #816]	@ 340012f4 <evision_api_awb_init_profiles+0x3a0>
34000fc6:	f8c4 12bc 	str.w	r1, [r4, #700]	@ 0x2bc
34000fca:	f04f 517f 	mov.w	r1, #1069547520	@ 0x3fc00000
34000fce:	2300      	movs	r3, #0
34000fd0:	e9c4 89a8 	strd	r8, r9, [r4, #672]	@ 0x2a0
34000fd4:	2701      	movs	r7, #1
34000fd6:	f04f 0800 	mov.w	r8, #0
34000fda:	f8c4 12c0 	str.w	r1, [r4, #704]	@ 0x2c0
34000fde:	1e71      	subs	r1, r6, #1
34000fe0:	f8df 9314 	ldr.w	r9, [pc, #788]	@ 340012f8 <evision_api_awb_init_profiles+0x3a4>
34000fe4:	b288      	uxth	r0, r1
34000fe6:	2804      	cmp	r0, #4
34000fe8:	e9c4 89a0 	strd	r8, r9, [r4, #640]	@ 0x280
34000fec:	f20f 29c0 	addw	r9, pc, #704	@ 0x2c0
34000ff0:	e9d9 8900 	ldrd	r8, r9, [r9]
34000ff4:	f884 3060 	strb.w	r3, [r4, #96]	@ 0x60
34000ff8:	e9c4 89a2 	strd	r8, r9, [r4, #648]	@ 0x288
34000ffc:	f8a4 30e0 	strh.w	r3, [r4, #224]	@ 0xe0
34001000:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
34001004:	f8a4 7278 	strh.w	r7, [r4, #632]	@ 0x278
34001008:	d914      	bls.n	34001034 <evision_api_awb_init_profiles+0xe0>
3400100a:	2305      	movs	r3, #5
3400100c:	f44f 7180 	mov.w	r1, #256	@ 0x100
34001010:	4aac      	ldr	r2, [pc, #688]	@ (340012c4 <evision_api_awb_init_profiles+0x370>)
34001012:	a806      	add	r0, sp, #24
34001014:	f025 ff5a 	bl	34026ecc <sniprintf>
34001018:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400101c:	a806      	add	r0, sp, #24
3400101e:	4798      	blx	r3
34001020:	f884 7050 	strb.w	r7, [r4, #80]	@ 0x50
34001024:	4620      	mov	r0, r4
34001026:	b047      	add	sp, #284	@ 0x11c
34001028:	ecbd 8b06 	vpop	{d8-d10}
3400102c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001030:	f7ff bec2 	b.w	34000db8 <JxZhqVLLqu>
34001034:	ed95 7a00 	vldr	s14, [r5]
34001038:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400103c:	eeb4 0bc7 	vcmpe.f64	d0, d7
34001040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001044:	dd12      	ble.n	3400106c <evision_api_awb_init_profiles+0x118>
34001046:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400104a:	489f      	ldr	r0, [pc, #636]	@ (340012c8 <evision_api_awb_init_profiles+0x374>)
3400104c:	4798      	blx	r3
3400104e:	ed95 7a00 	vldr	s14, [r5]
34001052:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001056:	ed8d 9b00 	vstr	d9, [sp]
3400105a:	ed8d 7b02 	vstr	d7, [sp, #8]
3400105e:	4a9b      	ldr	r2, [pc, #620]	@ (340012cc <evision_api_awb_init_profiles+0x378>)
34001060:	f44f 7180 	mov.w	r1, #256	@ 0x100
34001064:	a806      	add	r0, sp, #24
34001066:	f025 ff31 	bl	34026ecc <sniprintf>
3400106a:	e7d5      	b.n	34001018 <evision_api_awb_init_profiles+0xc4>
3400106c:	f04f 0c44 	mov.w	ip, #68	@ 0x44
34001070:	fb0c 5806 	mla	r8, ip, r6, r5
34001074:	ed18 7a11 	vldr	s14, [r8, #-68]	@ 0xffffffbc
34001078:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400107c:	eeb4 1bc7 	vcmpe.f64	d1, d7
34001080:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001084:	d541      	bpl.n	3400110a <evision_api_awb_init_profiles+0x1b6>
34001086:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400108a:	4891      	ldr	r0, [pc, #580]	@ (340012d0 <evision_api_awb_init_profiles+0x37c>)
3400108c:	4798      	blx	r3
3400108e:	ed98 7a00 	vldr	s14, [r8]
34001092:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001096:	ed8d 8b00 	vstr	d8, [sp]
3400109a:	ed8d 7b02 	vstr	d7, [sp, #8]
3400109e:	4a8d      	ldr	r2, [pc, #564]	@ (340012d4 <evision_api_awb_init_profiles+0x380>)
340010a0:	e7de      	b.n	34001060 <evision_api_awb_init_profiles+0x10c>
340010a2:	fb0c f708 	mul.w	r7, ip, r8
340010a6:	eb05 0907 	add.w	r9, r5, r7
340010aa:	3744      	adds	r7, #68	@ 0x44
340010ac:	442f      	add	r7, r5
340010ae:	ed99 7a00 	vldr	s14, [r9]
340010b2:	edd7 7a00 	vldr	s15, [r7]
340010b6:	eeb4 7ae7 	vcmpe.f32	s14, s15
340010ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340010be:	f108 0a01 	add.w	sl, r8, #1
340010c2:	f100 0001 	add.w	r0, r0, #1
340010c6:	db21      	blt.n	3400110c <evision_api_awb_init_profiles+0x1b8>
340010c8:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
340010cc:	4882      	ldr	r0, [pc, #520]	@ (340012d8 <evision_api_awb_init_profiles+0x384>)
340010ce:	4798      	blx	r3
340010d0:	ed97 7a00 	vldr	s14, [r7]
340010d4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340010d8:	ed8d 7b04 	vstr	d7, [sp, #16]
340010dc:	f8cd a008 	str.w	sl, [sp, #8]
340010e0:	ed99 7a00 	vldr	s14, [r9]
340010e4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340010e8:	4643      	mov	r3, r8
340010ea:	ed8d 7b00 	vstr	d7, [sp]
340010ee:	4a7b      	ldr	r2, [pc, #492]	@ (340012dc <evision_api_awb_init_profiles+0x388>)
340010f0:	f44f 7180 	mov.w	r1, #256	@ 0x100
340010f4:	a806      	add	r0, sp, #24
340010f6:	f025 fee9 	bl	34026ecc <sniprintf>
340010fa:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
340010fe:	a806      	add	r0, sp, #24
34001100:	4798      	blx	r3
34001102:	2301      	movs	r3, #1
34001104:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34001108:	e78c      	b.n	34001024 <evision_api_awb_init_profiles+0xd0>
3400110a:	4618      	mov	r0, r3
3400110c:	fa1f f880 	uxth.w	r8, r0
34001110:	4541      	cmp	r1, r8
34001112:	d8c6      	bhi.n	340010a2 <evision_api_awb_init_profiles+0x14e>
34001114:	2300      	movs	r3, #0
34001116:	f04f 0c44 	mov.w	ip, #68	@ 0x44
3400111a:	1eb0      	subs	r0, r6, #2
3400111c:	b29f      	uxth	r7, r3
3400111e:	42b9      	cmp	r1, r7
34001120:	d839      	bhi.n	34001196 <evision_api_awb_init_profiles+0x242>
34001122:	ed84 9b3a 	vstr	d9, [r4, #232]	@ 0xe8
34001126:	ed84 8b3c 	vstr	d8, [r4, #240]	@ 0xf0
3400112a:	2000      	movs	r0, #0
3400112c:	f8a4 60f8 	strh.w	r6, [r4, #248]	@ 0xf8
34001130:	b283      	uxth	r3, r0
34001132:	4299      	cmp	r1, r3
34001134:	f100 0001 	add.w	r0, r0, #1
34001138:	f200 808b 	bhi.w	34001252 <evision_api_awb_init_profiles+0x2fe>
3400113c:	2700      	movs	r7, #0
3400113e:	46b8      	mov	r8, r7
34001140:	f104 0afc 	add.w	sl, r4, #252	@ 0xfc
34001144:	f504 7990 	add.w	r9, r4, #288	@ 0x120
34001148:	eb05 0b07 	add.w	fp, r5, r7
3400114c:	eb09 0007 	add.w	r0, r9, r7
34001150:	2244      	movs	r2, #68	@ 0x44
34001152:	4659      	mov	r1, fp
34001154:	f026 faad 	bl	340276b2 <memcpy>
34001158:	f8db 3000 	ldr.w	r3, [fp]
3400115c:	f108 0801 	add.w	r8, r8, #1
34001160:	f84a 3b04 	str.w	r3, [sl], #4
34001164:	fa1f f388 	uxth.w	r3, r8
34001168:	429e      	cmp	r6, r3
3400116a:	f107 0744 	add.w	r7, r7, #68	@ 0x44
3400116e:	d8eb      	bhi.n	34001148 <evision_api_awb_init_profiles+0x1f4>
34001170:	1e73      	subs	r3, r6, #1
34001172:	b29b      	uxth	r3, r3
34001174:	2e00      	cmp	r6, #0
34001176:	f103 0301 	add.w	r3, r3, #1
3400117a:	bf14      	ite	ne
3400117c:	461a      	movne	r2, r3
3400117e:	2201      	moveq	r2, #1
34001180:	f8c4 9274 	str.w	r9, [r4, #628]	@ 0x274
34001184:	f504 71b2 	add.w	r1, r4, #356	@ 0x164
34001188:	3a01      	subs	r2, #1
3400118a:	d16a      	bne.n	34001262 <evision_api_awb_init_profiles+0x30e>
3400118c:	2301      	movs	r3, #1
3400118e:	f884 3050 	strb.w	r3, [r4, #80]	@ 0x50
34001192:	7023      	strb	r3, [r4, #0]
34001194:	e746      	b.n	34001024 <evision_api_awb_init_profiles+0xd0>
34001196:	eb02 0987 	add.w	r9, r2, r7, lsl #2
3400119a:	42b8      	cmp	r0, r7
3400119c:	edd9 7a00 	vldr	s15, [r9]
340011a0:	ea4f 0887 	mov.w	r8, r7, lsl #2
340011a4:	f107 0a01 	add.w	sl, r7, #1
340011a8:	d91e      	bls.n	340011e8 <evision_api_awb_init_profiles+0x294>
340011aa:	f108 0804 	add.w	r8, r8, #4
340011ae:	4490      	add	r8, r2
340011b0:	ed98 7a00 	vldr	s14, [r8]
340011b4:	eeb4 7ae7 	vcmpe.f32	s14, s15
340011b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340011bc:	d814      	bhi.n	340011e8 <evision_api_awb_init_profiles+0x294>
340011be:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
340011c2:	4847      	ldr	r0, [pc, #284]	@ (340012e0 <evision_api_awb_init_profiles+0x38c>)
340011c4:	4798      	blx	r3
340011c6:	ed98 7a00 	vldr	s14, [r8]
340011ca:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340011ce:	ed8d 7b04 	vstr	d7, [sp, #16]
340011d2:	f8cd a008 	str.w	sl, [sp, #8]
340011d6:	ed99 7a00 	vldr	s14, [r9]
340011da:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
340011de:	463b      	mov	r3, r7
340011e0:	ed8d 7b00 	vstr	d7, [sp]
340011e4:	4a3f      	ldr	r2, [pc, #252]	@ (340012e4 <evision_api_awb_init_profiles+0x390>)
340011e6:	e783      	b.n	340010f0 <evision_api_awb_init_profiles+0x19c>
340011e8:	fb0c f807 	mul.w	r8, ip, r7
340011ec:	eb05 0a08 	add.w	sl, r5, r8
340011f0:	ed9a 7a00 	vldr	s14, [sl]
340011f4:	eeb4 7ae7 	vcmpe.f32	s14, s15
340011f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340011fc:	f108 0844 	add.w	r8, r8, #68	@ 0x44
34001200:	44a8      	add	r8, r5
34001202:	da08      	bge.n	34001216 <evision_api_awb_init_profiles+0x2c2>
34001204:	ed98 7a00 	vldr	s14, [r8]
34001208:	eeb4 7ae7 	vcmpe.f32	s14, s15
3400120c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001210:	f103 0301 	add.w	r3, r3, #1
34001214:	d882      	bhi.n	3400111c <evision_api_awb_init_profiles+0x1c8>
34001216:	f8d4 32c8 	ldr.w	r3, [r4, #712]	@ 0x2c8
3400121a:	4833      	ldr	r0, [pc, #204]	@ (340012e8 <evision_api_awb_init_profiles+0x394>)
3400121c:	4798      	blx	r3
3400121e:	ed98 7a00 	vldr	s14, [r8]
34001222:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001226:	ed8d 7b04 	vstr	d7, [sp, #16]
3400122a:	ed9a 7a00 	vldr	s14, [sl]
3400122e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001232:	ed8d 7b02 	vstr	d7, [sp, #8]
34001236:	ed99 7a00 	vldr	s14, [r9]
3400123a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
3400123e:	463b      	mov	r3, r7
34001240:	ed8d 7b00 	vstr	d7, [sp]
34001244:	f44f 7180 	mov.w	r1, #256	@ 0x100
34001248:	4a28      	ldr	r2, [pc, #160]	@ (340012ec <evision_api_awb_init_profiles+0x398>)
3400124a:	a806      	add	r0, sp, #24
3400124c:	f025 fe3e 	bl	34026ecc <sniprintf>
34001250:	e753      	b.n	340010fa <evision_api_awb_init_profiles+0x1a6>
34001252:	eb02 0783 	add.w	r7, r2, r3, lsl #2
34001256:	683f      	ldr	r7, [r7, #0]
34001258:	eb04 0383 	add.w	r3, r4, r3, lsl #2
3400125c:	f8c3 7110 	str.w	r7, [r3, #272]	@ 0x110
34001260:	e766      	b.n	34001130 <evision_api_awb_init_profiles+0x1dc>
34001262:	f8d4 3274 	ldr.w	r3, [r4, #628]	@ 0x274
34001266:	ed91 6a00 	vldr	s12, [r1]
3400126a:	ed93 7a00 	vldr	s14, [r3]
3400126e:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
34001272:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34001276:	ee36 6b4a 	vsub.f64	d6, d6, d10
3400127a:	ee37 7b4a 	vsub.f64	d7, d7, d10
3400127e:	eeb4 6bc7 	vcmpe.f64	d6, d7
34001282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001286:	bf48      	it	mi
34001288:	f8c4 1274 	strmi.w	r1, [r4, #628]	@ 0x274
3400128c:	3144      	adds	r1, #68	@ 0x44
3400128e:	e77b      	b.n	34001188 <evision_api_awb_init_profiles+0x234>
34001290:	f04f 30ff 	mov.w	r0, #4294967295
34001294:	b047      	add	sp, #284	@ 0x11c
34001296:	ecbd 8b06 	vpop	{d8-d10}
3400129a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3400129e:	bf00      	nop
340012a0:	00000000 	.word	0x00000000
340012a4:	40b38800 	.word	0x40b38800
340012a8:	9999999a 	.word	0x9999999a
340012ac:	3fb99999 	.word	0x3fb99999
340012b0:	00000000 	.word	0x00000000
340012b4:	406ea000 	.word	0x406ea000
340012b8:	3ff00000 	.word	0x3ff00000
340012bc:	42480000 	.word	0x42480000
340012c0:	432f0000 	.word	0x432f0000
340012c4:	3403df50 	.word	0x3403df50
340012c8:	3403df94 	.word	0x3403df94
340012cc:	3403e01b 	.word	0x3403e01b
340012d0:	3403e079 	.word	0x3403e079
340012d4:	3403e101 	.word	0x3403e101
340012d8:	3403e15e 	.word	0x3403e15e
340012dc:	3403e1c2 	.word	0x3403e1c2
340012e0:	3403e21a 	.word	0x3403e21a
340012e4:	3403e289 	.word	0x3403e289
340012e8:	3403e2f3 	.word	0x3403e2f3
340012ec:	3403e34a 	.word	0x3403e34a
340012f0:	bff00000 	.word	0xbff00000
340012f4:	40080000 	.word	0x40080000
340012f8:	40240000 	.word	0x40240000

340012fc <evision_api_awb_run_average>:
340012fc:	b530      	push	{r4, r5, lr}
340012fe:	4605      	mov	r5, r0
34001300:	4614      	mov	r4, r2
34001302:	b08d      	sub	sp, #52	@ 0x34
34001304:	b952      	cbnz	r2, 3400131c <evision_api_awb_run_average+0x20>
34001306:	f8d0 32c8 	ldr.w	r3, [r0, #712]	@ 0x2c8
3400130a:	481d      	ldr	r0, [pc, #116]	@ (34001380 <evision_api_awb_run_average+0x84>)
3400130c:	4798      	blx	r3
3400130e:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
34001312:	481c      	ldr	r0, [pc, #112]	@ (34001384 <evision_api_awb_run_average+0x88>)
34001314:	4798      	blx	r3
34001316:	4620      	mov	r0, r4
34001318:	b00d      	add	sp, #52	@ 0x34
3400131a:	bd30      	pop	{r4, r5, pc}
3400131c:	ed93 2b04 	vldr	d2, [r3, #16]
34001320:	ed93 1b02 	vldr	d1, [r3, #8]
34001324:	ed93 0b00 	vldr	d0, [r3]
34001328:	aa0a      	add	r2, sp, #40	@ 0x28
3400132a:	a908      	add	r1, sp, #32
3400132c:	a806      	add	r0, sp, #24
3400132e:	f000 f82f 	bl	34001390 <LOXtOTiCQC>
34001332:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
34001336:	e9cd 2302 	strd	r2, r3, [sp, #8]
3400133a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	@ 0x28
3400133e:	e9cd 2304 	strd	r2, r3, [sp, #16]
34001342:	2301      	movs	r3, #1
34001344:	4298      	cmp	r0, r3
34001346:	4604      	mov	r4, r0
34001348:	e9cd 3300 	strd	r3, r3, [sp]
3400134c:	d1df      	bne.n	3400130e <evision_api_awb_run_average+0x12>
3400134e:	4669      	mov	r1, sp
34001350:	4628      	mov	r0, r5
34001352:	f7ff fb4d 	bl	340009f0 <vsvAKZpqpB>
34001356:	2801      	cmp	r0, #1
34001358:	4604      	mov	r4, r0
3400135a:	d003      	beq.n	34001364 <evision_api_awb_run_average+0x68>
3400135c:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
34001360:	4809      	ldr	r0, [pc, #36]	@ (34001388 <evision_api_awb_run_average+0x8c>)
34001362:	e7d7      	b.n	34001314 <evision_api_awb_run_average+0x18>
34001364:	f895 3060 	ldrb.w	r3, [r5, #96]	@ 0x60
34001368:	2b01      	cmp	r3, #1
3400136a:	d1d4      	bne.n	34001316 <evision_api_awb_run_average+0x1a>
3400136c:	4628      	mov	r0, r5
3400136e:	f7ff fd23 	bl	34000db8 <JxZhqVLLqu>
34001372:	2801      	cmp	r0, #1
34001374:	4604      	mov	r4, r0
34001376:	d0ce      	beq.n	34001316 <evision_api_awb_run_average+0x1a>
34001378:	f8d5 32c8 	ldr.w	r3, [r5, #712]	@ 0x2c8
3400137c:	4803      	ldr	r0, [pc, #12]	@ (3400138c <evision_api_awb_run_average+0x90>)
3400137e:	e7c9      	b.n	34001314 <evision_api_awb_run_average+0x18>
34001380:	3403e3d0 	.word	0x3403e3d0
34001384:	3403e431 	.word	0x3403e431
34001388:	3403e45a 	.word	0x3403e45a
3400138c:	3403e48e 	.word	0x3403e48e

34001390 <LOXtOTiCQC>:
34001390:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
34001394:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001398:	b51f      	push	{r0, r1, r2, r3, r4, lr}
3400139a:	d409      	bmi.n	340013b0 <LOXtOTiCQC+0x20>
3400139c:	eeb5 1bc0 	vcmpe.f64	d1, #0.0
340013a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013a4:	d404      	bmi.n	340013b0 <LOXtOTiCQC+0x20>
340013a6:	eeb5 2bc0 	vcmpe.f64	d2, #0.0
340013aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013ae:	d50d      	bpl.n	340013cc <LOXtOTiCQC+0x3c>
340013b0:	ed8d 2b02 	vstr	d2, [sp, #8]
340013b4:	ed8d 1b00 	vstr	d1, [sp]
340013b8:	ec53 2b10 	vmov	r2, r3, d0
340013bc:	4844      	ldr	r0, [pc, #272]	@ (340014d0 <LOXtOTiCQC+0x140>)
340013be:	f025 fc61 	bl	34026c84 <iprintf>
340013c2:	f04f 30ff 	mov.w	r0, #4294967295
340013c6:	b005      	add	sp, #20
340013c8:	f85d fb04 	ldr.w	pc, [sp], #4
340013cc:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34001498 <LOXtOTiCQC+0x108>
340013d0:	eeb4 0bc7 	vcmpe.f64	d0, d7
340013d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013d8:	dc09      	bgt.n	340013ee <LOXtOTiCQC+0x5e>
340013da:	eeb4 1bc7 	vcmpe.f64	d1, d7
340013de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013e2:	dc04      	bgt.n	340013ee <LOXtOTiCQC+0x5e>
340013e4:	eeb4 2bc7 	vcmpe.f64	d2, d7
340013e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340013ec:	dd07      	ble.n	340013fe <LOXtOTiCQC+0x6e>
340013ee:	ed8d 2b02 	vstr	d2, [sp, #8]
340013f2:	ed8d 1b00 	vstr	d1, [sp]
340013f6:	ec53 2b10 	vmov	r2, r3, d0
340013fa:	4836      	ldr	r0, [pc, #216]	@ (340014d4 <LOXtOTiCQC+0x144>)
340013fc:	e7df      	b.n	340013be <LOXtOTiCQC+0x2e>
340013fe:	b128      	cbz	r0, 3400140c <LOXtOTiCQC+0x7c>
34001400:	b189      	cbz	r1, 34001426 <LOXtOTiCQC+0x96>
34001402:	b9b2      	cbnz	r2, 34001432 <LOXtOTiCQC+0xa2>
34001404:	4934      	ldr	r1, [pc, #208]	@ (340014d8 <LOXtOTiCQC+0x148>)
34001406:	4b35      	ldr	r3, [pc, #212]	@ (340014dc <LOXtOTiCQC+0x14c>)
34001408:	4608      	mov	r0, r1
3400140a:	e007      	b.n	3400141c <LOXtOTiCQC+0x8c>
3400140c:	b171      	cbz	r1, 3400142c <LOXtOTiCQC+0x9c>
3400140e:	4933      	ldr	r1, [pc, #204]	@ (340014dc <LOXtOTiCQC+0x14c>)
34001410:	4831      	ldr	r0, [pc, #196]	@ (340014d8 <LOXtOTiCQC+0x148>)
34001412:	2a00      	cmp	r2, #0
34001414:	4a30      	ldr	r2, [pc, #192]	@ (340014d8 <LOXtOTiCQC+0x148>)
34001416:	4b31      	ldr	r3, [pc, #196]	@ (340014dc <LOXtOTiCQC+0x14c>)
34001418:	bf18      	it	ne
3400141a:	4613      	movne	r3, r2
3400141c:	4602      	mov	r2, r0
3400141e:	4830      	ldr	r0, [pc, #192]	@ (340014e0 <LOXtOTiCQC+0x150>)
34001420:	f025 fc30 	bl	34026c84 <iprintf>
34001424:	e7cd      	b.n	340013c2 <LOXtOTiCQC+0x32>
34001426:	492c      	ldr	r1, [pc, #176]	@ (340014d8 <LOXtOTiCQC+0x148>)
34001428:	482c      	ldr	r0, [pc, #176]	@ (340014dc <LOXtOTiCQC+0x14c>)
3400142a:	e7f2      	b.n	34001412 <LOXtOTiCQC+0x82>
3400142c:	492b      	ldr	r1, [pc, #172]	@ (340014dc <LOXtOTiCQC+0x14c>)
3400142e:	4608      	mov	r0, r1
34001430:	e7ef      	b.n	34001412 <LOXtOTiCQC+0x82>
34001432:	ed9f 7b1b 	vldr	d7, [pc, #108]	@ 340014a0 <LOXtOTiCQC+0x110>
34001436:	ed9f 6b1c 	vldr	d6, [pc, #112]	@ 340014a8 <LOXtOTiCQC+0x118>
3400143a:	ee21 7b07 	vmul.f64	d7, d1, d7
3400143e:	eeb3 5b00 	vmov.f64	d5, #48	@ 0x41800000  16.0
34001442:	eea0 7b06 	vfma.f64	d7, d0, d6
34001446:	ed9f 6b1a 	vldr	d6, [pc, #104]	@ 340014b0 <LOXtOTiCQC+0x120>
3400144a:	eea2 7b05 	vfma.f64	d7, d2, d5
3400144e:	eea7 5b06 	vfma.f64	d5, d7, d6
34001452:	ed9f 7b19 	vldr	d7, [pc, #100]	@ 340014b8 <LOXtOTiCQC+0x128>
34001456:	ed80 5b00 	vstr	d5, [r0]
3400145a:	ee27 7b41 	vnmul.f64	d7, d7, d1
3400145e:	eebb 5b0a 	vmov.f64	d5, #186	@ 0xc1d00000 -26.0
34001462:	eea0 7b05 	vfma.f64	d7, d0, d5
34001466:	ed9f 5b16 	vldr	d5, [pc, #88]	@ 340014c0 <LOXtOTiCQC+0x130>
3400146a:	eea2 7b05 	vfma.f64	d7, d2, d5
3400146e:	ee27 7b06 	vmul.f64	d7, d7, d6
34001472:	ed81 7b00 	vstr	d7, [r1]
34001476:	ed9f 7b14 	vldr	d7, [pc, #80]	@ 340014c8 <LOXtOTiCQC+0x138>
3400147a:	ee27 1b41 	vnmul.f64	d1, d7, d1
3400147e:	eeb2 7b04 	vmov.f64	d7, #36	@ 0x41200000  10.0
34001482:	eea0 1b05 	vfma.f64	d1, d0, d5
34001486:	eea2 1b47 	vfms.f64	d1, d2, d7
3400148a:	ee21 1b06 	vmul.f64	d1, d1, d6
3400148e:	2001      	movs	r0, #1
34001490:	ed82 1b00 	vstr	d1, [r2]
34001494:	e797      	b.n	340013c6 <LOXtOTiCQC+0x36>
34001496:	bf00      	nop
34001498:	00000000 	.word	0x00000000
3400149c:	406fe000 	.word	0x406fe000
340014a0:	00000000 	.word	0x00000000
340014a4:	4063a000 	.word	0x4063a000
340014a8:	00000000 	.word	0x00000000
340014ac:	40478000 	.word	0x40478000
340014b0:	00000000 	.word	0x00000000
340014b4:	3f700000 	.word	0x3f700000
340014b8:	00000000 	.word	0x00000000
340014bc:	40558000 	.word	0x40558000
340014c0:	00000000 	.word	0x00000000
340014c4:	405c0000 	.word	0x405c0000
340014c8:	00000000 	.word	0x00000000
340014cc:	40598000 	.word	0x40598000
340014d0:	3403e4cb 	.word	0x3403e4cb
340014d4:	3403e509 	.word	0x3403e509
340014d8:	3403e4c5 	.word	0x3403e4c5
340014dc:	3403e4c3 	.word	0x3403e4c3
340014e0:	3403e549 	.word	0x3403e549
340014e4:	00000000 	.word	0x00000000

340014e8 <evision_api_st_ae_new>:
340014e8:	b510      	push	{r4, lr}
340014ea:	4604      	mov	r4, r0
340014ec:	b090      	sub	sp, #64	@ 0x40
340014ee:	b160      	cbz	r0, 3400150a <evision_api_st_ae_new+0x22>
340014f0:	2300      	movs	r3, #0
340014f2:	4c07      	ldr	r4, [pc, #28]	@ (34001510 <evision_api_st_ae_new+0x28>)
340014f4:	2140      	movs	r1, #64	@ 0x40
340014f6:	7023      	strb	r3, [r4, #0]
340014f8:	65a0      	str	r0, [r4, #88]	@ 0x58
340014fa:	4b06      	ldr	r3, [pc, #24]	@ (34001514 <evision_api_st_ae_new+0x2c>)
340014fc:	4668      	mov	r0, sp
340014fe:	4a06      	ldr	r2, [pc, #24]	@ (34001518 <evision_api_st_ae_new+0x30>)
34001500:	f025 fce4 	bl	34026ecc <sniprintf>
34001504:	4668      	mov	r0, sp
34001506:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34001508:	4798      	blx	r3
3400150a:	4620      	mov	r0, r4
3400150c:	b010      	add	sp, #64	@ 0x40
3400150e:	bd10      	pop	{r4, pc}
34001510:	34041970 	.word	0x34041970
34001514:	3404136e 	.word	0x3404136e
34001518:	3403e593 	.word	0x3403e593

3400151c <evision_api_st_ae_delete>:
3400151c:	2800      	cmp	r0, #0
3400151e:	bf14      	ite	ne
34001520:	2001      	movne	r0, #1
34001522:	f04f 30ff 	moveq.w	r0, #4294967295
34001526:	4770      	bx	lr

34001528 <AagifFaCgc>:
34001528:	2238      	movs	r2, #56	@ 0x38
3400152a:	230a      	movs	r3, #10
3400152c:	e9c0 2304 	strd	r2, r3, [r0, #16]
34001530:	2364      	movs	r3, #100	@ 0x64
34001532:	222d      	movs	r2, #45	@ 0x2d
34001534:	2178      	movs	r1, #120	@ 0x78
34001536:	e9c0 3206 	strd	r3, r2, [r0, #24]
3400153a:	f240 52dc 	movw	r2, #1500	@ 0x5dc
3400153e:	b530      	push	{r4, r5, lr}
34001540:	e9c0 1208 	strd	r1, r2, [r0, #32]
34001544:	f241 7470 	movw	r4, #6000	@ 0x1770
34001548:	f642 62e0 	movw	r2, #12000	@ 0x2ee0
3400154c:	e9c0 420a 	strd	r4, r2, [r0, #40]	@ 0x28
34001550:	a50b      	add	r5, pc, #44	@ (adr r5, 34001580 <AagifFaCgc+0x58>)
34001552:	e9d5 4500 	ldrd	r4, r5, [r5]
34001556:	2205      	movs	r2, #5
34001558:	f04f 0c00 	mov.w	ip, #0
3400155c:	6502      	str	r2, [r0, #80]	@ 0x50
3400155e:	f248 02e8 	movw	r2, #33000	@ 0x80e8
34001562:	e9c0 c210 	strd	ip, r2, [r0, #64]	@ 0x40
34001566:	2201      	movs	r2, #1
34001568:	e9c0 450c 	strd	r4, r5, [r0, #48]	@ 0x30
3400156c:	a506      	add	r5, pc, #24	@ (adr r5, 34001588 <AagifFaCgc+0x60>)
3400156e:	e9d5 4500 	ldrd	r4, r5, [r5]
34001572:	e9c0 2312 	strd	r2, r3, [r0, #72]	@ 0x48
34001576:	e9c0 450e 	strd	r4, r5, [r0, #56]	@ 0x38
3400157a:	bd30      	pop	{r4, r5, pc}
3400157c:	f3af 8000 	nop.w
34001580:	40000000 	.word	0x40000000
34001584:	3f947ae1 	.word	0x3f947ae1
34001588:	e0000000 	.word	0xe0000000
3400158c:	3f70624d 	.word	0x3f70624d

34001590 <evision_api_st_ae_init>:
34001590:	b510      	push	{r4, lr}
34001592:	4604      	mov	r4, r0
34001594:	b120      	cbz	r0, 340015a0 <evision_api_st_ae_init+0x10>
34001596:	f7ff ffc7 	bl	34001528 <AagifFaCgc>
3400159a:	2001      	movs	r0, #1
3400159c:	7020      	strb	r0, [r4, #0]
3400159e:	bd10      	pop	{r4, pc}
340015a0:	f04f 30ff 	mov.w	r0, #4294967295
340015a4:	e7fb      	b.n	3400159e <evision_api_st_ae_init+0xe>

340015a6 <evision_api_st_ae_process>:
340015a6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
340015aa:	460e      	mov	r6, r1
340015ac:	4604      	mov	r4, r0
340015ae:	2800      	cmp	r0, #0
340015b0:	f000 80e1 	beq.w	34001776 <evision_api_st_ae_process+0x1d0>
340015b4:	7801      	ldrb	r1, [r0, #0]
340015b6:	2901      	cmp	r1, #1
340015b8:	d10b      	bne.n	340015d2 <evision_api_st_ae_process+0x2c>
340015ba:	2102      	movs	r1, #2
340015bc:	7001      	strb	r1, [r0, #0]
340015be:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
340015c0:	e9c4 2601 	strd	r2, r6, [r4, #4]
340015c4:	42b5      	cmp	r5, r6
340015c6:	d208      	bcs.n	340015da <evision_api_st_ae_process+0x34>
340015c8:	6c61      	ldr	r1, [r4, #68]	@ 0x44
340015ca:	4291      	cmp	r1, r2
340015cc:	d905      	bls.n	340015da <evision_api_st_ae_process+0x34>
340015ce:	60a5      	str	r5, [r4, #8]
340015d0:	e04c      	b.n	3400166c <evision_api_st_ae_process+0xc6>
340015d2:	2902      	cmp	r1, #2
340015d4:	d0f3      	beq.n	340015be <evision_api_st_ae_process+0x18>
340015d6:	2000      	movs	r0, #0
340015d8:	e049      	b.n	3400166e <evision_api_st_ae_process+0xc8>
340015da:	f8d4 c010 	ldr.w	ip, [r4, #16]
340015de:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
340015e2:	ee07 ca90 	vmov	s15, ip
340015e6:	eeb8 6a67 	vcvt.f32.u32	s12, s15
340015ea:	ee07 3a90 	vmov	s15, r3
340015ee:	eeb8 7be7 	vcvt.f64.s32	d7, s15
340015f2:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
340015f6:	ee37 7b05 	vadd.f64	d7, d7, d5
340015fa:	ee86 0b07 	vdiv.f64	d0, d6, d7
340015fe:	6d21      	ldr	r1, [r4, #80]	@ 0x50
34001600:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34001604:	428b      	cmp	r3, r1
34001606:	d24b      	bcs.n	340016a0 <evision_api_st_ae_process+0xfa>
34001608:	eef0 7a00 	vmov.f32	s15, #0	@ 0x40000000  2.0
3400160c:	eeb4 0ae7 	vcmpe.f32	s0, s15
34001610:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34001614:	d444      	bmi.n	340016a0 <evision_api_st_ae_process+0xfa>
34001616:	6c61      	ldr	r1, [r4, #68]	@ 0x44
34001618:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3400161c:	428a      	cmp	r2, r1
3400161e:	d220      	bcs.n	34001662 <evision_api_st_ae_process+0xbc>
34001620:	2a01      	cmp	r2, #1
34001622:	4613      	mov	r3, r2
34001624:	bf38      	it	cc
34001626:	2301      	movcc	r3, #1
34001628:	ee07 3a90 	vmov	s15, r3
3400162c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34001630:	ee67 7a80 	vmul.f32	s15, s15, s0
34001634:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34001638:	ee17 3a90 	vmov	r3, s15
3400163c:	428b      	cmp	r3, r1
3400163e:	bfc1      	itttt	gt
34001640:	ee07 1a90 	vmovgt	s15, r1
34001644:	eeb8 6ae7 	vcvtgt.f32.s32	s12, s15
34001648:	ee07 2a90 	vmovgt	s15, r2
3400164c:	eef8 6a67 	vcvtgt.f32.u32	s13, s15
34001650:	bfc3      	ittte	gt
34001652:	eec6 7a26 	vdivgt.f32	s15, s12, s13
34001656:	460b      	movgt	r3, r1
34001658:	ee80 0a27 	vdivgt.f32	s0, s0, s15
3400165c:	eeb0 0a47 	vmovle.f32	s0, s14
34001660:	6063      	str	r3, [r4, #4]
34001662:	eeb4 0ac7 	vcmpe.f32	s0, s14
34001666:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3400166a:	dc02      	bgt.n	34001672 <evision_api_st_ae_process+0xcc>
3400166c:	2001      	movs	r0, #1
3400166e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34001672:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
34001676:	f027 fe33 	bl	340292e0 <log10>
3400167a:	eeb3 7b04 	vmov.f64	d7, #52	@ 0x41a00000  20.0
3400167e:	ee20 0b07 	vmul.f64	d0, d0, d7
34001682:	ed9f 7b3f 	vldr	d7, [pc, #252]	@ 34001780 <evision_api_st_ae_process+0x1da>
34001686:	ee20 0b07 	vmul.f64	d0, d0, d7
3400168a:	eebd 0bc0 	vcvt.s32.f64	s0, d0
3400168e:	ee10 3a10 	vmov	r3, s0
34001692:	6ce2      	ldr	r2, [r4, #76]	@ 0x4c
34001694:	4433      	add	r3, r6
34001696:	4293      	cmp	r3, r2
34001698:	bfd4      	ite	le
3400169a:	60a3      	strle	r3, [r4, #8]
3400169c:	60a2      	strgt	r2, [r4, #8]
3400169e:	e7e5      	b.n	3400166c <evision_api_st_ae_process+0xc6>
340016a0:	ebac 0703 	sub.w	r7, ip, r3
340016a4:	69e1      	ldr	r1, [r4, #28]
340016a6:	ea87 70e7 	eor.w	r0, r7, r7, asr #31
340016aa:	eba0 70e7 	sub.w	r0, r0, r7, asr #31
340016ae:	4288      	cmp	r0, r1
340016b0:	d847      	bhi.n	34001742 <evision_api_st_ae_process+0x19c>
340016b2:	6a60      	ldr	r0, [r4, #36]	@ 0x24
340016b4:	f8d4 e014 	ldr.w	lr, [r4, #20]
340016b8:	69a1      	ldr	r1, [r4, #24]
340016ba:	eb0e 080c 	add.w	r8, lr, ip
340016be:	4598      	cmp	r8, r3
340016c0:	fb07 f101 	mul.w	r1, r7, r1
340016c4:	d243      	bcs.n	3400174e <evision_api_st_ae_process+0x1a8>
340016c6:	ee07 0a90 	vmov	s15, r0
340016ca:	ed9f 7a2f 	vldr	s14, [pc, #188]	@ 34001788 <evision_api_st_ae_process+0x1e2>
340016ce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
340016d2:	ee67 7a87 	vmul.f32	s15, s15, s14
340016d6:	ee07 1a10 	vmov	s14, r1
340016da:	eef1 6a67 	vneg.f32	s13, s15
340016de:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
340016e2:	eeb4 7ae6 	vcmpe.f32	s14, s13
340016e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340016ea:	d504      	bpl.n	340016f6 <evision_api_st_ae_process+0x150>
340016ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340016f0:	ee17 3a90 	vmov	r3, s15
340016f4:	4259      	negs	r1, r3
340016f6:	2900      	cmp	r1, #0
340016f8:	d0b8      	beq.n	3400166c <evision_api_st_ae_process+0xc6>
340016fa:	42b5      	cmp	r5, r6
340016fc:	d132      	bne.n	34001764 <evision_api_st_ae_process+0x1be>
340016fe:	6c60      	ldr	r0, [r4, #68]	@ 0x44
34001700:	4290      	cmp	r0, r2
34001702:	d801      	bhi.n	34001708 <evision_api_st_ae_process+0x162>
34001704:	2900      	cmp	r1, #0
34001706:	da2d      	bge.n	34001764 <evision_api_st_ae_process+0x1be>
34001708:	fb02 7707 	mla	r7, r2, r7, r7
3400170c:	ee07 2a90 	vmov	s15, r2
34001710:	ee06 7a90 	vmov	s13, r7
34001714:	2900      	cmp	r1, #0
34001716:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3400171a:	eeb8 6be6 	vcvt.f64.s32	d6, s13
3400171e:	da1e      	bge.n	3400175e <evision_api_st_ae_process+0x1b8>
34001720:	ed94 5b0e 	vldr	d5, [r4, #56]	@ 0x38
34001724:	eea5 7b06 	vfma.f64	d7, d5, d6
34001728:	eebd 7bc7 	vcvt.s32.f64	s14, d7
3400172c:	ee17 2a10 	vmov	r2, s14
34001730:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34001732:	429a      	cmp	r2, r3
34001734:	bfb8      	it	lt
34001736:	461a      	movlt	r2, r3
34001738:	4282      	cmp	r2, r0
3400173a:	bfd4      	ite	le
3400173c:	6062      	strle	r2, [r4, #4]
3400173e:	6060      	strgt	r0, [r4, #4]
34001740:	e794      	b.n	3400166c <evision_api_st_ae_process+0xc6>
34001742:	6a21      	ldr	r1, [r4, #32]
34001744:	4288      	cmp	r0, r1
34001746:	bf2c      	ite	cs
34001748:	6ae0      	ldrcs	r0, [r4, #44]	@ 0x2c
3400174a:	6aa0      	ldrcc	r0, [r4, #40]	@ 0x28
3400174c:	e7b2      	b.n	340016b4 <evision_api_st_ae_process+0x10e>
3400174e:	ebac 0c0e 	sub.w	ip, ip, lr
34001752:	459c      	cmp	ip, r3
34001754:	dd8a      	ble.n	3400166c <evision_api_st_ae_process+0xc6>
34001756:	4281      	cmp	r1, r0
34001758:	bfa8      	it	ge
3400175a:	4601      	movge	r1, r0
3400175c:	e7cb      	b.n	340016f6 <evision_api_st_ae_process+0x150>
3400175e:	ed94 5b0c 	vldr	d5, [r4, #48]	@ 0x30
34001762:	e7df      	b.n	34001724 <evision_api_st_ae_process+0x17e>
34001764:	440e      	add	r6, r1
34001766:	42b5      	cmp	r5, r6
34001768:	f73f af31 	bgt.w	340015ce <evision_api_st_ae_process+0x28>
3400176c:	6ce5      	ldr	r5, [r4, #76]	@ 0x4c
3400176e:	42b5      	cmp	r5, r6
34001770:	bfa8      	it	ge
34001772:	4635      	movge	r5, r6
34001774:	e72b      	b.n	340015ce <evision_api_st_ae_process+0x28>
34001776:	f04f 30ff 	mov.w	r0, #4294967295
3400177a:	e778      	b.n	3400166e <evision_api_st_ae_process+0xc8>
3400177c:	f3af 8000 	nop.w
34001780:	00000000 	.word	0x00000000
34001784:	408f4000 	.word	0x408f4000
34001788:	3f59999a 	.word	0x3f59999a

3400178c <strlen>:
3400178c:	4603      	mov	r3, r0
3400178e:	f813 2b01 	ldrb.w	r2, [r3], #1
34001792:	2a00      	cmp	r2, #0
34001794:	d1fb      	bne.n	3400178e <strlen+0x2>
34001796:	1a18      	subs	r0, r3, r0
34001798:	3801      	subs	r0, #1
3400179a:	4770      	bx	lr

3400179c <__aeabi_drsub>:
3400179c:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
340017a0:	e002      	b.n	340017a8 <__adddf3>
340017a2:	bf00      	nop

340017a4 <__aeabi_dsub>:
340017a4:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

340017a8 <__adddf3>:
340017a8:	b530      	push	{r4, r5, lr}
340017aa:	ea4f 0441 	mov.w	r4, r1, lsl #1
340017ae:	ea4f 0543 	mov.w	r5, r3, lsl #1
340017b2:	ea94 0f05 	teq	r4, r5
340017b6:	bf08      	it	eq
340017b8:	ea90 0f02 	teqeq	r0, r2
340017bc:	bf1f      	itttt	ne
340017be:	ea54 0c00 	orrsne.w	ip, r4, r0
340017c2:	ea55 0c02 	orrsne.w	ip, r5, r2
340017c6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
340017ca:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
340017ce:	f000 80e2 	beq.w	34001996 <__adddf3+0x1ee>
340017d2:	ea4f 5454 	mov.w	r4, r4, lsr #21
340017d6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
340017da:	bfb8      	it	lt
340017dc:	426d      	neglt	r5, r5
340017de:	dd0c      	ble.n	340017fa <__adddf3+0x52>
340017e0:	442c      	add	r4, r5
340017e2:	ea80 0202 	eor.w	r2, r0, r2
340017e6:	ea81 0303 	eor.w	r3, r1, r3
340017ea:	ea82 0000 	eor.w	r0, r2, r0
340017ee:	ea83 0101 	eor.w	r1, r3, r1
340017f2:	ea80 0202 	eor.w	r2, r0, r2
340017f6:	ea81 0303 	eor.w	r3, r1, r3
340017fa:	2d36      	cmp	r5, #54	@ 0x36
340017fc:	bf88      	it	hi
340017fe:	bd30      	pophi	{r4, r5, pc}
34001800:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
34001804:	ea4f 3101 	mov.w	r1, r1, lsl #12
34001808:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
3400180c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
34001810:	d002      	beq.n	34001818 <__adddf3+0x70>
34001812:	4240      	negs	r0, r0
34001814:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001818:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
3400181c:	ea4f 3303 	mov.w	r3, r3, lsl #12
34001820:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
34001824:	d002      	beq.n	3400182c <__adddf3+0x84>
34001826:	4252      	negs	r2, r2
34001828:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
3400182c:	ea94 0f05 	teq	r4, r5
34001830:	f000 80a7 	beq.w	34001982 <__adddf3+0x1da>
34001834:	f1a4 0401 	sub.w	r4, r4, #1
34001838:	f1d5 0e20 	rsbs	lr, r5, #32
3400183c:	db0d      	blt.n	3400185a <__adddf3+0xb2>
3400183e:	fa02 fc0e 	lsl.w	ip, r2, lr
34001842:	fa22 f205 	lsr.w	r2, r2, r5
34001846:	1880      	adds	r0, r0, r2
34001848:	f141 0100 	adc.w	r1, r1, #0
3400184c:	fa03 f20e 	lsl.w	r2, r3, lr
34001850:	1880      	adds	r0, r0, r2
34001852:	fa43 f305 	asr.w	r3, r3, r5
34001856:	4159      	adcs	r1, r3
34001858:	e00e      	b.n	34001878 <__adddf3+0xd0>
3400185a:	f1a5 0520 	sub.w	r5, r5, #32
3400185e:	f10e 0e20 	add.w	lr, lr, #32
34001862:	2a01      	cmp	r2, #1
34001864:	fa03 fc0e 	lsl.w	ip, r3, lr
34001868:	bf28      	it	cs
3400186a:	f04c 0c02 	orrcs.w	ip, ip, #2
3400186e:	fa43 f305 	asr.w	r3, r3, r5
34001872:	18c0      	adds	r0, r0, r3
34001874:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
34001878:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
3400187c:	d507      	bpl.n	3400188e <__adddf3+0xe6>
3400187e:	f04f 0e00 	mov.w	lr, #0
34001882:	f1dc 0c00 	rsbs	ip, ip, #0
34001886:	eb7e 0000 	sbcs.w	r0, lr, r0
3400188a:	eb6e 0101 	sbc.w	r1, lr, r1
3400188e:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
34001892:	d31b      	bcc.n	340018cc <__adddf3+0x124>
34001894:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
34001898:	d30c      	bcc.n	340018b4 <__adddf3+0x10c>
3400189a:	0849      	lsrs	r1, r1, #1
3400189c:	ea5f 0030 	movs.w	r0, r0, rrx
340018a0:	ea4f 0c3c 	mov.w	ip, ip, rrx
340018a4:	f104 0401 	add.w	r4, r4, #1
340018a8:	ea4f 5244 	mov.w	r2, r4, lsl #21
340018ac:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
340018b0:	f080 809a 	bcs.w	340019e8 <__adddf3+0x240>
340018b4:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
340018b8:	bf08      	it	eq
340018ba:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
340018be:	f150 0000 	adcs.w	r0, r0, #0
340018c2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
340018c6:	ea41 0105 	orr.w	r1, r1, r5
340018ca:	bd30      	pop	{r4, r5, pc}
340018cc:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
340018d0:	4140      	adcs	r0, r0
340018d2:	eb41 0101 	adc.w	r1, r1, r1
340018d6:	3c01      	subs	r4, #1
340018d8:	bf28      	it	cs
340018da:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
340018de:	d2e9      	bcs.n	340018b4 <__adddf3+0x10c>
340018e0:	f091 0f00 	teq	r1, #0
340018e4:	bf04      	itt	eq
340018e6:	4601      	moveq	r1, r0
340018e8:	2000      	moveq	r0, #0
340018ea:	fab1 f381 	clz	r3, r1
340018ee:	bf08      	it	eq
340018f0:	3320      	addeq	r3, #32
340018f2:	f1a3 030b 	sub.w	r3, r3, #11
340018f6:	f1b3 0220 	subs.w	r2, r3, #32
340018fa:	da0c      	bge.n	34001916 <__adddf3+0x16e>
340018fc:	320c      	adds	r2, #12
340018fe:	dd08      	ble.n	34001912 <__adddf3+0x16a>
34001900:	f102 0c14 	add.w	ip, r2, #20
34001904:	f1c2 020c 	rsb	r2, r2, #12
34001908:	fa01 f00c 	lsl.w	r0, r1, ip
3400190c:	fa21 f102 	lsr.w	r1, r1, r2
34001910:	e00c      	b.n	3400192c <__adddf3+0x184>
34001912:	f102 0214 	add.w	r2, r2, #20
34001916:	bfd8      	it	le
34001918:	f1c2 0c20 	rsble	ip, r2, #32
3400191c:	fa01 f102 	lsl.w	r1, r1, r2
34001920:	fa20 fc0c 	lsr.w	ip, r0, ip
34001924:	bfdc      	itt	le
34001926:	ea41 010c 	orrle.w	r1, r1, ip
3400192a:	4090      	lslle	r0, r2
3400192c:	1ae4      	subs	r4, r4, r3
3400192e:	bfa2      	ittt	ge
34001930:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
34001934:	4329      	orrge	r1, r5
34001936:	bd30      	popge	{r4, r5, pc}
34001938:	ea6f 0404 	mvn.w	r4, r4
3400193c:	3c1f      	subs	r4, #31
3400193e:	da1c      	bge.n	3400197a <__adddf3+0x1d2>
34001940:	340c      	adds	r4, #12
34001942:	dc0e      	bgt.n	34001962 <__adddf3+0x1ba>
34001944:	f104 0414 	add.w	r4, r4, #20
34001948:	f1c4 0220 	rsb	r2, r4, #32
3400194c:	fa20 f004 	lsr.w	r0, r0, r4
34001950:	fa01 f302 	lsl.w	r3, r1, r2
34001954:	ea40 0003 	orr.w	r0, r0, r3
34001958:	fa21 f304 	lsr.w	r3, r1, r4
3400195c:	ea45 0103 	orr.w	r1, r5, r3
34001960:	bd30      	pop	{r4, r5, pc}
34001962:	f1c4 040c 	rsb	r4, r4, #12
34001966:	f1c4 0220 	rsb	r2, r4, #32
3400196a:	fa20 f002 	lsr.w	r0, r0, r2
3400196e:	fa01 f304 	lsl.w	r3, r1, r4
34001972:	ea40 0003 	orr.w	r0, r0, r3
34001976:	4629      	mov	r1, r5
34001978:	bd30      	pop	{r4, r5, pc}
3400197a:	fa21 f004 	lsr.w	r0, r1, r4
3400197e:	4629      	mov	r1, r5
34001980:	bd30      	pop	{r4, r5, pc}
34001982:	f094 0f00 	teq	r4, #0
34001986:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
3400198a:	bf06      	itte	eq
3400198c:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
34001990:	3401      	addeq	r4, #1
34001992:	3d01      	subne	r5, #1
34001994:	e74e      	b.n	34001834 <__adddf3+0x8c>
34001996:	ea7f 5c64 	mvns.w	ip, r4, asr #21
3400199a:	bf18      	it	ne
3400199c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
340019a0:	d029      	beq.n	340019f6 <__adddf3+0x24e>
340019a2:	ea94 0f05 	teq	r4, r5
340019a6:	bf08      	it	eq
340019a8:	ea90 0f02 	teqeq	r0, r2
340019ac:	d005      	beq.n	340019ba <__adddf3+0x212>
340019ae:	ea54 0c00 	orrs.w	ip, r4, r0
340019b2:	bf04      	itt	eq
340019b4:	4619      	moveq	r1, r3
340019b6:	4610      	moveq	r0, r2
340019b8:	bd30      	pop	{r4, r5, pc}
340019ba:	ea91 0f03 	teq	r1, r3
340019be:	bf1e      	ittt	ne
340019c0:	2100      	movne	r1, #0
340019c2:	2000      	movne	r0, #0
340019c4:	bd30      	popne	{r4, r5, pc}
340019c6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
340019ca:	d105      	bne.n	340019d8 <__adddf3+0x230>
340019cc:	0040      	lsls	r0, r0, #1
340019ce:	4149      	adcs	r1, r1
340019d0:	bf28      	it	cs
340019d2:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
340019d6:	bd30      	pop	{r4, r5, pc}
340019d8:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
340019dc:	bf3c      	itt	cc
340019de:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
340019e2:	bd30      	popcc	{r4, r5, pc}
340019e4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
340019e8:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
340019ec:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
340019f0:	f04f 0000 	mov.w	r0, #0
340019f4:	bd30      	pop	{r4, r5, pc}
340019f6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
340019fa:	bf1a      	itte	ne
340019fc:	4619      	movne	r1, r3
340019fe:	4610      	movne	r0, r2
34001a00:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
34001a04:	bf1c      	itt	ne
34001a06:	460b      	movne	r3, r1
34001a08:	4602      	movne	r2, r0
34001a0a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
34001a0e:	bf06      	itte	eq
34001a10:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
34001a14:	ea91 0f03 	teqeq	r1, r3
34001a18:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
34001a1c:	bd30      	pop	{r4, r5, pc}
34001a1e:	bf00      	nop

34001a20 <__aeabi_ui2d>:
34001a20:	f090 0f00 	teq	r0, #0
34001a24:	bf04      	itt	eq
34001a26:	2100      	moveq	r1, #0
34001a28:	4770      	bxeq	lr
34001a2a:	b530      	push	{r4, r5, lr}
34001a2c:	f44f 6480 	mov.w	r4, #1024	@ 0x400
34001a30:	f104 0432 	add.w	r4, r4, #50	@ 0x32
34001a34:	f04f 0500 	mov.w	r5, #0
34001a38:	f04f 0100 	mov.w	r1, #0
34001a3c:	e750      	b.n	340018e0 <__adddf3+0x138>
34001a3e:	bf00      	nop

34001a40 <__aeabi_i2d>:
34001a40:	f090 0f00 	teq	r0, #0
34001a44:	bf04      	itt	eq
34001a46:	2100      	moveq	r1, #0
34001a48:	4770      	bxeq	lr
34001a4a:	b530      	push	{r4, r5, lr}
34001a4c:	f44f 6480 	mov.w	r4, #1024	@ 0x400
34001a50:	f104 0432 	add.w	r4, r4, #50	@ 0x32
34001a54:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
34001a58:	bf48      	it	mi
34001a5a:	4240      	negmi	r0, r0
34001a5c:	f04f 0100 	mov.w	r1, #0
34001a60:	e73e      	b.n	340018e0 <__adddf3+0x138>
34001a62:	bf00      	nop

34001a64 <__aeabi_f2d>:
34001a64:	0042      	lsls	r2, r0, #1
34001a66:	ea4f 01e2 	mov.w	r1, r2, asr #3
34001a6a:	ea4f 0131 	mov.w	r1, r1, rrx
34001a6e:	ea4f 7002 	mov.w	r0, r2, lsl #28
34001a72:	bf1f      	itttt	ne
34001a74:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
34001a78:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
34001a7c:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
34001a80:	4770      	bxne	lr
34001a82:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
34001a86:	bf08      	it	eq
34001a88:	4770      	bxeq	lr
34001a8a:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
34001a8e:	bf04      	itt	eq
34001a90:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
34001a94:	4770      	bxeq	lr
34001a96:	b530      	push	{r4, r5, lr}
34001a98:	f44f 7460 	mov.w	r4, #896	@ 0x380
34001a9c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
34001aa0:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
34001aa4:	e71c      	b.n	340018e0 <__adddf3+0x138>
34001aa6:	bf00      	nop

34001aa8 <__aeabi_ul2d>:
34001aa8:	ea50 0201 	orrs.w	r2, r0, r1
34001aac:	bf08      	it	eq
34001aae:	4770      	bxeq	lr
34001ab0:	b530      	push	{r4, r5, lr}
34001ab2:	f04f 0500 	mov.w	r5, #0
34001ab6:	e00a      	b.n	34001ace <__aeabi_l2d+0x16>

34001ab8 <__aeabi_l2d>:
34001ab8:	ea50 0201 	orrs.w	r2, r0, r1
34001abc:	bf08      	it	eq
34001abe:	4770      	bxeq	lr
34001ac0:	b530      	push	{r4, r5, lr}
34001ac2:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
34001ac6:	d502      	bpl.n	34001ace <__aeabi_l2d+0x16>
34001ac8:	4240      	negs	r0, r0
34001aca:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001ace:	f44f 6480 	mov.w	r4, #1024	@ 0x400
34001ad2:	f104 0432 	add.w	r4, r4, #50	@ 0x32
34001ad6:	ea5f 5c91 	movs.w	ip, r1, lsr #22
34001ada:	f43f aed8 	beq.w	3400188e <__adddf3+0xe6>
34001ade:	f04f 0203 	mov.w	r2, #3
34001ae2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
34001ae6:	bf18      	it	ne
34001ae8:	3203      	addne	r2, #3
34001aea:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
34001aee:	bf18      	it	ne
34001af0:	3203      	addne	r2, #3
34001af2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
34001af6:	f1c2 0320 	rsb	r3, r2, #32
34001afa:	fa00 fc03 	lsl.w	ip, r0, r3
34001afe:	fa20 f002 	lsr.w	r0, r0, r2
34001b02:	fa01 fe03 	lsl.w	lr, r1, r3
34001b06:	ea40 000e 	orr.w	r0, r0, lr
34001b0a:	fa21 f102 	lsr.w	r1, r1, r2
34001b0e:	4414      	add	r4, r2
34001b10:	e6bd      	b.n	3400188e <__adddf3+0xe6>
34001b12:	bf00      	nop

34001b14 <__aeabi_ldivmod>:
34001b14:	b97b      	cbnz	r3, 34001b36 <__aeabi_ldivmod+0x22>
34001b16:	b972      	cbnz	r2, 34001b36 <__aeabi_ldivmod+0x22>
34001b18:	2900      	cmp	r1, #0
34001b1a:	bfbe      	ittt	lt
34001b1c:	2000      	movlt	r0, #0
34001b1e:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
34001b22:	e006      	blt.n	34001b32 <__aeabi_ldivmod+0x1e>
34001b24:	bf08      	it	eq
34001b26:	2800      	cmpeq	r0, #0
34001b28:	bf1c      	itt	ne
34001b2a:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
34001b2e:	f04f 30ff 	movne.w	r0, #4294967295
34001b32:	f000 b9fb 	b.w	34001f2c <__aeabi_idiv0>
34001b36:	f1ad 0c08 	sub.w	ip, sp, #8
34001b3a:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001b3e:	2900      	cmp	r1, #0
34001b40:	db09      	blt.n	34001b56 <__aeabi_ldivmod+0x42>
34001b42:	2b00      	cmp	r3, #0
34001b44:	db1a      	blt.n	34001b7c <__aeabi_ldivmod+0x68>
34001b46:	f000 f84d 	bl	34001be4 <__udivmoddi4>
34001b4a:	f8dd e004 	ldr.w	lr, [sp, #4]
34001b4e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001b52:	b004      	add	sp, #16
34001b54:	4770      	bx	lr
34001b56:	4240      	negs	r0, r0
34001b58:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001b5c:	2b00      	cmp	r3, #0
34001b5e:	db1b      	blt.n	34001b98 <__aeabi_ldivmod+0x84>
34001b60:	f000 f840 	bl	34001be4 <__udivmoddi4>
34001b64:	f8dd e004 	ldr.w	lr, [sp, #4]
34001b68:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001b6c:	b004      	add	sp, #16
34001b6e:	4240      	negs	r0, r0
34001b70:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001b74:	4252      	negs	r2, r2
34001b76:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
34001b7a:	4770      	bx	lr
34001b7c:	4252      	negs	r2, r2
34001b7e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
34001b82:	f000 f82f 	bl	34001be4 <__udivmoddi4>
34001b86:	f8dd e004 	ldr.w	lr, [sp, #4]
34001b8a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001b8e:	b004      	add	sp, #16
34001b90:	4240      	negs	r0, r0
34001b92:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
34001b96:	4770      	bx	lr
34001b98:	4252      	negs	r2, r2
34001b9a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
34001b9e:	f000 f821 	bl	34001be4 <__udivmoddi4>
34001ba2:	f8dd e004 	ldr.w	lr, [sp, #4]
34001ba6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001baa:	b004      	add	sp, #16
34001bac:	4252      	negs	r2, r2
34001bae:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
34001bb2:	4770      	bx	lr

34001bb4 <__aeabi_uldivmod>:
34001bb4:	b953      	cbnz	r3, 34001bcc <__aeabi_uldivmod+0x18>
34001bb6:	b94a      	cbnz	r2, 34001bcc <__aeabi_uldivmod+0x18>
34001bb8:	2900      	cmp	r1, #0
34001bba:	bf08      	it	eq
34001bbc:	2800      	cmpeq	r0, #0
34001bbe:	bf1c      	itt	ne
34001bc0:	f04f 31ff 	movne.w	r1, #4294967295
34001bc4:	f04f 30ff 	movne.w	r0, #4294967295
34001bc8:	f000 b9b0 	b.w	34001f2c <__aeabi_idiv0>
34001bcc:	f1ad 0c08 	sub.w	ip, sp, #8
34001bd0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
34001bd4:	f000 f806 	bl	34001be4 <__udivmoddi4>
34001bd8:	f8dd e004 	ldr.w	lr, [sp, #4]
34001bdc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
34001be0:	b004      	add	sp, #16
34001be2:	4770      	bx	lr

34001be4 <__udivmoddi4>:
34001be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34001be8:	9d09      	ldr	r5, [sp, #36]	@ 0x24
34001bea:	4688      	mov	r8, r1
34001bec:	4604      	mov	r4, r0
34001bee:	468e      	mov	lr, r1
34001bf0:	2b00      	cmp	r3, #0
34001bf2:	d14a      	bne.n	34001c8a <__udivmoddi4+0xa6>
34001bf4:	428a      	cmp	r2, r1
34001bf6:	4617      	mov	r7, r2
34001bf8:	d95f      	bls.n	34001cba <__udivmoddi4+0xd6>
34001bfa:	fab2 f682 	clz	r6, r2
34001bfe:	b14e      	cbz	r6, 34001c14 <__udivmoddi4+0x30>
34001c00:	f1c6 0320 	rsb	r3, r6, #32
34001c04:	fa01 fe06 	lsl.w	lr, r1, r6
34001c08:	40b7      	lsls	r7, r6
34001c0a:	40b4      	lsls	r4, r6
34001c0c:	fa20 f303 	lsr.w	r3, r0, r3
34001c10:	ea43 0e0e 	orr.w	lr, r3, lr
34001c14:	ea4f 4817 	mov.w	r8, r7, lsr #16
34001c18:	fa1f fc87 	uxth.w	ip, r7
34001c1c:	0c23      	lsrs	r3, r4, #16
34001c1e:	fbbe f1f8 	udiv	r1, lr, r8
34001c22:	fb08 ee11 	mls	lr, r8, r1, lr
34001c26:	fb01 f20c 	mul.w	r2, r1, ip
34001c2a:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
34001c2e:	429a      	cmp	r2, r3
34001c30:	d907      	bls.n	34001c42 <__udivmoddi4+0x5e>
34001c32:	18fb      	adds	r3, r7, r3
34001c34:	f101 30ff 	add.w	r0, r1, #4294967295
34001c38:	d202      	bcs.n	34001c40 <__udivmoddi4+0x5c>
34001c3a:	429a      	cmp	r2, r3
34001c3c:	f200 8154 	bhi.w	34001ee8 <__udivmoddi4+0x304>
34001c40:	4601      	mov	r1, r0
34001c42:	1a9b      	subs	r3, r3, r2
34001c44:	b2a2      	uxth	r2, r4
34001c46:	fbb3 f0f8 	udiv	r0, r3, r8
34001c4a:	fb08 3310 	mls	r3, r8, r0, r3
34001c4e:	fb00 fc0c 	mul.w	ip, r0, ip
34001c52:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
34001c56:	4594      	cmp	ip, r2
34001c58:	d90b      	bls.n	34001c72 <__udivmoddi4+0x8e>
34001c5a:	18ba      	adds	r2, r7, r2
34001c5c:	f100 33ff 	add.w	r3, r0, #4294967295
34001c60:	bf2c      	ite	cs
34001c62:	2401      	movcs	r4, #1
34001c64:	2400      	movcc	r4, #0
34001c66:	4594      	cmp	ip, r2
34001c68:	d902      	bls.n	34001c70 <__udivmoddi4+0x8c>
34001c6a:	2c00      	cmp	r4, #0
34001c6c:	f000 813f 	beq.w	34001eee <__udivmoddi4+0x30a>
34001c70:	4618      	mov	r0, r3
34001c72:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
34001c76:	eba2 020c 	sub.w	r2, r2, ip
34001c7a:	2100      	movs	r1, #0
34001c7c:	b11d      	cbz	r5, 34001c86 <__udivmoddi4+0xa2>
34001c7e:	40f2      	lsrs	r2, r6
34001c80:	2300      	movs	r3, #0
34001c82:	e9c5 2300 	strd	r2, r3, [r5]
34001c86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34001c8a:	428b      	cmp	r3, r1
34001c8c:	d905      	bls.n	34001c9a <__udivmoddi4+0xb6>
34001c8e:	b10d      	cbz	r5, 34001c94 <__udivmoddi4+0xb0>
34001c90:	e9c5 0100 	strd	r0, r1, [r5]
34001c94:	2100      	movs	r1, #0
34001c96:	4608      	mov	r0, r1
34001c98:	e7f5      	b.n	34001c86 <__udivmoddi4+0xa2>
34001c9a:	fab3 f183 	clz	r1, r3
34001c9e:	2900      	cmp	r1, #0
34001ca0:	d14e      	bne.n	34001d40 <__udivmoddi4+0x15c>
34001ca2:	4543      	cmp	r3, r8
34001ca4:	f0c0 8112 	bcc.w	34001ecc <__udivmoddi4+0x2e8>
34001ca8:	4282      	cmp	r2, r0
34001caa:	f240 810f 	bls.w	34001ecc <__udivmoddi4+0x2e8>
34001cae:	4608      	mov	r0, r1
34001cb0:	2d00      	cmp	r5, #0
34001cb2:	d0e8      	beq.n	34001c86 <__udivmoddi4+0xa2>
34001cb4:	e9c5 4e00 	strd	r4, lr, [r5]
34001cb8:	e7e5      	b.n	34001c86 <__udivmoddi4+0xa2>
34001cba:	2a00      	cmp	r2, #0
34001cbc:	f000 80ac 	beq.w	34001e18 <__udivmoddi4+0x234>
34001cc0:	fab2 f682 	clz	r6, r2
34001cc4:	2e00      	cmp	r6, #0
34001cc6:	f040 80bb 	bne.w	34001e40 <__udivmoddi4+0x25c>
34001cca:	1a8b      	subs	r3, r1, r2
34001ccc:	ea4f 4e12 	mov.w	lr, r2, lsr #16
34001cd0:	b2bc      	uxth	r4, r7
34001cd2:	2101      	movs	r1, #1
34001cd4:	0c02      	lsrs	r2, r0, #16
34001cd6:	b280      	uxth	r0, r0
34001cd8:	fbb3 fcfe 	udiv	ip, r3, lr
34001cdc:	fb0e 331c 	mls	r3, lr, ip, r3
34001ce0:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
34001ce4:	fb04 f20c 	mul.w	r2, r4, ip
34001ce8:	429a      	cmp	r2, r3
34001cea:	d90e      	bls.n	34001d0a <__udivmoddi4+0x126>
34001cec:	18fb      	adds	r3, r7, r3
34001cee:	f10c 38ff 	add.w	r8, ip, #4294967295
34001cf2:	bf2c      	ite	cs
34001cf4:	f04f 0901 	movcs.w	r9, #1
34001cf8:	f04f 0900 	movcc.w	r9, #0
34001cfc:	429a      	cmp	r2, r3
34001cfe:	d903      	bls.n	34001d08 <__udivmoddi4+0x124>
34001d00:	f1b9 0f00 	cmp.w	r9, #0
34001d04:	f000 80ec 	beq.w	34001ee0 <__udivmoddi4+0x2fc>
34001d08:	46c4      	mov	ip, r8
34001d0a:	1a9b      	subs	r3, r3, r2
34001d0c:	fbb3 f8fe 	udiv	r8, r3, lr
34001d10:	fb0e 3318 	mls	r3, lr, r8, r3
34001d14:	fb04 f408 	mul.w	r4, r4, r8
34001d18:	ea40 4203 	orr.w	r2, r0, r3, lsl #16
34001d1c:	4294      	cmp	r4, r2
34001d1e:	d90b      	bls.n	34001d38 <__udivmoddi4+0x154>
34001d20:	18ba      	adds	r2, r7, r2
34001d22:	f108 33ff 	add.w	r3, r8, #4294967295
34001d26:	bf2c      	ite	cs
34001d28:	2001      	movcs	r0, #1
34001d2a:	2000      	movcc	r0, #0
34001d2c:	4294      	cmp	r4, r2
34001d2e:	d902      	bls.n	34001d36 <__udivmoddi4+0x152>
34001d30:	2800      	cmp	r0, #0
34001d32:	f000 80d1 	beq.w	34001ed8 <__udivmoddi4+0x2f4>
34001d36:	4698      	mov	r8, r3
34001d38:	1b12      	subs	r2, r2, r4
34001d3a:	ea48 400c 	orr.w	r0, r8, ip, lsl #16
34001d3e:	e79d      	b.n	34001c7c <__udivmoddi4+0x98>
34001d40:	f1c1 0620 	rsb	r6, r1, #32
34001d44:	408b      	lsls	r3, r1
34001d46:	fa08 f401 	lsl.w	r4, r8, r1
34001d4a:	fa00 f901 	lsl.w	r9, r0, r1
34001d4e:	fa22 f706 	lsr.w	r7, r2, r6
34001d52:	fa28 f806 	lsr.w	r8, r8, r6
34001d56:	408a      	lsls	r2, r1
34001d58:	431f      	orrs	r7, r3
34001d5a:	fa20 f306 	lsr.w	r3, r0, r6
34001d5e:	0c38      	lsrs	r0, r7, #16
34001d60:	4323      	orrs	r3, r4
34001d62:	fa1f fc87 	uxth.w	ip, r7
34001d66:	0c1c      	lsrs	r4, r3, #16
34001d68:	fbb8 fef0 	udiv	lr, r8, r0
34001d6c:	fb00 881e 	mls	r8, r0, lr, r8
34001d70:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
34001d74:	fb0e f80c 	mul.w	r8, lr, ip
34001d78:	45a0      	cmp	r8, r4
34001d7a:	d90e      	bls.n	34001d9a <__udivmoddi4+0x1b6>
34001d7c:	193c      	adds	r4, r7, r4
34001d7e:	f10e 3aff 	add.w	sl, lr, #4294967295
34001d82:	bf2c      	ite	cs
34001d84:	f04f 0b01 	movcs.w	fp, #1
34001d88:	f04f 0b00 	movcc.w	fp, #0
34001d8c:	45a0      	cmp	r8, r4
34001d8e:	d903      	bls.n	34001d98 <__udivmoddi4+0x1b4>
34001d90:	f1bb 0f00 	cmp.w	fp, #0
34001d94:	f000 80b8 	beq.w	34001f08 <__udivmoddi4+0x324>
34001d98:	46d6      	mov	lr, sl
34001d9a:	eba4 0408 	sub.w	r4, r4, r8
34001d9e:	fa1f f883 	uxth.w	r8, r3
34001da2:	fbb4 f3f0 	udiv	r3, r4, r0
34001da6:	fb00 4413 	mls	r4, r0, r3, r4
34001daa:	fb03 fc0c 	mul.w	ip, r3, ip
34001dae:	ea48 4404 	orr.w	r4, r8, r4, lsl #16
34001db2:	45a4      	cmp	ip, r4
34001db4:	d90e      	bls.n	34001dd4 <__udivmoddi4+0x1f0>
34001db6:	193c      	adds	r4, r7, r4
34001db8:	f103 30ff 	add.w	r0, r3, #4294967295
34001dbc:	bf2c      	ite	cs
34001dbe:	f04f 0801 	movcs.w	r8, #1
34001dc2:	f04f 0800 	movcc.w	r8, #0
34001dc6:	45a4      	cmp	ip, r4
34001dc8:	d903      	bls.n	34001dd2 <__udivmoddi4+0x1ee>
34001dca:	f1b8 0f00 	cmp.w	r8, #0
34001dce:	f000 809f 	beq.w	34001f10 <__udivmoddi4+0x32c>
34001dd2:	4603      	mov	r3, r0
34001dd4:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
34001dd8:	eba4 040c 	sub.w	r4, r4, ip
34001ddc:	fba0 ec02 	umull	lr, ip, r0, r2
34001de0:	4564      	cmp	r4, ip
34001de2:	4673      	mov	r3, lr
34001de4:	46e0      	mov	r8, ip
34001de6:	d302      	bcc.n	34001dee <__udivmoddi4+0x20a>
34001de8:	d107      	bne.n	34001dfa <__udivmoddi4+0x216>
34001dea:	45f1      	cmp	r9, lr
34001dec:	d205      	bcs.n	34001dfa <__udivmoddi4+0x216>
34001dee:	ebbe 0302 	subs.w	r3, lr, r2
34001df2:	eb6c 0c07 	sbc.w	ip, ip, r7
34001df6:	3801      	subs	r0, #1
34001df8:	46e0      	mov	r8, ip
34001dfa:	b15d      	cbz	r5, 34001e14 <__udivmoddi4+0x230>
34001dfc:	ebb9 0203 	subs.w	r2, r9, r3
34001e00:	eb64 0408 	sbc.w	r4, r4, r8
34001e04:	fa04 f606 	lsl.w	r6, r4, r6
34001e08:	fa22 f301 	lsr.w	r3, r2, r1
34001e0c:	40cc      	lsrs	r4, r1
34001e0e:	431e      	orrs	r6, r3
34001e10:	e9c5 6400 	strd	r6, r4, [r5]
34001e14:	2100      	movs	r1, #0
34001e16:	e736      	b.n	34001c86 <__udivmoddi4+0xa2>
34001e18:	fbb1 fcf2 	udiv	ip, r1, r2
34001e1c:	0c01      	lsrs	r1, r0, #16
34001e1e:	4614      	mov	r4, r2
34001e20:	b280      	uxth	r0, r0
34001e22:	4696      	mov	lr, r2
34001e24:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001e28:	2620      	movs	r6, #32
34001e2a:	4690      	mov	r8, r2
34001e2c:	ea40 4301 	orr.w	r3, r0, r1, lsl #16
34001e30:	4610      	mov	r0, r2
34001e32:	fbb1 f1f2 	udiv	r1, r1, r2
34001e36:	eba3 0308 	sub.w	r3, r3, r8
34001e3a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
34001e3e:	e74b      	b.n	34001cd8 <__udivmoddi4+0xf4>
34001e40:	40b7      	lsls	r7, r6
34001e42:	f1c6 0320 	rsb	r3, r6, #32
34001e46:	fa01 f206 	lsl.w	r2, r1, r6
34001e4a:	fa21 f803 	lsr.w	r8, r1, r3
34001e4e:	ea4f 4e17 	mov.w	lr, r7, lsr #16
34001e52:	fa20 f303 	lsr.w	r3, r0, r3
34001e56:	b2bc      	uxth	r4, r7
34001e58:	40b0      	lsls	r0, r6
34001e5a:	4313      	orrs	r3, r2
34001e5c:	0c02      	lsrs	r2, r0, #16
34001e5e:	0c19      	lsrs	r1, r3, #16
34001e60:	b280      	uxth	r0, r0
34001e62:	fbb8 f9fe 	udiv	r9, r8, lr
34001e66:	fb0e 8819 	mls	r8, lr, r9, r8
34001e6a:	ea41 4108 	orr.w	r1, r1, r8, lsl #16
34001e6e:	fb09 f804 	mul.w	r8, r9, r4
34001e72:	4588      	cmp	r8, r1
34001e74:	d951      	bls.n	34001f1a <__udivmoddi4+0x336>
34001e76:	1879      	adds	r1, r7, r1
34001e78:	f109 3cff 	add.w	ip, r9, #4294967295
34001e7c:	bf2c      	ite	cs
34001e7e:	f04f 0a01 	movcs.w	sl, #1
34001e82:	f04f 0a00 	movcc.w	sl, #0
34001e86:	4588      	cmp	r8, r1
34001e88:	d902      	bls.n	34001e90 <__udivmoddi4+0x2ac>
34001e8a:	f1ba 0f00 	cmp.w	sl, #0
34001e8e:	d031      	beq.n	34001ef4 <__udivmoddi4+0x310>
34001e90:	eba1 0108 	sub.w	r1, r1, r8
34001e94:	fbb1 f9fe 	udiv	r9, r1, lr
34001e98:	fb09 f804 	mul.w	r8, r9, r4
34001e9c:	fb0e 1119 	mls	r1, lr, r9, r1
34001ea0:	b29b      	uxth	r3, r3
34001ea2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
34001ea6:	4543      	cmp	r3, r8
34001ea8:	d235      	bcs.n	34001f16 <__udivmoddi4+0x332>
34001eaa:	18fb      	adds	r3, r7, r3
34001eac:	f109 31ff 	add.w	r1, r9, #4294967295
34001eb0:	bf2c      	ite	cs
34001eb2:	f04f 0a01 	movcs.w	sl, #1
34001eb6:	f04f 0a00 	movcc.w	sl, #0
34001eba:	4543      	cmp	r3, r8
34001ebc:	d2bb      	bcs.n	34001e36 <__udivmoddi4+0x252>
34001ebe:	f1ba 0f00 	cmp.w	sl, #0
34001ec2:	d1b8      	bne.n	34001e36 <__udivmoddi4+0x252>
34001ec4:	f1a9 0102 	sub.w	r1, r9, #2
34001ec8:	443b      	add	r3, r7
34001eca:	e7b4      	b.n	34001e36 <__udivmoddi4+0x252>
34001ecc:	1a84      	subs	r4, r0, r2
34001ece:	eb68 0203 	sbc.w	r2, r8, r3
34001ed2:	2001      	movs	r0, #1
34001ed4:	4696      	mov	lr, r2
34001ed6:	e6eb      	b.n	34001cb0 <__udivmoddi4+0xcc>
34001ed8:	443a      	add	r2, r7
34001eda:	f1a8 0802 	sub.w	r8, r8, #2
34001ede:	e72b      	b.n	34001d38 <__udivmoddi4+0x154>
34001ee0:	f1ac 0c02 	sub.w	ip, ip, #2
34001ee4:	443b      	add	r3, r7
34001ee6:	e710      	b.n	34001d0a <__udivmoddi4+0x126>
34001ee8:	3902      	subs	r1, #2
34001eea:	443b      	add	r3, r7
34001eec:	e6a9      	b.n	34001c42 <__udivmoddi4+0x5e>
34001eee:	443a      	add	r2, r7
34001ef0:	3802      	subs	r0, #2
34001ef2:	e6be      	b.n	34001c72 <__udivmoddi4+0x8e>
34001ef4:	eba7 0808 	sub.w	r8, r7, r8
34001ef8:	f1a9 0c02 	sub.w	ip, r9, #2
34001efc:	4441      	add	r1, r8
34001efe:	fbb1 f9fe 	udiv	r9, r1, lr
34001f02:	fb09 f804 	mul.w	r8, r9, r4
34001f06:	e7c9      	b.n	34001e9c <__udivmoddi4+0x2b8>
34001f08:	f1ae 0e02 	sub.w	lr, lr, #2
34001f0c:	443c      	add	r4, r7
34001f0e:	e744      	b.n	34001d9a <__udivmoddi4+0x1b6>
34001f10:	3b02      	subs	r3, #2
34001f12:	443c      	add	r4, r7
34001f14:	e75e      	b.n	34001dd4 <__udivmoddi4+0x1f0>
34001f16:	4649      	mov	r1, r9
34001f18:	e78d      	b.n	34001e36 <__udivmoddi4+0x252>
34001f1a:	eba1 0108 	sub.w	r1, r1, r8
34001f1e:	46cc      	mov	ip, r9
34001f20:	fbb1 f9fe 	udiv	r9, r1, lr
34001f24:	fb09 f804 	mul.w	r8, r9, r4
34001f28:	e7b8      	b.n	34001e9c <__udivmoddi4+0x2b8>
34001f2a:	bf00      	nop

34001f2c <__aeabi_idiv0>:
34001f2c:	4770      	bx	lr
34001f2e:	bf00      	nop

34001f30 <LL_Buffer_len>:
  {
    return LL_Buffer_addr_base(buf) + buf->offset_limit;
  }

  static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
  {
34001f30:	b480      	push	{r7}
34001f32:	b083      	sub	sp, #12
34001f34:	af00      	add	r7, sp, #0
34001f36:	6078      	str	r0, [r7, #4]
    return buf->offset_end - buf->offset_start;
34001f38:	687b      	ldr	r3, [r7, #4]
34001f3a:	68da      	ldr	r2, [r3, #12]
34001f3c:	687b      	ldr	r3, [r7, #4]
34001f3e:	689b      	ldr	r3, [r3, #8]
34001f40:	1ad3      	subs	r3, r2, r3
  }
34001f42:	4618      	mov	r0, r3
34001f44:	370c      	adds	r7, #12
34001f46:	46bd      	mov	sp, r7
34001f48:	f85d 7b04 	ldr.w	r7, [sp], #4
34001f4c:	4770      	bx	lr
	...

34001f50 <app_run>:
static app_cpuload_t cpuload;

static void app_display_network_output(app_display_info_t *display_info);

void app_run(void)
{
34001f50:	b580      	push	{r7, lr}
34001f52:	b08c      	sub	sp, #48	@ 0x30
34001f54:	af08      	add	r7, sp, #32
    app_lcd_init();
34001f56:	f000 ffef 	bl	34002f38 <app_lcd_init>
    app_bqueue_init(&nn_input_queue, 2, (uint8_t *[2]){nn_input_buffers[0], nn_input_buffers[1]});
34001f5a:	4a4a      	ldr	r2, [pc, #296]	@ (34002084 <app_run+0x134>)
34001f5c:	f107 0308 	add.w	r3, r7, #8
34001f60:	e892 0003 	ldmia.w	r2, {r0, r1}
34001f64:	e883 0003 	stmia.w	r3, {r0, r1}
34001f68:	f107 0308 	add.w	r3, r7, #8
34001f6c:	461a      	mov	r2, r3
34001f6e:	2102      	movs	r1, #2
34001f70:	4845      	ldr	r0, [pc, #276]	@ (34002088 <app_run+0x138>)
34001f72:	f000 fbef 	bl	34002754 <app_bqueue_init>
    app_bqueue_init(&nn_output_queue, 2, (uint8_t *[2]){nn_output_buffers[0], nn_output_buffers[1]});
34001f76:	4a45      	ldr	r2, [pc, #276]	@ (3400208c <app_run+0x13c>)
34001f78:	463b      	mov	r3, r7
34001f7a:	e892 0003 	ldmia.w	r2, {r0, r1}
34001f7e:	e883 0003 	stmia.w	r3, {r0, r1}
34001f82:	463b      	mov	r3, r7
34001f84:	461a      	mov	r2, r3
34001f86:	2102      	movs	r1, #2
34001f88:	4841      	ldr	r0, [pc, #260]	@ (34002090 <app_run+0x140>)
34001f8a:	f000 fbe3 	bl	34002754 <app_bqueue_init>
    app_cpuload_init(&cpuload);
34001f8e:	4841      	ldr	r0, [pc, #260]	@ (34002094 <app_run+0x144>)
34001f90:	f000 fea2 	bl	34002cd8 <app_cpuload_init>
    app_camera_init(app_camera_display_pipe_vsync_cb, app_camera_display_pipe_frame_cb, NULL, app_camera_nn_pipe_frame_cb);
34001f94:	4b40      	ldr	r3, [pc, #256]	@ (34002098 <app_run+0x148>)
34001f96:	2200      	movs	r2, #0
34001f98:	4940      	ldr	r1, [pc, #256]	@ (3400209c <app_run+0x14c>)
34001f9a:	4841      	ldr	r0, [pc, #260]	@ (340020a0 <app_run+0x150>)
34001f9c:	f000 fc8c 	bl	340028b8 <app_camera_init>

    tx_semaphore_create(&isp_semaphore, NULL, 0);
34001fa0:	2320      	movs	r3, #32
34001fa2:	2200      	movs	r2, #0
34001fa4:	2100      	movs	r1, #0
34001fa6:	483f      	ldr	r0, [pc, #252]	@ (340020a4 <app_run+0x154>)
34001fa8:	f021 fbec 	bl	34023784 <_txe_semaphore_create>
    tx_semaphore_create(&display.update, NULL, 0);
34001fac:	2320      	movs	r3, #32
34001fae:	2200      	movs	r2, #0
34001fb0:	2100      	movs	r1, #0
34001fb2:	483d      	ldr	r0, [pc, #244]	@ (340020a8 <app_run+0x158>)
34001fb4:	f021 fbe6 	bl	34023784 <_txe_semaphore_create>
    tx_mutex_create(&display.lock, NULL, TX_INHERIT);
34001fb8:	2334      	movs	r3, #52	@ 0x34
34001fba:	2201      	movs	r2, #1
34001fbc:	2100      	movs	r1, #0
34001fbe:	483b      	ldr	r0, [pc, #236]	@ (340020ac <app_run+0x15c>)
34001fc0:	f021 fa4a 	bl	34023458 <_txe_mutex_create>

    app_camera_display_pipe_start(app_lcd_get_bg_buffer(), CMW_MODE_CONTINUOUS);
34001fc4:	f001 f878 	bl	340030b8 <app_lcd_get_bg_buffer>
34001fc8:	4603      	mov	r3, r0
34001fca:	2100      	movs	r1, #0
34001fcc:	4618      	mov	r0, r3
34001fce:	f000 fcc5 	bl	3400295c <app_camera_display_pipe_start>

    tx_thread_create(&nn_thread, "NN Thread", nn_thread_entry, 0, nn_thread_stack, sizeof(nn_thread_stack), TX_MAX_PRIORITIES - 3, TX_MAX_PRIORITIES - 3, 10, TX_AUTO_START);
34001fd2:	23c0      	movs	r3, #192	@ 0xc0
34001fd4:	9306      	str	r3, [sp, #24]
34001fd6:	2301      	movs	r3, #1
34001fd8:	9305      	str	r3, [sp, #20]
34001fda:	230a      	movs	r3, #10
34001fdc:	9304      	str	r3, [sp, #16]
34001fde:	231d      	movs	r3, #29
34001fe0:	9303      	str	r3, [sp, #12]
34001fe2:	231d      	movs	r3, #29
34001fe4:	9302      	str	r3, [sp, #8]
34001fe6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34001fea:	9301      	str	r3, [sp, #4]
34001fec:	4b30      	ldr	r3, [pc, #192]	@ (340020b0 <app_run+0x160>)
34001fee:	9300      	str	r3, [sp, #0]
34001ff0:	2300      	movs	r3, #0
34001ff2:	4a30      	ldr	r2, [pc, #192]	@ (340020b4 <app_run+0x164>)
34001ff4:	4930      	ldr	r1, [pc, #192]	@ (340020b8 <app_run+0x168>)
34001ff6:	4831      	ldr	r0, [pc, #196]	@ (340020bc <app_run+0x16c>)
34001ff8:	f021 fcf8 	bl	340239ec <_txe_thread_create>
    tx_thread_create(&pp_thread, "PP Thread", pp_thread_entry, 0, pp_thread_stack, sizeof(pp_thread_stack), TX_MAX_PRIORITIES - 2, TX_MAX_PRIORITIES - 2, 10, TX_AUTO_START);
34001ffc:	23c0      	movs	r3, #192	@ 0xc0
34001ffe:	9306      	str	r3, [sp, #24]
34002000:	2301      	movs	r3, #1
34002002:	9305      	str	r3, [sp, #20]
34002004:	230a      	movs	r3, #10
34002006:	9304      	str	r3, [sp, #16]
34002008:	231e      	movs	r3, #30
3400200a:	9303      	str	r3, [sp, #12]
3400200c:	231e      	movs	r3, #30
3400200e:	9302      	str	r3, [sp, #8]
34002010:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34002014:	9301      	str	r3, [sp, #4]
34002016:	4b2a      	ldr	r3, [pc, #168]	@ (340020c0 <app_run+0x170>)
34002018:	9300      	str	r3, [sp, #0]
3400201a:	2300      	movs	r3, #0
3400201c:	4a29      	ldr	r2, [pc, #164]	@ (340020c4 <app_run+0x174>)
3400201e:	492a      	ldr	r1, [pc, #168]	@ (340020c8 <app_run+0x178>)
34002020:	482a      	ldr	r0, [pc, #168]	@ (340020cc <app_run+0x17c>)
34002022:	f021 fce3 	bl	340239ec <_txe_thread_create>
    tx_thread_create(&dp_thread, "DP Thread", dp_thread_entry, 0, dp_thread_stack, sizeof(dp_thread_stack), TX_MAX_PRIORITIES - 2, TX_MAX_PRIORITIES - 2, 10, TX_AUTO_START);
34002026:	23c0      	movs	r3, #192	@ 0xc0
34002028:	9306      	str	r3, [sp, #24]
3400202a:	2301      	movs	r3, #1
3400202c:	9305      	str	r3, [sp, #20]
3400202e:	230a      	movs	r3, #10
34002030:	9304      	str	r3, [sp, #16]
34002032:	231e      	movs	r3, #30
34002034:	9303      	str	r3, [sp, #12]
34002036:	231e      	movs	r3, #30
34002038:	9302      	str	r3, [sp, #8]
3400203a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
3400203e:	9301      	str	r3, [sp, #4]
34002040:	4b23      	ldr	r3, [pc, #140]	@ (340020d0 <app_run+0x180>)
34002042:	9300      	str	r3, [sp, #0]
34002044:	2300      	movs	r3, #0
34002046:	4a23      	ldr	r2, [pc, #140]	@ (340020d4 <app_run+0x184>)
34002048:	4923      	ldr	r1, [pc, #140]	@ (340020d8 <app_run+0x188>)
3400204a:	4824      	ldr	r0, [pc, #144]	@ (340020dc <app_run+0x18c>)
3400204c:	f021 fcce 	bl	340239ec <_txe_thread_create>
    tx_thread_create(&isp_thread, "ISP Thread", isp_thread_entry, 0, isp_thread_stack, sizeof(isp_thread_stack), TX_MAX_PRIORITIES - 4, TX_MAX_PRIORITIES - 4, 10, TX_AUTO_START);
34002050:	23c0      	movs	r3, #192	@ 0xc0
34002052:	9306      	str	r3, [sp, #24]
34002054:	2301      	movs	r3, #1
34002056:	9305      	str	r3, [sp, #20]
34002058:	230a      	movs	r3, #10
3400205a:	9304      	str	r3, [sp, #16]
3400205c:	231c      	movs	r3, #28
3400205e:	9303      	str	r3, [sp, #12]
34002060:	231c      	movs	r3, #28
34002062:	9302      	str	r3, [sp, #8]
34002064:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34002068:	9301      	str	r3, [sp, #4]
3400206a:	4b1d      	ldr	r3, [pc, #116]	@ (340020e0 <app_run+0x190>)
3400206c:	9300      	str	r3, [sp, #0]
3400206e:	2300      	movs	r3, #0
34002070:	4a1c      	ldr	r2, [pc, #112]	@ (340020e4 <app_run+0x194>)
34002072:	491d      	ldr	r1, [pc, #116]	@ (340020e8 <app_run+0x198>)
34002074:	481d      	ldr	r0, [pc, #116]	@ (340020ec <app_run+0x19c>)
34002076:	f021 fcb9 	bl	340239ec <_txe_thread_create>
}
3400207a:	bf00      	nop
3400207c:	3710      	adds	r7, #16
3400207e:	46bd      	mov	sp, r7
34002080:	bd80      	pop	{r7, pc}
34002082:	bf00      	nop
34002084:	3402a13c 	.word	0x3402a13c
34002088:	34045e48 	.word	0x34045e48
3400208c:	3402a144 	.word	0x3402a144
34002090:	34048ca0 	.word	0x34048ca0
34002094:	34048cf0 	.word	0x34048cf0
34002098:	3400211d 	.word	0x3400211d
3400209c:	34002105 	.word	0x34002105
340020a0:	340020f1 	.word	0x340020f1
340020a4:	340419d0 	.word	0x340419d0
340020a8:	34045cf0 	.word	0x34045cf0
340020ac:	34045d10 	.word	0x34045d10
340020b0:	34041ab0 	.word	0x34041ab0
340020b4:	3400214d 	.word	0x3400214d
340020b8:	3402a10c 	.word	0x3402a10c
340020bc:	340419f0 	.word	0x340419f0
340020c0:	34042b70 	.word	0x34042b70
340020c4:	34002271 	.word	0x34002271
340020c8:	3402a118 	.word	0x3402a118
340020cc:	34042ab0 	.word	0x34042ab0
340020d0:	34043c30 	.word	0x34043c30
340020d4:	34002339 	.word	0x34002339
340020d8:	3402a124 	.word	0x3402a124
340020dc:	34043b70 	.word	0x34043b70
340020e0:	34044cf0 	.word	0x34044cf0
340020e4:	340023c1 	.word	0x340023c1
340020e8:	3402a130 	.word	0x3402a130
340020ec:	34044c30 	.word	0x34044c30

340020f0 <app_camera_display_pipe_vsync_cb>:

static void app_camera_display_pipe_vsync_cb(void)
{
340020f0:	b580      	push	{r7, lr}
340020f2:	af00      	add	r7, sp, #0
    tx_semaphore_put(&isp_semaphore);
340020f4:	4802      	ldr	r0, [pc, #8]	@ (34002100 <app_camera_display_pipe_vsync_cb+0x10>)
340020f6:	f021 fc5b 	bl	340239b0 <_txe_semaphore_put>
}
340020fa:	bf00      	nop
340020fc:	bd80      	pop	{r7, pc}
340020fe:	bf00      	nop
34002100:	340419d0 	.word	0x340419d0

34002104 <app_camera_display_pipe_frame_cb>:

static void app_camera_display_pipe_frame_cb(void)
{
34002104:	b580      	push	{r7, lr}
34002106:	af00      	add	r7, sp, #0
    app_lcd_switch_bg_buffer();
34002108:	f000 ffec 	bl	340030e4 <app_lcd_switch_bg_buffer>
    app_camera_display_pipe_set_address(app_lcd_get_bg_buffer());
3400210c:	f000 ffd4 	bl	340030b8 <app_lcd_get_bg_buffer>
34002110:	4603      	mov	r3, r0
34002112:	4618      	mov	r0, r3
34002114:	f000 fc30 	bl	34002978 <app_camera_display_pipe_set_address>
}
34002118:	bf00      	nop
3400211a:	bd80      	pop	{r7, pc}

3400211c <app_camera_nn_pipe_frame_cb>:

static void app_camera_nn_pipe_frame_cb(void)
{
3400211c:	b580      	push	{r7, lr}
3400211e:	b082      	sub	sp, #8
34002120:	af00      	add	r7, sp, #0
    uint8_t *buffer;

    buffer = app_bqueue_get_free(&nn_input_queue, 0);
34002122:	2100      	movs	r1, #0
34002124:	4808      	ldr	r0, [pc, #32]	@ (34002148 <app_camera_nn_pipe_frame_cb+0x2c>)
34002126:	f000 fb4f 	bl	340027c8 <app_bqueue_get_free>
3400212a:	6078      	str	r0, [r7, #4]
    if (buffer != NULL)
3400212c:	687b      	ldr	r3, [r7, #4]
3400212e:	2b00      	cmp	r3, #0
34002130:	d005      	beq.n	3400213e <app_camera_nn_pipe_frame_cb+0x22>
    {
        app_camera_nn_pipe_set_address(buffer);
34002132:	6878      	ldr	r0, [r7, #4]
34002134:	f000 fc3d 	bl	340029b2 <app_camera_nn_pipe_set_address>
        app_bqueue_put_ready(&nn_input_queue);
34002138:	4803      	ldr	r0, [pc, #12]	@ (34002148 <app_camera_nn_pipe_frame_cb+0x2c>)
3400213a:	f000 fbaf 	bl	3400289c <app_bqueue_put_ready>
    }
}
3400213e:	bf00      	nop
34002140:	3708      	adds	r7, #8
34002142:	46bd      	mov	sp, r7
34002144:	bd80      	pop	{r7, pc}
34002146:	bf00      	nop
34002148:	34045e48 	.word	0x34045e48

3400214c <nn_thread_entry>:

static VOID nn_thread_entry(ULONG id)
{
3400214c:	b580      	push	{r7, lr}
3400214e:	b090      	sub	sp, #64	@ 0x40
34002150:	af00      	add	r7, sp, #0
34002152:	6078      	str	r0, [r7, #4]
    uint32_t nn_period[2];
    uint32_t nn_period_ms;
    uint32_t time_stamp;
    uint32_t inf_ms;

    nn_in_len = LL_Buffer_len(LL_ATON_Input_Buffers_Info_Default());
34002154:	f022 f95c 	bl	34024410 <LL_ATON_Input_Buffers_Info_Default>
34002158:	4603      	mov	r3, r0
3400215a:	4618      	mov	r0, r3
3400215c:	f7ff fee8 	bl	34001f30 <LL_Buffer_len>
34002160:	63f8      	str	r0, [r7, #60]	@ 0x3c
    nn_out_len = LL_Buffer_len(LL_ATON_Output_Buffers_Info_Default());
34002162:	f022 f95f 	bl	34024424 <LL_ATON_Output_Buffers_Info_Default>
34002166:	4603      	mov	r3, r0
34002168:	4618      	mov	r0, r3
3400216a:	f7ff fee1 	bl	34001f30 <LL_Buffer_len>
3400216e:	63b8      	str	r0, [r7, #56]	@ 0x38

    nn_period[1] = HAL_GetTick();
34002170:	f002 fd5d 	bl	34004c2e <HAL_GetTick>
34002174:	4603      	mov	r3, r0
34002176:	60fb      	str	r3, [r7, #12]

    nn_pipe_dst = app_bqueue_get_free(&nn_input_queue, 0);
34002178:	2100      	movs	r1, #0
3400217a:	4837      	ldr	r0, [pc, #220]	@ (34002258 <nn_thread_entry+0x10c>)
3400217c:	f000 fb24 	bl	340027c8 <app_bqueue_get_free>
34002180:	6378      	str	r0, [r7, #52]	@ 0x34

    app_camera_nn_pipe_start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
34002182:	2100      	movs	r1, #0
34002184:	6b78      	ldr	r0, [r7, #52]	@ 0x34
34002186:	f000 fc06 	bl	34002996 <app_camera_nn_pipe_start>

    while (1)
    {
        nn_period[0] = nn_period[1];
3400218a:	68fb      	ldr	r3, [r7, #12]
3400218c:	60bb      	str	r3, [r7, #8]
        nn_period[1] = HAL_GetTick();
3400218e:	f002 fd4e 	bl	34004c2e <HAL_GetTick>
34002192:	4603      	mov	r3, r0
34002194:	60fb      	str	r3, [r7, #12]
        nn_period_ms = nn_period[1] - nn_period[0];
34002196:	68fa      	ldr	r2, [r7, #12]
34002198:	68bb      	ldr	r3, [r7, #8]
3400219a:	1ad3      	subs	r3, r2, r3
3400219c:	633b      	str	r3, [r7, #48]	@ 0x30

        capture_buffer = app_bqueue_get_ready(&nn_input_queue);
3400219e:	482e      	ldr	r0, [pc, #184]	@ (34002258 <nn_thread_entry+0x10c>)
340021a0:	f000 fb53 	bl	3400284a <app_bqueue_get_ready>
340021a4:	62f8      	str	r0, [r7, #44]	@ 0x2c
        output_buffer = app_bqueue_get_free(&nn_output_queue, 1);
340021a6:	2101      	movs	r1, #1
340021a8:	482c      	ldr	r0, [pc, #176]	@ (3400225c <nn_thread_entry+0x110>)
340021aa:	f000 fb0d 	bl	340027c8 <app_bqueue_get_free>
340021ae:	62b8      	str	r0, [r7, #40]	@ 0x28

        time_stamp = HAL_GetTick();
340021b0:	f002 fd3d 	bl	34004c2e <HAL_GetTick>
340021b4:	6278      	str	r0, [r7, #36]	@ 0x24
        LL_ATON_Set_User_Input_Buffer_Default(0, capture_buffer, nn_in_len);
340021b6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340021b8:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340021ba:	2000      	movs	r0, #0
340021bc:	f021 ff9c 	bl	340240f8 <LL_ATON_Set_User_Input_Buffer_Default>
        SCB_InvalidateDCache_by_Addr(output_buffer, nn_out_len);
340021c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340021c2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340021c4:	61fa      	str	r2, [r7, #28]
340021c6:	61bb      	str	r3, [r7, #24]
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
340021c8:	69bb      	ldr	r3, [r7, #24]
340021ca:	2b00      	cmp	r3, #0
340021cc:	dd1d      	ble.n	3400220a <nn_thread_entry+0xbe>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340021ce:	69fb      	ldr	r3, [r7, #28]
340021d0:	f003 021f 	and.w	r2, r3, #31
340021d4:	69bb      	ldr	r3, [r7, #24]
340021d6:	4413      	add	r3, r2
340021d8:	617b      	str	r3, [r7, #20]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
340021da:	69fb      	ldr	r3, [r7, #28]
340021dc:	613b      	str	r3, [r7, #16]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
340021de:	f3bf 8f4f 	dsb	sy
}
340021e2:	bf00      	nop

      __DSB();

      do {
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340021e4:	4a1e      	ldr	r2, [pc, #120]	@ (34002260 <nn_thread_entry+0x114>)
340021e6:	693b      	ldr	r3, [r7, #16]
340021e8:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
340021ec:	693b      	ldr	r3, [r7, #16]
340021ee:	3320      	adds	r3, #32
340021f0:	613b      	str	r3, [r7, #16]
        op_size -= __SCB_DCACHE_LINE_SIZE;
340021f2:	697b      	ldr	r3, [r7, #20]
340021f4:	3b20      	subs	r3, #32
340021f6:	617b      	str	r3, [r7, #20]
      } while ( op_size > 0 );
340021f8:	697b      	ldr	r3, [r7, #20]
340021fa:	2b00      	cmp	r3, #0
340021fc:	dcf2      	bgt.n	340021e4 <nn_thread_entry+0x98>
  __ASM volatile ("dsb 0xF":::"memory");
340021fe:	f3bf 8f4f 	dsb	sy
}
34002202:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34002204:	f3bf 8f6f 	isb	sy
}
34002208:	bf00      	nop

      __DSB();
      __ISB();
    }
  #endif
}
3400220a:	bf00      	nop
        LL_ATON_Set_User_Output_Buffer_Default(0, output_buffer, nn_out_len);
3400220c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3400220e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34002210:	2000      	movs	r0, #0
34002212:	f021 ffa9 	bl	34024168 <LL_ATON_Set_User_Output_Buffer_Default>
        LL_ATON_RT_Main(&NN_Instance_Default);
34002216:	4813      	ldr	r0, [pc, #76]	@ (34002264 <nn_thread_entry+0x118>)
34002218:	f018 f91c 	bl	3401a454 <LL_ATON_RT_Main>
        inf_ms = HAL_GetTick() - time_stamp;
3400221c:	f002 fd07 	bl	34004c2e <HAL_GetTick>
34002220:	4602      	mov	r2, r0
34002222:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002224:	1ad3      	subs	r3, r2, r3
34002226:	623b      	str	r3, [r7, #32]

        app_bqueue_put_free(&nn_input_queue);
34002228:	480b      	ldr	r0, [pc, #44]	@ (34002258 <nn_thread_entry+0x10c>)
3400222a:	f000 fb02 	bl	34002832 <app_bqueue_put_free>
        app_bqueue_put_ready(&nn_output_queue);
3400222e:	480b      	ldr	r0, [pc, #44]	@ (3400225c <nn_thread_entry+0x110>)
34002230:	f000 fb34 	bl	3400289c <app_bqueue_put_ready>

        tx_mutex_get(&display.lock, TX_WAIT_FOREVER);
34002234:	f04f 31ff 	mov.w	r1, #4294967295
34002238:	480b      	ldr	r0, [pc, #44]	@ (34002268 <nn_thread_entry+0x11c>)
3400223a:	f021 f9e9 	bl	34023610 <_txe_mutex_get>
        display.info.inf_ms = inf_ms;
3400223e:	4a0b      	ldr	r2, [pc, #44]	@ (3400226c <nn_thread_entry+0x120>)
34002240:	6a3b      	ldr	r3, [r7, #32]
34002242:	f8c2 314c 	str.w	r3, [r2, #332]	@ 0x14c
        display.info.nn_period_ms = nn_period_ms;
34002246:	4a09      	ldr	r2, [pc, #36]	@ (3400226c <nn_thread_entry+0x120>)
34002248:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400224a:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
        tx_mutex_put(&display.lock);
3400224e:	4806      	ldr	r0, [pc, #24]	@ (34002268 <nn_thread_entry+0x11c>)
34002250:	f021 fa38 	bl	340236c4 <_txe_mutex_put>
        nn_period[0] = nn_period[1];
34002254:	bf00      	nop
34002256:	e798      	b.n	3400218a <nn_thread_entry+0x3e>
34002258:	34045e48 	.word	0x34045e48
3400225c:	34048ca0 	.word	0x34048ca0
34002260:	e000ed00 	.word	0xe000ed00
34002264:	34041384 	.word	0x34041384
34002268:	34045d10 	.word	0x34045d10
3400226c:	34045cf0 	.word	0x34045cf0

34002270 <pp_thread_entry>:
    }
}

static VOID pp_thread_entry(ULONG id)
{
34002270:	b5b0      	push	{r4, r5, r7, lr}
34002272:	b094      	sub	sp, #80	@ 0x50
34002274:	af00      	add	r7, sp, #0
34002276:	6078      	str	r0, [r7, #4]
    uint8_t *output_buffer;
    od_pp_out_t pp_output;
    uint32_t nn_pp[2];
    int32_t i;

    app_postprocess_init(&pp_params);
34002278:	f107 0320 	add.w	r3, r7, #32
3400227c:	4618      	mov	r0, r3
3400227e:	f000 ffdf 	bl	34003240 <app_postprocess_init>

    while (1)
    {
        output_buffer = app_bqueue_get_ready(&nn_output_queue);
34002282:	482a      	ldr	r0, [pc, #168]	@ (3400232c <pp_thread_entry+0xbc>)
34002284:	f000 fae1 	bl	3400284a <app_bqueue_get_ready>
34002288:	64b8      	str	r0, [r7, #72]	@ 0x48
        pp_output.pOutBuff = NULL;
3400228a:	2300      	movs	r3, #0
3400228c:	61bb      	str	r3, [r7, #24]

        nn_pp[0] = HAL_GetTick();
3400228e:	f002 fcce 	bl	34004c2e <HAL_GetTick>
34002292:	4603      	mov	r3, r0
34002294:	613b      	str	r3, [r7, #16]
        app_postprocess_run((void *[]){(void *)output_buffer}, 1, &pp_output, &pp_params);
34002296:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34002298:	60fb      	str	r3, [r7, #12]
3400229a:	f107 0320 	add.w	r3, r7, #32
3400229e:	f107 0218 	add.w	r2, r7, #24
340022a2:	f107 000c 	add.w	r0, r7, #12
340022a6:	2101      	movs	r1, #1
340022a8:	f000 fffc 	bl	340032a4 <app_postprocess_run>
        nn_pp[1] = HAL_GetTick();
340022ac:	f002 fcbf 	bl	34004c2e <HAL_GetTick>
340022b0:	4603      	mov	r3, r0
340022b2:	617b      	str	r3, [r7, #20]

        tx_mutex_get(&display.lock, TX_WAIT_FOREVER);
340022b4:	f04f 31ff 	mov.w	r1, #4294967295
340022b8:	481d      	ldr	r0, [pc, #116]	@ (34002330 <pp_thread_entry+0xc0>)
340022ba:	f021 f9a9 	bl	34023610 <_txe_mutex_get>
        display.info.nb_detect = pp_output.nb_detect;
340022be:	69fb      	ldr	r3, [r7, #28]
340022c0:	4a1c      	ldr	r2, [pc, #112]	@ (34002334 <pp_thread_entry+0xc4>)
340022c2:	6553      	str	r3, [r2, #84]	@ 0x54
        for (i = 0; i < pp_output.nb_detect; i++)
340022c4:	2300      	movs	r3, #0
340022c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
340022c8:	e01a      	b.n	34002300 <pp_thread_entry+0x90>
        {
            display.info.detects[i] = pp_output.pOutBuff[i];
340022ca:	69b9      	ldr	r1, [r7, #24]
340022cc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
340022ce:	4613      	mov	r3, r2
340022d0:	005b      	lsls	r3, r3, #1
340022d2:	4413      	add	r3, r2
340022d4:	00db      	lsls	r3, r3, #3
340022d6:	18c8      	adds	r0, r1, r3
340022d8:	4916      	ldr	r1, [pc, #88]	@ (34002334 <pp_thread_entry+0xc4>)
340022da:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
340022dc:	4613      	mov	r3, r2
340022de:	005b      	lsls	r3, r3, #1
340022e0:	4413      	add	r3, r2
340022e2:	00db      	lsls	r3, r3, #3
340022e4:	440b      	add	r3, r1
340022e6:	3350      	adds	r3, #80	@ 0x50
340022e8:	f103 0408 	add.w	r4, r3, #8
340022ec:	4605      	mov	r5, r0
340022ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
340022f0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
340022f2:	e895 0003 	ldmia.w	r5, {r0, r1}
340022f6:	e884 0003 	stmia.w	r4, {r0, r1}
        for (i = 0; i < pp_output.nb_detect; i++)
340022fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340022fc:	3301      	adds	r3, #1
340022fe:	64fb      	str	r3, [r7, #76]	@ 0x4c
34002300:	69fb      	ldr	r3, [r7, #28]
34002302:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34002304:	429a      	cmp	r2, r3
34002306:	dbe0      	blt.n	340022ca <pp_thread_entry+0x5a>
        }
        display.info.pp_ms = nn_pp[1] - nn_pp[0];
34002308:	697a      	ldr	r2, [r7, #20]
3400230a:	693b      	ldr	r3, [r7, #16]
3400230c:	1ad3      	subs	r3, r2, r3
3400230e:	4a09      	ldr	r2, [pc, #36]	@ (34002334 <pp_thread_entry+0xc4>)
34002310:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
        tx_mutex_put(&display.lock);
34002314:	4806      	ldr	r0, [pc, #24]	@ (34002330 <pp_thread_entry+0xc0>)
34002316:	f021 f9d5 	bl	340236c4 <_txe_mutex_put>
        app_bqueue_put_free(&nn_output_queue);
3400231a:	4804      	ldr	r0, [pc, #16]	@ (3400232c <pp_thread_entry+0xbc>)
3400231c:	f000 fa89 	bl	34002832 <app_bqueue_put_free>
        tx_semaphore_ceiling_put(&display.update, 1);
34002320:	2101      	movs	r1, #1
34002322:	4804      	ldr	r0, [pc, #16]	@ (34002334 <pp_thread_entry+0xc4>)
34002324:	f021 fa08 	bl	34023738 <_txe_semaphore_ceiling_put>
    {
34002328:	e7ab      	b.n	34002282 <pp_thread_entry+0x12>
3400232a:	bf00      	nop
3400232c:	34048ca0 	.word	0x34048ca0
34002330:	34045d10 	.word	0x34045d10
34002334:	34045cf0 	.word	0x34045cf0

34002338 <dp_thread_entry>:
    }
}

static VOID dp_thread_entry(ULONG id)
{
34002338:	b580      	push	{r7, lr}
3400233a:	b0c6      	sub	sp, #280	@ 0x118
3400233c:	af00      	add	r7, sp, #0
3400233e:	f507 738c 	add.w	r3, r7, #280	@ 0x118
34002342:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
34002346:	6018      	str	r0, [r3, #0]
    uint32_t disp_ms = 0;
34002348:	2300      	movs	r3, #0
3400234a:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
    app_display_info_t display_info;
    uint32_t time_stamp;

    while (1)
    {
        tx_semaphore_get(&display.update, TX_WAIT_FOREVER);
3400234e:	f04f 31ff 	mov.w	r1, #4294967295
34002352:	4819      	ldr	r0, [pc, #100]	@ (340023b8 <dp_thread_entry+0x80>)
34002354:	f021 faea 	bl	3402392c <_txe_semaphore_get>
        tx_mutex_get(&display.lock, TX_WAIT_FOREVER);
34002358:	f04f 31ff 	mov.w	r1, #4294967295
3400235c:	4817      	ldr	r0, [pc, #92]	@ (340023bc <dp_thread_entry+0x84>)
3400235e:	f021 f957 	bl	34023610 <_txe_mutex_get>
        display_info = display.info;
34002362:	f507 738c 	add.w	r3, r7, #280	@ 0x118
34002366:	f5a3 7286 	sub.w	r2, r3, #268	@ 0x10c
3400236a:	4b13      	ldr	r3, [pc, #76]	@ (340023b8 <dp_thread_entry+0x80>)
3400236c:	4610      	mov	r0, r2
3400236e:	3354      	adds	r3, #84	@ 0x54
34002370:	f44f 7282 	mov.w	r2, #260	@ 0x104
34002374:	4619      	mov	r1, r3
34002376:	f025 f99c 	bl	340276b2 <memcpy>
        tx_mutex_put(&display.lock);
3400237a:	4810      	ldr	r0, [pc, #64]	@ (340023bc <dp_thread_entry+0x84>)
3400237c:	f021 f9a2 	bl	340236c4 <_txe_mutex_put>
        display_info.disp_ms = disp_ms;
34002380:	f507 738c 	add.w	r3, r7, #280	@ 0x118
34002384:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
34002388:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
3400238c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

        time_stamp = HAL_GetTick();
34002390:	f002 fc4d 	bl	34004c2e <HAL_GetTick>
34002394:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110
        app_display_network_output(&display_info);
34002398:	f107 030c 	add.w	r3, r7, #12
3400239c:	4618      	mov	r0, r3
3400239e:	f000 f8f3 	bl	34002588 <app_display_network_output>
        disp_ms = HAL_GetTick() - time_stamp;
340023a2:	f002 fc44 	bl	34004c2e <HAL_GetTick>
340023a6:	4602      	mov	r2, r0
340023a8:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
340023ac:	1ad3      	subs	r3, r2, r3
340023ae:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
        tx_semaphore_get(&display.update, TX_WAIT_FOREVER);
340023b2:	bf00      	nop
340023b4:	e7cb      	b.n	3400234e <dp_thread_entry+0x16>
340023b6:	bf00      	nop
340023b8:	34045cf0 	.word	0x34045cf0
340023bc:	34045d10 	.word	0x34045d10

340023c0 <isp_thread_entry>:
    }
}

static VOID isp_thread_entry(ULONG id)
{
340023c0:	b580      	push	{r7, lr}
340023c2:	b082      	sub	sp, #8
340023c4:	af00      	add	r7, sp, #0
340023c6:	6078      	str	r0, [r7, #4]
    while (1)
    {
        tx_semaphore_get(&isp_semaphore, TX_WAIT_FOREVER);
340023c8:	f04f 31ff 	mov.w	r1, #4294967295
340023cc:	4803      	ldr	r0, [pc, #12]	@ (340023dc <isp_thread_entry+0x1c>)
340023ce:	f021 faad 	bl	3402392c <_txe_semaphore_get>

        app_camera_isp_update();
340023d2:	f000 fafd 	bl	340029d0 <app_camera_isp_update>
        tx_semaphore_get(&isp_semaphore, TX_WAIT_FOREVER);
340023d6:	bf00      	nop
340023d8:	e7f6      	b.n	340023c8 <isp_thread_entry+0x8>
340023da:	bf00      	nop
340023dc:	340419d0 	.word	0x340419d0

340023e0 <app_clamp_point>:
    }
}

static uint8_t app_clamp_point(int32_t *x, int32_t *y)
{
340023e0:	b480      	push	{r7}
340023e2:	b085      	sub	sp, #20
340023e4:	af00      	add	r7, sp, #0
340023e6:	6078      	str	r0, [r7, #4]
340023e8:	6039      	str	r1, [r7, #0]
    int32_t xi;
    int32_t yi;

    xi = *x;
340023ea:	687b      	ldr	r3, [r7, #4]
340023ec:	681b      	ldr	r3, [r3, #0]
340023ee:	60fb      	str	r3, [r7, #12]
    yi = *y;
340023f0:	683b      	ldr	r3, [r7, #0]
340023f2:	681b      	ldr	r3, [r3, #0]
340023f4:	60bb      	str	r3, [r7, #8]

    if (*x < 0)
340023f6:	687b      	ldr	r3, [r7, #4]
340023f8:	681b      	ldr	r3, [r3, #0]
340023fa:	2b00      	cmp	r3, #0
340023fc:	da02      	bge.n	34002404 <app_clamp_point+0x24>
    {
        *x = 0;
340023fe:	687b      	ldr	r3, [r7, #4]
34002400:	2200      	movs	r2, #0
34002402:	601a      	str	r2, [r3, #0]
    }

    if (*y < 0)
34002404:	683b      	ldr	r3, [r7, #0]
34002406:	681b      	ldr	r3, [r3, #0]
34002408:	2b00      	cmp	r3, #0
3400240a:	da02      	bge.n	34002412 <app_clamp_point+0x32>
    {
        *y = 0;
3400240c:	683b      	ldr	r3, [r7, #0]
3400240e:	2200      	movs	r2, #0
34002410:	601a      	str	r2, [r3, #0]
    }

    if (*x >= LCD_BG_WIDTH)
34002412:	687b      	ldr	r3, [r7, #4]
34002414:	681b      	ldr	r3, [r3, #0]
34002416:	f5b3 7f48 	cmp.w	r3, #800	@ 0x320
3400241a:	db03      	blt.n	34002424 <app_clamp_point+0x44>
    {
        *x = LCD_BG_WIDTH - 1;
3400241c:	687b      	ldr	r3, [r7, #4]
3400241e:	f240 321f 	movw	r2, #799	@ 0x31f
34002422:	601a      	str	r2, [r3, #0]
    }

    if (*y >= LCD_BG_HEIGHT)
34002424:	683b      	ldr	r3, [r7, #0]
34002426:	681b      	ldr	r3, [r3, #0]
34002428:	f5b3 7ff0 	cmp.w	r3, #480	@ 0x1e0
3400242c:	db03      	blt.n	34002436 <app_clamp_point+0x56>
    {
        *y = LCD_BG_HEIGHT - 1;
3400242e:	683b      	ldr	r3, [r7, #0]
34002430:	f240 12df 	movw	r2, #479	@ 0x1df
34002434:	601a      	str	r2, [r3, #0]
    }

    return (xi != *x) || (yi != *y);
34002436:	687b      	ldr	r3, [r7, #4]
34002438:	681b      	ldr	r3, [r3, #0]
3400243a:	68fa      	ldr	r2, [r7, #12]
3400243c:	429a      	cmp	r2, r3
3400243e:	d104      	bne.n	3400244a <app_clamp_point+0x6a>
34002440:	683b      	ldr	r3, [r7, #0]
34002442:	681b      	ldr	r3, [r3, #0]
34002444:	68ba      	ldr	r2, [r7, #8]
34002446:	429a      	cmp	r2, r3
34002448:	d001      	beq.n	3400244e <app_clamp_point+0x6e>
3400244a:	2301      	movs	r3, #1
3400244c:	e000      	b.n	34002450 <app_clamp_point+0x70>
3400244e:	2300      	movs	r3, #0
34002450:	b2db      	uxtb	r3, r3
}
34002452:	4618      	mov	r0, r3
34002454:	3714      	adds	r7, #20
34002456:	46bd      	mov	sp, r7
34002458:	f85d 7b04 	ldr.w	r7, [sp], #4
3400245c:	4770      	bx	lr
	...

34002460 <app_display_detection>:

static void app_display_detection(od_pp_outBuffer_t *detect)
{
34002460:	b590      	push	{r4, r7, lr}
34002462:	b08d      	sub	sp, #52	@ 0x34
34002464:	af02      	add	r7, sp, #8
34002466:	6078      	str	r0, [r7, #4]
    int32_t x1;
    int32_t y1;
    int32_t w;
    int32_t h;

    xc = (int32_t)(LCD_BG_WIDTH * detect->x_center);
34002468:	687b      	ldr	r3, [r7, #4]
3400246a:	edd3 7a00 	vldr	s15, [r3]
3400246e:	ed9f 7a43 	vldr	s14, [pc, #268]	@ 3400257c <app_display_detection+0x11c>
34002472:	ee67 7a87 	vmul.f32	s15, s15, s14
34002476:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3400247a:	ee17 3a90 	vmov	r3, s15
3400247e:	627b      	str	r3, [r7, #36]	@ 0x24
    yc = (int32_t)(LCD_BG_HEIGHT * detect->y_center);
34002480:	687b      	ldr	r3, [r7, #4]
34002482:	edd3 7a01 	vldr	s15, [r3, #4]
34002486:	ed9f 7a3e 	vldr	s14, [pc, #248]	@ 34002580 <app_display_detection+0x120>
3400248a:	ee67 7a87 	vmul.f32	s15, s15, s14
3400248e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34002492:	ee17 3a90 	vmov	r3, s15
34002496:	623b      	str	r3, [r7, #32]
    w = (int32_t)(LCD_BG_WIDTH * detect->width);
34002498:	687b      	ldr	r3, [r7, #4]
3400249a:	edd3 7a02 	vldr	s15, [r3, #8]
3400249e:	ed9f 7a37 	vldr	s14, [pc, #220]	@ 3400257c <app_display_detection+0x11c>
340024a2:	ee67 7a87 	vmul.f32	s15, s15, s14
340024a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340024aa:	ee17 3a90 	vmov	r3, s15
340024ae:	61fb      	str	r3, [r7, #28]
    h = (int32_t)(LCD_BG_HEIGHT * detect->height);
340024b0:	687b      	ldr	r3, [r7, #4]
340024b2:	edd3 7a03 	vldr	s15, [r3, #12]
340024b6:	ed9f 7a32 	vldr	s14, [pc, #200]	@ 34002580 <app_display_detection+0x120>
340024ba:	ee67 7a87 	vmul.f32	s15, s15, s14
340024be:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340024c2:	ee17 3a90 	vmov	r3, s15
340024c6:	61bb      	str	r3, [r7, #24]

    x0 = xc - (w + 1) / 2;
340024c8:	69fb      	ldr	r3, [r7, #28]
340024ca:	3301      	adds	r3, #1
340024cc:	0fda      	lsrs	r2, r3, #31
340024ce:	4413      	add	r3, r2
340024d0:	105b      	asrs	r3, r3, #1
340024d2:	425b      	negs	r3, r3
340024d4:	461a      	mov	r2, r3
340024d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340024d8:	4413      	add	r3, r2
340024da:	617b      	str	r3, [r7, #20]
    y0 = yc - (h + 1) / 2;
340024dc:	69bb      	ldr	r3, [r7, #24]
340024de:	3301      	adds	r3, #1
340024e0:	0fda      	lsrs	r2, r3, #31
340024e2:	4413      	add	r3, r2
340024e4:	105b      	asrs	r3, r3, #1
340024e6:	425b      	negs	r3, r3
340024e8:	461a      	mov	r2, r3
340024ea:	6a3b      	ldr	r3, [r7, #32]
340024ec:	4413      	add	r3, r2
340024ee:	613b      	str	r3, [r7, #16]
    x1 = xc + (w + 1) / 2;
340024f0:	69fb      	ldr	r3, [r7, #28]
340024f2:	3301      	adds	r3, #1
340024f4:	0fda      	lsrs	r2, r3, #31
340024f6:	4413      	add	r3, r2
340024f8:	105b      	asrs	r3, r3, #1
340024fa:	461a      	mov	r2, r3
340024fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340024fe:	4413      	add	r3, r2
34002500:	60fb      	str	r3, [r7, #12]
    y1 = yc + (h + 1) / 2;
34002502:	69bb      	ldr	r3, [r7, #24]
34002504:	3301      	adds	r3, #1
34002506:	0fda      	lsrs	r2, r3, #31
34002508:	4413      	add	r3, r2
3400250a:	105b      	asrs	r3, r3, #1
3400250c:	461a      	mov	r2, r3
3400250e:	6a3b      	ldr	r3, [r7, #32]
34002510:	4413      	add	r3, r2
34002512:	60bb      	str	r3, [r7, #8]

    app_clamp_point(&x0, &y0);
34002514:	f107 0210 	add.w	r2, r7, #16
34002518:	f107 0314 	add.w	r3, r7, #20
3400251c:	4611      	mov	r1, r2
3400251e:	4618      	mov	r0, r3
34002520:	f7ff ff5e 	bl	340023e0 <app_clamp_point>
    app_clamp_point(&x1, &y1);
34002524:	f107 0208 	add.w	r2, r7, #8
34002528:	f107 030c 	add.w	r3, r7, #12
3400252c:	4611      	mov	r1, r2
3400252e:	4618      	mov	r0, r3
34002530:	f7ff ff56 	bl	340023e0 <app_clamp_point>

    UTIL_LCD_DrawRect(x0, y0, x1 - x0, y1 - y0, UTIL_LCD_COLOR_GREEN);
34002534:	697b      	ldr	r3, [r7, #20]
34002536:	4618      	mov	r0, r3
34002538:	693b      	ldr	r3, [r7, #16]
3400253a:	4619      	mov	r1, r3
3400253c:	68fa      	ldr	r2, [r7, #12]
3400253e:	697b      	ldr	r3, [r7, #20]
34002540:	1ad3      	subs	r3, r2, r3
34002542:	461c      	mov	r4, r3
34002544:	68ba      	ldr	r2, [r7, #8]
34002546:	693b      	ldr	r3, [r7, #16]
34002548:	1ad3      	subs	r3, r2, r3
3400254a:	461a      	mov	r2, r3
3400254c:	f04f 23ff 	mov.w	r3, #4278255360	@ 0xff00ff00
34002550:	9300      	str	r3, [sp, #0]
34002552:	4613      	mov	r3, r2
34002554:	4622      	mov	r2, r4
34002556:	f022 fa59 	bl	34024a0c <UTIL_LCD_DrawRect>
    UTIL_LCDEx_PrintfAt(x0, y0, LEFT_MODE, nn_classes_table[detect->class_index]);
3400255a:	697b      	ldr	r3, [r7, #20]
3400255c:	4618      	mov	r0, r3
3400255e:	693b      	ldr	r3, [r7, #16]
34002560:	4619      	mov	r1, r3
34002562:	687b      	ldr	r3, [r7, #4]
34002564:	695b      	ldr	r3, [r3, #20]
34002566:	4a07      	ldr	r2, [pc, #28]	@ (34002584 <app_display_detection+0x124>)
34002568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400256c:	2203      	movs	r2, #3
3400256e:	f001 ff39 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
}
34002572:	bf00      	nop
34002574:	372c      	adds	r7, #44	@ 0x2c
34002576:	46bd      	mov	sp, r7
34002578:	bd90      	pop	{r4, r7, pc}
3400257a:	bf00      	nop
3400257c:	44480000 	.word	0x44480000
34002580:	43f00000 	.word	0x43f00000
34002584:	340413b4 	.word	0x340413b4

34002588 <app_display_network_output>:

static void app_display_network_output(app_display_info_t *display_info)
{
34002588:	b590      	push	{r4, r7, lr}
3400258a:	b089      	sub	sp, #36	@ 0x24
3400258c:	af02      	add	r7, sp, #8
3400258e:	6078      	str	r0, [r7, #4]
    float cpuload_one_second;
    uint8_t line_nb = 0;
34002590:	2300      	movs	r3, #0
34002592:	74fb      	strb	r3, [r7, #19]
    int32_t i;

    app_lcd_draw_area_update();
34002594:	f000 fde8 	bl	34003168 <app_lcd_draw_area_update>

    UTIL_LCD_FillRect(0, 0, LCD_FG_WIDTH, LCD_FG_HEIGHT, 0x00000000);
34002598:	2300      	movs	r3, #0
3400259a:	9300      	str	r3, [sp, #0]
3400259c:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
340025a0:	f44f 7248 	mov.w	r2, #800	@ 0x320
340025a4:	2100      	movs	r1, #0
340025a6:	2000      	movs	r0, #0
340025a8:	f022 fa5a 	bl	34024a60 <UTIL_LCD_FillRect>

    app_cpuload_update(&cpuload);
340025ac:	4860      	ldr	r0, [pc, #384]	@ (34002730 <app_display_network_output+0x1a8>)
340025ae:	f000 fba9 	bl	34002d04 <app_cpuload_update>
    app_cpuload_get_info(&cpuload, NULL, &cpuload_one_second, NULL);
340025b2:	f107 020c 	add.w	r2, r7, #12
340025b6:	2300      	movs	r3, #0
340025b8:	2100      	movs	r1, #0
340025ba:	485d      	ldr	r0, [pc, #372]	@ (34002730 <app_display_network_output+0x1a8>)
340025bc:	f000 fc18 	bl	34002df0 <app_cpuload_get_info>

    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "CPU load");
340025c0:	7cfc      	ldrb	r4, [r7, #19]
340025c2:	f022 f805 	bl	340245d0 <UTIL_LCD_GetFont>
340025c6:	4603      	mov	r3, r0
340025c8:	88db      	ldrh	r3, [r3, #6]
340025ca:	fb04 f303 	mul.w	r3, r4, r3
340025ce:	4619      	mov	r1, r3
340025d0:	4b58      	ldr	r3, [pc, #352]	@ (34002734 <app_display_network_output+0x1ac>)
340025d2:	2202      	movs	r2, #2
340025d4:	2000      	movs	r0, #0
340025d6:	f001 ff05 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 1;
340025da:	7cfb      	ldrb	r3, [r7, #19]
340025dc:	3301      	adds	r3, #1
340025de:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "%.1f%%", cpuload_one_second);
340025e0:	7cfc      	ldrb	r4, [r7, #19]
340025e2:	f021 fff5 	bl	340245d0 <UTIL_LCD_GetFont>
340025e6:	4603      	mov	r3, r0
340025e8:	88db      	ldrh	r3, [r3, #6]
340025ea:	fb04 f303 	mul.w	r3, r4, r3
340025ee:	4619      	mov	r1, r3
340025f0:	edd7 7a03 	vldr	s15, [r7, #12]
340025f4:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
340025f8:	ed8d 7b00 	vstr	d7, [sp]
340025fc:	4b4e      	ldr	r3, [pc, #312]	@ (34002738 <app_display_network_output+0x1b0>)
340025fe:	2202      	movs	r2, #2
34002600:	2000      	movs	r0, #0
34002602:	f001 feef 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 2;
34002606:	7cfb      	ldrb	r3, [r7, #19]
34002608:	3302      	adds	r3, #2
3400260a:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Inference");
3400260c:	7cfc      	ldrb	r4, [r7, #19]
3400260e:	f021 ffdf 	bl	340245d0 <UTIL_LCD_GetFont>
34002612:	4603      	mov	r3, r0
34002614:	88db      	ldrh	r3, [r3, #6]
34002616:	fb04 f303 	mul.w	r3, r4, r3
3400261a:	4619      	mov	r1, r3
3400261c:	4b47      	ldr	r3, [pc, #284]	@ (3400273c <app_display_network_output+0x1b4>)
3400261e:	2202      	movs	r2, #2
34002620:	2000      	movs	r0, #0
34002622:	f001 fedf 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 1;
34002626:	7cfb      	ldrb	r3, [r7, #19]
34002628:	3301      	adds	r3, #1
3400262a:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "%ums", display_info->inf_ms);
3400262c:	7cfc      	ldrb	r4, [r7, #19]
3400262e:	f021 ffcf 	bl	340245d0 <UTIL_LCD_GetFont>
34002632:	4603      	mov	r3, r0
34002634:	88db      	ldrh	r3, [r3, #6]
34002636:	fb04 f303 	mul.w	r3, r4, r3
3400263a:	4619      	mov	r1, r3
3400263c:	687b      	ldr	r3, [r7, #4]
3400263e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34002642:	9300      	str	r3, [sp, #0]
34002644:	4b3e      	ldr	r3, [pc, #248]	@ (34002740 <app_display_network_output+0x1b8>)
34002646:	2202      	movs	r2, #2
34002648:	2000      	movs	r0, #0
3400264a:	f001 fecb 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 2;
3400264e:	7cfb      	ldrb	r3, [r7, #19]
34002650:	3302      	adds	r3, #2
34002652:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "FPS");
34002654:	7cfc      	ldrb	r4, [r7, #19]
34002656:	f021 ffbb 	bl	340245d0 <UTIL_LCD_GetFont>
3400265a:	4603      	mov	r3, r0
3400265c:	88db      	ldrh	r3, [r3, #6]
3400265e:	fb04 f303 	mul.w	r3, r4, r3
34002662:	4619      	mov	r1, r3
34002664:	4b37      	ldr	r3, [pc, #220]	@ (34002744 <app_display_network_output+0x1bc>)
34002666:	2202      	movs	r2, #2
34002668:	2000      	movs	r0, #0
3400266a:	f001 febb 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 1;
3400266e:	7cfb      	ldrb	r3, [r7, #19]
34002670:	3301      	adds	r3, #1
34002672:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "%.2f", 1000.0 / display_info->nn_period_ms);
34002674:	7cfc      	ldrb	r4, [r7, #19]
34002676:	f021 ffab 	bl	340245d0 <UTIL_LCD_GetFont>
3400267a:	4603      	mov	r3, r0
3400267c:	88db      	ldrh	r3, [r3, #6]
3400267e:	fb04 f303 	mul.w	r3, r4, r3
34002682:	4619      	mov	r1, r3
34002684:	687b      	ldr	r3, [r7, #4]
34002686:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3400268a:	ee07 3a90 	vmov	s15, r3
3400268e:	eeb8 6b67 	vcvt.f64.u32	d6, s15
34002692:	ed9f 5b25 	vldr	d5, [pc, #148]	@ 34002728 <app_display_network_output+0x1a0>
34002696:	ee85 7b06 	vdiv.f64	d7, d5, d6
3400269a:	ed8d 7b00 	vstr	d7, [sp]
3400269e:	4b2a      	ldr	r3, [pc, #168]	@ (34002748 <app_display_network_output+0x1c0>)
340026a0:	2202      	movs	r2, #2
340026a2:	2000      	movs	r0, #0
340026a4:	f001 fe9e 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 2;
340026a8:	7cfb      	ldrb	r3, [r7, #19]
340026aa:	3302      	adds	r3, #2
340026ac:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Peoples");
340026ae:	7cfc      	ldrb	r4, [r7, #19]
340026b0:	f021 ff8e 	bl	340245d0 <UTIL_LCD_GetFont>
340026b4:	4603      	mov	r3, r0
340026b6:	88db      	ldrh	r3, [r3, #6]
340026b8:	fb04 f303 	mul.w	r3, r4, r3
340026bc:	4619      	mov	r1, r3
340026be:	4b23      	ldr	r3, [pc, #140]	@ (3400274c <app_display_network_output+0x1c4>)
340026c0:	2202      	movs	r2, #2
340026c2:	2000      	movs	r0, #0
340026c4:	f001 fe8e 	bl	340043e4 <UTIL_LCDEx_PrintfAt>
    line_nb += 1;
340026c8:	7cfb      	ldrb	r3, [r7, #19]
340026ca:	3301      	adds	r3, #1
340026cc:	74fb      	strb	r3, [r7, #19]
    UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "%u", display_info->nb_detect);
340026ce:	7cfc      	ldrb	r4, [r7, #19]
340026d0:	f021 ff7e 	bl	340245d0 <UTIL_LCD_GetFont>
340026d4:	4603      	mov	r3, r0
340026d6:	88db      	ldrh	r3, [r3, #6]
340026d8:	fb04 f303 	mul.w	r3, r4, r3
340026dc:	4619      	mov	r1, r3
340026de:	687b      	ldr	r3, [r7, #4]
340026e0:	681b      	ldr	r3, [r3, #0]
340026e2:	9300      	str	r3, [sp, #0]
340026e4:	4b1a      	ldr	r3, [pc, #104]	@ (34002750 <app_display_network_output+0x1c8>)
340026e6:	2202      	movs	r2, #2
340026e8:	2000      	movs	r0, #0
340026ea:	f001 fe7b 	bl	340043e4 <UTIL_LCDEx_PrintfAt>

    for (i = 0; i < display_info->nb_detect; i++)
340026ee:	2300      	movs	r3, #0
340026f0:	617b      	str	r3, [r7, #20]
340026f2:	e00d      	b.n	34002710 <app_display_network_output+0x188>
    {
        app_display_detection(&display_info->detects[i]);
340026f4:	697a      	ldr	r2, [r7, #20]
340026f6:	4613      	mov	r3, r2
340026f8:	005b      	lsls	r3, r3, #1
340026fa:	4413      	add	r3, r2
340026fc:	00db      	lsls	r3, r3, #3
340026fe:	687a      	ldr	r2, [r7, #4]
34002700:	4413      	add	r3, r2
34002702:	3304      	adds	r3, #4
34002704:	4618      	mov	r0, r3
34002706:	f7ff feab 	bl	34002460 <app_display_detection>
    for (i = 0; i < display_info->nb_detect; i++)
3400270a:	697b      	ldr	r3, [r7, #20]
3400270c:	3301      	adds	r3, #1
3400270e:	617b      	str	r3, [r7, #20]
34002710:	687b      	ldr	r3, [r7, #4]
34002712:	681b      	ldr	r3, [r3, #0]
34002714:	697a      	ldr	r2, [r7, #20]
34002716:	429a      	cmp	r2, r3
34002718:	dbec      	blt.n	340026f4 <app_display_network_output+0x16c>
    }

    app_lcd_draw_area_commit();
3400271a:	f000 fd41 	bl	340031a0 <app_lcd_draw_area_commit>
}
3400271e:	bf00      	nop
34002720:	371c      	adds	r7, #28
34002722:	46bd      	mov	sp, r7
34002724:	bd90      	pop	{r4, r7, pc}
34002726:	bf00      	nop
34002728:	00000000 	.word	0x00000000
3400272c:	408f4000 	.word	0x408f4000
34002730:	34048cf0 	.word	0x34048cf0
34002734:	3402a14c 	.word	0x3402a14c
34002738:	3402a158 	.word	0x3402a158
3400273c:	3402a160 	.word	0x3402a160
34002740:	3402a16c 	.word	0x3402a16c
34002744:	3402a174 	.word	0x3402a174
34002748:	3402a178 	.word	0x3402a178
3400274c:	3402a180 	.word	0x3402a180
34002750:	3402a188 	.word	0x3402a188

34002754 <app_bqueue_init>:
 */

#include "app_bqueue.h"

void app_bqueue_init(app_bqueue_t *bqueue, uint8_t buffer_nb, uint8_t **buffers)
{
34002754:	b580      	push	{r7, lr}
34002756:	b086      	sub	sp, #24
34002758:	af00      	add	r7, sp, #0
3400275a:	60f8      	str	r0, [r7, #12]
3400275c:	460b      	mov	r3, r1
3400275e:	607a      	str	r2, [r7, #4]
34002760:	72fb      	strb	r3, [r7, #11]
    uint8_t i;

    tx_semaphore_create(&bqueue->free, NULL, buffer_nb);
34002762:	68f8      	ldr	r0, [r7, #12]
34002764:	7afa      	ldrb	r2, [r7, #11]
34002766:	2320      	movs	r3, #32
34002768:	2100      	movs	r1, #0
3400276a:	f021 f80b 	bl	34023784 <_txe_semaphore_create>
    tx_semaphore_create(&bqueue->ready, NULL, 0);
3400276e:	68fb      	ldr	r3, [r7, #12]
34002770:	f103 0020 	add.w	r0, r3, #32
34002774:	2320      	movs	r3, #32
34002776:	2200      	movs	r2, #0
34002778:	2100      	movs	r1, #0
3400277a:	f021 f803 	bl	34023784 <_txe_semaphore_create>

    bqueue->buffer_nb = buffer_nb;
3400277e:	68fb      	ldr	r3, [r7, #12]
34002780:	7afa      	ldrb	r2, [r7, #11]
34002782:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    for (i = 0; i < buffer_nb; i++)
34002786:	2300      	movs	r3, #0
34002788:	75fb      	strb	r3, [r7, #23]
3400278a:	e00d      	b.n	340027a8 <app_bqueue_init+0x54>
    {
        bqueue->buffers[i] = buffers[i];
3400278c:	7dfb      	ldrb	r3, [r7, #23]
3400278e:	009b      	lsls	r3, r3, #2
34002790:	687a      	ldr	r2, [r7, #4]
34002792:	441a      	add	r2, r3
34002794:	7dfb      	ldrb	r3, [r7, #23]
34002796:	6812      	ldr	r2, [r2, #0]
34002798:	68f9      	ldr	r1, [r7, #12]
3400279a:	3310      	adds	r3, #16
3400279c:	009b      	lsls	r3, r3, #2
3400279e:	440b      	add	r3, r1
340027a0:	605a      	str	r2, [r3, #4]
    for (i = 0; i < buffer_nb; i++)
340027a2:	7dfb      	ldrb	r3, [r7, #23]
340027a4:	3301      	adds	r3, #1
340027a6:	75fb      	strb	r3, [r7, #23]
340027a8:	7dfa      	ldrb	r2, [r7, #23]
340027aa:	7afb      	ldrb	r3, [r7, #11]
340027ac:	429a      	cmp	r2, r3
340027ae:	d3ed      	bcc.n	3400278c <app_bqueue_init+0x38>
    }
    bqueue->free_idx = 0;
340027b0:	68fb      	ldr	r3, [r7, #12]
340027b2:	2200      	movs	r2, #0
340027b4:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
    bqueue->ready_idx = 0;
340027b8:	68fb      	ldr	r3, [r7, #12]
340027ba:	2200      	movs	r2, #0
340027bc:	f883 204d 	strb.w	r2, [r3, #77]	@ 0x4d
}
340027c0:	bf00      	nop
340027c2:	3718      	adds	r7, #24
340027c4:	46bd      	mov	sp, r7
340027c6:	bd80      	pop	{r7, pc}

340027c8 <app_bqueue_get_free>:

uint8_t *app_bqueue_get_free(app_bqueue_t *bqueue, uint8_t is_blocking)
{
340027c8:	b580      	push	{r7, lr}
340027ca:	b084      	sub	sp, #16
340027cc:	af00      	add	r7, sp, #0
340027ce:	6078      	str	r0, [r7, #4]
340027d0:	460b      	mov	r3, r1
340027d2:	70fb      	strb	r3, [r7, #3]
    uint8_t *free;

    if (tx_semaphore_get(&bqueue->free, is_blocking ? TX_WAIT_FOREVER : TX_NO_WAIT) == TX_NO_INSTANCE)
340027d4:	687a      	ldr	r2, [r7, #4]
340027d6:	78fb      	ldrb	r3, [r7, #3]
340027d8:	2b00      	cmp	r3, #0
340027da:	d002      	beq.n	340027e2 <app_bqueue_get_free+0x1a>
340027dc:	f04f 33ff 	mov.w	r3, #4294967295
340027e0:	e000      	b.n	340027e4 <app_bqueue_get_free+0x1c>
340027e2:	2300      	movs	r3, #0
340027e4:	4619      	mov	r1, r3
340027e6:	4610      	mov	r0, r2
340027e8:	f021 f8a0 	bl	3402392c <_txe_semaphore_get>
340027ec:	4603      	mov	r3, r0
340027ee:	2b0d      	cmp	r3, #13
340027f0:	d101      	bne.n	340027f6 <app_bqueue_get_free+0x2e>
    {
        return NULL;
340027f2:	2300      	movs	r3, #0
340027f4:	e019      	b.n	3400282a <app_bqueue_get_free+0x62>
    }

    free = bqueue->buffers[bqueue->free_idx];
340027f6:	687b      	ldr	r3, [r7, #4]
340027f8:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
340027fc:	687a      	ldr	r2, [r7, #4]
340027fe:	3310      	adds	r3, #16
34002800:	009b      	lsls	r3, r3, #2
34002802:	4413      	add	r3, r2
34002804:	685b      	ldr	r3, [r3, #4]
34002806:	60fb      	str	r3, [r7, #12]
    bqueue->free_idx = (bqueue->free_idx + 1) % bqueue->buffer_nb;
34002808:	687b      	ldr	r3, [r7, #4]
3400280a:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
3400280e:	3301      	adds	r3, #1
34002810:	687a      	ldr	r2, [r7, #4]
34002812:	f892 2040 	ldrb.w	r2, [r2, #64]	@ 0x40
34002816:	fb93 f1f2 	sdiv	r1, r3, r2
3400281a:	fb01 f202 	mul.w	r2, r1, r2
3400281e:	1a9b      	subs	r3, r3, r2
34002820:	b2da      	uxtb	r2, r3
34002822:	687b      	ldr	r3, [r7, #4]
34002824:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    return free;
34002828:	68fb      	ldr	r3, [r7, #12]
}
3400282a:	4618      	mov	r0, r3
3400282c:	3710      	adds	r7, #16
3400282e:	46bd      	mov	sp, r7
34002830:	bd80      	pop	{r7, pc}

34002832 <app_bqueue_put_free>:

void app_bqueue_put_free(app_bqueue_t *bqueue)
{
34002832:	b580      	push	{r7, lr}
34002834:	b082      	sub	sp, #8
34002836:	af00      	add	r7, sp, #0
34002838:	6078      	str	r0, [r7, #4]
    tx_semaphore_put(&bqueue->free);
3400283a:	687b      	ldr	r3, [r7, #4]
3400283c:	4618      	mov	r0, r3
3400283e:	f021 f8b7 	bl	340239b0 <_txe_semaphore_put>
}
34002842:	bf00      	nop
34002844:	3708      	adds	r7, #8
34002846:	46bd      	mov	sp, r7
34002848:	bd80      	pop	{r7, pc}

3400284a <app_bqueue_get_ready>:

uint8_t *app_bqueue_get_ready(app_bqueue_t *bqueue)
{
3400284a:	b580      	push	{r7, lr}
3400284c:	b084      	sub	sp, #16
3400284e:	af00      	add	r7, sp, #0
34002850:	6078      	str	r0, [r7, #4]
    uint8_t *ready;

    tx_semaphore_get(&bqueue->ready, TX_WAIT_FOREVER);
34002852:	687b      	ldr	r3, [r7, #4]
34002854:	3320      	adds	r3, #32
34002856:	f04f 31ff 	mov.w	r1, #4294967295
3400285a:	4618      	mov	r0, r3
3400285c:	f021 f866 	bl	3402392c <_txe_semaphore_get>

    ready = bqueue->buffers[bqueue->ready_idx];
34002860:	687b      	ldr	r3, [r7, #4]
34002862:	f893 304d 	ldrb.w	r3, [r3, #77]	@ 0x4d
34002866:	687a      	ldr	r2, [r7, #4]
34002868:	3310      	adds	r3, #16
3400286a:	009b      	lsls	r3, r3, #2
3400286c:	4413      	add	r3, r2
3400286e:	685b      	ldr	r3, [r3, #4]
34002870:	60fb      	str	r3, [r7, #12]
    bqueue->ready_idx = (bqueue->ready_idx + 1) % bqueue->buffer_nb;
34002872:	687b      	ldr	r3, [r7, #4]
34002874:	f893 304d 	ldrb.w	r3, [r3, #77]	@ 0x4d
34002878:	3301      	adds	r3, #1
3400287a:	687a      	ldr	r2, [r7, #4]
3400287c:	f892 2040 	ldrb.w	r2, [r2, #64]	@ 0x40
34002880:	fb93 f1f2 	sdiv	r1, r3, r2
34002884:	fb01 f202 	mul.w	r2, r1, r2
34002888:	1a9b      	subs	r3, r3, r2
3400288a:	b2da      	uxtb	r2, r3
3400288c:	687b      	ldr	r3, [r7, #4]
3400288e:	f883 204d 	strb.w	r2, [r3, #77]	@ 0x4d

    return ready;
34002892:	68fb      	ldr	r3, [r7, #12]
}
34002894:	4618      	mov	r0, r3
34002896:	3710      	adds	r7, #16
34002898:	46bd      	mov	sp, r7
3400289a:	bd80      	pop	{r7, pc}

3400289c <app_bqueue_put_ready>:

void app_bqueue_put_ready(app_bqueue_t *bqueue)
{
3400289c:	b580      	push	{r7, lr}
3400289e:	b082      	sub	sp, #8
340028a0:	af00      	add	r7, sp, #0
340028a2:	6078      	str	r0, [r7, #4]
    tx_semaphore_put(&bqueue->ready);
340028a4:	687b      	ldr	r3, [r7, #4]
340028a6:	3320      	adds	r3, #32
340028a8:	4618      	mov	r0, r3
340028aa:	f021 f881 	bl	340239b0 <_txe_semaphore_put>
}
340028ae:	bf00      	nop
340028b0:	3708      	adds	r7, #8
340028b2:	46bd      	mov	sp, r7
340028b4:	bd80      	pop	{r7, pc}
	...

340028b8 <app_camera_init>:
static void (*app_camera_display_pipe_frame_user_cb)(void) = NULL;
static void (*app_camera_nn_pipe_vsync_user_cb)(void) = NULL;
static void (*app_camera_nn_pipe_frame_user_cb)(void) = NULL;

void app_camera_init(void (*display_pipe_vsync_cb)(void), void (*display_pipe_frame_cb)(void), void (*nn_pipe_vsync_cb)(void), void (*nn_pipe_frame_cb)(void))
{
340028b8:	b580      	push	{r7, lr}
340028ba:	b08a      	sub	sp, #40	@ 0x28
340028bc:	af00      	add	r7, sp, #0
340028be:	60f8      	str	r0, [r7, #12]
340028c0:	60b9      	str	r1, [r7, #8]
340028c2:	607a      	str	r2, [r7, #4]
340028c4:	603b      	str	r3, [r7, #0]
    CMW_CameraInit_t cmw_camera_init = {0};
340028c6:	f107 0310 	add.w	r3, r7, #16
340028ca:	2200      	movs	r2, #0
340028cc:	601a      	str	r2, [r3, #0]
340028ce:	605a      	str	r2, [r3, #4]
340028d0:	609a      	str	r2, [r3, #8]
340028d2:	60da      	str	r2, [r3, #12]
340028d4:	611a      	str	r2, [r3, #16]
340028d6:	615a      	str	r2, [r3, #20]

    cmw_camera_init.width = 0;
340028d8:	2300      	movs	r3, #0
340028da:	613b      	str	r3, [r7, #16]
    cmw_camera_init.height = 0;
340028dc:	2300      	movs	r3, #0
340028de:	617b      	str	r3, [r7, #20]
    cmw_camera_init.fps = 0;
340028e0:	2300      	movs	r3, #0
340028e2:	61bb      	str	r3, [r7, #24]
    cmw_camera_init.pixel_format = 0;
340028e4:	2300      	movs	r3, #0
340028e6:	61fb      	str	r3, [r7, #28]
    cmw_camera_init.anti_flicker = 0;
340028e8:	2300      	movs	r3, #0
340028ea:	623b      	str	r3, [r7, #32]
    cmw_camera_init.mirror_flip = CAMERA_MIRROR_FLIP;
340028ec:	2302      	movs	r3, #2
340028ee:	627b      	str	r3, [r7, #36]	@ 0x24
    CMW_CAMERA_Init(&cmw_camera_init);
340028f0:	f107 0310 	add.w	r3, r7, #16
340028f4:	4618      	mov	r0, r3
340028f6:	f019 f827 	bl	3401b948 <CMW_CAMERA_Init>

    app_camera_display_pipe_init(cmw_camera_init.width, cmw_camera_init.height);
340028fa:	693b      	ldr	r3, [r7, #16]
340028fc:	697a      	ldr	r2, [r7, #20]
340028fe:	4611      	mov	r1, r2
34002900:	4618      	mov	r0, r3
34002902:	f000 f86b 	bl	340029dc <app_camera_display_pipe_init>
    app_camera_nn_pipe_init(cmw_camera_init.width, cmw_camera_init.height);
34002906:	693b      	ldr	r3, [r7, #16]
34002908:	697a      	ldr	r2, [r7, #20]
3400290a:	4611      	mov	r1, r2
3400290c:	4618      	mov	r0, r3
3400290e:	f000 f895 	bl	34002a3c <app_camera_nn_pipe_init>

    if (display_pipe_vsync_cb != NULL)
34002912:	68fb      	ldr	r3, [r7, #12]
34002914:	2b00      	cmp	r3, #0
34002916:	d002      	beq.n	3400291e <app_camera_init+0x66>
    {
        app_camera_display_pipe_vsync_user_cb = display_pipe_vsync_cb;
34002918:	4a0c      	ldr	r2, [pc, #48]	@ (3400294c <app_camera_init+0x94>)
3400291a:	68fb      	ldr	r3, [r7, #12]
3400291c:	6013      	str	r3, [r2, #0]
    }

    if (display_pipe_frame_cb != NULL)
3400291e:	68bb      	ldr	r3, [r7, #8]
34002920:	2b00      	cmp	r3, #0
34002922:	d002      	beq.n	3400292a <app_camera_init+0x72>
    {
        app_camera_display_pipe_frame_user_cb = display_pipe_frame_cb;
34002924:	4a0a      	ldr	r2, [pc, #40]	@ (34002950 <app_camera_init+0x98>)
34002926:	68bb      	ldr	r3, [r7, #8]
34002928:	6013      	str	r3, [r2, #0]
    }

    if (nn_pipe_vsync_cb != NULL)
3400292a:	687b      	ldr	r3, [r7, #4]
3400292c:	2b00      	cmp	r3, #0
3400292e:	d002      	beq.n	34002936 <app_camera_init+0x7e>
    {
        app_camera_nn_pipe_vsync_user_cb = nn_pipe_vsync_cb;
34002930:	4a08      	ldr	r2, [pc, #32]	@ (34002954 <app_camera_init+0x9c>)
34002932:	687b      	ldr	r3, [r7, #4]
34002934:	6013      	str	r3, [r2, #0]
    }

    if (nn_pipe_frame_cb != NULL)
34002936:	683b      	ldr	r3, [r7, #0]
34002938:	2b00      	cmp	r3, #0
3400293a:	d002      	beq.n	34002942 <app_camera_init+0x8a>
    {
        app_camera_nn_pipe_frame_user_cb = nn_pipe_frame_cb;
3400293c:	4a06      	ldr	r2, [pc, #24]	@ (34002958 <app_camera_init+0xa0>)
3400293e:	683b      	ldr	r3, [r7, #0]
34002940:	6013      	str	r3, [r2, #0]
    }
}
34002942:	bf00      	nop
34002944:	3728      	adds	r7, #40	@ 0x28
34002946:	46bd      	mov	sp, r7
34002948:	bd80      	pop	{r7, pc}
3400294a:	bf00      	nop
3400294c:	34048dd0 	.word	0x34048dd0
34002950:	34048dd4 	.word	0x34048dd4
34002954:	34048dd8 	.word	0x34048dd8
34002958:	34048ddc 	.word	0x34048ddc

3400295c <app_camera_display_pipe_start>:

void app_camera_display_pipe_start(uint8_t *display_pipe_destination, uint32_t capture_mode)
{
3400295c:	b580      	push	{r7, lr}
3400295e:	b082      	sub	sp, #8
34002960:	af00      	add	r7, sp, #0
34002962:	6078      	str	r0, [r7, #4]
34002964:	6039      	str	r1, [r7, #0]
    CMW_CAMERA_Start(DCMIPP_PIPE1, display_pipe_destination, capture_mode);
34002966:	683a      	ldr	r2, [r7, #0]
34002968:	6879      	ldr	r1, [r7, #4]
3400296a:	2001      	movs	r0, #1
3400296c:	f019 f882 	bl	3401ba74 <CMW_CAMERA_Start>
}
34002970:	bf00      	nop
34002972:	3708      	adds	r7, #8
34002974:	46bd      	mov	sp, r7
34002976:	bd80      	pop	{r7, pc}

34002978 <app_camera_display_pipe_set_address>:

void app_camera_display_pipe_set_address(uint8_t *display_pipe_destination)
{
34002978:	b580      	push	{r7, lr}
3400297a:	b082      	sub	sp, #8
3400297c:	af00      	add	r7, sp, #0
3400297e:	6078      	str	r0, [r7, #4]
    HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE1, DCMIPP_MEMORY_ADDRESS_0, (uint32_t)display_pipe_destination);
34002980:	f018 ffac 	bl	3401b8dc <CMW_CAMERA_GetDCMIPPHandle>
34002984:	687b      	ldr	r3, [r7, #4]
34002986:	2200      	movs	r2, #0
34002988:	2101      	movs	r1, #1
3400298a:	f006 ffa5 	bl	340098d8 <HAL_DCMIPP_PIPE_SetMemoryAddress>
}
3400298e:	bf00      	nop
34002990:	3708      	adds	r7, #8
34002992:	46bd      	mov	sp, r7
34002994:	bd80      	pop	{r7, pc}

34002996 <app_camera_nn_pipe_start>:

void app_camera_nn_pipe_start(uint8_t *nn_pipe_destination, uint32_t capture_mode)
{
34002996:	b580      	push	{r7, lr}
34002998:	b082      	sub	sp, #8
3400299a:	af00      	add	r7, sp, #0
3400299c:	6078      	str	r0, [r7, #4]
3400299e:	6039      	str	r1, [r7, #0]
    CMW_CAMERA_Start(DCMIPP_PIPE2, nn_pipe_destination, capture_mode);
340029a0:	683a      	ldr	r2, [r7, #0]
340029a2:	6879      	ldr	r1, [r7, #4]
340029a4:	2002      	movs	r0, #2
340029a6:	f019 f865 	bl	3401ba74 <CMW_CAMERA_Start>
}
340029aa:	bf00      	nop
340029ac:	3708      	adds	r7, #8
340029ae:	46bd      	mov	sp, r7
340029b0:	bd80      	pop	{r7, pc}

340029b2 <app_camera_nn_pipe_set_address>:

void app_camera_nn_pipe_set_address(uint8_t *nn_pipe_destination)
{
340029b2:	b580      	push	{r7, lr}
340029b4:	b082      	sub	sp, #8
340029b6:	af00      	add	r7, sp, #0
340029b8:	6078      	str	r0, [r7, #4]
    HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2, DCMIPP_MEMORY_ADDRESS_0, (uint32_t)nn_pipe_destination);
340029ba:	f018 ff8f 	bl	3401b8dc <CMW_CAMERA_GetDCMIPPHandle>
340029be:	687b      	ldr	r3, [r7, #4]
340029c0:	2200      	movs	r2, #0
340029c2:	2102      	movs	r1, #2
340029c4:	f006 ff88 	bl	340098d8 <HAL_DCMIPP_PIPE_SetMemoryAddress>
}
340029c8:	bf00      	nop
340029ca:	3708      	adds	r7, #8
340029cc:	46bd      	mov	sp, r7
340029ce:	bd80      	pop	{r7, pc}

340029d0 <app_camera_isp_update>:

void app_camera_isp_update(void)
{
340029d0:	b580      	push	{r7, lr}
340029d2:	af00      	add	r7, sp, #0
    CMW_CAMERA_Run();
340029d4:	f019 f91e 	bl	3401bc14 <CMW_CAMERA_Run>
}
340029d8:	bf00      	nop
340029da:	bd80      	pop	{r7, pc}

340029dc <app_camera_display_pipe_init>:

static void app_camera_display_pipe_init(uint32_t sensor_width, uint32_t sensor_height)
{
340029dc:	b580      	push	{r7, lr}
340029de:	b08e      	sub	sp, #56	@ 0x38
340029e0:	af00      	add	r7, sp, #0
340029e2:	6078      	str	r0, [r7, #4]
340029e4:	6039      	str	r1, [r7, #0]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
340029e6:	f107 030c 	add.w	r3, r7, #12
340029ea:	222c      	movs	r2, #44	@ 0x2c
340029ec:	2100      	movs	r1, #0
340029ee:	4618      	mov	r0, r3
340029f0:	f024 fbd0 	bl	34027194 <memset>
    uint32_t hw_pitch;

    cmw_dcmipp_conf.output_width = LCD_BG_WIDTH;
340029f4:	f44f 7348 	mov.w	r3, #800	@ 0x320
340029f8:	60fb      	str	r3, [r7, #12]
    cmw_dcmipp_conf.output_height = LCD_BG_HEIGHT;
340029fa:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
340029fe:	613b      	str	r3, [r7, #16]
    cmw_dcmipp_conf.output_format = DCMIPP_PIXEL_PACKER_FORMAT_RGB565_1;
34002a00:	2301      	movs	r3, #1
34002a02:	617b      	str	r3, [r7, #20]
    cmw_dcmipp_conf.output_bpp = 2;
34002a04:	2302      	movs	r3, #2
34002a06:	61bb      	str	r3, [r7, #24]
    cmw_dcmipp_conf.enable_swap = 0;
34002a08:	2300      	movs	r3, #0
34002a0a:	61fb      	str	r3, [r7, #28]
    cmw_dcmipp_conf.enable_gamma_conversion = 0;
34002a0c:	2300      	movs	r3, #0
34002a0e:	623b      	str	r3, [r7, #32]
    cmw_dcmipp_conf.mode = CMW_Aspect_ratio_manual_roi;
34002a10:	2303      	movs	r3, #3
34002a12:	627b      	str	r3, [r7, #36]	@ 0x24
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34002a14:	f107 030c 	add.w	r3, r7, #12
34002a18:	331c      	adds	r3, #28
34002a1a:	683a      	ldr	r2, [r7, #0]
34002a1c:	6879      	ldr	r1, [r7, #4]
34002a1e:	4618      	mov	r0, r3
34002a20:	f000 f83a 	bl	34002a98 <app_camera_init_crop_config>
    CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE1, &cmw_dcmipp_conf, &hw_pitch);
34002a24:	f107 0208 	add.w	r2, r7, #8
34002a28:	f107 030c 	add.w	r3, r7, #12
34002a2c:	4619      	mov	r1, r3
34002a2e:	2001      	movs	r0, #1
34002a30:	f018 ff5e 	bl	3401b8f0 <CMW_CAMERA_SetPipeConfig>
}
34002a34:	bf00      	nop
34002a36:	3738      	adds	r7, #56	@ 0x38
34002a38:	46bd      	mov	sp, r7
34002a3a:	bd80      	pop	{r7, pc}

34002a3c <app_camera_nn_pipe_init>:

static void app_camera_nn_pipe_init(uint32_t sensor_width, uint32_t sensor_height)
{
34002a3c:	b580      	push	{r7, lr}
34002a3e:	b08e      	sub	sp, #56	@ 0x38
34002a40:	af00      	add	r7, sp, #0
34002a42:	6078      	str	r0, [r7, #4]
34002a44:	6039      	str	r1, [r7, #0]
    CMW_DCMIPP_Conf_t cmw_dcmipp_conf = {0};
34002a46:	f107 030c 	add.w	r3, r7, #12
34002a4a:	222c      	movs	r2, #44	@ 0x2c
34002a4c:	2100      	movs	r1, #0
34002a4e:	4618      	mov	r0, r3
34002a50:	f024 fba0 	bl	34027194 <memset>
    uint32_t hw_pitch;

    cmw_dcmipp_conf.output_width = NN_WIDTH;
34002a54:	23e0      	movs	r3, #224	@ 0xe0
34002a56:	60fb      	str	r3, [r7, #12]
    cmw_dcmipp_conf.output_height = NN_HEIGHT;
34002a58:	23e0      	movs	r3, #224	@ 0xe0
34002a5a:	613b      	str	r3, [r7, #16]
    cmw_dcmipp_conf.output_format = NN_FORMAT;
34002a5c:	2300      	movs	r3, #0
34002a5e:	617b      	str	r3, [r7, #20]
    cmw_dcmipp_conf.output_bpp = NN_BPP;
34002a60:	2303      	movs	r3, #3
34002a62:	61bb      	str	r3, [r7, #24]
    cmw_dcmipp_conf.enable_swap = 1;
34002a64:	2301      	movs	r3, #1
34002a66:	61fb      	str	r3, [r7, #28]
    cmw_dcmipp_conf.enable_gamma_conversion = 0;
34002a68:	2300      	movs	r3, #0
34002a6a:	623b      	str	r3, [r7, #32]
    cmw_dcmipp_conf.mode = CMW_Aspect_ratio_manual_roi;
34002a6c:	2303      	movs	r3, #3
34002a6e:	627b      	str	r3, [r7, #36]	@ 0x24
    app_camera_init_crop_config(&cmw_dcmipp_conf.manual_conf, sensor_width, sensor_height);
34002a70:	f107 030c 	add.w	r3, r7, #12
34002a74:	331c      	adds	r3, #28
34002a76:	683a      	ldr	r2, [r7, #0]
34002a78:	6879      	ldr	r1, [r7, #4]
34002a7a:	4618      	mov	r0, r3
34002a7c:	f000 f80c 	bl	34002a98 <app_camera_init_crop_config>
    CMW_CAMERA_SetPipeConfig(DCMIPP_PIPE2, &cmw_dcmipp_conf, &hw_pitch);
34002a80:	f107 0208 	add.w	r2, r7, #8
34002a84:	f107 030c 	add.w	r3, r7, #12
34002a88:	4619      	mov	r1, r3
34002a8a:	2002      	movs	r0, #2
34002a8c:	f018 ff30 	bl	3401b8f0 <CMW_CAMERA_SetPipeConfig>
}
34002a90:	bf00      	nop
34002a92:	3738      	adds	r7, #56	@ 0x38
34002a94:	46bd      	mov	sp, r7
34002a96:	bd80      	pop	{r7, pc}

34002a98 <app_camera_init_crop_config>:

static void app_camera_init_crop_config(CMW_Manual_roi_area_t *roi, uint32_t sensor_width, uint32_t sensor_height)
{
34002a98:	b480      	push	{r7}
34002a9a:	b089      	sub	sp, #36	@ 0x24
34002a9c:	af00      	add	r7, sp, #0
34002a9e:	60f8      	str	r0, [r7, #12]
34002aa0:	60b9      	str	r1, [r7, #8]
34002aa2:	607a      	str	r2, [r7, #4]
    float ratiox;
    float ratioy;
    float ratio;

    ratiox = (float)sensor_width / LCD_BG_WIDTH;
34002aa4:	68bb      	ldr	r3, [r7, #8]
34002aa6:	ee07 3a90 	vmov	s15, r3
34002aaa:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34002aae:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 34002ba4 <app_camera_init_crop_config+0x10c>
34002ab2:	eec7 7a26 	vdiv.f32	s15, s14, s13
34002ab6:	edc7 7a07 	vstr	s15, [r7, #28]
    ratioy = (float)sensor_height / LCD_BG_HEIGHT;
34002aba:	687b      	ldr	r3, [r7, #4]
34002abc:	ee07 3a90 	vmov	s15, r3
34002ac0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34002ac4:	eddf 6a38 	vldr	s13, [pc, #224]	@ 34002ba8 <app_camera_init_crop_config+0x110>
34002ac8:	eec7 7a26 	vdiv.f32	s15, s14, s13
34002acc:	edc7 7a06 	vstr	s15, [r7, #24]
    ratio = MIN(ratiox, ratioy);
34002ad0:	ed97 7a07 	vldr	s14, [r7, #28]
34002ad4:	edd7 7a06 	vldr	s15, [r7, #24]
34002ad8:	eeb4 7ae7 	vcmpe.f32	s14, s15
34002adc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34002ae0:	d501      	bpl.n	34002ae6 <app_camera_init_crop_config+0x4e>
34002ae2:	69fb      	ldr	r3, [r7, #28]
34002ae4:	e000      	b.n	34002ae8 <app_camera_init_crop_config+0x50>
34002ae6:	69bb      	ldr	r3, [r7, #24]
34002ae8:	617b      	str	r3, [r7, #20]

    roi->width = (uint32_t)MIN(LCD_BG_WIDTH * ratio, sensor_width);
34002aea:	edd7 7a05 	vldr	s15, [r7, #20]
34002aee:	ed9f 7a2d 	vldr	s14, [pc, #180]	@ 34002ba4 <app_camera_init_crop_config+0x10c>
34002af2:	ee27 7a87 	vmul.f32	s14, s15, s14
34002af6:	68bb      	ldr	r3, [r7, #8]
34002af8:	ee07 3a90 	vmov	s15, r3
34002afc:	eef8 7a67 	vcvt.f32.u32	s15, s15
34002b00:	eeb4 7ae7 	vcmpe.f32	s14, s15
34002b04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34002b08:	d508      	bpl.n	34002b1c <app_camera_init_crop_config+0x84>
34002b0a:	edd7 7a05 	vldr	s15, [r7, #20]
34002b0e:	ed9f 7a25 	vldr	s14, [pc, #148]	@ 34002ba4 <app_camera_init_crop_config+0x10c>
34002b12:	ee67 7a87 	vmul.f32	s15, s15, s14
34002b16:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34002b1a:	e006      	b.n	34002b2a <app_camera_init_crop_config+0x92>
34002b1c:	68bb      	ldr	r3, [r7, #8]
34002b1e:	ee07 3a90 	vmov	s15, r3
34002b22:	eef8 7a67 	vcvt.f32.u32	s15, s15
34002b26:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34002b2a:	68fb      	ldr	r3, [r7, #12]
34002b2c:	edc3 7a00 	vstr	s15, [r3]
    roi->height = (uint32_t)MIN(LCD_BG_HEIGHT * ratio, sensor_height);
34002b30:	edd7 7a05 	vldr	s15, [r7, #20]
34002b34:	ed9f 7a1c 	vldr	s14, [pc, #112]	@ 34002ba8 <app_camera_init_crop_config+0x110>
34002b38:	ee27 7a87 	vmul.f32	s14, s15, s14
34002b3c:	687b      	ldr	r3, [r7, #4]
34002b3e:	ee07 3a90 	vmov	s15, r3
34002b42:	eef8 7a67 	vcvt.f32.u32	s15, s15
34002b46:	eeb4 7ae7 	vcmpe.f32	s14, s15
34002b4a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34002b4e:	d508      	bpl.n	34002b62 <app_camera_init_crop_config+0xca>
34002b50:	edd7 7a05 	vldr	s15, [r7, #20]
34002b54:	ed9f 7a14 	vldr	s14, [pc, #80]	@ 34002ba8 <app_camera_init_crop_config+0x110>
34002b58:	ee67 7a87 	vmul.f32	s15, s15, s14
34002b5c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34002b60:	e006      	b.n	34002b70 <app_camera_init_crop_config+0xd8>
34002b62:	687b      	ldr	r3, [r7, #4]
34002b64:	ee07 3a90 	vmov	s15, r3
34002b68:	eef8 7a67 	vcvt.f32.u32	s15, s15
34002b6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34002b70:	68fb      	ldr	r3, [r7, #12]
34002b72:	edc3 7a01 	vstr	s15, [r3, #4]
    roi->offset_x = (sensor_width - roi->width + 1) / 2;
34002b76:	68fb      	ldr	r3, [r7, #12]
34002b78:	681b      	ldr	r3, [r3, #0]
34002b7a:	68ba      	ldr	r2, [r7, #8]
34002b7c:	1ad3      	subs	r3, r2, r3
34002b7e:	3301      	adds	r3, #1
34002b80:	085a      	lsrs	r2, r3, #1
34002b82:	68fb      	ldr	r3, [r7, #12]
34002b84:	609a      	str	r2, [r3, #8]
    roi->offset_y = (sensor_height - roi->height + 1) / 2;
34002b86:	68fb      	ldr	r3, [r7, #12]
34002b88:	685b      	ldr	r3, [r3, #4]
34002b8a:	687a      	ldr	r2, [r7, #4]
34002b8c:	1ad3      	subs	r3, r2, r3
34002b8e:	3301      	adds	r3, #1
34002b90:	085a      	lsrs	r2, r3, #1
34002b92:	68fb      	ldr	r3, [r7, #12]
34002b94:	60da      	str	r2, [r3, #12]
}
34002b96:	bf00      	nop
34002b98:	3724      	adds	r7, #36	@ 0x24
34002b9a:	46bd      	mov	sp, r7
34002b9c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ba0:	4770      	bx	lr
34002ba2:	bf00      	nop
34002ba4:	44480000 	.word	0x44480000
34002ba8:	43f00000 	.word	0x43f00000

34002bac <MX_DCMIPP_ClockConfig>:

HAL_StatusTypeDef MX_DCMIPP_ClockConfig(DCMIPP_HandleTypeDef *hdcmipp)
{
34002bac:	b580      	push	{r7, lr}
34002bae:	b0e6      	sub	sp, #408	@ 0x198
34002bb0:	af00      	add	r7, sp, #0
34002bb2:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002bb6:	f5a3 73ca 	sub.w	r3, r3, #404	@ 0x194
34002bba:	6018      	str	r0, [r3, #0]
    RCC_PeriphCLKInitTypeDef rcc_periph_clk_init_struct = {0};
34002bbc:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002bc0:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002bc4:	4618      	mov	r0, r3
34002bc6:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34002bca:	461a      	mov	r2, r3
34002bcc:	2100      	movs	r1, #0
34002bce:	f024 fae1 	bl	34027194 <memset>

    rcc_periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_DCMIPP | RCC_PERIPHCLK_CSI;
34002bd2:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002bd6:	f5a3 71c8 	sub.w	r1, r3, #400	@ 0x190
34002bda:	f04f 0218 	mov.w	r2, #24
34002bde:	f04f 0300 	mov.w	r3, #0
34002be2:	e9c1 2300 	strd	r2, r3, [r1]
    rcc_periph_clk_init_struct.DcmippClockSelection = RCC_DCMIPPCLKSOURCE_IC17;
34002be6:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002bea:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002bee:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34002bf2:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
    rcc_periph_clk_init_struct.ICSelection[RCC_IC17].ClockSelection = RCC_ICCLKSOURCE_PLL2;
34002bf6:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002bfa:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002bfe:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34002c02:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    rcc_periph_clk_init_struct.ICSelection[RCC_IC17].ClockDivider = 3;
34002c06:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002c0a:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002c0e:	2203      	movs	r2, #3
34002c10:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
    rcc_periph_clk_init_struct.ICSelection[RCC_IC18].ClockSelection = RCC_ICCLKSOURCE_PLL1;
34002c14:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002c18:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002c1c:	2200      	movs	r2, #0
34002c1e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    rcc_periph_clk_init_struct.ICSelection[RCC_IC18].ClockDivider = 40;
34002c22:	f507 73cc 	add.w	r3, r7, #408	@ 0x198
34002c26:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
34002c2a:	2228      	movs	r2, #40	@ 0x28
34002c2c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&rcc_periph_clk_init_struct) != HAL_OK)
34002c30:	f107 0308 	add.w	r3, r7, #8
34002c34:	4618      	mov	r0, r3
34002c36:	f00d fe9b 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
34002c3a:	4603      	mov	r3, r0
34002c3c:	2b00      	cmp	r3, #0
34002c3e:	d001      	beq.n	34002c44 <MX_DCMIPP_ClockConfig+0x98>
    {
        return HAL_ERROR;
34002c40:	2301      	movs	r3, #1
34002c42:	e000      	b.n	34002c46 <MX_DCMIPP_ClockConfig+0x9a>
    }

    return HAL_OK;
34002c44:	2300      	movs	r3, #0
}
34002c46:	4618      	mov	r0, r3
34002c48:	f507 77cc 	add.w	r7, r7, #408	@ 0x198
34002c4c:	46bd      	mov	sp, r7
34002c4e:	bd80      	pop	{r7, pc}

34002c50 <CMW_CAMERA_PIPE_VsyncEventCallback>:

int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
{
34002c50:	b580      	push	{r7, lr}
34002c52:	b082      	sub	sp, #8
34002c54:	af00      	add	r7, sp, #0
34002c56:	6078      	str	r0, [r7, #4]
    if (pipe == DCMIPP_PIPE1)
34002c58:	687b      	ldr	r3, [r7, #4]
34002c5a:	2b01      	cmp	r3, #1
34002c5c:	d107      	bne.n	34002c6e <CMW_CAMERA_PIPE_VsyncEventCallback+0x1e>
    {
        if (app_camera_display_pipe_vsync_user_cb != NULL)
34002c5e:	4b0b      	ldr	r3, [pc, #44]	@ (34002c8c <CMW_CAMERA_PIPE_VsyncEventCallback+0x3c>)
34002c60:	681b      	ldr	r3, [r3, #0]
34002c62:	2b00      	cmp	r3, #0
34002c64:	d00d      	beq.n	34002c82 <CMW_CAMERA_PIPE_VsyncEventCallback+0x32>
        {
            app_camera_display_pipe_vsync_user_cb();
34002c66:	4b09      	ldr	r3, [pc, #36]	@ (34002c8c <CMW_CAMERA_PIPE_VsyncEventCallback+0x3c>)
34002c68:	681b      	ldr	r3, [r3, #0]
34002c6a:	4798      	blx	r3
34002c6c:	e009      	b.n	34002c82 <CMW_CAMERA_PIPE_VsyncEventCallback+0x32>
        }
    }
    else if (pipe == DCMIPP_PIPE2)
34002c6e:	687b      	ldr	r3, [r7, #4]
34002c70:	2b02      	cmp	r3, #2
34002c72:	d106      	bne.n	34002c82 <CMW_CAMERA_PIPE_VsyncEventCallback+0x32>
    {
        if (app_camera_nn_pipe_vsync_user_cb != NULL)
34002c74:	4b06      	ldr	r3, [pc, #24]	@ (34002c90 <CMW_CAMERA_PIPE_VsyncEventCallback+0x40>)
34002c76:	681b      	ldr	r3, [r3, #0]
34002c78:	2b00      	cmp	r3, #0
34002c7a:	d002      	beq.n	34002c82 <CMW_CAMERA_PIPE_VsyncEventCallback+0x32>
        {
            app_camera_nn_pipe_vsync_user_cb();
34002c7c:	4b04      	ldr	r3, [pc, #16]	@ (34002c90 <CMW_CAMERA_PIPE_VsyncEventCallback+0x40>)
34002c7e:	681b      	ldr	r3, [r3, #0]
34002c80:	4798      	blx	r3
        }
    }

    return 0;
34002c82:	2300      	movs	r3, #0
}
34002c84:	4618      	mov	r0, r3
34002c86:	3708      	adds	r7, #8
34002c88:	46bd      	mov	sp, r7
34002c8a:	bd80      	pop	{r7, pc}
34002c8c:	34048dd0 	.word	0x34048dd0
34002c90:	34048dd8 	.word	0x34048dd8

34002c94 <CMW_CAMERA_PIPE_FrameEventCallback>:

int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
{
34002c94:	b580      	push	{r7, lr}
34002c96:	b082      	sub	sp, #8
34002c98:	af00      	add	r7, sp, #0
34002c9a:	6078      	str	r0, [r7, #4]
    if (pipe == DCMIPP_PIPE1)
34002c9c:	687b      	ldr	r3, [r7, #4]
34002c9e:	2b01      	cmp	r3, #1
34002ca0:	d107      	bne.n	34002cb2 <CMW_CAMERA_PIPE_FrameEventCallback+0x1e>
    {
        if (app_camera_display_pipe_frame_user_cb != NULL)
34002ca2:	4b0b      	ldr	r3, [pc, #44]	@ (34002cd0 <CMW_CAMERA_PIPE_FrameEventCallback+0x3c>)
34002ca4:	681b      	ldr	r3, [r3, #0]
34002ca6:	2b00      	cmp	r3, #0
34002ca8:	d00d      	beq.n	34002cc6 <CMW_CAMERA_PIPE_FrameEventCallback+0x32>
        {
            app_camera_display_pipe_frame_user_cb();
34002caa:	4b09      	ldr	r3, [pc, #36]	@ (34002cd0 <CMW_CAMERA_PIPE_FrameEventCallback+0x3c>)
34002cac:	681b      	ldr	r3, [r3, #0]
34002cae:	4798      	blx	r3
34002cb0:	e009      	b.n	34002cc6 <CMW_CAMERA_PIPE_FrameEventCallback+0x32>
        }
    }
    else if (pipe == DCMIPP_PIPE2)
34002cb2:	687b      	ldr	r3, [r7, #4]
34002cb4:	2b02      	cmp	r3, #2
34002cb6:	d106      	bne.n	34002cc6 <CMW_CAMERA_PIPE_FrameEventCallback+0x32>
    {
        if (app_camera_nn_pipe_frame_user_cb != NULL)
34002cb8:	4b06      	ldr	r3, [pc, #24]	@ (34002cd4 <CMW_CAMERA_PIPE_FrameEventCallback+0x40>)
34002cba:	681b      	ldr	r3, [r3, #0]
34002cbc:	2b00      	cmp	r3, #0
34002cbe:	d002      	beq.n	34002cc6 <CMW_CAMERA_PIPE_FrameEventCallback+0x32>
        {
            app_camera_nn_pipe_frame_user_cb();
34002cc0:	4b04      	ldr	r3, [pc, #16]	@ (34002cd4 <CMW_CAMERA_PIPE_FrameEventCallback+0x40>)
34002cc2:	681b      	ldr	r3, [r3, #0]
34002cc4:	4798      	blx	r3
        }
    }

    return 0;
34002cc6:	2300      	movs	r3, #0
}
34002cc8:	4618      	mov	r0, r3
34002cca:	3708      	adds	r7, #8
34002ccc:	46bd      	mov	sp, r7
34002cce:	bd80      	pop	{r7, pc}
34002cd0:	34048dd4 	.word	0x34048dd4
34002cd4:	34048ddc 	.word	0x34048ddc

34002cd8 <app_cpuload_init>:
#include "app_cpuload.h"
#include "tx_api.h"
#include <string.h>

void app_cpuload_init(app_cpuload_t *cpuload)
{
34002cd8:	b580      	push	{r7, lr}
34002cda:	b082      	sub	sp, #8
34002cdc:	af00      	add	r7, sp, #0
34002cde:	6078      	str	r0, [r7, #4]
    CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
34002ce0:	4b07      	ldr	r3, [pc, #28]	@ (34002d00 <app_cpuload_init+0x28>)
34002ce2:	68db      	ldr	r3, [r3, #12]
34002ce4:	4a06      	ldr	r2, [pc, #24]	@ (34002d00 <app_cpuload_init+0x28>)
34002ce6:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
34002cea:	60d3      	str	r3, [r2, #12]

    memset(cpuload, 0, sizeof(app_cpuload_t));
34002cec:	22e0      	movs	r2, #224	@ 0xe0
34002cee:	2100      	movs	r1, #0
34002cf0:	6878      	ldr	r0, [r7, #4]
34002cf2:	f024 fa4f 	bl	34027194 <memset>
}
34002cf6:	bf00      	nop
34002cf8:	3708      	adds	r7, #8
34002cfa:	46bd      	mov	sp, r7
34002cfc:	bd80      	pop	{r7, pc}
34002cfe:	bf00      	nop
34002d00:	e000edf0 	.word	0xe000edf0

34002d04 <app_cpuload_update>:

void app_cpuload_update(app_cpuload_t *cpuload)
{
34002d04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
34002d08:	b08b      	sub	sp, #44	@ 0x2c
34002d0a:	af00      	add	r7, sp, #0
34002d0c:	6078      	str	r0, [r7, #4]
    EXECUTION_TIME thread_total;
    EXECUTION_TIME isr;
    EXECUTION_TIME idle;
    uint8_t i;

    cpuload->history[1] = cpuload->history[0];
34002d0e:	687a      	ldr	r2, [r7, #4]
34002d10:	687b      	ldr	r3, [r7, #4]
34002d12:	f102 0638 	add.w	r6, r2, #56	@ 0x38
34002d16:	f103 0c20 	add.w	ip, r3, #32
34002d1a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
34002d1e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
34002d20:	e89c 0003 	ldmia.w	ip, {r0, r1}
34002d24:	e886 0003 	stmia.w	r6, {r0, r1}

    _tx_execution_thread_total_time_get(&thread_total);
34002d28:	f107 0318 	add.w	r3, r7, #24
34002d2c:	4618      	mov	r0, r3
34002d2e:	f021 f9a7 	bl	34024080 <_tx_execution_thread_total_time_get>
    _tx_execution_isr_time_get(&isr);
34002d32:	f107 0310 	add.w	r3, r7, #16
34002d36:	4618      	mov	r0, r3
34002d38:	f021 f9b6 	bl	340240a8 <_tx_execution_isr_time_get>
    _tx_execution_idle_time_get(&idle);
34002d3c:	f107 0308 	add.w	r3, r7, #8
34002d40:	4618      	mov	r0, r3
34002d42:	f021 f9c5 	bl	340240d0 <_tx_execution_idle_time_get>

    cpuload->history[0].total = thread_total + isr + idle;
34002d46:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34002d4a:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34002d4e:	1884      	adds	r4, r0, r2
34002d50:	eb41 0503 	adc.w	r5, r1, r3
34002d54:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
34002d58:	eb14 0802 	adds.w	r8, r4, r2
34002d5c:	eb45 0903 	adc.w	r9, r5, r3
34002d60:	687b      	ldr	r3, [r7, #4]
34002d62:	e9c3 8908 	strd	r8, r9, [r3, #32]
    cpuload->history[0].thread = thread_total;
34002d66:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
34002d6a:	6879      	ldr	r1, [r7, #4]
34002d6c:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
    cpuload->history[0].tick = HAL_GetTick();
34002d70:	f001 ff5d 	bl	34004c2e <HAL_GetTick>
34002d74:	4602      	mov	r2, r0
34002d76:	687b      	ldr	r3, [r7, #4]
34002d78:	631a      	str	r2, [r3, #48]	@ 0x30

    if ((cpuload->history[1].tick - cpuload->history[2].tick) < 1000)
34002d7a:	687b      	ldr	r3, [r7, #4]
34002d7c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34002d7e:	687b      	ldr	r3, [r7, #4]
34002d80:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34002d82:	1ad3      	subs	r3, r2, r3
34002d84:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
34002d88:	d32c      	bcc.n	34002de4 <app_cpuload_update+0xe0>
    {
        return;
    }

    for (i = 0; i < CPU_LOAD_HISTORY_DEPTH - 2; i++)
34002d8a:	2300      	movs	r3, #0
34002d8c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
34002d90:	e023      	b.n	34002dda <app_cpuload_update+0xd6>
    {
        cpuload->history[CPU_LOAD_HISTORY_DEPTH - 1 - i] = cpuload->history[CPU_LOAD_HISTORY_DEPTH - 1 - i - 1];
34002d92:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34002d96:	f1c3 0206 	rsb	r2, r3, #6
34002d9a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34002d9e:	f1c3 0107 	rsb	r1, r3, #7
34002da2:	6878      	ldr	r0, [r7, #4]
34002da4:	460b      	mov	r3, r1
34002da6:	005b      	lsls	r3, r3, #1
34002da8:	440b      	add	r3, r1
34002daa:	00db      	lsls	r3, r3, #3
34002dac:	4403      	add	r3, r0
34002dae:	f103 0020 	add.w	r0, r3, #32
34002db2:	6879      	ldr	r1, [r7, #4]
34002db4:	4613      	mov	r3, r2
34002db6:	005b      	lsls	r3, r3, #1
34002db8:	4413      	add	r3, r2
34002dba:	00db      	lsls	r3, r3, #3
34002dbc:	440b      	add	r3, r1
34002dbe:	3320      	adds	r3, #32
34002dc0:	4604      	mov	r4, r0
34002dc2:	461d      	mov	r5, r3
34002dc4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34002dc6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34002dc8:	e895 0003 	ldmia.w	r5, {r0, r1}
34002dcc:	e884 0003 	stmia.w	r4, {r0, r1}
    for (i = 0; i < CPU_LOAD_HISTORY_DEPTH - 2; i++)
34002dd0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34002dd4:	3301      	adds	r3, #1
34002dd6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
34002dda:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34002dde:	2b05      	cmp	r3, #5
34002de0:	d9d7      	bls.n	34002d92 <app_cpuload_update+0x8e>
34002de2:	e000      	b.n	34002de6 <app_cpuload_update+0xe2>
        return;
34002de4:	bf00      	nop
    }
}
34002de6:	372c      	adds	r7, #44	@ 0x2c
34002de8:	46bd      	mov	sp, r7
34002dea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

34002df0 <app_cpuload_get_info>:

void app_cpuload_get_info(app_cpuload_t *cpuload, float *cpuload_last, float *cpuload_last_second, float *cpuload_last_five_seconds)
{
34002df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34002df4:	ed2d 8b02 	vpush	{d8}
34002df8:	b08b      	sub	sp, #44	@ 0x2c
34002dfa:	af00      	add	r7, sp, #0
34002dfc:	6278      	str	r0, [r7, #36]	@ 0x24
34002dfe:	6239      	str	r1, [r7, #32]
34002e00:	61fa      	str	r2, [r7, #28]
34002e02:	61bb      	str	r3, [r7, #24]
    if (cpuload_last != NULL)
34002e04:	6a3b      	ldr	r3, [r7, #32]
34002e06:	2b00      	cmp	r3, #0
34002e08:	d02c      	beq.n	34002e64 <app_cpuload_get_info+0x74>
    {
        *cpuload_last = 100.0 * (cpuload->history[0].thread - cpuload->history[1].thread) / (cpuload->history[0].total - cpuload->history[1].total);
34002e0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e0c:	e9d3 010a 	ldrd	r0, r1, [r3, #40]	@ 0x28
34002e10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e12:	e9d3 2310 	ldrd	r2, r3, [r3, #64]	@ 0x40
34002e16:	1a86      	subs	r6, r0, r2
34002e18:	613e      	str	r6, [r7, #16]
34002e1a:	eb61 0303 	sbc.w	r3, r1, r3
34002e1e:	617b      	str	r3, [r7, #20]
34002e20:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34002e24:	f7fe fe40 	bl	34001aa8 <__aeabi_ul2d>
34002e28:	ec41 0b16 	vmov	d6, r0, r1
34002e2c:	ed9f 7b40 	vldr	d7, [pc, #256]	@ 34002f30 <app_cpuload_get_info+0x140>
34002e30:	ee26 8b07 	vmul.f64	d8, d6, d7
34002e34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e36:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
34002e3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e3c:	e9d3 230e 	ldrd	r2, r3, [r3, #56]	@ 0x38
34002e40:	1a86      	subs	r6, r0, r2
34002e42:	60be      	str	r6, [r7, #8]
34002e44:	eb61 0303 	sbc.w	r3, r1, r3
34002e48:	60fb      	str	r3, [r7, #12]
34002e4a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34002e4e:	f7fe fe2b 	bl	34001aa8 <__aeabi_ul2d>
34002e52:	ec41 0b16 	vmov	d6, r0, r1
34002e56:	ee88 7b06 	vdiv.f64	d7, d8, d6
34002e5a:	eef7 7bc7 	vcvt.f32.f64	s15, d7
34002e5e:	6a3b      	ldr	r3, [r7, #32]
34002e60:	edc3 7a00 	vstr	s15, [r3]
    }

    if (cpuload_last_second != NULL)
34002e64:	69fb      	ldr	r3, [r7, #28]
34002e66:	2b00      	cmp	r3, #0
34002e68:	d02b      	beq.n	34002ec2 <app_cpuload_get_info+0xd2>
    {
        *cpuload_last_second = 100.0 * (cpuload->history[2].thread - cpuload->history[3].thread) / (cpuload->history[2].total - cpuload->history[3].total);
34002e6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e6c:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	@ 0x58
34002e70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e72:	e9d3 231c 	ldrd	r2, r3, [r3, #112]	@ 0x70
34002e76:	1a86      	subs	r6, r0, r2
34002e78:	603e      	str	r6, [r7, #0]
34002e7a:	eb61 0303 	sbc.w	r3, r1, r3
34002e7e:	607b      	str	r3, [r7, #4]
34002e80:	e9d7 0100 	ldrd	r0, r1, [r7]
34002e84:	f7fe fe10 	bl	34001aa8 <__aeabi_ul2d>
34002e88:	ec41 0b16 	vmov	d6, r0, r1
34002e8c:	ed9f 7b28 	vldr	d7, [pc, #160]	@ 34002f30 <app_cpuload_get_info+0x140>
34002e90:	ee26 8b07 	vmul.f64	d8, d6, d7
34002e94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e96:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
34002e9a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002e9c:	e9d3 231a 	ldrd	r2, r3, [r3, #104]	@ 0x68
34002ea0:	ebb0 0a02 	subs.w	sl, r0, r2
34002ea4:	eb61 0b03 	sbc.w	fp, r1, r3
34002ea8:	4650      	mov	r0, sl
34002eaa:	4659      	mov	r1, fp
34002eac:	f7fe fdfc 	bl	34001aa8 <__aeabi_ul2d>
34002eb0:	ec41 0b16 	vmov	d6, r0, r1
34002eb4:	ee88 7b06 	vdiv.f64	d7, d8, d6
34002eb8:	eef7 7bc7 	vcvt.f32.f64	s15, d7
34002ebc:	69fb      	ldr	r3, [r7, #28]
34002ebe:	edc3 7a00 	vstr	s15, [r3]
    }

    if (cpuload_last_five_seconds != NULL)
34002ec2:	69bb      	ldr	r3, [r7, #24]
34002ec4:	2b00      	cmp	r3, #0
34002ec6:	d029      	beq.n	34002f1c <app_cpuload_get_info+0x12c>
    {
        *cpuload_last_five_seconds = 100.0 * (cpuload->history[2].thread - cpuload->history[7].thread) / (cpuload->history[2].total - cpuload->history[7].total);
34002ec8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002eca:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	@ 0x58
34002ece:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002ed0:	e9d3 2334 	ldrd	r2, r3, [r3, #208]	@ 0xd0
34002ed4:	ebb0 0802 	subs.w	r8, r0, r2
34002ed8:	eb61 0903 	sbc.w	r9, r1, r3
34002edc:	4640      	mov	r0, r8
34002ede:	4649      	mov	r1, r9
34002ee0:	f7fe fde2 	bl	34001aa8 <__aeabi_ul2d>
34002ee4:	ec41 0b16 	vmov	d6, r0, r1
34002ee8:	ed9f 7b11 	vldr	d7, [pc, #68]	@ 34002f30 <app_cpuload_get_info+0x140>
34002eec:	ee26 8b07 	vmul.f64	d8, d6, d7
34002ef0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002ef2:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	@ 0x50
34002ef6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002ef8:	e9d3 2332 	ldrd	r2, r3, [r3, #200]	@ 0xc8
34002efc:	1a84      	subs	r4, r0, r2
34002efe:	eb61 0503 	sbc.w	r5, r1, r3
34002f02:	4620      	mov	r0, r4
34002f04:	4629      	mov	r1, r5
34002f06:	f7fe fdcf 	bl	34001aa8 <__aeabi_ul2d>
34002f0a:	ec41 0b16 	vmov	d6, r0, r1
34002f0e:	ee88 7b06 	vdiv.f64	d7, d8, d6
34002f12:	eef7 7bc7 	vcvt.f32.f64	s15, d7
34002f16:	69bb      	ldr	r3, [r7, #24]
34002f18:	edc3 7a00 	vstr	s15, [r3]
    }
}
34002f1c:	bf00      	nop
34002f1e:	372c      	adds	r7, #44	@ 0x2c
34002f20:	46bd      	mov	sp, r7
34002f22:	ecbd 8b02 	vpop	{d8}
34002f26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34002f2a:	bf00      	nop
34002f2c:	f3af 8000 	nop.w
34002f30:	00000000 	.word	0x00000000
34002f34:	40590000 	.word	0x40590000

34002f38 <app_lcd_init>:
static uint8_t app_lcd_bg_buffer_fill_idx = 0;
static uint8_t app_lcd_fg_buffer[2][LCD_FG_WIDTH * LCD_FG_HEIGHT * 2] __attribute__((aligned(32))) __attribute__((section(".EXTRAM")));
static uint8_t app_lcd_fg_buffer_load_idx;

void app_lcd_init(void)
{
34002f38:	b580      	push	{r7, lr}
34002f3a:	b08e      	sub	sp, #56	@ 0x38
34002f3c:	af00      	add	r7, sp, #0
    bsp_lcd_layer_config_t bsp_lcd_layer_config = {0};
34002f3e:	463b      	mov	r3, r7
34002f40:	2200      	movs	r2, #0
34002f42:	601a      	str	r2, [r3, #0]
34002f44:	605a      	str	r2, [r3, #4]
34002f46:	609a      	str	r2, [r3, #8]
34002f48:	60da      	str	r2, [r3, #12]
34002f4a:	611a      	str	r2, [r3, #16]
34002f4c:	615a      	str	r2, [r3, #20]

    memset(app_lcd_bg_buffer, 0, sizeof(app_lcd_bg_buffer));
34002f4e:	4a50      	ldr	r2, [pc, #320]	@ (34003090 <app_lcd_init+0x158>)
34002f50:	2100      	movs	r1, #0
34002f52:	4850      	ldr	r0, [pc, #320]	@ (34003094 <app_lcd_init+0x15c>)
34002f54:	f024 f91e 	bl	34027194 <memset>
34002f58:	4b4e      	ldr	r3, [pc, #312]	@ (34003094 <app_lcd_init+0x15c>)
34002f5a:	627b      	str	r3, [r7, #36]	@ 0x24
34002f5c:	4b4c      	ldr	r3, [pc, #304]	@ (34003090 <app_lcd_init+0x158>)
34002f5e:	623b      	str	r3, [r7, #32]
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
{
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    if ( dsize > 0 ) {
34002f60:	6a3b      	ldr	r3, [r7, #32]
34002f62:	2b00      	cmp	r3, #0
34002f64:	dd1d      	ble.n	34002fa2 <app_lcd_init+0x6a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002f66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002f68:	f003 021f 	and.w	r2, r3, #31
34002f6c:	6a3b      	ldr	r3, [r7, #32]
34002f6e:	4413      	add	r3, r2
34002f70:	61fb      	str	r3, [r7, #28]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34002f72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002f74:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("dsb 0xF":::"memory");
34002f76:	f3bf 8f4f 	dsb	sy
}
34002f7a:	bf00      	nop

      __DSB();

      do {
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002f7c:	4a46      	ldr	r2, [pc, #280]	@ (34003098 <app_lcd_init+0x160>)
34002f7e:	69bb      	ldr	r3, [r7, #24]
34002f80:	f8c2 3270 	str.w	r3, [r2, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
34002f84:	69bb      	ldr	r3, [r7, #24]
34002f86:	3320      	adds	r3, #32
34002f88:	61bb      	str	r3, [r7, #24]
        op_size -=          __SCB_DCACHE_LINE_SIZE;
34002f8a:	69fb      	ldr	r3, [r7, #28]
34002f8c:	3b20      	subs	r3, #32
34002f8e:	61fb      	str	r3, [r7, #28]
      } while ( op_size > 0 );
34002f90:	69fb      	ldr	r3, [r7, #28]
34002f92:	2b00      	cmp	r3, #0
34002f94:	dcf2      	bgt.n	34002f7c <app_lcd_init+0x44>
  __ASM volatile ("dsb 0xF":::"memory");
34002f96:	f3bf 8f4f 	dsb	sy
}
34002f9a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34002f9c:	f3bf 8f6f 	isb	sy
}
34002fa0:	bf00      	nop

      __DSB();
      __ISB();
    }
  #endif
}
34002fa2:	bf00      	nop
    SCB_CleanInvalidateDCache_by_Addr(app_lcd_bg_buffer, sizeof(app_lcd_bg_buffer));
    memset(app_lcd_fg_buffer, 0, sizeof(app_lcd_fg_buffer));
34002fa4:	4a3d      	ldr	r2, [pc, #244]	@ (3400309c <app_lcd_init+0x164>)
34002fa6:	2100      	movs	r1, #0
34002fa8:	483d      	ldr	r0, [pc, #244]	@ (340030a0 <app_lcd_init+0x168>)
34002faa:	f024 f8f3 	bl	34027194 <memset>
34002fae:	4b3c      	ldr	r3, [pc, #240]	@ (340030a0 <app_lcd_init+0x168>)
34002fb0:	637b      	str	r3, [r7, #52]	@ 0x34
34002fb2:	4b3a      	ldr	r3, [pc, #232]	@ (3400309c <app_lcd_init+0x164>)
34002fb4:	633b      	str	r3, [r7, #48]	@ 0x30
    if ( dsize > 0 ) {
34002fb6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34002fb8:	2b00      	cmp	r3, #0
34002fba:	dd1d      	ble.n	34002ff8 <app_lcd_init+0xc0>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34002fbc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34002fbe:	f003 021f 	and.w	r2, r3, #31
34002fc2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34002fc4:	4413      	add	r3, r2
34002fc6:	62fb      	str	r3, [r7, #44]	@ 0x2c
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34002fc8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34002fca:	62bb      	str	r3, [r7, #40]	@ 0x28
  __ASM volatile ("dsb 0xF":::"memory");
34002fcc:	f3bf 8f4f 	dsb	sy
}
34002fd0:	bf00      	nop
        SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bits 31..5 are valid */
34002fd2:	4a31      	ldr	r2, [pc, #196]	@ (34003098 <app_lcd_init+0x160>)
34002fd4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002fd6:	f8c2 3270 	str.w	r3, [r2, #624]	@ 0x270
        op_addr +=          __SCB_DCACHE_LINE_SIZE;
34002fda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34002fdc:	3320      	adds	r3, #32
34002fde:	62bb      	str	r3, [r7, #40]	@ 0x28
        op_size -=          __SCB_DCACHE_LINE_SIZE;
34002fe0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34002fe2:	3b20      	subs	r3, #32
34002fe4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      } while ( op_size > 0 );
34002fe6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34002fe8:	2b00      	cmp	r3, #0
34002fea:	dcf2      	bgt.n	34002fd2 <app_lcd_init+0x9a>
  __ASM volatile ("dsb 0xF":::"memory");
34002fec:	f3bf 8f4f 	dsb	sy
}
34002ff0:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34002ff2:	f3bf 8f6f 	isb	sy
}
34002ff6:	bf00      	nop
}
34002ff8:	bf00      	nop
    SCB_CleanInvalidateDCache_by_Addr(app_lcd_fg_buffer, sizeof(app_lcd_fg_buffer));

    bsp_lcd_init();
34002ffa:	f002 f943 	bl	34005284 <bsp_lcd_init>
    bsp_lcd_set_brightness(100);
34002ffe:	2064      	movs	r0, #100	@ 0x64
34003000:	f002 f9d8 	bl	340053b4 <bsp_lcd_set_brightness>

    bsp_lcd_layer_config.x0 = (BSP_LCD_WIDTH - LCD_BG_WIDTH) / 2;
34003004:	2300      	movs	r3, #0
34003006:	603b      	str	r3, [r7, #0]
    bsp_lcd_layer_config.y0 = (BSP_LCD_HEIGHT - LCD_BG_HEIGHT) / 2;
34003008:	2300      	movs	r3, #0
3400300a:	60bb      	str	r3, [r7, #8]
    bsp_lcd_layer_config.x1 = bsp_lcd_layer_config.x0 + LCD_BG_WIDTH;
3400300c:	683b      	ldr	r3, [r7, #0]
3400300e:	f503 7348 	add.w	r3, r3, #800	@ 0x320
34003012:	607b      	str	r3, [r7, #4]
    bsp_lcd_layer_config.y1 = bsp_lcd_layer_config.y0 + LCD_BG_HEIGHT;
34003014:	68bb      	ldr	r3, [r7, #8]
34003016:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
3400301a:	60fb      	str	r3, [r7, #12]
    bsp_lcd_layer_config.pixel_format = LCD_PIXEL_FORMAT_RGB565;
3400301c:	2302      	movs	r3, #2
3400301e:	613b      	str	r3, [r7, #16]
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx];
34003020:	4b20      	ldr	r3, [pc, #128]	@ (340030a4 <app_lcd_init+0x16c>)
34003022:	781b      	ldrb	r3, [r3, #0]
34003024:	461a      	mov	r2, r3
34003026:	4b20      	ldr	r3, [pc, #128]	@ (340030a8 <app_lcd_init+0x170>)
34003028:	fb02 f303 	mul.w	r3, r2, r3
3400302c:	4a19      	ldr	r2, [pc, #100]	@ (34003094 <app_lcd_init+0x15c>)
3400302e:	4413      	add	r3, r2
34003030:	617b      	str	r3, [r7, #20]
    bsp_lcd_config_layer(0, &bsp_lcd_layer_config);
34003032:	463b      	mov	r3, r7
34003034:	4619      	mov	r1, r3
34003036:	2000      	movs	r0, #0
34003038:	f002 f962 	bl	34005300 <bsp_lcd_config_layer>

    bsp_lcd_layer_config.x0 = (BSP_LCD_WIDTH - LCD_FG_WIDTH) / 2;
3400303c:	2300      	movs	r3, #0
3400303e:	603b      	str	r3, [r7, #0]
    bsp_lcd_layer_config.y0 = (BSP_LCD_HEIGHT - LCD_FG_HEIGHT) / 2;
34003040:	2300      	movs	r3, #0
34003042:	60bb      	str	r3, [r7, #8]
    bsp_lcd_layer_config.x1 = bsp_lcd_layer_config.x0 + LCD_FG_WIDTH;
34003044:	683b      	ldr	r3, [r7, #0]
34003046:	f503 7348 	add.w	r3, r3, #800	@ 0x320
3400304a:	607b      	str	r3, [r7, #4]
    bsp_lcd_layer_config.y1 = bsp_lcd_layer_config.y0 + LCD_FG_HEIGHT;
3400304c:	68bb      	ldr	r3, [r7, #8]
3400304e:	f503 73f0 	add.w	r3, r3, #480	@ 0x1e0
34003052:	60fb      	str	r3, [r7, #12]
    bsp_lcd_layer_config.pixel_format = LCD_PIXEL_FORMAT_ARGB4444;
34003054:	2304      	movs	r3, #4
34003056:	613b      	str	r3, [r7, #16]
    bsp_lcd_layer_config.address = (uint32_t)app_lcd_fg_buffer[1];
34003058:	4b14      	ldr	r3, [pc, #80]	@ (340030ac <app_lcd_init+0x174>)
3400305a:	617b      	str	r3, [r7, #20]
    bsp_lcd_config_layer(1, &bsp_lcd_layer_config);
3400305c:	463b      	mov	r3, r7
3400305e:	4619      	mov	r1, r3
34003060:	2001      	movs	r0, #1
34003062:	f002 f94d 	bl	34005300 <bsp_lcd_config_layer>

    UTIL_LCD_SetFuncDriver(&bsp_lcd_driver);
34003066:	4812      	ldr	r0, [pc, #72]	@ (340030b0 <app_lcd_init+0x178>)
34003068:	f021 f9f0 	bl	3402444c <UTIL_LCD_SetFuncDriver>
    UTIL_LCD_SetLayer(1);
3400306c:	2001      	movs	r0, #1
3400306e:	f021 fa43 	bl	340244f8 <UTIL_LCD_SetLayer>
    UTIL_LCD_Clear(0x00000000);
34003072:	2000      	movs	r0, #0
34003074:	f021 fbbc 	bl	340247f0 <UTIL_LCD_Clear>
    UTIL_LCD_SetFont(&Font20);
34003078:	480e      	ldr	r0, [pc, #56]	@ (340030b4 <app_lcd_init+0x17c>)
3400307a:	f021 fa95 	bl	340245a8 <UTIL_LCD_SetFont>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
3400307e:	f04f 30ff 	mov.w	r0, #4294967295
34003082:	f021 fa7d 	bl	34024580 <UTIL_LCD_SetTextColor>
}
34003086:	bf00      	nop
34003088:	3738      	adds	r7, #56	@ 0x38
3400308a:	46bd      	mov	sp, r7
3400308c:	bd80      	pop	{r7, pc}
3400308e:	bf00      	nop
34003090:	00232800 	.word	0x00232800
34003094:	91049800 	.word	0x91049800
34003098:	e000ed00 	.word	0xe000ed00
3400309c:	00177000 	.word	0x00177000
340030a0:	9127c000 	.word	0x9127c000
340030a4:	340413bc 	.word	0x340413bc
340030a8:	000bb800 	.word	0x000bb800
340030ac:	91337800 	.word	0x91337800
340030b0:	3402be2c 	.word	0x3402be2c
340030b4:	34041490 	.word	0x34041490

340030b8 <app_lcd_get_bg_buffer>:

uint8_t *app_lcd_get_bg_buffer(void)
{
340030b8:	b480      	push	{r7}
340030ba:	af00      	add	r7, sp, #0
    return app_lcd_bg_buffer[app_lcd_bg_buffer_fill_idx];
340030bc:	4b06      	ldr	r3, [pc, #24]	@ (340030d8 <app_lcd_get_bg_buffer+0x20>)
340030be:	781b      	ldrb	r3, [r3, #0]
340030c0:	461a      	mov	r2, r3
340030c2:	4b06      	ldr	r3, [pc, #24]	@ (340030dc <app_lcd_get_bg_buffer+0x24>)
340030c4:	fb02 f303 	mul.w	r3, r2, r3
340030c8:	4a05      	ldr	r2, [pc, #20]	@ (340030e0 <app_lcd_get_bg_buffer+0x28>)
340030ca:	4413      	add	r3, r2
}
340030cc:	4618      	mov	r0, r3
340030ce:	46bd      	mov	sp, r7
340030d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340030d4:	4770      	bx	lr
340030d6:	bf00      	nop
340030d8:	34048de0 	.word	0x34048de0
340030dc:	000bb800 	.word	0x000bb800
340030e0:	91049800 	.word	0x91049800

340030e4 <app_lcd_switch_bg_buffer>:

void app_lcd_switch_bg_buffer(void)
{
340030e4:	b580      	push	{r7, lr}
340030e6:	af00      	add	r7, sp, #0
    app_lcd_bg_buffer_disp_idx = (app_lcd_bg_buffer_disp_idx + 1) % DISPLAY_BUFFER_NB;
340030e8:	4b1a      	ldr	r3, [pc, #104]	@ (34003154 <app_lcd_switch_bg_buffer+0x70>)
340030ea:	781b      	ldrb	r3, [r3, #0]
340030ec:	1c5a      	adds	r2, r3, #1
340030ee:	4b1a      	ldr	r3, [pc, #104]	@ (34003158 <app_lcd_switch_bg_buffer+0x74>)
340030f0:	fb83 3102 	smull	r3, r1, r3, r2
340030f4:	17d3      	asrs	r3, r2, #31
340030f6:	1ac9      	subs	r1, r1, r3
340030f8:	460b      	mov	r3, r1
340030fa:	005b      	lsls	r3, r3, #1
340030fc:	440b      	add	r3, r1
340030fe:	1ad1      	subs	r1, r2, r3
34003100:	b2ca      	uxtb	r2, r1
34003102:	4b14      	ldr	r3, [pc, #80]	@ (34003154 <app_lcd_switch_bg_buffer+0x70>)
34003104:	701a      	strb	r2, [r3, #0]
    app_lcd_bg_buffer_fill_idx = (app_lcd_bg_buffer_fill_idx + 1) % DISPLAY_BUFFER_NB;
34003106:	4b15      	ldr	r3, [pc, #84]	@ (3400315c <app_lcd_switch_bg_buffer+0x78>)
34003108:	781b      	ldrb	r3, [r3, #0]
3400310a:	1c5a      	adds	r2, r3, #1
3400310c:	4b12      	ldr	r3, [pc, #72]	@ (34003158 <app_lcd_switch_bg_buffer+0x74>)
3400310e:	fb83 3102 	smull	r3, r1, r3, r2
34003112:	17d3      	asrs	r3, r2, #31
34003114:	1ac9      	subs	r1, r1, r3
34003116:	460b      	mov	r3, r1
34003118:	005b      	lsls	r3, r3, #1
3400311a:	440b      	add	r3, r1
3400311c:	1ad1      	subs	r1, r2, r3
3400311e:	b2ca      	uxtb	r2, r1
34003120:	4b0e      	ldr	r3, [pc, #56]	@ (3400315c <app_lcd_switch_bg_buffer+0x78>)
34003122:	701a      	strb	r2, [r3, #0]

    HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(), (uint32_t)app_lcd_bg_buffer[app_lcd_bg_buffer_disp_idx], 0);
34003124:	f002 f960 	bl	340053e8 <bsp_lcd_get_ltdc_handle>
34003128:	4b0a      	ldr	r3, [pc, #40]	@ (34003154 <app_lcd_switch_bg_buffer+0x70>)
3400312a:	781b      	ldrb	r3, [r3, #0]
3400312c:	461a      	mov	r2, r3
3400312e:	4b0c      	ldr	r3, [pc, #48]	@ (34003160 <app_lcd_switch_bg_buffer+0x7c>)
34003130:	fb02 f303 	mul.w	r3, r2, r3
34003134:	4a0b      	ldr	r2, [pc, #44]	@ (34003164 <app_lcd_switch_bg_buffer+0x80>)
34003136:	4413      	add	r3, r2
34003138:	2200      	movs	r2, #0
3400313a:	4619      	mov	r1, r3
3400313c:	f008 ff49 	bl	3400bfd2 <HAL_LTDC_SetAddress_NoReload>
    HAL_LTDC_ReloadLayer(bsp_lcd_get_ltdc_handle(), LTDC_RELOAD_VERTICAL_BLANKING, 0);
34003140:	f002 f952 	bl	340053e8 <bsp_lcd_get_ltdc_handle>
34003144:	4603      	mov	r3, r0
34003146:	2200      	movs	r2, #0
34003148:	2102      	movs	r1, #2
3400314a:	4618      	mov	r0, r3
3400314c:	f008 ff08 	bl	3400bf60 <HAL_LTDC_ReloadLayer>
}
34003150:	bf00      	nop
34003152:	bd80      	pop	{r7, pc}
34003154:	340413bc 	.word	0x340413bc
34003158:	55555556 	.word	0x55555556
3400315c:	34048de0 	.word	0x34048de0
34003160:	000bb800 	.word	0x000bb800
34003164:	91049800 	.word	0x91049800

34003168 <app_lcd_draw_area_update>:

void app_lcd_draw_area_update(void)
{
34003168:	b580      	push	{r7, lr}
3400316a:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
3400316c:	b672      	cpsid	i
}
3400316e:	bf00      	nop
    __disable_irq();
    HAL_LTDC_SetAddress_NoReload(bsp_lcd_get_ltdc_handle(), (uint32_t)app_lcd_fg_buffer[app_lcd_fg_buffer_load_idx], 1);
34003170:	f002 f93a 	bl	340053e8 <bsp_lcd_get_ltdc_handle>
34003174:	4b07      	ldr	r3, [pc, #28]	@ (34003194 <app_lcd_draw_area_update+0x2c>)
34003176:	781b      	ldrb	r3, [r3, #0]
34003178:	461a      	mov	r2, r3
3400317a:	4b07      	ldr	r3, [pc, #28]	@ (34003198 <app_lcd_draw_area_update+0x30>)
3400317c:	fb02 f303 	mul.w	r3, r2, r3
34003180:	4a06      	ldr	r2, [pc, #24]	@ (3400319c <app_lcd_draw_area_update+0x34>)
34003182:	4413      	add	r3, r2
34003184:	2201      	movs	r2, #1
34003186:	4619      	mov	r1, r3
34003188:	f008 ff23 	bl	3400bfd2 <HAL_LTDC_SetAddress_NoReload>
  __ASM volatile ("cpsie i" : : : "memory");
3400318c:	b662      	cpsie	i
}
3400318e:	bf00      	nop
    __enable_irq();
}
34003190:	bf00      	nop
34003192:	bd80      	pop	{r7, pc}
34003194:	34048de1 	.word	0x34048de1
34003198:	000bb800 	.word	0x000bb800
3400319c:	9127c000 	.word	0x9127c000

340031a0 <app_lcd_draw_area_commit>:

void app_lcd_draw_area_commit(void)
{
340031a0:	b580      	push	{r7, lr}
340031a2:	b084      	sub	sp, #16
340031a4:	af00      	add	r7, sp, #0
    SCB_CleanDCache_by_Addr(app_lcd_fg_buffer[app_lcd_fg_buffer_load_idx], sizeof(app_lcd_fg_buffer[app_lcd_fg_buffer_load_idx]));
340031a6:	4b22      	ldr	r3, [pc, #136]	@ (34003230 <app_lcd_draw_area_commit+0x90>)
340031a8:	781b      	ldrb	r3, [r3, #0]
340031aa:	461a      	mov	r2, r3
340031ac:	4b21      	ldr	r3, [pc, #132]	@ (34003234 <app_lcd_draw_area_commit+0x94>)
340031ae:	fb02 f303 	mul.w	r3, r2, r3
340031b2:	4a21      	ldr	r2, [pc, #132]	@ (34003238 <app_lcd_draw_area_commit+0x98>)
340031b4:	4413      	add	r3, r2
340031b6:	60fb      	str	r3, [r7, #12]
340031b8:	4b1e      	ldr	r3, [pc, #120]	@ (34003234 <app_lcd_draw_area_commit+0x94>)
340031ba:	60bb      	str	r3, [r7, #8]
    if ( dsize > 0 ) {
340031bc:	68bb      	ldr	r3, [r7, #8]
340031be:	2b00      	cmp	r3, #0
340031c0:	dd1d      	ble.n	340031fe <app_lcd_draw_area_commit+0x5e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340031c2:	68fb      	ldr	r3, [r7, #12]
340031c4:	f003 021f 	and.w	r2, r3, #31
340031c8:	68bb      	ldr	r3, [r7, #8]
340031ca:	4413      	add	r3, r2
340031cc:	607b      	str	r3, [r7, #4]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
340031ce:	68fb      	ldr	r3, [r7, #12]
340031d0:	603b      	str	r3, [r7, #0]
  __ASM volatile ("dsb 0xF":::"memory");
340031d2:	f3bf 8f4f 	dsb	sy
}
340031d6:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340031d8:	4a18      	ldr	r2, [pc, #96]	@ (3400323c <app_lcd_draw_area_commit+0x9c>)
340031da:	683b      	ldr	r3, [r7, #0]
340031dc:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340031e0:	683b      	ldr	r3, [r7, #0]
340031e2:	3320      	adds	r3, #32
340031e4:	603b      	str	r3, [r7, #0]
        op_size -= __SCB_DCACHE_LINE_SIZE;
340031e6:	687b      	ldr	r3, [r7, #4]
340031e8:	3b20      	subs	r3, #32
340031ea:	607b      	str	r3, [r7, #4]
      } while ( op_size > 0 );
340031ec:	687b      	ldr	r3, [r7, #4]
340031ee:	2b00      	cmp	r3, #0
340031f0:	dcf2      	bgt.n	340031d8 <app_lcd_draw_area_commit+0x38>
  __ASM volatile ("dsb 0xF":::"memory");
340031f2:	f3bf 8f4f 	dsb	sy
}
340031f6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
340031f8:	f3bf 8f6f 	isb	sy
}
340031fc:	bf00      	nop
}
340031fe:	bf00      	nop
  __ASM volatile ("cpsid i" : : : "memory");
34003200:	b672      	cpsid	i
}
34003202:	bf00      	nop
    __disable_irq();
    HAL_LTDC_ReloadLayer(bsp_lcd_get_ltdc_handle(), LTDC_RELOAD_VERTICAL_BLANKING, 1);
34003204:	f002 f8f0 	bl	340053e8 <bsp_lcd_get_ltdc_handle>
34003208:	4603      	mov	r3, r0
3400320a:	2201      	movs	r2, #1
3400320c:	2102      	movs	r1, #2
3400320e:	4618      	mov	r0, r3
34003210:	f008 fea6 	bl	3400bf60 <HAL_LTDC_ReloadLayer>
  __ASM volatile ("cpsie i" : : : "memory");
34003214:	b662      	cpsie	i
}
34003216:	bf00      	nop
    __enable_irq();
    app_lcd_fg_buffer_load_idx = 1 - app_lcd_fg_buffer_load_idx;
34003218:	4b05      	ldr	r3, [pc, #20]	@ (34003230 <app_lcd_draw_area_commit+0x90>)
3400321a:	781b      	ldrb	r3, [r3, #0]
3400321c:	f1c3 0301 	rsb	r3, r3, #1
34003220:	b2da      	uxtb	r2, r3
34003222:	4b03      	ldr	r3, [pc, #12]	@ (34003230 <app_lcd_draw_area_commit+0x90>)
34003224:	701a      	strb	r2, [r3, #0]
}
34003226:	bf00      	nop
34003228:	3710      	adds	r7, #16
3400322a:	46bd      	mov	sp, r7
3400322c:	bd80      	pop	{r7, pc}
3400322e:	bf00      	nop
34003230:	34048de1 	.word	0x34048de1
34003234:	000bb800 	.word	0x000bb800
34003238:	9127c000 	.word	0x9127c000
3400323c:	e000ed00 	.word	0xe000ed00

34003240 <app_postprocess_init>:
#elif POSTPROCESS_TYPE == POSTPROCESS_SSEG_DEEPLAB_V3_UF
static uint8_t out_sseg_map[AI_SSEG_DEEPLABV3_PP_WIDTH * AI_SSEG_DEEPLABV3_PP_HEIGHT];
#endif

int32_t app_postprocess_init(void *params_postprocess)
{
34003240:	b580      	push	{r7, lr}
34003242:	b084      	sub	sp, #16
34003244:	af00      	add	r7, sp, #0
34003246:	6078      	str	r0, [r7, #4]
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
34003248:	2300      	movs	r3, #0
3400324a:	60fb      	str	r3, [r7, #12]
  yolov2_pp_static_param_t *params = (yolov2_pp_static_param_t *) params_postprocess;
3400324c:	687b      	ldr	r3, [r7, #4]
3400324e:	60bb      	str	r3, [r7, #8]
  params->conf_threshold = AI_OBJDETECT_YOLOV2_PP_CONF_THRESHOLD;
34003250:	68bb      	ldr	r3, [r7, #8]
34003252:	4a11      	ldr	r2, [pc, #68]	@ (34003298 <app_postprocess_init+0x58>)
34003254:	619a      	str	r2, [r3, #24]
  params->iou_threshold = AI_OBJDETECT_YOLOV2_PP_IOU_THRESHOLD;
34003256:	68bb      	ldr	r3, [r7, #8]
34003258:	4a10      	ldr	r2, [pc, #64]	@ (3400329c <app_postprocess_init+0x5c>)
3400325a:	61da      	str	r2, [r3, #28]
  params->nb_anchors = AI_OBJDETECT_YOLOV2_PP_NB_ANCHORS;
3400325c:	68bb      	ldr	r3, [r7, #8]
3400325e:	2205      	movs	r2, #5
34003260:	605a      	str	r2, [r3, #4]
  params->nb_classes = AI_OBJDETECT_YOLOV2_PP_NB_CLASSES;
34003262:	68bb      	ldr	r3, [r7, #8]
34003264:	2201      	movs	r2, #1
34003266:	601a      	str	r2, [r3, #0]
  params->grid_height = AI_OBJDETECT_YOLOV2_PP_GRID_HEIGHT;
34003268:	68bb      	ldr	r3, [r7, #8]
3400326a:	2207      	movs	r2, #7
3400326c:	60da      	str	r2, [r3, #12]
  params->grid_width = AI_OBJDETECT_YOLOV2_PP_GRID_WIDTH;
3400326e:	68bb      	ldr	r3, [r7, #8]
34003270:	2207      	movs	r2, #7
34003272:	609a      	str	r2, [r3, #8]
  params->nb_input_boxes = AI_OBJDETECT_YOLOV2_PP_NB_INPUT_BOXES;
34003274:	68bb      	ldr	r3, [r7, #8]
34003276:	2231      	movs	r2, #49	@ 0x31
34003278:	611a      	str	r2, [r3, #16]
  params->pAnchors = AI_OBJDETECT_YOLOV2_PP_ANCHORS;
3400327a:	68bb      	ldr	r3, [r7, #8]
3400327c:	4a08      	ldr	r2, [pc, #32]	@ (340032a0 <app_postprocess_init+0x60>)
3400327e:	621a      	str	r2, [r3, #32]
  params->max_boxes_limit = AI_OBJDETECT_YOLOV2_PP_MAX_BOXES_LIMIT;
34003280:	68bb      	ldr	r3, [r7, #8]
34003282:	220a      	movs	r2, #10
34003284:	615a      	str	r2, [r3, #20]
  error = od_yolov2_pp_reset(params);
34003286:	68b8      	ldr	r0, [r7, #8]
34003288:	f01d fb98 	bl	340209bc <od_yolov2_pp_reset>
3400328c:	60f8      	str	r0, [r7, #12]
  error = sseg_deeplabv3_pp_reset(params);
#else
  #error "PostProcessing type not supported"
#endif

  return error;
3400328e:	68fb      	ldr	r3, [r7, #12]
}
34003290:	4618      	mov	r0, r3
34003292:	3710      	adds	r7, #16
34003294:	46bd      	mov	sp, r7
34003296:	bd80      	pop	{r7, pc}
34003298:	3f19999a 	.word	0x3f19999a
3400329c:	3e99999a 	.word	0x3e99999a
340032a0:	3402bdf0 	.word	0x3402bdf0

340032a4 <app_postprocess_run>:

int32_t app_postprocess_run(void *pInput[], int nb_input, void *pOutput, void *pInput_param)
{
340032a4:	b580      	push	{r7, lr}
340032a6:	b086      	sub	sp, #24
340032a8:	af00      	add	r7, sp, #0
340032aa:	60f8      	str	r0, [r7, #12]
340032ac:	60b9      	str	r1, [r7, #8]
340032ae:	607a      	str	r2, [r7, #4]
340032b0:	603b      	str	r3, [r7, #0]
#if POSTPROCESS_TYPE == POSTPROCESS_OD_YOLO_V2_UF
  assert(nb_input == 1);
340032b2:	68bb      	ldr	r3, [r7, #8]
340032b4:	2b01      	cmp	r3, #1
340032b6:	d005      	beq.n	340032c4 <app_postprocess_run+0x20>
340032b8:	4b0b      	ldr	r3, [pc, #44]	@ (340032e8 <app_postprocess_run+0x44>)
340032ba:	4a0c      	ldr	r2, [pc, #48]	@ (340032ec <app_postprocess_run+0x48>)
340032bc:	21c4      	movs	r1, #196	@ 0xc4
340032be:	480c      	ldr	r0, [pc, #48]	@ (340032f0 <app_postprocess_run+0x4c>)
340032c0:	f022 fd52 	bl	34025d68 <__assert_func>
  int32_t error = AI_OD_POSTPROCESS_ERROR_NO;
340032c4:	2300      	movs	r3, #0
340032c6:	617b      	str	r3, [r7, #20]
  yolov2_pp_in_t pp_input = {
    .pRaw_detections = (float32_t *) pInput[0]
340032c8:	68fb      	ldr	r3, [r7, #12]
340032ca:	681b      	ldr	r3, [r3, #0]
  yolov2_pp_in_t pp_input = {
340032cc:	613b      	str	r3, [r7, #16]
  };
  error = od_yolov2_pp_process(&pp_input, (od_pp_out_t *) pOutput,
340032ce:	f107 0310 	add.w	r3, r7, #16
340032d2:	683a      	ldr	r2, [r7, #0]
340032d4:	6879      	ldr	r1, [r7, #4]
340032d6:	4618      	mov	r0, r3
340032d8:	f01d fb7e 	bl	340209d8 <od_yolov2_pp_process>
340032dc:	6178      	str	r0, [r7, #20]
                                    (sseg_deeplabv3_pp_static_param_t *) pInput_param);
#else
  #error "PostProcessing type not supported"
#endif

  return error;
340032de:	697b      	ldr	r3, [r7, #20]
}
340032e0:	4618      	mov	r0, r3
340032e2:	3718      	adds	r7, #24
340032e4:	46bd      	mov	sp, r7
340032e6:	bd80      	pop	{r7, pc}
340032e8:	3402a18c 	.word	0x3402a18c
340032ec:	3402be18 	.word	0x3402be18
340032f0:	3402a19c 	.word	0x3402a19c

340032f4 <LL_BUS_EnableClockLowPower>:
  *         @arg @ref LL_APB4
  *         @arg @ref LL_APB5
  * @retval None
  */
__STATIC_INLINE void LL_BUS_EnableClockLowPower(uint32_t Bus)
{
340032f4:	b480      	push	{r7}
340032f6:	b085      	sub	sp, #20
340032f8:	af00      	add	r7, sp, #0
340032fa:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->BUSLPENSR, Bus);
340032fc:	4a07      	ldr	r2, [pc, #28]	@ (3400331c <LL_BUS_EnableClockLowPower+0x28>)
340032fe:	687b      	ldr	r3, [r7, #4]
34003300:	f8c2 3a84 	str.w	r3, [r2, #2692]	@ 0xa84
  /* Delay after an RCC bus clock enabling */
  tmpreg = READ_REG(RCC->BUSLPENR);
34003304:	4b05      	ldr	r3, [pc, #20]	@ (3400331c <LL_BUS_EnableClockLowPower+0x28>)
34003306:	f8d3 3284 	ldr.w	r3, [r3, #644]	@ 0x284
3400330a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3400330c:	68fb      	ldr	r3, [r7, #12]
}
3400330e:	bf00      	nop
34003310:	3714      	adds	r7, #20
34003312:	46bd      	mov	sp, r7
34003314:	f85d 7b04 	ldr.w	r7, [sp], #4
34003318:	4770      	bx	lr
3400331a:	bf00      	nop
3400331c:	56028000 	.word	0x56028000

34003320 <LL_MEM_EnableClockLowPower>:
  *         @arg @ref LL_MEM_CACHEAXIRAM
  *         @arg @ref LL_MEM_VENCRAM
  * @retval None
  */
__STATIC_INLINE void LL_MEM_EnableClockLowPower(uint32_t Memories)
{
34003320:	b480      	push	{r7}
34003322:	b085      	sub	sp, #20
34003324:	af00      	add	r7, sp, #0
34003326:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MEMLPENSR, Memories);
34003328:	4a07      	ldr	r2, [pc, #28]	@ (34003348 <LL_MEM_EnableClockLowPower+0x28>)
3400332a:	687b      	ldr	r3, [r7, #4]
3400332c:	f8c2 3a8c 	str.w	r3, [r2, #2700]	@ 0xa8c
  /* Delay after an RCC memories clock enabling */
  tmpreg = READ_REG(RCC->MEMLPENR);
34003330:	4b05      	ldr	r3, [pc, #20]	@ (34003348 <LL_MEM_EnableClockLowPower+0x28>)
34003332:	f8d3 328c 	ldr.w	r3, [r3, #652]	@ 0x28c
34003336:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003338:	68fb      	ldr	r3, [r7, #12]
}
3400333a:	bf00      	nop
3400333c:	3714      	adds	r7, #20
3400333e:	46bd      	mov	sp, r7
34003340:	f85d 7b04 	ldr.w	r7, [sp], #4
34003344:	4770      	bx	lr
34003346:	bf00      	nop
34003348:	56028000 	.word	0x56028000

3400334c <LL_AHB1_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_AHB1_GRP1_PERIPH_GPDMA1
  *         @arg @ref LL_AHB1_GRP1_PERIPH_ADC12
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClockLowPower(uint32_t Periphs)
{
3400334c:	b480      	push	{r7}
3400334e:	b085      	sub	sp, #20
34003350:	af00      	add	r7, sp, #0
34003352:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB1LPENSR, Periphs);
34003354:	4a07      	ldr	r2, [pc, #28]	@ (34003374 <LL_AHB1_GRP1_EnableClockLowPower+0x28>)
34003356:	687b      	ldr	r3, [r7, #4]
34003358:	f8c2 3a90 	str.w	r3, [r2, #2704]	@ 0xa90
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB1LPENR);
3400335c:	4b05      	ldr	r3, [pc, #20]	@ (34003374 <LL_AHB1_GRP1_EnableClockLowPower+0x28>)
3400335e:	f8d3 3290 	ldr.w	r3, [r3, #656]	@ 0x290
34003362:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003364:	68fb      	ldr	r3, [r7, #12]
}
34003366:	bf00      	nop
34003368:	3714      	adds	r7, #20
3400336a:	46bd      	mov	sp, r7
3400336c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003370:	4770      	bx	lr
34003372:	bf00      	nop
34003374:	56028000 	.word	0x56028000

34003378 <LL_AHB2_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_AHB2_GRP1_PERIPH_MDF1
  *         @arg @ref LL_AHB2_GRP1_PERIPH_ADF1
  * @retval None
  */
__STATIC_INLINE void LL_AHB2_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003378:	b480      	push	{r7}
3400337a:	b085      	sub	sp, #20
3400337c:	af00      	add	r7, sp, #0
3400337e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB2LPENSR, Periphs);
34003380:	4a07      	ldr	r2, [pc, #28]	@ (340033a0 <LL_AHB2_GRP1_EnableClockLowPower+0x28>)
34003382:	687b      	ldr	r3, [r7, #4]
34003384:	f8c2 3a94 	str.w	r3, [r2, #2708]	@ 0xa94
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB2LPENR);
34003388:	4b05      	ldr	r3, [pc, #20]	@ (340033a0 <LL_AHB2_GRP1_EnableClockLowPower+0x28>)
3400338a:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
3400338e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003390:	68fb      	ldr	r3, [r7, #12]
}
34003392:	bf00      	nop
34003394:	3714      	adds	r7, #20
34003396:	46bd      	mov	sp, r7
34003398:	f85d 7b04 	ldr.w	r7, [sp], #4
3400339c:	4770      	bx	lr
3400339e:	bf00      	nop
340033a0:	56028000 	.word	0x56028000

340033a4 <LL_AHB3_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
340033a4:	b480      	push	{r7}
340033a6:	b085      	sub	sp, #20
340033a8:	af00      	add	r7, sp, #0
340033aa:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3ENSR, Periphs);
340033ac:	4a07      	ldr	r2, [pc, #28]	@ (340033cc <LL_AHB3_GRP1_EnableClock+0x28>)
340033ae:	687b      	ldr	r3, [r7, #4]
340033b0:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3ENR);
340033b4:	4b05      	ldr	r3, [pc, #20]	@ (340033cc <LL_AHB3_GRP1_EnableClock+0x28>)
340033b6:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
340033ba:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340033bc:	68fb      	ldr	r3, [r7, #12]
}
340033be:	bf00      	nop
340033c0:	3714      	adds	r7, #20
340033c2:	46bd      	mov	sp, r7
340033c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340033c8:	4770      	bx	lr
340033ca:	bf00      	nop
340033cc:	56028000 	.word	0x56028000

340033d0 <LL_AHB3_GRP1_ForceReset>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_ForceReset(uint32_t Periphs)
{
340033d0:	b480      	push	{r7}
340033d2:	b083      	sub	sp, #12
340033d4:	af00      	add	r7, sp, #0
340033d6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTSR, Periphs);
340033d8:	4a04      	ldr	r2, [pc, #16]	@ (340033ec <LL_AHB3_GRP1_ForceReset+0x1c>)
340033da:	687b      	ldr	r3, [r7, #4]
340033dc:	f8c2 3a18 	str.w	r3, [r2, #2584]	@ 0xa18
}
340033e0:	bf00      	nop
340033e2:	370c      	adds	r7, #12
340033e4:	46bd      	mov	sp, r7
340033e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340033ea:	4770      	bx	lr
340033ec:	56028000 	.word	0x56028000

340033f0 <LL_AHB3_GRP1_ReleaseReset>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
{
340033f0:	b480      	push	{r7}
340033f2:	b083      	sub	sp, #12
340033f4:	af00      	add	r7, sp, #0
340033f6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB3RSTCR, Periphs);
340033f8:	4b06      	ldr	r3, [pc, #24]	@ (34003414 <LL_AHB3_GRP1_ReleaseReset+0x24>)
340033fa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340033fe:	461a      	mov	r2, r3
34003400:	687b      	ldr	r3, [r7, #4]
34003402:	f8c2 3218 	str.w	r3, [r2, #536]	@ 0x218
}
34003406:	bf00      	nop
34003408:	370c      	adds	r7, #12
3400340a:	46bd      	mov	sp, r7
3400340c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003410:	4770      	bx	lr
34003412:	bf00      	nop
34003414:	56028000 	.word	0x56028000

34003418 <LL_AHB3_GRP1_EnableClockLowPower>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003418:	b480      	push	{r7}
3400341a:	b085      	sub	sp, #20
3400341c:	af00      	add	r7, sp, #0
3400341e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3LPENSR, Periphs);
34003420:	4a07      	ldr	r2, [pc, #28]	@ (34003440 <LL_AHB3_GRP1_EnableClockLowPower+0x28>)
34003422:	687b      	ldr	r3, [r7, #4]
34003424:	f8c2 3a98 	str.w	r3, [r2, #2712]	@ 0xa98
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3LPENR);
34003428:	4b05      	ldr	r3, [pc, #20]	@ (34003440 <LL_AHB3_GRP1_EnableClockLowPower+0x28>)
3400342a:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
3400342e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003430:	68fb      	ldr	r3, [r7, #12]
}
34003432:	bf00      	nop
34003434:	3714      	adds	r7, #20
34003436:	46bd      	mov	sp, r7
34003438:	f85d 7b04 	ldr.w	r7, [sp], #4
3400343c:	4770      	bx	lr
3400343e:	bf00      	nop
34003440:	56028000 	.word	0x56028000

34003444 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
34003444:	b480      	push	{r7}
34003446:	b085      	sub	sp, #20
34003448:	af00      	add	r7, sp, #0
3400344a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3400344c:	4a07      	ldr	r2, [pc, #28]	@ (3400346c <LL_AHB4_GRP1_EnableClock+0x28>)
3400344e:	687b      	ldr	r3, [r7, #4]
34003450:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
34003454:	4b05      	ldr	r3, [pc, #20]	@ (3400346c <LL_AHB4_GRP1_EnableClock+0x28>)
34003456:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3400345a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3400345c:	68fb      	ldr	r3, [r7, #12]
}
3400345e:	bf00      	nop
34003460:	3714      	adds	r7, #20
34003462:	46bd      	mov	sp, r7
34003464:	f85d 7b04 	ldr.w	r7, [sp], #4
34003468:	4770      	bx	lr
3400346a:	bf00      	nop
3400346c:	56028000 	.word	0x56028000

34003470 <LL_AHB4_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003470:	b480      	push	{r7}
34003472:	b085      	sub	sp, #20
34003474:	af00      	add	r7, sp, #0
34003476:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4LPENSR, Periphs);
34003478:	4a07      	ldr	r2, [pc, #28]	@ (34003498 <LL_AHB4_GRP1_EnableClockLowPower+0x28>)
3400347a:	687b      	ldr	r3, [r7, #4]
3400347c:	f8c2 3a9c 	str.w	r3, [r2, #2716]	@ 0xa9c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4LPENR);
34003480:	4b05      	ldr	r3, [pc, #20]	@ (34003498 <LL_AHB4_GRP1_EnableClockLowPower+0x28>)
34003482:	f8d3 329c 	ldr.w	r3, [r3, #668]	@ 0x29c
34003486:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003488:	68fb      	ldr	r3, [r7, #12]
}
3400348a:	bf00      	nop
3400348c:	3714      	adds	r7, #20
3400348e:	46bd      	mov	sp, r7
34003490:	f85d 7b04 	ldr.w	r7, [sp], #4
34003494:	4770      	bx	lr
34003496:	bf00      	nop
34003498:	56028000 	.word	0x56028000

3400349c <LL_AHB5_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClock(uint32_t Periphs)
{
3400349c:	b480      	push	{r7}
3400349e:	b085      	sub	sp, #20
340034a0:	af00      	add	r7, sp, #0
340034a2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5ENSR, Periphs);
340034a4:	4a07      	ldr	r2, [pc, #28]	@ (340034c4 <LL_AHB5_GRP1_EnableClock+0x28>)
340034a6:	687b      	ldr	r3, [r7, #4]
340034a8:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5ENR);
340034ac:	4b05      	ldr	r3, [pc, #20]	@ (340034c4 <LL_AHB5_GRP1_EnableClock+0x28>)
340034ae:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
340034b2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340034b4:	68fb      	ldr	r3, [r7, #12]
}
340034b6:	bf00      	nop
340034b8:	3714      	adds	r7, #20
340034ba:	46bd      	mov	sp, r7
340034bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340034c0:	4770      	bx	lr
340034c2:	bf00      	nop
340034c4:	56028000 	.word	0x56028000

340034c8 <LL_AHB5_GRP1_ForceReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ForceReset(uint32_t Periphs)
{
340034c8:	b480      	push	{r7}
340034ca:	b083      	sub	sp, #12
340034cc:	af00      	add	r7, sp, #0
340034ce:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
340034d0:	4a04      	ldr	r2, [pc, #16]	@ (340034e4 <LL_AHB5_GRP1_ForceReset+0x1c>)
340034d2:	687b      	ldr	r3, [r7, #4]
340034d4:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
340034d8:	bf00      	nop
340034da:	370c      	adds	r7, #12
340034dc:	46bd      	mov	sp, r7
340034de:	f85d 7b04 	ldr.w	r7, [sp], #4
340034e2:	4770      	bx	lr
340034e4:	56028000 	.word	0x56028000

340034e8 <LL_AHB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_AHB5_GRP1_PERIPH_CACHEAXI
  *         @arg @ref LL_AHB5_GRP1_PERIPH_NPU
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_ReleaseReset(uint32_t Periphs)
{
340034e8:	b480      	push	{r7}
340034ea:	b083      	sub	sp, #12
340034ec:	af00      	add	r7, sp, #0
340034ee:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
340034f0:	4b06      	ldr	r3, [pc, #24]	@ (3400350c <LL_AHB5_GRP1_ReleaseReset+0x24>)
340034f2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340034f6:	461a      	mov	r2, r3
340034f8:	687b      	ldr	r3, [r7, #4]
340034fa:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
340034fe:	bf00      	nop
34003500:	370c      	adds	r7, #12
34003502:	46bd      	mov	sp, r7
34003504:	f85d 7b04 	ldr.w	r7, [sp], #4
34003508:	4770      	bx	lr
3400350a:	bf00      	nop
3400350c:	56028000 	.word	0x56028000

34003510 <LL_AHB5_GRP1_EnableClockLowPower>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003510:	b480      	push	{r7}
34003512:	b085      	sub	sp, #20
34003514:	af00      	add	r7, sp, #0
34003516:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB5LPENSR, Periphs);
34003518:	4a07      	ldr	r2, [pc, #28]	@ (34003538 <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
3400351a:	687b      	ldr	r3, [r7, #4]
3400351c:	f8c2 3aa0 	str.w	r3, [r2, #2720]	@ 0xaa0
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB5LPENR);
34003520:	4b05      	ldr	r3, [pc, #20]	@ (34003538 <LL_AHB5_GRP1_EnableClockLowPower+0x28>)
34003522:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
34003526:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003528:	68fb      	ldr	r3, [r7, #12]
}
3400352a:	bf00      	nop
3400352c:	3714      	adds	r7, #20
3400352e:	46bd      	mov	sp, r7
34003530:	f85d 7b04 	ldr.w	r7, [sp], #4
34003534:	4770      	bx	lr
34003536:	bf00      	nop
34003538:	56028000 	.word	0x56028000

3400353c <LL_APB1_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_UART8
  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClockLowPower(uint32_t Periphs)
{
3400353c:	b480      	push	{r7}
3400353e:	b085      	sub	sp, #20
34003540:	af00      	add	r7, sp, #0
34003542:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1LPENSR1, Periphs);
34003544:	4a07      	ldr	r2, [pc, #28]	@ (34003564 <LL_APB1_GRP1_EnableClockLowPower+0x28>)
34003546:	687b      	ldr	r3, [r7, #4]
34003548:	f8c2 3aa4 	str.w	r3, [r2, #2724]	@ 0xaa4
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1LPENR1);
3400354c:	4b05      	ldr	r3, [pc, #20]	@ (34003564 <LL_APB1_GRP1_EnableClockLowPower+0x28>)
3400354e:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
34003552:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003554:	68fb      	ldr	r3, [r7, #12]
}
34003556:	bf00      	nop
34003558:	3714      	adds	r7, #20
3400355a:	46bd      	mov	sp, r7
3400355c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003560:	4770      	bx	lr
34003562:	bf00      	nop
34003564:	56028000 	.word	0x56028000

34003568 <LL_APB1_GRP2_EnableClockLowPower>:
  *         @arg @ref LL_APB1_GRP2_PERIPH_MDIOS
  *         @arg @ref LL_APB1_GRP2_PERIPH_UCPD1
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP2_EnableClockLowPower(uint32_t Periphs)
{
34003568:	b480      	push	{r7}
3400356a:	b085      	sub	sp, #20
3400356c:	af00      	add	r7, sp, #0
3400356e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1LPENSR2, Periphs);
34003570:	4a07      	ldr	r2, [pc, #28]	@ (34003590 <LL_APB1_GRP2_EnableClockLowPower+0x28>)
34003572:	687b      	ldr	r3, [r7, #4]
34003574:	f8c2 3aa8 	str.w	r3, [r2, #2728]	@ 0xaa8
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1LPENR2);
34003578:	4b05      	ldr	r3, [pc, #20]	@ (34003590 <LL_APB1_GRP2_EnableClockLowPower+0x28>)
3400357a:	f8d3 32a8 	ldr.w	r3, [r3, #680]	@ 0x2a8
3400357e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003580:	68fb      	ldr	r3, [r7, #12]
}
34003582:	bf00      	nop
34003584:	3714      	adds	r7, #20
34003586:	46bd      	mov	sp, r7
34003588:	f85d 7b04 	ldr.w	r7, [sp], #4
3400358c:	4770      	bx	lr
3400358e:	bf00      	nop
34003590:	56028000 	.word	0x56028000

34003594 <LL_APB2_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB2_GRP1_PERIPH_UART9
  *         @arg @ref LL_APB2_GRP1_PERIPH_USART10
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003594:	b480      	push	{r7}
34003596:	b085      	sub	sp, #20
34003598:	af00      	add	r7, sp, #0
3400359a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB2LPENSR, Periphs);
3400359c:	4a07      	ldr	r2, [pc, #28]	@ (340035bc <LL_APB2_GRP1_EnableClockLowPower+0x28>)
3400359e:	687b      	ldr	r3, [r7, #4]
340035a0:	f8c2 3aac 	str.w	r3, [r2, #2732]	@ 0xaac
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB2LPENR);
340035a4:	4b05      	ldr	r3, [pc, #20]	@ (340035bc <LL_APB2_GRP1_EnableClockLowPower+0x28>)
340035a6:	f8d3 32ac 	ldr.w	r3, [r3, #684]	@ 0x2ac
340035aa:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340035ac:	68fb      	ldr	r3, [r7, #12]
}
340035ae:	bf00      	nop
340035b0:	3714      	adds	r7, #20
340035b2:	46bd      	mov	sp, r7
340035b4:	f85d 7b04 	ldr.w	r7, [sp], #4
340035b8:	4770      	bx	lr
340035ba:	bf00      	nop
340035bc:	56028000 	.word	0x56028000

340035c0 <LL_APB4_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB4_GRP1_PERIPH_SPI6
  *         @arg @ref LL_APB4_GRP1_PERIPH_VREFBUF
  * @retval None
  */
__STATIC_INLINE void LL_APB4_GRP1_EnableClockLowPower(uint32_t Periphs)
{
340035c0:	b480      	push	{r7}
340035c2:	b085      	sub	sp, #20
340035c4:	af00      	add	r7, sp, #0
340035c6:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB4LPENSR1, Periphs);
340035c8:	4a07      	ldr	r2, [pc, #28]	@ (340035e8 <LL_APB4_GRP1_EnableClockLowPower+0x28>)
340035ca:	687b      	ldr	r3, [r7, #4]
340035cc:	f8c2 3ab4 	str.w	r3, [r2, #2740]	@ 0xab4
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB4LPENR1);
340035d0:	4b05      	ldr	r3, [pc, #20]	@ (340035e8 <LL_APB4_GRP1_EnableClockLowPower+0x28>)
340035d2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
340035d6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340035d8:	68fb      	ldr	r3, [r7, #12]
}
340035da:	bf00      	nop
340035dc:	3714      	adds	r7, #20
340035de:	46bd      	mov	sp, r7
340035e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340035e4:	4770      	bx	lr
340035e6:	bf00      	nop
340035e8:	56028000 	.word	0x56028000

340035ec <LL_APB4_GRP2_EnableClockLowPower>:
  *         @arg @ref LL_APB4_GRP2_PERIPH_SYSCFG
  *         @arg @ref LL_APB4_GRP2_PERIPH_DTS
  * @retval None
  */
__STATIC_INLINE void LL_APB4_GRP2_EnableClockLowPower(uint32_t Periphs)
{
340035ec:	b480      	push	{r7}
340035ee:	b085      	sub	sp, #20
340035f0:	af00      	add	r7, sp, #0
340035f2:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB4LPENSR2, Periphs);
340035f4:	4a07      	ldr	r2, [pc, #28]	@ (34003614 <LL_APB4_GRP2_EnableClockLowPower+0x28>)
340035f6:	687b      	ldr	r3, [r7, #4]
340035f8:	f8c2 3ab8 	str.w	r3, [r2, #2744]	@ 0xab8
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB4LPENR2);
340035fc:	4b05      	ldr	r3, [pc, #20]	@ (34003614 <LL_APB4_GRP2_EnableClockLowPower+0x28>)
340035fe:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
34003602:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003604:	68fb      	ldr	r3, [r7, #12]
}
34003606:	bf00      	nop
34003608:	3714      	adds	r7, #20
3400360a:	46bd      	mov	sp, r7
3400360c:	f85d 7b04 	ldr.w	r7, [sp], #4
34003610:	4770      	bx	lr
34003612:	bf00      	nop
34003614:	56028000 	.word	0x56028000

34003618 <LL_APB5_GRP1_EnableClockLowPower>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClockLowPower(uint32_t Periphs)
{
34003618:	b480      	push	{r7}
3400361a:	b085      	sub	sp, #20
3400361c:	af00      	add	r7, sp, #0
3400361e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5LPENSR, Periphs);
34003620:	4a07      	ldr	r2, [pc, #28]	@ (34003640 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
34003622:	687b      	ldr	r3, [r7, #4]
34003624:	f8c2 3abc 	str.w	r3, [r2, #2748]	@ 0xabc
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5LPENR);
34003628:	4b05      	ldr	r3, [pc, #20]	@ (34003640 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
3400362a:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
3400362e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34003630:	68fb      	ldr	r3, [r7, #12]
}
34003632:	bf00      	nop
34003634:	3714      	adds	r7, #20
34003636:	46bd      	mov	sp, r7
34003638:	f85d 7b04 	ldr.w	r7, [sp], #4
3400363c:	4770      	bx	lr
3400363e:	bf00      	nop
34003640:	56028000 	.word	0x56028000

34003644 <LL_MISC_EnableClockLowPower>:
  *         @arg @ref LL_XSPIPHYCOMP
  *         @arg @ref LL_PER
  * @retval None
  */
__STATIC_INLINE void LL_MISC_EnableClockLowPower(uint32_t Misc)
{
34003644:	b480      	push	{r7}
34003646:	b085      	sub	sp, #20
34003648:	af00      	add	r7, sp, #0
3400364a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->MISCLPENSR, Misc);
3400364c:	4a07      	ldr	r2, [pc, #28]	@ (3400366c <LL_MISC_EnableClockLowPower+0x28>)
3400364e:	687b      	ldr	r3, [r7, #4]
34003650:	f8c2 3a88 	str.w	r3, [r2, #2696]	@ 0xa88
  /* Delay after an RCC miscellaneous clock enabling */
  tmpreg = READ_REG(RCC->MISCLPENR);
34003654:	4b05      	ldr	r3, [pc, #20]	@ (3400366c <LL_MISC_EnableClockLowPower+0x28>)
34003656:	f8d3 3288 	ldr.w	r3, [r3, #648]	@ 0x288
3400365a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3400365c:	68fb      	ldr	r3, [r7, #12]
}
3400365e:	bf00      	nop
34003660:	3714      	adds	r7, #20
34003662:	46bd      	mov	sp, r7
34003664:	f85d 7b04 	ldr.w	r7, [sp], #4
34003668:	4770      	bx	lr
3400366a:	bf00      	nop
3400366c:	56028000 	.word	0x56028000

34003670 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34003670:	b580      	push	{r7, lr}
34003672:	b084      	sub	sp, #16
34003674:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN 1 */
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_ICACTIVE_Msk;
34003676:	4b3d      	ldr	r3, [pc, #244]	@ (3400376c <main+0xfc>)
34003678:	681b      	ldr	r3, [r3, #0]
3400367a:	4a3c      	ldr	r2, [pc, #240]	@ (3400376c <main+0xfc>)
3400367c:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
34003680:	6013      	str	r3, [r2, #0]
  MEMSYSCTL->MSCR |= MEMSYSCTL_MSCR_DCACTIVE_Msk;
34003682:	4b3a      	ldr	r3, [pc, #232]	@ (3400376c <main+0xfc>)
34003684:	681b      	ldr	r3, [r3, #0]
34003686:	4a39      	ldr	r2, [pc, #228]	@ (3400376c <main+0xfc>)
34003688:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
3400368c:	6013      	str	r3, [r2, #0]
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
3400368e:	4b38      	ldr	r3, [pc, #224]	@ (34003770 <main+0x100>)
34003690:	695b      	ldr	r3, [r3, #20]
34003692:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34003696:	2b00      	cmp	r3, #0
34003698:	d11b      	bne.n	340036d2 <main+0x62>
  __ASM volatile ("dsb 0xF":::"memory");
3400369a:	f3bf 8f4f 	dsb	sy
}
3400369e:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
340036a0:	f3bf 8f6f 	isb	sy
}
340036a4:	bf00      	nop
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
340036a6:	4b32      	ldr	r3, [pc, #200]	@ (34003770 <main+0x100>)
340036a8:	2200      	movs	r2, #0
340036aa:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
340036ae:	f3bf 8f4f 	dsb	sy
}
340036b2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
340036b4:	f3bf 8f6f 	isb	sy
}
340036b8:	bf00      	nop
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
340036ba:	4b2d      	ldr	r3, [pc, #180]	@ (34003770 <main+0x100>)
340036bc:	695b      	ldr	r3, [r3, #20]
340036be:	4a2c      	ldr	r2, [pc, #176]	@ (34003770 <main+0x100>)
340036c0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
340036c4:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
340036c6:	f3bf 8f4f 	dsb	sy
}
340036ca:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
340036cc:	f3bf 8f6f 	isb	sy
}
340036d0:	e000      	b.n	340036d4 <main+0x64>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
340036d2:	bf00      	nop
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
340036d4:	4b26      	ldr	r3, [pc, #152]	@ (34003770 <main+0x100>)
340036d6:	695b      	ldr	r3, [r3, #20]
340036d8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340036dc:	2b00      	cmp	r3, #0
340036de:	d138      	bne.n	34003752 <main+0xe2>
    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
340036e0:	4b23      	ldr	r3, [pc, #140]	@ (34003770 <main+0x100>)
340036e2:	2200      	movs	r2, #0
340036e4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
340036e8:	f3bf 8f4f 	dsb	sy
}
340036ec:	bf00      	nop
    ccsidr = SCB->CCSIDR;
340036ee:	4b20      	ldr	r3, [pc, #128]	@ (34003770 <main+0x100>)
340036f0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340036f4:	60fb      	str	r3, [r7, #12]
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
340036f6:	68fb      	ldr	r3, [r7, #12]
340036f8:	0b5b      	lsrs	r3, r3, #13
340036fa:	f3c3 030e 	ubfx	r3, r3, #0, #15
340036fe:	60bb      	str	r3, [r7, #8]
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
34003700:	68fb      	ldr	r3, [r7, #12]
34003702:	08db      	lsrs	r3, r3, #3
34003704:	f3c3 0309 	ubfx	r3, r3, #0, #10
34003708:	607b      	str	r3, [r7, #4]
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
3400370a:	68bb      	ldr	r3, [r7, #8]
3400370c:	015a      	lsls	r2, r3, #5
3400370e:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
34003712:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
34003714:	687a      	ldr	r2, [r7, #4]
34003716:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
34003718:	4915      	ldr	r1, [pc, #84]	@ (34003770 <main+0x100>)
3400371a:	4313      	orrs	r3, r2
3400371c:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
      } while (ways-- != 0U);
34003720:	687b      	ldr	r3, [r7, #4]
34003722:	1e5a      	subs	r2, r3, #1
34003724:	607a      	str	r2, [r7, #4]
34003726:	2b00      	cmp	r3, #0
34003728:	d1ef      	bne.n	3400370a <main+0x9a>
    } while(sets-- != 0U);
3400372a:	68bb      	ldr	r3, [r7, #8]
3400372c:	1e5a      	subs	r2, r3, #1
3400372e:	60ba      	str	r2, [r7, #8]
34003730:	2b00      	cmp	r3, #0
34003732:	d1e5      	bne.n	34003700 <main+0x90>
  __ASM volatile ("dsb 0xF":::"memory");
34003734:	f3bf 8f4f 	dsb	sy
}
34003738:	bf00      	nop
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
3400373a:	4b0d      	ldr	r3, [pc, #52]	@ (34003770 <main+0x100>)
3400373c:	695b      	ldr	r3, [r3, #20]
3400373e:	4a0c      	ldr	r2, [pc, #48]	@ (34003770 <main+0x100>)
34003740:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34003744:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
34003746:	f3bf 8f4f 	dsb	sy
}
3400374a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3400374c:	f3bf 8f6f 	isb	sy
}
34003750:	e000      	b.n	34003754 <main+0xe4>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
34003752:	bf00      	nop
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Update SystemCoreClock variable according to RCC registers values. */
  SystemCoreClockUpdate();
34003754:	f003 f98a 	bl	34006a6c <SystemCoreClockUpdate>
  HAL_Init();
34003758:	f003 fb46 	bl	34006de8 <HAL_Init>

  /* USER CODE BEGIN Init */
  _tx_initialize_kernel_setup();
3400375c:	f01d fd3c 	bl	340211d8 <_tx_initialize_kernel_setup>
  tx_kernel_enter();
34003760:	f01d fd0e 	bl	34021180 <_tx_initialize_kernel_enter>

  /* USER CODE END Init */

  /* Update SystemCoreClock variable */
  SystemCoreClockUpdate();
34003764:	f003 f982 	bl	34006a6c <SystemCoreClockUpdate>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34003768:	bf00      	nop
3400376a:	e7fd      	b.n	34003768 <main+0xf8>
3400376c:	e001e000 	.word	0xe001e000
34003770:	e000ed00 	.word	0xe000ed00

34003774 <MX_DMA2D_Init>:
  * @brief DMA2D Initialization Function
  * @param None
  * @retval None
  */
void MX_DMA2D_Init(void)
{
34003774:	b580      	push	{r7, lr}
34003776:	af00      	add	r7, sp, #0
  /* USER CODE END DMA2D_Init 0 */

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
34003778:	4b0b      	ldr	r3, [pc, #44]	@ (340037a8 <MX_DMA2D_Init+0x34>)
3400377a:	4a0c      	ldr	r2, [pc, #48]	@ (340037ac <MX_DMA2D_Init+0x38>)
3400377c:	601a      	str	r2, [r3, #0]
  hdma2d.Init.Mode = DMA2D_R2M;
3400377e:	4b0a      	ldr	r3, [pc, #40]	@ (340037a8 <MX_DMA2D_Init+0x34>)
34003780:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34003784:	605a      	str	r2, [r3, #4]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
34003786:	4b08      	ldr	r3, [pc, #32]	@ (340037a8 <MX_DMA2D_Init+0x34>)
34003788:	2202      	movs	r2, #2
3400378a:	609a      	str	r2, [r3, #8]
  hdma2d.Init.OutputOffset = 0;
3400378c:	4b06      	ldr	r3, [pc, #24]	@ (340037a8 <MX_DMA2D_Init+0x34>)
3400378e:	2200      	movs	r2, #0
34003790:	60da      	str	r2, [r3, #12]
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
34003792:	4805      	ldr	r0, [pc, #20]	@ (340037a8 <MX_DMA2D_Init+0x34>)
34003794:	f006 fe68 	bl	3400a468 <HAL_DMA2D_Init>
34003798:	4603      	mov	r3, r0
3400379a:	2b00      	cmp	r3, #0
3400379c:	d001      	beq.n	340037a2 <MX_DMA2D_Init+0x2e>
  {
    Error_Handler();
3400379e:	f000 fdf1 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
340037a2:	bf00      	nop
340037a4:	bd80      	pop	{r7, pc}
340037a6:	bf00      	nop
340037a8:	34048de4 	.word	0x34048de4
340037ac:	58021000 	.word	0x58021000

340037b0 <MX_I2C2_Init>:
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
void MX_I2C2_Init(void)
{
340037b0:	b580      	push	{r7, lr}
340037b2:	af00      	add	r7, sp, #0
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
340037b4:	4b1b      	ldr	r3, [pc, #108]	@ (34003824 <MX_I2C2_Init+0x74>)
340037b6:	4a1c      	ldr	r2, [pc, #112]	@ (34003828 <MX_I2C2_Init+0x78>)
340037b8:	601a      	str	r2, [r3, #0]
  hi2c2.Init.Timing = 0x30C0EDFF;
340037ba:	4b1a      	ldr	r3, [pc, #104]	@ (34003824 <MX_I2C2_Init+0x74>)
340037bc:	4a1b      	ldr	r2, [pc, #108]	@ (3400382c <MX_I2C2_Init+0x7c>)
340037be:	605a      	str	r2, [r3, #4]
  hi2c2.Init.OwnAddress1 = 0;
340037c0:	4b18      	ldr	r3, [pc, #96]	@ (34003824 <MX_I2C2_Init+0x74>)
340037c2:	2200      	movs	r2, #0
340037c4:	609a      	str	r2, [r3, #8]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
340037c6:	4b17      	ldr	r3, [pc, #92]	@ (34003824 <MX_I2C2_Init+0x74>)
340037c8:	2201      	movs	r2, #1
340037ca:	60da      	str	r2, [r3, #12]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
340037cc:	4b15      	ldr	r3, [pc, #84]	@ (34003824 <MX_I2C2_Init+0x74>)
340037ce:	2200      	movs	r2, #0
340037d0:	611a      	str	r2, [r3, #16]
  hi2c2.Init.OwnAddress2 = 0;
340037d2:	4b14      	ldr	r3, [pc, #80]	@ (34003824 <MX_I2C2_Init+0x74>)
340037d4:	2200      	movs	r2, #0
340037d6:	615a      	str	r2, [r3, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
340037d8:	4b12      	ldr	r3, [pc, #72]	@ (34003824 <MX_I2C2_Init+0x74>)
340037da:	2200      	movs	r2, #0
340037dc:	619a      	str	r2, [r3, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
340037de:	4b11      	ldr	r3, [pc, #68]	@ (34003824 <MX_I2C2_Init+0x74>)
340037e0:	2200      	movs	r2, #0
340037e2:	61da      	str	r2, [r3, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
340037e4:	4b0f      	ldr	r3, [pc, #60]	@ (34003824 <MX_I2C2_Init+0x74>)
340037e6:	2200      	movs	r2, #0
340037e8:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
340037ea:	480e      	ldr	r0, [pc, #56]	@ (34003824 <MX_I2C2_Init+0x74>)
340037ec:	f007 fc57 	bl	3400b09e <HAL_I2C_Init>
340037f0:	4603      	mov	r3, r0
340037f2:	2b00      	cmp	r3, #0
340037f4:	d001      	beq.n	340037fa <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
340037f6:	f000 fdc5 	bl	34004384 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
340037fa:	2100      	movs	r1, #0
340037fc:	4809      	ldr	r0, [pc, #36]	@ (34003824 <MX_I2C2_Init+0x74>)
340037fe:	f008 fa09 	bl	3400bc14 <HAL_I2CEx_ConfigAnalogFilter>
34003802:	4603      	mov	r3, r0
34003804:	2b00      	cmp	r3, #0
34003806:	d001      	beq.n	3400380c <MX_I2C2_Init+0x5c>
  {
    Error_Handler();
34003808:	f000 fdbc 	bl	34004384 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
3400380c:	2100      	movs	r1, #0
3400380e:	4805      	ldr	r0, [pc, #20]	@ (34003824 <MX_I2C2_Init+0x74>)
34003810:	f008 fa4b 	bl	3400bcaa <HAL_I2CEx_ConfigDigitalFilter>
34003814:	4603      	mov	r3, r0
34003816:	2b00      	cmp	r3, #0
34003818:	d001      	beq.n	3400381e <MX_I2C2_Init+0x6e>
  {
    Error_Handler();
3400381a:	f000 fdb3 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN I2C2_Init 2 */

  /* USER CODE END I2C2_Init 2 */

}
3400381e:	bf00      	nop
34003820:	bd80      	pop	{r7, pc}
34003822:	bf00      	nop
34003824:	34048e4c 	.word	0x34048e4c
34003828:	50005800 	.word	0x50005800
3400382c:	30c0edff 	.word	0x30c0edff

34003830 <MX_LTDC_Init>:
  * @brief LTDC Initialization Function
  * @param None
  * @retval None
  */
void MX_LTDC_Init(void)
{
34003830:	b580      	push	{r7, lr}
34003832:	b09a      	sub	sp, #104	@ 0x68
34003834:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
34003836:	f107 0334 	add.w	r3, r7, #52	@ 0x34
3400383a:	2234      	movs	r2, #52	@ 0x34
3400383c:	2100      	movs	r1, #0
3400383e:	4618      	mov	r0, r3
34003840:	f023 fca8 	bl	34027194 <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
34003844:	463b      	mov	r3, r7
34003846:	2234      	movs	r2, #52	@ 0x34
34003848:	2100      	movs	r1, #0
3400384a:	4618      	mov	r0, r3
3400384c:	f023 fca2 	bl	34027194 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
34003850:	4b52      	ldr	r3, [pc, #328]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003852:	4a53      	ldr	r2, [pc, #332]	@ (340039a0 <MX_LTDC_Init+0x170>)
34003854:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
34003856:	4b51      	ldr	r3, [pc, #324]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003858:	2200      	movs	r2, #0
3400385a:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
3400385c:	4b4f      	ldr	r3, [pc, #316]	@ (3400399c <MX_LTDC_Init+0x16c>)
3400385e:	2200      	movs	r2, #0
34003860:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
34003862:	4b4e      	ldr	r3, [pc, #312]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003864:	2200      	movs	r2, #0
34003866:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34003868:	4b4c      	ldr	r3, [pc, #304]	@ (3400399c <MX_LTDC_Init+0x16c>)
3400386a:	2200      	movs	r2, #0
3400386c:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 47;
3400386e:	4b4b      	ldr	r3, [pc, #300]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003870:	222f      	movs	r2, #47	@ 0x2f
34003872:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 2;
34003874:	4b49      	ldr	r3, [pc, #292]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003876:	2202      	movs	r2, #2
34003878:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 135;
3400387a:	4b48      	ldr	r3, [pc, #288]	@ (3400399c <MX_LTDC_Init+0x16c>)
3400387c:	2287      	movs	r2, #135	@ 0x87
3400387e:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 34;
34003880:	4b46      	ldr	r3, [pc, #280]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003882:	2222      	movs	r2, #34	@ 0x22
34003884:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 935;
34003886:	4b45      	ldr	r3, [pc, #276]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003888:	f240 32a7 	movw	r2, #935	@ 0x3a7
3400388c:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc.Init.AccumulatedActiveH = 514;
3400388e:	4b43      	ldr	r3, [pc, #268]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003890:	f240 2202 	movw	r2, #514	@ 0x202
34003894:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc.Init.TotalWidth = 975;
34003896:	4b41      	ldr	r3, [pc, #260]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003898:	f240 32cf 	movw	r2, #975	@ 0x3cf
3400389c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc.Init.TotalHeigh = 527;
3400389e:	4b3f      	ldr	r3, [pc, #252]	@ (3400399c <MX_LTDC_Init+0x16c>)
340038a0:	f240 220f 	movw	r2, #527	@ 0x20f
340038a4:	631a      	str	r2, [r3, #48]	@ 0x30
  hltdc.Init.Backcolor.Blue = 0;
340038a6:	4b3d      	ldr	r3, [pc, #244]	@ (3400399c <MX_LTDC_Init+0x16c>)
340038a8:	2200      	movs	r2, #0
340038aa:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc.Init.Backcolor.Green = 0;
340038ae:	4b3b      	ldr	r3, [pc, #236]	@ (3400399c <MX_LTDC_Init+0x16c>)
340038b0:	2200      	movs	r2, #0
340038b2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc.Init.Backcolor.Red = 0;
340038b6:	4b39      	ldr	r3, [pc, #228]	@ (3400399c <MX_LTDC_Init+0x16c>)
340038b8:	2200      	movs	r2, #0
340038ba:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
340038be:	4837      	ldr	r0, [pc, #220]	@ (3400399c <MX_LTDC_Init+0x16c>)
340038c0:	f008 fa3f 	bl	3400bd42 <HAL_LTDC_Init>
340038c4:	4603      	mov	r3, r0
340038c6:	2b00      	cmp	r3, #0
340038c8:	d001      	beq.n	340038ce <MX_LTDC_Init+0x9e>
  {
    Error_Handler();
340038ca:	f000 fd5b 	bl	34004384 <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
340038ce:	2300      	movs	r3, #0
340038d0:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg.WindowX1 = 800;
340038d2:	f44f 7348 	mov.w	r3, #800	@ 0x320
340038d6:	63bb      	str	r3, [r7, #56]	@ 0x38
  pLayerCfg.WindowY0 = 0;
340038d8:	2300      	movs	r3, #0
340038da:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.WindowY1 = 480;
340038dc:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
340038e0:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
340038e2:	2304      	movs	r3, #4
340038e4:	647b      	str	r3, [r7, #68]	@ 0x44
  pLayerCfg.Alpha = 0xFF;
340038e6:	23ff      	movs	r3, #255	@ 0xff
340038e8:	64bb      	str	r3, [r7, #72]	@ 0x48
  pLayerCfg.Alpha0 = 0;
340038ea:	2300      	movs	r3, #0
340038ec:	64fb      	str	r3, [r7, #76]	@ 0x4c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
340038ee:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
340038f2:	653b      	str	r3, [r7, #80]	@ 0x50
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
340038f4:	2307      	movs	r3, #7
340038f6:	657b      	str	r3, [r7, #84]	@ 0x54
  pLayerCfg.FBStartAdress = 0;
340038f8:	2300      	movs	r3, #0
340038fa:	65bb      	str	r3, [r7, #88]	@ 0x58
  pLayerCfg.ImageWidth = 800;
340038fc:	f44f 7348 	mov.w	r3, #800	@ 0x320
34003900:	65fb      	str	r3, [r7, #92]	@ 0x5c
  pLayerCfg.ImageHeight = 480;
34003902:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
34003906:	663b      	str	r3, [r7, #96]	@ 0x60
  pLayerCfg.Backcolor.Blue = 0;
34003908:	2300      	movs	r3, #0
3400390a:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
  pLayerCfg.Backcolor.Green = 0;
3400390e:	2300      	movs	r3, #0
34003910:	f887 3065 	strb.w	r3, [r7, #101]	@ 0x65
  pLayerCfg.Backcolor.Red = 0;
34003914:	2300      	movs	r3, #0
34003916:	f887 3066 	strb.w	r3, [r7, #102]	@ 0x66
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
3400391a:	f107 0334 	add.w	r3, r7, #52	@ 0x34
3400391e:	2200      	movs	r2, #0
34003920:	4619      	mov	r1, r3
34003922:	481e      	ldr	r0, [pc, #120]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003924:	f008 fab8 	bl	3400be98 <HAL_LTDC_ConfigLayer>
34003928:	4603      	mov	r3, r0
3400392a:	2b00      	cmp	r3, #0
3400392c:	d001      	beq.n	34003932 <MX_LTDC_Init+0x102>
  {
    Error_Handler();
3400392e:	f000 fd29 	bl	34004384 <Error_Handler>
  }
  pLayerCfg1.WindowX0 = 0;
34003932:	2300      	movs	r3, #0
34003934:	603b      	str	r3, [r7, #0]
  pLayerCfg1.WindowX1 = 800;
34003936:	f44f 7348 	mov.w	r3, #800	@ 0x320
3400393a:	607b      	str	r3, [r7, #4]
  pLayerCfg1.WindowY0 = 0;
3400393c:	2300      	movs	r3, #0
3400393e:	60bb      	str	r3, [r7, #8]
  pLayerCfg1.WindowY1 = 480;
34003940:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
34003944:	60fb      	str	r3, [r7, #12]
  pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34003946:	2308      	movs	r3, #8
34003948:	613b      	str	r3, [r7, #16]
  pLayerCfg1.Alpha = 0xFF;
3400394a:	23ff      	movs	r3, #255	@ 0xff
3400394c:	617b      	str	r3, [r7, #20]
  pLayerCfg1.Alpha0 = 0;
3400394e:	2300      	movs	r3, #0
34003950:	61bb      	str	r3, [r7, #24]
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
34003952:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
34003956:	61fb      	str	r3, [r7, #28]
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34003958:	2307      	movs	r3, #7
3400395a:	623b      	str	r3, [r7, #32]
  pLayerCfg1.FBStartAdress = 0;
3400395c:	2300      	movs	r3, #0
3400395e:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg1.ImageWidth = 800;
34003960:	f44f 7348 	mov.w	r3, #800	@ 0x320
34003964:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg1.ImageHeight = 480;
34003966:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
3400396a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg1.Backcolor.Blue = 0;
3400396c:	2300      	movs	r3, #0
3400396e:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
  pLayerCfg1.Backcolor.Green = 0;
34003972:	2300      	movs	r3, #0
34003974:	f887 3031 	strb.w	r3, [r7, #49]	@ 0x31
  pLayerCfg1.Backcolor.Red = 0;
34003978:	2300      	movs	r3, #0
3400397a:	f887 3032 	strb.w	r3, [r7, #50]	@ 0x32
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
3400397e:	463b      	mov	r3, r7
34003980:	2201      	movs	r2, #1
34003982:	4619      	mov	r1, r3
34003984:	4805      	ldr	r0, [pc, #20]	@ (3400399c <MX_LTDC_Init+0x16c>)
34003986:	f008 fa87 	bl	3400be98 <HAL_LTDC_ConfigLayer>
3400398a:	4603      	mov	r3, r0
3400398c:	2b00      	cmp	r3, #0
3400398e:	d001      	beq.n	34003994 <MX_LTDC_Init+0x164>
  {
    Error_Handler();
34003990:	f000 fcf8 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
34003994:	bf00      	nop
34003996:	3768      	adds	r7, #104	@ 0x68
34003998:	46bd      	mov	sp, r7
3400399a:	bd80      	pop	{r7, pc}
3400399c:	34048ea0 	.word	0x34048ea0
340039a0:	58001000 	.word	0x58001000

340039a4 <MX_RAMCFG_Init>:
  * @brief RAMCFG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RAMCFG_Init(void)
{
340039a4:	b580      	push	{r7, lr}
340039a6:	af00      	add	r7, sp, #0

  /* USER CODE END RAMCFG_Init 1 */

  /** Initialize RAMCFG SRAM3
  */
  hramcfg_SRAM3.Instance = RAMCFG_SRAM3_AXI;
340039a8:	4b1c      	ldr	r3, [pc, #112]	@ (34003a1c <MX_RAMCFG_Init+0x78>)
340039aa:	4a1d      	ldr	r2, [pc, #116]	@ (34003a20 <MX_RAMCFG_Init+0x7c>)
340039ac:	601a      	str	r2, [r3, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM3) != HAL_OK)
340039ae:	481b      	ldr	r0, [pc, #108]	@ (34003a1c <MX_RAMCFG_Init+0x78>)
340039b0:	f009 ffc4 	bl	3400d93c <HAL_RAMCFG_Init>
340039b4:	4603      	mov	r3, r0
340039b6:	2b00      	cmp	r3, #0
340039b8:	d001      	beq.n	340039be <MX_RAMCFG_Init+0x1a>
  {
    Error_Handler();
340039ba:	f000 fce3 	bl	34004384 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM4
  */
  hramcfg_SRAM4.Instance = RAMCFG_SRAM4_AXI;
340039be:	4b19      	ldr	r3, [pc, #100]	@ (34003a24 <MX_RAMCFG_Init+0x80>)
340039c0:	4a19      	ldr	r2, [pc, #100]	@ (34003a28 <MX_RAMCFG_Init+0x84>)
340039c2:	601a      	str	r2, [r3, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM4) != HAL_OK)
340039c4:	4817      	ldr	r0, [pc, #92]	@ (34003a24 <MX_RAMCFG_Init+0x80>)
340039c6:	f009 ffb9 	bl	3400d93c <HAL_RAMCFG_Init>
340039ca:	4603      	mov	r3, r0
340039cc:	2b00      	cmp	r3, #0
340039ce:	d001      	beq.n	340039d4 <MX_RAMCFG_Init+0x30>
  {
    Error_Handler();
340039d0:	f000 fcd8 	bl	34004384 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM5
  */
  hramcfg_SRAM5.Instance = RAMCFG_SRAM5_AXI;
340039d4:	4b15      	ldr	r3, [pc, #84]	@ (34003a2c <MX_RAMCFG_Init+0x88>)
340039d6:	4a16      	ldr	r2, [pc, #88]	@ (34003a30 <MX_RAMCFG_Init+0x8c>)
340039d8:	601a      	str	r2, [r3, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM5) != HAL_OK)
340039da:	4814      	ldr	r0, [pc, #80]	@ (34003a2c <MX_RAMCFG_Init+0x88>)
340039dc:	f009 ffae 	bl	3400d93c <HAL_RAMCFG_Init>
340039e0:	4603      	mov	r3, r0
340039e2:	2b00      	cmp	r3, #0
340039e4:	d001      	beq.n	340039ea <MX_RAMCFG_Init+0x46>
  {
    Error_Handler();
340039e6:	f000 fccd 	bl	34004384 <Error_Handler>
  }

  /** Initialize RAMCFG SRAM6
  */
  hramcfg_SRAM6.Instance = RAMCFG_SRAM6_AXI;
340039ea:	4b12      	ldr	r3, [pc, #72]	@ (34003a34 <MX_RAMCFG_Init+0x90>)
340039ec:	4a12      	ldr	r2, [pc, #72]	@ (34003a38 <MX_RAMCFG_Init+0x94>)
340039ee:	601a      	str	r2, [r3, #0]
  if (HAL_RAMCFG_Init(&hramcfg_SRAM6) != HAL_OK)
340039f0:	4810      	ldr	r0, [pc, #64]	@ (34003a34 <MX_RAMCFG_Init+0x90>)
340039f2:	f009 ffa3 	bl	3400d93c <HAL_RAMCFG_Init>
340039f6:	4603      	mov	r3, r0
340039f8:	2b00      	cmp	r3, #0
340039fa:	d001      	beq.n	34003a00 <MX_RAMCFG_Init+0x5c>
  {
    Error_Handler();
340039fc:	f000 fcc2 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN RAMCFG_Init 2 */
  HAL_RAMCFG_EnableAXISRAM(&hramcfg_SRAM3);
34003a00:	4806      	ldr	r0, [pc, #24]	@ (34003a1c <MX_RAMCFG_Init+0x78>)
34003a02:	f009 ffcf 	bl	3400d9a4 <HAL_RAMCFG_EnableAXISRAM>
  HAL_RAMCFG_EnableAXISRAM(&hramcfg_SRAM4);
34003a06:	4807      	ldr	r0, [pc, #28]	@ (34003a24 <MX_RAMCFG_Init+0x80>)
34003a08:	f009 ffcc 	bl	3400d9a4 <HAL_RAMCFG_EnableAXISRAM>
  HAL_RAMCFG_EnableAXISRAM(&hramcfg_SRAM5);
34003a0c:	4807      	ldr	r0, [pc, #28]	@ (34003a2c <MX_RAMCFG_Init+0x88>)
34003a0e:	f009 ffc9 	bl	3400d9a4 <HAL_RAMCFG_EnableAXISRAM>
  HAL_RAMCFG_EnableAXISRAM(&hramcfg_SRAM6);
34003a12:	4808      	ldr	r0, [pc, #32]	@ (34003a34 <MX_RAMCFG_Init+0x90>)
34003a14:	f009 ffc6 	bl	3400d9a4 <HAL_RAMCFG_EnableAXISRAM>

  /* USER CODE END RAMCFG_Init 2 */

}
34003a18:	bf00      	nop
34003a1a:	bd80      	pop	{r7, pc}
34003a1c:	34048f48 	.word	0x34048f48
34003a20:	52023100 	.word	0x52023100
34003a24:	34048f54 	.word	0x34048f54
34003a28:	52023180 	.word	0x52023180
34003a2c:	34048f60 	.word	0x34048f60
34003a30:	52023200 	.word	0x52023200
34003a34:	34048f6c 	.word	0x34048f6c
34003a38:	52023280 	.word	0x52023280

34003a3c <SystemIsolation_Config>:
  * @brief RIF Initialization Function
  * @param None
  * @retval None
  */
  static void SystemIsolation_Config(void)
{
34003a3c:	b580      	push	{r7, lr}
34003a3e:	b082      	sub	sp, #8
34003a40:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RIF_Init 0 */

  /* USER CODE END RIF_Init 0 */

  /* set all required IPs as secure privileged */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34003a42:	f44f 7000 	mov.w	r0, #512	@ 0x200
34003a46:	f7ff fcad 	bl	340033a4 <LL_AHB3_GRP1_EnableClock>
  RIMC_MasterConfig_t RIMC_master = {0};
34003a4a:	463b      	mov	r3, r7
34003a4c:	2200      	movs	r2, #0
34003a4e:	601a      	str	r2, [r3, #0]
34003a50:	605a      	str	r2, [r3, #4]
  RIMC_master.MasterCID = RIF_CID_1;
34003a52:	2302      	movs	r3, #2
34003a54:	603b      	str	r3, [r7, #0]
  RIMC_master.SecPriv = RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV;
34003a56:	2303      	movs	r3, #3
34003a58:	607b      	str	r3, [r7, #4]

  /*RIMC configuration*/
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DCMIPP, &RIMC_master);
34003a5a:	463b      	mov	r3, r7
34003a5c:	4619      	mov	r1, r3
34003a5e:	2009      	movs	r0, #9
34003a60:	f013 fc32 	bl	340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_DMA2D, &RIMC_master);
34003a64:	463b      	mov	r3, r7
34003a66:	4619      	mov	r1, r3
34003a68:	2008      	movs	r0, #8
34003a6a:	f013 fc2d 	bl	340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC1, &RIMC_master);
34003a6e:	463b      	mov	r3, r7
34003a70:	4619      	mov	r1, r3
34003a72:	200a      	movs	r0, #10
34003a74:	f013 fc28 	bl	340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_LTDC2, &RIMC_master);
34003a78:	463b      	mov	r3, r7
34003a7a:	4619      	mov	r1, r3
34003a7c:	200b      	movs	r0, #11
34003a7e:	f013 fc23 	bl	340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>
  HAL_RIF_RIMC_ConfigMasterAttributes(RIF_MASTER_INDEX_NPU, &RIMC_master);
34003a82:	463b      	mov	r3, r7
34003a84:	4619      	mov	r1, r3
34003a86:	2001      	movs	r0, #1
34003a88:	f013 fc1e 	bl	340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>

  /*RISUP configuration*/
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DCMIPP , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003a8c:	2103      	movs	r1, #3
34003a8e:	4875      	ldr	r0, [pc, #468]	@ (34003c64 <SystemIsolation_Config+0x228>)
34003a90:	f013 fc56 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_DMA2D , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003a94:	2103      	movs	r1, #3
34003a96:	4874      	ldr	r0, [pc, #464]	@ (34003c68 <SystemIsolation_Config+0x22c>)
34003a98:	f013 fc52 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDC , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003a9c:	2103      	movs	r1, #3
34003a9e:	4873      	ldr	r0, [pc, #460]	@ (34003c6c <SystemIsolation_Config+0x230>)
34003aa0:	f013 fc4e 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL1 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003aa4:	2103      	movs	r1, #3
34003aa6:	4872      	ldr	r0, [pc, #456]	@ (34003c70 <SystemIsolation_Config+0x234>)
34003aa8:	f013 fc4a 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_LTDCL2 , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003aac:	2103      	movs	r1, #3
34003aae:	4871      	ldr	r0, [pc, #452]	@ (34003c74 <SystemIsolation_Config+0x238>)
34003ab0:	f013 fc46 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_NPU , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003ab4:	2103      	movs	r1, #3
34003ab6:	4870      	ldr	r0, [pc, #448]	@ (34003c78 <SystemIsolation_Config+0x23c>)
34003ab8:	f013 fc42 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>

  /* RIF-Aware IPs Config */

  /* set up PWR configuration */
  HAL_PWR_ConfigAttributes(PWR_ITEM_0,PWR_SEC_NPRIV);
34003abc:	2120      	movs	r1, #32
34003abe:	2001      	movs	r0, #1
34003ac0:	f009 fe3e 	bl	3400d740 <HAL_PWR_ConfigAttributes>

  /* set up GPIO configuration */
  HAL_GPIO_ConfigPinAttributes(GPIOA,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003ac4:	f240 3201 	movw	r2, #769	@ 0x301
34003ac8:	2108      	movs	r1, #8
34003aca:	486c      	ldr	r0, [pc, #432]	@ (34003c7c <SystemIsolation_Config+0x240>)
34003acc:	f007 faa0 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003ad0:	f240 3201 	movw	r2, #769	@ 0x301
34003ad4:	2110      	movs	r1, #16
34003ad6:	486a      	ldr	r0, [pc, #424]	@ (34003c80 <SystemIsolation_Config+0x244>)
34003ad8:	f007 fa9a 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOD,GPIO_PIN_14,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003adc:	f240 3201 	movw	r2, #769	@ 0x301
34003ae0:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
34003ae4:	4866      	ldr	r0, [pc, #408]	@ (34003c80 <SystemIsolation_Config+0x244>)
34003ae6:	f007 fa93 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003aea:	f240 3201 	movw	r2, #769	@ 0x301
34003aee:	2120      	movs	r1, #32
34003af0:	4864      	ldr	r0, [pc, #400]	@ (34003c84 <SystemIsolation_Config+0x248>)
34003af2:	f007 fa8d 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003af6:	f240 3201 	movw	r2, #769	@ 0x301
34003afa:	2140      	movs	r1, #64	@ 0x40
34003afc:	4861      	ldr	r0, [pc, #388]	@ (34003c84 <SystemIsolation_Config+0x248>)
34003afe:	f007 fa87 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOE,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b02:	f240 3201 	movw	r2, #769	@ 0x301
34003b06:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34003b0a:	485e      	ldr	r0, [pc, #376]	@ (34003c84 <SystemIsolation_Config+0x248>)
34003b0c:	f007 fa80 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b10:	f240 3201 	movw	r2, #769	@ 0x301
34003b14:	2110      	movs	r1, #16
34003b16:	485c      	ldr	r0, [pc, #368]	@ (34003c88 <SystemIsolation_Config+0x24c>)
34003b18:	f007 fa7a 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b1c:	f240 3201 	movw	r2, #769	@ 0x301
34003b20:	2140      	movs	r1, #64	@ 0x40
34003b22:	4859      	ldr	r0, [pc, #356]	@ (34003c88 <SystemIsolation_Config+0x24c>)
34003b24:	f007 fa74 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOG,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b28:	f240 3201 	movw	r2, #769	@ 0x301
34003b2c:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34003b30:	4855      	ldr	r0, [pc, #340]	@ (34003c88 <SystemIsolation_Config+0x24c>)
34003b32:	f007 fa6d 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b36:	f240 3201 	movw	r2, #769	@ 0x301
34003b3a:	2101      	movs	r1, #1
34003b3c:	4853      	ldr	r0, [pc, #332]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b3e:	f007 fa67 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b42:	f240 3201 	movw	r2, #769	@ 0x301
34003b46:	2102      	movs	r1, #2
34003b48:	4850      	ldr	r0, [pc, #320]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b4a:	f007 fa61 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b4e:	f240 3201 	movw	r2, #769	@ 0x301
34003b52:	2104      	movs	r1, #4
34003b54:	484d      	ldr	r0, [pc, #308]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b56:	f007 fa5b 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b5a:	f240 3201 	movw	r2, #769	@ 0x301
34003b5e:	2108      	movs	r1, #8
34003b60:	484a      	ldr	r0, [pc, #296]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b62:	f007 fa55 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b66:	f240 3201 	movw	r2, #769	@ 0x301
34003b6a:	2110      	movs	r1, #16
34003b6c:	4847      	ldr	r0, [pc, #284]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b6e:	f007 fa4f 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b72:	f240 3201 	movw	r2, #769	@ 0x301
34003b76:	2120      	movs	r1, #32
34003b78:	4844      	ldr	r0, [pc, #272]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b7a:	f007 fa49 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b7e:	f240 3201 	movw	r2, #769	@ 0x301
34003b82:	2140      	movs	r1, #64	@ 0x40
34003b84:	4841      	ldr	r0, [pc, #260]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b86:	f007 fa43 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_8,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b8a:	f240 3201 	movw	r2, #769	@ 0x301
34003b8e:	f44f 7180 	mov.w	r1, #256	@ 0x100
34003b92:	483e      	ldr	r0, [pc, #248]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003b94:	f007 fa3c 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_9,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003b98:	f240 3201 	movw	r2, #769	@ 0x301
34003b9c:	f44f 7100 	mov.w	r1, #512	@ 0x200
34003ba0:	483a      	ldr	r0, [pc, #232]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003ba2:	f007 fa35 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_10,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003ba6:	f240 3201 	movw	r2, #769	@ 0x301
34003baa:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34003bae:	4837      	ldr	r0, [pc, #220]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003bb0:	f007 fa2e 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPION,GPIO_PIN_11,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bb4:	f240 3201 	movw	r2, #769	@ 0x301
34003bb8:	f44f 6100 	mov.w	r1, #2048	@ 0x800
34003bbc:	4833      	ldr	r0, [pc, #204]	@ (34003c8c <SystemIsolation_Config+0x250>)
34003bbe:	f007 fa27 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bc2:	f240 3201 	movw	r2, #769	@ 0x301
34003bc6:	2101      	movs	r1, #1
34003bc8:	4831      	ldr	r0, [pc, #196]	@ (34003c90 <SystemIsolation_Config+0x254>)
34003bca:	f007 fa21 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bce:	f240 3201 	movw	r2, #769	@ 0x301
34003bd2:	2104      	movs	r1, #4
34003bd4:	482e      	ldr	r0, [pc, #184]	@ (34003c90 <SystemIsolation_Config+0x254>)
34003bd6:	f007 fa1b 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bda:	f240 3201 	movw	r2, #769	@ 0x301
34003bde:	2110      	movs	r1, #16
34003be0:	482b      	ldr	r0, [pc, #172]	@ (34003c90 <SystemIsolation_Config+0x254>)
34003be2:	f007 fa15 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOO,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003be6:	f240 3201 	movw	r2, #769	@ 0x301
34003bea:	2120      	movs	r1, #32
34003bec:	4828      	ldr	r0, [pc, #160]	@ (34003c90 <SystemIsolation_Config+0x254>)
34003bee:	f007 fa0f 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_0,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bf2:	f240 3201 	movw	r2, #769	@ 0x301
34003bf6:	2101      	movs	r1, #1
34003bf8:	4826      	ldr	r0, [pc, #152]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003bfa:	f007 fa09 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_1,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003bfe:	f240 3201 	movw	r2, #769	@ 0x301
34003c02:	2102      	movs	r1, #2
34003c04:	4823      	ldr	r0, [pc, #140]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c06:	f007 fa03 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_2,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c0a:	f240 3201 	movw	r2, #769	@ 0x301
34003c0e:	2104      	movs	r1, #4
34003c10:	4820      	ldr	r0, [pc, #128]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c12:	f007 f9fd 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_3,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c16:	f240 3201 	movw	r2, #769	@ 0x301
34003c1a:	2108      	movs	r1, #8
34003c1c:	481d      	ldr	r0, [pc, #116]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c1e:	f007 f9f7 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_4,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c22:	f240 3201 	movw	r2, #769	@ 0x301
34003c26:	2110      	movs	r1, #16
34003c28:	481a      	ldr	r0, [pc, #104]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c2a:	f007 f9f1 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_5,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c2e:	f240 3201 	movw	r2, #769	@ 0x301
34003c32:	2120      	movs	r1, #32
34003c34:	4817      	ldr	r0, [pc, #92]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c36:	f007 f9eb 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_6,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c3a:	f240 3201 	movw	r2, #769	@ 0x301
34003c3e:	2140      	movs	r1, #64	@ 0x40
34003c40:	4814      	ldr	r0, [pc, #80]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c42:	f007 f9e5 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>
  HAL_GPIO_ConfigPinAttributes(GPIOP,GPIO_PIN_7,GPIO_PIN_SEC|GPIO_PIN_NPRIV);
34003c46:	f240 3201 	movw	r2, #769	@ 0x301
34003c4a:	2180      	movs	r1, #128	@ 0x80
34003c4c:	4811      	ldr	r0, [pc, #68]	@ (34003c94 <SystemIsolation_Config+0x258>)
34003c4e:	f007 f9df 	bl	3400b010 <HAL_GPIO_ConfigPinAttributes>

  /* USER CODE BEGIN RIF_Init 1 */
  HAL_RIF_RISC_SetSlaveSecureAttributes(RIF_RISC_PERIPH_INDEX_CSI , RIF_ATTRIBUTE_SEC | RIF_ATTRIBUTE_PRIV);
34003c52:	2103      	movs	r1, #3
34003c54:	4810      	ldr	r0, [pc, #64]	@ (34003c98 <SystemIsolation_Config+0x25c>)
34003c56:	f013 fb73 	bl	34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>
  /* USER CODE END RIF_Init 1 */
  /* USER CODE BEGIN RIF_Init 2 */

  /* USER CODE END RIF_Init 2 */

}
34003c5a:	bf00      	nop
34003c5c:	3708      	adds	r7, #8
34003c5e:	46bd      	mov	sp, r7
34003c60:	bd80      	pop	{r7, pc}
34003c62:	bf00      	nop
34003c64:	2000001d 	.word	0x2000001d
34003c68:	30000005 	.word	0x30000005
34003c6c:	30000006 	.word	0x30000006
34003c70:	30000007 	.word	0x30000007
34003c74:	30000008 	.word	0x30000008
34003c78:	3000000a 	.word	0x3000000a
34003c7c:	56020000 	.word	0x56020000
34003c80:	56020c00 	.word	0x56020c00
34003c84:	56021000 	.word	0x56021000
34003c88:	56021800 	.word	0x56021800
34003c8c:	56023400 	.word	0x56023400
34003c90:	56023800 	.word	0x56023800
34003c94:	56023c00 	.word	0x56023c00
34003c98:	2000001c 	.word	0x2000001c

34003c9c <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
34003c9c:	b580      	push	{r7, lr}
34003c9e:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
34003ca0:	4b22      	ldr	r3, [pc, #136]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003ca2:	4a23      	ldr	r2, [pc, #140]	@ (34003d30 <MX_USART1_UART_Init+0x94>)
34003ca4:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
34003ca6:	4b21      	ldr	r3, [pc, #132]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003ca8:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
34003cac:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
34003cae:	4b1f      	ldr	r3, [pc, #124]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cb0:	2200      	movs	r2, #0
34003cb2:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
34003cb4:	4b1d      	ldr	r3, [pc, #116]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cb6:	2200      	movs	r2, #0
34003cb8:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
34003cba:	4b1c      	ldr	r3, [pc, #112]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cbc:	2200      	movs	r2, #0
34003cbe:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
34003cc0:	4b1a      	ldr	r3, [pc, #104]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cc2:	220c      	movs	r2, #12
34003cc4:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
34003cc6:	4b19      	ldr	r3, [pc, #100]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cc8:	2200      	movs	r2, #0
34003cca:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
34003ccc:	4b17      	ldr	r3, [pc, #92]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cce:	2200      	movs	r2, #0
34003cd0:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
34003cd2:	4b16      	ldr	r3, [pc, #88]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cd4:	2200      	movs	r2, #0
34003cd6:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
34003cd8:	4b14      	ldr	r3, [pc, #80]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cda:	2200      	movs	r2, #0
34003cdc:	625a      	str	r2, [r3, #36]	@ 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
34003cde:	4b13      	ldr	r3, [pc, #76]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003ce0:	2200      	movs	r2, #0
34003ce2:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
34003ce4:	4811      	ldr	r0, [pc, #68]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003ce6:	f013 fb7d 	bl	340173e4 <HAL_UART_Init>
34003cea:	4603      	mov	r3, r0
34003cec:	2b00      	cmp	r3, #0
34003cee:	d001      	beq.n	34003cf4 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
34003cf0:	f000 fb48 	bl	34004384 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
34003cf4:	2100      	movs	r1, #0
34003cf6:	480d      	ldr	r0, [pc, #52]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003cf8:	f014 f896 	bl	34017e28 <HAL_UARTEx_SetTxFifoThreshold>
34003cfc:	4603      	mov	r3, r0
34003cfe:	2b00      	cmp	r3, #0
34003d00:	d001      	beq.n	34003d06 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
34003d02:	f000 fb3f 	bl	34004384 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
34003d06:	2100      	movs	r1, #0
34003d08:	4808      	ldr	r0, [pc, #32]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003d0a:	f014 f8cb 	bl	34017ea4 <HAL_UARTEx_SetRxFifoThreshold>
34003d0e:	4603      	mov	r3, r0
34003d10:	2b00      	cmp	r3, #0
34003d12:	d001      	beq.n	34003d18 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
34003d14:	f000 fb36 	bl	34004384 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
34003d18:	4804      	ldr	r0, [pc, #16]	@ (34003d2c <MX_USART1_UART_Init+0x90>)
34003d1a:	f014 f84c 	bl	34017db6 <HAL_UARTEx_DisableFifoMode>
34003d1e:	4603      	mov	r3, r0
34003d20:	2b00      	cmp	r3, #0
34003d22:	d001      	beq.n	34003d28 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
34003d24:	f000 fb2e 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
34003d28:	bf00      	nop
34003d2a:	bd80      	pop	{r7, pc}
34003d2c:	34048f78 	.word	0x34048f78
34003d30:	52001000 	.word	0x52001000

34003d34 <MX_XSPI1_Init>:
  * @brief XSPI1 Initialization Function
  * @param None
  * @retval None
  */
void MX_XSPI1_Init(void)
{
34003d34:	b580      	push	{r7, lr}
34003d36:	b088      	sub	sp, #32
34003d38:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34003d3a:	f107 0314 	add.w	r3, r7, #20
34003d3e:	2200      	movs	r2, #0
34003d40:	601a      	str	r2, [r3, #0]
34003d42:	605a      	str	r2, [r3, #4]
34003d44:	609a      	str	r2, [r3, #8]
  XSPI_HyperbusCfgTypeDef sHyperBusCfg = {0};
34003d46:	1d3b      	adds	r3, r7, #4
34003d48:	2200      	movs	r2, #0
34003d4a:	601a      	str	r2, [r3, #0]
34003d4c:	605a      	str	r2, [r3, #4]
34003d4e:	609a      	str	r2, [r3, #8]
34003d50:	60da      	str	r2, [r3, #12]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  /* XSPI1 parameter configuration*/
  hxspi1.Instance = XSPI1;
34003d52:	4b32      	ldr	r3, [pc, #200]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d54:	4a32      	ldr	r2, [pc, #200]	@ (34003e20 <MX_XSPI1_Init+0xec>)
34003d56:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 4;
34003d58:	4b30      	ldr	r3, [pc, #192]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d5a:	2204      	movs	r2, #4
34003d5c:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34003d5e:	4b2f      	ldr	r3, [pc, #188]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d60:	2200      	movs	r2, #0
34003d62:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_HYPERBUS;
34003d64:	4b2d      	ldr	r3, [pc, #180]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d66:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34003d6a:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34003d6c:	4b2b      	ldr	r3, [pc, #172]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d6e:	2218      	movs	r2, #24
34003d70:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 2;
34003d72:	4b2a      	ldr	r3, [pc, #168]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d74:	2202      	movs	r2, #2
34003d76:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34003d78:	4b28      	ldr	r3, [pc, #160]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d7a:	2200      	movs	r2, #0
34003d7c:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34003d7e:	4b27      	ldr	r3, [pc, #156]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d80:	2200      	movs	r2, #0
34003d82:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_32_BYTES;
34003d84:	4b25      	ldr	r3, [pc, #148]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d86:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34003d8a:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 1 - 1;
34003d8c:	4b23      	ldr	r3, [pc, #140]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d8e:	2200      	movs	r2, #0
34003d90:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34003d92:	4b22      	ldr	r3, [pc, #136]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d94:	2200      	movs	r2, #0
34003d96:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34003d98:	4b20      	ldr	r3, [pc, #128]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003d9a:	2200      	movs	r2, #0
34003d9c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34003d9e:	4b1f      	ldr	r3, [pc, #124]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003da0:	2200      	movs	r2, #0
34003da2:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
34003da4:	4b1d      	ldr	r3, [pc, #116]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003da6:	2200      	movs	r2, #0
34003da8:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
34003daa:	4b1c      	ldr	r3, [pc, #112]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003dac:	2200      	movs	r2, #0
34003dae:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34003db0:	4b1a      	ldr	r3, [pc, #104]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003db2:	2200      	movs	r2, #0
34003db4:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
34003db6:	4819      	ldr	r0, [pc, #100]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003db8:	f014 f918 	bl	34017fec <HAL_XSPI_Init>
34003dbc:	4603      	mov	r3, r0
34003dbe:	2b00      	cmp	r3, #0
34003dc0:	d001      	beq.n	34003dc6 <MX_XSPI1_Init+0x92>
  {
    Error_Handler();
34003dc2:	f000 fadf 	bl	34004384 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34003dc6:	2310      	movs	r3, #16
34003dc8:	617b      	str	r3, [r7, #20]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
34003dca:	2300      	movs	r3, #0
34003dcc:	61bb      	str	r3, [r7, #24]
  sXspiManagerCfg.Req2AckTime = 1;
34003dce:	2301      	movs	r3, #1
34003dd0:	61fb      	str	r3, [r7, #28]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003dd2:	f107 0314 	add.w	r3, r7, #20
34003dd6:	f241 3288 	movw	r2, #5000	@ 0x1388
34003dda:	4619      	mov	r1, r3
34003ddc:	480f      	ldr	r0, [pc, #60]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003dde:	f014 fe21 	bl	34018a24 <HAL_XSPIM_Config>
34003de2:	4603      	mov	r3, r0
34003de4:	2b00      	cmp	r3, #0
34003de6:	d001      	beq.n	34003dec <MX_XSPI1_Init+0xb8>
  {
    Error_Handler();
34003de8:	f000 facc 	bl	34004384 <Error_Handler>
  }
  sHyperBusCfg.RWRecoveryTimeCycle = 7;
34003dec:	2307      	movs	r3, #7
34003dee:	607b      	str	r3, [r7, #4]
  sHyperBusCfg.AccessTimeCycle = 7;
34003df0:	2307      	movs	r3, #7
34003df2:	60bb      	str	r3, [r7, #8]
  sHyperBusCfg.WriteZeroLatency = HAL_XSPI_LATENCY_ON_WRITE;
34003df4:	2300      	movs	r3, #0
34003df6:	60fb      	str	r3, [r7, #12]
  sHyperBusCfg.LatencyMode = HAL_XSPI_FIXED_LATENCY;
34003df8:	2301      	movs	r3, #1
34003dfa:	613b      	str	r3, [r7, #16]
  if (HAL_XSPI_HyperbusCfg(&hxspi1, &sHyperBusCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003dfc:	1d3b      	adds	r3, r7, #4
34003dfe:	f241 3288 	movw	r2, #5000	@ 0x1388
34003e02:	4619      	mov	r1, r3
34003e04:	4805      	ldr	r0, [pc, #20]	@ (34003e1c <MX_XSPI1_Init+0xe8>)
34003e06:	f014 fa93 	bl	34018330 <HAL_XSPI_HyperbusCfg>
34003e0a:	4603      	mov	r3, r0
34003e0c:	2b00      	cmp	r3, #0
34003e0e:	d001      	beq.n	34003e14 <MX_XSPI1_Init+0xe0>
  {
    Error_Handler();
34003e10:	f000 fab8 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
34003e14:	bf00      	nop
34003e16:	3720      	adds	r7, #32
34003e18:	46bd      	mov	sp, r7
34003e1a:	bd80      	pop	{r7, pc}
34003e1c:	3404900c 	.word	0x3404900c
34003e20:	58025000 	.word	0x58025000

34003e24 <MX_XSPI2_Init>:
  * @brief XSPI2 Initialization Function
  * @param None
  * @retval None
  */
void MX_XSPI2_Init(void)
{
34003e24:	b580      	push	{r7, lr}
34003e26:	b084      	sub	sp, #16
34003e28:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI2_Init 0 */

  /* USER CODE END XSPI2_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
34003e2a:	1d3b      	adds	r3, r7, #4
34003e2c:	2200      	movs	r2, #0
34003e2e:	601a      	str	r2, [r3, #0]
34003e30:	605a      	str	r2, [r3, #4]
34003e32:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI2_Init 1 */

  /* USER CODE END XSPI2_Init 1 */
  /* XSPI2 parameter configuration*/
  hxspi2.Instance = XSPI2;
34003e34:	4b27      	ldr	r3, [pc, #156]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e36:	4a28      	ldr	r2, [pc, #160]	@ (34003ed8 <MX_XSPI2_Init+0xb4>)
34003e38:	601a      	str	r2, [r3, #0]
  hxspi2.Init.FifoThresholdByte = 4;
34003e3a:	4b26      	ldr	r3, [pc, #152]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e3c:	2204      	movs	r2, #4
34003e3e:	605a      	str	r2, [r3, #4]
  hxspi2.Init.MemoryMode = HAL_XSPI_SINGLE_MEM;
34003e40:	4b24      	ldr	r3, [pc, #144]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e42:	2200      	movs	r2, #0
34003e44:	609a      	str	r2, [r3, #8]
  hxspi2.Init.MemoryType = HAL_XSPI_MEMTYPE_MACRONIX;
34003e46:	4b23      	ldr	r3, [pc, #140]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e48:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34003e4c:	60da      	str	r2, [r3, #12]
  hxspi2.Init.MemorySize = HAL_XSPI_SIZE_256MB;
34003e4e:	4b21      	ldr	r3, [pc, #132]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e50:	2218      	movs	r2, #24
34003e52:	611a      	str	r2, [r3, #16]
  hxspi2.Init.ChipSelectHighTimeCycle = 1;
34003e54:	4b1f      	ldr	r3, [pc, #124]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e56:	2201      	movs	r2, #1
34003e58:	615a      	str	r2, [r3, #20]
  hxspi2.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_DISABLE;
34003e5a:	4b1e      	ldr	r3, [pc, #120]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e5c:	2200      	movs	r2, #0
34003e5e:	619a      	str	r2, [r3, #24]
  hxspi2.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
34003e60:	4b1c      	ldr	r3, [pc, #112]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e62:	2200      	movs	r2, #0
34003e64:	61da      	str	r2, [r3, #28]
  hxspi2.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
34003e66:	4b1b      	ldr	r3, [pc, #108]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e68:	2200      	movs	r2, #0
34003e6a:	621a      	str	r2, [r3, #32]
  hxspi2.Init.ClockPrescaler = 1 - 1;
34003e6c:	4b19      	ldr	r3, [pc, #100]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e6e:	2200      	movs	r2, #0
34003e70:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi2.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
34003e72:	4b18      	ldr	r3, [pc, #96]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e74:	2200      	movs	r2, #0
34003e76:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi2.Init.DelayHoldQuarterCycle = HAL_XSPI_DHQC_DISABLE;
34003e78:	4b16      	ldr	r3, [pc, #88]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e7a:	2200      	movs	r2, #0
34003e7c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hxspi2.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
34003e7e:	4b15      	ldr	r3, [pc, #84]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e80:	2200      	movs	r2, #0
34003e82:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi2.Init.MaxTran = 0;
34003e84:	4b13      	ldr	r3, [pc, #76]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e86:	2200      	movs	r2, #0
34003e88:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi2.Init.Refresh = 0;
34003e8a:	4b12      	ldr	r3, [pc, #72]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e8c:	2200      	movs	r2, #0
34003e8e:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi2.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
34003e90:	4b10      	ldr	r3, [pc, #64]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e92:	2200      	movs	r2, #0
34003e94:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi2) != HAL_OK)
34003e96:	480f      	ldr	r0, [pc, #60]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003e98:	f014 f8a8 	bl	34017fec <HAL_XSPI_Init>
34003e9c:	4603      	mov	r3, r0
34003e9e:	2b00      	cmp	r3, #0
34003ea0:	d001      	beq.n	34003ea6 <MX_XSPI2_Init+0x82>
  {
    Error_Handler();
34003ea2:	f000 fa6f 	bl	34004384 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34003ea6:	2310      	movs	r3, #16
34003ea8:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_2;
34003eaa:	2301      	movs	r3, #1
34003eac:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
34003eae:	2301      	movs	r3, #1
34003eb0:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi2, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34003eb2:	1d3b      	adds	r3, r7, #4
34003eb4:	f241 3288 	movw	r2, #5000	@ 0x1388
34003eb8:	4619      	mov	r1, r3
34003eba:	4806      	ldr	r0, [pc, #24]	@ (34003ed4 <MX_XSPI2_Init+0xb0>)
34003ebc:	f014 fdb2 	bl	34018a24 <HAL_XSPIM_Config>
34003ec0:	4603      	mov	r3, r0
34003ec2:	2b00      	cmp	r3, #0
34003ec4:	d001      	beq.n	34003eca <MX_XSPI2_Init+0xa6>
  {
    Error_Handler();
34003ec6:	f000 fa5d 	bl	34004384 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI2_Init 2 */

  /* USER CODE END XSPI2_Init 2 */

}
34003eca:	bf00      	nop
34003ecc:	3710      	adds	r7, #16
34003ece:	46bd      	mov	sp, r7
34003ed0:	bd80      	pop	{r7, pc}
34003ed2:	bf00      	nop
34003ed4:	34049070 	.word	0x34049070
34003ed8:	5802a000 	.word	0x5802a000

34003edc <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34003edc:	b580      	push	{r7, lr}
34003ede:	b086      	sub	sp, #24
34003ee0:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34003ee2:	1d3b      	adds	r3, r7, #4
34003ee4:	2200      	movs	r2, #0
34003ee6:	601a      	str	r2, [r3, #0]
34003ee8:	605a      	str	r2, [r3, #4]
34003eea:	609a      	str	r2, [r3, #8]
34003eec:	60da      	str	r2, [r3, #12]
34003eee:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOD_CLK_ENABLE();
34003ef0:	2008      	movs	r0, #8
34003ef2:	f7ff faa7 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
34003ef6:	2010      	movs	r0, #16
34003ef8:	f7ff faa4 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
34003efc:	2002      	movs	r0, #2
34003efe:	f7ff faa1 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34003f02:	2080      	movs	r0, #128	@ 0x80
34003f04:	f7ff fa9e 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOP_CLK_ENABLE();
34003f08:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34003f0c:	f7ff fa9a 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
34003f10:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34003f14:	f7ff fa96 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
34003f18:	2040      	movs	r0, #64	@ 0x40
34003f1a:	f7ff fa93 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOF_CLK_ENABLE();
34003f1e:	2020      	movs	r0, #32
34003f20:	f7ff fa90 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPION_CLK_ENABLE();
34003f24:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34003f28:	f7ff fa8c 	bl	34003444 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
34003f2c:	2001      	movs	r0, #1
34003f2e:	f7ff fa89 	bl	34003444 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_10, GPIO_PIN_SET);
34003f32:	2201      	movs	r2, #1
34003f34:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34003f38:	4826      	ldr	r0, [pc, #152]	@ (34003fd4 <MX_GPIO_Init+0xf8>)
34003f3a:	f007 f851 	bl	3400afe0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_4, GPIO_PIN_RESET);
34003f3e:	2200      	movs	r2, #0
34003f40:	2150      	movs	r1, #80	@ 0x50
34003f42:	4825      	ldr	r0, [pc, #148]	@ (34003fd8 <MX_GPIO_Init+0xfc>)
34003f44:	f007 f84c 	bl	3400afe0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
34003f48:	2200      	movs	r2, #0
34003f4a:	2108      	movs	r1, #8
34003f4c:	4823      	ldr	r0, [pc, #140]	@ (34003fdc <MX_GPIO_Init+0x100>)
34003f4e:	f007 f847 	bl	3400afe0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
34003f52:	2201      	movs	r2, #1
34003f54:	f44f 6180 	mov.w	r1, #1024	@ 0x400
34003f58:	481f      	ldr	r0, [pc, #124]	@ (34003fd8 <MX_GPIO_Init+0xfc>)
34003f5a:	f007 f841 	bl	3400afe0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PE10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
34003f5e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34003f62:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34003f64:	2301      	movs	r3, #1
34003f66:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
34003f68:	2302      	movs	r3, #2
34003f6a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003f6c:	2303      	movs	r3, #3
34003f6e:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
34003f70:	1d3b      	adds	r3, r7, #4
34003f72:	4619      	mov	r1, r3
34003f74:	4817      	ldr	r0, [pc, #92]	@ (34003fd4 <MX_GPIO_Init+0xf8>)
34003f76:	f006 fd41 	bl	3400a9fc <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG4 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_4;
34003f7a:	2350      	movs	r3, #80	@ 0x50
34003f7c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34003f7e:	2301      	movs	r3, #1
34003f80:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
34003f82:	2301      	movs	r3, #1
34003f84:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003f86:	2303      	movs	r3, #3
34003f88:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34003f8a:	1d3b      	adds	r3, r7, #4
34003f8c:	4619      	mov	r1, r3
34003f8e:	4812      	ldr	r0, [pc, #72]	@ (34003fd8 <MX_GPIO_Init+0xfc>)
34003f90:	f006 fd34 	bl	3400a9fc <HAL_GPIO_Init>

  /*Configure GPIO pin : PA3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
34003f94:	2308      	movs	r3, #8
34003f96:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34003f98:	2301      	movs	r3, #1
34003f9a:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
34003f9c:	2301      	movs	r3, #1
34003f9e:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003fa0:	2303      	movs	r3, #3
34003fa2:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34003fa4:	1d3b      	adds	r3, r7, #4
34003fa6:	4619      	mov	r1, r3
34003fa8:	480c      	ldr	r0, [pc, #48]	@ (34003fdc <MX_GPIO_Init+0x100>)
34003faa:	f006 fd27 	bl	3400a9fc <HAL_GPIO_Init>

  /*Configure GPIO pin : PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
34003fae:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34003fb2:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34003fb4:	2301      	movs	r3, #1
34003fb6:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
34003fb8:	2302      	movs	r3, #2
34003fba:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34003fbc:	2303      	movs	r3, #3
34003fbe:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
34003fc0:	1d3b      	adds	r3, r7, #4
34003fc2:	4619      	mov	r1, r3
34003fc4:	4804      	ldr	r0, [pc, #16]	@ (34003fd8 <MX_GPIO_Init+0xfc>)
34003fc6:	f006 fd19 	bl	3400a9fc <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
34003fca:	bf00      	nop
34003fcc:	3718      	adds	r7, #24
34003fce:	46bd      	mov	sp, r7
34003fd0:	bd80      	pop	{r7, pc}
34003fd2:	bf00      	nop
34003fd4:	56021000 	.word	0x56021000
34003fd8:	56021800 	.word	0x56021800
34003fdc:	56020000 	.word	0x56020000

34003fe0 <tx_application_define>:

/* USER CODE BEGIN 4 */
VOID tx_application_define(VOID *first_unused_memory)
{
34003fe0:	b580      	push	{r7, lr}
34003fe2:	b08a      	sub	sp, #40	@ 0x28
34003fe4:	af08      	add	r7, sp, #32
34003fe6:	6078      	str	r0, [r7, #4]
  if (tx_thread_create(&main_thread, "Main Thread", main_thread_entry, 0, main_thread_stack, sizeof(main_thread_stack), TX_MAX_PRIORITIES - 1, TX_MAX_PRIORITIES - 1, 10, TX_AUTO_START) != TX_SUCCESS)
34003fe8:	23c0      	movs	r3, #192	@ 0xc0
34003fea:	9306      	str	r3, [sp, #24]
34003fec:	2301      	movs	r3, #1
34003fee:	9305      	str	r3, [sp, #20]
34003ff0:	230a      	movs	r3, #10
34003ff2:	9304      	str	r3, [sp, #16]
34003ff4:	231f      	movs	r3, #31
34003ff6:	9303      	str	r3, [sp, #12]
34003ff8:	231f      	movs	r3, #31
34003ffa:	9302      	str	r3, [sp, #8]
34003ffc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
34004000:	9301      	str	r3, [sp, #4]
34004002:	4b08      	ldr	r3, [pc, #32]	@ (34004024 <tx_application_define+0x44>)
34004004:	9300      	str	r3, [sp, #0]
34004006:	2300      	movs	r3, #0
34004008:	4a07      	ldr	r2, [pc, #28]	@ (34004028 <tx_application_define+0x48>)
3400400a:	4908      	ldr	r1, [pc, #32]	@ (3400402c <tx_application_define+0x4c>)
3400400c:	4808      	ldr	r0, [pc, #32]	@ (34004030 <tx_application_define+0x50>)
3400400e:	f01f fced 	bl	340239ec <_txe_thread_create>
34004012:	4603      	mov	r3, r0
34004014:	2b00      	cmp	r3, #0
34004016:	d001      	beq.n	3400401c <tx_application_define+0x3c>
  {
    Error_Handler();
34004018:	f000 f9b4 	bl	34004384 <Error_Handler>
  }
}
3400401c:	bf00      	nop
3400401e:	3708      	adds	r7, #8
34004020:	46bd      	mov	sp, r7
34004022:	bd80      	pop	{r7, pc}
34004024:	34049198 	.word	0x34049198
34004028:	34004035 	.word	0x34004035
3400402c:	3402a204 	.word	0x3402a204
34004030:	340490d8 	.word	0x340490d8

34004034 <main_thread_entry>:

static VOID main_thread_entry(ULONG id)
{
34004034:	b580      	push	{r7, lr}
34004036:	b0a8      	sub	sp, #160	@ 0xa0
34004038:	af00      	add	r7, sp, #0
3400403a:	6078      	str	r0, [r7, #4]
#ifdef DEBUG
  HyperRAM_ObjectTypeDef HyperRAMObject = {0};
3400403c:	f107 0380 	add.w	r3, r7, #128	@ 0x80
34004040:	2220      	movs	r2, #32
34004042:	2100      	movs	r1, #0
34004044:	4618      	mov	r0, r3
34004046:	f023 f8a5 	bl	34027194 <memset>
  NORFlash_ObjectTypeDef NORFlashObject = {0};
3400404a:	f107 030c 	add.w	r3, r7, #12
3400404e:	2274      	movs	r2, #116	@ 0x74
34004050:	2100      	movs	r1, #0
34004052:	4618      	mov	r0, r3
34004054:	f023 f89e 	bl	34027194 <memset>
#endif

#ifdef DEBUG
  system_clock_config();
34004058:	f000 f854 	bl	34004104 <system_clock_config>
#endif
  SystemCoreClockUpdate();
3400405c:	f002 fd06 	bl	34006a6c <SystemCoreClockUpdate>

  MX_GPIO_Init();
34004060:	f7ff ff3c 	bl	34003edc <MX_GPIO_Init>
#ifdef DEBUG
  MX_XSPI1_Init();
34004064:	f7ff fe66 	bl	34003d34 <MX_XSPI1_Init>
  MX_XSPI2_Init();
34004068:	f7ff fedc 	bl	34003e24 <MX_XSPI2_Init>
#endif
  MX_USART1_UART_Init();
3400406c:	f7ff fe16 	bl	34003c9c <MX_USART1_UART_Init>
  MX_RAMCFG_Init();
34004070:	f7ff fc98 	bl	340039a4 <MX_RAMCFG_Init>
  SystemIsolation_Config();
34004074:	f7ff fce2 	bl	34003a3c <SystemIsolation_Config>

#ifdef DEBUG
  if (HyperRAM_Init(&HyperRAMObject, &hxspi1) != HyperRAM_OK)
34004078:	f107 0380 	add.w	r3, r7, #128	@ 0x80
3400407c:	491f      	ldr	r1, [pc, #124]	@ (340040fc <main_thread_entry+0xc8>)
3400407e:	4618      	mov	r0, r3
34004080:	f000 ff9b 	bl	34004fba <HyperRAM_Init>
34004084:	4603      	mov	r3, r0
34004086:	2b00      	cmp	r3, #0
34004088:	d001      	beq.n	3400408e <main_thread_entry+0x5a>
  {
    Error_Handler();
3400408a:	f000 f97b 	bl	34004384 <Error_Handler>
  }

  if (NORFlash_Init(&NORFlashObject, &hxspi2, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI2)) != NORFlash_OK)
3400408e:	f04f 0000 	mov.w	r0, #0
34004092:	f44f 0100 	mov.w	r1, #8388608	@ 0x800000
34004096:	f00e ff4f 	bl	34012f38 <HAL_RCCEx_GetPeriphCLKFreq>
3400409a:	4602      	mov	r2, r0
3400409c:	f107 030c 	add.w	r3, r7, #12
340040a0:	4917      	ldr	r1, [pc, #92]	@ (34004100 <main_thread_entry+0xcc>)
340040a2:	4618      	mov	r0, r3
340040a4:	f001 fdf8 	bl	34005c98 <NORFlash_Init>
340040a8:	4603      	mov	r3, r0
340040aa:	2b00      	cmp	r3, #0
340040ac:	d001      	beq.n	340040b2 <main_thread_entry+0x7e>
  {
    Error_Handler();
340040ae:	f000 f969 	bl	34004384 <Error_Handler>
  }

  if (HyperRAM_EnableMemoryMappedMode(&HyperRAMObject) != HyperRAM_OK)
340040b2:	f107 0380 	add.w	r3, r7, #128	@ 0x80
340040b6:	4618      	mov	r0, r3
340040b8:	f000 ffd6 	bl	34005068 <HyperRAM_EnableMemoryMappedMode>
340040bc:	4603      	mov	r3, r0
340040be:	2b00      	cmp	r3, #0
340040c0:	d001      	beq.n	340040c6 <main_thread_entry+0x92>
  {
    Error_Handler();
340040c2:	f000 f95f 	bl	34004384 <Error_Handler>
  }

  if (NORFlash_EnableMemoryMappedMode(&NORFlashObject) != NORFlash_OK)
340040c6:	f107 030c 	add.w	r3, r7, #12
340040ca:	4618      	mov	r0, r3
340040cc:	f001 ff2b 	bl	34005f26 <NORFlash_EnableMemoryMappedMode>
340040d0:	4603      	mov	r3, r0
340040d2:	2b00      	cmp	r3, #0
340040d4:	d001      	beq.n	340040da <main_thread_entry+0xa6>
  {
    Error_Handler();
340040d6:	f000 f955 	bl	34004384 <Error_Handler>
  }
#endif

  uart_init(0);
340040da:	2000      	movs	r0, #0
340040dc:	f002 fc30 	bl	34006940 <uart_init>
  npu_config();
340040e0:	f000 f8ec 	bl	340042bc <npu_config>
  iac_config();
340040e4:	f000 f8fa 	bl	340042dc <iac_config>
  npu_cache_config();
340040e8:	f000 f908 	bl	340042fc <npu_cache_config>
  low_power_clock_config();
340040ec:	f000 f90e 	bl	3400430c <low_power_clock_config>

  app_run();
340040f0:	f7fd ff2e 	bl	34001f50 <app_run>
}
340040f4:	bf00      	nop
340040f6:	37a0      	adds	r7, #160	@ 0xa0
340040f8:	46bd      	mov	sp, r7
340040fa:	bd80      	pop	{r7, pc}
340040fc:	3404900c 	.word	0x3404900c
34004100:	34049070 	.word	0x34049070

34004104 <system_clock_config>:

#ifdef DEBUG
static void system_clock_config(void)
{
34004104:	b580      	push	{r7, lr}
34004106:	b0b6      	sub	sp, #216	@ 0xd8
34004108:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
3400410a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3400410e:	2298      	movs	r2, #152	@ 0x98
34004110:	2100      	movs	r1, #0
34004112:	4618      	mov	r0, r3
34004114:	f023 f83e 	bl	34027194 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
34004118:	463b      	mov	r3, r7
3400411a:	2240      	movs	r2, #64	@ 0x40
3400411c:	2100      	movs	r1, #0
3400411e:	4618      	mov	r0, r3
34004120:	f023 f838 	bl	34027194 <memset>

  /** Configure the System Power Supply
  */
  if (HAL_PWREx_ConfigSupply(PWR_SMPS_SUPPLY) != HAL_OK)
34004124:	2004      	movs	r0, #4
34004126:	f009 fb5f 	bl	3400d7e8 <HAL_PWREx_ConfigSupply>
3400412a:	4603      	mov	r3, r0
3400412c:	2b00      	cmp	r3, #0
3400412e:	d001      	beq.n	34004134 <system_clock_config+0x30>
  {
    Error_Handler();
34004130:	f000 f928 	bl	34004384 <Error_Handler>
  }

  /* Enable HSI */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
34004134:	2302      	movs	r3, #2
34004136:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
34004138:	2308      	movs	r3, #8
3400413a:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.HSIDiv = RCC_HSI_DIV1;
3400413c:	2300      	movs	r3, #0
3400413e:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
34004140:	2300      	movs	r3, #0
34004142:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_NONE;
34004144:	2300      	movs	r3, #0
34004146:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_NONE;
34004148:	2300      	movs	r3, #0
3400414a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_NONE;
3400414e:	2300      	movs	r3, #0
34004150:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_NONE;
34004154:	2300      	movs	r3, #0
34004156:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
3400415a:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3400415e:	4618      	mov	r0, r3
34004160:	f009 feac 	bl	3400debc <HAL_RCC_OscConfig>
34004164:	4603      	mov	r3, r0
34004166:	2b00      	cmp	r3, #0
34004168:	d001      	beq.n	3400416e <system_clock_config+0x6a>
  {
    Error_Handler();
3400416a:	f000 f90b 	bl	34004384 <Error_Handler>
  }

  /** Get current CPU/System buses clocks configuration and if necessary switch
 to intermediate HSI clock to ensure target clock can be set
  */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct);
3400416e:	463b      	mov	r3, r7
34004170:	4618      	mov	r0, r3
34004172:	f00a fd83 	bl	3400ec7c <HAL_RCC_GetClockConfig>
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34004176:	687b      	ldr	r3, [r7, #4]
34004178:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400417c:	d003      	beq.n	34004186 <system_clock_config+0x82>
     (RCC_ClkInitStruct.SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11))
3400417e:	68bb      	ldr	r3, [r7, #8]
  if ((RCC_ClkInitStruct.CPUCLKSource == RCC_CPUCLKSOURCE_IC1) ||
34004180:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34004184:	d10e      	bne.n	340041a4 <system_clock_config+0xa0>
  {
    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK);
34004186:	2303      	movs	r3, #3
34004188:	603b      	str	r3, [r7, #0]
    RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_HSI;
3400418a:	2300      	movs	r3, #0
3400418c:	607b      	str	r3, [r7, #4]
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
3400418e:	2300      	movs	r3, #0
34004190:	60bb      	str	r3, [r7, #8]
    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
34004192:	463b      	mov	r3, r7
34004194:	4618      	mov	r0, r3
34004196:	f00a fa71 	bl	3400e67c <HAL_RCC_ClockConfig>
3400419a:	4603      	mov	r3, r0
3400419c:	2b00      	cmp	r3, #0
3400419e:	d001      	beq.n	340041a4 <system_clock_config+0xa0>
    {
      /* Initialization Error */
      Error_Handler();
340041a0:	f000 f8f0 	bl	34004384 <Error_Handler>
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
340041a4:	2300      	movs	r3, #0
340041a6:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL1.PLLState = RCC_PLL_ON;
340041a8:	2302      	movs	r3, #2
340041aa:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL1.PLLSource = RCC_PLLSOURCE_HSI;
340041ac:	2300      	movs	r3, #0
340041ae:	66fb      	str	r3, [r7, #108]	@ 0x6c
  RCC_OscInitStruct.PLL1.PLLM = 2;
340041b0:	2302      	movs	r3, #2
340041b2:	673b      	str	r3, [r7, #112]	@ 0x70
  RCC_OscInitStruct.PLL1.PLLN = 25;
340041b4:	2319      	movs	r3, #25
340041b6:	67bb      	str	r3, [r7, #120]	@ 0x78
  RCC_OscInitStruct.PLL1.PLLFractional = 0;
340041b8:	2300      	movs	r3, #0
340041ba:	677b      	str	r3, [r7, #116]	@ 0x74
  RCC_OscInitStruct.PLL1.PLLP1 = 1;
340041bc:	2301      	movs	r3, #1
340041be:	67fb      	str	r3, [r7, #124]	@ 0x7c
  RCC_OscInitStruct.PLL1.PLLP2 = 1;
340041c0:	2301      	movs	r3, #1
340041c2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  RCC_OscInitStruct.PLL2.PLLState = RCC_PLL_ON;
340041c6:	2302      	movs	r3, #2
340041c8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
  RCC_OscInitStruct.PLL2.PLLSource = RCC_PLLSOURCE_HSI;
340041cc:	2300      	movs	r3, #0
340041ce:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  RCC_OscInitStruct.PLL2.PLLM = 8;
340041d2:	2308      	movs	r3, #8
340041d4:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
  RCC_OscInitStruct.PLL2.PLLN = 125;
340041d8:	237d      	movs	r3, #125	@ 0x7d
340041da:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
  RCC_OscInitStruct.PLL2.PLLFractional = 0;
340041de:	2300      	movs	r3, #0
340041e0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  RCC_OscInitStruct.PLL2.PLLP1 = 1;
340041e4:	2301      	movs	r3, #1
340041e6:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
  RCC_OscInitStruct.PLL2.PLLP2 = 1;
340041ea:	2301      	movs	r3, #1
340041ec:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
  RCC_OscInitStruct.PLL3.PLLState = RCC_PLL_ON;
340041f0:	2302      	movs	r3, #2
340041f2:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
  RCC_OscInitStruct.PLL3.PLLSource = RCC_PLLSOURCE_HSI;
340041f6:	2300      	movs	r3, #0
340041f8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
  RCC_OscInitStruct.PLL3.PLLM = 8;
340041fc:	2308      	movs	r3, #8
340041fe:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
  RCC_OscInitStruct.PLL3.PLLN = 200;
34004202:	23c8      	movs	r3, #200	@ 0xc8
34004204:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
  RCC_OscInitStruct.PLL3.PLLFractional = 0;
34004208:	2300      	movs	r3, #0
3400420a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  RCC_OscInitStruct.PLL3.PLLP1 = 1;
3400420e:	2301      	movs	r3, #1
34004210:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
  RCC_OscInitStruct.PLL3.PLLP2 = 2;
34004214:	2302      	movs	r3, #2
34004216:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
  RCC_OscInitStruct.PLL4.PLLState = RCC_PLL_ON;
3400421a:	2302      	movs	r3, #2
3400421c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
  RCC_OscInitStruct.PLL4.PLLSource = RCC_PLLSOURCE_HSI;
34004220:	2300      	movs	r3, #0
34004222:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
  RCC_OscInitStruct.PLL4.PLLM = 8;
34004226:	2308      	movs	r3, #8
34004228:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
  RCC_OscInitStruct.PLL4.PLLN = 225;
3400422c:	23e1      	movs	r3, #225	@ 0xe1
3400422e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
  RCC_OscInitStruct.PLL4.PLLFractional = 0;
34004232:	2300      	movs	r3, #0
34004234:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
  RCC_OscInitStruct.PLL4.PLLP1 = 3;
34004238:	2303      	movs	r3, #3
3400423a:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
  RCC_OscInitStruct.PLL4.PLLP2 = 6;
3400423e:	2306      	movs	r3, #6
34004240:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
34004244:	f107 0340 	add.w	r3, r7, #64	@ 0x40
34004248:	4618      	mov	r0, r3
3400424a:	f009 fe37 	bl	3400debc <HAL_RCC_OscConfig>
3400424e:	4603      	mov	r3, r0
34004250:	2b00      	cmp	r3, #0
34004252:	d001      	beq.n	34004258 <system_clock_config+0x154>
  {
    Error_Handler();
34004254:	f000 f896 	bl	34004384 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_CPUCLK|RCC_CLOCKTYPE_HCLK
34004258:	237f      	movs	r3, #127	@ 0x7f
3400425a:	603b      	str	r3, [r7, #0]
                              |RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
                              |RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_PCLK5
                              |RCC_CLOCKTYPE_PCLK4;
  RCC_ClkInitStruct.CPUCLKSource = RCC_CPUCLKSOURCE_IC1;
3400425c:	f44f 3340 	mov.w	r3, #196608	@ 0x30000
34004260:	607b      	str	r3, [r7, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_IC2_IC6_IC11;
34004262:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
34004266:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
34004268:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
3400426c:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
3400426e:	2300      	movs	r3, #0
34004270:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
34004272:	2300      	movs	r3, #0
34004274:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
34004276:	2300      	movs	r3, #0
34004278:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB5CLKDivider = RCC_APB5_DIV1;
3400427a:	2300      	movs	r3, #0
3400427c:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.IC1Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
3400427e:	2300      	movs	r3, #0
34004280:	623b      	str	r3, [r7, #32]
  RCC_ClkInitStruct.IC1Selection.ClockDivider = 1;
34004282:	2301      	movs	r3, #1
34004284:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_ClkInitStruct.IC2Selection.ClockSelection = RCC_ICCLKSOURCE_PLL1;
34004286:	2300      	movs	r3, #0
34004288:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_ClkInitStruct.IC2Selection.ClockDivider = 2;
3400428a:	2302      	movs	r3, #2
3400428c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  RCC_ClkInitStruct.IC6Selection.ClockSelection = RCC_ICCLKSOURCE_PLL2;
3400428e:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
34004292:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_ClkInitStruct.IC6Selection.ClockDivider = 1;
34004294:	2301      	movs	r3, #1
34004296:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_ClkInitStruct.IC11Selection.ClockSelection = RCC_ICCLKSOURCE_PLL3;
34004298:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
3400429c:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_ClkInitStruct.IC11Selection.ClockDivider = 1;
3400429e:	2301      	movs	r3, #1
340042a0:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct) != HAL_OK)
340042a2:	463b      	mov	r3, r7
340042a4:	4618      	mov	r0, r3
340042a6:	f00a f9e9 	bl	3400e67c <HAL_RCC_ClockConfig>
340042aa:	4603      	mov	r3, r0
340042ac:	2b00      	cmp	r3, #0
340042ae:	d001      	beq.n	340042b4 <system_clock_config+0x1b0>
  {
    Error_Handler();
340042b0:	f000 f868 	bl	34004384 <Error_Handler>
  }
}
340042b4:	bf00      	nop
340042b6:	37d8      	adds	r7, #216	@ 0xd8
340042b8:	46bd      	mov	sp, r7
340042ba:	bd80      	pop	{r7, pc}

340042bc <npu_config>:
#endif

static void npu_config(void)
{
340042bc:	b580      	push	{r7, lr}
340042be:	af00      	add	r7, sp, #0
  __HAL_RCC_NPU_CLK_ENABLE();
340042c0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
340042c4:	f7ff f8ea 	bl	3400349c <LL_AHB5_GRP1_EnableClock>
  __HAL_RCC_NPU_FORCE_RESET();
340042c8:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
340042cc:	f7ff f8fc 	bl	340034c8 <LL_AHB5_GRP1_ForceReset>
  __HAL_RCC_NPU_RELEASE_RESET();
340042d0:	f04f 4000 	mov.w	r0, #2147483648	@ 0x80000000
340042d4:	f7ff f908 	bl	340034e8 <LL_AHB5_GRP1_ReleaseReset>
}
340042d8:	bf00      	nop
340042da:	bd80      	pop	{r7, pc}

340042dc <iac_config>:

static void iac_config(void)
{
340042dc:	b580      	push	{r7, lr}
340042de:	af00      	add	r7, sp, #0
  __HAL_RCC_IAC_CLK_ENABLE();
340042e0:	f44f 6080 	mov.w	r0, #1024	@ 0x400
340042e4:	f7ff f85e 	bl	340033a4 <LL_AHB3_GRP1_EnableClock>
  __HAL_RCC_IAC_FORCE_RESET();
340042e8:	f44f 6080 	mov.w	r0, #1024	@ 0x400
340042ec:	f7ff f870 	bl	340033d0 <LL_AHB3_GRP1_ForceReset>
  __HAL_RCC_IAC_RELEASE_RESET();
340042f0:	f44f 6080 	mov.w	r0, #1024	@ 0x400
340042f4:	f7ff f87c 	bl	340033f0 <LL_AHB3_GRP1_ReleaseReset>
}
340042f8:	bf00      	nop
340042fa:	bd80      	pop	{r7, pc}

340042fc <npu_cache_config>:

static void npu_cache_config(void)
{
340042fc:	b580      	push	{r7, lr}
340042fe:	af00      	add	r7, sp, #0
  npu_cache_init();
34004300:	f014 ff74 	bl	340191ec <npu_cache_init>
  npu_cache_enable();
34004304:	f014 ff80 	bl	34019208 <npu_cache_enable>
}
34004308:	bf00      	nop
3400430a:	bd80      	pop	{r7, pc}

3400430c <low_power_clock_config>:

static void low_power_clock_config(void)
{
3400430c:	b580      	push	{r7, lr}
3400430e:	af00      	add	r7, sp, #0
  LL_BUS_EnableClockLowPower(~0);
34004310:	f04f 30ff 	mov.w	r0, #4294967295
34004314:	f7fe ffee 	bl	340032f4 <LL_BUS_EnableClockLowPower>
  LL_MEM_EnableClockLowPower(~0);
34004318:	f04f 30ff 	mov.w	r0, #4294967295
3400431c:	f7ff f800 	bl	34003320 <LL_MEM_EnableClockLowPower>
  LL_AHB1_GRP1_EnableClockLowPower(~0);
34004320:	f04f 30ff 	mov.w	r0, #4294967295
34004324:	f7ff f812 	bl	3400334c <LL_AHB1_GRP1_EnableClockLowPower>
  LL_AHB2_GRP1_EnableClockLowPower(~0);
34004328:	f04f 30ff 	mov.w	r0, #4294967295
3400432c:	f7ff f824 	bl	34003378 <LL_AHB2_GRP1_EnableClockLowPower>
  LL_AHB3_GRP1_EnableClockLowPower(~0);
34004330:	f04f 30ff 	mov.w	r0, #4294967295
34004334:	f7ff f870 	bl	34003418 <LL_AHB3_GRP1_EnableClockLowPower>
  LL_AHB4_GRP1_EnableClockLowPower(~0);
34004338:	f04f 30ff 	mov.w	r0, #4294967295
3400433c:	f7ff f898 	bl	34003470 <LL_AHB4_GRP1_EnableClockLowPower>
  LL_AHB5_GRP1_EnableClockLowPower(~0);
34004340:	f04f 30ff 	mov.w	r0, #4294967295
34004344:	f7ff f8e4 	bl	34003510 <LL_AHB5_GRP1_EnableClockLowPower>
  LL_APB1_GRP1_EnableClockLowPower(~0);
34004348:	f04f 30ff 	mov.w	r0, #4294967295
3400434c:	f7ff f8f6 	bl	3400353c <LL_APB1_GRP1_EnableClockLowPower>
  LL_APB1_GRP2_EnableClockLowPower(~0);
34004350:	f04f 30ff 	mov.w	r0, #4294967295
34004354:	f7ff f908 	bl	34003568 <LL_APB1_GRP2_EnableClockLowPower>
  LL_APB2_GRP1_EnableClockLowPower(~0);
34004358:	f04f 30ff 	mov.w	r0, #4294967295
3400435c:	f7ff f91a 	bl	34003594 <LL_APB2_GRP1_EnableClockLowPower>
  LL_APB4_GRP1_EnableClockLowPower(~0);
34004360:	f04f 30ff 	mov.w	r0, #4294967295
34004364:	f7ff f92c 	bl	340035c0 <LL_APB4_GRP1_EnableClockLowPower>
  LL_APB4_GRP2_EnableClockLowPower(~0);
34004368:	f04f 30ff 	mov.w	r0, #4294967295
3400436c:	f7ff f93e 	bl	340035ec <LL_APB4_GRP2_EnableClockLowPower>
  LL_APB5_GRP1_EnableClockLowPower(~0);
34004370:	f04f 30ff 	mov.w	r0, #4294967295
34004374:	f7ff f950 	bl	34003618 <LL_APB5_GRP1_EnableClockLowPower>
  LL_MISC_EnableClockLowPower(~0);
34004378:	f04f 30ff 	mov.w	r0, #4294967295
3400437c:	f7ff f962 	bl	34003644 <LL_MISC_EnableClockLowPower>
}
34004380:	bf00      	nop
34004382:	bd80      	pop	{r7, pc}

34004384 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
34004384:	b480      	push	{r7}
34004386:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
34004388:	b672      	cpsid	i
}
3400438a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
3400438c:	bf00      	nop
3400438e:	e7fd      	b.n	3400438c <Error_Handler+0x8>

34004390 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
34004390:	b2c0      	uxtb	r0, r0
34004392:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34004396:	b480      	push	{r7}
34004398:	b082      	sub	sp, #8
3400439a:	af00      	add	r7, sp, #0
3400439c:	4603      	mov	r3, r0
3400439e:	6039      	str	r1, [r7, #0]
340043a0:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
340043a2:	683b      	ldr	r3, [r7, #0]
340043a4:	2b00      	cmp	r3, #0
340043a6:	d00d      	beq.n	340043c4 <__acle_se_SECURE_RegisterCallback+0x34>
  {
    switch(CallbackId)
340043a8:	79fb      	ldrb	r3, [r7, #7]
340043aa:	2b00      	cmp	r3, #0
340043ac:	d002      	beq.n	340043b4 <__acle_se_SECURE_RegisterCallback+0x24>
340043ae:	2b01      	cmp	r3, #1
340043b0:	d004      	beq.n	340043bc <__acle_se_SECURE_RegisterCallback+0x2c>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
340043b2:	e007      	b.n	340043c4 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureFaultCallback = func;
340043b4:	4a09      	ldr	r2, [pc, #36]	@ (340043dc <__acle_se_SECURE_RegisterCallback+0x4c>)
340043b6:	683b      	ldr	r3, [r7, #0]
340043b8:	6013      	str	r3, [r2, #0]
        break;
340043ba:	e003      	b.n	340043c4 <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureErrorCallback = func;
340043bc:	4a08      	ldr	r2, [pc, #32]	@ (340043e0 <__acle_se_SECURE_RegisterCallback+0x50>)
340043be:	683b      	ldr	r3, [r7, #0]
340043c0:	6013      	str	r3, [r2, #0]
        break;
340043c2:	bf00      	nop
    }
  }
}
340043c4:	bf00      	nop
340043c6:	3708      	adds	r7, #8
340043c8:	46bd      	mov	sp, r7
340043ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340043ce:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
340043d2:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
340043d6:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
340043da:	4774      	bxns	lr
340043dc:	3404a198 	.word	0x3404a198
340043e0:	3404a19c 	.word	0x3404a19c

340043e4 <UTIL_LCDEx_PrintfAt>:
  UTIL_LCD_DisplayStringAtLine(line, (uint8_t *) buffer);
  va_end(args);
}

void UTIL_LCDEx_PrintfAt(uint32_t x_pos, uint32_t y_pos, Text_AlignModeTypdef mode, const char * format, ...)
{
340043e4:	b408      	push	{r3}
340043e6:	b580      	push	{r7, lr}
340043e8:	b087      	sub	sp, #28
340043ea:	af00      	add	r7, sp, #0
340043ec:	60f8      	str	r0, [r7, #12]
340043ee:	60b9      	str	r1, [r7, #8]
340043f0:	4613      	mov	r3, r2
340043f2:	71fb      	strb	r3, [r7, #7]
  static char buffer[N_PRINTABLE_CHARS + 1];
  va_list args;
  va_start(args, format);
340043f4:	f107 0328 	add.w	r3, r7, #40	@ 0x28
340043f8:	617b      	str	r3, [r7, #20]
  vsnprintf(buffer, N_PRINTABLE_CHARS + 1, format, args);
340043fa:	697b      	ldr	r3, [r7, #20]
340043fc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340043fe:	2130      	movs	r1, #48	@ 0x30
34004400:	4807      	ldr	r0, [pc, #28]	@ (34004420 <UTIL_LCDEx_PrintfAt+0x3c>)
34004402:	f022 fe0b 	bl	3402701c <vsniprintf>
  UTIL_LCD_DisplayStringAt(x_pos, y_pos, (uint8_t *) buffer, mode);
34004406:	79fb      	ldrb	r3, [r7, #7]
34004408:	4a05      	ldr	r2, [pc, #20]	@ (34004420 <UTIL_LCDEx_PrintfAt+0x3c>)
3400440a:	68b9      	ldr	r1, [r7, #8]
3400440c:	68f8      	ldr	r0, [r7, #12]
3400440e:	f020 fa45 	bl	3402489c <UTIL_LCD_DisplayStringAt>
  va_end(args);
}
34004412:	bf00      	nop
34004414:	371c      	adds	r7, #28
34004416:	46bd      	mov	sp, r7
34004418:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
3400441c:	b001      	add	sp, #4
3400441e:	4770      	bx	lr
34004420:	3404a1a0 	.word	0x3404a1a0

34004424 <LL_MEM_EnableClock>:
{
34004424:	b480      	push	{r7}
34004426:	b085      	sub	sp, #20
34004428:	af00      	add	r7, sp, #0
3400442a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->MEMENSR, Memories);
3400442c:	4a07      	ldr	r2, [pc, #28]	@ (3400444c <LL_MEM_EnableClock+0x28>)
3400442e:	687b      	ldr	r3, [r7, #4]
34004430:	f8c2 3a4c 	str.w	r3, [r2, #2636]	@ 0xa4c
  tmpreg = READ_REG(RCC->MEMENR);
34004434:	4b05      	ldr	r3, [pc, #20]	@ (3400444c <LL_MEM_EnableClock+0x28>)
34004436:	f8d3 324c 	ldr.w	r3, [r3, #588]	@ 0x24c
3400443a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3400443c:	68fb      	ldr	r3, [r7, #12]
}
3400443e:	bf00      	nop
34004440:	3714      	adds	r7, #20
34004442:	46bd      	mov	sp, r7
34004444:	f85d 7b04 	ldr.w	r7, [sp], #4
34004448:	4770      	bx	lr
3400444a:	bf00      	nop
3400444c:	56028000 	.word	0x56028000

34004450 <LL_AHB2_GRP1_EnableClock>:
{
34004450:	b480      	push	{r7}
34004452:	b085      	sub	sp, #20
34004454:	af00      	add	r7, sp, #0
34004456:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB2ENSR, Periphs);
34004458:	4a07      	ldr	r2, [pc, #28]	@ (34004478 <LL_AHB2_GRP1_EnableClock+0x28>)
3400445a:	687b      	ldr	r3, [r7, #4]
3400445c:	f8c2 3a54 	str.w	r3, [r2, #2644]	@ 0xa54
  tmpreg = READ_REG(RCC->AHB2ENR);
34004460:	4b05      	ldr	r3, [pc, #20]	@ (34004478 <LL_AHB2_GRP1_EnableClock+0x28>)
34004462:	f8d3 3254 	ldr.w	r3, [r3, #596]	@ 0x254
34004466:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004468:	68fb      	ldr	r3, [r7, #12]
}
3400446a:	bf00      	nop
3400446c:	3714      	adds	r7, #20
3400446e:	46bd      	mov	sp, r7
34004470:	f85d 7b04 	ldr.w	r7, [sp], #4
34004474:	4770      	bx	lr
34004476:	bf00      	nop
34004478:	56028000 	.word	0x56028000

3400447c <LL_AHB4_GRP1_EnableClock>:
{
3400447c:	b480      	push	{r7}
3400447e:	b085      	sub	sp, #20
34004480:	af00      	add	r7, sp, #0
34004482:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34004484:	4a07      	ldr	r2, [pc, #28]	@ (340044a4 <LL_AHB4_GRP1_EnableClock+0x28>)
34004486:	687b      	ldr	r3, [r7, #4]
34004488:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3400448c:	4b05      	ldr	r3, [pc, #20]	@ (340044a4 <LL_AHB4_GRP1_EnableClock+0x28>)
3400448e:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34004492:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004494:	68fb      	ldr	r3, [r7, #12]
}
34004496:	bf00      	nop
34004498:	3714      	adds	r7, #20
3400449a:	46bd      	mov	sp, r7
3400449c:	f85d 7b04 	ldr.w	r7, [sp], #4
340044a0:	4770      	bx	lr
340044a2:	bf00      	nop
340044a4:	56028000 	.word	0x56028000

340044a8 <LL_AHB5_GRP1_EnableClock>:
{
340044a8:	b480      	push	{r7}
340044aa:	b085      	sub	sp, #20
340044ac:	af00      	add	r7, sp, #0
340044ae:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
340044b0:	4a07      	ldr	r2, [pc, #28]	@ (340044d0 <LL_AHB5_GRP1_EnableClock+0x28>)
340044b2:	687b      	ldr	r3, [r7, #4]
340044b4:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
340044b8:	4b05      	ldr	r3, [pc, #20]	@ (340044d0 <LL_AHB5_GRP1_EnableClock+0x28>)
340044ba:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
340044be:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340044c0:	68fb      	ldr	r3, [r7, #12]
}
340044c2:	bf00      	nop
340044c4:	3714      	adds	r7, #20
340044c6:	46bd      	mov	sp, r7
340044c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340044cc:	4770      	bx	lr
340044ce:	bf00      	nop
340044d0:	56028000 	.word	0x56028000

340044d4 <LL_AHB5_GRP1_ForceReset>:
{
340044d4:	b480      	push	{r7}
340044d6:	b083      	sub	sp, #12
340044d8:	af00      	add	r7, sp, #0
340044da:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
340044dc:	4a04      	ldr	r2, [pc, #16]	@ (340044f0 <LL_AHB5_GRP1_ForceReset+0x1c>)
340044de:	687b      	ldr	r3, [r7, #4]
340044e0:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
340044e4:	bf00      	nop
340044e6:	370c      	adds	r7, #12
340044e8:	46bd      	mov	sp, r7
340044ea:	f85d 7b04 	ldr.w	r7, [sp], #4
340044ee:	4770      	bx	lr
340044f0:	56028000 	.word	0x56028000

340044f4 <LL_AHB5_GRP1_ReleaseReset>:
{
340044f4:	b480      	push	{r7}
340044f6:	b083      	sub	sp, #12
340044f8:	af00      	add	r7, sp, #0
340044fa:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
340044fc:	4b06      	ldr	r3, [pc, #24]	@ (34004518 <LL_AHB5_GRP1_ReleaseReset+0x24>)
340044fe:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34004502:	461a      	mov	r2, r3
34004504:	687b      	ldr	r3, [r7, #4]
34004506:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
3400450a:	bf00      	nop
3400450c:	370c      	adds	r7, #12
3400450e:	46bd      	mov	sp, r7
34004510:	f85d 7b04 	ldr.w	r7, [sp], #4
34004514:	4770      	bx	lr
34004516:	bf00      	nop
34004518:	56028000 	.word	0x56028000

3400451c <LL_APB1_GRP1_EnableClock>:
{
3400451c:	b480      	push	{r7}
3400451e:	b085      	sub	sp, #20
34004520:	af00      	add	r7, sp, #0
34004522:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENSR1, Periphs);
34004524:	4a07      	ldr	r2, [pc, #28]	@ (34004544 <LL_APB1_GRP1_EnableClock+0x28>)
34004526:	687b      	ldr	r3, [r7, #4]
34004528:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  tmpreg = READ_REG(RCC->APB1ENR1);
3400452c:	4b05      	ldr	r3, [pc, #20]	@ (34004544 <LL_APB1_GRP1_EnableClock+0x28>)
3400452e:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
34004532:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004534:	68fb      	ldr	r3, [r7, #12]
}
34004536:	bf00      	nop
34004538:	3714      	adds	r7, #20
3400453a:	46bd      	mov	sp, r7
3400453c:	f85d 7b04 	ldr.w	r7, [sp], #4
34004540:	4770      	bx	lr
34004542:	bf00      	nop
34004544:	56028000 	.word	0x56028000

34004548 <LL_APB1_GRP1_DisableClock>:
{
34004548:	b480      	push	{r7}
3400454a:	b083      	sub	sp, #12
3400454c:	af00      	add	r7, sp, #0
3400454e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB1ENCR1, Periphs);
34004550:	4b06      	ldr	r3, [pc, #24]	@ (3400456c <LL_APB1_GRP1_DisableClock+0x24>)
34004552:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34004556:	461a      	mov	r2, r3
34004558:	687b      	ldr	r3, [r7, #4]
3400455a:	f8c2 3264 	str.w	r3, [r2, #612]	@ 0x264
}
3400455e:	bf00      	nop
34004560:	370c      	adds	r7, #12
34004562:	46bd      	mov	sp, r7
34004564:	f85d 7b04 	ldr.w	r7, [sp], #4
34004568:	4770      	bx	lr
3400456a:	bf00      	nop
3400456c:	56028000 	.word	0x56028000

34004570 <LL_APB2_GRP1_EnableClock>:
{
34004570:	b480      	push	{r7}
34004572:	b085      	sub	sp, #20
34004574:	af00      	add	r7, sp, #0
34004576:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB2ENSR, Periphs);
34004578:	4a07      	ldr	r2, [pc, #28]	@ (34004598 <LL_APB2_GRP1_EnableClock+0x28>)
3400457a:	687b      	ldr	r3, [r7, #4]
3400457c:	f8c2 3a6c 	str.w	r3, [r2, #2668]	@ 0xa6c
  tmpreg = READ_REG(RCC->APB2ENR);
34004580:	4b05      	ldr	r3, [pc, #20]	@ (34004598 <LL_APB2_GRP1_EnableClock+0x28>)
34004582:	f8d3 326c 	ldr.w	r3, [r3, #620]	@ 0x26c
34004586:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34004588:	68fb      	ldr	r3, [r7, #12]
}
3400458a:	bf00      	nop
3400458c:	3714      	adds	r7, #20
3400458e:	46bd      	mov	sp, r7
34004590:	f85d 7b04 	ldr.w	r7, [sp], #4
34004594:	4770      	bx	lr
34004596:	bf00      	nop
34004598:	56028000 	.word	0x56028000

3400459c <LL_APB5_GRP1_EnableClock>:
{
3400459c:	b480      	push	{r7}
3400459e:	b085      	sub	sp, #20
340045a0:	af00      	add	r7, sp, #0
340045a2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
340045a4:	4a07      	ldr	r2, [pc, #28]	@ (340045c4 <LL_APB5_GRP1_EnableClock+0x28>)
340045a6:	687b      	ldr	r3, [r7, #4]
340045a8:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
340045ac:	4b05      	ldr	r3, [pc, #20]	@ (340045c4 <LL_APB5_GRP1_EnableClock+0x28>)
340045ae:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
340045b2:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
340045b4:	68fb      	ldr	r3, [r7, #12]
}
340045b6:	bf00      	nop
340045b8:	3714      	adds	r7, #20
340045ba:	46bd      	mov	sp, r7
340045bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340045c0:	4770      	bx	lr
340045c2:	bf00      	nop
340045c4:	56028000 	.word	0x56028000

340045c8 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
340045c8:	b580      	push	{r7, lr}
340045ca:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
340045cc:	f009 f986 	bl	3400d8dc <HAL_PWREx_EnableVddIO2>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO2,PWR_VDDIO_RANGE_1V8);
340045d0:	2101      	movs	r1, #1
340045d2:	2001      	movs	r0, #1
340045d4:	f009 f930 	bl	3400d838 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO3();
340045d8:	f009 f990 	bl	3400d8fc <HAL_PWREx_EnableVddIO3>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO3,PWR_VDDIO_RANGE_1V8);
340045dc:	2101      	movs	r1, #1
340045de:	2002      	movs	r0, #2
340045e0:	f009 f92a 	bl	3400d838 <HAL_PWREx_ConfigVddIORange>

  HAL_PWREx_EnableVddIO4();
340045e4:	f009 f99a 	bl	3400d91c <HAL_PWREx_EnableVddIO4>
  HAL_PWREx_ConfigVddIORange(PWR_VDDIO4,PWR_VDDIO_RANGE_3V3);
340045e8:	2100      	movs	r1, #0
340045ea:	2003      	movs	r0, #3
340045ec:	f009 f924 	bl	3400d838 <HAL_PWREx_ConfigVddIORange>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
340045f0:	bf00      	nop
340045f2:	bd80      	pop	{r7, pc}

340045f4 <HAL_DMA2D_MspInit>:
* This function configures the hardware resources used in this example
* @param hdma2d: DMA2D handle pointer
* @retval None
*/
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
{
340045f4:	b580      	push	{r7, lr}
340045f6:	b082      	sub	sp, #8
340045f8:	af00      	add	r7, sp, #0
340045fa:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance==DMA2D)
340045fc:	687b      	ldr	r3, [r7, #4]
340045fe:	681b      	ldr	r3, [r3, #0]
34004600:	4a04      	ldr	r2, [pc, #16]	@ (34004614 <HAL_DMA2D_MspInit+0x20>)
34004602:	4293      	cmp	r3, r2
34004604:	d102      	bne.n	3400460c <HAL_DMA2D_MspInit+0x18>
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
34004606:	2002      	movs	r0, #2
34004608:	f7ff ff4e 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>

  /* USER CODE END DMA2D_MspInit 1 */

  }

}
3400460c:	bf00      	nop
3400460e:	3708      	adds	r7, #8
34004610:	46bd      	mov	sp, r7
34004612:	bd80      	pop	{r7, pc}
34004614:	58021000 	.word	0x58021000

34004618 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
34004618:	b580      	push	{r7, lr}
3400461a:	b0ec      	sub	sp, #432	@ 0x1b0
3400461c:	af00      	add	r7, sp, #0
3400461e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004622:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004626:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34004628:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400462c:	2200      	movs	r2, #0
3400462e:	601a      	str	r2, [r3, #0]
34004630:	605a      	str	r2, [r3, #4]
34004632:	609a      	str	r2, [r3, #8]
34004634:	60da      	str	r2, [r3, #12]
34004636:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34004638:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400463c:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34004640:	4618      	mov	r0, r3
34004642:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34004646:	461a      	mov	r2, r3
34004648:	2100      	movs	r1, #0
3400464a:	f022 fda3 	bl	34027194 <memset>
  if(hi2c->Instance==I2C2)
3400464e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004652:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004656:	681b      	ldr	r3, [r3, #0]
34004658:	681b      	ldr	r3, [r3, #0]
3400465a:	4a20      	ldr	r2, [pc, #128]	@ (340046dc <HAL_I2C_MspInit+0xc4>)
3400465c:	4293      	cmp	r3, r2
3400465e:	d137      	bne.n	340046d0 <HAL_I2C_MspInit+0xb8>

  /* USER CODE END I2C2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
34004660:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004664:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34004668:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3400466c:	f04f 0300 	mov.w	r3, #0
34004670:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
34004674:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004678:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400467c:	4a18      	ldr	r2, [pc, #96]	@ (340046e0 <HAL_I2C_MspInit+0xc8>)
3400467e:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34004682:	f107 0308 	add.w	r3, r7, #8
34004686:	4618      	mov	r0, r3
34004688:	f00c f972 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
3400468c:	4603      	mov	r3, r0
3400468e:	2b00      	cmp	r3, #0
34004690:	d001      	beq.n	34004696 <HAL_I2C_MspInit+0x7e>
    {
      Error_Handler();
34004692:	f7ff fe77 	bl	34004384 <Error_Handler>
    }

    __HAL_RCC_GPIOD_CLK_ENABLE();
34004696:	2008      	movs	r0, #8
34004698:	f7ff fef0 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    /**I2C2 GPIO Configuration
    PD4     ------> I2C2_SDA
    PD14     ------> I2C2_SCL
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_14;
3400469c:	f244 0310 	movw	r3, #16400	@ 0x4010
340046a0:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
340046a4:	2312      	movs	r3, #18
340046a6:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340046aa:	2300      	movs	r3, #0
340046ac:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340046b0:	2303      	movs	r3, #3
340046b2:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
340046b6:	2304      	movs	r3, #4
340046b8:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
340046bc:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340046c0:	4619      	mov	r1, r3
340046c2:	4808      	ldr	r0, [pc, #32]	@ (340046e4 <HAL_I2C_MspInit+0xcc>)
340046c4:	f006 f99a 	bl	3400a9fc <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
340046c8:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
340046cc:	f7ff ff26 	bl	3400451c <LL_APB1_GRP1_EnableClock>

  /* USER CODE END I2C2_MspInit 1 */

  }

}
340046d0:	bf00      	nop
340046d2:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
340046d6:	46bd      	mov	sp, r7
340046d8:	bd80      	pop	{r7, pc}
340046da:	bf00      	nop
340046dc:	50005800 	.word	0x50005800
340046e0:	0700040c 	.word	0x0700040c
340046e4:	56020c00 	.word	0x56020c00

340046e8 <HAL_I2C_MspDeInit>:
* This function freeze the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
{
340046e8:	b580      	push	{r7, lr}
340046ea:	b082      	sub	sp, #8
340046ec:	af00      	add	r7, sp, #0
340046ee:	6078      	str	r0, [r7, #4]
  if(hi2c->Instance==I2C2)
340046f0:	687b      	ldr	r3, [r7, #4]
340046f2:	681b      	ldr	r3, [r3, #0]
340046f4:	4a09      	ldr	r2, [pc, #36]	@ (3400471c <HAL_I2C_MspDeInit+0x34>)
340046f6:	4293      	cmp	r3, r2
340046f8:	d10c      	bne.n	34004714 <HAL_I2C_MspDeInit+0x2c>
  {
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C2_CLK_DISABLE();
340046fa:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
340046fe:	f7ff ff23 	bl	34004548 <LL_APB1_GRP1_DisableClock>

    /**I2C2 GPIO Configuration
    PD4     ------> I2C2_SDA
    PD14     ------> I2C2_SCL
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_4);
34004702:	2110      	movs	r1, #16
34004704:	4806      	ldr	r0, [pc, #24]	@ (34004720 <HAL_I2C_MspDeInit+0x38>)
34004706:	f006 fb2b 	bl	3400ad60 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_14);
3400470a:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
3400470e:	4804      	ldr	r0, [pc, #16]	@ (34004720 <HAL_I2C_MspDeInit+0x38>)
34004710:	f006 fb26 	bl	3400ad60 <HAL_GPIO_DeInit>
  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }

}
34004714:	bf00      	nop
34004716:	3708      	adds	r7, #8
34004718:	46bd      	mov	sp, r7
3400471a:	bd80      	pop	{r7, pc}
3400471c:	50005800 	.word	0x50005800
34004720:	56020c00 	.word	0x56020c00

34004724 <HAL_LTDC_MspInit>:
* This function configures the hardware resources used in this example
* @param hltdc: LTDC handle pointer
* @retval None
*/
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
34004724:	b580      	push	{r7, lr}
34004726:	b0ec      	sub	sp, #432	@ 0x1b0
34004728:	af00      	add	r7, sp, #0
3400472a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400472e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004732:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34004734:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004738:	2200      	movs	r2, #0
3400473a:	601a      	str	r2, [r3, #0]
3400473c:	605a      	str	r2, [r3, #4]
3400473e:	609a      	str	r2, [r3, #8]
34004740:	60da      	str	r2, [r3, #12]
34004742:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34004744:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004748:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400474c:	4618      	mov	r0, r3
3400474e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34004752:	461a      	mov	r2, r3
34004754:	2100      	movs	r1, #0
34004756:	f022 fd1d 	bl	34027194 <memset>
  if(hltdc->Instance==LTDC)
3400475a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400475e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004762:	681b      	ldr	r3, [r3, #0]
34004764:	681b      	ldr	r3, [r3, #0]
34004766:	4a64      	ldr	r2, [pc, #400]	@ (340048f8 <HAL_LTDC_MspInit+0x1d4>)
34004768:	4293      	cmp	r3, r2
3400476a:	f040 80bf 	bne.w	340048ec <HAL_LTDC_MspInit+0x1c8>

  /* USER CODE END LTDC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
3400476e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004772:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34004776:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400477a:	f04f 0300 	mov.w	r3, #0
3400477e:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34004782:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004786:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400478a:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
3400478e:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL3;
34004792:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004796:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400479a:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
3400479e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    PeriphClkInitStruct.ICSelection[RCC_IC16].ClockDivider = 24;
340047a2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340047a6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340047aa:	2218      	movs	r2, #24
340047ac:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340047b0:	f107 0308 	add.w	r3, r7, #8
340047b4:	4618      	mov	r0, r3
340047b6:	f00c f8db 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
340047ba:	4603      	mov	r3, r0
340047bc:	2b00      	cmp	r3, #0
340047be:	d001      	beq.n	340047c4 <HAL_LTDC_MspInit+0xa0>
    {
      Error_Handler();
340047c0:	f7ff fde0 	bl	34004384 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
340047c4:	2002      	movs	r0, #2
340047c6:	f7ff fee9 	bl	3400459c <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_GPIOB_CLK_ENABLE();
340047ca:	2002      	movs	r0, #2
340047cc:	f7ff fe56 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
340047d0:	2080      	movs	r0, #128	@ 0x80
340047d2:	f7ff fe53 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOF_CLK_ENABLE();
340047d6:	2020      	movs	r0, #32
340047d8:	f7ff fe50 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
340047dc:	2001      	movs	r0, #1
340047de:	f7ff fe4d 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
340047e2:	2040      	movs	r0, #64	@ 0x40
340047e4:	f7ff fe4a 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    PG13     ------> LTDC_DE
    PA0     ------> LTDC_G3
    PB10     ------> LTDC_G7
    PB5(JTDO/TRACESWO)     ------> LTDC_R2
    */
    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_1
340047e8:	f649 4332 	movw	r3, #39986	@ 0x9c32
340047ec:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_4|GPIO_PIN_10|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340047f0:	2302      	movs	r3, #2
340047f2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340047f6:	2300      	movs	r3, #0
340047f8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340047fc:	2303      	movs	r3, #3
340047fe:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34004802:	230e      	movs	r3, #14
34004804:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
34004808:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400480c:	4619      	mov	r1, r3
3400480e:	483b      	ldr	r0, [pc, #236]	@ (340048fc <HAL_LTDC_MspInit+0x1d8>)
34004810:	f006 f8f4 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_4;
34004814:	2310      	movs	r3, #16
34004816:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400481a:	2302      	movs	r3, #2
3400481c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34004820:	2300      	movs	r3, #0
34004822:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004826:	2303      	movs	r3, #3
34004828:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3400482c:	230e      	movs	r3, #14
3400482e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
34004832:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004836:	4619      	mov	r1, r3
34004838:	4831      	ldr	r0, [pc, #196]	@ (34004900 <HAL_LTDC_MspInit+0x1dc>)
3400483a:	f006 f8df 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
3400483e:	f44f 7340 	mov.w	r3, #768	@ 0x300
34004842:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34004846:	2302      	movs	r3, #2
34004848:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400484c:	2300      	movs	r3, #0
3400484e:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004852:	2303      	movs	r3, #3
34004854:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34004858:	230e      	movs	r3, #14
3400485a:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
3400485e:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004862:	4619      	mov	r1, r3
34004864:	4827      	ldr	r0, [pc, #156]	@ (34004904 <HAL_LTDC_MspInit+0x1e0>)
34004866:	f006 f8c9 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_1|GPIO_PIN_15|GPIO_PIN_10
3400486a:	f649 73a7 	movw	r3, #40871	@ 0x9fa7
3400486e:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_5|GPIO_PIN_7|GPIO_PIN_11|GPIO_PIN_2
                          |GPIO_PIN_12|GPIO_PIN_8|GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34004872:	2302      	movs	r3, #2
34004874:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34004878:	2300      	movs	r3, #0
3400487a:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
3400487e:	2303      	movs	r3, #3
34004880:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34004884:	230e      	movs	r3, #14
34004886:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
3400488a:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400488e:	4619      	mov	r1, r3
34004890:	481d      	ldr	r0, [pc, #116]	@ (34004908 <HAL_LTDC_MspInit+0x1e4>)
34004892:	f006 f8b3 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_2
34004896:	f24b 2306 	movw	r3, #45574	@ 0xb206
3400489a:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_9|GPIO_PIN_13;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400489e:	2302      	movs	r3, #2
340048a0:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340048a4:	2300      	movs	r3, #0
340048a6:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340048aa:	2303      	movs	r3, #3
340048ac:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340048b0:	230e      	movs	r3, #14
340048b2:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
340048b6:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340048ba:	4619      	mov	r1, r3
340048bc:	4813      	ldr	r0, [pc, #76]	@ (3400490c <HAL_LTDC_MspInit+0x1e8>)
340048be:	f006 f89d 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0;
340048c2:	2301      	movs	r3, #1
340048c4:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340048c8:	2302      	movs	r3, #2
340048ca:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340048ce:	2300      	movs	r3, #0
340048d0:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
340048d4:	2303      	movs	r3, #3
340048d6:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF10_LCD;
340048da:	230a      	movs	r3, #10
340048dc:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
340048e0:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340048e4:	4619      	mov	r1, r3
340048e6:	4809      	ldr	r0, [pc, #36]	@ (3400490c <HAL_LTDC_MspInit+0x1e8>)
340048e8:	f006 f888 	bl	3400a9fc <HAL_GPIO_Init>

  /* USER CODE END LTDC_MspInit 1 */

  }

}
340048ec:	bf00      	nop
340048ee:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
340048f2:	46bd      	mov	sp, r7
340048f4:	bd80      	pop	{r7, pc}
340048f6:	bf00      	nop
340048f8:	58001000 	.word	0x58001000
340048fc:	56020400 	.word	0x56020400
34004900:	56021c00 	.word	0x56021c00
34004904:	56021400 	.word	0x56021400
34004908:	56020000 	.word	0x56020000
3400490c:	56021800 	.word	0x56021800

34004910 <HAL_RAMCFG_MspInit>:
* This function configures the hardware resources used in this example
* @param hramcfg: RAMCFG handle pointer
* @retval None
*/
void HAL_RAMCFG_MspInit(RAMCFG_HandleTypeDef* hramcfg)
{
34004910:	b580      	push	{r7, lr}
34004912:	b082      	sub	sp, #8
34004914:	af00      	add	r7, sp, #0
34004916:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN RAMCFG_MspInit 0 */
  __HAL_RCC_AXISRAM3_MEM_CLK_ENABLE();
34004918:	2001      	movs	r0, #1
3400491a:	f7ff fd83 	bl	34004424 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM4_MEM_CLK_ENABLE();
3400491e:	2002      	movs	r0, #2
34004920:	f7ff fd80 	bl	34004424 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM5_MEM_CLK_ENABLE();
34004924:	2004      	movs	r0, #4
34004926:	f7ff fd7d 	bl	34004424 <LL_MEM_EnableClock>
  __HAL_RCC_AXISRAM6_MEM_CLK_ENABLE();
3400492a:	2008      	movs	r0, #8
3400492c:	f7ff fd7a 	bl	34004424 <LL_MEM_EnableClock>

  /* USER CODE END RAMCFG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RAMCFG_CLK_ENABLE();
34004930:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34004934:	f7ff fd8c 	bl	34004450 <LL_AHB2_GRP1_EnableClock>
  /* USER CODE BEGIN RAMCFG_MspInit 1 */

  /* USER CODE END RAMCFG_MspInit 1 */

}
34004938:	bf00      	nop
3400493a:	3708      	adds	r7, #8
3400493c:	46bd      	mov	sp, r7
3400493e:	bd80      	pop	{r7, pc}

34004940 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
34004940:	b580      	push	{r7, lr}
34004942:	b0ec      	sub	sp, #432	@ 0x1b0
34004944:	af00      	add	r7, sp, #0
34004946:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400494a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400494e:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34004950:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004954:	2200      	movs	r2, #0
34004956:	601a      	str	r2, [r3, #0]
34004958:	605a      	str	r2, [r3, #4]
3400495a:	609a      	str	r2, [r3, #8]
3400495c:	60da      	str	r2, [r3, #12]
3400495e:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34004960:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004964:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34004968:	4618      	mov	r0, r3
3400496a:	f44f 73c8 	mov.w	r3, #400	@ 0x190
3400496e:	461a      	mov	r2, r3
34004970:	2100      	movs	r1, #0
34004972:	f022 fc0f 	bl	34027194 <memset>
  if(huart->Instance==USART1)
34004976:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400497a:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
3400497e:	681b      	ldr	r3, [r3, #0]
34004980:	681b      	ldr	r3, [r3, #0]
34004982:	4a1f      	ldr	r2, [pc, #124]	@ (34004a00 <HAL_UART_MspInit+0xc0>)
34004984:	4293      	cmp	r3, r2
34004986:	d135      	bne.n	340049f4 <HAL_UART_MspInit+0xb4>

  /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
34004988:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400498c:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34004990:	f04f 0200 	mov.w	r2, #0
34004994:	f44f 7380 	mov.w	r3, #256	@ 0x100
34004998:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_CLKP;
3400499c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340049a0:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340049a4:	4a17      	ldr	r2, [pc, #92]	@ (34004a04 <HAL_UART_MspInit+0xc4>)
340049a6:	f8c3 2150 	str.w	r2, [r3, #336]	@ 0x150
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340049aa:	f107 0308 	add.w	r3, r7, #8
340049ae:	4618      	mov	r0, r3
340049b0:	f00b ffde 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
340049b4:	4603      	mov	r3, r0
340049b6:	2b00      	cmp	r3, #0
340049b8:	d001      	beq.n	340049be <HAL_UART_MspInit+0x7e>
    {
      Error_Handler();
340049ba:	f7ff fce3 	bl	34004384 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
340049be:	2010      	movs	r0, #16
340049c0:	f7ff fdd6 	bl	34004570 <LL_APB2_GRP1_EnableClock>

    __HAL_RCC_GPIOE_CLK_ENABLE();
340049c4:	2010      	movs	r0, #16
340049c6:	f7ff fd59 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    /**USART1 GPIO Configuration
    PE5     ------> USART1_TX
    PE6     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
340049ca:	2360      	movs	r3, #96	@ 0x60
340049cc:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340049d0:	2302      	movs	r3, #2
340049d2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
340049d6:	2300      	movs	r3, #0
340049d8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
340049dc:	2300      	movs	r3, #0
340049de:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
340049e2:	2307      	movs	r3, #7
340049e4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
340049e8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
340049ec:	4619      	mov	r1, r3
340049ee:	4806      	ldr	r0, [pc, #24]	@ (34004a08 <HAL_UART_MspInit+0xc8>)
340049f0:	f006 f804 	bl	3400a9fc <HAL_GPIO_Init>

  /* USER CODE END USART1_MspInit 1 */

  }

}
340049f4:	bf00      	nop
340049f6:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
340049fa:	46bd      	mov	sp, r7
340049fc:	bd80      	pop	{r7, pc}
340049fe:	bf00      	nop
34004a00:	52001000 	.word	0x52001000
34004a04:	07010030 	.word	0x07010030
34004a08:	56021000 	.word	0x56021000

34004a0c <HAL_XSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hxspi: XSPI handle pointer
* @retval None
*/
void HAL_XSPI_MspInit(XSPI_HandleTypeDef* hxspi)
{
34004a0c:	b580      	push	{r7, lr}
34004a0e:	b0ec      	sub	sp, #432	@ 0x1b0
34004a10:	af00      	add	r7, sp, #0
34004a12:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004a16:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004a1a:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34004a1c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004a20:	2200      	movs	r2, #0
34004a22:	601a      	str	r2, [r3, #0]
34004a24:	605a      	str	r2, [r3, #4]
34004a26:	609a      	str	r2, [r3, #8]
34004a28:	60da      	str	r2, [r3, #12]
34004a2a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34004a2c:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004a30:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34004a34:	4618      	mov	r0, r3
34004a36:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34004a3a:	461a      	mov	r2, r3
34004a3c:	2100      	movs	r1, #0
34004a3e:	f022 fba9 	bl	34027194 <memset>
  if(hxspi->Instance==XSPI1)
34004a42:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004a46:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004a4a:	681b      	ldr	r3, [r3, #0]
34004a4c:	681b      	ldr	r3, [r3, #0]
34004a4e:	4a5a      	ldr	r2, [pc, #360]	@ (34004bb8 <HAL_XSPI_MspInit+0x1ac>)
34004a50:	4293      	cmp	r3, r2
34004a52:	d15d      	bne.n	34004b10 <HAL_XSPI_MspInit+0x104>

  /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
34004a54:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004a58:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34004a5c:	f04f 0200 	mov.w	r2, #0
34004a60:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34004a64:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_HCLK;
34004a68:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004a6c:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34004a70:	4a52      	ldr	r2, [pc, #328]	@ (34004bbc <HAL_XSPI_MspInit+0x1b0>)
34004a72:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34004a76:	f107 0308 	add.w	r3, r7, #8
34004a7a:	4618      	mov	r0, r3
34004a7c:	f00b ff78 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
34004a80:	4603      	mov	r3, r0
34004a82:	2b00      	cmp	r3, #0
34004a84:	d001      	beq.n	34004a8a <HAL_XSPI_MspInit+0x7e>
    {
      Error_Handler();
34004a86:	f7ff fc7d 	bl	34004384 <Error_Handler>
    }

    /* Peripheral clock enable */
    HAL_RCC_XSPIM_CLK_ENABLED++;
34004a8a:	4b4d      	ldr	r3, [pc, #308]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004a8c:	681b      	ldr	r3, [r3, #0]
34004a8e:	3301      	adds	r3, #1
34004a90:	4a4b      	ldr	r2, [pc, #300]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004a92:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34004a94:	4b4a      	ldr	r3, [pc, #296]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004a96:	681b      	ldr	r3, [r3, #0]
34004a98:	2b01      	cmp	r3, #1
34004a9a:	d103      	bne.n	34004aa4 <HAL_XSPI_MspInit+0x98>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34004a9c:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34004aa0:	f7ff fd02 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>
    }
    __HAL_RCC_XSPI1_CLK_ENABLE();
34004aa4:	2020      	movs	r0, #32
34004aa6:	f7ff fcff 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>

    __HAL_RCC_GPIOP_CLK_ENABLE();
34004aaa:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
34004aae:	f7ff fce5 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOO_CLK_ENABLE();
34004ab2:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
34004ab6:	f7ff fce1 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    PO5     ------> XSPIM_P1_NCLK
    PO2     ------> XSPIM_P1_DQS0
    PO0     ------> XSPIM_P1_NCS1
    PO4     ------> XSPIM_P1_CLK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6|GPIO_PIN_0|GPIO_PIN_4
34004aba:	23ff      	movs	r3, #255	@ 0xff
34004abc:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
                          |GPIO_PIN_1|GPIO_PIN_5|GPIO_PIN_3|GPIO_PIN_2;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34004ac0:	2302      	movs	r3, #2
34004ac2:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34004ac6:	2300      	movs	r3, #0
34004ac8:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004acc:	2303      	movs	r3, #3
34004ace:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34004ad2:	2309      	movs	r3, #9
34004ad4:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
34004ad8:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004adc:	4619      	mov	r1, r3
34004ade:	4839      	ldr	r0, [pc, #228]	@ (34004bc4 <HAL_XSPI_MspInit+0x1b8>)
34004ae0:	f005 ff8c 	bl	3400a9fc <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_2|GPIO_PIN_0|GPIO_PIN_4;
34004ae4:	2335      	movs	r3, #53	@ 0x35
34004ae6:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34004aea:	2302      	movs	r3, #2
34004aec:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34004af0:	2300      	movs	r3, #0
34004af2:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004af6:	2303      	movs	r3, #3
34004af8:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
34004afc:	2309      	movs	r3, #9
34004afe:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
34004b02:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004b06:	4619      	mov	r1, r3
34004b08:	482f      	ldr	r0, [pc, #188]	@ (34004bc8 <HAL_XSPI_MspInit+0x1bc>)
34004b0a:	f005 ff77 	bl	3400a9fc <HAL_GPIO_Init>
  /* USER CODE BEGIN XSPI2_MspInit 1 */

  /* USER CODE END XSPI2_MspInit 1 */
  }

}
34004b0e:	e04e      	b.n	34004bae <HAL_XSPI_MspInit+0x1a2>
  else if(hxspi->Instance==XSPI2)
34004b10:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004b14:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34004b18:	681b      	ldr	r3, [r3, #0]
34004b1a:	681b      	ldr	r3, [r3, #0]
34004b1c:	4a2b      	ldr	r2, [pc, #172]	@ (34004bcc <HAL_XSPI_MspInit+0x1c0>)
34004b1e:	4293      	cmp	r3, r2
34004b20:	d145      	bne.n	34004bae <HAL_XSPI_MspInit+0x1a2>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_XSPI2;
34004b22:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004b26:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
34004b2a:	f04f 0200 	mov.w	r2, #0
34004b2e:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
34004b32:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.Xspi2ClockSelection = RCC_XSPI2CLKSOURCE_HCLK;
34004b36:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34004b3a:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
34004b3e:	4a24      	ldr	r2, [pc, #144]	@ (34004bd0 <HAL_XSPI_MspInit+0x1c4>)
34004b40:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34004b44:	f107 0308 	add.w	r3, r7, #8
34004b48:	4618      	mov	r0, r3
34004b4a:	f00b ff11 	bl	34010970 <HAL_RCCEx_PeriphCLKConfig>
34004b4e:	4603      	mov	r3, r0
34004b50:	2b00      	cmp	r3, #0
34004b52:	d001      	beq.n	34004b58 <HAL_XSPI_MspInit+0x14c>
      Error_Handler();
34004b54:	f7ff fc16 	bl	34004384 <Error_Handler>
    HAL_RCC_XSPIM_CLK_ENABLED++;
34004b58:	4b19      	ldr	r3, [pc, #100]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004b5a:	681b      	ldr	r3, [r3, #0]
34004b5c:	3301      	adds	r3, #1
34004b5e:	4a18      	ldr	r2, [pc, #96]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004b60:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_XSPIM_CLK_ENABLED==1){
34004b62:	4b17      	ldr	r3, [pc, #92]	@ (34004bc0 <HAL_XSPI_MspInit+0x1b4>)
34004b64:	681b      	ldr	r3, [r3, #0]
34004b66:	2b01      	cmp	r3, #1
34004b68:	d103      	bne.n	34004b72 <HAL_XSPI_MspInit+0x166>
      __HAL_RCC_XSPIM_CLK_ENABLE();
34004b6a:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34004b6e:	f7ff fc9b 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_XSPI2_CLK_ENABLE();
34004b72:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34004b76:	f7ff fc97 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_GPION_CLK_ENABLE();
34004b7a:	f44f 5000 	mov.w	r0, #8192	@ 0x2000
34004b7e:	f7ff fc7d 	bl	3400447c <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_0
34004b82:	f640 737f 	movw	r3, #3967	@ 0xf7f
34004b86:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34004b8a:	2302      	movs	r3, #2
34004b8c:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34004b90:	2300      	movs	r3, #0
34004b92:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
34004b96:	2303      	movs	r3, #3
34004b98:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P2;
34004b9c:	2309      	movs	r3, #9
34004b9e:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(GPION, &GPIO_InitStruct);
34004ba2:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34004ba6:	4619      	mov	r1, r3
34004ba8:	480a      	ldr	r0, [pc, #40]	@ (34004bd4 <HAL_XSPI_MspInit+0x1c8>)
34004baa:	f005 ff27 	bl	3400a9fc <HAL_GPIO_Init>
}
34004bae:	bf00      	nop
34004bb0:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34004bb4:	46bd      	mov	sp, r7
34004bb6:	bd80      	pop	{r7, pc}
34004bb8:	58025000 	.word	0x58025000
34004bbc:	03000014 	.word	0x03000014
34004bc0:	3404a1d0 	.word	0x3404a1d0
34004bc4:	56023c00 	.word	0x56023c00
34004bc8:	56023800 	.word	0x56023800
34004bcc:	5802a000 	.word	0x5802a000
34004bd0:	03000414 	.word	0x03000414
34004bd4:	56023400 	.word	0x56023400

34004bd8 <HAL_CACHEAXI_MspInit>:

}

/* USER CODE BEGIN 1 */
void HAL_CACHEAXI_MspInit(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34004bd8:	b580      	push	{r7, lr}
34004bda:	b082      	sub	sp, #8
34004bdc:	af00      	add	r7, sp, #0
34004bde:	6078      	str	r0, [r7, #4]
  if (hcacheaxi->Instance == CACHEAXI)
34004be0:	687b      	ldr	r3, [r7, #4]
34004be2:	681b      	ldr	r3, [r3, #0]
34004be4:	4a0b      	ldr	r2, [pc, #44]	@ (34004c14 <HAL_CACHEAXI_MspInit+0x3c>)
34004be6:	4293      	cmp	r3, r2
34004be8:	d10f      	bne.n	34004c0a <HAL_CACHEAXI_MspInit+0x32>
  {
    __HAL_RCC_CACHEAXIRAM_MEM_CLK_ENABLE();
34004bea:	f44f 6080 	mov.w	r0, #1024	@ 0x400
34004bee:	f7ff fc19 	bl	34004424 <LL_MEM_EnableClock>
    __HAL_RCC_CACHEAXI_CLK_ENABLE();
34004bf2:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34004bf6:	f7ff fc57 	bl	340044a8 <LL_AHB5_GRP1_EnableClock>
    __HAL_RCC_CACHEAXI_FORCE_RESET();
34004bfa:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34004bfe:	f7ff fc69 	bl	340044d4 <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_CACHEAXI_RELEASE_RESET();
34004c02:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
34004c06:	f7ff fc75 	bl	340044f4 <LL_AHB5_GRP1_ReleaseReset>
  }
}
34004c0a:	bf00      	nop
34004c0c:	3708      	adds	r7, #8
34004c0e:	46bd      	mov	sp, r7
34004c10:	bd80      	pop	{r7, pc}
34004c12:	bf00      	nop
34004c14:	580dfc00 	.word	0x580dfc00

34004c18 <HAL_InitTick>:

#include "stm32n6xx_hal.h"
#include "tx_api.h"

HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34004c18:	b480      	push	{r7}
34004c1a:	b083      	sub	sp, #12
34004c1c:	af00      	add	r7, sp, #0
34004c1e:	6078      	str	r0, [r7, #4]
    UNUSED(TickPriority);

    return 0;
34004c20:	2300      	movs	r3, #0
}
34004c22:	4618      	mov	r0, r3
34004c24:	370c      	adds	r7, #12
34004c26:	46bd      	mov	sp, r7
34004c28:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c2c:	4770      	bx	lr

34004c2e <HAL_GetTick>:

uint32_t HAL_GetTick(void)
{
34004c2e:	b580      	push	{r7, lr}
34004c30:	af00      	add	r7, sp, #0
    return tx_time_get();
34004c32:	f01e f9bd 	bl	34022fb0 <_tx_time_get>
34004c36:	4603      	mov	r3, r0
}
34004c38:	4618      	mov	r0, r3
34004c3a:	bd80      	pop	{r7, pc}

34004c3c <HAL_Delay>:

void HAL_Delay(uint32_t Delay)
{
34004c3c:	b580      	push	{r7, lr}
34004c3e:	b082      	sub	sp, #8
34004c40:	af00      	add	r7, sp, #0
34004c42:	6078      	str	r0, [r7, #4]
    tx_thread_sleep(Delay);
34004c44:	6878      	ldr	r0, [r7, #4]
34004c46:	f01d fdc7 	bl	340227d8 <_tx_thread_sleep>
}
34004c4a:	bf00      	nop
34004c4c:	3708      	adds	r7, #8
34004c4e:	46bd      	mov	sp, r7
34004c50:	bd80      	pop	{r7, pc}

34004c52 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34004c52:	b480      	push	{r7}
34004c54:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
34004c56:	bf00      	nop
34004c58:	e7fd      	b.n	34004c56 <NMI_Handler+0x4>

34004c5a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
34004c5a:	b480      	push	{r7}
34004c5c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
34004c5e:	bf00      	nop
34004c60:	e7fd      	b.n	34004c5e <HardFault_Handler+0x4>

34004c62 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
34004c62:	b480      	push	{r7}
34004c64:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
34004c66:	bf00      	nop
34004c68:	e7fd      	b.n	34004c66 <MemManage_Handler+0x4>

34004c6a <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
34004c6a:	b480      	push	{r7}
34004c6c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
34004c6e:	bf00      	nop
34004c70:	e7fd      	b.n	34004c6e <BusFault_Handler+0x4>

34004c72 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
34004c72:	b480      	push	{r7}
34004c74:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
34004c76:	bf00      	nop
34004c78:	e7fd      	b.n	34004c76 <UsageFault_Handler+0x4>

34004c7a <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
34004c7a:	b480      	push	{r7}
34004c7c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
34004c7e:	bf00      	nop
34004c80:	e7fd      	b.n	34004c7e <SecureFault_Handler+0x4>

34004c82 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
34004c82:	b480      	push	{r7}
34004c84:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
34004c86:	bf00      	nop
34004c88:	46bd      	mov	sp, r7
34004c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c8e:	4770      	bx	lr

34004c90 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
34004c90:	b480      	push	{r7}
34004c92:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
34004c94:	bf00      	nop
34004c96:	46bd      	mov	sp, r7
34004c98:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c9c:	4770      	bx	lr

34004c9e <DCMIPP_IRQHandler>:

/**
  * @brief This function handles DCMIPP global interrupt.
  */
void DCMIPP_IRQHandler(void)
{
34004c9e:	b580      	push	{r7, lr}
34004ca0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DCMIPP_IRQn 0 */
  HAL_DCMIPP_IRQHandler(CMW_CAMERA_GetDCMIPPHandle());
34004ca2:	f016 fe1b 	bl	3401b8dc <CMW_CAMERA_GetDCMIPPHandle>
34004ca6:	4603      	mov	r3, r0
34004ca8:	4618      	mov	r0, r3
34004caa:	f002 fd8f 	bl	340077cc <HAL_DCMIPP_IRQHandler>

  /* USER CODE END DCMIPP_IRQn 0 */
  /* USER CODE BEGIN DCMIPP_IRQn 1 */

  /* USER CODE END DCMIPP_IRQn 1 */
}
34004cae:	bf00      	nop
34004cb0:	bd80      	pop	{r7, pc}

34004cb2 <CSI_IRQHandler>:

/* USER CODE BEGIN 1 */
void CSI_IRQHandler(void)
{
34004cb2:	b580      	push	{r7, lr}
34004cb4:	af00      	add	r7, sp, #0
  HAL_DCMIPP_CSI_IRQHandler(CMW_CAMERA_GetDCMIPPHandle());
34004cb6:	f016 fe11 	bl	3401b8dc <CMW_CAMERA_GetDCMIPPHandle>
34004cba:	4603      	mov	r3, r0
34004cbc:	4618      	mov	r0, r3
34004cbe:	f002 ff69 	bl	34007b94 <HAL_DCMIPP_CSI_IRQHandler>
}
34004cc2:	bf00      	nop
34004cc4:	bd80      	pop	{r7, pc}

34004cc6 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
34004cc6:	b480      	push	{r7}
34004cc8:	af00      	add	r7, sp, #0
  return 1;
34004cca:	2301      	movs	r3, #1
}
34004ccc:	4618      	mov	r0, r3
34004cce:	46bd      	mov	sp, r7
34004cd0:	f85d 7b04 	ldr.w	r7, [sp], #4
34004cd4:	4770      	bx	lr

34004cd6 <_kill>:

int _kill(int pid, int sig)
{
34004cd6:	b580      	push	{r7, lr}
34004cd8:	b082      	sub	sp, #8
34004cda:	af00      	add	r7, sp, #0
34004cdc:	6078      	str	r0, [r7, #4]
34004cde:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
34004ce0:	f022 fcac 	bl	3402763c <__errno>
34004ce4:	4603      	mov	r3, r0
34004ce6:	2216      	movs	r2, #22
34004ce8:	601a      	str	r2, [r3, #0]
  return -1;
34004cea:	f04f 33ff 	mov.w	r3, #4294967295
}
34004cee:	4618      	mov	r0, r3
34004cf0:	3708      	adds	r7, #8
34004cf2:	46bd      	mov	sp, r7
34004cf4:	bd80      	pop	{r7, pc}

34004cf6 <_exit>:

void _exit (int status)
{
34004cf6:	b580      	push	{r7, lr}
34004cf8:	b082      	sub	sp, #8
34004cfa:	af00      	add	r7, sp, #0
34004cfc:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
34004cfe:	f04f 31ff 	mov.w	r1, #4294967295
34004d02:	6878      	ldr	r0, [r7, #4]
34004d04:	f7ff ffe7 	bl	34004cd6 <_kill>
  while (1) {}    /* Make sure we hang here */
34004d08:	bf00      	nop
34004d0a:	e7fd      	b.n	34004d08 <_exit+0x12>

34004d0c <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
34004d0c:	b580      	push	{r7, lr}
34004d0e:	b086      	sub	sp, #24
34004d10:	af00      	add	r7, sp, #0
34004d12:	60f8      	str	r0, [r7, #12]
34004d14:	60b9      	str	r1, [r7, #8]
34004d16:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34004d18:	2300      	movs	r3, #0
34004d1a:	617b      	str	r3, [r7, #20]
34004d1c:	e00a      	b.n	34004d34 <_read+0x28>
  {
    *ptr++ = __io_getchar();
34004d1e:	f3af 8000 	nop.w
34004d22:	4601      	mov	r1, r0
34004d24:	68bb      	ldr	r3, [r7, #8]
34004d26:	1c5a      	adds	r2, r3, #1
34004d28:	60ba      	str	r2, [r7, #8]
34004d2a:	b2ca      	uxtb	r2, r1
34004d2c:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34004d2e:	697b      	ldr	r3, [r7, #20]
34004d30:	3301      	adds	r3, #1
34004d32:	617b      	str	r3, [r7, #20]
34004d34:	697a      	ldr	r2, [r7, #20]
34004d36:	687b      	ldr	r3, [r7, #4]
34004d38:	429a      	cmp	r2, r3
34004d3a:	dbf0      	blt.n	34004d1e <_read+0x12>
  }

  return len;
34004d3c:	687b      	ldr	r3, [r7, #4]
}
34004d3e:	4618      	mov	r0, r3
34004d40:	3718      	adds	r7, #24
34004d42:	46bd      	mov	sp, r7
34004d44:	bd80      	pop	{r7, pc}

34004d46 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
34004d46:	b580      	push	{r7, lr}
34004d48:	b086      	sub	sp, #24
34004d4a:	af00      	add	r7, sp, #0
34004d4c:	60f8      	str	r0, [r7, #12]
34004d4e:	60b9      	str	r1, [r7, #8]
34004d50:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
34004d52:	2300      	movs	r3, #0
34004d54:	617b      	str	r3, [r7, #20]
34004d56:	e009      	b.n	34004d6c <_write+0x26>
  {
    __io_putchar(*ptr++);
34004d58:	68bb      	ldr	r3, [r7, #8]
34004d5a:	1c5a      	adds	r2, r3, #1
34004d5c:	60ba      	str	r2, [r7, #8]
34004d5e:	781b      	ldrb	r3, [r3, #0]
34004d60:	4618      	mov	r0, r3
34004d62:	f001 fdff 	bl	34006964 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
34004d66:	697b      	ldr	r3, [r7, #20]
34004d68:	3301      	adds	r3, #1
34004d6a:	617b      	str	r3, [r7, #20]
34004d6c:	697a      	ldr	r2, [r7, #20]
34004d6e:	687b      	ldr	r3, [r7, #4]
34004d70:	429a      	cmp	r2, r3
34004d72:	dbf1      	blt.n	34004d58 <_write+0x12>
  }
  return len;
34004d74:	687b      	ldr	r3, [r7, #4]
}
34004d76:	4618      	mov	r0, r3
34004d78:	3718      	adds	r7, #24
34004d7a:	46bd      	mov	sp, r7
34004d7c:	bd80      	pop	{r7, pc}

34004d7e <_close>:

int _close(int file)
{
34004d7e:	b480      	push	{r7}
34004d80:	b083      	sub	sp, #12
34004d82:	af00      	add	r7, sp, #0
34004d84:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
34004d86:	f04f 33ff 	mov.w	r3, #4294967295
}
34004d8a:	4618      	mov	r0, r3
34004d8c:	370c      	adds	r7, #12
34004d8e:	46bd      	mov	sp, r7
34004d90:	f85d 7b04 	ldr.w	r7, [sp], #4
34004d94:	4770      	bx	lr

34004d96 <_fstat>:


int _fstat(int file, struct stat *st)
{
34004d96:	b480      	push	{r7}
34004d98:	b083      	sub	sp, #12
34004d9a:	af00      	add	r7, sp, #0
34004d9c:	6078      	str	r0, [r7, #4]
34004d9e:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
34004da0:	683b      	ldr	r3, [r7, #0]
34004da2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34004da6:	605a      	str	r2, [r3, #4]
  return 0;
34004da8:	2300      	movs	r3, #0
}
34004daa:	4618      	mov	r0, r3
34004dac:	370c      	adds	r7, #12
34004dae:	46bd      	mov	sp, r7
34004db0:	f85d 7b04 	ldr.w	r7, [sp], #4
34004db4:	4770      	bx	lr

34004db6 <_isatty>:

int _isatty(int file)
{
34004db6:	b480      	push	{r7}
34004db8:	b083      	sub	sp, #12
34004dba:	af00      	add	r7, sp, #0
34004dbc:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
34004dbe:	2301      	movs	r3, #1
}
34004dc0:	4618      	mov	r0, r3
34004dc2:	370c      	adds	r7, #12
34004dc4:	46bd      	mov	sp, r7
34004dc6:	f85d 7b04 	ldr.w	r7, [sp], #4
34004dca:	4770      	bx	lr

34004dcc <_lseek>:

int _lseek(int file, int ptr, int dir)
{
34004dcc:	b480      	push	{r7}
34004dce:	b085      	sub	sp, #20
34004dd0:	af00      	add	r7, sp, #0
34004dd2:	60f8      	str	r0, [r7, #12]
34004dd4:	60b9      	str	r1, [r7, #8]
34004dd6:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
34004dd8:	2300      	movs	r3, #0
}
34004dda:	4618      	mov	r0, r3
34004ddc:	3714      	adds	r7, #20
34004dde:	46bd      	mov	sp, r7
34004de0:	f85d 7b04 	ldr.w	r7, [sp], #4
34004de4:	4770      	bx	lr
	...

34004de8 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
34004de8:	b580      	push	{r7, lr}
34004dea:	b086      	sub	sp, #24
34004dec:	af00      	add	r7, sp, #0
34004dee:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
34004df0:	4a14      	ldr	r2, [pc, #80]	@ (34004e44 <_sbrk+0x5c>)
34004df2:	4b15      	ldr	r3, [pc, #84]	@ (34004e48 <_sbrk+0x60>)
34004df4:	1ad3      	subs	r3, r2, r3
34004df6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
34004df8:	697b      	ldr	r3, [r7, #20]
34004dfa:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
34004dfc:	4b13      	ldr	r3, [pc, #76]	@ (34004e4c <_sbrk+0x64>)
34004dfe:	681b      	ldr	r3, [r3, #0]
34004e00:	2b00      	cmp	r3, #0
34004e02:	d102      	bne.n	34004e0a <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
34004e04:	4b11      	ldr	r3, [pc, #68]	@ (34004e4c <_sbrk+0x64>)
34004e06:	4a12      	ldr	r2, [pc, #72]	@ (34004e50 <_sbrk+0x68>)
34004e08:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
34004e0a:	4b10      	ldr	r3, [pc, #64]	@ (34004e4c <_sbrk+0x64>)
34004e0c:	681a      	ldr	r2, [r3, #0]
34004e0e:	687b      	ldr	r3, [r7, #4]
34004e10:	4413      	add	r3, r2
34004e12:	693a      	ldr	r2, [r7, #16]
34004e14:	429a      	cmp	r2, r3
34004e16:	d207      	bcs.n	34004e28 <_sbrk+0x40>
  {
    errno = ENOMEM;
34004e18:	f022 fc10 	bl	3402763c <__errno>
34004e1c:	4603      	mov	r3, r0
34004e1e:	220c      	movs	r2, #12
34004e20:	601a      	str	r2, [r3, #0]
    return (void *)-1;
34004e22:	f04f 33ff 	mov.w	r3, #4294967295
34004e26:	e009      	b.n	34004e3c <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
34004e28:	4b08      	ldr	r3, [pc, #32]	@ (34004e4c <_sbrk+0x64>)
34004e2a:	681b      	ldr	r3, [r3, #0]
34004e2c:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
34004e2e:	4b07      	ldr	r3, [pc, #28]	@ (34004e4c <_sbrk+0x64>)
34004e30:	681a      	ldr	r2, [r3, #0]
34004e32:	687b      	ldr	r3, [r7, #4]
34004e34:	4413      	add	r3, r2
34004e36:	4a05      	ldr	r2, [pc, #20]	@ (34004e4c <_sbrk+0x64>)
34004e38:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
34004e3a:	68fb      	ldr	r3, [r7, #12]
}
34004e3c:	4618      	mov	r0, r3
34004e3e:	3718      	adds	r7, #24
34004e40:	46bd      	mov	sp, r7
34004e42:	bd80      	pop	{r7, pc}
34004e44:	34200000 	.word	0x34200000
34004e48:	00000800 	.word	0x00000800
34004e4c:	3404a1d4 	.word	0x3404a1d4
34004e50:	340567f8 	.word	0x340567f8

34004e54 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34004e54:	480f      	ldr	r0, [pc, #60]	@ (34004e94 <LoopForever+0x4>)
  msr   MSPLIM, r0
34004e56:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34004e5a:	480f      	ldr	r0, [pc, #60]	@ (34004e98 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34004e5c:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34004e5e:	f001 fdcd 	bl	340069fc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34004e62:	480e      	ldr	r0, [pc, #56]	@ (34004e9c <LoopForever+0xc>)
  ldr r1, =_edata
34004e64:	490e      	ldr	r1, [pc, #56]	@ (34004ea0 <LoopForever+0x10>)
  ldr r2, =_sidata
34004e66:	4a0f      	ldr	r2, [pc, #60]	@ (34004ea4 <LoopForever+0x14>)
  movs r3, #0
34004e68:	2300      	movs	r3, #0
  b LoopCopyDataInit
34004e6a:	e002      	b.n	34004e72 <LoopCopyDataInit>

34004e6c <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34004e6c:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34004e6e:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34004e70:	3304      	adds	r3, #4

34004e72 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34004e72:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34004e74:	428c      	cmp	r4, r1
  bcc CopyDataInit
34004e76:	d3f9      	bcc.n	34004e6c <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34004e78:	4a0b      	ldr	r2, [pc, #44]	@ (34004ea8 <LoopForever+0x18>)
  ldr r4, =_ebss
34004e7a:	4c0c      	ldr	r4, [pc, #48]	@ (34004eac <LoopForever+0x1c>)
  movs r3, #0
34004e7c:	2300      	movs	r3, #0
  b LoopFillZerobss
34004e7e:	e001      	b.n	34004e84 <LoopFillZerobss>

34004e80 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34004e80:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34004e82:	3204      	adds	r2, #4

34004e84 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34004e84:	42a2      	cmp	r2, r4
  bcc FillZerobss
34004e86:	d3fb      	bcc.n	34004e80 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34004e88:	f022 fbde 	bl	34027648 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34004e8c:	f7fe fbf0 	bl	34003670 <main>

34004e90 <LoopForever>:

LoopForever:
  b LoopForever
34004e90:	e7fe      	b.n	34004e90 <LoopForever>
34004e92:	0000      	.short	0x0000
  ldr   r0, =_sstack
34004e94:	341ff800 	.word	0x341ff800
  ldr   r0, =_estack
34004e98:	34200000 	.word	0x34200000
  ldr r0, =_sdata
34004e9c:	34041384 	.word	0x34041384
  ldr r1, =_edata
34004ea0:	34041660 	.word	0x34041660
  ldr r2, =_sidata
34004ea4:	34041384 	.word	0x34041384
  ldr r2, =_sbss
34004ea8:	34041680 	.word	0x34041680
  ldr r4, =_ebss
34004eac:	340567f8 	.word	0x340567f8

34004eb0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34004eb0:	e7fe      	b.n	34004eb0 <ADC1_2_IRQHandler>
	...

34004eb4 <bsp_i2c2_init>:
extern I2C_HandleTypeDef hi2c2;

static uint8_t bsp_i2c2_init_counter = 0;

int32_t bsp_i2c2_init(void)
{
34004eb4:	b580      	push	{r7, lr}
34004eb6:	af00      	add	r7, sp, #0
    if (bsp_i2c2_init_counter == 0)
34004eb8:	4b07      	ldr	r3, [pc, #28]	@ (34004ed8 <bsp_i2c2_init+0x24>)
34004eba:	781b      	ldrb	r3, [r3, #0]
34004ebc:	2b00      	cmp	r3, #0
34004ebe:	d107      	bne.n	34004ed0 <bsp_i2c2_init+0x1c>
    {
        bsp_i2c2_init_counter++;
34004ec0:	4b05      	ldr	r3, [pc, #20]	@ (34004ed8 <bsp_i2c2_init+0x24>)
34004ec2:	781b      	ldrb	r3, [r3, #0]
34004ec4:	3301      	adds	r3, #1
34004ec6:	b2da      	uxtb	r2, r3
34004ec8:	4b03      	ldr	r3, [pc, #12]	@ (34004ed8 <bsp_i2c2_init+0x24>)
34004eca:	701a      	strb	r2, [r3, #0]

        MX_I2C2_Init();
34004ecc:	f7fe fc70 	bl	340037b0 <MX_I2C2_Init>
    }

    return 0;
34004ed0:	2300      	movs	r3, #0
}
34004ed2:	4618      	mov	r0, r3
34004ed4:	bd80      	pop	{r7, pc}
34004ed6:	bf00      	nop
34004ed8:	3404a1d8 	.word	0x3404a1d8

34004edc <bsp_i2c2_deinit>:

int32_t bsp_i2c2_deinit(void)
{
34004edc:	b580      	push	{r7, lr}
34004ede:	af00      	add	r7, sp, #0
    if (bsp_i2c2_init_counter == 0)
34004ee0:	4b0a      	ldr	r3, [pc, #40]	@ (34004f0c <bsp_i2c2_deinit+0x30>)
34004ee2:	781b      	ldrb	r3, [r3, #0]
34004ee4:	2b00      	cmp	r3, #0
34004ee6:	d101      	bne.n	34004eec <bsp_i2c2_deinit+0x10>
    {
        return 0;
34004ee8:	2300      	movs	r3, #0
34004eea:	e00d      	b.n	34004f08 <bsp_i2c2_deinit+0x2c>
    }

    bsp_i2c2_init_counter--;
34004eec:	4b07      	ldr	r3, [pc, #28]	@ (34004f0c <bsp_i2c2_deinit+0x30>)
34004eee:	781b      	ldrb	r3, [r3, #0]
34004ef0:	3b01      	subs	r3, #1
34004ef2:	b2da      	uxtb	r2, r3
34004ef4:	4b05      	ldr	r3, [pc, #20]	@ (34004f0c <bsp_i2c2_deinit+0x30>)
34004ef6:	701a      	strb	r2, [r3, #0]
    if (bsp_i2c2_init_counter == 0)
34004ef8:	4b04      	ldr	r3, [pc, #16]	@ (34004f0c <bsp_i2c2_deinit+0x30>)
34004efa:	781b      	ldrb	r3, [r3, #0]
34004efc:	2b00      	cmp	r3, #0
34004efe:	d102      	bne.n	34004f06 <bsp_i2c2_deinit+0x2a>
    {
        HAL_I2C_DeInit(&hi2c2);
34004f00:	4803      	ldr	r0, [pc, #12]	@ (34004f10 <bsp_i2c2_deinit+0x34>)
34004f02:	f006 f967 	bl	3400b1d4 <HAL_I2C_DeInit>
    }

    return 0;
34004f06:	2300      	movs	r3, #0
}
34004f08:	4618      	mov	r0, r3
34004f0a:	bd80      	pop	{r7, pc}
34004f0c:	3404a1d8 	.word	0x3404a1d8
34004f10:	34048e4c 	.word	0x34048e4c

34004f14 <bsp_i2c2_write_reg16>:

int32_t bsp_i2c2_write_reg16(uint16_t address, uint16_t reg, uint8_t *data, uint16_t length)
{
34004f14:	b580      	push	{r7, lr}
34004f16:	b088      	sub	sp, #32
34004f18:	af04      	add	r7, sp, #16
34004f1a:	60ba      	str	r2, [r7, #8]
34004f1c:	461a      	mov	r2, r3
34004f1e:	4603      	mov	r3, r0
34004f20:	81fb      	strh	r3, [r7, #14]
34004f22:	460b      	mov	r3, r1
34004f24:	81bb      	strh	r3, [r7, #12]
34004f26:	4613      	mov	r3, r2
34004f28:	80fb      	strh	r3, [r7, #6]
    if (HAL_I2C_Mem_Write(&hi2c2, address, reg, I2C_MEMADD_SIZE_16BIT, data, length, 1000) != HAL_OK)
34004f2a:	89ba      	ldrh	r2, [r7, #12]
34004f2c:	89f9      	ldrh	r1, [r7, #14]
34004f2e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34004f32:	9302      	str	r3, [sp, #8]
34004f34:	88fb      	ldrh	r3, [r7, #6]
34004f36:	9301      	str	r3, [sp, #4]
34004f38:	68bb      	ldr	r3, [r7, #8]
34004f3a:	9300      	str	r3, [sp, #0]
34004f3c:	2302      	movs	r3, #2
34004f3e:	4807      	ldr	r0, [pc, #28]	@ (34004f5c <bsp_i2c2_write_reg16+0x48>)
34004f40:	f006 f978 	bl	3400b234 <HAL_I2C_Mem_Write>
34004f44:	4603      	mov	r3, r0
34004f46:	2b00      	cmp	r3, #0
34004f48:	d002      	beq.n	34004f50 <bsp_i2c2_write_reg16+0x3c>
    {
        return -1;
34004f4a:	f04f 33ff 	mov.w	r3, #4294967295
34004f4e:	e000      	b.n	34004f52 <bsp_i2c2_write_reg16+0x3e>
    }

    return 0;
34004f50:	2300      	movs	r3, #0
}
34004f52:	4618      	mov	r0, r3
34004f54:	3710      	adds	r7, #16
34004f56:	46bd      	mov	sp, r7
34004f58:	bd80      	pop	{r7, pc}
34004f5a:	bf00      	nop
34004f5c:	34048e4c 	.word	0x34048e4c

34004f60 <bsp_i2c2_read_reg16>:

int32_t bsp_i2c2_read_reg16(uint16_t address, uint16_t reg, uint8_t *data, uint16_t length)
{
34004f60:	b580      	push	{r7, lr}
34004f62:	b088      	sub	sp, #32
34004f64:	af04      	add	r7, sp, #16
34004f66:	60ba      	str	r2, [r7, #8]
34004f68:	461a      	mov	r2, r3
34004f6a:	4603      	mov	r3, r0
34004f6c:	81fb      	strh	r3, [r7, #14]
34004f6e:	460b      	mov	r3, r1
34004f70:	81bb      	strh	r3, [r7, #12]
34004f72:	4613      	mov	r3, r2
34004f74:	80fb      	strh	r3, [r7, #6]
    if (HAL_I2C_Mem_Read(&hi2c2, address, reg, I2C_MEMADD_SIZE_16BIT, data, length, 1000) != HAL_OK)
34004f76:	89ba      	ldrh	r2, [r7, #12]
34004f78:	89f9      	ldrh	r1, [r7, #14]
34004f7a:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34004f7e:	9302      	str	r3, [sp, #8]
34004f80:	88fb      	ldrh	r3, [r7, #6]
34004f82:	9301      	str	r3, [sp, #4]
34004f84:	68bb      	ldr	r3, [r7, #8]
34004f86:	9300      	str	r3, [sp, #0]
34004f88:	2302      	movs	r3, #2
34004f8a:	4807      	ldr	r0, [pc, #28]	@ (34004fa8 <bsp_i2c2_read_reg16+0x48>)
34004f8c:	f006 fa66 	bl	3400b45c <HAL_I2C_Mem_Read>
34004f90:	4603      	mov	r3, r0
34004f92:	2b00      	cmp	r3, #0
34004f94:	d002      	beq.n	34004f9c <bsp_i2c2_read_reg16+0x3c>
    {
        return -1;
34004f96:	f04f 33ff 	mov.w	r3, #4294967295
34004f9a:	e000      	b.n	34004f9e <bsp_i2c2_read_reg16+0x3e>
    }

    return 0;
34004f9c:	2300      	movs	r3, #0
}
34004f9e:	4618      	mov	r0, r3
34004fa0:	3710      	adds	r7, #16
34004fa2:	46bd      	mov	sp, r7
34004fa4:	bd80      	pop	{r7, pc}
34004fa6:	bf00      	nop
34004fa8:	34048e4c 	.word	0x34048e4c

34004fac <bsp_bus_get_tick>:

int32_t bsp_bus_get_tick(void)
{
34004fac:	b580      	push	{r7, lr}
34004fae:	af00      	add	r7, sp, #0
    return (int32_t)HAL_GetTick();
34004fb0:	f7ff fe3d 	bl	34004c2e <HAL_GetTick>
34004fb4:	4603      	mov	r3, r0
}
34004fb6:	4618      	mov	r0, r3
34004fb8:	bd80      	pop	{r7, pc}

34004fba <HyperRAM_Init>:
static HyperRAM_StatusTypeDef HyperRAM_GetID0(HyperRAM_ObjectTypeDef *HyperRAMObject, uint16_t *ID);
static HyperRAM_StatusTypeDef HyperRAM_GetID1(HyperRAM_ObjectTypeDef *HyperRAMObject, uint16_t *ID);
static HyperRAM_StatusTypeDef HyperRAM_EnableDifferentialClock(HyperRAM_ObjectTypeDef *HyperRAMObject);

HyperRAM_StatusTypeDef HyperRAM_Init(HyperRAM_ObjectTypeDef *HyperRAMObject, XSPI_HandleTypeDef *hxspi)
{
34004fba:	b580      	push	{r7, lr}
34004fbc:	b084      	sub	sp, #16
34004fbe:	af00      	add	r7, sp, #0
34004fc0:	6078      	str	r0, [r7, #4]
34004fc2:	6039      	str	r1, [r7, #0]
    uint16_t ID[2];

    HyperRAMObject->XSPIHandle = hxspi;
34004fc4:	687b      	ldr	r3, [r7, #4]
34004fc6:	683a      	ldr	r2, [r7, #0]
34004fc8:	601a      	str	r2, [r3, #0]
    HyperRAMObject->BaseCommand.AddressSpace = HAL_XSPI_REGISTER_ADDRESS_SPACE;
34004fca:	687b      	ldr	r3, [r7, #4]
34004fcc:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34004fd0:	605a      	str	r2, [r3, #4]
    HyperRAMObject->BaseCommand.Address = 0x00000000;
34004fd2:	687b      	ldr	r3, [r7, #4]
34004fd4:	2200      	movs	r2, #0
34004fd6:	609a      	str	r2, [r3, #8]
    HyperRAMObject->BaseCommand.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34004fd8:	687b      	ldr	r3, [r7, #4]
34004fda:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
34004fde:	60da      	str	r2, [r3, #12]
    HyperRAMObject->BaseCommand.DataLength = 2;
34004fe0:	687b      	ldr	r3, [r7, #4]
34004fe2:	2202      	movs	r2, #2
34004fe4:	611a      	str	r2, [r3, #16]
    HyperRAMObject->BaseCommand.DQSMode = HAL_XSPI_DQS_ENABLE;
34004fe6:	687b      	ldr	r3, [r7, #4]
34004fe8:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
34004fec:	615a      	str	r2, [r3, #20]
    HyperRAMObject->BaseCommand.DataMode = HAL_XSPI_DATA_8_LINES;
34004fee:	687b      	ldr	r3, [r7, #4]
34004ff0:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34004ff4:	619a      	str	r2, [r3, #24]

    HyperRAM_GetID0(HyperRAMObject, &ID[0]);
34004ff6:	f107 030c 	add.w	r3, r7, #12
34004ffa:	4619      	mov	r1, r3
34004ffc:	6878      	ldr	r0, [r7, #4]
34004ffe:	f000 f8e0 	bl	340051c2 <HyperRAM_GetID0>
    if ((ID[0] & HYPERRAM_IDENTIFICATION_0_MANUFACTURER_MASK) != HYPERRAM_IDENTIFICATION_0_MANUFACTURER)
34005002:	89bb      	ldrh	r3, [r7, #12]
34005004:	f003 030f 	and.w	r3, r3, #15
34005008:	2b06      	cmp	r3, #6
3400500a:	d123      	bne.n	34005054 <HyperRAM_Init+0x9a>
    {
        goto Error;
    }

    HyperRAM_GetID1(HyperRAMObject, &ID[1]);
3400500c:	f107 030c 	add.w	r3, r7, #12
34005010:	3302      	adds	r3, #2
34005012:	4619      	mov	r1, r3
34005014:	6878      	ldr	r0, [r7, #4]
34005016:	f000 f8ee 	bl	340051f6 <HyperRAM_GetID1>
    if ((ID[1] & HYPERRAM_IDENTIFICATION_1_DEVICE_TYPE_MASK) != HYPERRAM_IDENTIFICATION_1_DEVICE_TYPE)
3400501a:	89fb      	ldrh	r3, [r7, #14]
3400501c:	f003 030f 	and.w	r3, r3, #15
34005020:	2b01      	cmp	r3, #1
34005022:	d119      	bne.n	34005058 <HyperRAM_Init+0x9e>
    {
        goto Error;
    }

    HyperRAMObject->Size = (uint32_t)1 << (((((ID[0] & HYPERRAM_IDENTIFICATION_0_COL_COUNT_MASK) >> HYPERRAM_IDENTIFICATION_0_COL_COUNT_POS) + 1) + (((ID[0] & HYPERRAM_IDENTIFICATION_0_ROW_COUNT_MASK) >> HYPERRAM_IDENTIFICATION_0_ROW_COUNT_POS) + 1)) + 1);
34005024:	89bb      	ldrh	r3, [r7, #12]
34005026:	121b      	asrs	r3, r3, #8
34005028:	f003 030f 	and.w	r3, r3, #15
3400502c:	1c5a      	adds	r2, r3, #1
3400502e:	89bb      	ldrh	r3, [r7, #12]
34005030:	111b      	asrs	r3, r3, #4
34005032:	f003 031f 	and.w	r3, r3, #31
34005036:	3301      	adds	r3, #1
34005038:	4413      	add	r3, r2
3400503a:	3301      	adds	r3, #1
3400503c:	2201      	movs	r2, #1
3400503e:	409a      	lsls	r2, r3
34005040:	687b      	ldr	r3, [r7, #4]
34005042:	61da      	str	r2, [r3, #28]

    if (HyperRAM_EnableDifferentialClock(HyperRAMObject) != HyperRAM_OK)
34005044:	6878      	ldr	r0, [r7, #4]
34005046:	f000 f8f0 	bl	3400522a <HyperRAM_EnableDifferentialClock>
3400504a:	4603      	mov	r3, r0
3400504c:	2b00      	cmp	r3, #0
3400504e:	d105      	bne.n	3400505c <HyperRAM_Init+0xa2>
    {
        goto Error;
    }

    return HyperRAM_OK;
34005050:	2300      	movs	r3, #0
34005052:	e005      	b.n	34005060 <HyperRAM_Init+0xa6>
        goto Error;
34005054:	bf00      	nop
34005056:	e002      	b.n	3400505e <HyperRAM_Init+0xa4>
        goto Error;
34005058:	bf00      	nop
3400505a:	e000      	b.n	3400505e <HyperRAM_Init+0xa4>
        goto Error;
3400505c:	bf00      	nop

Error:
    return HyperRAM_ERROR;
3400505e:	2301      	movs	r3, #1
}
34005060:	4618      	mov	r0, r3
34005062:	3710      	adds	r7, #16
34005064:	46bd      	mov	sp, r7
34005066:	bd80      	pop	{r7, pc}

34005068 <HyperRAM_EnableMemoryMappedMode>:

HyperRAM_StatusTypeDef HyperRAM_EnableMemoryMappedMode(HyperRAM_ObjectTypeDef *HyperRAMObject)
{
34005068:	b5b0      	push	{r4, r5, r7, lr}
3400506a:	b08c      	sub	sp, #48	@ 0x30
3400506c:	af00      	add	r7, sp, #0
3400506e:	6078      	str	r0, [r7, #4]
    XSPI_HyperbusCmdTypeDef Cmd = HyperRAMObject->BaseCommand;
34005070:	687b      	ldr	r3, [r7, #4]
34005072:	f107 0418 	add.w	r4, r7, #24
34005076:	1d1d      	adds	r5, r3, #4
34005078:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400507a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400507c:	e895 0003 	ldmia.w	r5, {r0, r1}
34005080:	e884 0003 	stmia.w	r4, {r0, r1}
    XSPI_MemoryMappedTypeDef Cfg = {0};
34005084:	f107 0308 	add.w	r3, r7, #8
34005088:	2200      	movs	r2, #0
3400508a:	601a      	str	r2, [r3, #0]
3400508c:	605a      	str	r2, [r3, #4]
3400508e:	609a      	str	r2, [r3, #8]
34005090:	60da      	str	r2, [r3, #12]

    Cmd.AddressSpace = HAL_XSPI_MEMORY_ADDRESS_SPACE;
34005092:	2300      	movs	r3, #0
34005094:	61bb      	str	r3, [r7, #24]
    if (HAL_XSPI_HyperbusCmd(HyperRAMObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34005096:	687b      	ldr	r3, [r7, #4]
34005098:	681b      	ldr	r3, [r3, #0]
3400509a:	f107 0118 	add.w	r1, r7, #24
3400509e:	f241 3288 	movw	r2, #5000	@ 0x1388
340050a2:	4618      	mov	r0, r3
340050a4:	f013 f986 	bl	340183b4 <HAL_XSPI_HyperbusCmd>
340050a8:	4603      	mov	r3, r0
340050aa:	2b00      	cmp	r3, #0
340050ac:	d110      	bne.n	340050d0 <HyperRAM_EnableMemoryMappedMode+0x68>
    {
        goto Error;
    }

    Cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_ENABLE;
340050ae:	2308      	movs	r3, #8
340050b0:	60bb      	str	r3, [r7, #8]
    Cfg.TimeoutPeriodClock = 0x34;
340050b2:	2334      	movs	r3, #52	@ 0x34
340050b4:	60fb      	str	r3, [r7, #12]
    if (HAL_XSPI_MemoryMapped(HyperRAMObject->XSPIHandle, &Cfg) != HAL_OK)
340050b6:	687b      	ldr	r3, [r7, #4]
340050b8:	681b      	ldr	r3, [r3, #0]
340050ba:	f107 0208 	add.w	r2, r7, #8
340050be:	4611      	mov	r1, r2
340050c0:	4618      	mov	r0, r3
340050c2:	f013 fb85 	bl	340187d0 <HAL_XSPI_MemoryMapped>
340050c6:	4603      	mov	r3, r0
340050c8:	2b00      	cmp	r3, #0
340050ca:	d103      	bne.n	340050d4 <HyperRAM_EnableMemoryMappedMode+0x6c>
    {
        goto Error;
    }

    return HyperRAM_OK;
340050cc:	2300      	movs	r3, #0
340050ce:	e003      	b.n	340050d8 <HyperRAM_EnableMemoryMappedMode+0x70>
        goto Error;
340050d0:	bf00      	nop
340050d2:	e000      	b.n	340050d6 <HyperRAM_EnableMemoryMappedMode+0x6e>
        goto Error;
340050d4:	bf00      	nop

Error:
    return HyperRAM_ERROR;
340050d6:	2301      	movs	r3, #1
}
340050d8:	4618      	mov	r0, r3
340050da:	3730      	adds	r7, #48	@ 0x30
340050dc:	46bd      	mov	sp, r7
340050de:	bdb0      	pop	{r4, r5, r7, pc}

340050e0 <HyperRAM_ReadRegister>:
Error:
    return HyperRAM_ERROR;
}

static HyperRAM_StatusTypeDef HyperRAM_ReadRegister(HyperRAM_ObjectTypeDef *HyperRAMObject, uint32_t Address, uint16_t *Data)
{
340050e0:	b5b0      	push	{r4, r5, r7, lr}
340050e2:	b08a      	sub	sp, #40	@ 0x28
340050e4:	af00      	add	r7, sp, #0
340050e6:	60f8      	str	r0, [r7, #12]
340050e8:	60b9      	str	r1, [r7, #8]
340050ea:	607a      	str	r2, [r7, #4]
    XSPI_HyperbusCmdTypeDef Cmd = HyperRAMObject->BaseCommand;
340050ec:	68fb      	ldr	r3, [r7, #12]
340050ee:	f107 0410 	add.w	r4, r7, #16
340050f2:	1d1d      	adds	r5, r3, #4
340050f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
340050f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
340050f8:	e895 0003 	ldmia.w	r5, {r0, r1}
340050fc:	e884 0003 	stmia.w	r4, {r0, r1}

    Cmd.Address = Address;
34005100:	68bb      	ldr	r3, [r7, #8]
34005102:	617b      	str	r3, [r7, #20]
    if (HAL_XSPI_HyperbusCmd(HyperRAMObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34005104:	68fb      	ldr	r3, [r7, #12]
34005106:	681b      	ldr	r3, [r3, #0]
34005108:	f107 0110 	add.w	r1, r7, #16
3400510c:	f241 3288 	movw	r2, #5000	@ 0x1388
34005110:	4618      	mov	r0, r3
34005112:	f013 f94f 	bl	340183b4 <HAL_XSPI_HyperbusCmd>
34005116:	4603      	mov	r3, r0
34005118:	2b00      	cmp	r3, #0
3400511a:	d10c      	bne.n	34005136 <HyperRAM_ReadRegister+0x56>
    {
        goto Error;
    }

    if (HAL_XSPI_Receive(HyperRAMObject->XSPIHandle, (uint8_t *)Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400511c:	68fb      	ldr	r3, [r7, #12]
3400511e:	681b      	ldr	r3, [r3, #0]
34005120:	f241 3288 	movw	r2, #5000	@ 0x1388
34005124:	6879      	ldr	r1, [r7, #4]
34005126:	4618      	mov	r0, r3
34005128:	f013 fa25 	bl	34018576 <HAL_XSPI_Receive>
3400512c:	4603      	mov	r3, r0
3400512e:	2b00      	cmp	r3, #0
34005130:	d103      	bne.n	3400513a <HyperRAM_ReadRegister+0x5a>
    {
        goto Error;
    }

    return HyperRAM_OK;
34005132:	2300      	movs	r3, #0
34005134:	e008      	b.n	34005148 <HyperRAM_ReadRegister+0x68>
        goto Error;
34005136:	bf00      	nop
34005138:	e000      	b.n	3400513c <HyperRAM_ReadRegister+0x5c>
        goto Error;
3400513a:	bf00      	nop

Error:
    HAL_XSPI_Abort(HyperRAMObject->XSPIHandle);
3400513c:	68fb      	ldr	r3, [r7, #12]
3400513e:	681b      	ldr	r3, [r3, #0]
34005140:	4618      	mov	r0, r3
34005142:	f013 fbb1 	bl	340188a8 <HAL_XSPI_Abort>
    return HyperRAM_ERROR;
34005146:	2301      	movs	r3, #1
}
34005148:	4618      	mov	r0, r3
3400514a:	3728      	adds	r7, #40	@ 0x28
3400514c:	46bd      	mov	sp, r7
3400514e:	bdb0      	pop	{r4, r5, r7, pc}

34005150 <HyperRAM_WriteRegister>:

static HyperRAM_StatusTypeDef HyperRAM_WriteRegister(HyperRAM_ObjectTypeDef *HyperRAMObject, uint32_t Address, uint16_t Data)
{
34005150:	b5b0      	push	{r4, r5, r7, lr}
34005152:	b08a      	sub	sp, #40	@ 0x28
34005154:	af00      	add	r7, sp, #0
34005156:	60f8      	str	r0, [r7, #12]
34005158:	60b9      	str	r1, [r7, #8]
3400515a:	4613      	mov	r3, r2
3400515c:	80fb      	strh	r3, [r7, #6]
    XSPI_HyperbusCmdTypeDef Cmd = HyperRAMObject->BaseCommand;
3400515e:	68fb      	ldr	r3, [r7, #12]
34005160:	f107 0410 	add.w	r4, r7, #16
34005164:	1d1d      	adds	r5, r3, #4
34005166:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34005168:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400516a:	e895 0003 	ldmia.w	r5, {r0, r1}
3400516e:	e884 0003 	stmia.w	r4, {r0, r1}

    Cmd.Address = Address;
34005172:	68bb      	ldr	r3, [r7, #8]
34005174:	617b      	str	r3, [r7, #20]
    if (HAL_XSPI_HyperbusCmd(HyperRAMObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34005176:	68fb      	ldr	r3, [r7, #12]
34005178:	681b      	ldr	r3, [r3, #0]
3400517a:	f107 0110 	add.w	r1, r7, #16
3400517e:	f241 3288 	movw	r2, #5000	@ 0x1388
34005182:	4618      	mov	r0, r3
34005184:	f013 f916 	bl	340183b4 <HAL_XSPI_HyperbusCmd>
34005188:	4603      	mov	r3, r0
3400518a:	2b00      	cmp	r3, #0
3400518c:	d10c      	bne.n	340051a8 <HyperRAM_WriteRegister+0x58>
    {
        goto Error;
    }

    if (HAL_XSPI_Transmit(HyperRAMObject->XSPIHandle, (uint8_t *)&Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400518e:	68fb      	ldr	r3, [r7, #12]
34005190:	681b      	ldr	r3, [r3, #0]
34005192:	1db9      	adds	r1, r7, #6
34005194:	f241 3288 	movw	r2, #5000	@ 0x1388
34005198:	4618      	mov	r0, r3
3400519a:	f013 f979 	bl	34018490 <HAL_XSPI_Transmit>
3400519e:	4603      	mov	r3, r0
340051a0:	2b00      	cmp	r3, #0
340051a2:	d103      	bne.n	340051ac <HyperRAM_WriteRegister+0x5c>
    {
        goto Error;
    }

    return HyperRAM_OK;
340051a4:	2300      	movs	r3, #0
340051a6:	e008      	b.n	340051ba <HyperRAM_WriteRegister+0x6a>
        goto Error;
340051a8:	bf00      	nop
340051aa:	e000      	b.n	340051ae <HyperRAM_WriteRegister+0x5e>
        goto Error;
340051ac:	bf00      	nop

Error:
    HAL_XSPI_Abort(HyperRAMObject->XSPIHandle);
340051ae:	68fb      	ldr	r3, [r7, #12]
340051b0:	681b      	ldr	r3, [r3, #0]
340051b2:	4618      	mov	r0, r3
340051b4:	f013 fb78 	bl	340188a8 <HAL_XSPI_Abort>
    return HyperRAM_ERROR;
340051b8:	2301      	movs	r3, #1
}
340051ba:	4618      	mov	r0, r3
340051bc:	3728      	adds	r7, #40	@ 0x28
340051be:	46bd      	mov	sp, r7
340051c0:	bdb0      	pop	{r4, r5, r7, pc}

340051c2 <HyperRAM_GetID0>:

static HyperRAM_StatusTypeDef HyperRAM_GetID0(HyperRAM_ObjectTypeDef *HyperRAMObject, uint16_t *ID)
{
340051c2:	b580      	push	{r7, lr}
340051c4:	b082      	sub	sp, #8
340051c6:	af00      	add	r7, sp, #0
340051c8:	6078      	str	r0, [r7, #4]
340051ca:	6039      	str	r1, [r7, #0]
    if (HyperRAM_ReadRegister(HyperRAMObject, HYPERRAM_IDENTIFICATION_REGISTER_0, ID) != HyperRAM_OK)
340051cc:	683a      	ldr	r2, [r7, #0]
340051ce:	2100      	movs	r1, #0
340051d0:	6878      	ldr	r0, [r7, #4]
340051d2:	f7ff ff85 	bl	340050e0 <HyperRAM_ReadRegister>
340051d6:	4603      	mov	r3, r0
340051d8:	2b00      	cmp	r3, #0
340051da:	d101      	bne.n	340051e0 <HyperRAM_GetID0+0x1e>
    {
        goto Error;
    }

    return HyperRAM_OK;
340051dc:	2300      	movs	r3, #0
340051de:	e006      	b.n	340051ee <HyperRAM_GetID0+0x2c>
        goto Error;
340051e0:	bf00      	nop

Error:
    HAL_XSPI_Abort(HyperRAMObject->XSPIHandle);
340051e2:	687b      	ldr	r3, [r7, #4]
340051e4:	681b      	ldr	r3, [r3, #0]
340051e6:	4618      	mov	r0, r3
340051e8:	f013 fb5e 	bl	340188a8 <HAL_XSPI_Abort>
    return HyperRAM_ERROR;
340051ec:	2301      	movs	r3, #1
}
340051ee:	4618      	mov	r0, r3
340051f0:	3708      	adds	r7, #8
340051f2:	46bd      	mov	sp, r7
340051f4:	bd80      	pop	{r7, pc}

340051f6 <HyperRAM_GetID1>:

static HyperRAM_StatusTypeDef HyperRAM_GetID1(HyperRAM_ObjectTypeDef *HyperRAMObject, uint16_t *ID)
{
340051f6:	b580      	push	{r7, lr}
340051f8:	b082      	sub	sp, #8
340051fa:	af00      	add	r7, sp, #0
340051fc:	6078      	str	r0, [r7, #4]
340051fe:	6039      	str	r1, [r7, #0]
    if (HyperRAM_ReadRegister(HyperRAMObject, HYPERRAM_IDENTIFICATION_REGISTER_1, ID) != HyperRAM_OK)
34005200:	683a      	ldr	r2, [r7, #0]
34005202:	2102      	movs	r1, #2
34005204:	6878      	ldr	r0, [r7, #4]
34005206:	f7ff ff6b 	bl	340050e0 <HyperRAM_ReadRegister>
3400520a:	4603      	mov	r3, r0
3400520c:	2b00      	cmp	r3, #0
3400520e:	d101      	bne.n	34005214 <HyperRAM_GetID1+0x1e>
    {
        goto Error;
    }

    return HyperRAM_OK;
34005210:	2300      	movs	r3, #0
34005212:	e006      	b.n	34005222 <HyperRAM_GetID1+0x2c>
        goto Error;
34005214:	bf00      	nop

Error:
    HAL_XSPI_Abort(HyperRAMObject->XSPIHandle);
34005216:	687b      	ldr	r3, [r7, #4]
34005218:	681b      	ldr	r3, [r3, #0]
3400521a:	4618      	mov	r0, r3
3400521c:	f013 fb44 	bl	340188a8 <HAL_XSPI_Abort>
    return HyperRAM_ERROR;
34005220:	2301      	movs	r3, #1
}
34005222:	4618      	mov	r0, r3
34005224:	3708      	adds	r7, #8
34005226:	46bd      	mov	sp, r7
34005228:	bd80      	pop	{r7, pc}

3400522a <HyperRAM_EnableDifferentialClock>:

static HyperRAM_StatusTypeDef HyperRAM_EnableDifferentialClock(HyperRAM_ObjectTypeDef *HyperRAMObject)
{
3400522a:	b580      	push	{r7, lr}
3400522c:	b084      	sub	sp, #16
3400522e:	af00      	add	r7, sp, #0
34005230:	6078      	str	r0, [r7, #4]
    uint16_t Cfg;

    if (HyperRAM_ReadRegister(HyperRAMObject, HYPERRAM_CONFIGURATION_REGISTER_1, &Cfg) != HyperRAM_OK)
34005232:	f107 030e 	add.w	r3, r7, #14
34005236:	461a      	mov	r2, r3
34005238:	f241 0102 	movw	r1, #4098	@ 0x1002
3400523c:	6878      	ldr	r0, [r7, #4]
3400523e:	f7ff ff4f 	bl	340050e0 <HyperRAM_ReadRegister>
34005242:	4603      	mov	r3, r0
34005244:	2b00      	cmp	r3, #0
34005246:	d110      	bne.n	3400526a <HyperRAM_EnableDifferentialClock+0x40>
    {
        goto Error;
    }

    Cfg &= ~HYPERRAM_CONFIGURATION_1_MASTER_CLOCK_TYPE_MASK;
34005248:	89fb      	ldrh	r3, [r7, #14]
3400524a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400524e:	b29b      	uxth	r3, r3
34005250:	81fb      	strh	r3, [r7, #14]
    if (HyperRAM_WriteRegister(HyperRAMObject, HYPERRAM_CONFIGURATION_REGISTER_1, Cfg) != HyperRAM_OK)
34005252:	89fb      	ldrh	r3, [r7, #14]
34005254:	461a      	mov	r2, r3
34005256:	f241 0102 	movw	r1, #4098	@ 0x1002
3400525a:	6878      	ldr	r0, [r7, #4]
3400525c:	f7ff ff78 	bl	34005150 <HyperRAM_WriteRegister>
34005260:	4603      	mov	r3, r0
34005262:	2b00      	cmp	r3, #0
34005264:	d103      	bne.n	3400526e <HyperRAM_EnableDifferentialClock+0x44>
    {
        goto Error;
    }

    return HyperRAM_OK;
34005266:	2300      	movs	r3, #0
34005268:	e008      	b.n	3400527c <HyperRAM_EnableDifferentialClock+0x52>
        goto Error;
3400526a:	bf00      	nop
3400526c:	e000      	b.n	34005270 <HyperRAM_EnableDifferentialClock+0x46>
        goto Error;
3400526e:	bf00      	nop

Error:
    HAL_XSPI_Abort(HyperRAMObject->XSPIHandle);
34005270:	687b      	ldr	r3, [r7, #4]
34005272:	681b      	ldr	r3, [r3, #0]
34005274:	4618      	mov	r0, r3
34005276:	f013 fb17 	bl	340188a8 <HAL_XSPI_Abort>
    return HyperRAM_ERROR;
3400527a:	2301      	movs	r3, #1
}
3400527c:	4618      	mov	r0, r3
3400527e:	3710      	adds	r7, #16
34005280:	46bd      	mov	sp, r7
34005282:	bd80      	pop	{r7, pc}

34005284 <bsp_lcd_init>:
static void bsp_lcd_fill_buffer(uint32_t *destination, uint32_t x_size, uint32_t y_size, uint32_t offset, uint32_t color);

bsp_lcd_t bsp_lcd;

void bsp_lcd_init(void)
{
34005284:	b580      	push	{r7, lr}
34005286:	af00      	add	r7, sp, #0
    bsp_lcd_init_ex(LCD_PIXEL_FORMAT_RGB565, BSP_LCD_WIDTH, BSP_LCD_HEIGHT);
34005288:	f44f 72f0 	mov.w	r2, #480	@ 0x1e0
3400528c:	f44f 7148 	mov.w	r1, #800	@ 0x320
34005290:	2002      	movs	r0, #2
34005292:	f000 f803 	bl	3400529c <bsp_lcd_init_ex>
}
34005296:	bf00      	nop
34005298:	bd80      	pop	{r7, pc}
	...

3400529c <bsp_lcd_init_ex>:

void bsp_lcd_init_ex(uint32_t pixel_format, uint32_t width, uint32_t height)
{
3400529c:	b580      	push	{r7, lr}
3400529e:	b084      	sub	sp, #16
340052a0:	af00      	add	r7, sp, #0
340052a2:	60f8      	str	r0, [r7, #12]
340052a4:	60b9      	str	r1, [r7, #8]
340052a6:	607a      	str	r2, [r7, #4]
    if (pixel_format == LCD_PIXEL_FORMAT_RGB565)
340052a8:	68fb      	ldr	r3, [r7, #12]
340052aa:	2b02      	cmp	r3, #2
340052ac:	d103      	bne.n	340052b6 <bsp_lcd_init_ex+0x1a>
    {
        bsp_lcd.bpp_factor = 2;
340052ae:	4b13      	ldr	r3, [pc, #76]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052b0:	2202      	movs	r2, #2
340052b2:	611a      	str	r2, [r3, #16]
340052b4:	e010      	b.n	340052d8 <bsp_lcd_init_ex+0x3c>
    }
    else if (pixel_format == LCD_PIXEL_FORMAT_RGB888)
340052b6:	68fb      	ldr	r3, [r7, #12]
340052b8:	2b01      	cmp	r3, #1
340052ba:	d103      	bne.n	340052c4 <bsp_lcd_init_ex+0x28>
    {
        bsp_lcd.bpp_factor = 3;
340052bc:	4b0f      	ldr	r3, [pc, #60]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052be:	2203      	movs	r2, #3
340052c0:	611a      	str	r2, [r3, #16]
340052c2:	e009      	b.n	340052d8 <bsp_lcd_init_ex+0x3c>
    }
    else if (pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
340052c4:	68fb      	ldr	r3, [r7, #12]
340052c6:	2b04      	cmp	r3, #4
340052c8:	d103      	bne.n	340052d2 <bsp_lcd_init_ex+0x36>
    {
        bsp_lcd.bpp_factor = 2;
340052ca:	4b0c      	ldr	r3, [pc, #48]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052cc:	2202      	movs	r2, #2
340052ce:	611a      	str	r2, [r3, #16]
340052d0:	e002      	b.n	340052d8 <bsp_lcd_init_ex+0x3c>
    }
    else
    {
        bsp_lcd.bpp_factor = 4;
340052d2:	4b0a      	ldr	r3, [pc, #40]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052d4:	2204      	movs	r2, #4
340052d6:	611a      	str	r2, [r3, #16]
    }
    bsp_lcd.pixel_format = pixel_format;
340052d8:	4a08      	ldr	r2, [pc, #32]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052da:	68fb      	ldr	r3, [r7, #12]
340052dc:	60d3      	str	r3, [r2, #12]
    bsp_lcd.x_size = width;
340052de:	4a07      	ldr	r2, [pc, #28]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052e0:	68bb      	ldr	r3, [r7, #8]
340052e2:	6013      	str	r3, [r2, #0]
    bsp_lcd.y_size = height;
340052e4:	4a05      	ldr	r2, [pc, #20]	@ (340052fc <bsp_lcd_init_ex+0x60>)
340052e6:	687b      	ldr	r3, [r7, #4]
340052e8:	6053      	str	r3, [r2, #4]

    MX_DMA2D_Init();
340052ea:	f7fe fa43 	bl	34003774 <MX_DMA2D_Init>
    MX_LTDC_Init();
340052ee:	f7fe fa9f 	bl	34003830 <MX_LTDC_Init>
}
340052f2:	bf00      	nop
340052f4:	3710      	adds	r7, #16
340052f6:	46bd      	mov	sp, r7
340052f8:	bd80      	pop	{r7, pc}
340052fa:	bf00      	nop
340052fc:	3404a1dc 	.word	0x3404a1dc

34005300 <bsp_lcd_config_layer>:

void bsp_lcd_config_layer(uint32_t layer_index, bsp_lcd_layer_config_t *layer_config)
{
34005300:	b580      	push	{r7, lr}
34005302:	b090      	sub	sp, #64	@ 0x40
34005304:	af00      	add	r7, sp, #0
34005306:	6078      	str	r0, [r7, #4]
34005308:	6039      	str	r1, [r7, #0]
    uint32_t layer_id;
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400530a:	f107 0308 	add.w	r3, r7, #8
3400530e:	2234      	movs	r2, #52	@ 0x34
34005310:	2100      	movs	r1, #0
34005312:	4618      	mov	r0, r3
34005314:	f021 ff3e 	bl	34027194 <memset>
        .WindowX0 = layer_config->x0,
34005318:	683b      	ldr	r3, [r7, #0]
3400531a:	681b      	ldr	r3, [r3, #0]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400531c:	60bb      	str	r3, [r7, #8]
        .WindowX1 = layer_config->x1,
3400531e:	683b      	ldr	r3, [r7, #0]
34005320:	685b      	ldr	r3, [r3, #4]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34005322:	60fb      	str	r3, [r7, #12]
        .WindowY0 = layer_config->y0,
34005324:	683b      	ldr	r3, [r7, #0]
34005326:	689b      	ldr	r3, [r3, #8]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34005328:	613b      	str	r3, [r7, #16]
        .WindowY1 = layer_config->y1,
3400532a:	683b      	ldr	r3, [r7, #0]
3400532c:	68db      	ldr	r3, [r3, #12]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400532e:	617b      	str	r3, [r7, #20]
34005330:	23ff      	movs	r3, #255	@ 0xff
34005332:	61fb      	str	r3, [r7, #28]
34005334:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
34005338:	627b      	str	r3, [r7, #36]	@ 0x24
3400533a:	2307      	movs	r3, #7
3400533c:	62bb      	str	r3, [r7, #40]	@ 0x28
        .PixelFormat = 0,
        .Alpha = LTDC_LxCACR_CONSTA,
        .Alpha0 = 0,
        .BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA,
        .BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA,
        .FBStartAdress = layer_config->address,
3400533e:	683b      	ldr	r3, [r7, #0]
34005340:	695b      	ldr	r3, [r3, #20]
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
34005342:	62fb      	str	r3, [r7, #44]	@ 0x2c
        .ImageWidth = layer_config->x1 - layer_config->x0,
34005344:	683b      	ldr	r3, [r7, #0]
34005346:	685a      	ldr	r2, [r3, #4]
34005348:	683b      	ldr	r3, [r7, #0]
3400534a:	681b      	ldr	r3, [r3, #0]
3400534c:	1ad3      	subs	r3, r2, r3
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400534e:	633b      	str	r3, [r7, #48]	@ 0x30
        .ImageHeight = layer_config->y1 - layer_config->y0,
34005350:	683b      	ldr	r3, [r7, #0]
34005352:	68da      	ldr	r2, [r3, #12]
34005354:	683b      	ldr	r3, [r7, #0]
34005356:	689b      	ldr	r3, [r3, #8]
34005358:	1ad3      	subs	r3, r2, r3
    LTDC_LayerCfgTypeDef ltdc_layer_cfg = {
3400535a:	637b      	str	r3, [r7, #52]	@ 0x34
        .Backcolor.Blue = 0,
        .Backcolor.Green = 0,
        .Backcolor.Red = 0,
    };

    if (layer_config->pixel_format == LCD_PIXEL_FORMAT_RGB565)
3400535c:	683b      	ldr	r3, [r7, #0]
3400535e:	691b      	ldr	r3, [r3, #16]
34005360:	2b02      	cmp	r3, #2
34005362:	d102      	bne.n	3400536a <bsp_lcd_config_layer+0x6a>
    {
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
34005364:	2304      	movs	r3, #4
34005366:	61bb      	str	r3, [r7, #24]
34005368:	e00f      	b.n	3400538a <bsp_lcd_config_layer+0x8a>
    }
    else if (layer_config->pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
3400536a:	683b      	ldr	r3, [r7, #0]
3400536c:	691b      	ldr	r3, [r3, #16]
3400536e:	2b04      	cmp	r3, #4
34005370:	d102      	bne.n	34005378 <bsp_lcd_config_layer+0x78>
    {
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB4444;
34005372:	2308      	movs	r3, #8
34005374:	61bb      	str	r3, [r7, #24]
34005376:	e008      	b.n	3400538a <bsp_lcd_config_layer+0x8a>
    }
    else if (layer_config->pixel_format == LCD_PIXEL_FORMAT_ARGB8888)
34005378:	683b      	ldr	r3, [r7, #0]
3400537a:	691b      	ldr	r3, [r3, #16]
3400537c:	2b00      	cmp	r3, #0
3400537e:	d102      	bne.n	34005386 <bsp_lcd_config_layer+0x86>
    {
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
34005380:	2300      	movs	r3, #0
34005382:	61bb      	str	r3, [r7, #24]
34005384:	e001      	b.n	3400538a <bsp_lcd_config_layer+0x8a>
    }
    else
    {
        ltdc_layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
34005386:	2306      	movs	r3, #6
34005388:	61bb      	str	r3, [r7, #24]
    }

    if (layer_index == 1)
3400538a:	687b      	ldr	r3, [r7, #4]
3400538c:	2b01      	cmp	r3, #1
3400538e:	d102      	bne.n	34005396 <bsp_lcd_config_layer+0x96>
    {
        layer_id = LTDC_LAYER_2;
34005390:	2301      	movs	r3, #1
34005392:	63fb      	str	r3, [r7, #60]	@ 0x3c
34005394:	e001      	b.n	3400539a <bsp_lcd_config_layer+0x9a>
    }
    else
    {
        layer_id = LTDC_LAYER_1;
34005396:	2300      	movs	r3, #0
34005398:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }

    HAL_LTDC_ConfigLayer(&hltdc, &ltdc_layer_cfg, layer_id);
3400539a:	f107 0308 	add.w	r3, r7, #8
3400539e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340053a0:	4619      	mov	r1, r3
340053a2:	4803      	ldr	r0, [pc, #12]	@ (340053b0 <bsp_lcd_config_layer+0xb0>)
340053a4:	f006 fd78 	bl	3400be98 <HAL_LTDC_ConfigLayer>
}
340053a8:	bf00      	nop
340053aa:	3740      	adds	r7, #64	@ 0x40
340053ac:	46bd      	mov	sp, r7
340053ae:	bd80      	pop	{r7, pc}
340053b0:	34048ea0 	.word	0x34048ea0

340053b4 <bsp_lcd_set_brightness>:

void bsp_lcd_set_brightness(uint8_t brightness)
{
340053b4:	b580      	push	{r7, lr}
340053b6:	b082      	sub	sp, #8
340053b8:	af00      	add	r7, sp, #0
340053ba:	4603      	mov	r3, r0
340053bc:	71fb      	strb	r3, [r7, #7]
    if (brightness != 0)
340053be:	79fb      	ldrb	r3, [r7, #7]
340053c0:	2b00      	cmp	r3, #0
340053c2:	d005      	beq.n	340053d0 <bsp_lcd_set_brightness+0x1c>
    {
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_SET);
340053c4:	2201      	movs	r2, #1
340053c6:	2108      	movs	r1, #8
340053c8:	4806      	ldr	r0, [pc, #24]	@ (340053e4 <bsp_lcd_set_brightness+0x30>)
340053ca:	f005 fe09 	bl	3400afe0 <HAL_GPIO_WritePin>
    }
    else
    {
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_RESET);
    }
}
340053ce:	e004      	b.n	340053da <bsp_lcd_set_brightness+0x26>
        HAL_GPIO_WritePin(BSP_LCD_BL_GPIO, BSP_LCD_BL_PIN, GPIO_PIN_RESET);
340053d0:	2200      	movs	r2, #0
340053d2:	2108      	movs	r1, #8
340053d4:	4803      	ldr	r0, [pc, #12]	@ (340053e4 <bsp_lcd_set_brightness+0x30>)
340053d6:	f005 fe03 	bl	3400afe0 <HAL_GPIO_WritePin>
}
340053da:	bf00      	nop
340053dc:	3708      	adds	r7, #8
340053de:	46bd      	mov	sp, r7
340053e0:	bd80      	pop	{r7, pc}
340053e2:	bf00      	nop
340053e4:	56020000 	.word	0x56020000

340053e8 <bsp_lcd_get_ltdc_handle>:

LTDC_HandleTypeDef *bsp_lcd_get_ltdc_handle(void)
{
340053e8:	b480      	push	{r7}
340053ea:	af00      	add	r7, sp, #0
    return &hltdc;
340053ec:	4b02      	ldr	r3, [pc, #8]	@ (340053f8 <bsp_lcd_get_ltdc_handle+0x10>)
}
340053ee:	4618      	mov	r0, r3
340053f0:	46bd      	mov	sp, r7
340053f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340053f6:	4770      	bx	lr
340053f8:	34048ea0 	.word	0x34048ea0

340053fc <bsp_lcd_draw_bitmap>:

static int32_t bsp_lcd_draw_bitmap(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint8_t *bitmap)
{
340053fc:	b580      	push	{r7, lr}
340053fe:	b08a      	sub	sp, #40	@ 0x28
34005400:	af00      	add	r7, sp, #0
34005402:	60f8      	str	r0, [r7, #12]
34005404:	60b9      	str	r1, [r7, #8]
34005406:	607a      	str	r2, [r7, #4]
34005408:	603b      	str	r3, [r7, #0]
    uint32_t height;
    uint32_t bit_pixel;
    uint32_t address;
    uint32_t input_color_mode;

    index = (uint32_t)bitmap[10] + ((uint32_t)bitmap[11] << 8) + ((uint32_t)bitmap[12] << 16) + ((uint32_t)bitmap[13] << 24);
3400540a:	683b      	ldr	r3, [r7, #0]
3400540c:	330a      	adds	r3, #10
3400540e:	781b      	ldrb	r3, [r3, #0]
34005410:	461a      	mov	r2, r3
34005412:	683b      	ldr	r3, [r7, #0]
34005414:	330b      	adds	r3, #11
34005416:	781b      	ldrb	r3, [r3, #0]
34005418:	021b      	lsls	r3, r3, #8
3400541a:	441a      	add	r2, r3
3400541c:	683b      	ldr	r3, [r7, #0]
3400541e:	330c      	adds	r3, #12
34005420:	781b      	ldrb	r3, [r3, #0]
34005422:	041b      	lsls	r3, r3, #16
34005424:	441a      	add	r2, r3
34005426:	683b      	ldr	r3, [r7, #0]
34005428:	330d      	adds	r3, #13
3400542a:	781b      	ldrb	r3, [r3, #0]
3400542c:	061b      	lsls	r3, r3, #24
3400542e:	4413      	add	r3, r2
34005430:	627b      	str	r3, [r7, #36]	@ 0x24
    width = (uint32_t)bitmap[18] + ((uint32_t)bitmap[19] << 8) + ((uint32_t)bitmap[20] << 16) + ((uint32_t)bitmap[21] << 24);
34005432:	683b      	ldr	r3, [r7, #0]
34005434:	3312      	adds	r3, #18
34005436:	781b      	ldrb	r3, [r3, #0]
34005438:	461a      	mov	r2, r3
3400543a:	683b      	ldr	r3, [r7, #0]
3400543c:	3313      	adds	r3, #19
3400543e:	781b      	ldrb	r3, [r3, #0]
34005440:	021b      	lsls	r3, r3, #8
34005442:	441a      	add	r2, r3
34005444:	683b      	ldr	r3, [r7, #0]
34005446:	3314      	adds	r3, #20
34005448:	781b      	ldrb	r3, [r3, #0]
3400544a:	041b      	lsls	r3, r3, #16
3400544c:	441a      	add	r2, r3
3400544e:	683b      	ldr	r3, [r7, #0]
34005450:	3315      	adds	r3, #21
34005452:	781b      	ldrb	r3, [r3, #0]
34005454:	061b      	lsls	r3, r3, #24
34005456:	4413      	add	r3, r2
34005458:	61bb      	str	r3, [r7, #24]
    height = (uint32_t)bitmap[22] + ((uint32_t)bitmap[23] << 8) + ((uint32_t)bitmap[24] << 16) + ((uint32_t)bitmap[25] << 24);
3400545a:	683b      	ldr	r3, [r7, #0]
3400545c:	3316      	adds	r3, #22
3400545e:	781b      	ldrb	r3, [r3, #0]
34005460:	461a      	mov	r2, r3
34005462:	683b      	ldr	r3, [r7, #0]
34005464:	3317      	adds	r3, #23
34005466:	781b      	ldrb	r3, [r3, #0]
34005468:	021b      	lsls	r3, r3, #8
3400546a:	441a      	add	r2, r3
3400546c:	683b      	ldr	r3, [r7, #0]
3400546e:	3318      	adds	r3, #24
34005470:	781b      	ldrb	r3, [r3, #0]
34005472:	041b      	lsls	r3, r3, #16
34005474:	441a      	add	r2, r3
34005476:	683b      	ldr	r3, [r7, #0]
34005478:	3319      	adds	r3, #25
3400547a:	781b      	ldrb	r3, [r3, #0]
3400547c:	061b      	lsls	r3, r3, #24
3400547e:	4413      	add	r3, r2
34005480:	617b      	str	r3, [r7, #20]
    bit_pixel = (uint32_t)bitmap[28] + ((uint32_t)bitmap[29] << 8);
34005482:	683b      	ldr	r3, [r7, #0]
34005484:	331c      	adds	r3, #28
34005486:	781b      	ldrb	r3, [r3, #0]
34005488:	461a      	mov	r2, r3
3400548a:	683b      	ldr	r3, [r7, #0]
3400548c:	331d      	adds	r3, #29
3400548e:	781b      	ldrb	r3, [r3, #0]
34005490:	021b      	lsls	r3, r3, #8
34005492:	4413      	add	r3, r2
34005494:	613b      	str	r3, [r7, #16]
    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
34005496:	4b2d      	ldr	r3, [pc, #180]	@ (3400554c <bsp_lcd_draw_bitmap+0x150>)
34005498:	689b      	ldr	r3, [r3, #8]
3400549a:	4a2d      	ldr	r2, [pc, #180]	@ (34005550 <bsp_lcd_draw_bitmap+0x154>)
3400549c:	2134      	movs	r1, #52	@ 0x34
3400549e:	fb01 f303 	mul.w	r3, r1, r3
340054a2:	4413      	add	r3, r2
340054a4:	335c      	adds	r3, #92	@ 0x5c
340054a6:	681a      	ldr	r2, [r3, #0]
340054a8:	4b28      	ldr	r3, [pc, #160]	@ (3400554c <bsp_lcd_draw_bitmap+0x150>)
340054aa:	691b      	ldr	r3, [r3, #16]
340054ac:	4927      	ldr	r1, [pc, #156]	@ (3400554c <bsp_lcd_draw_bitmap+0x150>)
340054ae:	6809      	ldr	r1, [r1, #0]
340054b0:	6878      	ldr	r0, [r7, #4]
340054b2:	fb01 f000 	mul.w	r0, r1, r0
340054b6:	68b9      	ldr	r1, [r7, #8]
340054b8:	4401      	add	r1, r0
340054ba:	fb01 f303 	mul.w	r3, r1, r3
340054be:	4413      	add	r3, r2
340054c0:	623b      	str	r3, [r7, #32]

    if ((bit_pixel / 8) == 4)
340054c2:	693b      	ldr	r3, [r7, #16]
340054c4:	3b20      	subs	r3, #32
340054c6:	2b07      	cmp	r3, #7
340054c8:	d802      	bhi.n	340054d0 <bsp_lcd_draw_bitmap+0xd4>
    {
        input_color_mode = DMA2D_INPUT_ARGB8888;
340054ca:	2300      	movs	r3, #0
340054cc:	61fb      	str	r3, [r7, #28]
340054ce:	e008      	b.n	340054e2 <bsp_lcd_draw_bitmap+0xe6>
    }
    else if ((bit_pixel / 8) == 2)
340054d0:	693b      	ldr	r3, [r7, #16]
340054d2:	3b10      	subs	r3, #16
340054d4:	2b07      	cmp	r3, #7
340054d6:	d802      	bhi.n	340054de <bsp_lcd_draw_bitmap+0xe2>
    {
        input_color_mode = DMA2D_INPUT_RGB565;
340054d8:	2302      	movs	r3, #2
340054da:	61fb      	str	r3, [r7, #28]
340054dc:	e001      	b.n	340054e2 <bsp_lcd_draw_bitmap+0xe6>
    }
    else
    {
        input_color_mode = DMA2D_INPUT_RGB888;
340054de:	2301      	movs	r3, #1
340054e0:	61fb      	str	r3, [r7, #28]
    }

    bitmap += index + (width * (height - 1) * (bit_pixel / 8));
340054e2:	697b      	ldr	r3, [r7, #20]
340054e4:	3b01      	subs	r3, #1
340054e6:	69ba      	ldr	r2, [r7, #24]
340054e8:	fb02 f303 	mul.w	r3, r2, r3
340054ec:	693a      	ldr	r2, [r7, #16]
340054ee:	08d2      	lsrs	r2, r2, #3
340054f0:	fb03 f202 	mul.w	r2, r3, r2
340054f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340054f6:	4413      	add	r3, r2
340054f8:	683a      	ldr	r2, [r7, #0]
340054fa:	4413      	add	r3, r2
340054fc:	603b      	str	r3, [r7, #0]
    for(index=0; index < height; index++)
340054fe:	2300      	movs	r3, #0
34005500:	627b      	str	r3, [r7, #36]	@ 0x24
34005502:	e01a      	b.n	3400553a <bsp_lcd_draw_bitmap+0x13e>
    {
        bsp_lcd_convert_line_to_rgb((uint32_t *)bitmap, (uint32_t *)address, width, input_color_mode);
34005504:	6a39      	ldr	r1, [r7, #32]
34005506:	69fb      	ldr	r3, [r7, #28]
34005508:	69ba      	ldr	r2, [r7, #24]
3400550a:	6838      	ldr	r0, [r7, #0]
3400550c:	f000 facc 	bl	34005aa8 <bsp_lcd_convert_line_to_rgb>
        address += (bsp_lcd.bpp_factor * bsp_lcd.x_size);
34005510:	4b0e      	ldr	r3, [pc, #56]	@ (3400554c <bsp_lcd_draw_bitmap+0x150>)
34005512:	691b      	ldr	r3, [r3, #16]
34005514:	4a0d      	ldr	r2, [pc, #52]	@ (3400554c <bsp_lcd_draw_bitmap+0x150>)
34005516:	6812      	ldr	r2, [r2, #0]
34005518:	fb02 f303 	mul.w	r3, r2, r3
3400551c:	6a3a      	ldr	r2, [r7, #32]
3400551e:	4413      	add	r3, r2
34005520:	623b      	str	r3, [r7, #32]
        bitmap -= width * (bit_pixel / 8);
34005522:	693b      	ldr	r3, [r7, #16]
34005524:	08db      	lsrs	r3, r3, #3
34005526:	69ba      	ldr	r2, [r7, #24]
34005528:	fb02 f303 	mul.w	r3, r2, r3
3400552c:	425b      	negs	r3, r3
3400552e:	683a      	ldr	r2, [r7, #0]
34005530:	4413      	add	r3, r2
34005532:	603b      	str	r3, [r7, #0]
    for(index=0; index < height; index++)
34005534:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005536:	3301      	adds	r3, #1
34005538:	627b      	str	r3, [r7, #36]	@ 0x24
3400553a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3400553c:	697b      	ldr	r3, [r7, #20]
3400553e:	429a      	cmp	r2, r3
34005540:	d3e0      	bcc.n	34005504 <bsp_lcd_draw_bitmap+0x108>
    }

    return 0;
34005542:	2300      	movs	r3, #0
}
34005544:	4618      	mov	r0, r3
34005546:	3728      	adds	r7, #40	@ 0x28
34005548:	46bd      	mov	sp, r7
3400554a:	bd80      	pop	{r7, pc}
3400554c:	3404a1dc 	.word	0x3404a1dc
34005550:	34048ea0 	.word	0x34048ea0

34005554 <bsp_lcd_fill_rgb_rect>:

static int32_t bsp_lcd_fill_rgb_rect(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint8_t *data, uint32_t width, uint32_t height)
{
34005554:	b590      	push	{r4, r7, lr}
34005556:	b08d      	sub	sp, #52	@ 0x34
34005558:	af00      	add	r7, sp, #0
3400555a:	60f8      	str	r0, [r7, #12]
3400555c:	60b9      	str	r1, [r7, #8]
3400555e:	607a      	str	r2, [r7, #4]
34005560:	603b      	str	r3, [r7, #0]
    uint32_t i;
    uint32_t address;
    uint32_t input_color_mode;

    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
34005562:	4b3c      	ldr	r3, [pc, #240]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
34005564:	68db      	ldr	r3, [r3, #12]
34005566:	2b02      	cmp	r3, #2
34005568:	d102      	bne.n	34005570 <bsp_lcd_fill_rgb_rect+0x1c>
    {
        input_color_mode = DMA2D_INPUT_RGB565;
3400556a:	2302      	movs	r3, #2
3400556c:	62bb      	str	r3, [r7, #40]	@ 0x28
3400556e:	e00f      	b.n	34005590 <bsp_lcd_fill_rgb_rect+0x3c>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
34005570:	4b38      	ldr	r3, [pc, #224]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
34005572:	68db      	ldr	r3, [r3, #12]
34005574:	2b04      	cmp	r3, #4
34005576:	d102      	bne.n	3400557e <bsp_lcd_fill_rgb_rect+0x2a>
    {
        input_color_mode = DMA2D_INPUT_ARGB4444;
34005578:	2304      	movs	r3, #4
3400557a:	62bb      	str	r3, [r7, #40]	@ 0x28
3400557c:	e008      	b.n	34005590 <bsp_lcd_fill_rgb_rect+0x3c>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB888)
3400557e:	4b35      	ldr	r3, [pc, #212]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
34005580:	68db      	ldr	r3, [r3, #12]
34005582:	2b01      	cmp	r3, #1
34005584:	d102      	bne.n	3400558c <bsp_lcd_fill_rgb_rect+0x38>
    {
        input_color_mode = DMA2D_INPUT_RGB888;
34005586:	2301      	movs	r3, #1
34005588:	62bb      	str	r3, [r7, #40]	@ 0x28
3400558a:	e001      	b.n	34005590 <bsp_lcd_fill_rgb_rect+0x3c>
    }
    else
    {
        input_color_mode = DMA2D_INPUT_ARGB8888;
3400558c:	2300      	movs	r3, #0
3400558e:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    for (i = 0; i < height; i++)
34005590:	2300      	movs	r3, #0
34005592:	62fb      	str	r3, [r7, #44]	@ 0x2c
34005594:	e054      	b.n	34005640 <bsp_lcd_fill_rgb_rect+0xec>
    {
        address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * (y_pos + i)) + x_pos));
34005596:	4b2f      	ldr	r3, [pc, #188]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
34005598:	689b      	ldr	r3, [r3, #8]
3400559a:	4a2f      	ldr	r2, [pc, #188]	@ (34005658 <bsp_lcd_fill_rgb_rect+0x104>)
3400559c:	2134      	movs	r1, #52	@ 0x34
3400559e:	fb01 f303 	mul.w	r3, r1, r3
340055a2:	4413      	add	r3, r2
340055a4:	335c      	adds	r3, #92	@ 0x5c
340055a6:	681a      	ldr	r2, [r3, #0]
340055a8:	4b2a      	ldr	r3, [pc, #168]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
340055aa:	691b      	ldr	r3, [r3, #16]
340055ac:	4929      	ldr	r1, [pc, #164]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
340055ae:	6809      	ldr	r1, [r1, #0]
340055b0:	687c      	ldr	r4, [r7, #4]
340055b2:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
340055b4:	4420      	add	r0, r4
340055b6:	fb01 f000 	mul.w	r0, r1, r0
340055ba:	68b9      	ldr	r1, [r7, #8]
340055bc:	4401      	add	r1, r0
340055be:	fb01 f303 	mul.w	r3, r1, r3
340055c2:	4413      	add	r3, r2
340055c4:	627b      	str	r3, [r7, #36]	@ 0x24
        SCB_CleanDCache_by_Addr((uint32_t *)data, bsp_lcd.bpp_factor * bsp_lcd.x_size);
340055c6:	4b23      	ldr	r3, [pc, #140]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
340055c8:	691b      	ldr	r3, [r3, #16]
340055ca:	4a22      	ldr	r2, [pc, #136]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
340055cc:	6812      	ldr	r2, [r2, #0]
340055ce:	fb02 f303 	mul.w	r3, r2, r3
340055d2:	461a      	mov	r2, r3
340055d4:	683b      	ldr	r3, [r7, #0]
340055d6:	623b      	str	r3, [r7, #32]
340055d8:	61fa      	str	r2, [r7, #28]
    if ( dsize > 0 ) {
340055da:	69fb      	ldr	r3, [r7, #28]
340055dc:	2b00      	cmp	r3, #0
340055de:	dd1d      	ble.n	3400561c <bsp_lcd_fill_rgb_rect+0xc8>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
340055e0:	6a3b      	ldr	r3, [r7, #32]
340055e2:	f003 021f 	and.w	r2, r3, #31
340055e6:	69fb      	ldr	r3, [r7, #28]
340055e8:	4413      	add	r3, r2
340055ea:	61bb      	str	r3, [r7, #24]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
340055ec:	6a3b      	ldr	r3, [r7, #32]
340055ee:	617b      	str	r3, [r7, #20]
  __ASM volatile ("dsb 0xF":::"memory");
340055f0:	f3bf 8f4f 	dsb	sy
}
340055f4:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340055f6:	4a19      	ldr	r2, [pc, #100]	@ (3400565c <bsp_lcd_fill_rgb_rect+0x108>)
340055f8:	697b      	ldr	r3, [r7, #20]
340055fa:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340055fe:	697b      	ldr	r3, [r7, #20]
34005600:	3320      	adds	r3, #32
34005602:	617b      	str	r3, [r7, #20]
        op_size -= __SCB_DCACHE_LINE_SIZE;
34005604:	69bb      	ldr	r3, [r7, #24]
34005606:	3b20      	subs	r3, #32
34005608:	61bb      	str	r3, [r7, #24]
      } while ( op_size > 0 );
3400560a:	69bb      	ldr	r3, [r7, #24]
3400560c:	2b00      	cmp	r3, #0
3400560e:	dcf2      	bgt.n	340055f6 <bsp_lcd_fill_rgb_rect+0xa2>
  __ASM volatile ("dsb 0xF":::"memory");
34005610:	f3bf 8f4f 	dsb	sy
}
34005614:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
34005616:	f3bf 8f6f 	isb	sy
}
3400561a:	bf00      	nop
}
3400561c:	bf00      	nop
        bsp_lcd_convert_line_to_rgb((uint32_t *)data, (uint32_t *)address, width, input_color_mode);
3400561e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
34005620:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34005622:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34005624:	6838      	ldr	r0, [r7, #0]
34005626:	f000 fa3f 	bl	34005aa8 <bsp_lcd_convert_line_to_rgb>
        data += bsp_lcd.bpp_factor * width;
3400562a:	4b0a      	ldr	r3, [pc, #40]	@ (34005654 <bsp_lcd_fill_rgb_rect+0x100>)
3400562c:	691b      	ldr	r3, [r3, #16]
3400562e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34005630:	fb02 f303 	mul.w	r3, r2, r3
34005634:	683a      	ldr	r2, [r7, #0]
34005636:	4413      	add	r3, r2
34005638:	603b      	str	r3, [r7, #0]
    for (i = 0; i < height; i++)
3400563a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400563c:	3301      	adds	r3, #1
3400563e:	62fb      	str	r3, [r7, #44]	@ 0x2c
34005640:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34005642:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34005644:	429a      	cmp	r2, r3
34005646:	d3a6      	bcc.n	34005596 <bsp_lcd_fill_rgb_rect+0x42>
    }

    return 0;
34005648:	2300      	movs	r3, #0
}
3400564a:	4618      	mov	r0, r3
3400564c:	3734      	adds	r7, #52	@ 0x34
3400564e:	46bd      	mov	sp, r7
34005650:	bd90      	pop	{r4, r7, pc}
34005652:	bf00      	nop
34005654:	3404a1dc 	.word	0x3404a1dc
34005658:	34048ea0 	.word	0x34048ea0
3400565c:	e000ed00 	.word	0xe000ed00

34005660 <bsp_lcd_draw_h_line>:

static int32_t bsp_lcd_draw_h_line(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t length, uint32_t color)
{
34005660:	b580      	push	{r7, lr}
34005662:	b088      	sub	sp, #32
34005664:	af02      	add	r7, sp, #8
34005666:	60f8      	str	r0, [r7, #12]
34005668:	60b9      	str	r1, [r7, #8]
3400566a:	607a      	str	r2, [r7, #4]
3400566c:	603b      	str	r3, [r7, #0]
    uint32_t address;

    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
3400566e:	4b11      	ldr	r3, [pc, #68]	@ (340056b4 <bsp_lcd_draw_h_line+0x54>)
34005670:	689b      	ldr	r3, [r3, #8]
34005672:	4a11      	ldr	r2, [pc, #68]	@ (340056b8 <bsp_lcd_draw_h_line+0x58>)
34005674:	2134      	movs	r1, #52	@ 0x34
34005676:	fb01 f303 	mul.w	r3, r1, r3
3400567a:	4413      	add	r3, r2
3400567c:	335c      	adds	r3, #92	@ 0x5c
3400567e:	681a      	ldr	r2, [r3, #0]
34005680:	4b0c      	ldr	r3, [pc, #48]	@ (340056b4 <bsp_lcd_draw_h_line+0x54>)
34005682:	691b      	ldr	r3, [r3, #16]
34005684:	490b      	ldr	r1, [pc, #44]	@ (340056b4 <bsp_lcd_draw_h_line+0x54>)
34005686:	6809      	ldr	r1, [r1, #0]
34005688:	6878      	ldr	r0, [r7, #4]
3400568a:	fb01 f000 	mul.w	r0, r1, r0
3400568e:	68b9      	ldr	r1, [r7, #8]
34005690:	4401      	add	r1, r0
34005692:	fb01 f303 	mul.w	r3, r1, r3
34005696:	4413      	add	r3, r2
34005698:	617b      	str	r3, [r7, #20]
    bsp_lcd_fill_buffer((uint32_t *)address, length, 1, 0, color);
3400569a:	6978      	ldr	r0, [r7, #20]
3400569c:	6a3b      	ldr	r3, [r7, #32]
3400569e:	9300      	str	r3, [sp, #0]
340056a0:	2300      	movs	r3, #0
340056a2:	2201      	movs	r2, #1
340056a4:	6839      	ldr	r1, [r7, #0]
340056a6:	f000 fa5d 	bl	34005b64 <bsp_lcd_fill_buffer>

    return 0;
340056aa:	2300      	movs	r3, #0
}
340056ac:	4618      	mov	r0, r3
340056ae:	3718      	adds	r7, #24
340056b0:	46bd      	mov	sp, r7
340056b2:	bd80      	pop	{r7, pc}
340056b4:	3404a1dc 	.word	0x3404a1dc
340056b8:	34048ea0 	.word	0x34048ea0

340056bc <bsp_lcd_draw_v_line>:

static int32_t bsp_lcd_draw_v_line(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t length, uint32_t color)
{
340056bc:	b580      	push	{r7, lr}
340056be:	b088      	sub	sp, #32
340056c0:	af02      	add	r7, sp, #8
340056c2:	60f8      	str	r0, [r7, #12]
340056c4:	60b9      	str	r1, [r7, #8]
340056c6:	607a      	str	r2, [r7, #4]
340056c8:	603b      	str	r3, [r7, #0]
    uint32_t address;

    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
340056ca:	4b13      	ldr	r3, [pc, #76]	@ (34005718 <bsp_lcd_draw_v_line+0x5c>)
340056cc:	689b      	ldr	r3, [r3, #8]
340056ce:	4a13      	ldr	r2, [pc, #76]	@ (3400571c <bsp_lcd_draw_v_line+0x60>)
340056d0:	2134      	movs	r1, #52	@ 0x34
340056d2:	fb01 f303 	mul.w	r3, r1, r3
340056d6:	4413      	add	r3, r2
340056d8:	335c      	adds	r3, #92	@ 0x5c
340056da:	681a      	ldr	r2, [r3, #0]
340056dc:	4b0e      	ldr	r3, [pc, #56]	@ (34005718 <bsp_lcd_draw_v_line+0x5c>)
340056de:	691b      	ldr	r3, [r3, #16]
340056e0:	490d      	ldr	r1, [pc, #52]	@ (34005718 <bsp_lcd_draw_v_line+0x5c>)
340056e2:	6809      	ldr	r1, [r1, #0]
340056e4:	6878      	ldr	r0, [r7, #4]
340056e6:	fb01 f000 	mul.w	r0, r1, r0
340056ea:	68b9      	ldr	r1, [r7, #8]
340056ec:	4401      	add	r1, r0
340056ee:	fb01 f303 	mul.w	r3, r1, r3
340056f2:	4413      	add	r3, r2
340056f4:	617b      	str	r3, [r7, #20]
    bsp_lcd_fill_buffer((uint32_t *)address, 1, length, bsp_lcd.x_size - 1, color);
340056f6:	6978      	ldr	r0, [r7, #20]
340056f8:	4b07      	ldr	r3, [pc, #28]	@ (34005718 <bsp_lcd_draw_v_line+0x5c>)
340056fa:	681b      	ldr	r3, [r3, #0]
340056fc:	1e5a      	subs	r2, r3, #1
340056fe:	6a3b      	ldr	r3, [r7, #32]
34005700:	9300      	str	r3, [sp, #0]
34005702:	4613      	mov	r3, r2
34005704:	683a      	ldr	r2, [r7, #0]
34005706:	2101      	movs	r1, #1
34005708:	f000 fa2c 	bl	34005b64 <bsp_lcd_fill_buffer>

    return 0;
3400570c:	2300      	movs	r3, #0
}
3400570e:	4618      	mov	r0, r3
34005710:	3718      	adds	r7, #24
34005712:	46bd      	mov	sp, r7
34005714:	bd80      	pop	{r7, pc}
34005716:	bf00      	nop
34005718:	3404a1dc 	.word	0x3404a1dc
3400571c:	34048ea0 	.word	0x34048ea0

34005720 <bsp_lcd_fill_rect>:

static int32_t bsp_lcd_fill_rect(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t width, uint32_t height, uint32_t color)
{
34005720:	b580      	push	{r7, lr}
34005722:	b088      	sub	sp, #32
34005724:	af02      	add	r7, sp, #8
34005726:	60f8      	str	r0, [r7, #12]
34005728:	60b9      	str	r1, [r7, #8]
3400572a:	607a      	str	r2, [r7, #4]
3400572c:	603b      	str	r3, [r7, #0]
    uint32_t address;

    address = hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (bsp_lcd.bpp_factor * ((bsp_lcd.x_size * y_pos) + x_pos));
3400572e:	4b13      	ldr	r3, [pc, #76]	@ (3400577c <bsp_lcd_fill_rect+0x5c>)
34005730:	689b      	ldr	r3, [r3, #8]
34005732:	4a13      	ldr	r2, [pc, #76]	@ (34005780 <bsp_lcd_fill_rect+0x60>)
34005734:	2134      	movs	r1, #52	@ 0x34
34005736:	fb01 f303 	mul.w	r3, r1, r3
3400573a:	4413      	add	r3, r2
3400573c:	335c      	adds	r3, #92	@ 0x5c
3400573e:	681a      	ldr	r2, [r3, #0]
34005740:	4b0e      	ldr	r3, [pc, #56]	@ (3400577c <bsp_lcd_fill_rect+0x5c>)
34005742:	691b      	ldr	r3, [r3, #16]
34005744:	490d      	ldr	r1, [pc, #52]	@ (3400577c <bsp_lcd_fill_rect+0x5c>)
34005746:	6809      	ldr	r1, [r1, #0]
34005748:	6878      	ldr	r0, [r7, #4]
3400574a:	fb01 f000 	mul.w	r0, r1, r0
3400574e:	68b9      	ldr	r1, [r7, #8]
34005750:	4401      	add	r1, r0
34005752:	fb01 f303 	mul.w	r3, r1, r3
34005756:	4413      	add	r3, r2
34005758:	617b      	str	r3, [r7, #20]
    bsp_lcd_fill_buffer((uint32_t *)address, width, height, bsp_lcd.x_size - width, color);
3400575a:	6978      	ldr	r0, [r7, #20]
3400575c:	4b07      	ldr	r3, [pc, #28]	@ (3400577c <bsp_lcd_fill_rect+0x5c>)
3400575e:	681a      	ldr	r2, [r3, #0]
34005760:	683b      	ldr	r3, [r7, #0]
34005762:	1ad2      	subs	r2, r2, r3
34005764:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34005766:	9300      	str	r3, [sp, #0]
34005768:	4613      	mov	r3, r2
3400576a:	6a3a      	ldr	r2, [r7, #32]
3400576c:	6839      	ldr	r1, [r7, #0]
3400576e:	f000 f9f9 	bl	34005b64 <bsp_lcd_fill_buffer>

    return 0;
34005772:	2300      	movs	r3, #0
}
34005774:	4618      	mov	r0, r3
34005776:	3718      	adds	r7, #24
34005778:	46bd      	mov	sp, r7
3400577a:	bd80      	pop	{r7, pc}
3400577c:	3404a1dc 	.word	0x3404a1dc
34005780:	34048ea0 	.word	0x34048ea0

34005784 <bsp_lcd_get_pixel>:

static int32_t bsp_lcd_get_pixel(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t *color)
{
34005784:	b480      	push	{r7}
34005786:	b085      	sub	sp, #20
34005788:	af00      	add	r7, sp, #0
3400578a:	60f8      	str	r0, [r7, #12]
3400578c:	60b9      	str	r1, [r7, #8]
3400578e:	607a      	str	r2, [r7, #4]
34005790:	603b      	str	r3, [r7, #0]
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
34005792:	4b34      	ldr	r3, [pc, #208]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
34005794:	689b      	ldr	r3, [r3, #8]
34005796:	4a34      	ldr	r2, [pc, #208]	@ (34005868 <bsp_lcd_get_pixel+0xe4>)
34005798:	2134      	movs	r1, #52	@ 0x34
3400579a:	fb01 f303 	mul.w	r3, r1, r3
3400579e:	4413      	add	r3, r2
340057a0:	3348      	adds	r3, #72	@ 0x48
340057a2:	681b      	ldr	r3, [r3, #0]
340057a4:	2b00      	cmp	r3, #0
340057a6:	d115      	bne.n	340057d4 <bsp_lcd_get_pixel+0x50>
    {
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340057a8:	4b2e      	ldr	r3, [pc, #184]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
340057aa:	689b      	ldr	r3, [r3, #8]
340057ac:	4a2e      	ldr	r2, [pc, #184]	@ (34005868 <bsp_lcd_get_pixel+0xe4>)
340057ae:	2134      	movs	r1, #52	@ 0x34
340057b0:	fb01 f303 	mul.w	r3, r1, r3
340057b4:	4413      	add	r3, r2
340057b6:	335c      	adds	r3, #92	@ 0x5c
340057b8:	681a      	ldr	r2, [r3, #0]
340057ba:	4b2a      	ldr	r3, [pc, #168]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
340057bc:	681b      	ldr	r3, [r3, #0]
340057be:	6879      	ldr	r1, [r7, #4]
340057c0:	fb03 f101 	mul.w	r1, r3, r1
340057c4:	68bb      	ldr	r3, [r7, #8]
340057c6:	440b      	add	r3, r1
340057c8:	009b      	lsls	r3, r3, #2
340057ca:	4413      	add	r3, r2
340057cc:	681a      	ldr	r2, [r3, #0]
340057ce:	683b      	ldr	r3, [r7, #0]
340057d0:	601a      	str	r2, [r3, #0]
340057d2:	e03f      	b.n	34005854 <bsp_lcd_get_pixel+0xd0>
    }
    else if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340057d4:	4b23      	ldr	r3, [pc, #140]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
340057d6:	689b      	ldr	r3, [r3, #8]
340057d8:	4a23      	ldr	r2, [pc, #140]	@ (34005868 <bsp_lcd_get_pixel+0xe4>)
340057da:	2134      	movs	r1, #52	@ 0x34
340057dc:	fb01 f303 	mul.w	r3, r1, r3
340057e0:	4413      	add	r3, r2
340057e2:	3348      	adds	r3, #72	@ 0x48
340057e4:	681b      	ldr	r3, [r3, #0]
340057e6:	2b06      	cmp	r3, #6
340057e8:	d11d      	bne.n	34005826 <bsp_lcd_get_pixel+0xa2>
    {
        *color = *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (3 * ((bsp_lcd.x_size * y_pos) + x_pos)));
340057ea:	4b1e      	ldr	r3, [pc, #120]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
340057ec:	689b      	ldr	r3, [r3, #8]
340057ee:	4a1e      	ldr	r2, [pc, #120]	@ (34005868 <bsp_lcd_get_pixel+0xe4>)
340057f0:	2134      	movs	r1, #52	@ 0x34
340057f2:	fb01 f303 	mul.w	r3, r1, r3
340057f6:	4413      	add	r3, r2
340057f8:	335c      	adds	r3, #92	@ 0x5c
340057fa:	6819      	ldr	r1, [r3, #0]
340057fc:	4b19      	ldr	r3, [pc, #100]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
340057fe:	681b      	ldr	r3, [r3, #0]
34005800:	687a      	ldr	r2, [r7, #4]
34005802:	fb03 f202 	mul.w	r2, r3, r2
34005806:	68bb      	ldr	r3, [r7, #8]
34005808:	441a      	add	r2, r3
3400580a:	4613      	mov	r3, r2
3400580c:	005b      	lsls	r3, r3, #1
3400580e:	4413      	add	r3, r2
34005810:	440b      	add	r3, r1
34005812:	681a      	ldr	r2, [r3, #0]
34005814:	683b      	ldr	r3, [r7, #0]
34005816:	601a      	str	r2, [r3, #0]
        *color = CONVERTARGB88882RGB888(*color);
34005818:	683b      	ldr	r3, [r7, #0]
3400581a:	681b      	ldr	r3, [r3, #0]
3400581c:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34005820:	683b      	ldr	r3, [r7, #0]
34005822:	601a      	str	r2, [r3, #0]
34005824:	e016      	b.n	34005854 <bsp_lcd_get_pixel+0xd0>
    }
    else
    {
        *color = *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos)));
34005826:	4b0f      	ldr	r3, [pc, #60]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
34005828:	689b      	ldr	r3, [r3, #8]
3400582a:	4a0f      	ldr	r2, [pc, #60]	@ (34005868 <bsp_lcd_get_pixel+0xe4>)
3400582c:	2134      	movs	r1, #52	@ 0x34
3400582e:	fb01 f303 	mul.w	r3, r1, r3
34005832:	4413      	add	r3, r2
34005834:	335c      	adds	r3, #92	@ 0x5c
34005836:	681a      	ldr	r2, [r3, #0]
34005838:	4b0a      	ldr	r3, [pc, #40]	@ (34005864 <bsp_lcd_get_pixel+0xe0>)
3400583a:	681b      	ldr	r3, [r3, #0]
3400583c:	6879      	ldr	r1, [r7, #4]
3400583e:	fb03 f101 	mul.w	r1, r3, r1
34005842:	68bb      	ldr	r3, [r7, #8]
34005844:	440b      	add	r3, r1
34005846:	005b      	lsls	r3, r3, #1
34005848:	4413      	add	r3, r2
3400584a:	881b      	ldrh	r3, [r3, #0]
3400584c:	b29b      	uxth	r3, r3
3400584e:	461a      	mov	r2, r3
34005850:	683b      	ldr	r3, [r7, #0]
34005852:	601a      	str	r2, [r3, #0]
    }

    return 0;
34005854:	2300      	movs	r3, #0
}
34005856:	4618      	mov	r0, r3
34005858:	3714      	adds	r7, #20
3400585a:	46bd      	mov	sp, r7
3400585c:	f85d 7b04 	ldr.w	r7, [sp], #4
34005860:	4770      	bx	lr
34005862:	bf00      	nop
34005864:	3404a1dc 	.word	0x3404a1dc
34005868:	34048ea0 	.word	0x34048ea0

3400586c <bsp_lcd_set_pixel>:

static int32_t bsp_lcd_set_pixel(uint32_t instance, uint32_t x_pos, uint32_t y_pos, uint32_t color)
{
3400586c:	b480      	push	{r7}
3400586e:	b085      	sub	sp, #20
34005870:	af00      	add	r7, sp, #0
34005872:	60f8      	str	r0, [r7, #12]
34005874:	60b9      	str	r1, [r7, #8]
34005876:	607a      	str	r2, [r7, #4]
34005878:	603b      	str	r3, [r7, #0]
    if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
3400587a:	4b49      	ldr	r3, [pc, #292]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400587c:	689b      	ldr	r3, [r3, #8]
3400587e:	4a49      	ldr	r2, [pc, #292]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
34005880:	2134      	movs	r1, #52	@ 0x34
34005882:	fb01 f303 	mul.w	r3, r1, r3
34005886:	4413      	add	r3, r2
34005888:	3348      	adds	r3, #72	@ 0x48
3400588a:	681b      	ldr	r3, [r3, #0]
3400588c:	2b00      	cmp	r3, #0
3400588e:	d115      	bne.n	340058bc <bsp_lcd_set_pixel+0x50>
    {
        *(__IO uint32_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (4 * ((bsp_lcd.x_size * y_pos) + x_pos))) = color;
34005890:	4b43      	ldr	r3, [pc, #268]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
34005892:	689b      	ldr	r3, [r3, #8]
34005894:	4a43      	ldr	r2, [pc, #268]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
34005896:	2134      	movs	r1, #52	@ 0x34
34005898:	fb01 f303 	mul.w	r3, r1, r3
3400589c:	4413      	add	r3, r2
3400589e:	335c      	adds	r3, #92	@ 0x5c
340058a0:	681a      	ldr	r2, [r3, #0]
340058a2:	4b3f      	ldr	r3, [pc, #252]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
340058a4:	681b      	ldr	r3, [r3, #0]
340058a6:	6879      	ldr	r1, [r7, #4]
340058a8:	fb03 f101 	mul.w	r1, r3, r1
340058ac:	68bb      	ldr	r3, [r7, #8]
340058ae:	440b      	add	r3, r1
340058b0:	009b      	lsls	r3, r3, #2
340058b2:	4413      	add	r3, r2
340058b4:	461a      	mov	r2, r3
340058b6:	683b      	ldr	r3, [r7, #0]
340058b8:	6013      	str	r3, [r2, #0]
340058ba:	e06a      	b.n	34005992 <bsp_lcd_set_pixel+0x126>
    }
    else if (hltdc.LayerCfg[bsp_lcd.active_layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
340058bc:	4b38      	ldr	r3, [pc, #224]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
340058be:	689b      	ldr	r3, [r3, #8]
340058c0:	4a38      	ldr	r2, [pc, #224]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
340058c2:	2134      	movs	r1, #52	@ 0x34
340058c4:	fb01 f303 	mul.w	r3, r1, r3
340058c8:	4413      	add	r3, r2
340058ca:	3348      	adds	r3, #72	@ 0x48
340058cc:	681b      	ldr	r3, [r3, #0]
340058ce:	2b06      	cmp	r3, #6
340058d0:	d14a      	bne.n	34005968 <bsp_lcd_set_pixel+0xfc>
    {
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 3)) = (uint8_t)color;
340058d2:	4b33      	ldr	r3, [pc, #204]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
340058d4:	689b      	ldr	r3, [r3, #8]
340058d6:	4a33      	ldr	r2, [pc, #204]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
340058d8:	2134      	movs	r1, #52	@ 0x34
340058da:	fb01 f303 	mul.w	r3, r1, r3
340058de:	4413      	add	r3, r2
340058e0:	335c      	adds	r3, #92	@ 0x5c
340058e2:	6819      	ldr	r1, [r3, #0]
340058e4:	4b2e      	ldr	r3, [pc, #184]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
340058e6:	681b      	ldr	r3, [r3, #0]
340058e8:	687a      	ldr	r2, [r7, #4]
340058ea:	fb03 f202 	mul.w	r2, r3, r2
340058ee:	68bb      	ldr	r3, [r7, #8]
340058f0:	441a      	add	r2, r3
340058f2:	4613      	mov	r3, r2
340058f4:	005b      	lsls	r3, r3, #1
340058f6:	4413      	add	r3, r2
340058f8:	440b      	add	r3, r1
340058fa:	3b03      	subs	r3, #3
340058fc:	683a      	ldr	r2, [r7, #0]
340058fe:	b2d2      	uxtb	r2, r2
34005900:	701a      	strb	r2, [r3, #0]
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 2)) = (uint8_t)(color >> 8);
34005902:	683b      	ldr	r3, [r7, #0]
34005904:	0a18      	lsrs	r0, r3, #8
34005906:	4b26      	ldr	r3, [pc, #152]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
34005908:	689b      	ldr	r3, [r3, #8]
3400590a:	4a26      	ldr	r2, [pc, #152]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
3400590c:	2134      	movs	r1, #52	@ 0x34
3400590e:	fb01 f303 	mul.w	r3, r1, r3
34005912:	4413      	add	r3, r2
34005914:	335c      	adds	r3, #92	@ 0x5c
34005916:	6819      	ldr	r1, [r3, #0]
34005918:	4b21      	ldr	r3, [pc, #132]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400591a:	681b      	ldr	r3, [r3, #0]
3400591c:	687a      	ldr	r2, [r7, #4]
3400591e:	fb03 f202 	mul.w	r2, r3, r2
34005922:	68bb      	ldr	r3, [r7, #8]
34005924:	441a      	add	r2, r3
34005926:	4613      	mov	r3, r2
34005928:	005b      	lsls	r3, r3, #1
3400592a:	4413      	add	r3, r2
3400592c:	440b      	add	r3, r1
3400592e:	3b02      	subs	r3, #2
34005930:	b2c2      	uxtb	r2, r0
34005932:	701a      	strb	r2, [r3, #0]
        *(__IO uint8_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + ((3 * ((bsp_lcd.x_size * y_pos) + x_pos)) - 1)) = (uint8_t)(color >> 16);
34005934:	683b      	ldr	r3, [r7, #0]
34005936:	0c18      	lsrs	r0, r3, #16
34005938:	4b19      	ldr	r3, [pc, #100]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400593a:	689b      	ldr	r3, [r3, #8]
3400593c:	4a19      	ldr	r2, [pc, #100]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
3400593e:	2134      	movs	r1, #52	@ 0x34
34005940:	fb01 f303 	mul.w	r3, r1, r3
34005944:	4413      	add	r3, r2
34005946:	335c      	adds	r3, #92	@ 0x5c
34005948:	6819      	ldr	r1, [r3, #0]
3400594a:	4b15      	ldr	r3, [pc, #84]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400594c:	681b      	ldr	r3, [r3, #0]
3400594e:	687a      	ldr	r2, [r7, #4]
34005950:	fb03 f202 	mul.w	r2, r3, r2
34005954:	68bb      	ldr	r3, [r7, #8]
34005956:	441a      	add	r2, r3
34005958:	4613      	mov	r3, r2
3400595a:	005b      	lsls	r3, r3, #1
3400595c:	4413      	add	r3, r2
3400595e:	440b      	add	r3, r1
34005960:	3b01      	subs	r3, #1
34005962:	b2c2      	uxtb	r2, r0
34005964:	701a      	strb	r2, [r3, #0]
34005966:	e014      	b.n	34005992 <bsp_lcd_set_pixel+0x126>
    }
    else
    {
        *(__IO uint16_t *)(hltdc.LayerCfg[bsp_lcd.active_layer].FBStartAdress + (2 * ((bsp_lcd.x_size * y_pos) + x_pos))) = (uint16_t)color;
34005968:	4b0d      	ldr	r3, [pc, #52]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400596a:	689b      	ldr	r3, [r3, #8]
3400596c:	4a0d      	ldr	r2, [pc, #52]	@ (340059a4 <bsp_lcd_set_pixel+0x138>)
3400596e:	2134      	movs	r1, #52	@ 0x34
34005970:	fb01 f303 	mul.w	r3, r1, r3
34005974:	4413      	add	r3, r2
34005976:	335c      	adds	r3, #92	@ 0x5c
34005978:	681a      	ldr	r2, [r3, #0]
3400597a:	4b09      	ldr	r3, [pc, #36]	@ (340059a0 <bsp_lcd_set_pixel+0x134>)
3400597c:	681b      	ldr	r3, [r3, #0]
3400597e:	6879      	ldr	r1, [r7, #4]
34005980:	fb03 f101 	mul.w	r1, r3, r1
34005984:	68bb      	ldr	r3, [r7, #8]
34005986:	440b      	add	r3, r1
34005988:	005b      	lsls	r3, r3, #1
3400598a:	4413      	add	r3, r2
3400598c:	683a      	ldr	r2, [r7, #0]
3400598e:	b292      	uxth	r2, r2
34005990:	801a      	strh	r2, [r3, #0]
    }

    return 0;
34005992:	2300      	movs	r3, #0
}
34005994:	4618      	mov	r0, r3
34005996:	3714      	adds	r7, #20
34005998:	46bd      	mov	sp, r7
3400599a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400599e:	4770      	bx	lr
340059a0:	3404a1dc 	.word	0x3404a1dc
340059a4:	34048ea0 	.word	0x34048ea0

340059a8 <bsp_lcd_get_x_size>:

static int32_t bsp_lcd_get_x_size(uint32_t instance, uint32_t *x_size)
{
340059a8:	b480      	push	{r7}
340059aa:	b083      	sub	sp, #12
340059ac:	af00      	add	r7, sp, #0
340059ae:	6078      	str	r0, [r7, #4]
340059b0:	6039      	str	r1, [r7, #0]
    *x_size = bsp_lcd.x_size;
340059b2:	4b05      	ldr	r3, [pc, #20]	@ (340059c8 <bsp_lcd_get_x_size+0x20>)
340059b4:	681a      	ldr	r2, [r3, #0]
340059b6:	683b      	ldr	r3, [r7, #0]
340059b8:	601a      	str	r2, [r3, #0]

    return 0;
340059ba:	2300      	movs	r3, #0
}
340059bc:	4618      	mov	r0, r3
340059be:	370c      	adds	r7, #12
340059c0:	46bd      	mov	sp, r7
340059c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340059c6:	4770      	bx	lr
340059c8:	3404a1dc 	.word	0x3404a1dc

340059cc <bsp_lcd_get_y_size>:

static int32_t bsp_lcd_get_y_size(uint32_t instance, uint32_t *y_size)
{
340059cc:	b480      	push	{r7}
340059ce:	b083      	sub	sp, #12
340059d0:	af00      	add	r7, sp, #0
340059d2:	6078      	str	r0, [r7, #4]
340059d4:	6039      	str	r1, [r7, #0]
    *y_size = bsp_lcd.y_size;
340059d6:	4b05      	ldr	r3, [pc, #20]	@ (340059ec <bsp_lcd_get_y_size+0x20>)
340059d8:	685a      	ldr	r2, [r3, #4]
340059da:	683b      	ldr	r3, [r7, #0]
340059dc:	601a      	str	r2, [r3, #0]

    return 0;
340059de:	2300      	movs	r3, #0
}
340059e0:	4618      	mov	r0, r3
340059e2:	370c      	adds	r7, #12
340059e4:	46bd      	mov	sp, r7
340059e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340059ea:	4770      	bx	lr
340059ec:	3404a1dc 	.word	0x3404a1dc

340059f0 <bsp_lcd_set_layer>:

static int32_t bsp_lcd_set_layer(uint32_t instance, uint32_t layer_index)
{
340059f0:	b480      	push	{r7}
340059f2:	b085      	sub	sp, #20
340059f4:	af00      	add	r7, sp, #0
340059f6:	6078      	str	r0, [r7, #4]
340059f8:	6039      	str	r1, [r7, #0]
    LTDC_LayerCfgTypeDef *layer_cfg;

    layer_cfg = &hltdc.LayerCfg[layer_index];
340059fa:	683b      	ldr	r3, [r7, #0]
340059fc:	2234      	movs	r2, #52	@ 0x34
340059fe:	fb02 f303 	mul.w	r3, r2, r3
34005a02:	3338      	adds	r3, #56	@ 0x38
34005a04:	4a1d      	ldr	r2, [pc, #116]	@ (34005a7c <bsp_lcd_set_layer+0x8c>)
34005a06:	4413      	add	r3, r2
34005a08:	60fb      	str	r3, [r7, #12]

    bsp_lcd.active_layer = layer_index;
34005a0a:	4a1d      	ldr	r2, [pc, #116]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a0c:	683b      	ldr	r3, [r7, #0]
34005a0e:	6093      	str	r3, [r2, #8]
    bsp_lcd.x_size = layer_cfg->ImageWidth;
34005a10:	68fb      	ldr	r3, [r7, #12]
34005a12:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34005a14:	4a1a      	ldr	r2, [pc, #104]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a16:	6013      	str	r3, [r2, #0]
    bsp_lcd.y_size = layer_cfg->ImageHeight;
34005a18:	68fb      	ldr	r3, [r7, #12]
34005a1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005a1c:	4a18      	ldr	r2, [pc, #96]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a1e:	6053      	str	r3, [r2, #4]
    if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)
34005a20:	68fb      	ldr	r3, [r7, #12]
34005a22:	691b      	ldr	r3, [r3, #16]
34005a24:	2b04      	cmp	r3, #4
34005a26:	d106      	bne.n	34005a36 <bsp_lcd_set_layer+0x46>
    {
        bsp_lcd.bpp_factor = 2;
34005a28:	4b15      	ldr	r3, [pc, #84]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a2a:	2202      	movs	r2, #2
34005a2c:	611a      	str	r2, [r3, #16]
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_RGB565;
34005a2e:	4b14      	ldr	r3, [pc, #80]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a30:	2202      	movs	r2, #2
34005a32:	60da      	str	r2, [r3, #12]
34005a34:	e01b      	b.n	34005a6e <bsp_lcd_set_layer+0x7e>
    }
    else if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444)
34005a36:	68fb      	ldr	r3, [r7, #12]
34005a38:	691b      	ldr	r3, [r3, #16]
34005a3a:	2b08      	cmp	r3, #8
34005a3c:	d106      	bne.n	34005a4c <bsp_lcd_set_layer+0x5c>
    {
        bsp_lcd.bpp_factor = 2;
34005a3e:	4b10      	ldr	r3, [pc, #64]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a40:	2202      	movs	r2, #2
34005a42:	611a      	str	r2, [r3, #16]
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_ARGB4444;
34005a44:	4b0e      	ldr	r3, [pc, #56]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a46:	2204      	movs	r2, #4
34005a48:	60da      	str	r2, [r3, #12]
34005a4a:	e010      	b.n	34005a6e <bsp_lcd_set_layer+0x7e>
    }
    else if (layer_cfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
34005a4c:	68fb      	ldr	r3, [r7, #12]
34005a4e:	691b      	ldr	r3, [r3, #16]
34005a50:	2b06      	cmp	r3, #6
34005a52:	d106      	bne.n	34005a62 <bsp_lcd_set_layer+0x72>
    {
        bsp_lcd.bpp_factor = 3;
34005a54:	4b0a      	ldr	r3, [pc, #40]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a56:	2203      	movs	r2, #3
34005a58:	611a      	str	r2, [r3, #16]
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_RGB888;
34005a5a:	4b09      	ldr	r3, [pc, #36]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a5c:	2201      	movs	r2, #1
34005a5e:	60da      	str	r2, [r3, #12]
34005a60:	e005      	b.n	34005a6e <bsp_lcd_set_layer+0x7e>
    }
    else
    {
        bsp_lcd.bpp_factor = 4;
34005a62:	4b07      	ldr	r3, [pc, #28]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a64:	2204      	movs	r2, #4
34005a66:	611a      	str	r2, [r3, #16]
        bsp_lcd.pixel_format = LCD_PIXEL_FORMAT_ARGB8888;
34005a68:	4b05      	ldr	r3, [pc, #20]	@ (34005a80 <bsp_lcd_set_layer+0x90>)
34005a6a:	2200      	movs	r2, #0
34005a6c:	60da      	str	r2, [r3, #12]
    }

    return 0;
34005a6e:	2300      	movs	r3, #0
}
34005a70:	4618      	mov	r0, r3
34005a72:	3714      	adds	r7, #20
34005a74:	46bd      	mov	sp, r7
34005a76:	f85d 7b04 	ldr.w	r7, [sp], #4
34005a7a:	4770      	bx	lr
34005a7c:	34048ea0 	.word	0x34048ea0
34005a80:	3404a1dc 	.word	0x3404a1dc

34005a84 <bsp_lcd_get_format>:

static int32_t bsp_lcd_get_format(uint32_t instance, uint32_t *pixel_format)
{
34005a84:	b480      	push	{r7}
34005a86:	b083      	sub	sp, #12
34005a88:	af00      	add	r7, sp, #0
34005a8a:	6078      	str	r0, [r7, #4]
34005a8c:	6039      	str	r1, [r7, #0]
    *pixel_format =  bsp_lcd.pixel_format;
34005a8e:	4b05      	ldr	r3, [pc, #20]	@ (34005aa4 <bsp_lcd_get_format+0x20>)
34005a90:	68da      	ldr	r2, [r3, #12]
34005a92:	683b      	ldr	r3, [r7, #0]
34005a94:	601a      	str	r2, [r3, #0]

    return 0;
34005a96:	2300      	movs	r3, #0
}
34005a98:	4618      	mov	r0, r3
34005a9a:	370c      	adds	r7, #12
34005a9c:	46bd      	mov	sp, r7
34005a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
34005aa2:	4770      	bx	lr
34005aa4:	3404a1dc 	.word	0x3404a1dc

34005aa8 <bsp_lcd_convert_line_to_rgb>:
    bsp_lcd_set_layer,
    bsp_lcd_get_format,
};

static void bsp_lcd_convert_line_to_rgb(uint32_t *source, uint32_t *destination, uint32_t x_size, uint32_t color_mode)
{
34005aa8:	b580      	push	{r7, lr}
34005aaa:	b088      	sub	sp, #32
34005aac:	af02      	add	r7, sp, #8
34005aae:	60f8      	str	r0, [r7, #12]
34005ab0:	60b9      	str	r1, [r7, #8]
34005ab2:	607a      	str	r2, [r7, #4]
34005ab4:	603b      	str	r3, [r7, #0]
    uint32_t output_color_mode;

    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
34005ab6:	4b28      	ldr	r3, [pc, #160]	@ (34005b58 <bsp_lcd_convert_line_to_rgb+0xb0>)
34005ab8:	68db      	ldr	r3, [r3, #12]
34005aba:	2b02      	cmp	r3, #2
34005abc:	d102      	bne.n	34005ac4 <bsp_lcd_convert_line_to_rgb+0x1c>
    {
        output_color_mode = DMA2D_OUTPUT_RGB565;
34005abe:	2302      	movs	r3, #2
34005ac0:	617b      	str	r3, [r7, #20]
34005ac2:	e00f      	b.n	34005ae4 <bsp_lcd_convert_line_to_rgb+0x3c>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
34005ac4:	4b24      	ldr	r3, [pc, #144]	@ (34005b58 <bsp_lcd_convert_line_to_rgb+0xb0>)
34005ac6:	68db      	ldr	r3, [r3, #12]
34005ac8:	2b04      	cmp	r3, #4
34005aca:	d102      	bne.n	34005ad2 <bsp_lcd_convert_line_to_rgb+0x2a>
    {
        output_color_mode = DMA2D_OUTPUT_ARGB4444;
34005acc:	2304      	movs	r3, #4
34005ace:	617b      	str	r3, [r7, #20]
34005ad0:	e008      	b.n	34005ae4 <bsp_lcd_convert_line_to_rgb+0x3c>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB888)
34005ad2:	4b21      	ldr	r3, [pc, #132]	@ (34005b58 <bsp_lcd_convert_line_to_rgb+0xb0>)
34005ad4:	68db      	ldr	r3, [r3, #12]
34005ad6:	2b01      	cmp	r3, #1
34005ad8:	d102      	bne.n	34005ae0 <bsp_lcd_convert_line_to_rgb+0x38>
    {
        output_color_mode = DMA2D_OUTPUT_RGB888;
34005ada:	2301      	movs	r3, #1
34005adc:	617b      	str	r3, [r7, #20]
34005ade:	e001      	b.n	34005ae4 <bsp_lcd_convert_line_to_rgb+0x3c>
    }
    else
    {
        output_color_mode = DMA2D_OUTPUT_ARGB8888;
34005ae0:	2300      	movs	r3, #0
34005ae2:	617b      	str	r3, [r7, #20]
    }

    hdma2d.Instance = DMA2D;
34005ae4:	4b1d      	ldr	r3, [pc, #116]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005ae6:	4a1e      	ldr	r2, [pc, #120]	@ (34005b60 <bsp_lcd_convert_line_to_rgb+0xb8>)
34005ae8:	601a      	str	r2, [r3, #0]
    hdma2d.Init.Mode = DMA2D_M2M_PFC;
34005aea:	4b1c      	ldr	r3, [pc, #112]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005aec:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34005af0:	605a      	str	r2, [r3, #4]
    hdma2d.Init.ColorMode = output_color_mode;
34005af2:	4a1a      	ldr	r2, [pc, #104]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005af4:	697b      	ldr	r3, [r7, #20]
34005af6:	6093      	str	r3, [r2, #8]
    hdma2d.Init.OutputOffset = 0;
34005af8:	4b18      	ldr	r3, [pc, #96]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005afa:	2200      	movs	r2, #0
34005afc:	60da      	str	r2, [r3, #12]
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].AlphaMode = DMA2D_NO_MODIF_ALPHA;
34005afe:	4b17      	ldr	r3, [pc, #92]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b00:	2200      	movs	r2, #0
34005b02:	64da      	str	r2, [r3, #76]	@ 0x4c
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputAlpha = 0xFF;
34005b04:	4b15      	ldr	r3, [pc, #84]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b06:	22ff      	movs	r2, #255	@ 0xff
34005b08:	651a      	str	r2, [r3, #80]	@ 0x50
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputColorMode = color_mode;
34005b0a:	4a14      	ldr	r2, [pc, #80]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b0c:	683b      	ldr	r3, [r7, #0]
34005b0e:	6493      	str	r3, [r2, #72]	@ 0x48
    hdma2d.LayerCfg[DMA2D_FOREGROUND_LAYER].InputOffset = 0;
34005b10:	4b12      	ldr	r3, [pc, #72]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b12:	2200      	movs	r2, #0
34005b14:	645a      	str	r2, [r3, #68]	@ 0x44
    if (HAL_DMA2D_Init(&hdma2d) == HAL_OK)
34005b16:	4811      	ldr	r0, [pc, #68]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b18:	f004 fca6 	bl	3400a468 <HAL_DMA2D_Init>
34005b1c:	4603      	mov	r3, r0
34005b1e:	2b00      	cmp	r3, #0
34005b20:	d115      	bne.n	34005b4e <bsp_lcd_convert_line_to_rgb+0xa6>
    {
        if (HAL_DMA2D_ConfigLayer(&hdma2d, DMA2D_FOREGROUND_LAYER) == HAL_OK)
34005b22:	2101      	movs	r1, #1
34005b24:	480d      	ldr	r0, [pc, #52]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b26:	f004 fe15 	bl	3400a754 <HAL_DMA2D_ConfigLayer>
34005b2a:	4603      	mov	r3, r0
34005b2c:	2b00      	cmp	r3, #0
34005b2e:	d10e      	bne.n	34005b4e <bsp_lcd_convert_line_to_rgb+0xa6>
        {
            if (HAL_DMA2D_Start(&hdma2d, (uint32_t)source, (uint32_t)destination, x_size, DMA2D_FOREGROUND_LAYER) == HAL_OK)
34005b30:	68f9      	ldr	r1, [r7, #12]
34005b32:	68ba      	ldr	r2, [r7, #8]
34005b34:	2301      	movs	r3, #1
34005b36:	9300      	str	r3, [sp, #0]
34005b38:	687b      	ldr	r3, [r7, #4]
34005b3a:	4808      	ldr	r0, [pc, #32]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b3c:	f004 fcf5 	bl	3400a52a <HAL_DMA2D_Start>
34005b40:	4603      	mov	r3, r0
34005b42:	2b00      	cmp	r3, #0
34005b44:	d103      	bne.n	34005b4e <bsp_lcd_convert_line_to_rgb+0xa6>
            {
                HAL_DMA2D_PollForTransfer(&hdma2d, 50);
34005b46:	2132      	movs	r1, #50	@ 0x32
34005b48:	4804      	ldr	r0, [pc, #16]	@ (34005b5c <bsp_lcd_convert_line_to_rgb+0xb4>)
34005b4a:	f004 fd19 	bl	3400a580 <HAL_DMA2D_PollForTransfer>
            }
        }
    }
}
34005b4e:	bf00      	nop
34005b50:	3718      	adds	r7, #24
34005b52:	46bd      	mov	sp, r7
34005b54:	bd80      	pop	{r7, pc}
34005b56:	bf00      	nop
34005b58:	3404a1dc 	.word	0x3404a1dc
34005b5c:	34048de4 	.word	0x34048de4
34005b60:	58021000 	.word	0x58021000

34005b64 <bsp_lcd_fill_buffer>:

static void bsp_lcd_fill_buffer(uint32_t *destination, uint32_t x_size, uint32_t y_size, uint32_t offset, uint32_t color)
{
34005b64:	b580      	push	{r7, lr}
34005b66:	b088      	sub	sp, #32
34005b68:	af02      	add	r7, sp, #8
34005b6a:	60f8      	str	r0, [r7, #12]
34005b6c:	60b9      	str	r1, [r7, #8]
34005b6e:	607a      	str	r2, [r7, #4]
34005b70:	603b      	str	r3, [r7, #0]
    uint32_t output_color_mode;
    uint32_t input_color;

    if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB565)
34005b72:	4b46      	ldr	r3, [pc, #280]	@ (34005c8c <bsp_lcd_fill_buffer+0x128>)
34005b74:	68db      	ldr	r3, [r3, #12]
34005b76:	2b02      	cmp	r3, #2
34005b78:	d129      	bne.n	34005bce <bsp_lcd_fill_buffer+0x6a>
    {
        output_color_mode = DMA2D_OUTPUT_RGB565;
34005b7a:	2302      	movs	r3, #2
34005b7c:	617b      	str	r3, [r7, #20]
        input_color = CONVERTRGB5652ARGB8888(color);
34005b7e:	6a3b      	ldr	r3, [r7, #32]
34005b80:	0adb      	lsrs	r3, r3, #11
34005b82:	f003 021f 	and.w	r2, r3, #31
34005b86:	4613      	mov	r3, r2
34005b88:	011b      	lsls	r3, r3, #4
34005b8a:	4413      	add	r3, r2
34005b8c:	015a      	lsls	r2, r3, #5
34005b8e:	1ad3      	subs	r3, r2, r3
34005b90:	3317      	adds	r3, #23
34005b92:	099b      	lsrs	r3, r3, #6
34005b94:	0419      	lsls	r1, r3, #16
34005b96:	6a3b      	ldr	r3, [r7, #32]
34005b98:	095b      	lsrs	r3, r3, #5
34005b9a:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
34005b9e:	4613      	mov	r3, r2
34005ba0:	01db      	lsls	r3, r3, #7
34005ba2:	4413      	add	r3, r2
34005ba4:	005b      	lsls	r3, r3, #1
34005ba6:	4413      	add	r3, r2
34005ba8:	3321      	adds	r3, #33	@ 0x21
34005baa:	099b      	lsrs	r3, r3, #6
34005bac:	021b      	lsls	r3, r3, #8
34005bae:	4319      	orrs	r1, r3
34005bb0:	6a3b      	ldr	r3, [r7, #32]
34005bb2:	f003 021f 	and.w	r2, r3, #31
34005bb6:	4613      	mov	r3, r2
34005bb8:	011b      	lsls	r3, r3, #4
34005bba:	4413      	add	r3, r2
34005bbc:	015a      	lsls	r2, r3, #5
34005bbe:	1ad3      	subs	r3, r2, r3
34005bc0:	3317      	adds	r3, #23
34005bc2:	099b      	lsrs	r3, r3, #6
34005bc4:	430b      	orrs	r3, r1
34005bc6:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34005bca:	613b      	str	r3, [r7, #16]
34005bcc:	e037      	b.n	34005c3e <bsp_lcd_fill_buffer+0xda>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_ARGB4444)
34005bce:	4b2f      	ldr	r3, [pc, #188]	@ (34005c8c <bsp_lcd_fill_buffer+0x128>)
34005bd0:	68db      	ldr	r3, [r3, #12]
34005bd2:	2b04      	cmp	r3, #4
34005bd4:	d124      	bne.n	34005c20 <bsp_lcd_fill_buffer+0xbc>
    {
        output_color_mode = DMA2D_OUTPUT_ARGB4444;
34005bd6:	2304      	movs	r3, #4
34005bd8:	617b      	str	r3, [r7, #20]
        input_color = CONVERTARGB44442ARGB8888(color);
34005bda:	6a3b      	ldr	r3, [r7, #32]
34005bdc:	0b1b      	lsrs	r3, r3, #12
34005bde:	f003 020f 	and.w	r2, r3, #15
34005be2:	4613      	mov	r3, r2
34005be4:	011b      	lsls	r3, r3, #4
34005be6:	4413      	add	r3, r2
34005be8:	0619      	lsls	r1, r3, #24
34005bea:	6a3b      	ldr	r3, [r7, #32]
34005bec:	0a1b      	lsrs	r3, r3, #8
34005bee:	f003 020f 	and.w	r2, r3, #15
34005bf2:	4613      	mov	r3, r2
34005bf4:	011b      	lsls	r3, r3, #4
34005bf6:	4413      	add	r3, r2
34005bf8:	041b      	lsls	r3, r3, #16
34005bfa:	4319      	orrs	r1, r3
34005bfc:	6a3b      	ldr	r3, [r7, #32]
34005bfe:	091b      	lsrs	r3, r3, #4
34005c00:	f003 020f 	and.w	r2, r3, #15
34005c04:	4613      	mov	r3, r2
34005c06:	011b      	lsls	r3, r3, #4
34005c08:	4413      	add	r3, r2
34005c0a:	021b      	lsls	r3, r3, #8
34005c0c:	4319      	orrs	r1, r3
34005c0e:	6a3b      	ldr	r3, [r7, #32]
34005c10:	f003 020f 	and.w	r2, r3, #15
34005c14:	4613      	mov	r3, r2
34005c16:	011b      	lsls	r3, r3, #4
34005c18:	4413      	add	r3, r2
34005c1a:	430b      	orrs	r3, r1
34005c1c:	613b      	str	r3, [r7, #16]
34005c1e:	e00e      	b.n	34005c3e <bsp_lcd_fill_buffer+0xda>
    }
    else if (bsp_lcd.pixel_format == LCD_PIXEL_FORMAT_RGB888)
34005c20:	4b1a      	ldr	r3, [pc, #104]	@ (34005c8c <bsp_lcd_fill_buffer+0x128>)
34005c22:	68db      	ldr	r3, [r3, #12]
34005c24:	2b01      	cmp	r3, #1
34005c26:	d106      	bne.n	34005c36 <bsp_lcd_fill_buffer+0xd2>
    {
        output_color_mode = DMA2D_OUTPUT_RGB888;
34005c28:	2301      	movs	r3, #1
34005c2a:	617b      	str	r3, [r7, #20]
        input_color = CONVERTRGB8882ARGB8888(color);
34005c2c:	6a3b      	ldr	r3, [r7, #32]
34005c2e:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34005c32:	613b      	str	r3, [r7, #16]
34005c34:	e003      	b.n	34005c3e <bsp_lcd_fill_buffer+0xda>
    }
    else
    {
        output_color_mode = DMA2D_OUTPUT_ARGB8888;
34005c36:	2300      	movs	r3, #0
34005c38:	617b      	str	r3, [r7, #20]
        input_color = color;
34005c3a:	6a3b      	ldr	r3, [r7, #32]
34005c3c:	613b      	str	r3, [r7, #16]
    }

    hdma2d.Instance = DMA2D;
34005c3e:	4b14      	ldr	r3, [pc, #80]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c40:	4a14      	ldr	r2, [pc, #80]	@ (34005c94 <bsp_lcd_fill_buffer+0x130>)
34005c42:	601a      	str	r2, [r3, #0]
    hdma2d.Init.Mode = DMA2D_R2M;
34005c44:	4b12      	ldr	r3, [pc, #72]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c46:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34005c4a:	605a      	str	r2, [r3, #4]
    hdma2d.Init.ColorMode = output_color_mode;
34005c4c:	4a10      	ldr	r2, [pc, #64]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c4e:	697b      	ldr	r3, [r7, #20]
34005c50:	6093      	str	r3, [r2, #8]
    hdma2d.Init.OutputOffset = offset;
34005c52:	4a0f      	ldr	r2, [pc, #60]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c54:	683b      	ldr	r3, [r7, #0]
34005c56:	60d3      	str	r3, [r2, #12]
    if (HAL_DMA2D_Init(&hdma2d) == HAL_OK)
34005c58:	480d      	ldr	r0, [pc, #52]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c5a:	f004 fc05 	bl	3400a468 <HAL_DMA2D_Init>
34005c5e:	4603      	mov	r3, r0
34005c60:	2b00      	cmp	r3, #0
34005c62:	d10e      	bne.n	34005c82 <bsp_lcd_fill_buffer+0x11e>
    {
        if (HAL_DMA2D_Start(&hdma2d, input_color, (uint32_t)destination, x_size, y_size) == HAL_OK)
34005c64:	68fa      	ldr	r2, [r7, #12]
34005c66:	687b      	ldr	r3, [r7, #4]
34005c68:	9300      	str	r3, [sp, #0]
34005c6a:	68bb      	ldr	r3, [r7, #8]
34005c6c:	6939      	ldr	r1, [r7, #16]
34005c6e:	4808      	ldr	r0, [pc, #32]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c70:	f004 fc5b 	bl	3400a52a <HAL_DMA2D_Start>
34005c74:	4603      	mov	r3, r0
34005c76:	2b00      	cmp	r3, #0
34005c78:	d103      	bne.n	34005c82 <bsp_lcd_fill_buffer+0x11e>
        {
            HAL_DMA2D_PollForTransfer(&hdma2d, 50);
34005c7a:	2132      	movs	r1, #50	@ 0x32
34005c7c:	4804      	ldr	r0, [pc, #16]	@ (34005c90 <bsp_lcd_fill_buffer+0x12c>)
34005c7e:	f004 fc7f 	bl	3400a580 <HAL_DMA2D_PollForTransfer>
        }
    }
}
34005c82:	bf00      	nop
34005c84:	3718      	adds	r7, #24
34005c86:	46bd      	mov	sp, r7
34005c88:	bd80      	pop	{r7, pc}
34005c8a:	bf00      	nop
34005c8c:	3404a1dc 	.word	0x3404a1dc
34005c90:	34048de4 	.word	0x34048de4
34005c94:	58021000 	.word	0x58021000

34005c98 <NORFlash_Init>:
#include "norflash_mx25um25645g.h"

#define NORFlash_IS_DUAL_CHIP(NORFlashObject) (NORFlashObject->XSPIObject.XSPIHandle->Init.MemoryMode != HAL_XSPI_SINGLE_MEM)

NORFlash_StatusTypeDef NORFlash_Init(NORFlash_ObjectTypeDef *NORFlashObject, XSPI_HandleTypeDef *hxspi, uint32_t ClockInput)
{
34005c98:	b580      	push	{r7, lr}
34005c9a:	b088      	sub	sp, #32
34005c9c:	af00      	add	r7, sp, #0
34005c9e:	60f8      	str	r0, [r7, #12]
34005ca0:	60b9      	str	r1, [r7, #8]
34005ca2:	607a      	str	r2, [r7, #4]
    uint8_t JEDECID[3 * 2];
    uint8_t JEDECIDSize = sizeof(JEDECID) / 2;
34005ca4:	2303      	movs	r3, #3
34005ca6:	77fb      	strb	r3, [r7, #31]
    uint32_t ClockRequested;

    NORFlash_XSPI_Init(&(NORFlashObject->XSPIObject), hxspi);
34005ca8:	68fb      	ldr	r3, [r7, #12]
34005caa:	68b9      	ldr	r1, [r7, #8]
34005cac:	4618      	mov	r0, r3
34005cae:	f000 fb13 	bl	340062d8 <NORFlash_XSPI_Init>

    if (NORFlash_IS_DUAL_CHIP(NORFlashObject))
34005cb2:	68fb      	ldr	r3, [r7, #12]
34005cb4:	681b      	ldr	r3, [r3, #0]
34005cb6:	689b      	ldr	r3, [r3, #8]
34005cb8:	2b00      	cmp	r3, #0
34005cba:	d002      	beq.n	34005cc2 <NORFlash_Init+0x2a>
    {
        JEDECIDSize *= 2;
34005cbc:	7ffb      	ldrb	r3, [r7, #31]
34005cbe:	005b      	lsls	r3, r3, #1
34005cc0:	77fb      	strb	r3, [r7, #31]
    }

    if (NORFlash_XSPI_SetClock(&(NORFlashObject->XSPIObject), ClockInput, 50000000, NULL) != NORFlash_XSPI_OK)
34005cc2:	68f8      	ldr	r0, [r7, #12]
34005cc4:	2300      	movs	r3, #0
34005cc6:	4a3a      	ldr	r2, [pc, #232]	@ (34005db0 <NORFlash_Init+0x118>)
34005cc8:	6879      	ldr	r1, [r7, #4]
34005cca:	f000 fb4c 	bl	34006366 <NORFlash_XSPI_SetClock>
34005cce:	4603      	mov	r3, r0
34005cd0:	2b00      	cmp	r3, #0
34005cd2:	d15f      	bne.n	34005d94 <NORFlash_Init+0xfc>
    {
        goto Error;
    }

    NORFlash_Reset(NORFlashObject);
34005cd4:	68f8      	ldr	r0, [r7, #12]
34005cd6:	f000 f86d 	bl	34005db4 <NORFlash_Reset>
    HAL_Delay(10);
34005cda:	200a      	movs	r0, #10
34005cdc:	f7fe ffae 	bl	34004c3c <HAL_Delay>

    if (NORFlash_XSPI_CommandRead(&(NORFlashObject->XSPIObject), 0x9F, JEDECID, JEDECIDSize) != NORFlash_XSPI_OK)
34005ce0:	68f8      	ldr	r0, [r7, #12]
34005ce2:	7ffb      	ldrb	r3, [r7, #31]
34005ce4:	b29b      	uxth	r3, r3
34005ce6:	f107 0218 	add.w	r2, r7, #24
34005cea:	219f      	movs	r1, #159	@ 0x9f
34005cec:	f000 fcbc 	bl	34006668 <NORFlash_XSPI_CommandRead>
34005cf0:	4603      	mov	r3, r0
34005cf2:	2b00      	cmp	r3, #0
34005cf4:	d150      	bne.n	34005d98 <NORFlash_Init+0x100>
    {
        goto Error;
    }

    if (NORFlash_IS_BY25FQ128EL(JEDECID))
34005cf6:	7e3b      	ldrb	r3, [r7, #24]
34005cf8:	2b68      	cmp	r3, #104	@ 0x68
34005cfa:	d110      	bne.n	34005d1e <NORFlash_Init+0x86>
34005cfc:	7e7b      	ldrb	r3, [r7, #25]
34005cfe:	2b60      	cmp	r3, #96	@ 0x60
34005d00:	d10d      	bne.n	34005d1e <NORFlash_Init+0x86>
34005d02:	7ebb      	ldrb	r3, [r7, #26]
34005d04:	2b18      	cmp	r3, #24
34005d06:	d10a      	bne.n	34005d1e <NORFlash_Init+0x86>
    {
        if (NORFlash_BY25FQ128EL_Init(NORFlashObject, ClockInput, &ClockRequested) != NORFlash_OK)
34005d08:	f107 0314 	add.w	r3, r7, #20
34005d0c:	461a      	mov	r2, r3
34005d0e:	6879      	ldr	r1, [r7, #4]
34005d10:	68f8      	ldr	r0, [r7, #12]
34005d12:	f000 fa49 	bl	340061a8 <NORFlash_BY25FQ128EL_Init>
34005d16:	4603      	mov	r3, r0
34005d18:	2b00      	cmp	r3, #0
34005d1a:	d030      	beq.n	34005d7e <NORFlash_Init+0xe6>
        {
            goto Error;
34005d1c:	e043      	b.n	34005da6 <NORFlash_Init+0x10e>
        }
    }
    else if (NORFlash_IS_DUAL_BY25FQ128EL(JEDECID))
34005d1e:	7e3b      	ldrb	r3, [r7, #24]
34005d20:	2b68      	cmp	r3, #104	@ 0x68
34005d22:	d119      	bne.n	34005d58 <NORFlash_Init+0xc0>
34005d24:	7ebb      	ldrb	r3, [r7, #26]
34005d26:	2b60      	cmp	r3, #96	@ 0x60
34005d28:	d116      	bne.n	34005d58 <NORFlash_Init+0xc0>
34005d2a:	7f3b      	ldrb	r3, [r7, #28]
34005d2c:	2b18      	cmp	r3, #24
34005d2e:	d113      	bne.n	34005d58 <NORFlash_Init+0xc0>
34005d30:	7e7b      	ldrb	r3, [r7, #25]
34005d32:	2b68      	cmp	r3, #104	@ 0x68
34005d34:	d110      	bne.n	34005d58 <NORFlash_Init+0xc0>
34005d36:	7efb      	ldrb	r3, [r7, #27]
34005d38:	2b60      	cmp	r3, #96	@ 0x60
34005d3a:	d10d      	bne.n	34005d58 <NORFlash_Init+0xc0>
34005d3c:	7f7b      	ldrb	r3, [r7, #29]
34005d3e:	2b18      	cmp	r3, #24
34005d40:	d10a      	bne.n	34005d58 <NORFlash_Init+0xc0>
    {
        if (NORFlash_DUAL_BY25FQ128EL_Init(NORFlashObject, ClockInput, &ClockRequested) != NORFlash_OK)
34005d42:	f107 0314 	add.w	r3, r7, #20
34005d46:	461a      	mov	r2, r3
34005d48:	6879      	ldr	r1, [r7, #4]
34005d4a:	68f8      	ldr	r0, [r7, #12]
34005d4c:	f000 fa3d 	bl	340061ca <NORFlash_DUAL_BY25FQ128EL_Init>
34005d50:	4603      	mov	r3, r0
34005d52:	2b00      	cmp	r3, #0
34005d54:	d013      	beq.n	34005d7e <NORFlash_Init+0xe6>
        {
            goto Error;
34005d56:	e026      	b.n	34005da6 <NORFlash_Init+0x10e>
        }
    }
    else if (NORFlash_IS_MX25UM25645G(JEDECID))
34005d58:	7e3b      	ldrb	r3, [r7, #24]
34005d5a:	2bc2      	cmp	r3, #194	@ 0xc2
34005d5c:	d11e      	bne.n	34005d9c <NORFlash_Init+0x104>
34005d5e:	7e7b      	ldrb	r3, [r7, #25]
34005d60:	2b80      	cmp	r3, #128	@ 0x80
34005d62:	d11b      	bne.n	34005d9c <NORFlash_Init+0x104>
34005d64:	7ebb      	ldrb	r3, [r7, #26]
34005d66:	2b39      	cmp	r3, #57	@ 0x39
34005d68:	d118      	bne.n	34005d9c <NORFlash_Init+0x104>
    {
        if (NORFlash_MX25UM25645G_Init(NORFlashObject, ClockInput, &ClockRequested) != NORFlash_OK)
34005d6a:	f107 0314 	add.w	r3, r7, #20
34005d6e:	461a      	mov	r2, r3
34005d70:	6879      	ldr	r1, [r7, #4]
34005d72:	68f8      	ldr	r0, [r7, #12]
34005d74:	f000 fa3a 	bl	340061ec <NORFlash_MX25UM25645G_Init>
34005d78:	4603      	mov	r3, r0
34005d7a:	2b00      	cmp	r3, #0
34005d7c:	d110      	bne.n	34005da0 <NORFlash_Init+0x108>
    else
    {
        goto Error;
    }

    if (NORFlash_XSPI_SetClock(&(NORFlashObject->XSPIObject), ClockInput, ClockRequested, NULL) != NORFlash_XSPI_OK)
34005d7e:	68f8      	ldr	r0, [r7, #12]
34005d80:	697a      	ldr	r2, [r7, #20]
34005d82:	2300      	movs	r3, #0
34005d84:	6879      	ldr	r1, [r7, #4]
34005d86:	f000 faee 	bl	34006366 <NORFlash_XSPI_SetClock>
34005d8a:	4603      	mov	r3, r0
34005d8c:	2b00      	cmp	r3, #0
34005d8e:	d109      	bne.n	34005da4 <NORFlash_Init+0x10c>
    {
        goto Error;
    }

    return NORFlash_OK;
34005d90:	2300      	movs	r3, #0
34005d92:	e009      	b.n	34005da8 <NORFlash_Init+0x110>
        goto Error;
34005d94:	bf00      	nop
34005d96:	e006      	b.n	34005da6 <NORFlash_Init+0x10e>
        goto Error;
34005d98:	bf00      	nop
34005d9a:	e004      	b.n	34005da6 <NORFlash_Init+0x10e>
        goto Error;
34005d9c:	bf00      	nop
34005d9e:	e002      	b.n	34005da6 <NORFlash_Init+0x10e>
            goto Error;
34005da0:	bf00      	nop
34005da2:	e000      	b.n	34005da6 <NORFlash_Init+0x10e>
        goto Error;
34005da4:	bf00      	nop

Error:
    return NORFlash_ERROR;
34005da6:	2301      	movs	r3, #1
}
34005da8:	4618      	mov	r0, r3
34005daa:	3720      	adds	r7, #32
34005dac:	46bd      	mov	sp, r7
34005dae:	bd80      	pop	{r7, pc}
34005db0:	02faf080 	.word	0x02faf080

34005db4 <NORFlash_Reset>:

    return NORFlash_OK;
}

void NORFlash_Reset(NORFlash_ObjectTypeDef *NORFlashObject)
{
34005db4:	b580      	push	{r7, lr}
34005db6:	b084      	sub	sp, #16
34005db8:	af00      	add	r7, sp, #0
34005dba:	6078      	str	r0, [r7, #4]
    uint8_t index;
    NORFlash_XSPI_PhysicalLinkTypeDef PhyLinkTable[] = {
34005dbc:	4a18      	ldr	r2, [pc, #96]	@ (34005e20 <NORFlash_Reset+0x6c>)
34005dbe:	f107 030c 	add.w	r3, r7, #12
34005dc2:	6812      	ldr	r2, [r2, #0]
34005dc4:	4611      	mov	r1, r2
34005dc6:	8019      	strh	r1, [r3, #0]
34005dc8:	3302      	adds	r3, #2
34005dca:	0c12      	lsrs	r2, r2, #16
34005dcc:	701a      	strb	r2, [r3, #0]
        NORFlash_PHY_LINK_1S1S1S,
        NORFlash_PHY_LINK_4S4S4S,
        NORFlash_PHY_LINK_8D8D8D,
    };

    for (index = 0; index < (sizeof(PhyLinkTable) / sizeof(NORFlash_XSPI_PhysicalLinkTypeDef)); index++)
34005dce:	2300      	movs	r3, #0
34005dd0:	73fb      	strb	r3, [r7, #15]
34005dd2:	e018      	b.n	34005e06 <NORFlash_Reset+0x52>
    {
        NORFlash_XSPI_ConfigPHYLink(&(NORFlashObject->XSPIObject), PhyLinkTable[index]);
34005dd4:	687a      	ldr	r2, [r7, #4]
34005dd6:	7bfb      	ldrb	r3, [r7, #15]
34005dd8:	3310      	adds	r3, #16
34005dda:	443b      	add	r3, r7
34005ddc:	f813 3c04 	ldrb.w	r3, [r3, #-4]
34005de0:	4619      	mov	r1, r3
34005de2:	4610      	mov	r0, r2
34005de4:	f000 fb67 	bl	340064b6 <NORFlash_XSPI_ConfigPHYLink>

        NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0x66, NULL, 0);
34005de8:	6878      	ldr	r0, [r7, #4]
34005dea:	2300      	movs	r3, #0
34005dec:	2200      	movs	r2, #0
34005dee:	2166      	movs	r1, #102	@ 0x66
34005df0:	f000 fbe8 	bl	340065c4 <NORFlash_XSPI_CommandSendData>
        NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0x99, NULL, 0);
34005df4:	6878      	ldr	r0, [r7, #4]
34005df6:	2300      	movs	r3, #0
34005df8:	2200      	movs	r2, #0
34005dfa:	2199      	movs	r1, #153	@ 0x99
34005dfc:	f000 fbe2 	bl	340065c4 <NORFlash_XSPI_CommandSendData>
    for (index = 0; index < (sizeof(PhyLinkTable) / sizeof(NORFlash_XSPI_PhysicalLinkTypeDef)); index++)
34005e00:	7bfb      	ldrb	r3, [r7, #15]
34005e02:	3301      	adds	r3, #1
34005e04:	73fb      	strb	r3, [r7, #15]
34005e06:	7bfb      	ldrb	r3, [r7, #15]
34005e08:	2b02      	cmp	r3, #2
34005e0a:	d9e3      	bls.n	34005dd4 <NORFlash_Reset+0x20>
    }

    NORFlash_XSPI_ConfigPHYLink(&(NORFlashObject->XSPIObject), NORFlash_PHY_LINK_1S1S1S);
34005e0c:	687b      	ldr	r3, [r7, #4]
34005e0e:	2100      	movs	r1, #0
34005e10:	4618      	mov	r0, r3
34005e12:	f000 fb50 	bl	340064b6 <NORFlash_XSPI_ConfigPHYLink>
}
34005e16:	bf00      	nop
34005e18:	3710      	adds	r7, #16
34005e1a:	46bd      	mov	sp, r7
34005e1c:	bd80      	pop	{r7, pc}
34005e1e:	bf00      	nop
34005e20:	3402a210 	.word	0x3402a210

34005e24 <NORFlash_WaitBusy>:

NORFlash_StatusTypeDef NORFlash_WaitBusy(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t Timeout)
{
34005e24:	b580      	push	{r7, lr}
34005e26:	b086      	sub	sp, #24
34005e28:	af02      	add	r7, sp, #8
34005e2a:	6078      	str	r0, [r7, #4]
34005e2c:	6039      	str	r1, [r7, #0]
    uint16_t MatchValue = 0 << 0;
34005e2e:	2300      	movs	r3, #0
34005e30:	81fb      	strh	r3, [r7, #14]
    uint16_t MatchMask = 1 << 0;
34005e32:	2301      	movs	r3, #1
34005e34:	81bb      	strh	r3, [r7, #12]
    uint8_t DataSize = 1;
34005e36:	2301      	movs	r3, #1
34005e38:	72fb      	strb	r3, [r7, #11]

    if (NORFlash_IS_DUAL_CHIP(NORFlashObject))
34005e3a:	687b      	ldr	r3, [r7, #4]
34005e3c:	681b      	ldr	r3, [r3, #0]
34005e3e:	689b      	ldr	r3, [r3, #8]
34005e40:	2b00      	cmp	r3, #0
34005e42:	d014      	beq.n	34005e6e <NORFlash_WaitBusy+0x4a>
    {
        MatchValue |= (MatchValue << 8);
34005e44:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34005e48:	021b      	lsls	r3, r3, #8
34005e4a:	b21a      	sxth	r2, r3
34005e4c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34005e50:	4313      	orrs	r3, r2
34005e52:	b21b      	sxth	r3, r3
34005e54:	81fb      	strh	r3, [r7, #14]
        MatchMask |= (MatchMask << 8);
34005e56:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
34005e5a:	021b      	lsls	r3, r3, #8
34005e5c:	b21a      	sxth	r2, r3
34005e5e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
34005e62:	4313      	orrs	r3, r2
34005e64:	b21b      	sxth	r3, r3
34005e66:	81bb      	strh	r3, [r7, #12]
        DataSize *= 2;
34005e68:	7afb      	ldrb	r3, [r7, #11]
34005e6a:	005b      	lsls	r3, r3, #1
34005e6c:	72fb      	strb	r3, [r7, #11]
    }
    if (NORFlash_XSPI_WaitStatusRegister(&(NORFlashObject->XSPIObject), 0x05, MatchValue, MatchMask,DataSize, Timeout) != NORFlash_XSPI_OK)
34005e6e:	6878      	ldr	r0, [r7, #4]
34005e70:	89b9      	ldrh	r1, [r7, #12]
34005e72:	89fa      	ldrh	r2, [r7, #14]
34005e74:	683b      	ldr	r3, [r7, #0]
34005e76:	9301      	str	r3, [sp, #4]
34005e78:	7afb      	ldrb	r3, [r7, #11]
34005e7a:	9300      	str	r3, [sp, #0]
34005e7c:	460b      	mov	r3, r1
34005e7e:	2105      	movs	r1, #5
34005e80:	f000 fcf0 	bl	34006864 <NORFlash_XSPI_WaitStatusRegister>
34005e84:	4603      	mov	r3, r0
34005e86:	2b00      	cmp	r3, #0
34005e88:	d101      	bne.n	34005e8e <NORFlash_WaitBusy+0x6a>
    {
        goto Error;
    }

    return NORFlash_OK;
34005e8a:	2300      	movs	r3, #0
34005e8c:	e001      	b.n	34005e92 <NORFlash_WaitBusy+0x6e>
        goto Error;
34005e8e:	bf00      	nop

Error:
    return NORFlash_ERROR;
34005e90:	2301      	movs	r3, #1
}
34005e92:	4618      	mov	r0, r3
34005e94:	3710      	adds	r7, #16
34005e96:	46bd      	mov	sp, r7
34005e98:	bd80      	pop	{r7, pc}

34005e9a <NORFlash_EnableWrite>:

NORFlash_StatusTypeDef NORFlash_EnableWrite(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t Timeout)
{
34005e9a:	b580      	push	{r7, lr}
34005e9c:	b086      	sub	sp, #24
34005e9e:	af02      	add	r7, sp, #8
34005ea0:	6078      	str	r0, [r7, #4]
34005ea2:	6039      	str	r1, [r7, #0]
    uint16_t MatchValue = 1 << 1;
34005ea4:	2302      	movs	r3, #2
34005ea6:	81fb      	strh	r3, [r7, #14]
    uint16_t MatchMask = 1 << 1;
34005ea8:	2302      	movs	r3, #2
34005eaa:	81bb      	strh	r3, [r7, #12]
    uint8_t DataSize = 1;
34005eac:	2301      	movs	r3, #1
34005eae:	72fb      	strb	r3, [r7, #11]

    if (NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0x06, NULL, 0) != NORFlash_XSPI_OK)
34005eb0:	6878      	ldr	r0, [r7, #4]
34005eb2:	2300      	movs	r3, #0
34005eb4:	2200      	movs	r2, #0
34005eb6:	2106      	movs	r1, #6
34005eb8:	f000 fb84 	bl	340065c4 <NORFlash_XSPI_CommandSendData>
34005ebc:	4603      	mov	r3, r0
34005ebe:	2b00      	cmp	r3, #0
34005ec0:	d129      	bne.n	34005f16 <NORFlash_EnableWrite+0x7c>
    {
        goto Error;
    }

    if (NORFlash_IS_DUAL_CHIP(NORFlashObject))
34005ec2:	687b      	ldr	r3, [r7, #4]
34005ec4:	681b      	ldr	r3, [r3, #0]
34005ec6:	689b      	ldr	r3, [r3, #8]
34005ec8:	2b00      	cmp	r3, #0
34005eca:	d014      	beq.n	34005ef6 <NORFlash_EnableWrite+0x5c>
    {
        MatchValue |= (MatchValue << 8);
34005ecc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34005ed0:	021b      	lsls	r3, r3, #8
34005ed2:	b21a      	sxth	r2, r3
34005ed4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
34005ed8:	4313      	orrs	r3, r2
34005eda:	b21b      	sxth	r3, r3
34005edc:	81fb      	strh	r3, [r7, #14]
        MatchMask |= (MatchMask << 8);
34005ede:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
34005ee2:	021b      	lsls	r3, r3, #8
34005ee4:	b21a      	sxth	r2, r3
34005ee6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
34005eea:	4313      	orrs	r3, r2
34005eec:	b21b      	sxth	r3, r3
34005eee:	81bb      	strh	r3, [r7, #12]
        DataSize *= 2;
34005ef0:	7afb      	ldrb	r3, [r7, #11]
34005ef2:	005b      	lsls	r3, r3, #1
34005ef4:	72fb      	strb	r3, [r7, #11]
    }
    if (NORFlash_XSPI_WaitStatusRegister(&(NORFlashObject->XSPIObject), 0x05, MatchValue, MatchMask, DataSize, Timeout) != NORFlash_XSPI_OK)
34005ef6:	6878      	ldr	r0, [r7, #4]
34005ef8:	89b9      	ldrh	r1, [r7, #12]
34005efa:	89fa      	ldrh	r2, [r7, #14]
34005efc:	683b      	ldr	r3, [r7, #0]
34005efe:	9301      	str	r3, [sp, #4]
34005f00:	7afb      	ldrb	r3, [r7, #11]
34005f02:	9300      	str	r3, [sp, #0]
34005f04:	460b      	mov	r3, r1
34005f06:	2105      	movs	r1, #5
34005f08:	f000 fcac 	bl	34006864 <NORFlash_XSPI_WaitStatusRegister>
34005f0c:	4603      	mov	r3, r0
34005f0e:	2b00      	cmp	r3, #0
34005f10:	d103      	bne.n	34005f1a <NORFlash_EnableWrite+0x80>
    {
        goto Error;
    }

    return NORFlash_OK;
34005f12:	2300      	movs	r3, #0
34005f14:	e003      	b.n	34005f1e <NORFlash_EnableWrite+0x84>
        goto Error;
34005f16:	bf00      	nop
34005f18:	e000      	b.n	34005f1c <NORFlash_EnableWrite+0x82>
        goto Error;
34005f1a:	bf00      	nop

Error:
    return NORFlash_ERROR;
34005f1c:	2301      	movs	r3, #1
}
34005f1e:	4618      	mov	r0, r3
34005f20:	3710      	adds	r7, #16
34005f22:	46bd      	mov	sp, r7
34005f24:	bd80      	pop	{r7, pc}

34005f26 <NORFlash_EnableMemoryMappedMode>:

NORFlash_StatusTypeDef NORFlash_EnableMemoryMappedMode(NORFlash_ObjectTypeDef *NORFlashObject)
{
34005f26:	b590      	push	{r4, r7, lr}
34005f28:	b085      	sub	sp, #20
34005f2a:	af02      	add	r7, sp, #8
34005f2c:	6078      	str	r0, [r7, #4]
    if (NORFlash_XSPI_EnableMapMode(&(NORFlashObject->XSPIObject), NORFlashObject->Command.MapRead.Command, NORFlashObject->Command.MapRead.Dummy, NORFlashObject->Command.MapWrite.Command, NORFlashObject->Command.MapWrite.Dummy) != NORFlash_XSPI_OK)
34005f2e:	6878      	ldr	r0, [r7, #4]
34005f30:	687b      	ldr	r3, [r7, #4]
34005f32:	f893 106c 	ldrb.w	r1, [r3, #108]	@ 0x6c
34005f36:	687b      	ldr	r3, [r7, #4]
34005f38:	f893 206d 	ldrb.w	r2, [r3, #109]	@ 0x6d
34005f3c:	687b      	ldr	r3, [r7, #4]
34005f3e:	f893 406e 	ldrb.w	r4, [r3, #110]	@ 0x6e
34005f42:	687b      	ldr	r3, [r7, #4]
34005f44:	f893 306f 	ldrb.w	r3, [r3, #111]	@ 0x6f
34005f48:	9300      	str	r3, [sp, #0]
34005f4a:	4623      	mov	r3, r4
34005f4c:	f000 fa3e 	bl	340063cc <NORFlash_XSPI_EnableMapMode>
34005f50:	4603      	mov	r3, r0
34005f52:	2b00      	cmp	r3, #0
34005f54:	d101      	bne.n	34005f5a <NORFlash_EnableMemoryMappedMode+0x34>
    {
        goto Error;
    }

    return NORFlash_OK;
34005f56:	2300      	movs	r3, #0
34005f58:	e001      	b.n	34005f5e <NORFlash_EnableMemoryMappedMode+0x38>
        goto Error;
34005f5a:	bf00      	nop

Error:
    return NORFlash_ERROR;
34005f5c:	2301      	movs	r3, #1
}
34005f5e:	4618      	mov	r0, r3
34005f60:	370c      	adds	r7, #12
34005f62:	46bd      	mov	sp, r7
34005f64:	bd90      	pop	{r4, r7, pc}
	...

34005f68 <BY25FQ128EL_Init>:
#include "norflash_by25fq128el.h"

static NORFlash_StatusTypeDef BY25FQ128EL_Init(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t ClockInput, uint32_t *ClockRequested, uint8_t IsDualChip)
{
34005f68:	b580      	push	{r7, lr}
34005f6a:	b086      	sub	sp, #24
34005f6c:	af00      	add	r7, sp, #0
34005f6e:	60f8      	str	r0, [r7, #12]
34005f70:	60b9      	str	r1, [r7, #8]
34005f72:	607a      	str	r2, [r7, #4]
34005f74:	70fb      	strb	r3, [r7, #3]
    uint8_t Data[2];
    uint8_t DataSize = sizeof(Data) / 2;
34005f76:	2301      	movs	r3, #1
34005f78:	75fb      	strb	r3, [r7, #23]

    NORFlashObject->Information.FlashSize = 0x1000000;
34005f7a:	68fb      	ldr	r3, [r7, #12]
34005f7c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34005f80:	655a      	str	r2, [r3, #84]	@ 0x54
    NORFlashObject->Information.SectorSize = 0x1000;
34005f82:	68fb      	ldr	r3, [r7, #12]
34005f84:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34005f88:	659a      	str	r2, [r3, #88]	@ 0x58
    NORFlashObject->Information.PageSize = 0x100;
34005f8a:	68fb      	ldr	r3, [r7, #12]
34005f8c:	f44f 7280 	mov.w	r2, #256	@ 0x100
34005f90:	65da      	str	r2, [r3, #92]	@ 0x5c
    NORFlashObject->Timing.EraseChip = 60000;
34005f92:	68fb      	ldr	r3, [r7, #12]
34005f94:	f64e 2260 	movw	r2, #60000	@ 0xea60
34005f98:	661a      	str	r2, [r3, #96]	@ 0x60
    NORFlashObject->Timing.EraseSector = 200;
34005f9a:	68fb      	ldr	r3, [r7, #12]
34005f9c:	22c8      	movs	r2, #200	@ 0xc8
34005f9e:	665a      	str	r2, [r3, #100]	@ 0x64
    NORFlashObject->Timing.ProgramPage = 3;
34005fa0:	68fb      	ldr	r3, [r7, #12]
34005fa2:	2203      	movs	r2, #3
34005fa4:	669a      	str	r2, [r3, #104]	@ 0x68
#ifdef CONFIG_NORFLASH_BY25FQ128EL_IN_SPI_MODE
    NORFlashObject->Command.MapRead.Command = 0x03;
    NORFlashObject->Command.MapRead.Dummy = 0;
#else
    NORFlashObject->Command.MapRead.Command = 0x0B;
34005fa6:	68fb      	ldr	r3, [r7, #12]
34005fa8:	220b      	movs	r2, #11
34005faa:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
    NORFlashObject->Command.MapRead.Dummy = 4;
34005fae:	68fb      	ldr	r3, [r7, #12]
34005fb0:	2204      	movs	r2, #4
34005fb2:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
#endif
    NORFlashObject->Command.MapWrite.Command = 0x02;
34005fb6:	68fb      	ldr	r3, [r7, #12]
34005fb8:	2202      	movs	r2, #2
34005fba:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
    NORFlashObject->Command.MapWrite.Dummy = 0;
34005fbe:	68fb      	ldr	r3, [r7, #12]
34005fc0:	2200      	movs	r2, #0
34005fc2:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
    NORFlashObject->Command.ProgramPage.Command = 0x02;
34005fc6:	68fb      	ldr	r3, [r7, #12]
34005fc8:	2202      	movs	r2, #2
34005fca:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
    NORFlashObject->Command.ProgramPage.Dummy = 0;
34005fce:	68fb      	ldr	r3, [r7, #12]
34005fd0:	2200      	movs	r2, #0
34005fd2:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
    NORFlashObject->Command.EraseSector.Command = 0x20;
34005fd6:	68fb      	ldr	r3, [r7, #12]
34005fd8:	2220      	movs	r2, #32
34005fda:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
    NORFlashObject->Command.EraseSector.Dummy = 0;
34005fde:	68fb      	ldr	r3, [r7, #12]
34005fe0:	2200      	movs	r2, #0
34005fe2:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73

    if (IsDualChip)
34005fe6:	78fb      	ldrb	r3, [r7, #3]
34005fe8:	2b00      	cmp	r3, #0
34005fea:	d011      	beq.n	34006010 <BY25FQ128EL_Init+0xa8>
    {
        DataSize *= 2;
34005fec:	7dfb      	ldrb	r3, [r7, #23]
34005fee:	005b      	lsls	r3, r3, #1
34005ff0:	75fb      	strb	r3, [r7, #23]

        NORFlashObject->Information.FlashSize *= 2;
34005ff2:	68fb      	ldr	r3, [r7, #12]
34005ff4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34005ff6:	005a      	lsls	r2, r3, #1
34005ff8:	68fb      	ldr	r3, [r7, #12]
34005ffa:	655a      	str	r2, [r3, #84]	@ 0x54
        NORFlashObject->Information.SectorSize *= 2;
34005ffc:	68fb      	ldr	r3, [r7, #12]
34005ffe:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34006000:	005a      	lsls	r2, r3, #1
34006002:	68fb      	ldr	r3, [r7, #12]
34006004:	659a      	str	r2, [r3, #88]	@ 0x58
        NORFlashObject->Information.PageSize *= 2;
34006006:	68fb      	ldr	r3, [r7, #12]
34006008:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3400600a:	005a      	lsls	r2, r3, #1
3400600c:	68fb      	ldr	r3, [r7, #12]
3400600e:	65da      	str	r2, [r3, #92]	@ 0x5c
    }

#ifndef CONFIG_NORFLASH_BY25FQ128EL_IN_SPI_MODE
    NORFlash_XSPI_CommandRead(&(NORFlashObject->XSPIObject), 0x35, Data, DataSize);
34006010:	68f8      	ldr	r0, [r7, #12]
34006012:	7dfb      	ldrb	r3, [r7, #23]
34006014:	b29b      	uxth	r3, r3
34006016:	f107 0214 	add.w	r2, r7, #20
3400601a:	2135      	movs	r1, #53	@ 0x35
3400601c:	f000 fb24 	bl	34006668 <NORFlash_XSPI_CommandRead>
    if (((Data[0] & (1 << 1)) != (1 << 1)) || (IsDualChip && ((Data[1] & (1 << 1)) != (1 << 1))))
34006020:	7d3b      	ldrb	r3, [r7, #20]
34006022:	f003 0302 	and.w	r3, r3, #2
34006026:	2b00      	cmp	r3, #0
34006028:	d007      	beq.n	3400603a <BY25FQ128EL_Init+0xd2>
3400602a:	78fb      	ldrb	r3, [r7, #3]
3400602c:	2b00      	cmp	r3, #0
3400602e:	d041      	beq.n	340060b4 <BY25FQ128EL_Init+0x14c>
34006030:	7d7b      	ldrb	r3, [r7, #21]
34006032:	f003 0302 	and.w	r3, r3, #2
34006036:	2b00      	cmp	r3, #0
34006038:	d13c      	bne.n	340060b4 <BY25FQ128EL_Init+0x14c>
    {
        Data[0] |= (1 << 1);
3400603a:	7d3b      	ldrb	r3, [r7, #20]
3400603c:	f043 0302 	orr.w	r3, r3, #2
34006040:	b2db      	uxtb	r3, r3
34006042:	753b      	strb	r3, [r7, #20]
        Data[1] |= (1 << 1);
34006044:	7d7b      	ldrb	r3, [r7, #21]
34006046:	f043 0302 	orr.w	r3, r3, #2
3400604a:	b2db      	uxtb	r3, r3
3400604c:	757b      	strb	r3, [r7, #21]

        NORFlash_EnableWrite(NORFlashObject, 1000);
3400604e:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
34006052:	68f8      	ldr	r0, [r7, #12]
34006054:	f7ff ff21 	bl	34005e9a <NORFlash_EnableWrite>

        NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0x31, Data, DataSize);
34006058:	68f8      	ldr	r0, [r7, #12]
3400605a:	7dfb      	ldrb	r3, [r7, #23]
3400605c:	b29b      	uxth	r3, r3
3400605e:	f107 0214 	add.w	r2, r7, #20
34006062:	2131      	movs	r1, #49	@ 0x31
34006064:	f000 faae 	bl	340065c4 <NORFlash_XSPI_CommandSendData>

        NORFlash_WaitBusy(NORFlashObject, 1000);
34006068:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
3400606c:	68f8      	ldr	r0, [r7, #12]
3400606e:	f7ff fed9 	bl	34005e24 <NORFlash_WaitBusy>

        Data[0] &= ~(1 << 1);
34006072:	7d3b      	ldrb	r3, [r7, #20]
34006074:	f023 0302 	bic.w	r3, r3, #2
34006078:	b2db      	uxtb	r3, r3
3400607a:	753b      	strb	r3, [r7, #20]
        Data[1] &= ~(1 << 1);
3400607c:	7d7b      	ldrb	r3, [r7, #21]
3400607e:	f023 0302 	bic.w	r3, r3, #2
34006082:	b2db      	uxtb	r3, r3
34006084:	757b      	strb	r3, [r7, #21]
        NORFlash_XSPI_CommandRead(&(NORFlashObject->XSPIObject), 0x35, Data, DataSize);
34006086:	68f8      	ldr	r0, [r7, #12]
34006088:	7dfb      	ldrb	r3, [r7, #23]
3400608a:	b29b      	uxth	r3, r3
3400608c:	f107 0214 	add.w	r2, r7, #20
34006090:	2135      	movs	r1, #53	@ 0x35
34006092:	f000 fae9 	bl	34006668 <NORFlash_XSPI_CommandRead>
        if (((Data[0] & (1 << 1)) != (1 << 1)) || (IsDualChip && ((Data[1] & (1 << 1)) != (1 << 1))))
34006096:	7d3b      	ldrb	r3, [r7, #20]
34006098:	f003 0302 	and.w	r3, r3, #2
3400609c:	2b00      	cmp	r3, #0
3400609e:	d007      	beq.n	340060b0 <BY25FQ128EL_Init+0x148>
340060a0:	78fb      	ldrb	r3, [r7, #3]
340060a2:	2b00      	cmp	r3, #0
340060a4:	d006      	beq.n	340060b4 <BY25FQ128EL_Init+0x14c>
340060a6:	7d7b      	ldrb	r3, [r7, #21]
340060a8:	f003 0302 	and.w	r3, r3, #2
340060ac:	2b00      	cmp	r3, #0
340060ae:	d101      	bne.n	340060b4 <BY25FQ128EL_Init+0x14c>
        {
            return NORFlash_ERROR;
340060b0:	2301      	movs	r3, #1
340060b2:	e06d      	b.n	34006190 <BY25FQ128EL_Init+0x228>
        }
    }

    if (NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0x38, NULL, 0) != NORFlash_XSPI_OK)
340060b4:	68f8      	ldr	r0, [r7, #12]
340060b6:	2300      	movs	r3, #0
340060b8:	2200      	movs	r2, #0
340060ba:	2138      	movs	r1, #56	@ 0x38
340060bc:	f000 fa82 	bl	340065c4 <NORFlash_XSPI_CommandSendData>
340060c0:	4603      	mov	r3, r0
340060c2:	2b00      	cmp	r3, #0
340060c4:	d001      	beq.n	340060ca <BY25FQ128EL_Init+0x162>
    {
        return NORFlash_ERROR;
340060c6:	2301      	movs	r3, #1
340060c8:	e062      	b.n	34006190 <BY25FQ128EL_Init+0x228>
    }

    NORFlash_XSPI_ConfigPHYLink(&(NORFlashObject->XSPIObject), NORFlash_PHY_LINK_4S4S4S);
340060ca:	68fb      	ldr	r3, [r7, #12]
340060cc:	2101      	movs	r1, #1
340060ce:	4618      	mov	r0, r3
340060d0:	f000 f9f1 	bl	340064b6 <NORFlash_XSPI_ConfigPHYLink>

    Data[0] = 0 << 0;
340060d4:	2300      	movs	r3, #0
340060d6:	753b      	strb	r3, [r7, #20]
    Data[1] = 0 << 0;
340060d8:	2300      	movs	r3, #0
340060da:	757b      	strb	r3, [r7, #21]
    if (ClockInput <= 80000000)
340060dc:	68bb      	ldr	r3, [r7, #8]
340060de:	4a2e      	ldr	r2, [pc, #184]	@ (34006198 <BY25FQ128EL_Init+0x230>)
340060e0:	4293      	cmp	r3, r2
340060e2:	d808      	bhi.n	340060f6 <BY25FQ128EL_Init+0x18e>
    {
        Data[0] |= 0 << 4;
340060e4:	7d3b      	ldrb	r3, [r7, #20]
340060e6:	753b      	strb	r3, [r7, #20]
        Data[1] |= 0 << 4;
340060e8:	7d7b      	ldrb	r3, [r7, #21]
340060ea:	757b      	strb	r3, [r7, #21]
        NORFlashObject->Command.MapRead.Dummy = 4;
340060ec:	68fb      	ldr	r3, [r7, #12]
340060ee:	2204      	movs	r2, #4
340060f0:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
340060f4:	e020      	b.n	34006138 <BY25FQ128EL_Init+0x1d0>
    }
    else if (ClockInput < 133333333)
340060f6:	68bb      	ldr	r3, [r7, #8]
340060f8:	4a28      	ldr	r2, [pc, #160]	@ (3400619c <BY25FQ128EL_Init+0x234>)
340060fa:	4293      	cmp	r3, r2
340060fc:	d80e      	bhi.n	3400611c <BY25FQ128EL_Init+0x1b4>
    {
        Data[0] |= 1 << 4;
340060fe:	7d3b      	ldrb	r3, [r7, #20]
34006100:	f043 0310 	orr.w	r3, r3, #16
34006104:	b2db      	uxtb	r3, r3
34006106:	753b      	strb	r3, [r7, #20]
        Data[1] |= 1 << 4;
34006108:	7d7b      	ldrb	r3, [r7, #21]
3400610a:	f043 0310 	orr.w	r3, r3, #16
3400610e:	b2db      	uxtb	r3, r3
34006110:	757b      	strb	r3, [r7, #21]
        NORFlashObject->Command.MapRead.Dummy = 6;
34006112:	68fb      	ldr	r3, [r7, #12]
34006114:	2206      	movs	r2, #6
34006116:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
3400611a:	e00d      	b.n	34006138 <BY25FQ128EL_Init+0x1d0>
    }
    else
    {
        Data[0] |= 2 << 4;
3400611c:	7d3b      	ldrb	r3, [r7, #20]
3400611e:	f043 0320 	orr.w	r3, r3, #32
34006122:	b2db      	uxtb	r3, r3
34006124:	753b      	strb	r3, [r7, #20]
        Data[1] |= 2 << 4;
34006126:	7d7b      	ldrb	r3, [r7, #21]
34006128:	f043 0320 	orr.w	r3, r3, #32
3400612c:	b2db      	uxtb	r3, r3
3400612e:	757b      	strb	r3, [r7, #21]
        NORFlashObject->Command.MapRead.Dummy = 8;
34006130:	68fb      	ldr	r3, [r7, #12]
34006132:	2208      	movs	r2, #8
34006134:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
    }
    if (NORFlash_XSPI_CommandSendData(&(NORFlashObject->XSPIObject), 0xC0, Data, DataSize) != NORFlash_XSPI_OK)
34006138:	68f8      	ldr	r0, [r7, #12]
3400613a:	7dfb      	ldrb	r3, [r7, #23]
3400613c:	b29b      	uxth	r3, r3
3400613e:	f107 0214 	add.w	r2, r7, #20
34006142:	21c0      	movs	r1, #192	@ 0xc0
34006144:	f000 fa3e 	bl	340065c4 <NORFlash_XSPI_CommandSendData>
34006148:	4603      	mov	r3, r0
3400614a:	2b00      	cmp	r3, #0
3400614c:	d001      	beq.n	34006152 <BY25FQ128EL_Init+0x1ea>
    {
        return NORFlash_ERROR;
3400614e:	2301      	movs	r3, #1
34006150:	e01e      	b.n	34006190 <BY25FQ128EL_Init+0x228>
    }
#endif

    if (ClockRequested != NULL)
34006152:	687b      	ldr	r3, [r7, #4]
34006154:	2b00      	cmp	r3, #0
34006156:	d01a      	beq.n	3400618e <BY25FQ128EL_Init+0x226>
    {
        if (ClockInput <= 80000000)
34006158:	68bb      	ldr	r3, [r7, #8]
3400615a:	4a0f      	ldr	r2, [pc, #60]	@ (34006198 <BY25FQ128EL_Init+0x230>)
3400615c:	4293      	cmp	r3, r2
3400615e:	d803      	bhi.n	34006168 <BY25FQ128EL_Init+0x200>
        {
            *ClockRequested = ClockInput;
34006160:	687b      	ldr	r3, [r7, #4]
34006162:	68ba      	ldr	r2, [r7, #8]
34006164:	601a      	str	r2, [r3, #0]
34006166:	e012      	b.n	3400618e <BY25FQ128EL_Init+0x226>
        }
        else if (ClockInput < 108000000)
34006168:	68bb      	ldr	r3, [r7, #8]
3400616a:	4a0d      	ldr	r2, [pc, #52]	@ (340061a0 <BY25FQ128EL_Init+0x238>)
3400616c:	4293      	cmp	r3, r2
3400616e:	d203      	bcs.n	34006178 <BY25FQ128EL_Init+0x210>
        {
            *ClockRequested = 80000000;
34006170:	687b      	ldr	r3, [r7, #4]
34006172:	4a09      	ldr	r2, [pc, #36]	@ (34006198 <BY25FQ128EL_Init+0x230>)
34006174:	601a      	str	r2, [r3, #0]
34006176:	e00a      	b.n	3400618e <BY25FQ128EL_Init+0x226>
        }
        else if (ClockInput < 133333333)
34006178:	68bb      	ldr	r3, [r7, #8]
3400617a:	4a08      	ldr	r2, [pc, #32]	@ (3400619c <BY25FQ128EL_Init+0x234>)
3400617c:	4293      	cmp	r3, r2
3400617e:	d803      	bhi.n	34006188 <BY25FQ128EL_Init+0x220>
        {
            *ClockRequested = 108000000;
34006180:	687b      	ldr	r3, [r7, #4]
34006182:	4a07      	ldr	r2, [pc, #28]	@ (340061a0 <BY25FQ128EL_Init+0x238>)
34006184:	601a      	str	r2, [r3, #0]
34006186:	e002      	b.n	3400618e <BY25FQ128EL_Init+0x226>
        }
        else
        {
            *ClockRequested = 133333333;
34006188:	687b      	ldr	r3, [r7, #4]
3400618a:	4a06      	ldr	r2, [pc, #24]	@ (340061a4 <BY25FQ128EL_Init+0x23c>)
3400618c:	601a      	str	r2, [r3, #0]
        }
    }

    return NORFlash_OK;
3400618e:	2300      	movs	r3, #0
}
34006190:	4618      	mov	r0, r3
34006192:	3718      	adds	r7, #24
34006194:	46bd      	mov	sp, r7
34006196:	bd80      	pop	{r7, pc}
34006198:	04c4b400 	.word	0x04c4b400
3400619c:	07f28154 	.word	0x07f28154
340061a0:	066ff300 	.word	0x066ff300
340061a4:	07f28155 	.word	0x07f28155

340061a8 <NORFlash_BY25FQ128EL_Init>:

NORFlash_StatusTypeDef NORFlash_BY25FQ128EL_Init(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t ClockInput, uint32_t *ClockRequested)
{
340061a8:	b580      	push	{r7, lr}
340061aa:	b084      	sub	sp, #16
340061ac:	af00      	add	r7, sp, #0
340061ae:	60f8      	str	r0, [r7, #12]
340061b0:	60b9      	str	r1, [r7, #8]
340061b2:	607a      	str	r2, [r7, #4]
    return BY25FQ128EL_Init(NORFlashObject, ClockInput, ClockRequested, 0);
340061b4:	2300      	movs	r3, #0
340061b6:	687a      	ldr	r2, [r7, #4]
340061b8:	68b9      	ldr	r1, [r7, #8]
340061ba:	68f8      	ldr	r0, [r7, #12]
340061bc:	f7ff fed4 	bl	34005f68 <BY25FQ128EL_Init>
340061c0:	4603      	mov	r3, r0
}
340061c2:	4618      	mov	r0, r3
340061c4:	3710      	adds	r7, #16
340061c6:	46bd      	mov	sp, r7
340061c8:	bd80      	pop	{r7, pc}

340061ca <NORFlash_DUAL_BY25FQ128EL_Init>:

NORFlash_StatusTypeDef NORFlash_DUAL_BY25FQ128EL_Init(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t ClockInput, uint32_t *ClockRequested)
{
340061ca:	b580      	push	{r7, lr}
340061cc:	b084      	sub	sp, #16
340061ce:	af00      	add	r7, sp, #0
340061d0:	60f8      	str	r0, [r7, #12]
340061d2:	60b9      	str	r1, [r7, #8]
340061d4:	607a      	str	r2, [r7, #4]
    return BY25FQ128EL_Init(NORFlashObject, ClockInput, ClockRequested, 1);
340061d6:	2301      	movs	r3, #1
340061d8:	687a      	ldr	r2, [r7, #4]
340061da:	68b9      	ldr	r1, [r7, #8]
340061dc:	68f8      	ldr	r0, [r7, #12]
340061de:	f7ff fec3 	bl	34005f68 <BY25FQ128EL_Init>
340061e2:	4603      	mov	r3, r0
}
340061e4:	4618      	mov	r0, r3
340061e6:	3710      	adds	r7, #16
340061e8:	46bd      	mov	sp, r7
340061ea:	bd80      	pop	{r7, pc}

340061ec <NORFlash_MX25UM25645G_Init>:
#include "norflash_mx25um25645g.h"

NORFlash_StatusTypeDef NORFlash_MX25UM25645G_Init(NORFlash_ObjectTypeDef *NORFlashObject, uint32_t ClockInput, uint32_t *ClockRequested)
{
340061ec:	b580      	push	{r7, lr}
340061ee:	b088      	sub	sp, #32
340061f0:	af02      	add	r7, sp, #8
340061f2:	60f8      	str	r0, [r7, #12]
340061f4:	60b9      	str	r1, [r7, #8]
340061f6:	607a      	str	r2, [r7, #4]
    uint8_t Data;

    NORFlashObject->Information.FlashSize = 0x2000000;
340061f8:	68fb      	ldr	r3, [r7, #12]
340061fa:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
340061fe:	655a      	str	r2, [r3, #84]	@ 0x54
    NORFlashObject->Information.SectorSize = 0x1000;
34006200:	68fb      	ldr	r3, [r7, #12]
34006202:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34006206:	659a      	str	r2, [r3, #88]	@ 0x58
    NORFlashObject->Information.PageSize = 0x100;
34006208:	68fb      	ldr	r3, [r7, #12]
3400620a:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400620e:	65da      	str	r2, [r3, #92]	@ 0x5c
    NORFlashObject->Timing.EraseChip = 150000;
34006210:	68fb      	ldr	r3, [r7, #12]
34006212:	4a30      	ldr	r2, [pc, #192]	@ (340062d4 <NORFlash_MX25UM25645G_Init+0xe8>)
34006214:	661a      	str	r2, [r3, #96]	@ 0x60
    NORFlashObject->Timing.EraseSector = 400;
34006216:	68fb      	ldr	r3, [r7, #12]
34006218:	f44f 72c8 	mov.w	r2, #400	@ 0x190
3400621c:	665a      	str	r2, [r3, #100]	@ 0x64
    NORFlashObject->Timing.ProgramPage = 1;
3400621e:	68fb      	ldr	r3, [r7, #12]
34006220:	2201      	movs	r2, #1
34006222:	669a      	str	r2, [r3, #104]	@ 0x68
    NORFlashObject->Command.MapRead.Command = 0xEE;
34006224:	68fb      	ldr	r3, [r7, #12]
34006226:	22ee      	movs	r2, #238	@ 0xee
34006228:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
    NORFlashObject->Command.MapRead.Dummy = 20;
3400622c:	68fb      	ldr	r3, [r7, #12]
3400622e:	2214      	movs	r2, #20
34006230:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
    NORFlashObject->Command.MapWrite.Command = 0x12;
34006234:	68fb      	ldr	r3, [r7, #12]
34006236:	2212      	movs	r2, #18
34006238:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
    NORFlashObject->Command.MapWrite.Dummy = 0;
3400623c:	68fb      	ldr	r3, [r7, #12]
3400623e:	2200      	movs	r2, #0
34006240:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
    NORFlashObject->Command.ProgramPage.Command = 0x12;
34006244:	68fb      	ldr	r3, [r7, #12]
34006246:	2212      	movs	r2, #18
34006248:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
    NORFlashObject->Command.ProgramPage.Dummy = 0;
3400624c:	68fb      	ldr	r3, [r7, #12]
3400624e:	2200      	movs	r2, #0
34006250:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
    NORFlashObject->Command.EraseSector.Command = 0x21;
34006254:	68fb      	ldr	r3, [r7, #12]
34006256:	2221      	movs	r2, #33	@ 0x21
34006258:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
    NORFlashObject->Command.EraseSector.Dummy = 0;
3400625c:	68fb      	ldr	r3, [r7, #12]
3400625e:	2200      	movs	r2, #0
34006260:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73

    NORFlash_XSPI_CommandSendAddressReadData(&(NORFlashObject->XSPIObject), 0x71, 0x00000000, &Data, sizeof(Data));
34006264:	68f8      	ldr	r0, [r7, #12]
34006266:	f107 0317 	add.w	r3, r7, #23
3400626a:	2201      	movs	r2, #1
3400626c:	9200      	str	r2, [sp, #0]
3400626e:	2200      	movs	r2, #0
34006270:	2171      	movs	r1, #113	@ 0x71
34006272:	f000 fa4b 	bl	3400670c <NORFlash_XSPI_CommandSendAddressReadData>
    if ((Data & (3 << 0)) != 0)
34006276:	7dfb      	ldrb	r3, [r7, #23]
34006278:	f003 0303 	and.w	r3, r3, #3
3400627c:	2b00      	cmp	r3, #0
3400627e:	d001      	beq.n	34006284 <NORFlash_MX25UM25645G_Init+0x98>
    {
        return NORFlash_ERROR;
34006280:	2301      	movs	r3, #1
34006282:	e023      	b.n	340062cc <NORFlash_MX25UM25645G_Init+0xe0>
    }

    Data &= ~(3 << 0);
34006284:	7dfb      	ldrb	r3, [r7, #23]
34006286:	f023 0303 	bic.w	r3, r3, #3
3400628a:	b2db      	uxtb	r3, r3
3400628c:	75fb      	strb	r3, [r7, #23]
    Data |= (2 << 0);
3400628e:	7dfb      	ldrb	r3, [r7, #23]
34006290:	f043 0302 	orr.w	r3, r3, #2
34006294:	b2db      	uxtb	r3, r3
34006296:	75fb      	strb	r3, [r7, #23]

    NORFlash_EnableWrite(NORFlashObject, 1000);
34006298:	f44f 717a 	mov.w	r1, #1000	@ 0x3e8
3400629c:	68f8      	ldr	r0, [r7, #12]
3400629e:	f7ff fdfc 	bl	34005e9a <NORFlash_EnableWrite>

    NORFlash_XSPI_CommandSendAddressSendData(&(NORFlashObject->XSPIObject), 0x72, 0x00000000, &Data, sizeof(Data));
340062a2:	68f8      	ldr	r0, [r7, #12]
340062a4:	f107 0317 	add.w	r3, r7, #23
340062a8:	2201      	movs	r2, #1
340062aa:	9200      	str	r2, [sp, #0]
340062ac:	2200      	movs	r2, #0
340062ae:	2172      	movs	r1, #114	@ 0x72
340062b0:	f000 fa82 	bl	340067b8 <NORFlash_XSPI_CommandSendAddressSendData>

    NORFlash_XSPI_ConfigPHYLink(&(NORFlashObject->XSPIObject), NORFlash_PHY_LINK_8D8D8D);
340062b4:	68fb      	ldr	r3, [r7, #12]
340062b6:	2102      	movs	r1, #2
340062b8:	4618      	mov	r0, r3
340062ba:	f000 f8fc 	bl	340064b6 <NORFlash_XSPI_ConfigPHYLink>

    if (ClockRequested != NULL)
340062be:	687b      	ldr	r3, [r7, #4]
340062c0:	2b00      	cmp	r3, #0
340062c2:	d002      	beq.n	340062ca <NORFlash_MX25UM25645G_Init+0xde>
    {
        *ClockRequested = ClockInput;
340062c4:	687b      	ldr	r3, [r7, #4]
340062c6:	68ba      	ldr	r2, [r7, #8]
340062c8:	601a      	str	r2, [r3, #0]
    }

    return NORFlash_OK;
340062ca:	2300      	movs	r3, #0
}
340062cc:	4618      	mov	r0, r3
340062ce:	3718      	adds	r7, #24
340062d0:	46bd      	mov	sp, r7
340062d2:	bd80      	pop	{r7, pc}
340062d4:	000249f0 	.word	0x000249f0

340062d8 <NORFlash_XSPI_Init>:
#include "norflash_xspi.h"

void NORFlash_XSPI_Init(NORFlash_XSPI_ObjectTypeDef *XSPIObject, XSPI_HandleTypeDef *XSPIHandle)
{
340062d8:	b580      	push	{r7, lr}
340062da:	b082      	sub	sp, #8
340062dc:	af00      	add	r7, sp, #0
340062de:	6078      	str	r0, [r7, #4]
340062e0:	6039      	str	r1, [r7, #0]
    XSPIObject->XSPIHandle = XSPIHandle;
340062e2:	687b      	ldr	r3, [r7, #4]
340062e4:	683a      	ldr	r2, [r7, #0]
340062e6:	601a      	str	r2, [r3, #0]
    XSPIObject->BaseCommand.OperationType = HAL_XSPI_OPTYPE_COMMON_CFG;
340062e8:	687b      	ldr	r3, [r7, #4]
340062ea:	2200      	movs	r2, #0
340062ec:	605a      	str	r2, [r3, #4]
    XSPIObject->BaseCommand.IOSelect = HAL_XSPI_SELECT_IO_7_0;
340062ee:	687b      	ldr	r3, [r7, #4]
340062f0:	2200      	movs	r2, #0
340062f2:	609a      	str	r2, [r3, #8]
    XSPIObject->BaseCommand.Instruction = 0;
340062f4:	687b      	ldr	r3, [r7, #4]
340062f6:	2200      	movs	r2, #0
340062f8:	60da      	str	r2, [r3, #12]
    XSPIObject->BaseCommand.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
340062fa:	687b      	ldr	r3, [r7, #4]
340062fc:	2201      	movs	r2, #1
340062fe:	611a      	str	r2, [r3, #16]
    XSPIObject->BaseCommand.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
34006300:	687b      	ldr	r3, [r7, #4]
34006302:	2200      	movs	r2, #0
34006304:	615a      	str	r2, [r3, #20]
    XSPIObject->BaseCommand.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34006306:	687b      	ldr	r3, [r7, #4]
34006308:	2200      	movs	r2, #0
3400630a:	619a      	str	r2, [r3, #24]
    XSPIObject->BaseCommand.Address = 0;
3400630c:	687b      	ldr	r3, [r7, #4]
3400630e:	2200      	movs	r2, #0
34006310:	61da      	str	r2, [r3, #28]
    XSPIObject->BaseCommand.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
34006312:	687b      	ldr	r3, [r7, #4]
34006314:	f44f 7280 	mov.w	r2, #256	@ 0x100
34006318:	621a      	str	r2, [r3, #32]
    XSPIObject->BaseCommand.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
3400631a:	687b      	ldr	r3, [r7, #4]
3400631c:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34006320:	625a      	str	r2, [r3, #36]	@ 0x24
    XSPIObject->BaseCommand.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
34006322:	687b      	ldr	r3, [r7, #4]
34006324:	2200      	movs	r2, #0
34006326:	629a      	str	r2, [r3, #40]	@ 0x28
    XSPIObject->BaseCommand.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
34006328:	687b      	ldr	r3, [r7, #4]
3400632a:	2200      	movs	r2, #0
3400632c:	631a      	str	r2, [r3, #48]	@ 0x30
    XSPIObject->BaseCommand.DataMode = HAL_XSPI_DATA_1_LINE;
3400632e:	687b      	ldr	r3, [r7, #4]
34006330:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34006334:	63da      	str	r2, [r3, #60]	@ 0x3c
    XSPIObject->BaseCommand.DataLength = 0;
34006336:	687b      	ldr	r3, [r7, #4]
34006338:	2200      	movs	r2, #0
3400633a:	641a      	str	r2, [r3, #64]	@ 0x40
    XSPIObject->BaseCommand.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
3400633c:	687b      	ldr	r3, [r7, #4]
3400633e:	2200      	movs	r2, #0
34006340:	645a      	str	r2, [r3, #68]	@ 0x44
    XSPIObject->BaseCommand.DummyCycles = 0;
34006342:	687b      	ldr	r3, [r7, #4]
34006344:	2200      	movs	r2, #0
34006346:	649a      	str	r2, [r3, #72]	@ 0x48
    XSPIObject->BaseCommand.DQSMode = HAL_XSPI_DQS_DISABLE;
34006348:	687b      	ldr	r3, [r7, #4]
3400634a:	2200      	movs	r2, #0
3400634c:	64da      	str	r2, [r3, #76]	@ 0x4c
  __ASM volatile ("dsb 0xF":::"memory");
3400634e:	f3bf 8f4f 	dsb	sy
}
34006352:	bf00      	nop

    __DSB();
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
34006354:	687b      	ldr	r3, [r7, #4]
34006356:	681b      	ldr	r3, [r3, #0]
34006358:	4618      	mov	r0, r3
3400635a:	f012 faa5 	bl	340188a8 <HAL_XSPI_Abort>
}
3400635e:	bf00      	nop
34006360:	3708      	adds	r7, #8
34006362:	46bd      	mov	sp, r7
34006364:	bd80      	pop	{r7, pc}

34006366 <NORFlash_XSPI_SetClock>:
{
    XSPIObject->XSPIHandle = NULL;
}

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_SetClock(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint32_t ClockInput, uint32_t ClockRequested, uint32_t *ClockReal)
{
34006366:	b580      	push	{r7, lr}
34006368:	b086      	sub	sp, #24
3400636a:	af00      	add	r7, sp, #0
3400636c:	60f8      	str	r0, [r7, #12]
3400636e:	60b9      	str	r1, [r7, #8]
34006370:	607a      	str	r2, [r7, #4]
34006372:	603b      	str	r3, [r7, #0]
    uint32_t Divider;
    
    Divider = ClockInput / ClockRequested;
34006374:	68ba      	ldr	r2, [r7, #8]
34006376:	687b      	ldr	r3, [r7, #4]
34006378:	fbb2 f3f3 	udiv	r3, r2, r3
3400637c:	617b      	str	r3, [r7, #20]
    if (Divider >= 1)
3400637e:	697b      	ldr	r3, [r7, #20]
34006380:	2b00      	cmp	r3, #0
34006382:	d009      	beq.n	34006398 <NORFlash_XSPI_SetClock+0x32>
    {
        if ((ClockInput / Divider) <= ClockRequested)
34006384:	68ba      	ldr	r2, [r7, #8]
34006386:	697b      	ldr	r3, [r7, #20]
34006388:	fbb2 f3f3 	udiv	r3, r2, r3
3400638c:	687a      	ldr	r2, [r7, #4]
3400638e:	429a      	cmp	r2, r3
34006390:	d302      	bcc.n	34006398 <NORFlash_XSPI_SetClock+0x32>
        {
            Divider--;
34006392:	697b      	ldr	r3, [r7, #20]
34006394:	3b01      	subs	r3, #1
34006396:	617b      	str	r3, [r7, #20]
        }
    }

    if (HAL_XSPI_SetClockPrescaler(XSPIObject->XSPIHandle, Divider) != HAL_OK)
34006398:	68fb      	ldr	r3, [r7, #12]
3400639a:	681b      	ldr	r3, [r3, #0]
3400639c:	6979      	ldr	r1, [r7, #20]
3400639e:	4618      	mov	r0, r3
340063a0:	f012 fb09 	bl	340189b6 <HAL_XSPI_SetClockPrescaler>
340063a4:	4603      	mov	r3, r0
340063a6:	2b00      	cmp	r3, #0
340063a8:	d001      	beq.n	340063ae <NORFlash_XSPI_SetClock+0x48>
    {
        return NORFlash_XSPI_ERROR;
340063aa:	2301      	movs	r3, #1
340063ac:	e00a      	b.n	340063c4 <NORFlash_XSPI_SetClock+0x5e>
    }

    if (ClockReal != NULL)
340063ae:	683b      	ldr	r3, [r7, #0]
340063b0:	2b00      	cmp	r3, #0
340063b2:	d006      	beq.n	340063c2 <NORFlash_XSPI_SetClock+0x5c>
    {
        *ClockReal = ClockInput / (Divider + 1);
340063b4:	697b      	ldr	r3, [r7, #20]
340063b6:	3301      	adds	r3, #1
340063b8:	68ba      	ldr	r2, [r7, #8]
340063ba:	fbb2 f2f3 	udiv	r2, r2, r3
340063be:	683b      	ldr	r3, [r7, #0]
340063c0:	601a      	str	r2, [r3, #0]
    }

    return NORFlash_XSPI_OK;
340063c2:	2300      	movs	r3, #0
}
340063c4:	4618      	mov	r0, r3
340063c6:	3718      	adds	r7, #24
340063c8:	46bd      	mov	sp, r7
340063ca:	bd80      	pop	{r7, pc}

340063cc <NORFlash_XSPI_EnableMapMode>:

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_EnableMapMode(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t CommandRead, uint8_t DummyRead, uint8_t CommandWrite, uint8_t DummyWrite)
{
340063cc:	b580      	push	{r7, lr}
340063ce:	b09a      	sub	sp, #104	@ 0x68
340063d0:	af00      	add	r7, sp, #0
340063d2:	6078      	str	r0, [r7, #4]
340063d4:	4608      	mov	r0, r1
340063d6:	4611      	mov	r1, r2
340063d8:	461a      	mov	r2, r3
340063da:	4603      	mov	r3, r0
340063dc:	70fb      	strb	r3, [r7, #3]
340063de:	460b      	mov	r3, r1
340063e0:	70bb      	strb	r3, [r7, #2]
340063e2:	4613      	mov	r3, r2
340063e4:	707b      	strb	r3, [r7, #1]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
340063e6:	687b      	ldr	r3, [r7, #4]
340063e8:	f107 001c 	add.w	r0, r7, #28
340063ec:	3304      	adds	r3, #4
340063ee:	224c      	movs	r2, #76	@ 0x4c
340063f0:	4619      	mov	r1, r3
340063f2:	f021 f95e 	bl	340276b2 <memcpy>
    XSPI_MemoryMappedTypeDef Cfg = {0};
340063f6:	f107 030c 	add.w	r3, r7, #12
340063fa:	2200      	movs	r2, #0
340063fc:	601a      	str	r2, [r3, #0]
340063fe:	605a      	str	r2, [r3, #4]
34006400:	609a      	str	r2, [r3, #8]
34006402:	60da      	str	r2, [r3, #12]

    Cmd.OperationType = HAL_XSPI_OPTYPE_READ_CFG;
34006404:	2301      	movs	r3, #1
34006406:	61fb      	str	r3, [r7, #28]
    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)CommandRead << 8) | (uint8_t)(~CommandRead & 0xFF)) : CommandRead;
34006408:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400640a:	2b10      	cmp	r3, #16
3400640c:	d106      	bne.n	3400641c <NORFlash_XSPI_EnableMapMode+0x50>
3400640e:	78fb      	ldrb	r3, [r7, #3]
34006410:	021b      	lsls	r3, r3, #8
34006412:	78fa      	ldrb	r2, [r7, #3]
34006414:	43d2      	mvns	r2, r2
34006416:	b2d2      	uxtb	r2, r2
34006418:	4313      	orrs	r3, r2
3400641a:	e000      	b.n	3400641e <NORFlash_XSPI_EnableMapMode+0x52>
3400641c:	78fb      	ldrb	r3, [r7, #3]
3400641e:	627b      	str	r3, [r7, #36]	@ 0x24
    Cmd.DummyCycles = DummyRead;
34006420:	78bb      	ldrb	r3, [r7, #2]
34006422:	663b      	str	r3, [r7, #96]	@ 0x60
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006424:	687b      	ldr	r3, [r7, #4]
34006426:	681b      	ldr	r3, [r3, #0]
34006428:	f107 011c 	add.w	r1, r7, #28
3400642c:	f241 3288 	movw	r2, #5000	@ 0x1388
34006430:	4618      	mov	r0, r3
34006432:	f011 feed 	bl	34018210 <HAL_XSPI_Command>
34006436:	4603      	mov	r3, r0
34006438:	2b00      	cmp	r3, #0
3400643a:	d12d      	bne.n	34006498 <NORFlash_XSPI_EnableMapMode+0xcc>
    {
        goto Error;
    }

    Cmd.OperationType = HAL_XSPI_OPTYPE_WRITE_CFG;
3400643c:	2302      	movs	r3, #2
3400643e:	61fb      	str	r3, [r7, #28]
    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)CommandWrite << 8) | (uint8_t)(~CommandWrite & 0xFF)) : CommandWrite;
34006440:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34006442:	2b10      	cmp	r3, #16
34006444:	d106      	bne.n	34006454 <NORFlash_XSPI_EnableMapMode+0x88>
34006446:	787b      	ldrb	r3, [r7, #1]
34006448:	021b      	lsls	r3, r3, #8
3400644a:	787a      	ldrb	r2, [r7, #1]
3400644c:	43d2      	mvns	r2, r2
3400644e:	b2d2      	uxtb	r2, r2
34006450:	4313      	orrs	r3, r2
34006452:	e000      	b.n	34006456 <NORFlash_XSPI_EnableMapMode+0x8a>
34006454:	787b      	ldrb	r3, [r7, #1]
34006456:	627b      	str	r3, [r7, #36]	@ 0x24
    Cmd.DummyCycles = DummyWrite;
34006458:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
3400645c:	663b      	str	r3, [r7, #96]	@ 0x60
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
3400645e:	687b      	ldr	r3, [r7, #4]
34006460:	681b      	ldr	r3, [r3, #0]
34006462:	f107 011c 	add.w	r1, r7, #28
34006466:	f241 3288 	movw	r2, #5000	@ 0x1388
3400646a:	4618      	mov	r0, r3
3400646c:	f011 fed0 	bl	34018210 <HAL_XSPI_Command>
34006470:	4603      	mov	r3, r0
34006472:	2b00      	cmp	r3, #0
34006474:	d112      	bne.n	3400649c <NORFlash_XSPI_EnableMapMode+0xd0>
    {
        goto Error;
    }

    Cfg.TimeOutActivation = HAL_XSPI_TIMEOUT_COUNTER_DISABLE;
34006476:	2300      	movs	r3, #0
34006478:	60fb      	str	r3, [r7, #12]
    Cfg.TimeoutPeriodClock = 0x50;
3400647a:	2350      	movs	r3, #80	@ 0x50
3400647c:	613b      	str	r3, [r7, #16]
    if (HAL_XSPI_MemoryMapped(XSPIObject->XSPIHandle, &Cfg) != HAL_OK)
3400647e:	687b      	ldr	r3, [r7, #4]
34006480:	681b      	ldr	r3, [r3, #0]
34006482:	f107 020c 	add.w	r2, r7, #12
34006486:	4611      	mov	r1, r2
34006488:	4618      	mov	r0, r3
3400648a:	f012 f9a1 	bl	340187d0 <HAL_XSPI_MemoryMapped>
3400648e:	4603      	mov	r3, r0
34006490:	2b00      	cmp	r3, #0
34006492:	d105      	bne.n	340064a0 <NORFlash_XSPI_EnableMapMode+0xd4>
    {
        goto Error;
    }

    return NORFlash_XSPI_OK;
34006494:	2300      	movs	r3, #0
34006496:	e00a      	b.n	340064ae <NORFlash_XSPI_EnableMapMode+0xe2>
        goto Error;
34006498:	bf00      	nop
3400649a:	e002      	b.n	340064a2 <NORFlash_XSPI_EnableMapMode+0xd6>
        goto Error;
3400649c:	bf00      	nop
3400649e:	e000      	b.n	340064a2 <NORFlash_XSPI_EnableMapMode+0xd6>
        goto Error;
340064a0:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
340064a2:	687b      	ldr	r3, [r7, #4]
340064a4:	681b      	ldr	r3, [r3, #0]
340064a6:	4618      	mov	r0, r3
340064a8:	f012 f9fe 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
340064ac:	2301      	movs	r3, #1
}
340064ae:	4618      	mov	r0, r3
340064b0:	3768      	adds	r7, #104	@ 0x68
340064b2:	46bd      	mov	sp, r7
340064b4:	bd80      	pop	{r7, pc}

340064b6 <NORFlash_XSPI_ConfigPHYLink>:

    return NORFlash_XSPI_OK;
}

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_ConfigPHYLink(NORFlash_XSPI_ObjectTypeDef *XSPIObject, NORFlash_XSPI_PhysicalLinkTypeDef PhyLink)
{
340064b6:	b480      	push	{r7}
340064b8:	b083      	sub	sp, #12
340064ba:	af00      	add	r7, sp, #0
340064bc:	6078      	str	r0, [r7, #4]
340064be:	460b      	mov	r3, r1
340064c0:	70fb      	strb	r3, [r7, #3]
    switch (PhyLink)
340064c2:	78fb      	ldrb	r3, [r7, #3]
340064c4:	2b02      	cmp	r3, #2
340064c6:	d04a      	beq.n	3400655e <NORFlash_XSPI_ConfigPHYLink+0xa8>
340064c8:	2b02      	cmp	r3, #2
340064ca:	dc73      	bgt.n	340065b4 <NORFlash_XSPI_ConfigPHYLink+0xfe>
340064cc:	2b00      	cmp	r3, #0
340064ce:	d002      	beq.n	340064d6 <NORFlash_XSPI_ConfigPHYLink+0x20>
340064d0:	2b01      	cmp	r3, #1
340064d2:	d022      	beq.n	3400651a <NORFlash_XSPI_ConfigPHYLink+0x64>
            XSPIObject->BaseCommand.DQSMode = HAL_XSPI_DQS_ENABLE;
            break;
        }
        default:
        {
            goto Error;
340064d4:	e06e      	b.n	340065b4 <NORFlash_XSPI_ConfigPHYLink+0xfe>
            XSPIObject->BaseCommand.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
340064d6:	687b      	ldr	r3, [r7, #4]
340064d8:	2201      	movs	r2, #1
340064da:	611a      	str	r2, [r3, #16]
            XSPIObject->BaseCommand.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
340064dc:	687b      	ldr	r3, [r7, #4]
340064de:	2200      	movs	r2, #0
340064e0:	615a      	str	r2, [r3, #20]
            XSPIObject->BaseCommand.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
340064e2:	687b      	ldr	r3, [r7, #4]
340064e4:	2200      	movs	r2, #0
340064e6:	619a      	str	r2, [r3, #24]
            XSPIObject->BaseCommand.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
340064e8:	687b      	ldr	r3, [r7, #4]
340064ea:	f44f 7280 	mov.w	r2, #256	@ 0x100
340064ee:	621a      	str	r2, [r3, #32]
            XSPIObject->BaseCommand.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
340064f0:	687b      	ldr	r3, [r7, #4]
340064f2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
340064f6:	625a      	str	r2, [r3, #36]	@ 0x24
            XSPIObject->BaseCommand.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
340064f8:	687b      	ldr	r3, [r7, #4]
340064fa:	2200      	movs	r2, #0
340064fc:	629a      	str	r2, [r3, #40]	@ 0x28
            XSPIObject->BaseCommand.DataMode = HAL_XSPI_DATA_1_LINE;
340064fe:	687b      	ldr	r3, [r7, #4]
34006500:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34006504:	63da      	str	r2, [r3, #60]	@ 0x3c
            XSPIObject->BaseCommand.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
34006506:	687b      	ldr	r3, [r7, #4]
34006508:	2200      	movs	r2, #0
3400650a:	645a      	str	r2, [r3, #68]	@ 0x44
            XSPIObject->BaseCommand.DummyCycles = 0;
3400650c:	687b      	ldr	r3, [r7, #4]
3400650e:	2200      	movs	r2, #0
34006510:	649a      	str	r2, [r3, #72]	@ 0x48
            XSPIObject->BaseCommand.DQSMode = HAL_XSPI_DQS_DISABLE;
34006512:	687b      	ldr	r3, [r7, #4]
34006514:	2200      	movs	r2, #0
34006516:	64da      	str	r2, [r3, #76]	@ 0x4c
            break;
34006518:	e046      	b.n	340065a8 <NORFlash_XSPI_ConfigPHYLink+0xf2>
            XSPIObject->BaseCommand.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
3400651a:	687b      	ldr	r3, [r7, #4]
3400651c:	2203      	movs	r2, #3
3400651e:	611a      	str	r2, [r3, #16]
            XSPIObject->BaseCommand.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
34006520:	687b      	ldr	r3, [r7, #4]
34006522:	2200      	movs	r2, #0
34006524:	615a      	str	r2, [r3, #20]
            XSPIObject->BaseCommand.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
34006526:	687b      	ldr	r3, [r7, #4]
34006528:	2200      	movs	r2, #0
3400652a:	619a      	str	r2, [r3, #24]
            XSPIObject->BaseCommand.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
3400652c:	687b      	ldr	r3, [r7, #4]
3400652e:	f44f 7240 	mov.w	r2, #768	@ 0x300
34006532:	621a      	str	r2, [r3, #32]
            XSPIObject->BaseCommand.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
34006534:	687b      	ldr	r3, [r7, #4]
34006536:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
3400653a:	625a      	str	r2, [r3, #36]	@ 0x24
            XSPIObject->BaseCommand.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
3400653c:	687b      	ldr	r3, [r7, #4]
3400653e:	2200      	movs	r2, #0
34006540:	629a      	str	r2, [r3, #40]	@ 0x28
            XSPIObject->BaseCommand.DataMode = HAL_XSPI_DATA_4_LINES;
34006542:	687b      	ldr	r3, [r7, #4]
34006544:	f04f 7240 	mov.w	r2, #50331648	@ 0x3000000
34006548:	63da      	str	r2, [r3, #60]	@ 0x3c
            XSPIObject->BaseCommand.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
3400654a:	687b      	ldr	r3, [r7, #4]
3400654c:	2200      	movs	r2, #0
3400654e:	645a      	str	r2, [r3, #68]	@ 0x44
            XSPIObject->BaseCommand.DummyCycles = 0;
34006550:	687b      	ldr	r3, [r7, #4]
34006552:	2200      	movs	r2, #0
34006554:	649a      	str	r2, [r3, #72]	@ 0x48
            XSPIObject->BaseCommand.DQSMode = HAL_XSPI_DQS_DISABLE;
34006556:	687b      	ldr	r3, [r7, #4]
34006558:	2200      	movs	r2, #0
3400655a:	64da      	str	r2, [r3, #76]	@ 0x4c
            break;
3400655c:	e024      	b.n	340065a8 <NORFlash_XSPI_ConfigPHYLink+0xf2>
            XSPIObject->BaseCommand.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
3400655e:	687b      	ldr	r3, [r7, #4]
34006560:	2204      	movs	r2, #4
34006562:	611a      	str	r2, [r3, #16]
            XSPIObject->BaseCommand.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
34006564:	687b      	ldr	r3, [r7, #4]
34006566:	2210      	movs	r2, #16
34006568:	615a      	str	r2, [r3, #20]
            XSPIObject->BaseCommand.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
3400656a:	687b      	ldr	r3, [r7, #4]
3400656c:	2208      	movs	r2, #8
3400656e:	619a      	str	r2, [r3, #24]
            XSPIObject->BaseCommand.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
34006570:	687b      	ldr	r3, [r7, #4]
34006572:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34006576:	621a      	str	r2, [r3, #32]
            XSPIObject->BaseCommand.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34006578:	687b      	ldr	r3, [r7, #4]
3400657a:	f44f 5240 	mov.w	r2, #12288	@ 0x3000
3400657e:	625a      	str	r2, [r3, #36]	@ 0x24
            XSPIObject->BaseCommand.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
34006580:	687b      	ldr	r3, [r7, #4]
34006582:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34006586:	629a      	str	r2, [r3, #40]	@ 0x28
            XSPIObject->BaseCommand.DataMode = HAL_XSPI_DATA_8_LINES;
34006588:	687b      	ldr	r3, [r7, #4]
3400658a:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
3400658e:	63da      	str	r2, [r3, #60]	@ 0x3c
            XSPIObject->BaseCommand.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
34006590:	687b      	ldr	r3, [r7, #4]
34006592:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34006596:	645a      	str	r2, [r3, #68]	@ 0x44
            XSPIObject->BaseCommand.DummyCycles = 0;
34006598:	687b      	ldr	r3, [r7, #4]
3400659a:	2200      	movs	r2, #0
3400659c:	649a      	str	r2, [r3, #72]	@ 0x48
            XSPIObject->BaseCommand.DQSMode = HAL_XSPI_DQS_ENABLE;
3400659e:	687b      	ldr	r3, [r7, #4]
340065a0:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
340065a4:	64da      	str	r2, [r3, #76]	@ 0x4c
            break;
340065a6:	bf00      	nop
        }
    }

    XSPIObject->PhyLink = PhyLink;
340065a8:	687b      	ldr	r3, [r7, #4]
340065aa:	78fa      	ldrb	r2, [r7, #3]
340065ac:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    return NORFlash_XSPI_OK;
340065b0:	2300      	movs	r3, #0
340065b2:	e001      	b.n	340065b8 <NORFlash_XSPI_ConfigPHYLink+0x102>
            goto Error;
340065b4:	bf00      	nop

Error:
    return NORFlash_XSPI_ERROR;
340065b6:	2301      	movs	r3, #1
}
340065b8:	4618      	mov	r0, r3
340065ba:	370c      	adds	r7, #12
340065bc:	46bd      	mov	sp, r7
340065be:	f85d 7b04 	ldr.w	r7, [sp], #4
340065c2:	4770      	bx	lr

340065c4 <NORFlash_XSPI_CommandSendData>:

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_CommandSendData(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t Command, uint8_t *Data, uint16_t DataSize)
{
340065c4:	b580      	push	{r7, lr}
340065c6:	b098      	sub	sp, #96	@ 0x60
340065c8:	af00      	add	r7, sp, #0
340065ca:	60f8      	str	r0, [r7, #12]
340065cc:	607a      	str	r2, [r7, #4]
340065ce:	461a      	mov	r2, r3
340065d0:	460b      	mov	r3, r1
340065d2:	72fb      	strb	r3, [r7, #11]
340065d4:	4613      	mov	r3, r2
340065d6:	813b      	strh	r3, [r7, #8]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
340065d8:	68fb      	ldr	r3, [r7, #12]
340065da:	f107 0014 	add.w	r0, r7, #20
340065de:	3304      	adds	r3, #4
340065e0:	224c      	movs	r2, #76	@ 0x4c
340065e2:	4619      	mov	r1, r3
340065e4:	f021 f865 	bl	340276b2 <memcpy>

    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)Command << 8) | (uint8_t)(~Command & 0xFF)) : Command;
340065e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340065ea:	2b10      	cmp	r3, #16
340065ec:	d106      	bne.n	340065fc <NORFlash_XSPI_CommandSendData+0x38>
340065ee:	7afb      	ldrb	r3, [r7, #11]
340065f0:	021b      	lsls	r3, r3, #8
340065f2:	7afa      	ldrb	r2, [r7, #11]
340065f4:	43d2      	mvns	r2, r2
340065f6:	b2d2      	uxtb	r2, r2
340065f8:	4313      	orrs	r3, r2
340065fa:	e000      	b.n	340065fe <NORFlash_XSPI_CommandSendData+0x3a>
340065fc:	7afb      	ldrb	r3, [r7, #11]
340065fe:	61fb      	str	r3, [r7, #28]
    Cmd.AddressMode = HAL_XSPI_ADDRESS_NONE;
34006600:	2300      	movs	r3, #0
34006602:	633b      	str	r3, [r7, #48]	@ 0x30
    Cmd.DataMode = (DataSize == 0) ? HAL_XSPI_DATA_NONE : Cmd.DataMode;
34006604:	893b      	ldrh	r3, [r7, #8]
34006606:	2b00      	cmp	r3, #0
34006608:	d001      	beq.n	3400660e <NORFlash_XSPI_CommandSendData+0x4a>
3400660a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400660c:	e000      	b.n	34006610 <NORFlash_XSPI_CommandSendData+0x4c>
3400660e:	2300      	movs	r3, #0
34006610:	64fb      	str	r3, [r7, #76]	@ 0x4c
    Cmd.DataLength = DataSize;
34006612:	893b      	ldrh	r3, [r7, #8]
34006614:	653b      	str	r3, [r7, #80]	@ 0x50
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006616:	68fb      	ldr	r3, [r7, #12]
34006618:	681b      	ldr	r3, [r3, #0]
3400661a:	f107 0114 	add.w	r1, r7, #20
3400661e:	f241 3288 	movw	r2, #5000	@ 0x1388
34006622:	4618      	mov	r0, r3
34006624:	f011 fdf4 	bl	34018210 <HAL_XSPI_Command>
34006628:	4603      	mov	r3, r0
3400662a:	2b00      	cmp	r3, #0
3400662c:	d10f      	bne.n	3400664e <NORFlash_XSPI_CommandSendData+0x8a>
    {
        goto Error;
    }

    if (DataSize != 0)
3400662e:	893b      	ldrh	r3, [r7, #8]
34006630:	2b00      	cmp	r3, #0
34006632:	d00a      	beq.n	3400664a <NORFlash_XSPI_CommandSendData+0x86>
    {
        if (HAL_XSPI_Transmit(XSPIObject->XSPIHandle, Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006634:	68fb      	ldr	r3, [r7, #12]
34006636:	681b      	ldr	r3, [r3, #0]
34006638:	f241 3288 	movw	r2, #5000	@ 0x1388
3400663c:	6879      	ldr	r1, [r7, #4]
3400663e:	4618      	mov	r0, r3
34006640:	f011 ff26 	bl	34018490 <HAL_XSPI_Transmit>
34006644:	4603      	mov	r3, r0
34006646:	2b00      	cmp	r3, #0
34006648:	d103      	bne.n	34006652 <NORFlash_XSPI_CommandSendData+0x8e>
        {
            goto Error;
        }
    }

    return NORFlash_XSPI_OK;
3400664a:	2300      	movs	r3, #0
3400664c:	e008      	b.n	34006660 <NORFlash_XSPI_CommandSendData+0x9c>
        goto Error;
3400664e:	bf00      	nop
34006650:	e000      	b.n	34006654 <NORFlash_XSPI_CommandSendData+0x90>
            goto Error;
34006652:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
34006654:	68fb      	ldr	r3, [r7, #12]
34006656:	681b      	ldr	r3, [r3, #0]
34006658:	4618      	mov	r0, r3
3400665a:	f012 f925 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
3400665e:	2301      	movs	r3, #1
}
34006660:	4618      	mov	r0, r3
34006662:	3760      	adds	r7, #96	@ 0x60
34006664:	46bd      	mov	sp, r7
34006666:	bd80      	pop	{r7, pc}

34006668 <NORFlash_XSPI_CommandRead>:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
    return NORFlash_XSPI_ERROR;
}

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_CommandRead(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t Command, uint8_t *Data, uint16_t DataSize)
{
34006668:	b580      	push	{r7, lr}
3400666a:	b098      	sub	sp, #96	@ 0x60
3400666c:	af00      	add	r7, sp, #0
3400666e:	60f8      	str	r0, [r7, #12]
34006670:	607a      	str	r2, [r7, #4]
34006672:	461a      	mov	r2, r3
34006674:	460b      	mov	r3, r1
34006676:	72fb      	strb	r3, [r7, #11]
34006678:	4613      	mov	r3, r2
3400667a:	813b      	strh	r3, [r7, #8]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
3400667c:	68fb      	ldr	r3, [r7, #12]
3400667e:	f107 0014 	add.w	r0, r7, #20
34006682:	3304      	adds	r3, #4
34006684:	224c      	movs	r2, #76	@ 0x4c
34006686:	4619      	mov	r1, r3
34006688:	f021 f813 	bl	340276b2 <memcpy>

    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)Command << 8) | (uint8_t)(~Command & 0xFF)) : Command;
3400668c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400668e:	2b10      	cmp	r3, #16
34006690:	d106      	bne.n	340066a0 <NORFlash_XSPI_CommandRead+0x38>
34006692:	7afb      	ldrb	r3, [r7, #11]
34006694:	021b      	lsls	r3, r3, #8
34006696:	7afa      	ldrb	r2, [r7, #11]
34006698:	43d2      	mvns	r2, r2
3400669a:	b2d2      	uxtb	r2, r2
3400669c:	4313      	orrs	r3, r2
3400669e:	e000      	b.n	340066a2 <NORFlash_XSPI_CommandRead+0x3a>
340066a0:	7afb      	ldrb	r3, [r7, #11]
340066a2:	61fb      	str	r3, [r7, #28]
    Cmd.AddressMode = HAL_XSPI_ADDRESS_NONE;
340066a4:	2300      	movs	r3, #0
340066a6:	633b      	str	r3, [r7, #48]	@ 0x30
    Cmd.DataMode = (DataSize == 0) ? HAL_XSPI_DATA_NONE : Cmd.DataMode;
340066a8:	893b      	ldrh	r3, [r7, #8]
340066aa:	2b00      	cmp	r3, #0
340066ac:	d001      	beq.n	340066b2 <NORFlash_XSPI_CommandRead+0x4a>
340066ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340066b0:	e000      	b.n	340066b4 <NORFlash_XSPI_CommandRead+0x4c>
340066b2:	2300      	movs	r3, #0
340066b4:	64fb      	str	r3, [r7, #76]	@ 0x4c
    Cmd.DataLength = DataSize;
340066b6:	893b      	ldrh	r3, [r7, #8]
340066b8:	653b      	str	r3, [r7, #80]	@ 0x50
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340066ba:	68fb      	ldr	r3, [r7, #12]
340066bc:	681b      	ldr	r3, [r3, #0]
340066be:	f107 0114 	add.w	r1, r7, #20
340066c2:	f241 3288 	movw	r2, #5000	@ 0x1388
340066c6:	4618      	mov	r0, r3
340066c8:	f011 fda2 	bl	34018210 <HAL_XSPI_Command>
340066cc:	4603      	mov	r3, r0
340066ce:	2b00      	cmp	r3, #0
340066d0:	d10f      	bne.n	340066f2 <NORFlash_XSPI_CommandRead+0x8a>
    {
        goto Error;
    }

    if (DataSize != 0)
340066d2:	893b      	ldrh	r3, [r7, #8]
340066d4:	2b00      	cmp	r3, #0
340066d6:	d00a      	beq.n	340066ee <NORFlash_XSPI_CommandRead+0x86>
    {
        if (HAL_XSPI_Receive(XSPIObject->XSPIHandle, Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340066d8:	68fb      	ldr	r3, [r7, #12]
340066da:	681b      	ldr	r3, [r3, #0]
340066dc:	f241 3288 	movw	r2, #5000	@ 0x1388
340066e0:	6879      	ldr	r1, [r7, #4]
340066e2:	4618      	mov	r0, r3
340066e4:	f011 ff47 	bl	34018576 <HAL_XSPI_Receive>
340066e8:	4603      	mov	r3, r0
340066ea:	2b00      	cmp	r3, #0
340066ec:	d103      	bne.n	340066f6 <NORFlash_XSPI_CommandRead+0x8e>
        {
            goto Error;
        }
    }

    return NORFlash_XSPI_OK;
340066ee:	2300      	movs	r3, #0
340066f0:	e008      	b.n	34006704 <NORFlash_XSPI_CommandRead+0x9c>
        goto Error;
340066f2:	bf00      	nop
340066f4:	e000      	b.n	340066f8 <NORFlash_XSPI_CommandRead+0x90>
            goto Error;
340066f6:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
340066f8:	68fb      	ldr	r3, [r7, #12]
340066fa:	681b      	ldr	r3, [r3, #0]
340066fc:	4618      	mov	r0, r3
340066fe:	f012 f8d3 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
34006702:	2301      	movs	r3, #1
}
34006704:	4618      	mov	r0, r3
34006706:	3760      	adds	r7, #96	@ 0x60
34006708:	46bd      	mov	sp, r7
3400670a:	bd80      	pop	{r7, pc}

3400670c <NORFlash_XSPI_CommandSendAddressReadData>:

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_CommandSendAddressReadData(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t Command, uint32_t Address, uint8_t *Data, uint16_t DataSize)
{
3400670c:	b580      	push	{r7, lr}
3400670e:	b098      	sub	sp, #96	@ 0x60
34006710:	af00      	add	r7, sp, #0
34006712:	60f8      	str	r0, [r7, #12]
34006714:	607a      	str	r2, [r7, #4]
34006716:	603b      	str	r3, [r7, #0]
34006718:	460b      	mov	r3, r1
3400671a:	72fb      	strb	r3, [r7, #11]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
3400671c:	68fb      	ldr	r3, [r7, #12]
3400671e:	f107 0014 	add.w	r0, r7, #20
34006722:	3304      	adds	r3, #4
34006724:	224c      	movs	r2, #76	@ 0x4c
34006726:	4619      	mov	r1, r3
34006728:	f020 ffc3 	bl	340276b2 <memcpy>

    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)Command << 8) | (uint8_t)(~Command & 0xFF)) : Command;
3400672c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400672e:	2b10      	cmp	r3, #16
34006730:	d106      	bne.n	34006740 <NORFlash_XSPI_CommandSendAddressReadData+0x34>
34006732:	7afb      	ldrb	r3, [r7, #11]
34006734:	021b      	lsls	r3, r3, #8
34006736:	7afa      	ldrb	r2, [r7, #11]
34006738:	43d2      	mvns	r2, r2
3400673a:	b2d2      	uxtb	r2, r2
3400673c:	4313      	orrs	r3, r2
3400673e:	e000      	b.n	34006742 <NORFlash_XSPI_CommandSendAddressReadData+0x36>
34006740:	7afb      	ldrb	r3, [r7, #11]
34006742:	61fb      	str	r3, [r7, #28]
    Cmd.Address = Address;
34006744:	687b      	ldr	r3, [r7, #4]
34006746:	62fb      	str	r3, [r7, #44]	@ 0x2c
    Cmd.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
34006748:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
3400674c:	637b      	str	r3, [r7, #52]	@ 0x34
    Cmd.DataMode = (DataSize == 0) ? HAL_XSPI_DATA_NONE : Cmd.DataMode;
3400674e:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
34006752:	2b00      	cmp	r3, #0
34006754:	d001      	beq.n	3400675a <NORFlash_XSPI_CommandSendAddressReadData+0x4e>
34006756:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34006758:	e000      	b.n	3400675c <NORFlash_XSPI_CommandSendAddressReadData+0x50>
3400675a:	2300      	movs	r3, #0
3400675c:	64fb      	str	r3, [r7, #76]	@ 0x4c
    Cmd.DataLength = DataSize;
3400675e:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
34006762:	653b      	str	r3, [r7, #80]	@ 0x50
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006764:	68fb      	ldr	r3, [r7, #12]
34006766:	681b      	ldr	r3, [r3, #0]
34006768:	f107 0114 	add.w	r1, r7, #20
3400676c:	f241 3288 	movw	r2, #5000	@ 0x1388
34006770:	4618      	mov	r0, r3
34006772:	f011 fd4d 	bl	34018210 <HAL_XSPI_Command>
34006776:	4603      	mov	r3, r0
34006778:	2b00      	cmp	r3, #0
3400677a:	d110      	bne.n	3400679e <NORFlash_XSPI_CommandSendAddressReadData+0x92>
    {
        goto Error;
    }

    if (DataSize != 0)
3400677c:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
34006780:	2b00      	cmp	r3, #0
34006782:	d00a      	beq.n	3400679a <NORFlash_XSPI_CommandSendAddressReadData+0x8e>
    {
        if (HAL_XSPI_Receive(XSPIObject->XSPIHandle, Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006784:	68fb      	ldr	r3, [r7, #12]
34006786:	681b      	ldr	r3, [r3, #0]
34006788:	f241 3288 	movw	r2, #5000	@ 0x1388
3400678c:	6839      	ldr	r1, [r7, #0]
3400678e:	4618      	mov	r0, r3
34006790:	f011 fef1 	bl	34018576 <HAL_XSPI_Receive>
34006794:	4603      	mov	r3, r0
34006796:	2b00      	cmp	r3, #0
34006798:	d103      	bne.n	340067a2 <NORFlash_XSPI_CommandSendAddressReadData+0x96>
        {
            goto Error;
        }
    }

    return NORFlash_XSPI_OK;
3400679a:	2300      	movs	r3, #0
3400679c:	e008      	b.n	340067b0 <NORFlash_XSPI_CommandSendAddressReadData+0xa4>
        goto Error;
3400679e:	bf00      	nop
340067a0:	e000      	b.n	340067a4 <NORFlash_XSPI_CommandSendAddressReadData+0x98>
            goto Error;
340067a2:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
340067a4:	68fb      	ldr	r3, [r7, #12]
340067a6:	681b      	ldr	r3, [r3, #0]
340067a8:	4618      	mov	r0, r3
340067aa:	f012 f87d 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
340067ae:	2301      	movs	r3, #1
}
340067b0:	4618      	mov	r0, r3
340067b2:	3760      	adds	r7, #96	@ 0x60
340067b4:	46bd      	mov	sp, r7
340067b6:	bd80      	pop	{r7, pc}

340067b8 <NORFlash_XSPI_CommandSendAddressSendData>:

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_CommandSendAddressSendData(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t Command, uint32_t Address, uint8_t *Data, uint16_t DataSize)
{
340067b8:	b580      	push	{r7, lr}
340067ba:	b098      	sub	sp, #96	@ 0x60
340067bc:	af00      	add	r7, sp, #0
340067be:	60f8      	str	r0, [r7, #12]
340067c0:	607a      	str	r2, [r7, #4]
340067c2:	603b      	str	r3, [r7, #0]
340067c4:	460b      	mov	r3, r1
340067c6:	72fb      	strb	r3, [r7, #11]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
340067c8:	68fb      	ldr	r3, [r7, #12]
340067ca:	f107 0014 	add.w	r0, r7, #20
340067ce:	3304      	adds	r3, #4
340067d0:	224c      	movs	r2, #76	@ 0x4c
340067d2:	4619      	mov	r1, r3
340067d4:	f020 ff6d 	bl	340276b2 <memcpy>

    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)Command << 8) | (uint8_t)(~Command & 0xFF)) : Command;
340067d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340067da:	2b10      	cmp	r3, #16
340067dc:	d106      	bne.n	340067ec <NORFlash_XSPI_CommandSendAddressSendData+0x34>
340067de:	7afb      	ldrb	r3, [r7, #11]
340067e0:	021b      	lsls	r3, r3, #8
340067e2:	7afa      	ldrb	r2, [r7, #11]
340067e4:	43d2      	mvns	r2, r2
340067e6:	b2d2      	uxtb	r2, r2
340067e8:	4313      	orrs	r3, r2
340067ea:	e000      	b.n	340067ee <NORFlash_XSPI_CommandSendAddressSendData+0x36>
340067ec:	7afb      	ldrb	r3, [r7, #11]
340067ee:	61fb      	str	r3, [r7, #28]
    Cmd.Address = Address;
340067f0:	687b      	ldr	r3, [r7, #4]
340067f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    Cmd.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
340067f4:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
340067f8:	637b      	str	r3, [r7, #52]	@ 0x34
    Cmd.DataMode = (DataSize == 0) ? HAL_XSPI_DATA_NONE : Cmd.DataMode;
340067fa:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
340067fe:	2b00      	cmp	r3, #0
34006800:	d001      	beq.n	34006806 <NORFlash_XSPI_CommandSendAddressSendData+0x4e>
34006802:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34006804:	e000      	b.n	34006808 <NORFlash_XSPI_CommandSendAddressSendData+0x50>
34006806:	2300      	movs	r3, #0
34006808:	64fb      	str	r3, [r7, #76]	@ 0x4c
    Cmd.DataLength = DataSize;
3400680a:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
3400680e:	653b      	str	r3, [r7, #80]	@ 0x50
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006810:	68fb      	ldr	r3, [r7, #12]
34006812:	681b      	ldr	r3, [r3, #0]
34006814:	f107 0114 	add.w	r1, r7, #20
34006818:	f241 3288 	movw	r2, #5000	@ 0x1388
3400681c:	4618      	mov	r0, r3
3400681e:	f011 fcf7 	bl	34018210 <HAL_XSPI_Command>
34006822:	4603      	mov	r3, r0
34006824:	2b00      	cmp	r3, #0
34006826:	d110      	bne.n	3400684a <NORFlash_XSPI_CommandSendAddressSendData+0x92>
    {
        goto Error;
    }

    if (DataSize != 0)
34006828:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
3400682c:	2b00      	cmp	r3, #0
3400682e:	d00a      	beq.n	34006846 <NORFlash_XSPI_CommandSendAddressSendData+0x8e>
    {
        if (HAL_XSPI_Transmit(XSPIObject->XSPIHandle, Data, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
34006830:	68fb      	ldr	r3, [r7, #12]
34006832:	681b      	ldr	r3, [r3, #0]
34006834:	f241 3288 	movw	r2, #5000	@ 0x1388
34006838:	6839      	ldr	r1, [r7, #0]
3400683a:	4618      	mov	r0, r3
3400683c:	f011 fe28 	bl	34018490 <HAL_XSPI_Transmit>
34006840:	4603      	mov	r3, r0
34006842:	2b00      	cmp	r3, #0
34006844:	d103      	bne.n	3400684e <NORFlash_XSPI_CommandSendAddressSendData+0x96>
        {
            goto Error;
        }
    }

    return NORFlash_XSPI_OK;
34006846:	2300      	movs	r3, #0
34006848:	e008      	b.n	3400685c <NORFlash_XSPI_CommandSendAddressSendData+0xa4>
        goto Error;
3400684a:	bf00      	nop
3400684c:	e000      	b.n	34006850 <NORFlash_XSPI_CommandSendAddressSendData+0x98>
            goto Error;
3400684e:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
34006850:	68fb      	ldr	r3, [r7, #12]
34006852:	681b      	ldr	r3, [r3, #0]
34006854:	4618      	mov	r0, r3
34006856:	f012 f827 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
3400685a:	2301      	movs	r3, #1
}
3400685c:	4618      	mov	r0, r3
3400685e:	3760      	adds	r7, #96	@ 0x60
34006860:	46bd      	mov	sp, r7
34006862:	bd80      	pop	{r7, pc}

34006864 <NORFlash_XSPI_WaitStatusRegister>:

NORFlash_XSPI_StatusTypeDef NORFlash_XSPI_WaitStatusRegister(NORFlash_XSPI_ObjectTypeDef *XSPIObject, uint8_t Command, uint16_t MatchValue, uint16_t MatchMask, uint8_t DataSize, uint32_t Timeout)
{
34006864:	b580      	push	{r7, lr}
34006866:	b09c      	sub	sp, #112	@ 0x70
34006868:	af00      	add	r7, sp, #0
3400686a:	60f8      	str	r0, [r7, #12]
3400686c:	4608      	mov	r0, r1
3400686e:	4611      	mov	r1, r2
34006870:	461a      	mov	r2, r3
34006872:	4603      	mov	r3, r0
34006874:	72fb      	strb	r3, [r7, #11]
34006876:	460b      	mov	r3, r1
34006878:	813b      	strh	r3, [r7, #8]
3400687a:	4613      	mov	r3, r2
3400687c:	80fb      	strh	r3, [r7, #6]
    XSPI_RegularCmdTypeDef Cmd = XSPIObject->BaseCommand;
3400687e:	68fb      	ldr	r3, [r7, #12]
34006880:	f107 0024 	add.w	r0, r7, #36	@ 0x24
34006884:	3304      	adds	r3, #4
34006886:	224c      	movs	r2, #76	@ 0x4c
34006888:	4619      	mov	r1, r3
3400688a:	f020 ff12 	bl	340276b2 <memcpy>
    XSPI_AutoPollingTypeDef Cfg = {0};
3400688e:	f107 0310 	add.w	r3, r7, #16
34006892:	2200      	movs	r2, #0
34006894:	601a      	str	r2, [r3, #0]
34006896:	605a      	str	r2, [r3, #4]
34006898:	609a      	str	r2, [r3, #8]
3400689a:	60da      	str	r2, [r3, #12]
3400689c:	611a      	str	r2, [r3, #16]

    Cmd.Instruction = (Cmd.InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS) ? (((uint16_t)Command << 8) | (uint8_t)(~Command & 0xFF)) : Command;
3400689e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340068a0:	2b10      	cmp	r3, #16
340068a2:	d106      	bne.n	340068b2 <NORFlash_XSPI_WaitStatusRegister+0x4e>
340068a4:	7afb      	ldrb	r3, [r7, #11]
340068a6:	021b      	lsls	r3, r3, #8
340068a8:	7afa      	ldrb	r2, [r7, #11]
340068aa:	43d2      	mvns	r2, r2
340068ac:	b2d2      	uxtb	r2, r2
340068ae:	4313      	orrs	r3, r2
340068b0:	e000      	b.n	340068b4 <NORFlash_XSPI_WaitStatusRegister+0x50>
340068b2:	7afb      	ldrb	r3, [r7, #11]
340068b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    Cmd.AddressMode = (Cmd.InstructionMode == HAL_XSPI_INSTRUCTION_8_LINES) ? HAL_XSPI_ADDRESS_8_LINES : HAL_XSPI_ADDRESS_NONE;
340068b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340068b8:	2b04      	cmp	r3, #4
340068ba:	d102      	bne.n	340068c2 <NORFlash_XSPI_WaitStatusRegister+0x5e>
340068bc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
340068c0:	e000      	b.n	340068c4 <NORFlash_XSPI_WaitStatusRegister+0x60>
340068c2:	2300      	movs	r3, #0
340068c4:	643b      	str	r3, [r7, #64]	@ 0x40
    Cmd.Address = 0x00000000;
340068c6:	2300      	movs	r3, #0
340068c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    Cmd.DataLength = DataSize;
340068ca:	f897 3078 	ldrb.w	r3, [r7, #120]	@ 0x78
340068ce:	663b      	str	r3, [r7, #96]	@ 0x60
    Cmd.DummyCycles = (Cmd.InstructionMode == HAL_XSPI_INSTRUCTION_8_LINES) ? 4 : Cmd.DummyCycles;
340068d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340068d2:	2b04      	cmp	r3, #4
340068d4:	d001      	beq.n	340068da <NORFlash_XSPI_WaitStatusRegister+0x76>
340068d6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
340068d8:	e000      	b.n	340068dc <NORFlash_XSPI_WaitStatusRegister+0x78>
340068da:	2304      	movs	r3, #4
340068dc:	66bb      	str	r3, [r7, #104]	@ 0x68
    if (HAL_XSPI_Command(XSPIObject->XSPIHandle, &Cmd, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
340068de:	68fb      	ldr	r3, [r7, #12]
340068e0:	681b      	ldr	r3, [r3, #0]
340068e2:	f107 0124 	add.w	r1, r7, #36	@ 0x24
340068e6:	f241 3288 	movw	r2, #5000	@ 0x1388
340068ea:	4618      	mov	r0, r3
340068ec:	f011 fc90 	bl	34018210 <HAL_XSPI_Command>
340068f0:	4603      	mov	r3, r0
340068f2:	2b00      	cmp	r3, #0
340068f4:	d117      	bne.n	34006926 <NORFlash_XSPI_WaitStatusRegister+0xc2>
    {
        goto Error;
    }

    Cfg.MatchValue = MatchValue;
340068f6:	893b      	ldrh	r3, [r7, #8]
340068f8:	613b      	str	r3, [r7, #16]
    Cfg.MatchMask = MatchMask;
340068fa:	88fb      	ldrh	r3, [r7, #6]
340068fc:	617b      	str	r3, [r7, #20]
    Cfg.MatchMode = HAL_XSPI_MATCH_MODE_AND;
340068fe:	2300      	movs	r3, #0
34006900:	61bb      	str	r3, [r7, #24]
    Cfg.AutomaticStop = HAL_XSPI_AUTOMATIC_STOP_ENABLE;
34006902:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
34006906:	61fb      	str	r3, [r7, #28]
    Cfg.IntervalTime = 0x10;
34006908:	2310      	movs	r3, #16
3400690a:	623b      	str	r3, [r7, #32]
    if (HAL_XSPI_AutoPolling(XSPIObject->XSPIHandle, &Cfg, Timeout) != HAL_OK)
3400690c:	68fb      	ldr	r3, [r7, #12]
3400690e:	681b      	ldr	r3, [r3, #0]
34006910:	f107 0110 	add.w	r1, r7, #16
34006914:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
34006916:	4618      	mov	r0, r3
34006918:	f011 fed0 	bl	340186bc <HAL_XSPI_AutoPolling>
3400691c:	4603      	mov	r3, r0
3400691e:	2b00      	cmp	r3, #0
34006920:	d103      	bne.n	3400692a <NORFlash_XSPI_WaitStatusRegister+0xc6>
    {
        goto Error;
    }

    return NORFlash_XSPI_OK;
34006922:	2300      	movs	r3, #0
34006924:	e008      	b.n	34006938 <NORFlash_XSPI_WaitStatusRegister+0xd4>
        goto Error;
34006926:	bf00      	nop
34006928:	e000      	b.n	3400692c <NORFlash_XSPI_WaitStatusRegister+0xc8>
        goto Error;
3400692a:	bf00      	nop

Error:
    HAL_XSPI_Abort(XSPIObject->XSPIHandle);
3400692c:	68fb      	ldr	r3, [r7, #12]
3400692e:	681b      	ldr	r3, [r3, #0]
34006930:	4618      	mov	r0, r3
34006932:	f011 ffb9 	bl	340188a8 <HAL_XSPI_Abort>
    return NORFlash_XSPI_ERROR;
34006936:	2301      	movs	r3, #1
}
34006938:	4618      	mov	r0, r3
3400693a:	3770      	adds	r7, #112	@ 0x70
3400693c:	46bd      	mov	sp, r7
3400693e:	bd80      	pop	{r7, pc}

34006940 <uart_init>:
 * @brief   
 * @param   baudrate: bps
 * @retval  
 */
void uart_init(uint32_t baudrate)
{
34006940:	b580      	push	{r7, lr}
34006942:	b082      	sub	sp, #8
34006944:	af00      	add	r7, sp, #0
34006946:	6078      	str	r0, [r7, #4]
    UNUSED(baudrate);

    setvbuf(stdout, NULL, _IONBF, 0);
34006948:	4b05      	ldr	r3, [pc, #20]	@ (34006960 <uart_init+0x20>)
3400694a:	681b      	ldr	r3, [r3, #0]
3400694c:	6898      	ldr	r0, [r3, #8]
3400694e:	2300      	movs	r3, #0
34006950:	2202      	movs	r2, #2
34006952:	2100      	movs	r1, #0
34006954:	f020 fa06 	bl	34026d64 <setvbuf>

#if UART_EN_RX
    /* UART */
    HAL_UART_Receive_IT(&huart1, g_rx_buffer, sizeof(g_rx_buffer));
#endif
}
34006958:	bf00      	nop
3400695a:	3708      	adds	r7, #8
3400695c:	46bd      	mov	sp, r7
3400695e:	bd80      	pop	{r7, pc}
34006960:	340414a4 	.word	0x340414a4

34006964 <__io_putchar>:
 * @brief   Cprintf
 * @param   
 * @retval  
 */
int __io_putchar(int ch)
{
34006964:	b580      	push	{r7, lr}
34006966:	b082      	sub	sp, #8
34006968:	af00      	add	r7, sp, #0
3400696a:	6078      	str	r0, [r7, #4]
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
3400696c:	1d39      	adds	r1, r7, #4
3400696e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34006972:	2201      	movs	r2, #1
34006974:	4803      	ldr	r0, [pc, #12]	@ (34006984 <__io_putchar+0x20>)
34006976:	f010 fd85 	bl	34017484 <HAL_UART_Transmit>

    return ch;
3400697a:	687b      	ldr	r3, [r7, #4]
}
3400697c:	4618      	mov	r0, r3
3400697e:	3708      	adds	r7, #8
34006980:	46bd      	mov	sp, r7
34006982:	bd80      	pop	{r7, pc}
34006984:	34048f78 	.word	0x34048f78

34006988 <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
34006988:	b480      	push	{r7}
3400698a:	af00      	add	r7, sp, #0
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
3400698c:	4b18      	ldr	r3, [pc, #96]	@ (340069f0 <TZ_SAU_Setup+0x68>)
3400698e:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34006992:	4a17      	ldr	r2, [pc, #92]	@ (340069f0 <TZ_SAU_Setup+0x68>)
34006994:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
34006998:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
3400699c:	4b15      	ldr	r3, [pc, #84]	@ (340069f4 <TZ_SAU_Setup+0x6c>)
3400699e:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
340069a0:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340069a4:	4a13      	ldr	r2, [pc, #76]	@ (340069f4 <TZ_SAU_Setup+0x6c>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
340069a6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
340069aa:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
340069ac:	4b12      	ldr	r3, [pc, #72]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069ae:	2200      	movs	r2, #0
340069b0:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
340069b4:	4b10      	ldr	r3, [pc, #64]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069b6:	2200      	movs	r2, #0
340069b8:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
340069bc:	4b0e      	ldr	r3, [pc, #56]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069be:	2200      	movs	r2, #0
340069c0:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
340069c4:	4b0c      	ldr	r3, [pc, #48]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069c6:	2200      	movs	r2, #0
340069c8:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
340069cc:	4b0a      	ldr	r3, [pc, #40]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069ce:	2200      	movs	r2, #0
340069d0:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
340069d4:	4b08      	ldr	r3, [pc, #32]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069d6:	2200      	movs	r2, #0
340069d8:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
340069dc:	4b06      	ldr	r3, [pc, #24]	@ (340069f8 <TZ_SAU_Setup+0x70>)
340069de:	2200      	movs	r2, #0
340069e0:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
  #endif

}
340069e4:	bf00      	nop
340069e6:	46bd      	mov	sp, r7
340069e8:	f85d 7b04 	ldr.w	r7, [sp], #4
340069ec:	4770      	bx	lr
340069ee:	bf00      	nop
340069f0:	e000ed00 	.word	0xe000ed00
340069f4:	e000ef30 	.word	0xe000ef30
340069f8:	e000e100 	.word	0xe000e100

340069fc <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
340069fc:	b580      	push	{r7, lr}
340069fe:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
34006a00:	f7ff ffc2 	bl	34006988 <TZ_SAU_Setup>

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
34006a04:	4b14      	ldr	r3, [pc, #80]	@ (34006a58 <SystemInit+0x5c>)
34006a06:	4a15      	ldr	r2, [pc, #84]	@ (34006a5c <SystemInit+0x60>)
34006a08:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
34006a0a:	4b15      	ldr	r3, [pc, #84]	@ (34006a60 <SystemInit+0x64>)
34006a0c:	2201      	movs	r2, #1
34006a0e:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
34006a12:	4b13      	ldr	r3, [pc, #76]	@ (34006a60 <SystemInit+0x64>)
34006a14:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
34006a18:	4b0f      	ldr	r3, [pc, #60]	@ (34006a58 <SystemInit+0x5c>)
34006a1a:	4a12      	ldr	r2, [pc, #72]	@ (34006a64 <SystemInit+0x68>)
34006a1c:	689b      	ldr	r3, [r3, #8]
34006a1e:	6113      	str	r3, [r2, #16]
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
34006a20:	4b10      	ldr	r3, [pc, #64]	@ (34006a64 <SystemInit+0x68>)
34006a22:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
34006a24:	4b0e      	ldr	r3, [pc, #56]	@ (34006a60 <SystemInit+0x64>)
34006a26:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34006a2a:	461a      	mov	r2, r3
34006a2c:	2301      	movs	r3, #1
34006a2e:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34006a32:	4b09      	ldr	r3, [pc, #36]	@ (34006a58 <SystemInit+0x5c>)
34006a34:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34006a38:	4a07      	ldr	r2, [pc, #28]	@ (34006a58 <SystemInit+0x5c>)
34006a3a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34006a3e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
34006a42:	4b09      	ldr	r3, [pc, #36]	@ (34006a68 <SystemInit+0x6c>)
34006a44:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34006a48:	4a07      	ldr	r2, [pc, #28]	@ (34006a68 <SystemInit+0x6c>)
34006a4a:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
34006a4e:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
34006a52:	bf00      	nop
34006a54:	bd80      	pop	{r7, pc}
34006a56:	bf00      	nop
34006a58:	e000ed00 	.word	0xe000ed00
34006a5c:	34000400 	.word	0x34000400
34006a60:	56028000 	.word	0x56028000
34006a64:	56008000 	.word	0x56008000
34006a68:	e002ed00 	.word	0xe002ed00

34006a6c <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34006a6c:	b480      	push	{r7}
34006a6e:	b08d      	sub	sp, #52	@ 0x34
34006a70:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
34006a72:	2300      	movs	r3, #0
34006a74:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34006a76:	2300      	movs	r3, #0
34006a78:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34006a7a:	2300      	movs	r3, #0
34006a7c:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
34006a7e:	2300      	movs	r3, #0
34006a80:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
34006a82:	2300      	movs	r3, #0
34006a84:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34006a86:	2300      	movs	r3, #0
34006a88:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34006a8a:	4b9b      	ldr	r3, [pc, #620]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006a8c:	6a1b      	ldr	r3, [r3, #32]
34006a8e:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
34006a92:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34006a96:	d029      	beq.n	34006aec <SystemCoreClockUpdate+0x80>
34006a98:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34006a9c:	f200 8180 	bhi.w	34006da0 <SystemCoreClockUpdate+0x334>
34006aa0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34006aa4:	d01f      	beq.n	34006ae6 <SystemCoreClockUpdate+0x7a>
34006aa6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34006aaa:	f200 8179 	bhi.w	34006da0 <SystemCoreClockUpdate+0x334>
34006aae:	2b00      	cmp	r3, #0
34006ab0:	d003      	beq.n	34006aba <SystemCoreClockUpdate+0x4e>
34006ab2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34006ab6:	d00a      	beq.n	34006ace <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34006ab8:	e172      	b.n	34006da0 <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34006aba:	4b8f      	ldr	r3, [pc, #572]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006abc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34006abe:	09db      	lsrs	r3, r3, #7
34006ac0:	f003 0303 	and.w	r3, r3, #3
34006ac4:	4a8d      	ldr	r2, [pc, #564]	@ (34006cfc <SystemCoreClockUpdate+0x290>)
34006ac6:	fa22 f303 	lsr.w	r3, r2, r3
34006aca:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34006acc:	e169      	b.n	34006da2 <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34006ace:	4b8a      	ldr	r3, [pc, #552]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006ad0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006ad2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006ad6:	2b00      	cmp	r3, #0
34006ad8:	d102      	bne.n	34006ae0 <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34006ada:	4b89      	ldr	r3, [pc, #548]	@ (34006d00 <SystemCoreClockUpdate+0x294>)
34006adc:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34006ade:	e160      	b.n	34006da2 <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
34006ae0:	4b88      	ldr	r3, [pc, #544]	@ (34006d04 <SystemCoreClockUpdate+0x298>)
34006ae2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34006ae4:	e15d      	b.n	34006da2 <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
34006ae6:	4b88      	ldr	r3, [pc, #544]	@ (34006d08 <SystemCoreClockUpdate+0x29c>)
34006ae8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34006aea:	e15a      	b.n	34006da2 <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
34006aec:	4b82      	ldr	r3, [pc, #520]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006aee:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006af2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
34006af6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006afa:	d066      	beq.n	34006bca <SystemCoreClockUpdate+0x15e>
34006afc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006b00:	f200 8091 	bhi.w	34006c26 <SystemCoreClockUpdate+0x1ba>
34006b04:	2b00      	cmp	r3, #0
34006b06:	d003      	beq.n	34006b10 <SystemCoreClockUpdate+0xa4>
34006b08:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006b0c:	d02f      	beq.n	34006b6e <SystemCoreClockUpdate+0x102>
34006b0e:	e08a      	b.n	34006c26 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
34006b10:	4b79      	ldr	r3, [pc, #484]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006b12:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34006b16:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
34006b18:	68fb      	ldr	r3, [r7, #12]
34006b1a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34006b1e:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
34006b20:	68fb      	ldr	r3, [r7, #12]
34006b22:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006b26:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34006b28:	693b      	ldr	r3, [r7, #16]
34006b2a:	2b00      	cmp	r3, #0
34006b2c:	f040 80a9 	bne.w	34006c82 <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
34006b30:	68fb      	ldr	r3, [r7, #12]
34006b32:	0d1b      	lsrs	r3, r3, #20
34006b34:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34006b38:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
34006b3a:	68fb      	ldr	r3, [r7, #12]
34006b3c:	0a1b      	lsrs	r3, r3, #8
34006b3e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006b42:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34006b44:	4b6c      	ldr	r3, [pc, #432]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006b46:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34006b4a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34006b4e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
34006b50:	4b69      	ldr	r3, [pc, #420]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006b52:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34006b56:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34006b58:	68fb      	ldr	r3, [r7, #12]
34006b5a:	0edb      	lsrs	r3, r3, #27
34006b5c:	f003 0307 	and.w	r3, r3, #7
34006b60:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
34006b62:	68fb      	ldr	r3, [r7, #12]
34006b64:	0e1b      	lsrs	r3, r3, #24
34006b66:	f003 0307 	and.w	r3, r3, #7
34006b6a:	61bb      	str	r3, [r7, #24]
      break;
34006b6c:	e089      	b.n	34006c82 <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
34006b6e:	4b62      	ldr	r3, [pc, #392]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006b70:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34006b74:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34006b76:	68fb      	ldr	r3, [r7, #12]
34006b78:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34006b7c:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
34006b7e:	68fb      	ldr	r3, [r7, #12]
34006b80:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006b84:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34006b86:	693b      	ldr	r3, [r7, #16]
34006b88:	2b00      	cmp	r3, #0
34006b8a:	d17c      	bne.n	34006c86 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34006b8c:	68fb      	ldr	r3, [r7, #12]
34006b8e:	0d1b      	lsrs	r3, r3, #20
34006b90:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34006b94:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34006b96:	68fb      	ldr	r3, [r7, #12]
34006b98:	0a1b      	lsrs	r3, r3, #8
34006b9a:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006b9e:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
34006ba0:	4b55      	ldr	r3, [pc, #340]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006ba2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34006ba6:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34006baa:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34006bac:	4b52      	ldr	r3, [pc, #328]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006bae:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34006bb2:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34006bb4:	68fb      	ldr	r3, [r7, #12]
34006bb6:	0edb      	lsrs	r3, r3, #27
34006bb8:	f003 0307 	and.w	r3, r3, #7
34006bbc:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
34006bbe:	68fb      	ldr	r3, [r7, #12]
34006bc0:	0e1b      	lsrs	r3, r3, #24
34006bc2:	f003 0307 	and.w	r3, r3, #7
34006bc6:	61bb      	str	r3, [r7, #24]
      break;
34006bc8:	e05d      	b.n	34006c86 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34006bca:	4b4b      	ldr	r3, [pc, #300]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006bcc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34006bd0:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
34006bd2:	68fb      	ldr	r3, [r7, #12]
34006bd4:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34006bd8:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34006bda:	68fb      	ldr	r3, [r7, #12]
34006bdc:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006be0:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34006be2:	693b      	ldr	r3, [r7, #16]
34006be4:	2b00      	cmp	r3, #0
34006be6:	d150      	bne.n	34006c8a <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
34006be8:	68fb      	ldr	r3, [r7, #12]
34006bea:	0d1b      	lsrs	r3, r3, #20
34006bec:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34006bf0:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
34006bf2:	68fb      	ldr	r3, [r7, #12]
34006bf4:	0a1b      	lsrs	r3, r3, #8
34006bf6:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006bfa:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
34006bfc:	4b3e      	ldr	r3, [pc, #248]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006bfe:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34006c02:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34006c06:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
34006c08:	4b3b      	ldr	r3, [pc, #236]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006c0a:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34006c0e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
34006c10:	68fb      	ldr	r3, [r7, #12]
34006c12:	0edb      	lsrs	r3, r3, #27
34006c14:	f003 0307 	and.w	r3, r3, #7
34006c18:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
34006c1a:	68fb      	ldr	r3, [r7, #12]
34006c1c:	0e1b      	lsrs	r3, r3, #24
34006c1e:	f003 0307 	and.w	r3, r3, #7
34006c22:	61bb      	str	r3, [r7, #24]
      break;
34006c24:	e031      	b.n	34006c8a <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
34006c26:	4b34      	ldr	r3, [pc, #208]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006c28:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34006c2c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
34006c2e:	68fb      	ldr	r3, [r7, #12]
34006c30:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34006c34:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
34006c36:	68fb      	ldr	r3, [r7, #12]
34006c38:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34006c3c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34006c3e:	693b      	ldr	r3, [r7, #16]
34006c40:	2b00      	cmp	r3, #0
34006c42:	d124      	bne.n	34006c8e <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34006c44:	68fb      	ldr	r3, [r7, #12]
34006c46:	0d1b      	lsrs	r3, r3, #20
34006c48:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34006c4c:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
34006c4e:	68fb      	ldr	r3, [r7, #12]
34006c50:	0a1b      	lsrs	r3, r3, #8
34006c52:	f3c3 030b 	ubfx	r3, r3, #0, #12
34006c56:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34006c58:	4b27      	ldr	r3, [pc, #156]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006c5a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34006c5e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34006c62:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34006c64:	4b24      	ldr	r3, [pc, #144]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006c66:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34006c6a:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34006c6c:	68fb      	ldr	r3, [r7, #12]
34006c6e:	0edb      	lsrs	r3, r3, #27
34006c70:	f003 0307 	and.w	r3, r3, #7
34006c74:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34006c76:	68fb      	ldr	r3, [r7, #12]
34006c78:	0e1b      	lsrs	r3, r3, #24
34006c7a:	f003 0307 	and.w	r3, r3, #7
34006c7e:	61bb      	str	r3, [r7, #24]
      break;
34006c80:	e005      	b.n	34006c8e <SystemCoreClockUpdate+0x222>
      break;
34006c82:	bf00      	nop
34006c84:	e004      	b.n	34006c90 <SystemCoreClockUpdate+0x224>
      break;
34006c86:	bf00      	nop
34006c88:	e002      	b.n	34006c90 <SystemCoreClockUpdate+0x224>
      break;
34006c8a:	bf00      	nop
34006c8c:	e000      	b.n	34006c90 <SystemCoreClockUpdate+0x224>
      break;
34006c8e:	bf00      	nop
    switch (pllsource)
34006c90:	697b      	ldr	r3, [r7, #20]
34006c92:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34006c96:	d02c      	beq.n	34006cf2 <SystemCoreClockUpdate+0x286>
34006c98:	697b      	ldr	r3, [r7, #20]
34006c9a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34006c9e:	d839      	bhi.n	34006d14 <SystemCoreClockUpdate+0x2a8>
34006ca0:	697b      	ldr	r3, [r7, #20]
34006ca2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006ca6:	d021      	beq.n	34006cec <SystemCoreClockUpdate+0x280>
34006ca8:	697b      	ldr	r3, [r7, #20]
34006caa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34006cae:	d831      	bhi.n	34006d14 <SystemCoreClockUpdate+0x2a8>
34006cb0:	697b      	ldr	r3, [r7, #20]
34006cb2:	2b00      	cmp	r3, #0
34006cb4:	d004      	beq.n	34006cc0 <SystemCoreClockUpdate+0x254>
34006cb6:	697b      	ldr	r3, [r7, #20]
34006cb8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34006cbc:	d00a      	beq.n	34006cd4 <SystemCoreClockUpdate+0x268>
      break;
34006cbe:	e029      	b.n	34006d14 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34006cc0:	4b0d      	ldr	r3, [pc, #52]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006cc2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34006cc4:	09db      	lsrs	r3, r3, #7
34006cc6:	f003 0303 	and.w	r3, r3, #3
34006cca:	4a0c      	ldr	r2, [pc, #48]	@ (34006cfc <SystemCoreClockUpdate+0x290>)
34006ccc:	fa22 f303 	lsr.w	r3, r2, r3
34006cd0:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34006cd2:	e020      	b.n	34006d16 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34006cd4:	4b08      	ldr	r3, [pc, #32]	@ (34006cf8 <SystemCoreClockUpdate+0x28c>)
34006cd6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006cd8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34006cdc:	2b00      	cmp	r3, #0
34006cde:	d102      	bne.n	34006ce6 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
34006ce0:	4b07      	ldr	r3, [pc, #28]	@ (34006d00 <SystemCoreClockUpdate+0x294>)
34006ce2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34006ce4:	e017      	b.n	34006d16 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
34006ce6:	4b07      	ldr	r3, [pc, #28]	@ (34006d04 <SystemCoreClockUpdate+0x298>)
34006ce8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34006cea:	e014      	b.n	34006d16 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
34006cec:	4b06      	ldr	r3, [pc, #24]	@ (34006d08 <SystemCoreClockUpdate+0x29c>)
34006cee:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34006cf0:	e011      	b.n	34006d16 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
34006cf2:	4b06      	ldr	r3, [pc, #24]	@ (34006d0c <SystemCoreClockUpdate+0x2a0>)
34006cf4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
34006cf6:	e00e      	b.n	34006d16 <SystemCoreClockUpdate+0x2aa>
34006cf8:	56028000 	.word	0x56028000
34006cfc:	03d09000 	.word	0x03d09000
34006d00:	003d0900 	.word	0x003d0900
34006d04:	00f42400 	.word	0x00f42400
34006d08:	02dc6c00 	.word	0x02dc6c00
34006d0c:	00bb8000 	.word	0x00bb8000
34006d10:	4b800000 	.word	0x4b800000
      break;
34006d14:	bf00      	nop
    if (pllbypass == 0U)
34006d16:	693b      	ldr	r3, [r7, #16]
34006d18:	2b00      	cmp	r3, #0
34006d1a:	d134      	bne.n	34006d86 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
34006d1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34006d1e:	ee07 3a90 	vmov	s15, r3
34006d22:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34006d26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34006d28:	ee07 3a90 	vmov	s15, r3
34006d2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
34006d30:	6a3b      	ldr	r3, [r7, #32]
34006d32:	ee07 3a90 	vmov	s15, r3
34006d36:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34006d3a:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 34006d10 <SystemCoreClockUpdate+0x2a4>
34006d3e:	eec6 7a25 	vdiv.f32	s15, s12, s11
34006d42:	ee76 7aa7 	vadd.f32	s15, s13, s15
34006d46:	ee67 6a27 	vmul.f32	s13, s14, s15
34006d4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34006d4c:	ee07 3a90 	vmov	s15, r3
34006d50:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34006d54:	eec6 7a87 	vdiv.f32	s15, s13, s14
34006d58:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34006d5c:	69fb      	ldr	r3, [r7, #28]
34006d5e:	ee07 3a90 	vmov	s15, r3
34006d62:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34006d66:	69bb      	ldr	r3, [r7, #24]
34006d68:	ee07 3a90 	vmov	s15, r3
34006d6c:	eef8 7a67 	vcvt.f32.u32	s15, s15
34006d70:	ee27 7a27 	vmul.f32	s14, s14, s15
34006d74:	edd7 6a02 	vldr	s13, [r7, #8]
34006d78:	eec6 7a87 	vdiv.f32	s15, s13, s14
34006d7c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34006d80:	ee17 3a90 	vmov	r3, s15
34006d84:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34006d86:	4b0b      	ldr	r3, [pc, #44]	@ (34006db4 <SystemCoreClockUpdate+0x348>)
34006d88:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34006d8c:	0c1b      	lsrs	r3, r3, #16
34006d8e:	b2db      	uxtb	r3, r3
34006d90:	3301      	adds	r3, #1
34006d92:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34006d94:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34006d96:	687b      	ldr	r3, [r7, #4]
34006d98:	fbb2 f3f3 	udiv	r3, r2, r3
34006d9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34006d9e:	e000      	b.n	34006da2 <SystemCoreClockUpdate+0x336>
    break;
34006da0:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34006da2:	4a05      	ldr	r2, [pc, #20]	@ (34006db8 <SystemCoreClockUpdate+0x34c>)
34006da4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34006da6:	6013      	str	r3, [r2, #0]
}
34006da8:	bf00      	nop
34006daa:	3734      	adds	r7, #52	@ 0x34
34006dac:	46bd      	mov	sp, r7
34006dae:	f85d 7b04 	ldr.w	r7, [sp], #4
34006db2:	4770      	bx	lr
34006db4:	56028000 	.word	0x56028000
34006db8:	340413c0 	.word	0x340413c0

34006dbc <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34006dbc:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34006dc0:	b588      	push	{r3, r7, lr}
34006dc2:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34006dc4:	f7ff fe52 	bl	34006a6c <SystemCoreClockUpdate>

  return SystemCoreClock;
34006dc8:	4b06      	ldr	r3, [pc, #24]	@ (34006de4 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34006dca:	681b      	ldr	r3, [r3, #0]
}
34006dcc:	4618      	mov	r0, r3
34006dce:	46bd      	mov	sp, r7
34006dd0:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34006dd4:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34006dd8:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34006ddc:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34006de0:	4774      	bxns	lr
34006de2:	bf00      	nop
34006de4:	340413c0 	.word	0x340413c0

34006de8 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
34006de8:	b580      	push	{r7, lr}
34006dea:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34006dec:	2003      	movs	r0, #3
34006dee:	f000 f9c2 	bl	34007176 <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34006df2:	f7ff fe3b 	bl	34006a6c <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
34006df6:	200f      	movs	r0, #15
34006df8:	f7fd ff0e 	bl	34004c18 <HAL_InitTick>
34006dfc:	4603      	mov	r3, r0
34006dfe:	2b00      	cmp	r3, #0
34006e00:	d001      	beq.n	34006e06 <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34006e02:	2301      	movs	r3, #1
34006e04:	e002      	b.n	34006e0c <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
34006e06:	f7fd fbdf 	bl	340045c8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
34006e0a:	2300      	movs	r3, #0
}
34006e0c:	4618      	mov	r0, r3
34006e0e:	bd80      	pop	{r7, pc}

34006e10 <HAL_CACHEAXI_Init>:
  * @note   In case HAL_CACHEAXI_Init() returns HAL_BUSY because an invalidation
  *         procedure is ongoing, the application should call again HAL_CACHEAXI_Init()
  *         until it returns HAL_OK to have the CACHEAXI enabled
  */
HAL_StatusTypeDef  HAL_CACHEAXI_Init(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34006e10:	b580      	push	{r7, lr}
34006e12:	b084      	sub	sp, #16
34006e14:	af00      	add	r7, sp, #0
34006e16:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the CACHEAXI handle allocation */
  if (hcacheaxi == NULL)
34006e18:	687b      	ldr	r3, [r7, #4]
34006e1a:	2b00      	cmp	r3, #0
34006e1c:	d101      	bne.n	34006e22 <HAL_CACHEAXI_Init+0x12>
  {
    return HAL_ERROR;
34006e1e:	2301      	movs	r3, #1
34006e20:	e013      	b.n	34006e4a <HAL_CACHEAXI_Init+0x3a>
  }

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  if (hcacheaxi->State == HAL_CACHEAXI_STATE_RESET)
34006e22:	687b      	ldr	r3, [r7, #4]
34006e24:	791b      	ldrb	r3, [r3, #4]
34006e26:	b2db      	uxtb	r3, r3
34006e28:	2b00      	cmp	r3, #0
34006e2a:	d102      	bne.n	34006e32 <HAL_CACHEAXI_Init+0x22>

    /* Init the low level hardware */
    hcacheaxi->MspInitCallback(hcacheaxi);
#else
    /* Init the low level hardware */
    HAL_CACHEAXI_MspInit(hcacheaxi);
34006e2c:	6878      	ldr	r0, [r7, #4]
34006e2e:	f7fd fed3 	bl	34004bd8 <HAL_CACHEAXI_MspInit>
#endif /* USE_HAL_CACHEAXI_REGISTER_CALLBACKS */
  }

  /* Init the error code */
  hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34006e32:	687b      	ldr	r3, [r7, #4]
34006e34:	2200      	movs	r2, #0
34006e36:	609a      	str	r2, [r3, #8]

  /* Init the CACHEAXI handle state */
  hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34006e38:	687b      	ldr	r3, [r7, #4]
34006e3a:	2201      	movs	r2, #1
34006e3c:	711a      	strb	r2, [r3, #4]

  /* Enable the selected CACHEAXI peripheral */
  status = HAL_CACHEAXI_Enable(hcacheaxi);
34006e3e:	6878      	ldr	r0, [r7, #4]
34006e40:	f000 f807 	bl	34006e52 <HAL_CACHEAXI_Enable>
34006e44:	4603      	mov	r3, r0
34006e46:	73fb      	strb	r3, [r7, #15]

  return status;
34006e48:	7bfb      	ldrb	r3, [r7, #15]
}
34006e4a:	4618      	mov	r0, r3
34006e4c:	3710      	adds	r7, #16
34006e4e:	46bd      	mov	sp, r7
34006e50:	bd80      	pop	{r7, pc}

34006e52 <HAL_CACHEAXI_Enable>:
  * @param  hcacheaxi Pointer to a CACHEAXI_HandleTypeDef structure that contains
  *                   the configuration information for the specified CACHEAXIx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_Enable(CACHEAXI_HandleTypeDef *hcacheaxi)
{
34006e52:	b580      	push	{r7, lr}
34006e54:	b084      	sub	sp, #16
34006e56:	af00      	add	r7, sp, #0
34006e58:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34006e5a:	2300      	movs	r3, #0
34006e5c:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
34006e5e:	687b      	ldr	r3, [r7, #4]
34006e60:	2b00      	cmp	r3, #0
34006e62:	d101      	bne.n	34006e68 <HAL_CACHEAXI_Enable+0x16>
  {
    return HAL_ERROR;
34006e64:	2301      	movs	r3, #1
34006e66:	e034      	b.n	34006ed2 <HAL_CACHEAXI_Enable+0x80>

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));

  /* Check if ongoing full invalidation operation */
  if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34006e68:	687b      	ldr	r3, [r7, #4]
34006e6a:	681b      	ldr	r3, [r3, #0]
34006e6c:	685b      	ldr	r3, [r3, #4]
34006e6e:	f003 0301 	and.w	r3, r3, #1
34006e72:	2b00      	cmp	r3, #0
34006e74:	d01e      	beq.n	34006eb4 <HAL_CACHEAXI_Enable+0x62>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34006e76:	f7fd feda 	bl	34004c2e <HAL_GetTick>
34006e7a:	60b8      	str	r0, [r7, #8]

    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34006e7c:	e013      	b.n	34006ea6 <HAL_CACHEAXI_Enable+0x54>
    {
      if ((HAL_GetTick() - tickstart) > CACHEAXI_ENABLE_TIMEOUT_VALUE)
34006e7e:	f7fd fed6 	bl	34004c2e <HAL_GetTick>
34006e82:	4602      	mov	r2, r0
34006e84:	68bb      	ldr	r3, [r7, #8]
34006e86:	1ad3      	subs	r3, r2, r3
34006e88:	2b01      	cmp	r3, #1
34006e8a:	d90c      	bls.n	34006ea6 <HAL_CACHEAXI_Enable+0x54>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) == 0U)
34006e8c:	687b      	ldr	r3, [r7, #4]
34006e8e:	681b      	ldr	r3, [r3, #0]
34006e90:	685b      	ldr	r3, [r3, #4]
34006e92:	f003 0301 	and.w	r3, r3, #1
34006e96:	2b00      	cmp	r3, #0
34006e98:	d105      	bne.n	34006ea6 <HAL_CACHEAXI_Enable+0x54>
        {
          /* Update error code */
          hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34006e9a:	687b      	ldr	r3, [r7, #4]
34006e9c:	2210      	movs	r2, #16
34006e9e:	609a      	str	r2, [r3, #8]
          /* Return error status */
          status =  HAL_ERROR;
34006ea0:	2301      	movs	r3, #1
34006ea2:	73fb      	strb	r3, [r7, #15]
          break;
34006ea4:	e006      	b.n	34006eb4 <HAL_CACHEAXI_Enable+0x62>
    while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_BUSYF) != 0U)
34006ea6:	687b      	ldr	r3, [r7, #4]
34006ea8:	681b      	ldr	r3, [r3, #0]
34006eaa:	685b      	ldr	r3, [r3, #4]
34006eac:	f003 0301 	and.w	r3, r3, #1
34006eb0:	2b00      	cmp	r3, #0
34006eb2:	d1e4      	bne.n	34006e7e <HAL_CACHEAXI_Enable+0x2c>
        }
      }
    }
  }

  if (status == HAL_OK)
34006eb4:	7bfb      	ldrb	r3, [r7, #15]
34006eb6:	2b00      	cmp	r3, #0
34006eb8:	d10a      	bne.n	34006ed0 <HAL_CACHEAXI_Enable+0x7e>
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34006eba:	687b      	ldr	r3, [r7, #4]
34006ebc:	2200      	movs	r2, #0
34006ebe:	609a      	str	r2, [r3, #8]
    /* Enable the selected CACHEAXI peripheral */
    SET_BIT(hcacheaxi->Instance->CR1, CACHEAXI_CR1_EN);
34006ec0:	687b      	ldr	r3, [r7, #4]
34006ec2:	681b      	ldr	r3, [r3, #0]
34006ec4:	681a      	ldr	r2, [r3, #0]
34006ec6:	687b      	ldr	r3, [r7, #4]
34006ec8:	681b      	ldr	r3, [r3, #0]
34006eca:	f042 0201 	orr.w	r2, r2, #1
34006ece:	601a      	str	r2, [r3, #0]
  }

  return status;
34006ed0:	7bfb      	ldrb	r3, [r7, #15]
}
34006ed2:	4618      	mov	r0, r3
34006ed4:	3710      	adds	r7, #16
34006ed6:	46bd      	mov	sp, r7
34006ed8:	bd80      	pop	{r7, pc}

34006eda <HAL_CACHEAXI_CleanInvalidByAddr>:
  * @note   This function waits for end of cache Clean and Invalidation
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CACHEAXI_CleanInvalidByAddr(CACHEAXI_HandleTypeDef *hcacheaxi, const uint32_t *const pAddr,
                                                  uint32_t dSize)
{
34006eda:	b580      	push	{r7, lr}
34006edc:	b088      	sub	sp, #32
34006ede:	af02      	add	r7, sp, #8
34006ee0:	60f8      	str	r0, [r7, #12]
34006ee2:	60b9      	str	r1, [r7, #8]
34006ee4:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;

  /* Check the cacheaxi handle allocation */
  if (hcacheaxi == NULL)
34006ee6:	68fb      	ldr	r3, [r7, #12]
34006ee8:	2b00      	cmp	r3, #0
34006eea:	d101      	bne.n	34006ef0 <HAL_CACHEAXI_CleanInvalidByAddr+0x16>
  {
    return HAL_ERROR;
34006eec:	2301      	movs	r3, #1
34006eee:	e00a      	b.n	34006f06 <HAL_CACHEAXI_CleanInvalidByAddr+0x2c>

  /* Check the parameters */
  assert_param(IS_CACHEAXI_ALL_INSTANCE(hcacheaxi->Instance));
  assert_param(IS_CACHEAXI_REGION_SIZE(dSize));

  status = CACHEAXI_CommandByAddr(hcacheaxi, CACHEAXI_COMMAND_CLEAN_INVALIDATE, pAddr, dSize, CACHEAXI_POLLING_MODE);
34006ef0:	2300      	movs	r3, #0
34006ef2:	9300      	str	r3, [sp, #0]
34006ef4:	687b      	ldr	r3, [r7, #4]
34006ef6:	68ba      	ldr	r2, [r7, #8]
34006ef8:	2106      	movs	r1, #6
34006efa:	68f8      	ldr	r0, [r7, #12]
34006efc:	f000 f807 	bl	34006f0e <CACHEAXI_CommandByAddr>
34006f00:	4603      	mov	r3, r0
34006f02:	75fb      	strb	r3, [r7, #23]

  return status;
34006f04:	7dfb      	ldrb	r3, [r7, #23]
}
34006f06:	4618      	mov	r0, r3
34006f08:	3718      	adds	r7, #24
34006f0a:	46bd      	mov	sp, r7
34006f0c:	bd80      	pop	{r7, pc}

34006f0e <CACHEAXI_CommandByAddr>:
  *                       CACHEAXI_IT_MODE, CACHEAXI_POLLING_MODE.
  * @retval HAL status
  */
static HAL_StatusTypeDef CACHEAXI_CommandByAddr(CACHEAXI_HandleTypeDef *hcacheaxi, uint32_t Command,
                                                const uint32_t *pAddr, uint32_t dSize, uint32_t mode)
{
34006f0e:	b580      	push	{r7, lr}
34006f10:	b088      	sub	sp, #32
34006f12:	af00      	add	r7, sp, #0
34006f14:	60f8      	str	r0, [r7, #12]
34006f16:	60b9      	str	r1, [r7, #8]
34006f18:	607a      	str	r2, [r7, #4]
34006f1a:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34006f1c:	2300      	movs	r3, #0
34006f1e:	77fb      	strb	r3, [r7, #31]
  uint32_t op_addr = (uint32_t)pAddr;
34006f20:	687b      	ldr	r3, [r7, #4]
34006f22:	61bb      	str	r3, [r7, #24]
  uint32_t tickstart;

  /* Check no ongoing operation */
  if (READ_BIT(hcacheaxi->Instance->SR, (CACHEAXI_SR_BUSYF | CACHEAXI_SR_BUSYCMDF)) != 0U)
34006f24:	68fb      	ldr	r3, [r7, #12]
34006f26:	681b      	ldr	r3, [r3, #0]
34006f28:	685b      	ldr	r3, [r3, #4]
34006f2a:	f003 0309 	and.w	r3, r3, #9
34006f2e:	2b00      	cmp	r3, #0
34006f30:	d002      	beq.n	34006f38 <CACHEAXI_CommandByAddr+0x2a>
  {
    /* Return busy status */
    status =  HAL_BUSY;
34006f32:	2302      	movs	r3, #2
34006f34:	77fb      	strb	r3, [r7, #31]
34006f36:	e06c      	b.n	34007012 <CACHEAXI_CommandByAddr+0x104>
  }
  else
  {
    /* Update the error code */
    hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_NONE;
34006f38:	68fb      	ldr	r3, [r7, #12]
34006f3a:	2200      	movs	r2, #0
34006f3c:	609a      	str	r2, [r3, #8]

    /* Update the CACHEAXI handle State */
    hcacheaxi->State = HAL_CACHEAXI_STATE_READY;
34006f3e:	68fb      	ldr	r3, [r7, #12]
34006f40:	2201      	movs	r2, #1
34006f42:	711a      	strb	r2, [r3, #4]

    /* Make sure flags are reset */
    WRITE_REG(hcacheaxi->Instance->FCR, (CACHEAXI_FCR_CBSYENDF | CACHEAXI_FCR_CCMDENDF));
34006f44:	68fb      	ldr	r3, [r7, #12]
34006f46:	681b      	ldr	r3, [r3, #0]
34006f48:	2212      	movs	r2, #18
34006f4a:	60da      	str	r2, [r3, #12]

    /* Fill area start address */
    WRITE_REG(hcacheaxi->Instance->CMDRSADDRR, op_addr);
34006f4c:	68fb      	ldr	r3, [r7, #12]
34006f4e:	681b      	ldr	r3, [r3, #0]
34006f50:	69ba      	ldr	r2, [r7, #24]
34006f52:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Fill area end address */
    WRITE_REG(hcacheaxi->Instance->CMDREADDRR, (op_addr + dSize - 1U));
34006f56:	69ba      	ldr	r2, [r7, #24]
34006f58:	683b      	ldr	r3, [r7, #0]
34006f5a:	441a      	add	r2, r3
34006f5c:	68fb      	ldr	r3, [r7, #12]
34006f5e:	681b      	ldr	r3, [r3, #0]
34006f60:	3a01      	subs	r2, #1
34006f62:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

    /* Set command */
    MODIFY_REG(hcacheaxi->Instance->CR2, CACHEAXI_CR2_CACHECMD, Command);
34006f66:	68fb      	ldr	r3, [r7, #12]
34006f68:	681b      	ldr	r3, [r3, #0]
34006f6a:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34006f6e:	f023 0106 	bic.w	r1, r3, #6
34006f72:	68fb      	ldr	r3, [r7, #12]
34006f74:	681b      	ldr	r3, [r3, #0]
34006f76:	68ba      	ldr	r2, [r7, #8]
34006f78:	430a      	orrs	r2, r1
34006f7a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

    /* Enable IT if required */
    if (mode == CACHEAXI_IT_MODE)
34006f7e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34006f80:	2b01      	cmp	r3, #1
34006f82:	d112      	bne.n	34006faa <CACHEAXI_CommandByAddr+0x9c>
    {
      /* Enable end of cache command interrupt */
      SET_BIT(hcacheaxi->Instance->IER, CACHEAXI_IER_CMDENDIE);
34006f84:	68fb      	ldr	r3, [r7, #12]
34006f86:	681b      	ldr	r3, [r3, #0]
34006f88:	689a      	ldr	r2, [r3, #8]
34006f8a:	68fb      	ldr	r3, [r7, #12]
34006f8c:	681b      	ldr	r3, [r3, #0]
34006f8e:	f042 0210 	orr.w	r2, r2, #16
34006f92:	609a      	str	r2, [r3, #8]

      /* Launch cache command */
      SET_BIT(hcacheaxi->Instance->CR2, CACHEAXI_CR2_STARTCMD);
34006f94:	68fb      	ldr	r3, [r7, #12]
34006f96:	681b      	ldr	r3, [r3, #0]
34006f98:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34006f9c:	68fb      	ldr	r3, [r7, #12]
34006f9e:	681b      	ldr	r3, [r3, #0]
34006fa0:	f042 0201 	orr.w	r2, r2, #1
34006fa4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
34006fa8:	e033      	b.n	34007012 <CACHEAXI_CommandByAddr+0x104>
    }
    else
    {
      /* Make sure that end of cache command interrupt is disabled */
      CLEAR_BIT(hcacheaxi->Instance->IER, CACHEAXI_IER_CMDENDIE);
34006faa:	68fb      	ldr	r3, [r7, #12]
34006fac:	681b      	ldr	r3, [r3, #0]
34006fae:	689a      	ldr	r2, [r3, #8]
34006fb0:	68fb      	ldr	r3, [r7, #12]
34006fb2:	681b      	ldr	r3, [r3, #0]
34006fb4:	f022 0210 	bic.w	r2, r2, #16
34006fb8:	609a      	str	r2, [r3, #8]

      /* Launch cache command */
      SET_BIT(hcacheaxi->Instance->CR2, CACHEAXI_CR2_STARTCMD);
34006fba:	68fb      	ldr	r3, [r7, #12]
34006fbc:	681b      	ldr	r3, [r3, #0]
34006fbe:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34006fc2:	68fb      	ldr	r3, [r7, #12]
34006fc4:	681b      	ldr	r3, [r3, #0]
34006fc6:	f042 0201 	orr.w	r2, r2, #1
34006fca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Get timeout */
      tickstart = HAL_GetTick();
34006fce:	f7fd fe2e 	bl	34004c2e <HAL_GetTick>
34006fd2:	6178      	str	r0, [r7, #20]

      /* Wait for end of cache command */
      while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_CMDENDF) == 0U)
34006fd4:	e016      	b.n	34007004 <CACHEAXI_CommandByAddr+0xf6>
      {
        if ((HAL_GetTick() - tickstart) > CACHEAXI_COMMAND_TIMEOUT_VALUE)
34006fd6:	f7fd fe2a 	bl	34004c2e <HAL_GetTick>
34006fda:	4602      	mov	r2, r0
34006fdc:	697b      	ldr	r3, [r7, #20]
34006fde:	1ad3      	subs	r3, r2, r3
34006fe0:	2bc8      	cmp	r3, #200	@ 0xc8
34006fe2:	d90f      	bls.n	34007004 <CACHEAXI_CommandByAddr+0xf6>
        {
          if (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_CMDENDF) == 0U)
34006fe4:	68fb      	ldr	r3, [r7, #12]
34006fe6:	681b      	ldr	r3, [r3, #0]
34006fe8:	685b      	ldr	r3, [r3, #4]
34006fea:	f003 0310 	and.w	r3, r3, #16
34006fee:	2b00      	cmp	r3, #0
34006ff0:	d108      	bne.n	34007004 <CACHEAXI_CommandByAddr+0xf6>
          {
            /* Update error code */
            hcacheaxi->ErrorCode = HAL_CACHEAXI_ERROR_TIMEOUT;
34006ff2:	68fb      	ldr	r3, [r7, #12]
34006ff4:	2210      	movs	r2, #16
34006ff6:	609a      	str	r2, [r3, #8]

            /* Change the CACHEAXI state */
            hcacheaxi->State = HAL_CACHEAXI_STATE_ERROR;
34006ff8:	68fb      	ldr	r3, [r7, #12]
34006ffa:	2206      	movs	r2, #6
34006ffc:	711a      	strb	r2, [r3, #4]

            /* Return error status */
            status =  HAL_ERROR;
34006ffe:	2301      	movs	r3, #1
34007000:	77fb      	strb	r3, [r7, #31]
            break;
34007002:	e006      	b.n	34007012 <CACHEAXI_CommandByAddr+0x104>
      while (READ_BIT(hcacheaxi->Instance->SR, CACHEAXI_SR_CMDENDF) == 0U)
34007004:	68fb      	ldr	r3, [r7, #12]
34007006:	681b      	ldr	r3, [r3, #0]
34007008:	685b      	ldr	r3, [r3, #4]
3400700a:	f003 0310 	and.w	r3, r3, #16
3400700e:	2b00      	cmp	r3, #0
34007010:	d0e1      	beq.n	34006fd6 <CACHEAXI_CommandByAddr+0xc8>
        }
      }
    }
  }

  return status;
34007012:	7ffb      	ldrb	r3, [r7, #31]
}
34007014:	4618      	mov	r0, r3
34007016:	3720      	adds	r7, #32
34007018:	46bd      	mov	sp, r7
3400701a:	bd80      	pop	{r7, pc}

3400701c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3400701c:	b480      	push	{r7}
3400701e:	b085      	sub	sp, #20
34007020:	af00      	add	r7, sp, #0
34007022:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34007024:	687b      	ldr	r3, [r7, #4]
34007026:	f003 0307 	and.w	r3, r3, #7
3400702a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
3400702c:	4b0c      	ldr	r3, [pc, #48]	@ (34007060 <__NVIC_SetPriorityGrouping+0x44>)
3400702e:	68db      	ldr	r3, [r3, #12]
34007030:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34007032:	68ba      	ldr	r2, [r7, #8]
34007034:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34007038:	4013      	ands	r3, r2
3400703a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3400703c:	68fb      	ldr	r3, [r7, #12]
3400703e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34007040:	68bb      	ldr	r3, [r7, #8]
34007042:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34007044:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34007048:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
3400704c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
3400704e:	4a04      	ldr	r2, [pc, #16]	@ (34007060 <__NVIC_SetPriorityGrouping+0x44>)
34007050:	68bb      	ldr	r3, [r7, #8]
34007052:	60d3      	str	r3, [r2, #12]
}
34007054:	bf00      	nop
34007056:	3714      	adds	r7, #20
34007058:	46bd      	mov	sp, r7
3400705a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400705e:	4770      	bx	lr
34007060:	e000ed00 	.word	0xe000ed00

34007064 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34007064:	b480      	push	{r7}
34007066:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34007068:	4b04      	ldr	r3, [pc, #16]	@ (3400707c <__NVIC_GetPriorityGrouping+0x18>)
3400706a:	68db      	ldr	r3, [r3, #12]
3400706c:	0a1b      	lsrs	r3, r3, #8
3400706e:	f003 0307 	and.w	r3, r3, #7
}
34007072:	4618      	mov	r0, r3
34007074:	46bd      	mov	sp, r7
34007076:	f85d 7b04 	ldr.w	r7, [sp], #4
3400707a:	4770      	bx	lr
3400707c:	e000ed00 	.word	0xe000ed00

34007080 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
34007080:	b480      	push	{r7}
34007082:	b083      	sub	sp, #12
34007084:	af00      	add	r7, sp, #0
34007086:	4603      	mov	r3, r0
34007088:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3400708a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3400708e:	2b00      	cmp	r3, #0
34007090:	db0b      	blt.n	340070aa <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
34007092:	88fb      	ldrh	r3, [r7, #6]
34007094:	f003 021f 	and.w	r2, r3, #31
34007098:	4907      	ldr	r1, [pc, #28]	@ (340070b8 <__NVIC_EnableIRQ+0x38>)
3400709a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3400709e:	095b      	lsrs	r3, r3, #5
340070a0:	2001      	movs	r0, #1
340070a2:	fa00 f202 	lsl.w	r2, r0, r2
340070a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
340070aa:	bf00      	nop
340070ac:	370c      	adds	r7, #12
340070ae:	46bd      	mov	sp, r7
340070b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340070b4:	4770      	bx	lr
340070b6:	bf00      	nop
340070b8:	e000e100 	.word	0xe000e100

340070bc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
340070bc:	b480      	push	{r7}
340070be:	b083      	sub	sp, #12
340070c0:	af00      	add	r7, sp, #0
340070c2:	4603      	mov	r3, r0
340070c4:	6039      	str	r1, [r7, #0]
340070c6:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
340070c8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340070cc:	2b00      	cmp	r3, #0
340070ce:	db0a      	blt.n	340070e6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340070d0:	683b      	ldr	r3, [r7, #0]
340070d2:	b2da      	uxtb	r2, r3
340070d4:	490c      	ldr	r1, [pc, #48]	@ (34007108 <__NVIC_SetPriority+0x4c>)
340070d6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340070da:	0112      	lsls	r2, r2, #4
340070dc:	b2d2      	uxtb	r2, r2
340070de:	440b      	add	r3, r1
340070e0:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
340070e4:	e00a      	b.n	340070fc <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340070e6:	683b      	ldr	r3, [r7, #0]
340070e8:	b2da      	uxtb	r2, r3
340070ea:	4908      	ldr	r1, [pc, #32]	@ (3400710c <__NVIC_SetPriority+0x50>)
340070ec:	88fb      	ldrh	r3, [r7, #6]
340070ee:	f003 030f 	and.w	r3, r3, #15
340070f2:	3b04      	subs	r3, #4
340070f4:	0112      	lsls	r2, r2, #4
340070f6:	b2d2      	uxtb	r2, r2
340070f8:	440b      	add	r3, r1
340070fa:	761a      	strb	r2, [r3, #24]
}
340070fc:	bf00      	nop
340070fe:	370c      	adds	r7, #12
34007100:	46bd      	mov	sp, r7
34007102:	f85d 7b04 	ldr.w	r7, [sp], #4
34007106:	4770      	bx	lr
34007108:	e000e100 	.word	0xe000e100
3400710c:	e000ed00 	.word	0xe000ed00

34007110 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34007110:	b480      	push	{r7}
34007112:	b089      	sub	sp, #36	@ 0x24
34007114:	af00      	add	r7, sp, #0
34007116:	60f8      	str	r0, [r7, #12]
34007118:	60b9      	str	r1, [r7, #8]
3400711a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
3400711c:	68fb      	ldr	r3, [r7, #12]
3400711e:	f003 0307 	and.w	r3, r3, #7
34007122:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34007124:	69fb      	ldr	r3, [r7, #28]
34007126:	f1c3 0307 	rsb	r3, r3, #7
3400712a:	2b04      	cmp	r3, #4
3400712c:	bf28      	it	cs
3400712e:	2304      	movcs	r3, #4
34007130:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34007132:	69fb      	ldr	r3, [r7, #28]
34007134:	3304      	adds	r3, #4
34007136:	2b06      	cmp	r3, #6
34007138:	d902      	bls.n	34007140 <NVIC_EncodePriority+0x30>
3400713a:	69fb      	ldr	r3, [r7, #28]
3400713c:	3b03      	subs	r3, #3
3400713e:	e000      	b.n	34007142 <NVIC_EncodePriority+0x32>
34007140:	2300      	movs	r3, #0
34007142:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34007144:	f04f 32ff 	mov.w	r2, #4294967295
34007148:	69bb      	ldr	r3, [r7, #24]
3400714a:	fa02 f303 	lsl.w	r3, r2, r3
3400714e:	43da      	mvns	r2, r3
34007150:	68bb      	ldr	r3, [r7, #8]
34007152:	401a      	ands	r2, r3
34007154:	697b      	ldr	r3, [r7, #20]
34007156:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34007158:	f04f 31ff 	mov.w	r1, #4294967295
3400715c:	697b      	ldr	r3, [r7, #20]
3400715e:	fa01 f303 	lsl.w	r3, r1, r3
34007162:	43d9      	mvns	r1, r3
34007164:	687b      	ldr	r3, [r7, #4]
34007166:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34007168:	4313      	orrs	r3, r2
         );
}
3400716a:	4618      	mov	r0, r3
3400716c:	3724      	adds	r7, #36	@ 0x24
3400716e:	46bd      	mov	sp, r7
34007170:	f85d 7b04 	ldr.w	r7, [sp], #4
34007174:	4770      	bx	lr

34007176 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
34007176:	b580      	push	{r7, lr}
34007178:	b082      	sub	sp, #8
3400717a:	af00      	add	r7, sp, #0
3400717c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
3400717e:	6878      	ldr	r0, [r7, #4]
34007180:	f7ff ff4c 	bl	3400701c <__NVIC_SetPriorityGrouping>
}
34007184:	bf00      	nop
34007186:	3708      	adds	r7, #8
34007188:	46bd      	mov	sp, r7
3400718a:	bd80      	pop	{r7, pc}

3400718c <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
3400718c:	b580      	push	{r7, lr}
3400718e:	b086      	sub	sp, #24
34007190:	af00      	add	r7, sp, #0
34007192:	4603      	mov	r3, r0
34007194:	60b9      	str	r1, [r7, #8]
34007196:	607a      	str	r2, [r7, #4]
34007198:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
3400719a:	f7ff ff63 	bl	34007064 <__NVIC_GetPriorityGrouping>
3400719e:	4603      	mov	r3, r0
340071a0:	f003 0307 	and.w	r3, r3, #7
340071a4:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
340071a6:	687a      	ldr	r2, [r7, #4]
340071a8:	68b9      	ldr	r1, [r7, #8]
340071aa:	6978      	ldr	r0, [r7, #20]
340071ac:	f7ff ffb0 	bl	34007110 <NVIC_EncodePriority>
340071b0:	4602      	mov	r2, r0
340071b2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
340071b6:	4611      	mov	r1, r2
340071b8:	4618      	mov	r0, r3
340071ba:	f7ff ff7f 	bl	340070bc <__NVIC_SetPriority>
}
340071be:	bf00      	nop
340071c0:	3718      	adds	r7, #24
340071c2:	46bd      	mov	sp, r7
340071c4:	bd80      	pop	{r7, pc}

340071c6 <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
340071c6:	b580      	push	{r7, lr}
340071c8:	b082      	sub	sp, #8
340071ca:	af00      	add	r7, sp, #0
340071cc:	4603      	mov	r3, r0
340071ce:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
340071d0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340071d4:	4618      	mov	r0, r3
340071d6:	f7ff ff53 	bl	34007080 <__NVIC_EnableIRQ>
}
340071da:	bf00      	nop
340071dc:	3708      	adds	r7, #8
340071de:	46bd      	mov	sp, r7
340071e0:	bd80      	pop	{r7, pc}

340071e2 <HAL_DCMIPP_Init>:
  * @brief  Initialize the selected HAL DCMIPP handle and associate a DCMIPP peripheral instance.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_Init(DCMIPP_HandleTypeDef *hdcmipp)
{
340071e2:	b580      	push	{r7, lr}
340071e4:	b084      	sub	sp, #16
340071e6:	af00      	add	r7, sp, #0
340071e8:	6078      	str	r0, [r7, #4]
  uint32_t pipe_index;

  /* Check pointer validity */
  if (hdcmipp == NULL)
340071ea:	687b      	ldr	r3, [r7, #4]
340071ec:	2b00      	cmp	r3, #0
340071ee:	d101      	bne.n	340071f4 <HAL_DCMIPP_Init+0x12>
  {
    return HAL_ERROR;
340071f0:	2301      	movs	r3, #1
340071f2:	e020      	b.n	34007236 <HAL_DCMIPP_Init+0x54>
  }

  /* Check function parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));

  if (hdcmipp->State == HAL_DCMIPP_STATE_RESET)
340071f4:	687b      	ldr	r3, [r7, #4]
340071f6:	791b      	ldrb	r3, [r3, #4]
340071f8:	b2db      	uxtb	r3, r3
340071fa:	2b00      	cmp	r3, #0
340071fc:	d102      	bne.n	34007204 <HAL_DCMIPP_Init+0x22>
    }
    /* Initialize the low level hardware (MSP) */
    hdcmipp->MspInitCallback(hdcmipp);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMIPP_MspInit(hdcmipp);
340071fe:	6878      	ldr	r0, [r7, #4]
34007200:	f014 fd50 	bl	3401bca4 <HAL_DCMIPP_MspInit>
#endif /* (USE_HAL_DCMIPP_REGISTER_CALLBACKS) */
  }

  /* Change the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_BUSY;
34007204:	687b      	ldr	r3, [r7, #4]
34007206:	2203      	movs	r2, #3
34007208:	711a      	strb	r2, [r3, #4]

  /* Reset DCMIPP Pipe state */
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
3400720a:	2300      	movs	r3, #0
3400720c:	60fb      	str	r3, [r7, #12]
3400720e:	e008      	b.n	34007222 <HAL_DCMIPP_Init+0x40>
  {
    hdcmipp->PipeState[pipe_index] = HAL_DCMIPP_PIPE_STATE_RESET;
34007210:	687a      	ldr	r2, [r7, #4]
34007212:	68fb      	ldr	r3, [r7, #12]
34007214:	4413      	add	r3, r2
34007216:	3305      	adds	r3, #5
34007218:	2200      	movs	r2, #0
3400721a:	701a      	strb	r2, [r3, #0]
  for (pipe_index = 0U; pipe_index < DCMIPP_NUM_OF_PIPES; pipe_index++)
3400721c:	68fb      	ldr	r3, [r7, #12]
3400721e:	3301      	adds	r3, #1
34007220:	60fb      	str	r3, [r7, #12]
34007222:	68fb      	ldr	r3, [r7, #12]
34007224:	2b02      	cmp	r3, #2
34007226:	d9f3      	bls.n	34007210 <HAL_DCMIPP_Init+0x2e>
  }

  /* Update error code */
  hdcmipp->ErrorCode = HAL_DCMIPP_ERROR_NONE;
34007228:	687b      	ldr	r3, [r7, #4]
3400722a:	2200      	movs	r2, #0
3400722c:	609a      	str	r2, [r3, #8]

  /* Update the DCMIPP state*/
  hdcmipp->State = HAL_DCMIPP_STATE_INIT;
3400722e:	687b      	ldr	r3, [r7, #4]
34007230:	2201      	movs	r2, #1
34007232:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34007234:	2300      	movs	r3, #0
}
34007236:	4618      	mov	r0, r3
34007238:	3710      	adds	r7, #16
3400723a:	46bd      	mov	sp, r7
3400723c:	bd80      	pop	{r7, pc}
	...

34007240 <HAL_DCMIPP_CSI_SetConfig>:
  *                     configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetConfig(const DCMIPP_HandleTypeDef *hdcmipp,
                                           const DCMIPP_CSI_ConfTypeDef *pCSI_Config)
{
34007240:	b580      	push	{r7, lr}
34007242:	f5ad 7d02 	sub.w	sp, sp, #520	@ 0x208
34007246:	af00      	add	r7, sp, #0
34007248:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400724c:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
34007250:	6018      	str	r0, [r3, #0]
34007252:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34007256:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3400725a:	6019      	str	r1, [r3, #0]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
3400725c:	4ba8      	ldr	r3, [pc, #672]	@ (34007500 <HAL_DCMIPP_CSI_SetConfig+0x2c0>)
3400725e:	f8c7 3204 	str.w	r3, [r7, #516]	@ 0x204

  const SNPS_FreqsTypeDef SNPS_Freqs[63] =
34007262:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34007266:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
3400726a:	4aa6      	ldr	r2, [pc, #664]	@ (34007504 <HAL_DCMIPP_CSI_SetConfig+0x2c4>)
3400726c:	4618      	mov	r0, r3
3400726e:	4611      	mov	r1, r2
34007270:	f44f 73fc 	mov.w	r3, #504	@ 0x1f8
34007274:	461a      	mov	r2, r3
34007276:	f020 fa1c 	bl	340276b2 <memcpy>
    { 0x48U, 451U },  /* HAL_CSI_BT_2450 */
    { 0x49U, 460U },  /* HAL_CSI_BT_2500 */
  };

  /* Check parameters */
  if ((hdcmipp == NULL) || (pCSI_Config == NULL))
3400727a:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400727e:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
34007282:	681b      	ldr	r3, [r3, #0]
34007284:	2b00      	cmp	r3, #0
34007286:	d006      	beq.n	34007296 <HAL_DCMIPP_CSI_SetConfig+0x56>
34007288:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400728c:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34007290:	681b      	ldr	r3, [r3, #0]
34007292:	2b00      	cmp	r3, #0
34007294:	d101      	bne.n	3400729a <HAL_DCMIPP_CSI_SetConfig+0x5a>
  {
    return HAL_ERROR;
34007296:	2301      	movs	r3, #1
34007298:	e12c      	b.n	340074f4 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  assert_param(IS_DCMIPP_NUMBER_OF_LANES(pCSI_Config->NumberOfLanes));
  assert_param(IS_DCMIPP_CSI_DATA_LANE_MAPPING(pCSI_Config->DataLaneMapping));
  assert_param(IS_DCMIPP_CSI_DATA_PHY_BITRATE(pCSI_Config->PHYBitrate));

  /* Ensure the CSI is disabled */
  CLEAR_BIT(csi_instance->CR, CSI_CR_CSIEN);
3400729a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3400729e:	681b      	ldr	r3, [r3, #0]
340072a0:	f023 0201 	bic.w	r2, r3, #1
340072a4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340072a8:	601a      	str	r2, [r3, #0]

  /* Configure the Lane Merger */
  if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
340072aa:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340072ae:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340072b2:	681b      	ldr	r3, [r3, #0]
340072b4:	685b      	ldr	r3, [r3, #4]
340072b6:	2b01      	cmp	r3, #1
340072b8:	d10b      	bne.n	340072d2 <HAL_DCMIPP_CSI_SetConfig+0x92>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL0MAP_Pos) | \
340072ba:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340072be:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340072c2:	681b      	ldr	r3, [r3, #0]
340072c4:	681b      	ldr	r3, [r3, #0]
340072c6:	f443 1204 	orr.w	r2, r3, #2162688	@ 0x210000
340072ca:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340072ce:	671a      	str	r2, [r3, #112]	@ 0x70
340072d0:	e015      	b.n	340072fe <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_INVERTED_DATA_LANES)
340072d2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340072d6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340072da:	681b      	ldr	r3, [r3, #0]
340072dc:	685b      	ldr	r3, [r3, #4]
340072de:	2b02      	cmp	r3, #2
340072e0:	d10b      	bne.n	340072fa <HAL_DCMIPP_CSI_SetConfig+0xba>
  {
    WRITE_REG(csi_instance->LMCFGR, pCSI_Config->NumberOfLanes | (DCMIPP_CSI_DATA_LANE1 << CSI_LMCFGR_DL0MAP_Pos) | \
340072e2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340072e6:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340072ea:	681b      	ldr	r3, [r3, #0]
340072ec:	681b      	ldr	r3, [r3, #0]
340072ee:	f443 1290 	orr.w	r2, r3, #1179648	@ 0x120000
340072f2:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340072f6:	671a      	str	r2, [r3, #112]	@ 0x70
340072f8:	e001      	b.n	340072fe <HAL_DCMIPP_CSI_SetConfig+0xbe>
              (DCMIPP_CSI_DATA_LANE0 << CSI_LMCFGR_DL1MAP_Pos));
  }
  else
  {
    return HAL_ERROR;
340072fa:	2301      	movs	r3, #1
340072fc:	e0fa      	b.n	340074f4 <HAL_DCMIPP_CSI_SetConfig+0x2b4>
  }

  /* Enable the CSI */
  SET_BIT(csi_instance->CR, CSI_CR_CSIEN);
340072fe:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007302:	681b      	ldr	r3, [r3, #0]
34007304:	f043 0201 	orr.w	r2, r3, #1
34007308:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3400730c:	601a      	str	r2, [r3, #0]

  /* Enable some interrupts, not related to virtual channels - all error cases */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO |  DCMIPP_CSI_IT_SYNCERR | \
3400730e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007312:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007316:	f043 43b0 	orr.w	r3, r3, #1476395008	@ 0x58000000
3400731a:	f443 1304 	orr.w	r3, r3, #2162688	@ 0x210000
3400731e:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34007322:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
                             DCMIPP_CSI_IT_SPKTERR | DCMIPP_CSI_IT_IDERR | \
                             DCMIPP_CSI_IT_SPKT);

  /* Enable D-PHY Interrupts */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
34007326:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400732a:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3400732e:	681b      	ldr	r3, [r3, #0]
34007330:	681b      	ldr	r3, [r3, #0]
34007332:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34007336:	d11d      	bne.n	34007374 <HAL_DCMIPP_CSI_SetConfig+0x134>
  {
    if (pCSI_Config->DataLaneMapping == DCMIPP_CSI_PHYSICAL_DATA_LANES)
34007338:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400733c:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34007340:	681b      	ldr	r3, [r3, #0]
34007342:	685b      	ldr	r3, [r3, #4]
34007344:	2b01      	cmp	r3, #1
34007346:	d10a      	bne.n	3400735e <HAL_DCMIPP_CSI_SetConfig+0x11e>
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0 | DCMIPP_CSI_IT_ESOTSYNCDL0 |
34007348:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3400734c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34007350:	f043 021f 	orr.w	r2, r3, #31
34007354:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007358:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
3400735c:	e016      	b.n	3400738c <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_EESCDL0 | DCMIPP_CSI_IT_ESYNCESCDL0 |
                                      DCMIPP_CSI_IT_ECTRLDL0);
    }
    else
    {
      __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
3400735e:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007362:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34007366:	f443 52f8 	orr.w	r2, r3, #7936	@ 0x1f00
3400736a:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
3400736e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
34007372:	e00b      	b.n	3400738c <HAL_DCMIPP_CSI_SetConfig+0x14c>
                                      DCMIPP_CSI_IT_ECTRLDL1);
    }
  }
  else
  {
    __HAL_DCMIPP_CSI_DPHY_ENABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1 | DCMIPP_CSI_IT_ESOTSYNCDL1 |
34007374:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007378:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400737c:	f443 53f8 	orr.w	r3, r3, #7936	@ 0x1f00
34007380:	f043 031f 	orr.w	r3, r3, #31
34007384:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
34007388:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                    DCMIPP_CSI_IT_ECTRLDL0);
  }

  /* Start D-PHY Configuration */
  /* Stop the D-PHY */
  CLEAR_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
3400738c:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
34007390:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34007394:	681b      	ldr	r3, [r3, #0]
34007396:	f023 0302 	bic.w	r3, r3, #2
3400739a:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3400739e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340073a2:	6013      	str	r3, [r2, #0]

  /* Get the D-PHY enabledb but with all lanes disabled */
  CLEAR_REG(csi_instance-> PCR);
340073a4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340073a8:	2200      	movs	r2, #0
340073aa:	605a      	str	r2, [r3, #4]

  /* Set the testclk (clock enable) on during 15ns */
  SET_BIT(csi_instance->PTCR0, CSI_PTCR0_TCKEN);
340073ac:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340073b0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340073b4:	691b      	ldr	r3, [r3, #16]
340073b6:	f043 0301 	orr.w	r3, r3, #1
340073ba:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
340073be:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340073c2:	6113      	str	r3, [r2, #16]

  HAL_Delay(1);
340073c4:	2001      	movs	r0, #1
340073c6:	f7fd fc39 	bl	34004c3c <HAL_Delay>

  CLEAR_REG(csi_instance->PTCR0);
340073ca:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340073ce:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340073d2:	461a      	mov	r2, r3
340073d4:	2300      	movs	r3, #0
340073d6:	6113      	str	r3, [r2, #16]

  /* Set hsfreqrange */
  MODIFY_REG(csi_instance->PFCR, CSI_PFCR_HSFR, (0x28U << CSI_PFCR_CCFR_Pos) |
340073d8:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340073dc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340073e0:	689b      	ldr	r3, [r3, #8]
340073e2:	f423 42fe 	bic.w	r2, r3, #32512	@ 0x7f00
340073e6:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340073ea:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340073ee:	681b      	ldr	r3, [r3, #0]
340073f0:	6899      	ldr	r1, [r3, #8]
340073f2:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340073f6:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
340073fa:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
340073fe:	021b      	lsls	r3, r3, #8
34007400:	4313      	orrs	r3, r2
34007402:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
34007406:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
3400740a:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400740e:	6093      	str	r3, [r2, #8]
             (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos));

  /* set reg @08 deskew_polarity_rw 1'b1 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0x08, 0x38);
34007410:	2338      	movs	r3, #56	@ 0x38
34007412:	2208      	movs	r2, #8
34007414:	2100      	movs	r1, #0
34007416:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
3400741a:	f002 fda7 	bl	34009f6c <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xE4 counter_for_des_en_config_if_rx 0x10 + DLL prog EN */
  /* This is because 13<= cfgclkfreqrange[5:0]<=38 */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe4, 0x11);
3400741e:	2311      	movs	r3, #17
34007420:	22e4      	movs	r2, #228	@ 0xe4
34007422:	2100      	movs	r1, #0
34007424:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34007428:	f002 fda0 	bl	34009f6c <DCMIPP_CSI_WritePHYReg>

  /* set reg @0xe3 & reg @0xe2 value DLL target oscilation freq */
  /* Based on the table page 77, osc_freq_target */
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target >> 8);
3400742c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34007430:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34007434:	681b      	ldr	r3, [r3, #0]
34007436:	689b      	ldr	r3, [r3, #8]
34007438:	f507 7202 	add.w	r2, r7, #520	@ 0x208
3400743c:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34007440:	00db      	lsls	r3, r3, #3
34007442:	4413      	add	r3, r2
34007444:	685b      	ldr	r3, [r3, #4]
34007446:	0a1b      	lsrs	r3, r3, #8
34007448:	22e3      	movs	r2, #227	@ 0xe3
3400744a:	2100      	movs	r1, #0
3400744c:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34007450:	f002 fd8c 	bl	34009f6c <DCMIPP_CSI_WritePHYReg>
  DCMIPP_CSI_WritePHYReg(csi_instance, 0x00, 0xe3, SNPS_Freqs[pCSI_Config->PHYBitrate].osc_freq_target & 0xFFU);
34007454:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34007458:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
3400745c:	681b      	ldr	r3, [r3, #0]
3400745e:	689b      	ldr	r3, [r3, #8]
34007460:	f507 7202 	add.w	r2, r7, #520	@ 0x208
34007464:	f5a2 72fe 	sub.w	r2, r2, #508	@ 0x1fc
34007468:	00db      	lsls	r3, r3, #3
3400746a:	4413      	add	r3, r2
3400746c:	685b      	ldr	r3, [r3, #4]
3400746e:	b2db      	uxtb	r3, r3
34007470:	22e3      	movs	r2, #227	@ 0xe3
34007472:	2100      	movs	r1, #0
34007474:	f8d7 0204 	ldr.w	r0, [r7, #516]	@ 0x204
34007478:	f002 fd78 	bl	34009f6c <DCMIPP_CSI_WritePHYReg>

  /* set basedir_0 to RX DLD 0 RX, 1 TX. Synopsys 1 RX 0 TX  + freq range */
  WRITE_REG(csi_instance-> PFCR, (0x28U << CSI_PFCR_CCFR_Pos) |
3400747c:	f507 7302 	add.w	r3, r7, #520	@ 0x208
34007480:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
34007484:	681b      	ldr	r3, [r3, #0]
34007486:	689a      	ldr	r2, [r3, #8]
34007488:	f507 7302 	add.w	r3, r7, #520	@ 0x208
3400748c:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
34007490:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
34007494:	021b      	lsls	r3, r3, #8
34007496:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400749a:	f043 0328 	orr.w	r3, r3, #40	@ 0x28
3400749e:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
340074a2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340074a6:	6093      	str	r3, [r2, #8]
            (SNPS_Freqs[pCSI_Config->PHYBitrate].hsfreqrange << CSI_PFCR_HSFR_Pos) | CSI_PFCR_DLD);

  /* Enable the D-PHY_RX lane(s) etc */
  if (pCSI_Config->NumberOfLanes == DCMIPP_CSI_ONE_DATA_LANE)
340074a8:	f507 7302 	add.w	r3, r7, #520	@ 0x208
340074ac:	f5a3 7302 	sub.w	r3, r3, #520	@ 0x208
340074b0:	681b      	ldr	r3, [r3, #0]
340074b2:	681b      	ldr	r3, [r3, #0]
340074b4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340074b8:	d104      	bne.n	340074c4 <HAL_DCMIPP_CSI_SetConfig+0x284>
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
340074ba:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340074be:	2207      	movs	r2, #7
340074c0:	605a      	str	r2, [r3, #4]
340074c2:	e003      	b.n	340074cc <HAL_DCMIPP_CSI_SetConfig+0x28c>
  }
  else
  {
    WRITE_REG(csi_instance->PCR, CSI_PCR_DL0EN | CSI_PCR_DL1EN | CSI_PCR_CLEN | CSI_PCR_PWRDOWN);
340074c4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340074c8:	220f      	movs	r2, #15
340074ca:	605a      	str	r2, [r3, #4]
  }


  /* Enable PHY, out of reset */
  SET_BIT(csi_instance->PRCR, CSI_PRCR_PEN);
340074cc:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340074d0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340074d4:	681b      	ldr	r3, [r3, #0]
340074d6:	f043 0302 	orr.w	r3, r3, #2
340074da:	f8d7 2204 	ldr.w	r2, [r7, #516]	@ 0x204
340074de:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
340074e2:	6013      	str	r3, [r2, #0]

  /* Remove the force */
  CLEAR_REG(csi_instance->PMCR);
340074e4:	f8d7 3204 	ldr.w	r3, [r7, #516]	@ 0x204
340074e8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340074ec:	461a      	mov	r2, r3
340074ee:	2300      	movs	r3, #0
340074f0:	6053      	str	r3, [r2, #4]

  return HAL_OK;
340074f2:	2300      	movs	r3, #0

}
340074f4:	4618      	mov	r0, r3
340074f6:	f507 7702 	add.w	r7, r7, #520	@ 0x208
340074fa:	46bd      	mov	sp, r7
340074fc:	bd80      	pop	{r7, pc}
340074fe:	bf00      	nop
34007500:	58006000 	.word	0x58006000
34007504:	3402a214 	.word	0x3402a214

34007508 <HAL_DCMIPP_CSI_PIPE_SetConfig>:
  *                         the CSI Pipe configuration information for DCMIPP.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CSI_PIPE_ConfTypeDef *pCSI_PipeConfig)
{
34007508:	b480      	push	{r7}
3400750a:	b087      	sub	sp, #28
3400750c:	af00      	add	r7, sp, #0
3400750e:	60f8      	str	r0, [r7, #12]
34007510:	60b9      	str	r1, [r7, #8]
34007512:	607a      	str	r2, [r7, #4]
  uint32_t pxfscr_reg = 0;
34007514:	2300      	movs	r3, #0
34007516:	617b      	str	r3, [r7, #20]
  HAL_DCMIPP_StateTypeDef state;

  /* Check the DCMIPP peripheral handle parameter and pCSI_Config parameter */
  if ((hdcmipp == NULL) || (pCSI_PipeConfig == NULL))
34007518:	68fb      	ldr	r3, [r7, #12]
3400751a:	2b00      	cmp	r3, #0
3400751c:	d002      	beq.n	34007524 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x1c>
3400751e:	687b      	ldr	r3, [r7, #4]
34007520:	2b00      	cmp	r3, #0
34007522:	d101      	bne.n	34007528 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x20>
  {
    return HAL_ERROR;
34007524:	2301      	movs	r3, #1
34007526:	e087      	b.n	34007638 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
  /* Check the parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

  if (Pipe != DCMIPP_PIPE2)
34007528:	68bb      	ldr	r3, [r7, #8]
3400752a:	2b02      	cmp	r3, #2
3400752c:	d003      	beq.n	34007536 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x2e>
  {
    assert_param(IS_DCMIPP_DATA_TYPE_MODE(pCSI_PipeConfig->DataTypeMode));

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
3400752e:	687b      	ldr	r3, [r7, #4]
34007530:	681b      	ldr	r3, [r3, #0]
34007532:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
  if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
  {
    assert_param(IS_DCMIPP_DATA_TYPE(pCSI_PipeConfig->DataTypeIDA));
  }

  state = hdcmipp->State;
34007536:	68fb      	ldr	r3, [r7, #12]
34007538:	791b      	ldrb	r3, [r3, #4]
3400753a:	74fb      	strb	r3, [r7, #19]
  if ((state == HAL_DCMIPP_STATE_INIT) || (state == HAL_DCMIPP_STATE_READY))
3400753c:	7cfb      	ldrb	r3, [r7, #19]
3400753e:	2b01      	cmp	r3, #1
34007540:	d002      	beq.n	34007548 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x40>
34007542:	7cfb      	ldrb	r3, [r7, #19]
34007544:	2b02      	cmp	r3, #2
34007546:	d173      	bne.n	34007630 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x128>
  {
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34007548:	687b      	ldr	r3, [r7, #4]
3400754a:	681b      	ldr	r3, [r3, #0]
3400754c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34007550:	d004      	beq.n	3400755c <HAL_DCMIPP_CSI_PIPE_SetConfig+0x54>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
34007552:	687b      	ldr	r3, [r7, #4]
34007554:	681b      	ldr	r3, [r3, #0]
    if (((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL) || \
34007556:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400755a:	d104      	bne.n	34007566 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
         (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB)) && (Pipe != DCMIPP_PIPE0))
3400755c:	68bb      	ldr	r3, [r7, #8]
3400755e:	2b00      	cmp	r3, #0
34007560:	d001      	beq.n	34007566 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x5e>
    {
      return HAL_ERROR;
34007562:	2301      	movs	r3, #1
34007564:	e068      	b.n	34007638 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x130>
    }

    /* Add Data Type Mode for the selected Pipe except Pipe2 */
    if (Pipe != DCMIPP_PIPE2)
34007566:	68bb      	ldr	r3, [r7, #8]
34007568:	2b02      	cmp	r3, #2
3400756a:	d004      	beq.n	34007576 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x6e>
    {
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeMode);
3400756c:	687b      	ldr	r3, [r7, #4]
3400756e:	681b      	ldr	r3, [r3, #0]
34007570:	697a      	ldr	r2, [r7, #20]
34007572:	4313      	orrs	r3, r2
34007574:	617b      	str	r3, [r7, #20]
    }

    if (pCSI_PipeConfig->DataTypeMode != DCMIPP_DTMODE_ALL)
34007576:	687b      	ldr	r3, [r7, #4]
34007578:	681b      	ldr	r3, [r3, #0]
3400757a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400757e:	d004      	beq.n	3400758a <HAL_DCMIPP_CSI_PIPE_SetConfig+0x82>
    {
      /* Add Data Type IDA for the selected Pipe */
      pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDA << DCMIPP_P0FSCR_DTIDA_Pos);
34007580:	687b      	ldr	r3, [r7, #4]
34007582:	685b      	ldr	r3, [r3, #4]
34007584:	697a      	ldr	r2, [r7, #20]
34007586:	4313      	orrs	r3, r2
34007588:	617b      	str	r3, [r7, #20]
    }

    if ((pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_DTIDA_OR_DTIDB)
3400758a:	687b      	ldr	r3, [r7, #4]
3400758c:	681b      	ldr	r3, [r3, #0]
3400758e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34007592:	d004      	beq.n	3400759e <HAL_DCMIPP_CSI_PIPE_SetConfig+0x96>
        || (pCSI_PipeConfig->DataTypeMode == DCMIPP_DTMODE_ALL_EXCEPT_DTIA_DTIB))
34007594:	687b      	ldr	r3, [r7, #4]
34007596:	681b      	ldr	r3, [r3, #0]
34007598:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400759c:	d108      	bne.n	340075b0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
    {
      if (Pipe != DCMIPP_PIPE2)
3400759e:	68bb      	ldr	r3, [r7, #8]
340075a0:	2b02      	cmp	r3, #2
340075a2:	d005      	beq.n	340075b0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xa8>
      {
        /* Add Data Type IDB for the selected Pipe except Pipe2 */
        pxfscr_reg |= (uint32_t)(pCSI_PipeConfig->DataTypeIDB << DCMIPP_P0FSCR_DTIDB_Pos);
340075a4:	687b      	ldr	r3, [r7, #4]
340075a6:	689b      	ldr	r3, [r3, #8]
340075a8:	021b      	lsls	r3, r3, #8
340075aa:	697a      	ldr	r2, [r7, #20]
340075ac:	4313      	orrs	r3, r2
340075ae:	617b      	str	r3, [r7, #20]
      }
    }

    if (Pipe == DCMIPP_PIPE0)
340075b0:	68bb      	ldr	r3, [r7, #8]
340075b2:	2b00      	cmp	r3, #0
340075b4:	d10c      	bne.n	340075d0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xc8>
    {
      MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_DTMODE | DCMIPP_P0FSCR_DTIDA |
340075b6:	68fb      	ldr	r3, [r7, #12]
340075b8:	681b      	ldr	r3, [r3, #0]
340075ba:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
340075be:	4b21      	ldr	r3, [pc, #132]	@ (34007644 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
340075c0:	4013      	ands	r3, r2
340075c2:	68fa      	ldr	r2, [r7, #12]
340075c4:	6812      	ldr	r2, [r2, #0]
340075c6:	6979      	ldr	r1, [r7, #20]
340075c8:	430b      	orrs	r3, r1
340075ca:	f8c2 3404 	str.w	r3, [r2, #1028]	@ 0x404
340075ce:	e01b      	b.n	34007608 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                 DCMIPP_P0FSCR_DTIDB, pxfscr_reg);
    }
    else if (Pipe == DCMIPP_PIPE1)
340075d0:	68bb      	ldr	r3, [r7, #8]
340075d2:	2b01      	cmp	r3, #1
340075d4:	d10c      	bne.n	340075f0 <HAL_DCMIPP_CSI_PIPE_SetConfig+0xe8>
    {
      MODIFY_REG(hdcmipp->Instance->P1FSCR, (DCMIPP_P1FSCR_DTIDA | DCMIPP_P1FSCR_DTIDB |
340075d6:	68fb      	ldr	r3, [r7, #12]
340075d8:	681b      	ldr	r3, [r3, #0]
340075da:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
340075de:	4b19      	ldr	r3, [pc, #100]	@ (34007644 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x13c>)
340075e0:	4013      	ands	r3, r2
340075e2:	68fa      	ldr	r2, [r7, #12]
340075e4:	6812      	ldr	r2, [r2, #0]
340075e6:	6979      	ldr	r1, [r7, #20]
340075e8:	430b      	orrs	r3, r1
340075ea:	f8c2 3804 	str.w	r3, [r2, #2052]	@ 0x804
340075ee:	e00b      	b.n	34007608 <HAL_DCMIPP_CSI_PIPE_SetConfig+0x100>
                                             DCMIPP_P1FSCR_DTMODE), pxfscr_reg);
    }
    else
    {
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_DTIDA, pxfscr_reg);
340075f0:	68fb      	ldr	r3, [r7, #12]
340075f2:	681b      	ldr	r3, [r3, #0]
340075f4:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
340075f8:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
340075fc:	68fb      	ldr	r3, [r7, #12]
340075fe:	681b      	ldr	r3, [r3, #0]
34007600:	697a      	ldr	r2, [r7, #20]
34007602:	430a      	orrs	r2, r1
34007604:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }

    /* Disable Parallel interface */
    CLEAR_BIT(hdcmipp->Instance->PRCR, DCMIPP_PRCR_ENABLE);
34007608:	68fb      	ldr	r3, [r7, #12]
3400760a:	681b      	ldr	r3, [r3, #0]
3400760c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34007610:	68fb      	ldr	r3, [r7, #12]
34007612:	681b      	ldr	r3, [r3, #0]
34007614:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34007618:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

    /* Set CSI Input Selection  */
    SET_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
3400761c:	68fb      	ldr	r3, [r7, #12]
3400761e:	681b      	ldr	r3, [r3, #0]
34007620:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
34007624:	68fb      	ldr	r3, [r7, #12]
34007626:	681b      	ldr	r3, [r3, #0]
34007628:	f042 0201 	orr.w	r2, r2, #1
3400762c:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204
  }

  /* Update the DCMIPP state */
  hdcmipp->State = HAL_DCMIPP_STATE_READY;
34007630:	68fb      	ldr	r3, [r7, #12]
34007632:	2202      	movs	r2, #2
34007634:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
34007636:	2300      	movs	r3, #0
}
34007638:	4618      	mov	r0, r3
3400763a:	371c      	adds	r7, #28
3400763c:	46bd      	mov	sp, r7
3400763e:	f85d 7b04 	ldr.w	r7, [sp], #4
34007642:	4770      	bx	lr
34007644:	fffcc0c0 	.word	0xfffcc0c0

34007648 <HAL_DCMIPP_CSI_SetVCConfig>:
  * @param  DataTypeFormat Specifies the Data Type Format, can be a value from @ref DCMIPP_CSI_DataTypeFormat.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_SetVCConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel,
                                             uint32_t DataTypeFormat)
{
34007648:	b480      	push	{r7}
3400764a:	b087      	sub	sp, #28
3400764c:	af00      	add	r7, sp, #0
3400764e:	60f8      	str	r0, [r7, #12]
34007650:	60b9      	str	r1, [r7, #8]
34007652:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34007654:	4b1c      	ldr	r3, [pc, #112]	@ (340076c8 <HAL_DCMIPP_CSI_SetVCConfig+0x80>)
34007656:	617b      	str	r3, [r7, #20]

  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CSI_DATA_TYPE_FORMAT(DataTypeFormat));

  /* Check pointer and input values validity */
  if (hdcmipp == NULL)
34007658:	68fb      	ldr	r3, [r7, #12]
3400765a:	2b00      	cmp	r3, #0
3400765c:	d101      	bne.n	34007662 <HAL_DCMIPP_CSI_SetVCConfig+0x1a>
  {
    return HAL_ERROR;
3400765e:	2301      	movs	r3, #1
34007660:	e02c      	b.n	340076bc <HAL_DCMIPP_CSI_SetVCConfig+0x74>
  }

  /* Set the common format for all data type for the selected virtual channel */
  switch (VirtualChannel)
34007662:	68bb      	ldr	r3, [r7, #8]
34007664:	2b03      	cmp	r3, #3
34007666:	d827      	bhi.n	340076b8 <HAL_DCMIPP_CSI_SetVCConfig+0x70>
34007668:	a201      	add	r2, pc, #4	@ (adr r2, 34007670 <HAL_DCMIPP_CSI_SetVCConfig+0x28>)
3400766a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400766e:	bf00      	nop
34007670:	34007681 	.word	0x34007681
34007674:	3400768f 	.word	0x3400768f
34007678:	3400769d 	.word	0x3400769d
3400767c:	340076ab 	.word	0x340076ab
  {
    case DCMIPP_VIRTUAL_CHANNEL0:
    {
      WRITE_REG(csi_instance->VC0CFGR1, (DataTypeFormat << CSI_VC0CFGR1_CDTFT_Pos) | CSI_VC0CFGR1_ALLDT);
34007680:	687b      	ldr	r3, [r7, #4]
34007682:	021b      	lsls	r3, r3, #8
34007684:	f043 0201 	orr.w	r2, r3, #1
34007688:	697b      	ldr	r3, [r7, #20]
3400768a:	611a      	str	r2, [r3, #16]
      break;
3400768c:	e015      	b.n	340076ba <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL1:
    {
      WRITE_REG(csi_instance->VC1CFGR1, (DataTypeFormat << CSI_VC1CFGR1_CDTFT_Pos) | CSI_VC1CFGR1_ALLDT);
3400768e:	687b      	ldr	r3, [r7, #4]
34007690:	021b      	lsls	r3, r3, #8
34007692:	f043 0201 	orr.w	r2, r3, #1
34007696:	697b      	ldr	r3, [r7, #20]
34007698:	621a      	str	r2, [r3, #32]
      break;
3400769a:	e00e      	b.n	340076ba <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL2:
    {
      WRITE_REG(csi_instance->VC2CFGR1, (DataTypeFormat << CSI_VC2CFGR1_CDTFT_Pos) | CSI_VC2CFGR1_ALLDT);
3400769c:	687b      	ldr	r3, [r7, #4]
3400769e:	021b      	lsls	r3, r3, #8
340076a0:	f043 0201 	orr.w	r2, r3, #1
340076a4:	697b      	ldr	r3, [r7, #20]
340076a6:	631a      	str	r2, [r3, #48]	@ 0x30
      break;
340076a8:	e007      	b.n	340076ba <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    case DCMIPP_VIRTUAL_CHANNEL3:
    {
      WRITE_REG(csi_instance->VC3CFGR1, (DataTypeFormat << CSI_VC3CFGR1_CDTFT_Pos) | CSI_VC3CFGR1_ALLDT);
340076aa:	687b      	ldr	r3, [r7, #4]
340076ac:	021b      	lsls	r3, r3, #8
340076ae:	f043 0201 	orr.w	r2, r3, #1
340076b2:	697b      	ldr	r3, [r7, #20]
340076b4:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
340076b6:	e000      	b.n	340076ba <HAL_DCMIPP_CSI_SetVCConfig+0x72>
    }
    default:
      break;
340076b8:	bf00      	nop
  }

  return HAL_OK;
340076ba:	2300      	movs	r3, #0
}
340076bc:	4618      	mov	r0, r3
340076be:	371c      	adds	r7, #28
340076c0:	46bd      	mov	sp, r7
340076c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340076c6:	4770      	bx	lr
340076c8:	58006000 	.word	0x58006000

340076cc <HAL_DCMIPP_PIPE_SetConfig>:
  * @param  pPipeConfig pointer to pipe configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                            const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
340076cc:	b580      	push	{r7, lr}
340076ce:	b086      	sub	sp, #24
340076d0:	af00      	add	r7, sp, #0
340076d2:	60f8      	str	r0, [r7, #12]
340076d4:	60b9      	str	r1, [r7, #8]
340076d6:	607a      	str	r2, [r7, #4]
  HAL_DCMIPP_PipeStateTypeDef pipe_state;

  /* Check the DCMIPP peripheral handle parameter and pPipeConfig parameter */
  if ((hdcmipp == NULL) || (pPipeConfig == NULL))
340076d8:	68fb      	ldr	r3, [r7, #12]
340076da:	2b00      	cmp	r3, #0
340076dc:	d002      	beq.n	340076e4 <HAL_DCMIPP_PIPE_SetConfig+0x18>
340076de:	687b      	ldr	r3, [r7, #4]
340076e0:	2b00      	cmp	r3, #0
340076e2:	d101      	bne.n	340076e8 <HAL_DCMIPP_PIPE_SetConfig+0x1c>
  {
    return HAL_ERROR;
340076e4:	2301      	movs	r3, #1
340076e6:	e02f      	b.n	34007748 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  {
    assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(pPipeConfig->PixelPackerFormat));
    assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(pPipeConfig->PixelPipePitch));
  }

  if ((Pipe == DCMIPP_PIPE2) && ((pPipeConfig->PixelPackerFormat) > DCMIPP_PIXEL_PACKER_FORMAT_YUV422_1))
340076e8:	68bb      	ldr	r3, [r7, #8]
340076ea:	2b02      	cmp	r3, #2
340076ec:	d105      	bne.n	340076fa <HAL_DCMIPP_PIPE_SetConfig+0x2e>
340076ee:	687b      	ldr	r3, [r7, #4]
340076f0:	689b      	ldr	r3, [r3, #8]
340076f2:	2b06      	cmp	r3, #6
340076f4:	d901      	bls.n	340076fa <HAL_DCMIPP_PIPE_SetConfig+0x2e>
  {
    return HAL_ERROR;
340076f6:	2301      	movs	r3, #1
340076f8:	e026      	b.n	34007748 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
  }
  /* Get Pipe State */
  pipe_state = hdcmipp->PipeState[Pipe];
340076fa:	68fa      	ldr	r2, [r7, #12]
340076fc:	68bb      	ldr	r3, [r7, #8]
340076fe:	4413      	add	r3, r2
34007700:	3305      	adds	r3, #5
34007702:	781b      	ldrb	r3, [r3, #0]
34007704:	75fb      	strb	r3, [r7, #23]

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34007706:	68fb      	ldr	r3, [r7, #12]
34007708:	791b      	ldrb	r3, [r3, #4]
3400770a:	b2db      	uxtb	r3, r3
3400770c:	2b02      	cmp	r3, #2
3400770e:	d11a      	bne.n	34007746 <HAL_DCMIPP_PIPE_SetConfig+0x7a>
  {
    if ((pipe_state == HAL_DCMIPP_PIPE_STATE_RESET) || (pipe_state == HAL_DCMIPP_PIPE_STATE_ERROR))
34007710:	7dfb      	ldrb	r3, [r7, #23]
34007712:	2b00      	cmp	r3, #0
34007714:	d002      	beq.n	3400771c <HAL_DCMIPP_PIPE_SetConfig+0x50>
34007716:	7dfb      	ldrb	r3, [r7, #23]
34007718:	2b04      	cmp	r3, #4
3400771a:	d112      	bne.n	34007742 <HAL_DCMIPP_PIPE_SetConfig+0x76>
    {
      /* Update the DCMIPP PIPE state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400771c:	68fa      	ldr	r2, [r7, #12]
3400771e:	68bb      	ldr	r3, [r7, #8]
34007720:	4413      	add	r3, r2
34007722:	3305      	adds	r3, #5
34007724:	2202      	movs	r2, #2
34007726:	701a      	strb	r2, [r3, #0]

      /* Initialize the DCMIPP Pipe registers */
      Pipe_Config(hdcmipp, Pipe, pPipeConfig);
34007728:	687a      	ldr	r2, [r7, #4]
3400772a:	68b9      	ldr	r1, [r7, #8]
3400772c:	68f8      	ldr	r0, [r7, #12]
3400772e:	f002 fb7e 	bl	34009e2e <Pipe_Config>

      /* Update the DCMIPP pipe state */
      hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_READY;
34007732:	68fa      	ldr	r2, [r7, #12]
34007734:	68bb      	ldr	r3, [r7, #8]
34007736:	4413      	add	r3, r2
34007738:	3305      	adds	r3, #5
3400773a:	2201      	movs	r2, #1
3400773c:	701a      	strb	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400773e:	2300      	movs	r3, #0
34007740:	e002      	b.n	34007748 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
      return HAL_ERROR;
34007742:	2301      	movs	r3, #1
34007744:	e000      	b.n	34007748 <HAL_DCMIPP_PIPE_SetConfig+0x7c>
    return HAL_ERROR;
34007746:	2301      	movs	r3, #1
}
34007748:	4618      	mov	r0, r3
3400774a:	3718      	adds	r7, #24
3400774c:	46bd      	mov	sp, r7
3400774e:	bd80      	pop	{r7, pc}

34007750 <HAL_DCMIPP_CSI_PIPE_Start>:
  * @param  CaptureMode    DCMIPP capture mode for the pipe can be a value from @ref DCMIPP_Capture_Mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_CSI_PIPE_Start(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel,
                                            uint32_t DstAddress, uint32_t CaptureMode)
{
34007750:	b580      	push	{r7, lr}
34007752:	b086      	sub	sp, #24
34007754:	af00      	add	r7, sp, #0
34007756:	60f8      	str	r0, [r7, #12]
34007758:	60b9      	str	r1, [r7, #8]
3400775a:	607a      	str	r2, [r7, #4]
3400775c:	603b      	str	r3, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VCID(VirtualChannel));
  assert_param(IS_DCMIPP_CAPTURE_MODE(CaptureMode));

  /* Check pointer validity */
  if ((hdcmipp == NULL) || ((DstAddress & 0xFU) != 0U))
3400775e:	68fb      	ldr	r3, [r7, #12]
34007760:	2b00      	cmp	r3, #0
34007762:	d004      	beq.n	3400776e <HAL_DCMIPP_CSI_PIPE_Start+0x1e>
34007764:	683b      	ldr	r3, [r7, #0]
34007766:	f003 030f 	and.w	r3, r3, #15
3400776a:	2b00      	cmp	r3, #0
3400776c:	d001      	beq.n	34007772 <HAL_DCMIPP_CSI_PIPE_Start+0x22>
  {
    return HAL_ERROR;
3400776e:	2301      	movs	r3, #1
34007770:	e028      	b.n	340077c4 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  mode = READ_BIT(hdcmipp->Instance->CMCR, DCMIPP_CMCR_INSEL);
34007772:	68fb      	ldr	r3, [r7, #12]
34007774:	681b      	ldr	r3, [r3, #0]
34007776:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
3400777a:	f003 0301 	and.w	r3, r3, #1
3400777e:	617b      	str	r3, [r7, #20]
  if ((hdcmipp->PipeState[Pipe] != HAL_DCMIPP_PIPE_STATE_READY) || (mode != DCMIPP_SERIAL_MODE))
34007780:	68fa      	ldr	r2, [r7, #12]
34007782:	68bb      	ldr	r3, [r7, #8]
34007784:	4413      	add	r3, r2
34007786:	3305      	adds	r3, #5
34007788:	781b      	ldrb	r3, [r3, #0]
3400778a:	b2db      	uxtb	r3, r3
3400778c:	2b01      	cmp	r3, #1
3400778e:	d102      	bne.n	34007796 <HAL_DCMIPP_CSI_PIPE_Start+0x46>
34007790:	697b      	ldr	r3, [r7, #20]
34007792:	2b01      	cmp	r3, #1
34007794:	d001      	beq.n	3400779a <HAL_DCMIPP_CSI_PIPE_Start+0x4a>
  {
    return HAL_ERROR;
34007796:	2301      	movs	r3, #1
34007798:	e014      	b.n	340077c4 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  /* Set Virtual Channel for the selected Pipe */
  if (DCMIPP_CSI_SetVCConfig(hdcmipp, Pipe, VirtualChannel) != HAL_OK)
3400779a:	687a      	ldr	r2, [r7, #4]
3400779c:	68b9      	ldr	r1, [r7, #8]
3400779e:	68f8      	ldr	r0, [r7, #12]
340077a0:	f002 fd4c 	bl	3400a23c <DCMIPP_CSI_SetVCConfig>
340077a4:	4603      	mov	r3, r0
340077a6:	2b00      	cmp	r3, #0
340077a8:	d001      	beq.n	340077ae <HAL_DCMIPP_CSI_PIPE_Start+0x5e>
  {
    return HAL_ERROR;
340077aa:	2301      	movs	r3, #1
340077ac:	e00a      	b.n	340077c4 <HAL_DCMIPP_CSI_PIPE_Start+0x74>
  }

  /* Set Capture Mode and Destination address for the selected pipe */
  DCMIPP_SetConfig(hdcmipp, Pipe, DstAddress, CaptureMode);
340077ae:	6a3b      	ldr	r3, [r7, #32]
340077b0:	683a      	ldr	r2, [r7, #0]
340077b2:	68b9      	ldr	r1, [r7, #8]
340077b4:	68f8      	ldr	r0, [r7, #12]
340077b6:	f002 fc73 	bl	3400a0a0 <DCMIPP_SetConfig>

  /* Enable Capture for the selected Pipe */
  DCMIPP_EnableCapture(hdcmipp, Pipe);
340077ba:	68b9      	ldr	r1, [r7, #8]
340077bc:	68f8      	ldr	r0, [r7, #12]
340077be:	f002 fce7 	bl	3400a190 <DCMIPP_EnableCapture>

  return HAL_OK;
340077c2:	2300      	movs	r3, #0
}
340077c4:	4618      	mov	r0, r3
340077c6:	3718      	adds	r7, #24
340077c8:	46bd      	mov	sp, r7
340077ca:	bd80      	pop	{r7, pc}

340077cc <HAL_DCMIPP_IRQHandler>:
  * @brief  Handles DCMIPP interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
340077cc:	b580      	push	{r7, lr}
340077ce:	b084      	sub	sp, #16
340077d0:	af00      	add	r7, sp, #0
340077d2:	6078      	str	r0, [r7, #4]
  uint32_t cmsr2flags = READ_REG(hdcmipp->Instance->CMSR2);
340077d4:	687b      	ldr	r3, [r7, #4]
340077d6:	681b      	ldr	r3, [r3, #0]
340077d8:	f8d3 33f8 	ldr.w	r3, [r3, #1016]	@ 0x3f8
340077dc:	60fb      	str	r3, [r7, #12]
  uint32_t cmierflags = READ_REG(hdcmipp->Instance->CMIER);
340077de:	687b      	ldr	r3, [r7, #4]
340077e0:	681b      	ldr	r3, [r3, #0]
340077e2:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
340077e6:	60bb      	str	r3, [r7, #8]

  /* ========================= PIPE0 INTERRUPTS ==================== */
  /* Limit error on the PIPE0 ********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LIMIT) != 0U)
340077e8:	68fb      	ldr	r3, [r7, #12]
340077ea:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340077ee:	2b00      	cmp	r3, #0
340077f0:	d01e      	beq.n	34007830 <HAL_DCMIPP_IRQHandler+0x64>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LIMIT) != 0U)
340077f2:	68bb      	ldr	r3, [r7, #8]
340077f4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340077f8:	2b00      	cmp	r3, #0
340077fa:	d019      	beq.n	34007830 <HAL_DCMIPP_IRQHandler+0x64>
    {
      /* Disable Limit error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_LIMIT);
340077fc:	687b      	ldr	r3, [r7, #4]
340077fe:	681b      	ldr	r3, [r3, #0]
34007800:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007804:	687b      	ldr	r3, [r7, #4]
34007806:	681b      	ldr	r3, [r3, #0]
34007808:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
3400780c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_LIMIT;
34007810:	687b      	ldr	r3, [r7, #4]
34007812:	689b      	ldr	r3, [r3, #8]
34007814:	f043 0204 	orr.w	r2, r3, #4
34007818:	687b      	ldr	r3, [r7, #4]
3400781a:	609a      	str	r2, [r3, #8]

      /* Clear the Limit error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LIMIT);
3400781c:	687b      	ldr	r3, [r7, #4]
3400781e:	681b      	ldr	r3, [r3, #0]
34007820:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34007824:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LIMIT Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LimitEventCallback(hdcmipp, DCMIPP_PIPE0);
34007828:	2100      	movs	r1, #0
3400782a:	6878      	ldr	r0, [r7, #4]
3400782c:	f000 fe67 	bl	340084fe <HAL_DCMIPP_PIPE_LimitEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_VSYNC) != 0U)
34007830:	68fb      	ldr	r3, [r7, #12]
34007832:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007836:	2b00      	cmp	r3, #0
34007838:	d00e      	beq.n	34007858 <HAL_DCMIPP_IRQHandler+0x8c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_VSYNC) != 0U)
3400783a:	68bb      	ldr	r3, [r7, #8]
3400783c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007840:	2b00      	cmp	r3, #0
34007842:	d009      	beq.n	34007858 <HAL_DCMIPP_IRQHandler+0x8c>
    {
      /* Clear the VSYNC flag for pipe0 */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_VSYNC);
34007844:	687b      	ldr	r3, [r7, #4]
34007846:	681b      	ldr	r3, [r3, #0]
34007848:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400784c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE0);
34007850:	2100      	movs	r1, #0
34007852:	6878      	ldr	r0, [r7, #4]
34007854:	f014 f9f2 	bl	3401bc3c <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* FRAME interrupt management ****************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_FRAME) != 0U)
34007858:	68fb      	ldr	r3, [r7, #12]
3400785a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400785e:	2b00      	cmp	r3, #0
34007860:	d023      	beq.n	340078aa <HAL_DCMIPP_IRQHandler+0xde>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_FRAME) != 0U)
34007862:	68bb      	ldr	r3, [r7, #8]
34007864:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007868:	2b00      	cmp	r3, #0
3400786a:	d01e      	beq.n	340078aa <HAL_DCMIPP_IRQHandler+0xde>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400786c:	687b      	ldr	r3, [r7, #4]
3400786e:	681b      	ldr	r3, [r3, #0]
34007870:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007874:	f003 0304 	and.w	r3, r3, #4
34007878:	2b04      	cmp	r3, #4
3400787a:	d10c      	bne.n	34007896 <HAL_DCMIPP_IRQHandler+0xca>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR);
3400787c:	687b      	ldr	r3, [r7, #4]
3400787e:	681b      	ldr	r3, [r3, #0]
34007880:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007884:	687b      	ldr	r3, [r7, #4]
34007886:	681b      	ldr	r3, [r3, #0]
34007888:	f422 4206 	bic.w	r2, r2, #34304	@ 0x8600
3400788c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_READY;
34007890:	687b      	ldr	r3, [r7, #4]
34007892:	2201      	movs	r2, #1
34007894:	715a      	strb	r2, [r3, #5]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_FRAME);
34007896:	687b      	ldr	r3, [r7, #4]
34007898:	681b      	ldr	r3, [r3, #0]
3400789a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400789e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE0);
340078a2:	2100      	movs	r1, #0
340078a4:	6878      	ldr	r0, [r7, #4]
340078a6:	f014 f9e3 	bl	3401bc70 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* LINE interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_LINE) != 0U)
340078aa:	68fb      	ldr	r3, [r7, #12]
340078ac:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340078b0:	2b00      	cmp	r3, #0
340078b2:	d00e      	beq.n	340078d2 <HAL_DCMIPP_IRQHandler+0x106>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_LINE) != 0U)
340078b4:	68bb      	ldr	r3, [r7, #8]
340078b6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340078ba:	2b00      	cmp	r3, #0
340078bc:	d009      	beq.n	340078d2 <HAL_DCMIPP_IRQHandler+0x106>
    {
      /* Clear the LINE flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_LINE);
340078be:	687b      	ldr	r3, [r7, #4]
340078c0:	681b      	ldr	r3, [r3, #0]
340078c2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340078c6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* LINE Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE0);
340078ca:	2100      	movs	r1, #0
340078cc:	6878      	ldr	r0, [r7, #4]
340078ce:	f000 fe0b 	bl	340084e8 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error interrupt for Pipe0 ***************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE0_OVR) != 0U)
340078d2:	68fb      	ldr	r3, [r7, #12]
340078d4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340078d8:	2b00      	cmp	r3, #0
340078da:	d021      	beq.n	34007920 <HAL_DCMIPP_IRQHandler+0x154>
  {
    if ((cmierflags & DCMIPP_IT_PIPE0_OVR) != 0U)
340078dc:	68bb      	ldr	r3, [r7, #8]
340078de:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340078e2:	2b00      	cmp	r3, #0
340078e4:	d01c      	beq.n	34007920 <HAL_DCMIPP_IRQHandler+0x154>
    {
      /* Disable Overrun Error Interrupt for pipe0 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_OVR);
340078e6:	687b      	ldr	r3, [r7, #4]
340078e8:	681b      	ldr	r3, [r3, #0]
340078ea:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340078ee:	687b      	ldr	r3, [r7, #4]
340078f0:	681b      	ldr	r3, [r3, #0]
340078f2:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340078f6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE0_OVR;
340078fa:	687b      	ldr	r3, [r7, #4]
340078fc:	689b      	ldr	r3, [r3, #8]
340078fe:	f043 0208 	orr.w	r2, r3, #8
34007902:	687b      	ldr	r3, [r7, #4]
34007904:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE0_OVR);
34007906:	687b      	ldr	r3, [r7, #4]
34007908:	681b      	ldr	r3, [r3, #0]
3400790a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3400790e:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP Pipe state */
      hdcmipp->PipeState[0] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007912:	687b      	ldr	r3, [r7, #4]
34007914:	2204      	movs	r2, #4
34007916:	715a      	strb	r2, [r3, #5]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE0);
34007918:	2100      	movs	r1, #0
3400791a:	6878      	ldr	r0, [r7, #4]
3400791c:	f000 fdfa 	bl	34008514 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE1 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
34007920:	68fb      	ldr	r3, [r7, #12]
34007922:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007926:	2b00      	cmp	r3, #0
34007928:	d00e      	beq.n	34007948 <HAL_DCMIPP_IRQHandler+0x17c>
  {
    if ((cmierflags & DCMIPP_FLAG_PIPE1_LINE) != 0U)
3400792a:	68bb      	ldr	r3, [r7, #8]
3400792c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007930:	2b00      	cmp	r3, #0
34007932:	d009      	beq.n	34007948 <HAL_DCMIPP_IRQHandler+0x17c>
    {
      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_LINE);
34007934:	687b      	ldr	r3, [r7, #4]
34007936:	681b      	ldr	r3, [r3, #0]
34007938:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400793c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE1);
34007940:	2101      	movs	r1, #1
34007942:	6878      	ldr	r0, [r7, #4]
34007944:	f000 fdd0 	bl	340084e8 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_VSYNC) != 0U)
34007948:	68fb      	ldr	r3, [r7, #12]
3400794a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400794e:	2b00      	cmp	r3, #0
34007950:	d00e      	beq.n	34007970 <HAL_DCMIPP_IRQHandler+0x1a4>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_VSYNC) != 0U)
34007952:	68bb      	ldr	r3, [r7, #8]
34007954:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34007958:	2b00      	cmp	r3, #0
3400795a:	d009      	beq.n	34007970 <HAL_DCMIPP_IRQHandler+0x1a4>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_VSYNC);
3400795c:	687b      	ldr	r3, [r7, #4]
3400795e:	681b      	ldr	r3, [r3, #0]
34007960:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34007964:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE1);
34007968:	2101      	movs	r1, #1
3400796a:	6878      	ldr	r0, [r7, #4]
3400796c:	f014 f966 	bl	3401bc3c <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_FRAME) != 0U)
34007970:	68fb      	ldr	r3, [r7, #12]
34007972:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34007976:	2b00      	cmp	r3, #0
34007978:	d023      	beq.n	340079c2 <HAL_DCMIPP_IRQHandler+0x1f6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_FRAME) != 0U)
3400797a:	68bb      	ldr	r3, [r7, #8]
3400797c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34007980:	2b00      	cmp	r3, #0
34007982:	d01e      	beq.n	340079c2 <HAL_DCMIPP_IRQHandler+0x1f6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P1FCTCR & DCMIPP_P1FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007984:	687b      	ldr	r3, [r7, #4]
34007986:	681b      	ldr	r3, [r3, #0]
34007988:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
3400798c:	f003 0304 	and.w	r3, r3, #4
34007990:	2b04      	cmp	r3, #4
34007992:	d10c      	bne.n	340079ae <HAL_DCMIPP_IRQHandler+0x1e2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME | DCMIPP_IT_PIPE1_VSYNC | DCMIPP_IT_PIPE1_OVR);
34007994:	687b      	ldr	r3, [r7, #4]
34007996:	681b      	ldr	r3, [r3, #0]
34007998:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
3400799c:	687b      	ldr	r3, [r7, #4]
3400799e:	681b      	ldr	r3, [r3, #0]
340079a0:	f422 0206 	bic.w	r2, r2, #8781824	@ 0x860000
340079a4:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_READY;
340079a8:	687b      	ldr	r3, [r7, #4]
340079aa:	2201      	movs	r2, #1
340079ac:	719a      	strb	r2, [r3, #6]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_FRAME);
340079ae:	687b      	ldr	r3, [r7, #4]
340079b0:	681b      	ldr	r3, [r3, #0]
340079b2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
340079b6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE1);
340079ba:	2101      	movs	r1, #1
340079bc:	6878      	ldr	r0, [r7, #4]
340079be:	f014 f957 	bl	3401bc70 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Overrun error on the PIPE1 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE1_OVR) != 0U)
340079c2:	68fb      	ldr	r3, [r7, #12]
340079c4:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
340079c8:	2b00      	cmp	r3, #0
340079ca:	d021      	beq.n	34007a10 <HAL_DCMIPP_IRQHandler+0x244>
  {
    if ((cmierflags & DCMIPP_IT_PIPE1_OVR) != 0U)
340079cc:	68bb      	ldr	r3, [r7, #8]
340079ce:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
340079d2:	2b00      	cmp	r3, #0
340079d4:	d01c      	beq.n	34007a10 <HAL_DCMIPP_IRQHandler+0x244>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_OVR);
340079d6:	687b      	ldr	r3, [r7, #4]
340079d8:	681b      	ldr	r3, [r3, #0]
340079da:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
340079de:	687b      	ldr	r3, [r7, #4]
340079e0:	681b      	ldr	r3, [r3, #0]
340079e2:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
340079e6:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE1_OVR;
340079ea:	687b      	ldr	r3, [r7, #4]
340079ec:	689b      	ldr	r3, [r3, #8]
340079ee:	f043 0210 	orr.w	r2, r3, #16
340079f2:	687b      	ldr	r3, [r7, #4]
340079f4:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE1_OVR);
340079f6:	687b      	ldr	r3, [r7, #4]
340079f8:	681b      	ldr	r3, [r3, #0]
340079fa:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
340079fe:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[1] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007a02:	687b      	ldr	r3, [r7, #4]
34007a04:	2204      	movs	r2, #4
34007a06:	719a      	strb	r2, [r3, #6]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE1);
34007a08:	2101      	movs	r1, #1
34007a0a:	6878      	ldr	r0, [r7, #4]
34007a0c:	f000 fd82 	bl	34008514 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* ========================= PIPE2 INTERRUPTS ==================== */
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_LINE) != 0U)
34007a10:	68fb      	ldr	r3, [r7, #12]
34007a12:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34007a16:	2b00      	cmp	r3, #0
34007a18:	d00e      	beq.n	34007a38 <HAL_DCMIPP_IRQHandler+0x26c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_LINE) != 0U)
34007a1a:	68bb      	ldr	r3, [r7, #8]
34007a1c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34007a20:	2b00      	cmp	r3, #0
34007a22:	d009      	beq.n	34007a38 <HAL_DCMIPP_IRQHandler+0x26c>
    {
      /* Clear the End of Line flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_LINE);
34007a24:	687b      	ldr	r3, [r7, #4]
34007a26:	681b      	ldr	r3, [r3, #0]
34007a28:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34007a2c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_LineEventCallback(hdcmipp, DCMIPP_PIPE2);
34007a30:	2102      	movs	r1, #2
34007a32:	6878      	ldr	r0, [r7, #4]
34007a34:	f000 fd58 	bl	340084e8 <HAL_DCMIPP_PIPE_LineEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* VSYNC interrupt management **********************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_VSYNC) != 0U)
34007a38:	68fb      	ldr	r3, [r7, #12]
34007a3a:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34007a3e:	2b00      	cmp	r3, #0
34007a40:	d00e      	beq.n	34007a60 <HAL_DCMIPP_IRQHandler+0x294>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_VSYNC) != 0U)
34007a42:	68bb      	ldr	r3, [r7, #8]
34007a44:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34007a48:	2b00      	cmp	r3, #0
34007a4a:	d009      	beq.n	34007a60 <HAL_DCMIPP_IRQHandler+0x294>
    {
      /* Clear the VSYNC flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_VSYNC);
34007a4c:	687b      	ldr	r3, [r7, #4]
34007a4e:	681b      	ldr	r3, [r3, #0]
34007a50:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34007a54:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* VSYNC Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_VsyncEventCallback(hdcmipp, DCMIPP_PIPE2);
34007a58:	2102      	movs	r1, #2
34007a5a:	6878      	ldr	r0, [r7, #4]
34007a5c:	f014 f8ee 	bl	3401bc3c <HAL_DCMIPP_PIPE_VsyncEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_FRAME) != 0U)
34007a60:	68fb      	ldr	r3, [r7, #12]
34007a62:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34007a66:	2b00      	cmp	r3, #0
34007a68:	d023      	beq.n	34007ab2 <HAL_DCMIPP_IRQHandler+0x2e6>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_FRAME) != 0U)
34007a6a:	68bb      	ldr	r3, [r7, #8]
34007a6c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34007a70:	2b00      	cmp	r3, #0
34007a72:	d01e      	beq.n	34007ab2 <HAL_DCMIPP_IRQHandler+0x2e6>
    {
      /* When snapshot mode, disable Vsync, Error and Overrun interrupts */
      if ((hdcmipp->Instance->P2FCTCR & DCMIPP_P2FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007a74:	687b      	ldr	r3, [r7, #4]
34007a76:	681b      	ldr	r3, [r3, #0]
34007a78:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34007a7c:	f003 0304 	and.w	r3, r3, #4
34007a80:	2b04      	cmp	r3, #4
34007a82:	d10c      	bne.n	34007a9e <HAL_DCMIPP_IRQHandler+0x2d2>
      {
        __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_VSYNC | DCMIPP_IT_PIPE2_OVR);
34007a84:	687b      	ldr	r3, [r7, #4]
34007a86:	681b      	ldr	r3, [r3, #0]
34007a88:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007a8c:	687b      	ldr	r3, [r7, #4]
34007a8e:	681b      	ldr	r3, [r3, #0]
34007a90:	f022 4206 	bic.w	r2, r2, #2248146944	@ 0x86000000
34007a94:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

        /* Update Pipe State */
        hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_READY;
34007a98:	687b      	ldr	r3, [r7, #4]
34007a9a:	2201      	movs	r2, #1
34007a9c:	71da      	strb	r2, [r3, #7]
      }

      /* Clear the End of Frame flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_FRAME);
34007a9e:	687b      	ldr	r3, [r7, #4]
34007aa0:	681b      	ldr	r3, [r3, #0]
34007aa2:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34007aa6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Frame Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_FrameEventCallback(hdcmipp, DCMIPP_PIPE2);
34007aaa:	2102      	movs	r1, #2
34007aac:	6878      	ldr	r0, [r7, #4]
34007aae:	f014 f8df 	bl	3401bc70 <HAL_DCMIPP_PIPE_FrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
  /* Overrun error on the PIPE2 **************************************/
  if ((cmsr2flags & DCMIPP_FLAG_PIPE2_OVR) != 0U)
34007ab2:	68fb      	ldr	r3, [r7, #12]
34007ab4:	2b00      	cmp	r3, #0
34007ab6:	da1f      	bge.n	34007af8 <HAL_DCMIPP_IRQHandler+0x32c>
  {
    if ((cmierflags & DCMIPP_IT_PIPE2_OVR) != 0U)
34007ab8:	68bb      	ldr	r3, [r7, #8]
34007aba:	2b00      	cmp	r3, #0
34007abc:	da1c      	bge.n	34007af8 <HAL_DCMIPP_IRQHandler+0x32c>
    {
      /* Disable Overrun Error Interrupt for pipe1 */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_OVR);
34007abe:	687b      	ldr	r3, [r7, #4]
34007ac0:	681b      	ldr	r3, [r3, #0]
34007ac2:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007ac6:	687b      	ldr	r3, [r7, #4]
34007ac8:	681b      	ldr	r3, [r3, #0]
34007aca:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34007ace:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PIPE2_OVR;
34007ad2:	687b      	ldr	r3, [r7, #4]
34007ad4:	689b      	ldr	r3, [r3, #8]
34007ad6:	f043 0220 	orr.w	r2, r3, #32
34007ada:	687b      	ldr	r3, [r7, #4]
34007adc:	609a      	str	r2, [r3, #8]

      /* Clear the overrun error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PIPE2_OVR);
34007ade:	687b      	ldr	r3, [r7, #4]
34007ae0:	681b      	ldr	r3, [r3, #0]
34007ae2:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34007ae6:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->PipeState[2] = HAL_DCMIPP_PIPE_STATE_ERROR;
34007aea:	687b      	ldr	r3, [r7, #4]
34007aec:	2204      	movs	r2, #4
34007aee:	71da      	strb	r2, [r3, #7]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
#else
      HAL_DCMIPP_PIPE_ErrorCallback(hdcmipp, DCMIPP_PIPE2);
34007af0:	2102      	movs	r1, #2
34007af2:	6878      	ldr	r0, [r7, #4]
34007af4:	f000 fd0e 	bl	34008514 <HAL_DCMIPP_PIPE_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization Error Interrupt on the parallel interface  **************/
  if ((cmsr2flags & DCMIPP_FLAG_PARALLEL_SYNC_ERROR) != 0U)
34007af8:	68fb      	ldr	r3, [r7, #12]
34007afa:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007afe:	2b00      	cmp	r3, #0
34007b00:	d01f      	beq.n	34007b42 <HAL_DCMIPP_IRQHandler+0x376>
  {
    if ((cmierflags & DCMIPP_IT_PARALLEL_SYNC_ERROR) != 0U)
34007b02:	68bb      	ldr	r3, [r7, #8]
34007b04:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007b08:	2b00      	cmp	r3, #0
34007b0a:	d01a      	beq.n	34007b42 <HAL_DCMIPP_IRQHandler+0x376>
    {
      /* Disable Synchronization error interrupt on parallel interface */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_PARALLEL_SYNC_ERROR);
34007b0c:	687b      	ldr	r3, [r7, #4]
34007b0e:	681b      	ldr	r3, [r3, #0]
34007b10:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007b14:	687b      	ldr	r3, [r7, #4]
34007b16:	681b      	ldr	r3, [r3, #0]
34007b18:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34007b1c:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_PARALLEL_SYNC;
34007b20:	687b      	ldr	r3, [r7, #4]
34007b22:	689b      	ldr	r3, [r3, #8]
34007b24:	f043 0202 	orr.w	r2, r3, #2
34007b28:	687b      	ldr	r3, [r7, #4]
34007b2a:	609a      	str	r2, [r3, #8]

      /* Clear the synchronization error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_PARALLEL_SYNC_ERROR);
34007b2c:	687b      	ldr	r3, [r7, #4]
34007b2e:	681b      	ldr	r3, [r3, #0]
34007b30:	2240      	movs	r2, #64	@ 0x40
34007b32:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34007b36:	687b      	ldr	r3, [r7, #4]
34007b38:	2204      	movs	r2, #4
34007b3a:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34007b3c:	6878      	ldr	r0, [r7, #4]
34007b3e:	f000 fcf4 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* IPPLUG AXI transfer Error Interrupt     *********************************/
  if ((cmsr2flags & DCMIPP_FLAG_AXI_TRANSFER_ERROR) != 0U)
34007b42:	68fb      	ldr	r3, [r7, #12]
34007b44:	f003 0320 	and.w	r3, r3, #32
34007b48:	2b00      	cmp	r3, #0
34007b4a:	d01f      	beq.n	34007b8c <HAL_DCMIPP_IRQHandler+0x3c0>
  {
    if ((cmierflags & DCMIPP_IT_AXI_TRANSFER_ERROR) != 0U)
34007b4c:	68bb      	ldr	r3, [r7, #8]
34007b4e:	f003 0320 	and.w	r3, r3, #32
34007b52:	2b00      	cmp	r3, #0
34007b54:	d01a      	beq.n	34007b8c <HAL_DCMIPP_IRQHandler+0x3c0>
    {
      /* Disable IPPLUG AXI transfer Error Interrupt */
      __HAL_DCMIPP_DISABLE_IT(hdcmipp, DCMIPP_IT_AXI_TRANSFER_ERROR);
34007b56:	687b      	ldr	r3, [r7, #4]
34007b58:	681b      	ldr	r3, [r3, #0]
34007b5a:	f8d3 23f0 	ldr.w	r2, [r3, #1008]	@ 0x3f0
34007b5e:	687b      	ldr	r3, [r7, #4]
34007b60:	681b      	ldr	r3, [r3, #0]
34007b62:	f022 0220 	bic.w	r2, r2, #32
34007b66:	f8c3 23f0 	str.w	r2, [r3, #1008]	@ 0x3f0

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_ERROR_AXI_TRANSFER;
34007b6a:	687b      	ldr	r3, [r7, #4]
34007b6c:	689b      	ldr	r3, [r3, #8]
34007b6e:	f043 0201 	orr.w	r2, r3, #1
34007b72:	687b      	ldr	r3, [r7, #4]
34007b74:	609a      	str	r2, [r3, #8]

      /* Clear the AXI transfer error flag */
      __HAL_DCMIPP_CLEAR_FLAG(hdcmipp, DCMIPP_FLAG_AXI_TRANSFER_ERROR);
34007b76:	687b      	ldr	r3, [r7, #4]
34007b78:	681b      	ldr	r3, [r3, #0]
34007b7a:	2220      	movs	r2, #32
34007b7c:	f8c3 23fc 	str.w	r2, [r3, #1020]	@ 0x3fc

      /* Change DCMIPP state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34007b80:	687b      	ldr	r3, [r7, #4]
34007b82:	2204      	movs	r2, #4
34007b84:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34007b86:	6878      	ldr	r0, [r7, #4]
34007b88:	f000 fccf 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
34007b8c:	bf00      	nop
34007b8e:	3710      	adds	r7, #16
34007b90:	46bd      	mov	sp, r7
34007b92:	bd80      	pop	{r7, pc}

34007b94 <HAL_DCMIPP_CSI_IRQHandler>:
  * @brief  Handles DCMIPP CSI interrupt request.
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_CSI_IRQHandler(DCMIPP_HandleTypeDef *hdcmipp)
{
34007b94:	b580      	push	{r7, lr}
34007b96:	b088      	sub	sp, #32
34007b98:	af00      	add	r7, sp, #0
34007b9a:	6078      	str	r0, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
34007b9c:	4bb1      	ldr	r3, [pc, #708]	@ (34007e64 <HAL_DCMIPP_CSI_IRQHandler+0x2d0>)
34007b9e:	61fb      	str	r3, [r7, #28]

  /* Read the SR0 register once */
  uint32_t sr0flags = READ_REG(csi_instance->SR0);
34007ba0:	69fb      	ldr	r3, [r7, #28]
34007ba2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34007ba6:	61bb      	str	r3, [r7, #24]
  uint32_t sr1flags = READ_REG(csi_instance->SR1);
34007ba8:	69fb      	ldr	r3, [r7, #28]
34007baa:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34007bae:	617b      	str	r3, [r7, #20]

  uint32_t ier0_flags = READ_REG(csi_instance->IER0);
34007bb0:	69fb      	ldr	r3, [r7, #28]
34007bb2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007bb6:	613b      	str	r3, [r7, #16]
  uint32_t ier1_flags = READ_REG(csi_instance->IER1);
34007bb8:	69fb      	ldr	r3, [r7, #28]
34007bba:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34007bbe:	60fb      	str	r3, [r7, #12]

  /* Clock changer FIFO full event */
  if ((sr0flags & DCMIPP_CSI_FLAG_CCFIFO) != 0U)
34007bc0:	69bb      	ldr	r3, [r7, #24]
34007bc2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34007bc6:	2b00      	cmp	r3, #0
34007bc8:	d014      	beq.n	34007bf4 <HAL_DCMIPP_CSI_IRQHandler+0x60>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CCFIFO) != 0U)
34007bca:	693b      	ldr	r3, [r7, #16]
34007bcc:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34007bd0:	2b00      	cmp	r3, #0
34007bd2:	d00f      	beq.n	34007bf4 <HAL_DCMIPP_CSI_IRQHandler+0x60>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CCFIFO);
34007bd4:	69fb      	ldr	r3, [r7, #28]
34007bd6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007bda:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
34007bde:	69fb      	ldr	r3, [r7, #28]
34007be0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CCFIFO);
34007be4:	69fb      	ldr	r3, [r7, #28]
34007be6:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
34007bea:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ClockChangerFifoFullEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(hdcmipp);
34007bee:	6878      	ldr	r0, [r7, #4]
34007bf0:	f000 fcb0 	bl	34008554 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>
  }

  /*###############################
     Byte/Line Counter Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_LB3) != 0U)
34007bf4:	69bb      	ldr	r3, [r7, #24]
34007bf6:	f003 0308 	and.w	r3, r3, #8
34007bfa:	2b00      	cmp	r3, #0
34007bfc:	d01c      	beq.n	34007c38 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB3) != 0U)
34007bfe:	693b      	ldr	r3, [r7, #16]
34007c00:	f003 0308 	and.w	r3, r3, #8
34007c04:	2b00      	cmp	r3, #0
34007c06:	d017      	beq.n	34007c38 <HAL_DCMIPP_CSI_IRQHandler+0xa4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007c08:	687b      	ldr	r3, [r7, #4]
34007c0a:	681b      	ldr	r3, [r3, #0]
34007c0c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007c10:	f003 0304 	and.w	r3, r3, #4
34007c14:	2b04      	cmp	r3, #4
34007c16:	d107      	bne.n	34007c28 <HAL_DCMIPP_CSI_IRQHandler+0x94>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB3);
34007c18:	69fb      	ldr	r3, [r7, #28]
34007c1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007c1e:	f023 0208 	bic.w	r2, r3, #8
34007c22:	69fb      	ldr	r3, [r7, #28]
34007c24:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB3);
34007c28:	69fb      	ldr	r3, [r7, #28]
34007c2a:	2208      	movs	r2, #8
34007c2c:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER3);
34007c30:	2103      	movs	r1, #3
34007c32:	6878      	ldr	r0, [r7, #4]
34007c34:	f000 fcc3 	bl	340085be <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB2) != 0U)
34007c38:	69bb      	ldr	r3, [r7, #24]
34007c3a:	f003 0304 	and.w	r3, r3, #4
34007c3e:	2b00      	cmp	r3, #0
34007c40:	d01c      	beq.n	34007c7c <HAL_DCMIPP_CSI_IRQHandler+0xe8>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB2) != 0U)
34007c42:	693b      	ldr	r3, [r7, #16]
34007c44:	f003 0304 	and.w	r3, r3, #4
34007c48:	2b00      	cmp	r3, #0
34007c4a:	d017      	beq.n	34007c7c <HAL_DCMIPP_CSI_IRQHandler+0xe8>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007c4c:	687b      	ldr	r3, [r7, #4]
34007c4e:	681b      	ldr	r3, [r3, #0]
34007c50:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007c54:	f003 0304 	and.w	r3, r3, #4
34007c58:	2b04      	cmp	r3, #4
34007c5a:	d107      	bne.n	34007c6c <HAL_DCMIPP_CSI_IRQHandler+0xd8>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB2);
34007c5c:	69fb      	ldr	r3, [r7, #28]
34007c5e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007c62:	f023 0204 	bic.w	r2, r3, #4
34007c66:	69fb      	ldr	r3, [r7, #28]
34007c68:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB2);
34007c6c:	69fb      	ldr	r3, [r7, #28]
34007c6e:	2204      	movs	r2, #4
34007c70:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER2);
34007c74:	2102      	movs	r1, #2
34007c76:	6878      	ldr	r0, [r7, #4]
34007c78:	f000 fca1 	bl	340085be <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB1) != 0U)
34007c7c:	69bb      	ldr	r3, [r7, #24]
34007c7e:	f003 0302 	and.w	r3, r3, #2
34007c82:	2b00      	cmp	r3, #0
34007c84:	d01c      	beq.n	34007cc0 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB1) != 0U)
34007c86:	693b      	ldr	r3, [r7, #16]
34007c88:	f003 0302 	and.w	r3, r3, #2
34007c8c:	2b00      	cmp	r3, #0
34007c8e:	d017      	beq.n	34007cc0 <HAL_DCMIPP_CSI_IRQHandler+0x12c>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007c90:	687b      	ldr	r3, [r7, #4]
34007c92:	681b      	ldr	r3, [r3, #0]
34007c94:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007c98:	f003 0304 	and.w	r3, r3, #4
34007c9c:	2b04      	cmp	r3, #4
34007c9e:	d107      	bne.n	34007cb0 <HAL_DCMIPP_CSI_IRQHandler+0x11c>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB1);
34007ca0:	69fb      	ldr	r3, [r7, #28]
34007ca2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007ca6:	f023 0202 	bic.w	r2, r3, #2
34007caa:	69fb      	ldr	r3, [r7, #28]
34007cac:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB1);
34007cb0:	69fb      	ldr	r3, [r7, #28]
34007cb2:	2202      	movs	r2, #2
34007cb4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER1);
34007cb8:	2101      	movs	r1, #1
34007cba:	6878      	ldr	r0, [r7, #4]
34007cbc:	f000 fc7f 	bl	340085be <HAL_DCMIPP_CSI_LineByteEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_LB0) != 0U)
34007cc0:	69bb      	ldr	r3, [r7, #24]
34007cc2:	f003 0301 	and.w	r3, r3, #1
34007cc6:	2b00      	cmp	r3, #0
34007cc8:	d01c      	beq.n	34007d04 <HAL_DCMIPP_CSI_IRQHandler+0x170>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_LB0) != 0U)
34007cca:	693b      	ldr	r3, [r7, #16]
34007ccc:	f003 0301 	and.w	r3, r3, #1
34007cd0:	2b00      	cmp	r3, #0
34007cd2:	d017      	beq.n	34007d04 <HAL_DCMIPP_CSI_IRQHandler+0x170>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007cd4:	687b      	ldr	r3, [r7, #4]
34007cd6:	681b      	ldr	r3, [r3, #0]
34007cd8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007cdc:	f003 0304 	and.w	r3, r3, #4
34007ce0:	2b04      	cmp	r3, #4
34007ce2:	d107      	bne.n	34007cf4 <HAL_DCMIPP_CSI_IRQHandler+0x160>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_LB0);
34007ce4:	69fb      	ldr	r3, [r7, #28]
34007ce6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007cea:	f023 0201 	bic.w	r2, r3, #1
34007cee:	69fb      	ldr	r3, [r7, #28]
34007cf0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_LB0);
34007cf4:	69fb      	ldr	r3, [r7, #28]
34007cf6:	2201      	movs	r2, #1
34007cf8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* LineByte Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
#else
      HAL_DCMIPP_CSI_LineByteEventCallback(hdcmipp, DCMIPP_CSI_COUNTER0);
34007cfc:	2100      	movs	r1, #0
34007cfe:	6878      	ldr	r0, [r7, #4]
34007d00:	f000 fc5d 	bl	340085be <HAL_DCMIPP_CSI_LineByteEventCallback>
  }

  /*###############################
            End Of Frame
    ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_EOF3) != 0U)
34007d04:	69bb      	ldr	r3, [r7, #24]
34007d06:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34007d0a:	2b00      	cmp	r3, #0
34007d0c:	d01d      	beq.n	34007d4a <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF3) != 0U)
34007d0e:	693b      	ldr	r3, [r7, #16]
34007d10:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34007d14:	2b00      	cmp	r3, #0
34007d16:	d018      	beq.n	34007d4a <HAL_DCMIPP_CSI_IRQHandler+0x1b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007d18:	687b      	ldr	r3, [r7, #4]
34007d1a:	681b      	ldr	r3, [r3, #0]
34007d1c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007d20:	f003 0304 	and.w	r3, r3, #4
34007d24:	2b04      	cmp	r3, #4
34007d26:	d107      	bne.n	34007d38 <HAL_DCMIPP_CSI_IRQHandler+0x1a4>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF3);
34007d28:	69fb      	ldr	r3, [r7, #28]
34007d2a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007d2e:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
34007d32:	69fb      	ldr	r3, [r7, #28]
34007d34:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF3);
34007d38:	69fb      	ldr	r3, [r7, #28]
34007d3a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
34007d3e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34007d42:	2103      	movs	r1, #3
34007d44:	6878      	ldr	r0, [r7, #4]
34007d46:	f000 fc19 	bl	3400857c <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF2) != 0U)
34007d4a:	69bb      	ldr	r3, [r7, #24]
34007d4c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34007d50:	2b00      	cmp	r3, #0
34007d52:	d01d      	beq.n	34007d90 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF2) != 0U)
34007d54:	693b      	ldr	r3, [r7, #16]
34007d56:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34007d5a:	2b00      	cmp	r3, #0
34007d5c:	d018      	beq.n	34007d90 <HAL_DCMIPP_CSI_IRQHandler+0x1fc>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007d5e:	687b      	ldr	r3, [r7, #4]
34007d60:	681b      	ldr	r3, [r3, #0]
34007d62:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007d66:	f003 0304 	and.w	r3, r3, #4
34007d6a:	2b04      	cmp	r3, #4
34007d6c:	d107      	bne.n	34007d7e <HAL_DCMIPP_CSI_IRQHandler+0x1ea>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF2);
34007d6e:	69fb      	ldr	r3, [r7, #28]
34007d70:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007d74:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
34007d78:	69fb      	ldr	r3, [r7, #28]
34007d7a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF2);
34007d7e:	69fb      	ldr	r3, [r7, #28]
34007d80:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34007d84:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34007d88:	2102      	movs	r1, #2
34007d8a:	6878      	ldr	r0, [r7, #4]
34007d8c:	f000 fbf6 	bl	3400857c <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF1) != 0U)
34007d90:	69bb      	ldr	r3, [r7, #24]
34007d92:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34007d96:	2b00      	cmp	r3, #0
34007d98:	d01d      	beq.n	34007dd6 <HAL_DCMIPP_CSI_IRQHandler+0x242>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF1) != 0U)
34007d9a:	693b      	ldr	r3, [r7, #16]
34007d9c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34007da0:	2b00      	cmp	r3, #0
34007da2:	d018      	beq.n	34007dd6 <HAL_DCMIPP_CSI_IRQHandler+0x242>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007da4:	687b      	ldr	r3, [r7, #4]
34007da6:	681b      	ldr	r3, [r3, #0]
34007da8:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007dac:	f003 0304 	and.w	r3, r3, #4
34007db0:	2b04      	cmp	r3, #4
34007db2:	d107      	bne.n	34007dc4 <HAL_DCMIPP_CSI_IRQHandler+0x230>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF1);
34007db4:	69fb      	ldr	r3, [r7, #28]
34007db6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007dba:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
34007dbe:	69fb      	ldr	r3, [r7, #28]
34007dc0:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF1);
34007dc4:	69fb      	ldr	r3, [r7, #28]
34007dc6:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34007dca:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34007dce:	2101      	movs	r1, #1
34007dd0:	6878      	ldr	r0, [r7, #4]
34007dd2:	f000 fbd3 	bl	3400857c <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_EOF0) != 0U)
34007dd6:	69bb      	ldr	r3, [r7, #24]
34007dd8:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34007ddc:	2b00      	cmp	r3, #0
34007dde:	d01d      	beq.n	34007e1c <HAL_DCMIPP_CSI_IRQHandler+0x288>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_EOF0) != 0U)
34007de0:	693b      	ldr	r3, [r7, #16]
34007de2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34007de6:	2b00      	cmp	r3, #0
34007de8:	d018      	beq.n	34007e1c <HAL_DCMIPP_CSI_IRQHandler+0x288>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007dea:	687b      	ldr	r3, [r7, #4]
34007dec:	681b      	ldr	r3, [r3, #0]
34007dee:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007df2:	f003 0304 	and.w	r3, r3, #4
34007df6:	2b04      	cmp	r3, #4
34007df8:	d107      	bne.n	34007e0a <HAL_DCMIPP_CSI_IRQHandler+0x276>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EOF0);
34007dfa:	69fb      	ldr	r3, [r7, #28]
34007dfc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007e00:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34007e04:	69fb      	ldr	r3, [r7, #28]
34007e06:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_EOF0);
34007e0a:	69fb      	ldr	r3, [r7, #28]
34007e0c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34007e10:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_CSIREGISTER_CALLBACKS == 1)
      hdcmipp->EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_EndOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34007e14:	2100      	movs	r1, #0
34007e16:	6878      	ldr	r0, [r7, #4]
34007e18:	f000 fbb0 	bl	3400857c <HAL_DCMIPP_CSI_EndOfFrameEventCallback>
  }

  /*###############################
           Start Of Frame
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_SOF3) != 0U)
34007e1c:	69bb      	ldr	r3, [r7, #24]
34007e1e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34007e22:	2b00      	cmp	r3, #0
34007e24:	d020      	beq.n	34007e68 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF3) != 0U)
34007e26:	693b      	ldr	r3, [r7, #16]
34007e28:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34007e2c:	2b00      	cmp	r3, #0
34007e2e:	d01b      	beq.n	34007e68 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007e30:	687b      	ldr	r3, [r7, #4]
34007e32:	681b      	ldr	r3, [r3, #0]
34007e34:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007e38:	f003 0304 	and.w	r3, r3, #4
34007e3c:	2b04      	cmp	r3, #4
34007e3e:	d107      	bne.n	34007e50 <HAL_DCMIPP_CSI_IRQHandler+0x2bc>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF3);
34007e40:	69fb      	ldr	r3, [r7, #28]
34007e42:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007e46:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34007e4a:	69fb      	ldr	r3, [r7, #28]
34007e4c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF3);
34007e50:	69fb      	ldr	r3, [r7, #28]
34007e52:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34007e56:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL3);
34007e5a:	2103      	movs	r1, #3
34007e5c:	6878      	ldr	r0, [r7, #4]
34007e5e:	f000 fb98 	bl	34008592 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
34007e62:	e001      	b.n	34007e68 <HAL_DCMIPP_CSI_IRQHandler+0x2d4>
34007e64:	58006000 	.word	0x58006000
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF2) != 0U)
34007e68:	69bb      	ldr	r3, [r7, #24]
34007e6a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007e6e:	2b00      	cmp	r3, #0
34007e70:	d01d      	beq.n	34007eae <HAL_DCMIPP_CSI_IRQHandler+0x31a>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF2) != 0U)
34007e72:	693b      	ldr	r3, [r7, #16]
34007e74:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34007e78:	2b00      	cmp	r3, #0
34007e7a:	d018      	beq.n	34007eae <HAL_DCMIPP_CSI_IRQHandler+0x31a>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007e7c:	687b      	ldr	r3, [r7, #4]
34007e7e:	681b      	ldr	r3, [r3, #0]
34007e80:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007e84:	f003 0304 	and.w	r3, r3, #4
34007e88:	2b04      	cmp	r3, #4
34007e8a:	d107      	bne.n	34007e9c <HAL_DCMIPP_CSI_IRQHandler+0x308>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF2);
34007e8c:	69fb      	ldr	r3, [r7, #28]
34007e8e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007e92:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34007e96:	69fb      	ldr	r3, [r7, #28]
34007e98:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF2);
34007e9c:	69fb      	ldr	r3, [r7, #28]
34007e9e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34007ea2:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL2);
34007ea6:	2102      	movs	r1, #2
34007ea8:	6878      	ldr	r0, [r7, #4]
34007eaa:	f000 fb72 	bl	34008592 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF1) != 0U)
34007eae:	69bb      	ldr	r3, [r7, #24]
34007eb0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007eb4:	2b00      	cmp	r3, #0
34007eb6:	d01d      	beq.n	34007ef4 <HAL_DCMIPP_CSI_IRQHandler+0x360>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF1) != 0U)
34007eb8:	693b      	ldr	r3, [r7, #16]
34007eba:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34007ebe:	2b00      	cmp	r3, #0
34007ec0:	d018      	beq.n	34007ef4 <HAL_DCMIPP_CSI_IRQHandler+0x360>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007ec2:	687b      	ldr	r3, [r7, #4]
34007ec4:	681b      	ldr	r3, [r3, #0]
34007ec6:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007eca:	f003 0304 	and.w	r3, r3, #4
34007ece:	2b04      	cmp	r3, #4
34007ed0:	d107      	bne.n	34007ee2 <HAL_DCMIPP_CSI_IRQHandler+0x34e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF1);
34007ed2:	69fb      	ldr	r3, [r7, #28]
34007ed4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007ed8:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34007edc:	69fb      	ldr	r3, [r7, #28]
34007ede:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF1);
34007ee2:	69fb      	ldr	r3, [r7, #28]
34007ee4:	f44f 7200 	mov.w	r2, #512	@ 0x200
34007ee8:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL1);
34007eec:	2101      	movs	r1, #1
34007eee:	6878      	ldr	r0, [r7, #4]
34007ef0:	f000 fb4f 	bl	34008592 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SOF0) != 0U)
34007ef4:	69bb      	ldr	r3, [r7, #24]
34007ef6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34007efa:	2b00      	cmp	r3, #0
34007efc:	d01d      	beq.n	34007f3a <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SOF0) != 0U)
34007efe:	693b      	ldr	r3, [r7, #16]
34007f00:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34007f04:	2b00      	cmp	r3, #0
34007f06:	d018      	beq.n	34007f3a <HAL_DCMIPP_CSI_IRQHandler+0x3a6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007f08:	687b      	ldr	r3, [r7, #4]
34007f0a:	681b      	ldr	r3, [r3, #0]
34007f0c:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007f10:	f003 0304 	and.w	r3, r3, #4
34007f14:	2b04      	cmp	r3, #4
34007f16:	d107      	bne.n	34007f28 <HAL_DCMIPP_CSI_IRQHandler+0x394>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SOF0);
34007f18:	69fb      	ldr	r3, [r7, #28]
34007f1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007f1e:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34007f22:	69fb      	ldr	r3, [r7, #28]
34007f24:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SOF0);
34007f28:	69fb      	ldr	r3, [r7, #28]
34007f2a:	f44f 7280 	mov.w	r2, #256	@ 0x100
34007f2e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
#else
      HAL_DCMIPP_CSI_StartOfFrameEventCallback(hdcmipp, DCMIPP_VIRTUAL_CHANNEL0);
34007f32:	2100      	movs	r1, #0
34007f34:	6878      	ldr	r0, [r7, #4]
34007f36:	f000 fb2c 	bl	34008592 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>
  }

  /*###############################
           Timer Interrupt
  ##############################*/
  if ((sr0flags & DCMIPP_CSI_FLAG_TIM3) != 0U)
34007f3a:	69bb      	ldr	r3, [r7, #24]
34007f3c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34007f40:	2b00      	cmp	r3, #0
34007f42:	d01c      	beq.n	34007f7e <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM3) != 0U)
34007f44:	693b      	ldr	r3, [r7, #16]
34007f46:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34007f4a:	2b00      	cmp	r3, #0
34007f4c:	d017      	beq.n	34007f7e <HAL_DCMIPP_CSI_IRQHandler+0x3ea>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007f4e:	687b      	ldr	r3, [r7, #4]
34007f50:	681b      	ldr	r3, [r3, #0]
34007f52:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007f56:	f003 0304 	and.w	r3, r3, #4
34007f5a:	2b04      	cmp	r3, #4
34007f5c:	d107      	bne.n	34007f6e <HAL_DCMIPP_CSI_IRQHandler+0x3da>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM3);
34007f5e:	69fb      	ldr	r3, [r7, #28]
34007f60:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007f64:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34007f68:	69fb      	ldr	r3, [r7, #28]
34007f6a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM3);
34007f6e:	69fb      	ldr	r3, [r7, #28]
34007f70:	2280      	movs	r2, #128	@ 0x80
34007f72:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER3);
34007f76:	2103      	movs	r1, #3
34007f78:	6878      	ldr	r0, [r7, #4]
34007f7a:	f000 fb15 	bl	340085a8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM2) != 0U)
34007f7e:	69bb      	ldr	r3, [r7, #24]
34007f80:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007f84:	2b00      	cmp	r3, #0
34007f86:	d01c      	beq.n	34007fc2 <HAL_DCMIPP_CSI_IRQHandler+0x42e>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM2) != 0U)
34007f88:	693b      	ldr	r3, [r7, #16]
34007f8a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34007f8e:	2b00      	cmp	r3, #0
34007f90:	d017      	beq.n	34007fc2 <HAL_DCMIPP_CSI_IRQHandler+0x42e>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007f92:	687b      	ldr	r3, [r7, #4]
34007f94:	681b      	ldr	r3, [r3, #0]
34007f96:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007f9a:	f003 0304 	and.w	r3, r3, #4
34007f9e:	2b04      	cmp	r3, #4
34007fa0:	d107      	bne.n	34007fb2 <HAL_DCMIPP_CSI_IRQHandler+0x41e>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM2);
34007fa2:	69fb      	ldr	r3, [r7, #28]
34007fa4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007fa8:	f023 0240 	bic.w	r2, r3, #64	@ 0x40
34007fac:	69fb      	ldr	r3, [r7, #28]
34007fae:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM2);
34007fb2:	69fb      	ldr	r3, [r7, #28]
34007fb4:	2240      	movs	r2, #64	@ 0x40
34007fb6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER2);
34007fba:	2102      	movs	r1, #2
34007fbc:	6878      	ldr	r0, [r7, #4]
34007fbe:	f000 faf3 	bl	340085a8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM1) != 0U)
34007fc2:	69bb      	ldr	r3, [r7, #24]
34007fc4:	f003 0320 	and.w	r3, r3, #32
34007fc8:	2b00      	cmp	r3, #0
34007fca:	d01c      	beq.n	34008006 <HAL_DCMIPP_CSI_IRQHandler+0x472>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM1) != 0U)
34007fcc:	693b      	ldr	r3, [r7, #16]
34007fce:	f003 0320 	and.w	r3, r3, #32
34007fd2:	2b00      	cmp	r3, #0
34007fd4:	d017      	beq.n	34008006 <HAL_DCMIPP_CSI_IRQHandler+0x472>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
34007fd6:	687b      	ldr	r3, [r7, #4]
34007fd8:	681b      	ldr	r3, [r3, #0]
34007fda:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34007fde:	f003 0304 	and.w	r3, r3, #4
34007fe2:	2b04      	cmp	r3, #4
34007fe4:	d107      	bne.n	34007ff6 <HAL_DCMIPP_CSI_IRQHandler+0x462>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM1);
34007fe6:	69fb      	ldr	r3, [r7, #28]
34007fe8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34007fec:	f023 0220 	bic.w	r2, r3, #32
34007ff0:	69fb      	ldr	r3, [r7, #28]
34007ff2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM1);
34007ff6:	69fb      	ldr	r3, [r7, #28]
34007ff8:	2220      	movs	r2, #32
34007ffa:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER1);
34007ffe:	2101      	movs	r1, #1
34008000:	6878      	ldr	r0, [r7, #4]
34008002:	f000 fad1 	bl	340085a8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_TIM0) != 0U)
34008006:	69bb      	ldr	r3, [r7, #24]
34008008:	f003 0310 	and.w	r3, r3, #16
3400800c:	2b00      	cmp	r3, #0
3400800e:	d01c      	beq.n	3400804a <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_TIM0) != 0U)
34008010:	693b      	ldr	r3, [r7, #16]
34008012:	f003 0310 	and.w	r3, r3, #16
34008016:	2b00      	cmp	r3, #0
34008018:	d017      	beq.n	3400804a <HAL_DCMIPP_CSI_IRQHandler+0x4b6>
    {
      if ((hdcmipp->Instance->P0FCTCR & DCMIPP_P0FCTCR_CPTMODE) == DCMIPP_MODE_SNAPSHOT)
3400801a:	687b      	ldr	r3, [r7, #4]
3400801c:	681b      	ldr	r3, [r3, #0]
3400801e:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34008022:	f003 0304 	and.w	r3, r3, #4
34008026:	2b04      	cmp	r3, #4
34008028:	d107      	bne.n	3400803a <HAL_DCMIPP_CSI_IRQHandler+0x4a6>
      {
        /* Disable IT */
        __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_TIM0);
3400802a:	69fb      	ldr	r3, [r7, #28]
3400802c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008030:	f023 0210 	bic.w	r2, r3, #16
34008034:	69fb      	ldr	r3, [r7, #28]
34008036:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      }

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_TIM0);
3400803a:	69fb      	ldr	r3, [r7, #28]
3400803c:	2210      	movs	r2, #16
3400803e:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
#else
      HAL_DCMIPP_CSI_TimerCounterEventCallback(hdcmipp, DCMIPP_CSI_TIMER0);
34008042:	2100      	movs	r1, #0
34008044:	6878      	ldr	r0, [r7, #4]
34008046:	f000 faaf 	bl	340085a8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Synchronization error  */
  if ((sr0flags & DCMIPP_CSI_FLAG_SYNCERR) != 0U)
3400804a:	69bb      	ldr	r3, [r7, #24]
3400804c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
34008050:	2b00      	cmp	r3, #0
34008052:	d01a      	beq.n	3400808a <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SYNCERR) != 0U)
34008054:	693b      	ldr	r3, [r7, #16]
34008056:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400805a:	2b00      	cmp	r3, #0
3400805c:	d015      	beq.n	3400808a <HAL_DCMIPP_CSI_IRQHandler+0x4f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SYNCERR);
3400805e:	69fb      	ldr	r3, [r7, #28]
34008060:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008064:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
34008068:	69fb      	ldr	r3, [r7, #28]
3400806a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SYNCERR);
3400806e:	69fb      	ldr	r3, [r7, #28]
34008070:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
34008074:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SYNC;
34008078:	687b      	ldr	r3, [r7, #4]
3400807a:	689b      	ldr	r3, [r3, #8]
3400807c:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34008080:	687b      	ldr	r3, [r7, #4]
34008082:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34008084:	6878      	ldr	r0, [r7, #4]
34008086:	f000 fa50 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_WDERR) != 0U)
3400808a:	69bb      	ldr	r3, [r7, #24]
3400808c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34008090:	2b00      	cmp	r3, #0
34008092:	d01a      	beq.n	340080ca <HAL_DCMIPP_CSI_IRQHandler+0x536>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_WDERR) != 0U)
34008094:	693b      	ldr	r3, [r7, #16]
34008096:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3400809a:	2b00      	cmp	r3, #0
3400809c:	d015      	beq.n	340080ca <HAL_DCMIPP_CSI_IRQHandler+0x536>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_WDERR);
3400809e:	69fb      	ldr	r3, [r7, #28]
340080a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340080a4:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
340080a8:	69fb      	ldr	r3, [r7, #28]
340080aa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_WDERR);
340080ae:	69fb      	ldr	r3, [r7, #28]
340080b0:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
340080b4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_WDG;
340080b8:	687b      	ldr	r3, [r7, #4]
340080ba:	689b      	ldr	r3, [r3, #8]
340080bc:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
340080c0:	687b      	ldr	r3, [r7, #4]
340080c2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340080c4:	6878      	ldr	r0, [r7, #4]
340080c6:	f000 fa30 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKTERR) != 0U)
340080ca:	69bb      	ldr	r3, [r7, #24]
340080cc:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
340080d0:	2b00      	cmp	r3, #0
340080d2:	d01a      	beq.n	3400810a <HAL_DCMIPP_CSI_IRQHandler+0x576>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKTERR) != 0U)
340080d4:	693b      	ldr	r3, [r7, #16]
340080d6:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
340080da:	2b00      	cmp	r3, #0
340080dc:	d015      	beq.n	3400810a <HAL_DCMIPP_CSI_IRQHandler+0x576>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKTERR);
340080de:	69fb      	ldr	r3, [r7, #28]
340080e0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340080e4:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
340080e8:	69fb      	ldr	r3, [r7, #28]
340080ea:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKTERR);
340080ee:	69fb      	ldr	r3, [r7, #28]
340080f0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
340080f4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SPKT;
340080f8:	687b      	ldr	r3, [r7, #4]
340080fa:	689b      	ldr	r3, [r3, #8]
340080fc:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
34008100:	687b      	ldr	r3, [r7, #4]
34008102:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34008104:	6878      	ldr	r0, [r7, #4]
34008106:	f000 fa10 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_IDERR) != 0U)
3400810a:	69bb      	ldr	r3, [r7, #24]
3400810c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34008110:	2b00      	cmp	r3, #0
34008112:	d01a      	beq.n	3400814a <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_IDERR) != 0U)
34008114:	693b      	ldr	r3, [r7, #16]
34008116:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400811a:	2b00      	cmp	r3, #0
3400811c:	d015      	beq.n	3400814a <HAL_DCMIPP_CSI_IRQHandler+0x5b6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_IDERR);
3400811e:	69fb      	ldr	r3, [r7, #28]
34008120:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008124:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
34008128:	69fb      	ldr	r3, [r7, #28]
3400812a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_IDERR);
3400812e:	69fb      	ldr	r3, [r7, #28]
34008130:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
34008134:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DATA_ID;
34008138:	687b      	ldr	r3, [r7, #4]
3400813a:	689b      	ldr	r3, [r3, #8]
3400813c:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
34008140:	687b      	ldr	r3, [r7, #4]
34008142:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34008144:	6878      	ldr	r0, [r7, #4]
34008146:	f000 f9f0 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CECCERR) != 0U)
3400814a:	69bb      	ldr	r3, [r7, #24]
3400814c:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
34008150:	2b00      	cmp	r3, #0
34008152:	d01a      	beq.n	3400818a <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CECCERR) != 0U)
34008154:	693b      	ldr	r3, [r7, #16]
34008156:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
3400815a:	2b00      	cmp	r3, #0
3400815c:	d015      	beq.n	3400818a <HAL_DCMIPP_CSI_IRQHandler+0x5f6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CECCERR);
3400815e:	69fb      	ldr	r3, [r7, #28]
34008160:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008164:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
34008168:	69fb      	ldr	r3, [r7, #28]
3400816a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CECCERR);
3400816e:	69fb      	ldr	r3, [r7, #28]
34008170:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
34008174:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CECC;
34008178:	687b      	ldr	r3, [r7, #4]
3400817a:	689b      	ldr	r3, [r3, #8]
3400817c:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34008180:	687b      	ldr	r3, [r7, #4]
34008182:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34008184:	6878      	ldr	r0, [r7, #4]
34008186:	f000 f9d0 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_ECCERR) != 0U)
3400818a:	69bb      	ldr	r3, [r7, #24]
3400818c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34008190:	2b00      	cmp	r3, #0
34008192:	d01a      	beq.n	340081ca <HAL_DCMIPP_CSI_IRQHandler+0x636>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_ECCERR) != 0U)
34008194:	693b      	ldr	r3, [r7, #16]
34008196:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400819a:	2b00      	cmp	r3, #0
3400819c:	d015      	beq.n	340081ca <HAL_DCMIPP_CSI_IRQHandler+0x636>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECCERR);
3400819e:	69fb      	ldr	r3, [r7, #28]
340081a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340081a4:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
340081a8:	69fb      	ldr	r3, [r7, #28]
340081aa:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECCERR);
340081ae:	69fb      	ldr	r3, [r7, #28]
340081b0:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
340081b4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_ECC;
340081b8:	687b      	ldr	r3, [r7, #4]
340081ba:	689b      	ldr	r3, [r3, #8]
340081bc:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
340081c0:	687b      	ldr	r3, [r7, #4]
340081c2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
340081c4:	6878      	ldr	r0, [r7, #4]
340081c6:	f000 f9b0 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_CRCERR) != 0U)
340081ca:	69bb      	ldr	r3, [r7, #24]
340081cc:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340081d0:	2b00      	cmp	r3, #0
340081d2:	d01a      	beq.n	3400820a <HAL_DCMIPP_CSI_IRQHandler+0x676>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_CRCERR) != 0U)
340081d4:	693b      	ldr	r3, [r7, #16]
340081d6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
340081da:	2b00      	cmp	r3, #0
340081dc:	d015      	beq.n	3400820a <HAL_DCMIPP_CSI_IRQHandler+0x676>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_CRCERR);
340081de:	69fb      	ldr	r3, [r7, #28]
340081e0:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340081e4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
340081e8:	69fb      	ldr	r3, [r7, #28]
340081ea:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_CRCERR);
340081ee:	69fb      	ldr	r3, [r7, #28]
340081f0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
340081f4:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_CRC;
340081f8:	687b      	ldr	r3, [r7, #4]
340081fa:	689b      	ldr	r3, [r3, #8]
340081fc:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
34008200:	687b      	ldr	r3, [r7, #4]
34008202:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ErrorCallback(hdcmipp);
#else
      HAL_DCMIPP_ErrorCallback(hdcmipp);
34008204:	6878      	ldr	r0, [r7, #4]
34008206:	f000 f990 	bl	3400852a <HAL_DCMIPP_ErrorCallback>
    }
  }

  /* Lane 0 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL0) != 0U)
3400820a:	697b      	ldr	r3, [r7, #20]
3400820c:	f003 0301 	and.w	r3, r3, #1
34008210:	2b00      	cmp	r3, #0
34008212:	d01d      	beq.n	34008250 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL0) != 0U)
34008214:	68fb      	ldr	r3, [r7, #12]
34008216:	f003 0301 	and.w	r3, r3, #1
3400821a:	2b00      	cmp	r3, #0
3400821c:	d018      	beq.n	34008250 <HAL_DCMIPP_CSI_IRQHandler+0x6bc>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL0);
3400821e:	69fb      	ldr	r3, [r7, #28]
34008220:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008224:	f023 0201 	bic.w	r2, r3, #1
34008228:	69fb      	ldr	r3, [r7, #28]
3400822a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL0);
3400822e:	69fb      	ldr	r3, [r7, #28]
34008230:	2201      	movs	r2, #1
34008232:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34008236:	687b      	ldr	r3, [r7, #4]
34008238:	689b      	ldr	r3, [r3, #8]
3400823a:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
3400823e:	687b      	ldr	r3, [r7, #4]
34008240:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008242:	687b      	ldr	r3, [r7, #4]
34008244:	2204      	movs	r2, #4
34008246:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
34008248:	2101      	movs	r1, #1
3400824a:	6878      	ldr	r0, [r7, #4]
3400824c:	f000 f977 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL0) != 0U)
34008250:	697b      	ldr	r3, [r7, #20]
34008252:	f003 0302 	and.w	r3, r3, #2
34008256:	2b00      	cmp	r3, #0
34008258:	d01d      	beq.n	34008296 <HAL_DCMIPP_CSI_IRQHandler+0x702>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL0) != 0U)
3400825a:	68fb      	ldr	r3, [r7, #12]
3400825c:	f003 0302 	and.w	r3, r3, #2
34008260:	2b00      	cmp	r3, #0
34008262:	d018      	beq.n	34008296 <HAL_DCMIPP_CSI_IRQHandler+0x702>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL0);
34008264:	69fb      	ldr	r3, [r7, #28]
34008266:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400826a:	f023 0202 	bic.w	r2, r3, #2
3400826e:	69fb      	ldr	r3, [r7, #28]
34008270:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL0);
34008274:	69fb      	ldr	r3, [r7, #28]
34008276:	2202      	movs	r2, #2
34008278:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
3400827c:	687b      	ldr	r3, [r7, #4]
3400827e:	689b      	ldr	r3, [r3, #8]
34008280:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
34008284:	687b      	ldr	r3, [r7, #4]
34008286:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008288:	687b      	ldr	r3, [r7, #4]
3400828a:	2204      	movs	r2, #4
3400828c:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400828e:	2101      	movs	r1, #1
34008290:	6878      	ldr	r0, [r7, #4]
34008292:	f000 f954 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL0) != 0U)
34008296:	697b      	ldr	r3, [r7, #20]
34008298:	f003 0304 	and.w	r3, r3, #4
3400829c:	2b00      	cmp	r3, #0
3400829e:	d01a      	beq.n	340082d6 <HAL_DCMIPP_CSI_IRQHandler+0x742>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL0) != 0U)
340082a0:	68fb      	ldr	r3, [r7, #12]
340082a2:	f003 0304 	and.w	r3, r3, #4
340082a6:	2b00      	cmp	r3, #0
340082a8:	d015      	beq.n	340082d6 <HAL_DCMIPP_CSI_IRQHandler+0x742>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL0);
340082aa:	69fb      	ldr	r3, [r7, #28]
340082ac:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340082b0:	f023 0204 	bic.w	r2, r3, #4
340082b4:	69fb      	ldr	r3, [r7, #28]
340082b6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL0);
340082ba:	69fb      	ldr	r3, [r7, #28]
340082bc:	2204      	movs	r2, #4
340082be:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
340082c2:	687b      	ldr	r3, [r7, #4]
340082c4:	689b      	ldr	r3, [r3, #8]
340082c6:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
340082ca:	687b      	ldr	r3, [r7, #4]
340082cc:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
340082ce:	2101      	movs	r1, #1
340082d0:	6878      	ldr	r0, [r7, #4]
340082d2:	f000 f934 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL0) != 0U)
340082d6:	697b      	ldr	r3, [r7, #20]
340082d8:	f003 0308 	and.w	r3, r3, #8
340082dc:	2b00      	cmp	r3, #0
340082de:	d01a      	beq.n	34008316 <HAL_DCMIPP_CSI_IRQHandler+0x782>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL0) != 0U)
340082e0:	68fb      	ldr	r3, [r7, #12]
340082e2:	f003 0308 	and.w	r3, r3, #8
340082e6:	2b00      	cmp	r3, #0
340082e8:	d015      	beq.n	34008316 <HAL_DCMIPP_CSI_IRQHandler+0x782>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL0);
340082ea:	69fb      	ldr	r3, [r7, #28]
340082ec:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340082f0:	f023 0208 	bic.w	r2, r3, #8
340082f4:	69fb      	ldr	r3, [r7, #28]
340082f6:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL0);
340082fa:	69fb      	ldr	r3, [r7, #28]
340082fc:	2208      	movs	r2, #8
340082fe:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34008302:	687b      	ldr	r3, [r7, #4]
34008304:	689b      	ldr	r3, [r3, #8]
34008306:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
3400830a:	687b      	ldr	r3, [r7, #4]
3400830c:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400830e:	2101      	movs	r1, #1
34008310:	6878      	ldr	r0, [r7, #4]
34008312:	f000 f914 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_FLAG_ECTRLDL0) != 0U)
34008316:	697b      	ldr	r3, [r7, #20]
34008318:	f003 0310 	and.w	r3, r3, #16
3400831c:	2b00      	cmp	r3, #0
3400831e:	d01a      	beq.n	34008356 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL0) != 0U)
34008320:	68fb      	ldr	r3, [r7, #12]
34008322:	f003 0310 	and.w	r3, r3, #16
34008326:	2b00      	cmp	r3, #0
34008328:	d015      	beq.n	34008356 <HAL_DCMIPP_CSI_IRQHandler+0x7c2>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL0);
3400832a:	69fb      	ldr	r3, [r7, #28]
3400832c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008330:	f023 0210 	bic.w	r2, r3, #16
34008334:	69fb      	ldr	r3, [r7, #28]
34008336:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ECTRLDL0);
3400833a:	69fb      	ldr	r3, [r7, #28]
3400833c:	2210      	movs	r2, #16
3400833e:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34008342:	687b      	ldr	r3, [r7, #4]
34008344:	689b      	ldr	r3, [r3, #8]
34008346:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
3400834a:	687b      	ldr	r3, [r7, #4]
3400834c:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE0);
3400834e:	2101      	movs	r1, #1
34008350:	6878      	ldr	r0, [r7, #4]
34008352:	f000 f8f4 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
    }
  }

  /* Lane 1 Errors */
  /* Start Of Transmission error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTDL1) != 0U)
34008356:	697b      	ldr	r3, [r7, #20]
34008358:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400835c:	2b00      	cmp	r3, #0
3400835e:	d01e      	beq.n	3400839e <HAL_DCMIPP_CSI_IRQHandler+0x80a>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTDL1) != 0U)
34008360:	68fb      	ldr	r3, [r7, #12]
34008362:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34008366:	2b00      	cmp	r3, #0
34008368:	d019      	beq.n	3400839e <HAL_DCMIPP_CSI_IRQHandler+0x80a>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTDL1);
3400836a:	69fb      	ldr	r3, [r7, #28]
3400836c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008370:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34008374:	69fb      	ldr	r3, [r7, #28]
34008376:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTDL1);
3400837a:	69fb      	ldr	r3, [r7, #28]
3400837c:	f44f 7280 	mov.w	r2, #256	@ 0x100
34008380:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT;
34008384:	687b      	ldr	r3, [r7, #4]
34008386:	689b      	ldr	r3, [r3, #8]
34008388:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
3400838c:	687b      	ldr	r3, [r7, #4]
3400838e:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
34008390:	687b      	ldr	r3, [r7, #4]
34008392:	2204      	movs	r2, #4
34008394:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34008396:	2102      	movs	r1, #2
34008398:	6878      	ldr	r0, [r7, #4]
3400839a:	f000 f8d0 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Start Of Transmission Synchronisation error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESOTSYNCDL1) != 0U)
3400839e:	697b      	ldr	r3, [r7, #20]
340083a0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340083a4:	2b00      	cmp	r3, #0
340083a6:	d01e      	beq.n	340083e6 <HAL_DCMIPP_CSI_IRQHandler+0x852>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESOTSYNCDL1) != 0U)
340083a8:	68fb      	ldr	r3, [r7, #12]
340083aa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
340083ae:	2b00      	cmp	r3, #0
340083b0:	d019      	beq.n	340083e6 <HAL_DCMIPP_CSI_IRQHandler+0x852>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESOTSYNCDL1);
340083b2:	69fb      	ldr	r3, [r7, #28]
340083b4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340083b8:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
340083bc:	69fb      	ldr	r3, [r7, #28]
340083be:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESOTSYNCDL1);
340083c2:	69fb      	ldr	r3, [r7, #28]
340083c4:	f44f 7200 	mov.w	r2, #512	@ 0x200
340083c8:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_SOT_SYNC;
340083cc:	687b      	ldr	r3, [r7, #4]
340083ce:	689b      	ldr	r3, [r3, #8]
340083d0:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
340083d4:	687b      	ldr	r3, [r7, #4]
340083d6:	609a      	str	r2, [r3, #8]

      /* Change CSI state */
      hdcmipp->State = HAL_DCMIPP_STATE_ERROR;
340083d8:	687b      	ldr	r3, [r7, #4]
340083da:	2204      	movs	r2, #4
340083dc:	711a      	strb	r2, [r3, #4]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340083de:	2102      	movs	r1, #2
340083e0:	6878      	ldr	r0, [r7, #4]
340083e2:	f000 f8ac 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Escape entry error   */
  if ((sr1flags & DCMIPP_CSI_FLAG_EESCDL1) != 0U)
340083e6:	697b      	ldr	r3, [r7, #20]
340083e8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340083ec:	2b00      	cmp	r3, #0
340083ee:	d01b      	beq.n	34008428 <HAL_DCMIPP_CSI_IRQHandler+0x894>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_EESCDL1) != 0U)
340083f0:	68fb      	ldr	r3, [r7, #12]
340083f2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340083f6:	2b00      	cmp	r3, #0
340083f8:	d016      	beq.n	34008428 <HAL_DCMIPP_CSI_IRQHandler+0x894>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_EESCDL1);
340083fa:	69fb      	ldr	r3, [r7, #28]
340083fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008400:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
34008404:	69fb      	ldr	r3, [r7, #28]
34008406:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_EESCDL1);
3400840a:	69fb      	ldr	r3, [r7, #28]
3400840c:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34008410:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_ESCAPE;
34008414:	687b      	ldr	r3, [r7, #4]
34008416:	689b      	ldr	r3, [r3, #8]
34008418:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
3400841c:	687b      	ldr	r3, [r7, #4]
3400841e:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34008420:	2102      	movs	r1, #2
34008422:	6878      	ldr	r0, [r7, #4]
34008424:	f000 f88b 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Low power data transmission synchronization error  */
  if ((sr1flags & DCMIPP_CSI_FLAG_ESYNCESCDL1) != 0U)
34008428:	697b      	ldr	r3, [r7, #20]
3400842a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400842e:	2b00      	cmp	r3, #0
34008430:	d01b      	beq.n	3400846a <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ESYNCESCDL1) != 0U)
34008432:	68fb      	ldr	r3, [r7, #12]
34008434:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34008438:	2b00      	cmp	r3, #0
3400843a:	d016      	beq.n	3400846a <HAL_DCMIPP_CSI_IRQHandler+0x8d6>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ESYNCESCDL1);
3400843c:	69fb      	ldr	r3, [r7, #28]
3400843e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008442:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
34008446:	69fb      	ldr	r3, [r7, #28]
34008448:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_FLAG_ESYNCESCDL1);
3400844c:	69fb      	ldr	r3, [r7, #28]
3400844e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34008452:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_LP_SYNC;
34008456:	687b      	ldr	r3, [r7, #4]
34008458:	689b      	ldr	r3, [r3, #8]
3400845a:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
3400845e:	687b      	ldr	r3, [r7, #4]
34008460:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
34008462:	2102      	movs	r1, #2
34008464:	6878      	ldr	r0, [r7, #4]
34008466:	f000 f86a 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  /* Error control on data line */
  if ((sr1flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
3400846a:	697b      	ldr	r3, [r7, #20]
3400846c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34008470:	2b00      	cmp	r3, #0
34008472:	d01b      	beq.n	340084ac <HAL_DCMIPP_CSI_IRQHandler+0x918>
  {
    if ((ier1_flags & DCMIPP_CSI_IT_ECTRLDL1) != 0U)
34008474:	68fb      	ldr	r3, [r7, #12]
34008476:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400847a:	2b00      	cmp	r3, #0
3400847c:	d016      	beq.n	340084ac <HAL_DCMIPP_CSI_IRQHandler+0x918>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
3400847e:	69fb      	ldr	r3, [r7, #28]
34008480:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34008484:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
34008488:	69fb      	ldr	r3, [r7, #28]
3400848a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_DPHY_FLAG(csi_instance, DCMIPP_CSI_IT_ECTRLDL1);
3400848e:	69fb      	ldr	r3, [r7, #28]
34008490:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34008494:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104

      /* Update error code */
      hdcmipp->ErrorCode |= HAL_DCMIPP_CSI_ERROR_DPHY_CTRL;
34008498:	687b      	ldr	r3, [r7, #4]
3400849a:	689b      	ldr	r3, [r3, #8]
3400849c:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
340084a0:	687b      	ldr	r3, [r7, #4]
340084a2:	609a      	str	r2, [r3, #8]

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
#else
      HAL_DCMIPP_CSI_LineErrorCallback(hdcmipp, DCMIPP_CSI_DATA_LANE1);
340084a4:	2102      	movs	r1, #2
340084a6:	6878      	ldr	r0, [r7, #4]
340084a8:	f000 f849 	bl	3400853e <HAL_DCMIPP_CSI_LineErrorCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }

  if ((sr0flags & DCMIPP_CSI_FLAG_SPKT) != 0U)
340084ac:	69bb      	ldr	r3, [r7, #24]
340084ae:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340084b2:	2b00      	cmp	r3, #0
340084b4:	d014      	beq.n	340084e0 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
  {
    if ((ier0_flags & DCMIPP_CSI_IT_SPKT) != 0U)
340084b6:	693b      	ldr	r3, [r7, #16]
340084b8:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340084bc:	2b00      	cmp	r3, #0
340084be:	d00f      	beq.n	340084e0 <HAL_DCMIPP_CSI_IRQHandler+0x94c>
    {
      /* Disable IT */
      __HAL_DCMIPP_CSI_DISABLE_IT(csi_instance, DCMIPP_CSI_IT_SPKT);
340084c0:	69fb      	ldr	r3, [r7, #28]
340084c2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340084c6:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
340084ca:	69fb      	ldr	r3, [r7, #28]
340084cc:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

      /* Clear Flag */
      __HAL_DCMIPP_CSI_CLEAR_FLAG(csi_instance, DCMIPP_CSI_FLAG_SPKT);
340084d0:	69fb      	ldr	r3, [r7, #28]
340084d2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
340084d6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100

      /* Error Callback */
#if (USE_HAL_DCMIPP_REGISTER_CALLBACKS == 1)
      hdcmipp->ShortPacketDetectionEventCallback(hdcmipp);
#else
      HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(hdcmipp);
340084da:	6878      	ldr	r0, [r7, #4]
340084dc:	f000 f844 	bl	34008568 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>
#endif /* USE_HAL_DCMIPP_REGISTER_CALLBACKS */
    }
  }
}
340084e0:	bf00      	nop
340084e2:	3720      	adds	r7, #32
340084e4:	46bd      	mov	sp, r7
340084e6:	bd80      	pop	{r7, pc}

340084e8 <HAL_DCMIPP_PIPE_LineEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LineEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340084e8:	b480      	push	{r7}
340084ea:	b083      	sub	sp, #12
340084ec:	af00      	add	r7, sp, #0
340084ee:	6078      	str	r0, [r7, #4]
340084f0:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LineEventMainPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
340084f2:	bf00      	nop
340084f4:	370c      	adds	r7, #12
340084f6:	46bd      	mov	sp, r7
340084f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340084fc:	4770      	bx	lr

340084fe <HAL_DCMIPP_PIPE_LimitEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_LimitEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340084fe:	b480      	push	{r7}
34008500:	b083      	sub	sp, #12
34008502:	af00      	add	r7, sp, #0
34008504:	6078      	str	r0, [r7, #4]
34008506:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_LimitEventDumpPipeCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
34008508:	bf00      	nop
3400850a:	370c      	adds	r7, #12
3400850c:	46bd      	mov	sp, r7
3400850e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008512:	4770      	bx	lr

34008514 <HAL_DCMIPP_PIPE_ErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
__weak void HAL_DCMIPP_PIPE_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008514:	b480      	push	{r7}
34008516:	b083      	sub	sp, #12
34008518:	af00      	add	r7, sp, #0
3400851a:	6078      	str	r0, [r7, #4]
3400851c:	6039      	str	r1, [r7, #0]
            the HAL_DCMIPP_SyncErrorEventCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Pipe);
  UNUSED(hdcmipp);
}
3400851e:	bf00      	nop
34008520:	370c      	adds	r7, #12
34008522:	46bd      	mov	sp, r7
34008524:	f85d 7b04 	ldr.w	r7, [sp], #4
34008528:	4770      	bx	lr

3400852a <HAL_DCMIPP_ErrorCallback>:
  * @brief  Error callback on DCMIPP
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_ErrorCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
3400852a:	b480      	push	{r7}
3400852c:	b083      	sub	sp, #12
3400852e:	af00      	add	r7, sp, #0
34008530:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_ErrorCallback could be implemented in the user file
   */
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hdcmipp);
}
34008532:	bf00      	nop
34008534:	370c      	adds	r7, #12
34008536:	46bd      	mov	sp, r7
34008538:	f85d 7b04 	ldr.w	r7, [sp], #4
3400853c:	4770      	bx	lr

3400853e <HAL_DCMIPP_CSI_LineErrorCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  DataLane
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineErrorCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t DataLane)
{
3400853e:	b480      	push	{r7}
34008540:	b083      	sub	sp, #12
34008542:	af00      	add	r7, sp, #0
34008544:	6078      	str	r0, [r7, #4]
34008546:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_LineErrorCallback could be implemented in the user file
   */
  UNUSED(DataLane);
  UNUSED(hdcmipp);
}
34008548:	bf00      	nop
3400854a:	370c      	adds	r7, #12
3400854c:	46bd      	mov	sp, r7
3400854e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008552:	4770      	bx	lr

34008554 <HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback>:
  * @brief  Clock Changer Fifo Full Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34008554:	b480      	push	{r7}
34008556:	b083      	sub	sp, #12
34008558:	af00      	add	r7, sp, #0
3400855a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ClockChangerFifoFullEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
3400855c:	bf00      	nop
3400855e:	370c      	adds	r7, #12
34008560:	46bd      	mov	sp, r7
34008562:	f85d 7b04 	ldr.w	r7, [sp], #4
34008566:	4770      	bx	lr

34008568 <HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback>:
  * @brief  Short Packet Detection Event Callback
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback(DCMIPP_HandleTypeDef *hdcmipp)
{
34008568:	b480      	push	{r7}
3400856a:	b083      	sub	sp, #12
3400856c:	af00      	add	r7, sp, #0
3400856e:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_ShortPacketDetectionEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
}
34008570:	bf00      	nop
34008572:	370c      	adds	r7, #12
34008574:	46bd      	mov	sp, r7
34008576:	f85d 7b04 	ldr.w	r7, [sp], #4
3400857a:	4770      	bx	lr

3400857c <HAL_DCMIPP_CSI_EndOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_EndOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
3400857c:	b480      	push	{r7}
3400857e:	b083      	sub	sp, #12
34008580:	af00      	add	r7, sp, #0
34008582:	6078      	str	r0, [r7, #4]
34008584:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_EndOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
34008586:	bf00      	nop
34008588:	370c      	adds	r7, #12
3400858a:	46bd      	mov	sp, r7
3400858c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008590:	4770      	bx	lr

34008592 <HAL_DCMIPP_CSI_StartOfFrameEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  VirtualChannel
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_StartOfFrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t VirtualChannel)
{
34008592:	b480      	push	{r7}
34008594:	b083      	sub	sp, #12
34008596:	af00      	add	r7, sp, #0
34008598:	6078      	str	r0, [r7, #4]
3400859a:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_StartOfFrameEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(VirtualChannel);
}
3400859c:	bf00      	nop
3400859e:	370c      	adds	r7, #12
340085a0:	46bd      	mov	sp, r7
340085a2:	f85d 7b04 	ldr.w	r7, [sp], #4
340085a6:	4770      	bx	lr

340085a8 <HAL_DCMIPP_CSI_TimerCounterEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Timer
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_TimerCounterEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Timer)
{
340085a8:	b480      	push	{r7}
340085aa:	b083      	sub	sp, #12
340085ac:	af00      	add	r7, sp, #0
340085ae:	6078      	str	r0, [r7, #4]
340085b0:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_DCMIPP_CSI_TimerCounterEventCallback could be implemented in the user file
   */
  UNUSED(hdcmipp);
  UNUSED(Timer);
}
340085b2:	bf00      	nop
340085b4:	370c      	adds	r7, #12
340085b6:	46bd      	mov	sp, r7
340085b8:	f85d 7b04 	ldr.w	r7, [sp], #4
340085bc:	4770      	bx	lr

340085be <HAL_DCMIPP_CSI_LineByteEventCallback>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Counter
  * @retval None
  */
__weak void HAL_DCMIPP_CSI_LineByteEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Counter)
{
340085be:	b480      	push	{r7}
340085c0:	b083      	sub	sp, #12
340085c2:	af00      	add	r7, sp, #0
340085c4:	6078      	str	r0, [r7, #4]
340085c6:	6039      	str	r1, [r7, #0]
  /* NOTE : This function Should not be modified, when the callback is needed,
          the HAL_DCMIPP_CSI_LineByteEventCallback could be implemented in the user file
  */
  UNUSED(hdcmipp);
  UNUSED(Counter);
}
340085c8:	bf00      	nop
340085ca:	370c      	adds	r7, #12
340085cc:	46bd      	mov	sp, r7
340085ce:	f85d 7b04 	ldr.w	r7, [sp], #4
340085d2:	4770      	bx	lr

340085d4 <HAL_DCMIPP_PIPE_SetCropConfig>:
  *                     the configuration information for Crop.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetCropConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                const DCMIPP_CropConfTypeDef *pCropConfig)
{
340085d4:	b480      	push	{r7}
340085d6:	b087      	sub	sp, #28
340085d8:	af00      	add	r7, sp, #0
340085da:	60f8      	str	r0, [r7, #12]
340085dc:	60b9      	str	r1, [r7, #8]
340085de:	607a      	str	r2, [r7, #4]
  uint32_t tmp;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCropConfig == NULL))
340085e0:	68fb      	ldr	r3, [r7, #12]
340085e2:	2b00      	cmp	r3, #0
340085e4:	d002      	beq.n	340085ec <HAL_DCMIPP_PIPE_SetCropConfig+0x18>
340085e6:	687b      	ldr	r3, [r7, #4]
340085e8:	2b00      	cmp	r3, #0
340085ea:	d101      	bne.n	340085f0 <HAL_DCMIPP_PIPE_SetCropConfig+0x1c>
  {
    return HAL_ERROR;
340085ec:	2301      	movs	r3, #1
340085ee:	e090      	b.n	34008712 <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  assert_param(IS_DCMIPP_PIPE_CROP_HSIZE(pCropConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSIZE(pCropConfig->VSize));
  assert_param(IS_DCMIPP_PIPE_CROP_VSTART(pCropConfig->VStart));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
340085f0:	68fb      	ldr	r3, [r7, #12]
340085f2:	791b      	ldrb	r3, [r3, #4]
340085f4:	b2db      	uxtb	r3, r3
340085f6:	2b02      	cmp	r3, #2
340085f8:	f040 8088 	bne.w	3400870c <HAL_DCMIPP_PIPE_SetCropConfig+0x138>
  {

    if (Pipe == DCMIPP_PIPE0)
340085fc:	68bb      	ldr	r3, [r7, #8]
340085fe:	2b00      	cmp	r3, #0
34008600:	d136      	bne.n	34008670 <HAL_DCMIPP_PIPE_SetCropConfig+0x9c>
    {
      tmp = READ_REG(hdcmipp->Instance->PRCR);
34008602:	68fb      	ldr	r3, [r7, #12]
34008604:	681b      	ldr	r3, [r3, #0]
34008606:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3400860a:	617b      	str	r3, [r7, #20]

      /* Verify for parallel mode with jpeg format , no Line Crop enable  */
      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
3400860c:	697b      	ldr	r3, [r7, #20]
3400860e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34008612:	2b00      	cmp	r3, #0
34008614:	d006      	beq.n	34008624 <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
34008616:	697b      	ldr	r3, [r7, #20]
34008618:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3400861c:	2b00      	cmp	r3, #0
3400861e:	d101      	bne.n	34008624 <HAL_DCMIPP_PIPE_SetCropConfig+0x50>
      {
        return HAL_ERROR;
34008620:	2301      	movs	r3, #1
34008622:	e076      	b.n	34008712 <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
      }
      else
      {
        /* Set Cropping horizontal and vertical start for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSTR, DCMIPP_P0SCSTR_HSTART | DCMIPP_P0SCSTR_VSTART,
34008624:	68fb      	ldr	r3, [r7, #12]
34008626:	681b      	ldr	r3, [r3, #0]
34008628:	f8d3 3504 	ldr.w	r3, [r3, #1284]	@ 0x504
3400862c:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34008630:	687b      	ldr	r3, [r7, #4]
34008632:	685a      	ldr	r2, [r3, #4]
34008634:	687b      	ldr	r3, [r7, #4]
34008636:	681b      	ldr	r3, [r3, #0]
34008638:	041b      	lsls	r3, r3, #16
3400863a:	431a      	orrs	r2, r3
3400863c:	68fb      	ldr	r3, [r7, #12]
3400863e:	681b      	ldr	r3, [r3, #0]
34008640:	430a      	orrs	r2, r1
34008642:	f8c3 2504 	str.w	r2, [r3, #1284]	@ 0x504
                   (pCropConfig->HStart << DCMIPP_P0SCSTR_HSTART_Pos) |
                   (pCropConfig->VStart << DCMIPP_P0SCSTR_VSTART_Pos));

        /* Set Cropping horizontal and vertical width for Pipe0 */
        /* Set crop Area (Inner or outer) for Pipe0 */
        MODIFY_REG(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_HSIZE | DCMIPP_P0SCSZR_VSIZE | DCMIPP_P0SCSZR_POSNEG,
34008646:	68fb      	ldr	r3, [r7, #12]
34008648:	681b      	ldr	r3, [r3, #0]
3400864a:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
3400864e:	4b34      	ldr	r3, [pc, #208]	@ (34008720 <HAL_DCMIPP_PIPE_SetCropConfig+0x14c>)
34008650:	4013      	ands	r3, r2
34008652:	687a      	ldr	r2, [r7, #4]
34008654:	68d1      	ldr	r1, [r2, #12]
34008656:	687a      	ldr	r2, [r7, #4]
34008658:	6892      	ldr	r2, [r2, #8]
3400865a:	0412      	lsls	r2, r2, #16
3400865c:	4311      	orrs	r1, r2
3400865e:	687a      	ldr	r2, [r7, #4]
34008660:	6912      	ldr	r2, [r2, #16]
34008662:	4311      	orrs	r1, r2
34008664:	68fa      	ldr	r2, [r7, #12]
34008666:	6812      	ldr	r2, [r2, #0]
34008668:	430b      	orrs	r3, r1
3400866a:	f8c2 3508 	str.w	r3, [r2, #1288]	@ 0x508
3400866e:	e04f      	b.n	34008710 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                   (pCropConfig->HSize << DCMIPP_P0SCSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P0SCSZR_VSIZE_Pos) |
                   (pCropConfig->PipeArea));
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34008670:	68bb      	ldr	r3, [r7, #8]
34008672:	2b01      	cmp	r3, #1
34008674:	d122      	bne.n	340086bc <HAL_DCMIPP_PIPE_SetCropConfig+0xe8>
    {
      /* Set Cropping horizontal and vertical start for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSTR, DCMIPP_P1CRSTR_HSTART | DCMIPP_P1CRSTR_VSTART,
34008676:	68fb      	ldr	r3, [r7, #12]
34008678:	681b      	ldr	r3, [r3, #0]
3400867a:	f8d3 3904 	ldr.w	r3, [r3, #2308]	@ 0x904
3400867e:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34008682:	687b      	ldr	r3, [r7, #4]
34008684:	685a      	ldr	r2, [r3, #4]
34008686:	687b      	ldr	r3, [r7, #4]
34008688:	681b      	ldr	r3, [r3, #0]
3400868a:	041b      	lsls	r3, r3, #16
3400868c:	431a      	orrs	r2, r3
3400868e:	68fb      	ldr	r3, [r7, #12]
34008690:	681b      	ldr	r3, [r3, #0]
34008692:	430a      	orrs	r2, r1
34008694:	f8c3 2904 	str.w	r2, [r3, #2308]	@ 0x904
                 (pCropConfig->HStart << DCMIPP_P1CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P1CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe1 */
      MODIFY_REG(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_HSIZE | DCMIPP_P1CRSZR_VSIZE,
34008698:	68fb      	ldr	r3, [r7, #12]
3400869a:	681b      	ldr	r3, [r3, #0]
3400869c:	f8d3 3908 	ldr.w	r3, [r3, #2312]	@ 0x908
340086a0:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
340086a4:	687b      	ldr	r3, [r7, #4]
340086a6:	68da      	ldr	r2, [r3, #12]
340086a8:	687b      	ldr	r3, [r7, #4]
340086aa:	689b      	ldr	r3, [r3, #8]
340086ac:	041b      	lsls	r3, r3, #16
340086ae:	431a      	orrs	r2, r3
340086b0:	68fb      	ldr	r3, [r7, #12]
340086b2:	681b      	ldr	r3, [r3, #0]
340086b4:	430a      	orrs	r2, r1
340086b6:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
340086ba:	e029      	b.n	34008710 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P1CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P1CRSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
340086bc:	68bb      	ldr	r3, [r7, #8]
340086be:	2b02      	cmp	r3, #2
340086c0:	d122      	bne.n	34008708 <HAL_DCMIPP_PIPE_SetCropConfig+0x134>
    {
      /* Set Cropping horizontal and vertical start for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSTR, DCMIPP_P2CRSTR_HSTART | DCMIPP_P2CRSTR_VSTART,
340086c2:	68fb      	ldr	r3, [r7, #12]
340086c4:	681b      	ldr	r3, [r3, #0]
340086c6:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	@ 0xd04
340086ca:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
340086ce:	687b      	ldr	r3, [r7, #4]
340086d0:	685a      	ldr	r2, [r3, #4]
340086d2:	687b      	ldr	r3, [r7, #4]
340086d4:	681b      	ldr	r3, [r3, #0]
340086d6:	041b      	lsls	r3, r3, #16
340086d8:	431a      	orrs	r2, r3
340086da:	68fb      	ldr	r3, [r7, #12]
340086dc:	681b      	ldr	r3, [r3, #0]
340086de:	430a      	orrs	r2, r1
340086e0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
                 (pCropConfig->HStart << DCMIPP_P2CRSTR_HSTART_Pos) | \
                 (pCropConfig->VStart << DCMIPP_P2CRSTR_VSTART_Pos));

      /* Set Cropping horizontal and vertical width for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_HSIZE | DCMIPP_P2CRSZR_VSIZE,
340086e4:	68fb      	ldr	r3, [r7, #12]
340086e6:	681b      	ldr	r3, [r3, #0]
340086e8:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	@ 0xd08
340086ec:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
340086f0:	687b      	ldr	r3, [r7, #4]
340086f2:	68da      	ldr	r2, [r3, #12]
340086f4:	687b      	ldr	r3, [r7, #4]
340086f6:	689b      	ldr	r3, [r3, #8]
340086f8:	041b      	lsls	r3, r3, #16
340086fa:	431a      	orrs	r2, r3
340086fc:	68fb      	ldr	r3, [r7, #12]
340086fe:	681b      	ldr	r3, [r3, #0]
34008700:	430a      	orrs	r2, r1
34008702:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34008706:	e003      	b.n	34008710 <HAL_DCMIPP_PIPE_SetCropConfig+0x13c>
                 (pCropConfig->HSize << DCMIPP_P2CRSZR_HSIZE_Pos) | (pCropConfig->VSize << DCMIPP_P2CRSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
34008708:	2301      	movs	r3, #1
3400870a:	e002      	b.n	34008712 <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
    }
  }
  else
  {
    return HAL_ERROR;
3400870c:	2301      	movs	r3, #1
3400870e:	e000      	b.n	34008712 <HAL_DCMIPP_PIPE_SetCropConfig+0x13e>
  }

  return HAL_OK;
34008710:	2300      	movs	r3, #0
}
34008712:	4618      	mov	r0, r3
34008714:	371c      	adds	r7, #28
34008716:	46bd      	mov	sp, r7
34008718:	f85d 7b04 	ldr.w	r7, [sp], #4
3400871c:	4770      	bx	lr
3400871e:	bf00      	nop
34008720:	b000f000 	.word	0xb000f000

34008724 <HAL_DCMIPP_PIPE_EnableCrop>:
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @note   Cropping cannot be enabled in parallel mode with JPEG Format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008724:	b480      	push	{r7}
34008726:	b085      	sub	sp, #20
34008728:	af00      	add	r7, sp, #0
3400872a:	6078      	str	r0, [r7, #4]
3400872c:	6039      	str	r1, [r7, #0]
  uint32_t tmp;

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
3400872e:	687b      	ldr	r3, [r7, #4]
34008730:	2b00      	cmp	r3, #0
34008732:	d101      	bne.n	34008738 <HAL_DCMIPP_PIPE_EnableCrop+0x14>
  {
    return HAL_ERROR;
34008734:	2301      	movs	r3, #1
34008736:	e04d      	b.n	340087d4 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34008738:	687b      	ldr	r3, [r7, #4]
3400873a:	791b      	ldrb	r3, [r3, #4]
3400873c:	b2db      	uxtb	r3, r3
3400873e:	2b02      	cmp	r3, #2
34008740:	d145      	bne.n	340087ce <HAL_DCMIPP_PIPE_EnableCrop+0xaa>
  {
    if (Pipe == DCMIPP_PIPE0)
34008742:	683b      	ldr	r3, [r7, #0]
34008744:	2b00      	cmp	r3, #0
34008746:	d11b      	bne.n	34008780 <HAL_DCMIPP_PIPE_EnableCrop+0x5c>
    {
      /* This bit must be kept cleared if the input format is JPEG */
      /* Verify for parallel mode with jpeg format , no Line Crop enable  */

      tmp = READ_REG(hdcmipp->Instance->PRCR);
34008748:	687b      	ldr	r3, [r7, #4]
3400874a:	681b      	ldr	r3, [r3, #0]
3400874c:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34008750:	60fb      	str	r3, [r7, #12]

      if (((tmp & DCMIPP_PRCR_ENABLE) == DCMIPP_PRCR_ENABLE) && ((tmp & DCMIPP_PRCR_FORMAT) == DCMIPP_FORMAT_BYTE))
34008752:	68fb      	ldr	r3, [r7, #12]
34008754:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34008758:	2b00      	cmp	r3, #0
3400875a:	d006      	beq.n	3400876a <HAL_DCMIPP_PIPE_EnableCrop+0x46>
3400875c:	68fb      	ldr	r3, [r7, #12]
3400875e:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34008762:	2b00      	cmp	r3, #0
34008764:	d101      	bne.n	3400876a <HAL_DCMIPP_PIPE_EnableCrop+0x46>
      {
        return HAL_ERROR;
34008766:	2301      	movs	r3, #1
34008768:	e034      	b.n	340087d4 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
      else
      {
        SET_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
3400876a:	687b      	ldr	r3, [r7, #4]
3400876c:	681b      	ldr	r3, [r3, #0]
3400876e:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34008772:	687b      	ldr	r3, [r7, #4]
34008774:	681b      	ldr	r3, [r3, #0]
34008776:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400877a:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
3400877e:	e028      	b.n	340087d2 <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
    }
    else if (Pipe == DCMIPP_PIPE1)
34008780:	683b      	ldr	r3, [r7, #0]
34008782:	2b01      	cmp	r3, #1
34008784:	d113      	bne.n	340087ae <HAL_DCMIPP_PIPE_EnableCrop+0x8a>
    {
      /* Verify Crop line is disabled */
      if (hdcmipp->Instance->P1SRCR != DCMIPP_P1SRCR_CROPEN)
34008786:	687b      	ldr	r3, [r7, #4]
34008788:	681b      	ldr	r3, [r3, #0]
3400878a:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
3400878e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34008792:	d00a      	beq.n	340087aa <HAL_DCMIPP_PIPE_EnableCrop+0x86>
      {
        SET_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34008794:	687b      	ldr	r3, [r7, #4]
34008796:	681b      	ldr	r3, [r3, #0]
34008798:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
3400879c:	687b      	ldr	r3, [r7, #4]
3400879e:	681b      	ldr	r3, [r3, #0]
340087a0:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
340087a4:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
340087a8:	e013      	b.n	340087d2 <HAL_DCMIPP_PIPE_EnableCrop+0xae>
      }
      else
      {
        return HAL_ERROR;
340087aa:	2301      	movs	r3, #1
340087ac:	e012      	b.n	340087d4 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
      }
    }
    else if (Pipe == DCMIPP_PIPE2)
340087ae:	683b      	ldr	r3, [r7, #0]
340087b0:	2b02      	cmp	r3, #2
340087b2:	d10a      	bne.n	340087ca <HAL_DCMIPP_PIPE_EnableCrop+0xa6>
    {
      SET_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
340087b4:	687b      	ldr	r3, [r7, #4]
340087b6:	681b      	ldr	r3, [r3, #0]
340087b8:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
340087bc:	687b      	ldr	r3, [r7, #4]
340087be:	681b      	ldr	r3, [r3, #0]
340087c0:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
340087c4:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
340087c8:	e003      	b.n	340087d2 <HAL_DCMIPP_PIPE_EnableCrop+0xae>
    }
    else
    {
      return HAL_ERROR;
340087ca:	2301      	movs	r3, #1
340087cc:	e002      	b.n	340087d4 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
    }
  }
  else
  {
    return HAL_ERROR;
340087ce:	2301      	movs	r3, #1
340087d0:	e000      	b.n	340087d4 <HAL_DCMIPP_PIPE_EnableCrop+0xb0>
  }

  return HAL_OK;
340087d2:	2300      	movs	r3, #0
}
340087d4:	4618      	mov	r0, r3
340087d6:	3714      	adds	r7, #20
340087d8:	46bd      	mov	sp, r7
340087da:	f85d 7b04 	ldr.w	r7, [sp], #4
340087de:	4770      	bx	lr

340087e0 <HAL_DCMIPP_PIPE_DisableCrop>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableCrop(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340087e0:	b480      	push	{r7}
340087e2:	b083      	sub	sp, #12
340087e4:	af00      	add	r7, sp, #0
340087e6:	6078      	str	r0, [r7, #4]
340087e8:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
340087ea:	687b      	ldr	r3, [r7, #4]
340087ec:	2b00      	cmp	r3, #0
340087ee:	d101      	bne.n	340087f4 <HAL_DCMIPP_PIPE_DisableCrop+0x14>
  {
    return HAL_ERROR;
340087f0:	2301      	movs	r3, #1
340087f2:	e02c      	b.n	3400884e <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  if (Pipe == DCMIPP_PIPE0)
340087f4:	683b      	ldr	r3, [r7, #0]
340087f6:	2b00      	cmp	r3, #0
340087f8:	d10a      	bne.n	34008810 <HAL_DCMIPP_PIPE_DisableCrop+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P0SCSZR, DCMIPP_P0SCSZR_ENABLE);
340087fa:	687b      	ldr	r3, [r7, #4]
340087fc:	681b      	ldr	r3, [r3, #0]
340087fe:	f8d3 2508 	ldr.w	r2, [r3, #1288]	@ 0x508
34008802:	687b      	ldr	r3, [r7, #4]
34008804:	681b      	ldr	r3, [r3, #0]
34008806:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
3400880a:	f8c3 2508 	str.w	r2, [r3, #1288]	@ 0x508
3400880e:	e01d      	b.n	3400884c <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE1)
34008810:	683b      	ldr	r3, [r7, #0]
34008812:	2b01      	cmp	r3, #1
34008814:	d10a      	bne.n	3400882c <HAL_DCMIPP_PIPE_DisableCrop+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CRSZR, DCMIPP_P1CRSZR_ENABLE);
34008816:	687b      	ldr	r3, [r7, #4]
34008818:	681b      	ldr	r3, [r3, #0]
3400881a:	f8d3 2908 	ldr.w	r2, [r3, #2312]	@ 0x908
3400881e:	687b      	ldr	r3, [r7, #4]
34008820:	681b      	ldr	r3, [r3, #0]
34008822:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34008826:	f8c3 2908 	str.w	r2, [r3, #2312]	@ 0x908
3400882a:	e00f      	b.n	3400884c <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else if (Pipe == DCMIPP_PIPE2)
3400882c:	683b      	ldr	r3, [r7, #0]
3400882e:	2b02      	cmp	r3, #2
34008830:	d10a      	bne.n	34008848 <HAL_DCMIPP_PIPE_DisableCrop+0x68>
  {
    CLEAR_BIT(hdcmipp->Instance->P2CRSZR, DCMIPP_P2CRSZR_ENABLE);
34008832:	687b      	ldr	r3, [r7, #4]
34008834:	681b      	ldr	r3, [r3, #0]
34008836:	f8d3 2d08 	ldr.w	r2, [r3, #3336]	@ 0xd08
3400883a:	687b      	ldr	r3, [r7, #4]
3400883c:	681b      	ldr	r3, [r3, #0]
3400883e:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
34008842:	f8c3 2d08 	str.w	r2, [r3, #3336]	@ 0xd08
34008846:	e001      	b.n	3400884c <HAL_DCMIPP_PIPE_DisableCrop+0x6c>
  }
  else
  {
    return HAL_ERROR;
34008848:	2301      	movs	r3, #1
3400884a:	e000      	b.n	3400884e <HAL_DCMIPP_PIPE_DisableCrop+0x6e>
  }

  return HAL_OK;
3400884c:	2300      	movs	r3, #0
}
3400884e:	4618      	mov	r0, r3
34008850:	370c      	adds	r7, #12
34008852:	46bd      	mov	sp, r7
34008854:	f85d 7b04 	ldr.w	r7, [sp], #4
34008858:	4770      	bx	lr

3400885a <HAL_DCMIPP_PIPE_SetISPDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                         const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
3400885a:	b480      	push	{r7}
3400885c:	b085      	sub	sp, #20
3400885e:	af00      	add	r7, sp, #0
34008860:	60f8      	str	r0, [r7, #12]
34008862:	60b9      	str	r1, [r7, #8]
34008864:	607a      	str	r2, [r7, #4]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDecConfig == NULL))
34008866:	68fb      	ldr	r3, [r7, #12]
34008868:	2b00      	cmp	r3, #0
3400886a:	d002      	beq.n	34008872 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x18>
3400886c:	687b      	ldr	r3, [r7, #4]
3400886e:	2b00      	cmp	r3, #0
34008870:	d101      	bne.n	34008876 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x1c>
  {
    return HAL_ERROR;
34008872:	2301      	movs	r3, #1
34008874:	e01c      	b.n	340088b0 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
  }

  /* Set Decimation Type , Vertical and Horizontal Ratio */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34008876:	68fb      	ldr	r3, [r7, #12]
34008878:	791b      	ldrb	r3, [r3, #4]
3400887a:	b2db      	uxtb	r3, r3
3400887c:	2b02      	cmp	r3, #2
3400887e:	d116      	bne.n	340088ae <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x54>
  {
    if (Pipe == DCMIPP_PIPE1)
34008880:	68bb      	ldr	r3, [r7, #8]
34008882:	2b01      	cmp	r3, #1
34008884:	d111      	bne.n	340088aa <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x50>
    {
      MODIFY_REG(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_VDEC | DCMIPP_P1DECR_HDEC,
34008886:	68fb      	ldr	r3, [r7, #12]
34008888:	681b      	ldr	r3, [r3, #0]
3400888a:	f8d3 3830 	ldr.w	r3, [r3, #2096]	@ 0x830
3400888e:	f023 011e 	bic.w	r1, r3, #30
34008892:	687b      	ldr	r3, [r7, #4]
34008894:	681a      	ldr	r2, [r3, #0]
34008896:	687b      	ldr	r3, [r7, #4]
34008898:	685b      	ldr	r3, [r3, #4]
3400889a:	431a      	orrs	r2, r3
3400889c:	68fb      	ldr	r3, [r7, #12]
3400889e:	681b      	ldr	r3, [r3, #0]
340088a0:	430a      	orrs	r2, r1
340088a2:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  {
    return HAL_ERROR;
  }


  return HAL_OK;
340088a6:	2300      	movs	r3, #0
340088a8:	e002      	b.n	340088b0 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
      return HAL_ERROR;
340088aa:	2301      	movs	r3, #1
340088ac:	e000      	b.n	340088b0 <HAL_DCMIPP_PIPE_SetISPDecimationConfig+0x56>
    return HAL_ERROR;
340088ae:	2301      	movs	r3, #1
}
340088b0:	4618      	mov	r0, r3
340088b2:	3714      	adds	r7, #20
340088b4:	46bd      	mov	sp, r7
340088b6:	f85d 7b04 	ldr.w	r7, [sp], #4
340088ba:	4770      	bx	lr

340088bc <HAL_DCMIPP_PIPE_EnableISPDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340088bc:	b480      	push	{r7}
340088be:	b083      	sub	sp, #12
340088c0:	af00      	add	r7, sp, #0
340088c2:	6078      	str	r0, [r7, #4]
340088c4:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check handle validity */
  if (hdcmipp == NULL)
340088c6:	687b      	ldr	r3, [r7, #4]
340088c8:	2b00      	cmp	r3, #0
340088ca:	d101      	bne.n	340088d0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x14>
  {
    return HAL_ERROR;
340088cc:	2301      	movs	r3, #1
340088ce:	e00f      	b.n	340088f0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
  }

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
340088d0:	683b      	ldr	r3, [r7, #0]
340088d2:	2b01      	cmp	r3, #1
340088d4:	d10b      	bne.n	340088ee <HAL_DCMIPP_PIPE_EnableISPDecimation+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DECR, DCMIPP_P1DECR_ENABLE);
340088d6:	687b      	ldr	r3, [r7, #4]
340088d8:	681b      	ldr	r3, [r3, #0]
340088da:	f8d3 2830 	ldr.w	r2, [r3, #2096]	@ 0x830
340088de:	687b      	ldr	r3, [r7, #4]
340088e0:	681b      	ldr	r3, [r3, #0]
340088e2:	f042 0201 	orr.w	r2, r2, #1
340088e6:	f8c3 2830 	str.w	r2, [r3, #2096]	@ 0x830
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340088ea:	2300      	movs	r3, #0
340088ec:	e000      	b.n	340088f0 <HAL_DCMIPP_PIPE_EnableISPDecimation+0x34>
    return HAL_ERROR;
340088ee:	2301      	movs	r3, #1
}
340088f0:	4618      	mov	r0, r3
340088f2:	370c      	adds	r7, #12
340088f4:	46bd      	mov	sp, r7
340088f6:	f85d 7b04 	ldr.w	r7, [sp], #4
340088fa:	4770      	bx	lr

340088fc <HAL_DCMIPP_PIPE_SetDecimationConfig>:
  * @param  pDecConfig pointer to DCMIPP_DecimationConfTypeDef structure that contains the decimation information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDecimationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                      const DCMIPP_DecimationConfTypeDef *pDecConfig)
{
340088fc:	b480      	push	{r7}
340088fe:	b085      	sub	sp, #20
34008900:	af00      	add	r7, sp, #0
34008902:	60f8      	str	r0, [r7, #12]
34008904:	60b9      	str	r1, [r7, #8]
34008906:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if (hdcmipp == NULL)
34008908:	68fb      	ldr	r3, [r7, #12]
3400890a:	2b00      	cmp	r3, #0
3400890c:	d101      	bne.n	34008912 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x16>
  {
    return HAL_ERROR;
3400890e:	2301      	movs	r3, #1
34008910:	e031      	b.n	34008976 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_VRATIO(pDecConfig->VRatio));
  assert_param(IS_DCMIPP_HRATIO(pDecConfig->HRatio));

  /* Check DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34008912:	68fb      	ldr	r3, [r7, #12]
34008914:	791b      	ldrb	r3, [r3, #4]
34008916:	b2db      	uxtb	r3, r3
34008918:	2b02      	cmp	r3, #2
3400891a:	d129      	bne.n	34008970 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x74>
  {
    /* Set Decimation Type , Vertical and Horizontal Ratio */
    if (Pipe == DCMIPP_PIPE1)
3400891c:	68bb      	ldr	r3, [r7, #8]
3400891e:	2b01      	cmp	r3, #1
34008920:	d110      	bne.n	34008944 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x48>
    {
      MODIFY_REG(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_VDEC | DCMIPP_P1DCCR_HDEC,
34008922:	68fb      	ldr	r3, [r7, #12]
34008924:	681b      	ldr	r3, [r3, #0]
34008926:	f8d3 390c 	ldr.w	r3, [r3, #2316]	@ 0x90c
3400892a:	f023 011e 	bic.w	r1, r3, #30
3400892e:	687b      	ldr	r3, [r7, #4]
34008930:	681a      	ldr	r2, [r3, #0]
34008932:	687b      	ldr	r3, [r7, #4]
34008934:	685b      	ldr	r3, [r3, #4]
34008936:	431a      	orrs	r2, r3
34008938:	68fb      	ldr	r3, [r7, #12]
3400893a:	681b      	ldr	r3, [r3, #0]
3400893c:	430a      	orrs	r2, r1
3400893e:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34008942:	e017      	b.n	34008974 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else if (Pipe == DCMIPP_PIPE2)
34008944:	68bb      	ldr	r3, [r7, #8]
34008946:	2b02      	cmp	r3, #2
34008948:	d110      	bne.n	3400896c <HAL_DCMIPP_PIPE_SetDecimationConfig+0x70>
    {
      MODIFY_REG(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_VDEC | DCMIPP_P2DCCR_HDEC,
3400894a:	68fb      	ldr	r3, [r7, #12]
3400894c:	681b      	ldr	r3, [r3, #0]
3400894e:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	@ 0xd0c
34008952:	f023 011e 	bic.w	r1, r3, #30
34008956:	687b      	ldr	r3, [r7, #4]
34008958:	681a      	ldr	r2, [r3, #0]
3400895a:	687b      	ldr	r3, [r7, #4]
3400895c:	685b      	ldr	r3, [r3, #4]
3400895e:	431a      	orrs	r2, r3
34008960:	68fb      	ldr	r3, [r7, #12]
34008962:	681b      	ldr	r3, [r3, #0]
34008964:	430a      	orrs	r2, r1
34008966:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
3400896a:	e003      	b.n	34008974 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x78>
                 (pDecConfig->VRatio | pDecConfig->HRatio));
    }
    else
    {
      return HAL_ERROR;
3400896c:	2301      	movs	r3, #1
3400896e:	e002      	b.n	34008976 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
    }
  }
  else
  {
    return HAL_ERROR;
34008970:	2301      	movs	r3, #1
34008972:	e000      	b.n	34008976 <HAL_DCMIPP_PIPE_SetDecimationConfig+0x7a>
  }

  return HAL_OK;
34008974:	2300      	movs	r3, #0
}
34008976:	4618      	mov	r0, r3
34008978:	3714      	adds	r7, #20
3400897a:	46bd      	mov	sp, r7
3400897c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008980:	4770      	bx	lr

34008982 <HAL_DCMIPP_PIPE_EnableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008982:	b480      	push	{r7}
34008984:	b083      	sub	sp, #12
34008986:	af00      	add	r7, sp, #0
34008988:	6078      	str	r0, [r7, #4]
3400898a:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3400898c:	687b      	ldr	r3, [r7, #4]
3400898e:	2b00      	cmp	r3, #0
34008990:	d101      	bne.n	34008996 <HAL_DCMIPP_PIPE_EnableDecimation+0x14>
  {
    return HAL_ERROR;
34008992:	2301      	movs	r3, #1
34008994:	e01e      	b.n	340089d4 <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
34008996:	683b      	ldr	r3, [r7, #0]
34008998:	2b01      	cmp	r3, #1
3400899a:	d10a      	bne.n	340089b2 <HAL_DCMIPP_PIPE_EnableDecimation+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
3400899c:	687b      	ldr	r3, [r7, #4]
3400899e:	681b      	ldr	r3, [r3, #0]
340089a0:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
340089a4:	687b      	ldr	r3, [r7, #4]
340089a6:	681b      	ldr	r3, [r3, #0]
340089a8:	f042 0201 	orr.w	r2, r2, #1
340089ac:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
340089b0:	e00f      	b.n	340089d2 <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
340089b2:	683b      	ldr	r3, [r7, #0]
340089b4:	2b02      	cmp	r3, #2
340089b6:	d10a      	bne.n	340089ce <HAL_DCMIPP_PIPE_EnableDecimation+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
340089b8:	687b      	ldr	r3, [r7, #4]
340089ba:	681b      	ldr	r3, [r3, #0]
340089bc:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
340089c0:	687b      	ldr	r3, [r7, #4]
340089c2:	681b      	ldr	r3, [r3, #0]
340089c4:	f042 0201 	orr.w	r2, r2, #1
340089c8:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
340089cc:	e001      	b.n	340089d2 <HAL_DCMIPP_PIPE_EnableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
340089ce:	2301      	movs	r3, #1
340089d0:	e000      	b.n	340089d4 <HAL_DCMIPP_PIPE_EnableDecimation+0x52>
  }

  return HAL_OK;
340089d2:	2300      	movs	r3, #0
}
340089d4:	4618      	mov	r0, r3
340089d6:	370c      	adds	r7, #12
340089d8:	46bd      	mov	sp, r7
340089da:	f85d 7b04 	ldr.w	r7, [sp], #4
340089de:	4770      	bx	lr

340089e0 <HAL_DCMIPP_PIPE_DisableDecimation>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableDecimation(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340089e0:	b480      	push	{r7}
340089e2:	b083      	sub	sp, #12
340089e4:	af00      	add	r7, sp, #0
340089e6:	6078      	str	r0, [r7, #4]
340089e8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340089ea:	687b      	ldr	r3, [r7, #4]
340089ec:	2b00      	cmp	r3, #0
340089ee:	d101      	bne.n	340089f4 <HAL_DCMIPP_PIPE_DisableDecimation+0x14>
  {
    return HAL_ERROR;
340089f0:	2301      	movs	r3, #1
340089f2:	e01e      	b.n	34008a32 <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Enable decimation */
  if (Pipe == DCMIPP_PIPE1)
340089f4:	683b      	ldr	r3, [r7, #0]
340089f6:	2b01      	cmp	r3, #1
340089f8:	d10a      	bne.n	34008a10 <HAL_DCMIPP_PIPE_DisableDecimation+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DCCR, DCMIPP_P1DCCR_ENABLE);
340089fa:	687b      	ldr	r3, [r7, #4]
340089fc:	681b      	ldr	r3, [r3, #0]
340089fe:	f8d3 290c 	ldr.w	r2, [r3, #2316]	@ 0x90c
34008a02:	687b      	ldr	r3, [r7, #4]
34008a04:	681b      	ldr	r3, [r3, #0]
34008a06:	f022 0201 	bic.w	r2, r2, #1
34008a0a:	f8c3 290c 	str.w	r2, [r3, #2316]	@ 0x90c
34008a0e:	e00f      	b.n	34008a30 <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34008a10:	683b      	ldr	r3, [r7, #0]
34008a12:	2b02      	cmp	r3, #2
34008a14:	d10a      	bne.n	34008a2c <HAL_DCMIPP_PIPE_DisableDecimation+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2DCCR, DCMIPP_P2DCCR_ENABLE);
34008a16:	687b      	ldr	r3, [r7, #4]
34008a18:	681b      	ldr	r3, [r3, #0]
34008a1a:	f8d3 2d0c 	ldr.w	r2, [r3, #3340]	@ 0xd0c
34008a1e:	687b      	ldr	r3, [r7, #4]
34008a20:	681b      	ldr	r3, [r3, #0]
34008a22:	f022 0201 	bic.w	r2, r2, #1
34008a26:	f8c3 2d0c 	str.w	r2, [r3, #3340]	@ 0xd0c
34008a2a:	e001      	b.n	34008a30 <HAL_DCMIPP_PIPE_DisableDecimation+0x50>
  }
  else
  {
    return HAL_ERROR;
34008a2c:	2301      	movs	r3, #1
34008a2e:	e000      	b.n	34008a32 <HAL_DCMIPP_PIPE_DisableDecimation+0x52>
  }

  return HAL_OK;
34008a30:	2300      	movs	r3, #0
}
34008a32:	4618      	mov	r0, r3
34008a34:	370c      	adds	r7, #12
34008a36:	46bd      	mov	sp, r7
34008a38:	f85d 7b04 	ldr.w	r7, [sp], #4
34008a3c:	4770      	bx	lr

34008a3e <HAL_DCMIPP_PIPE_SetDownsizeConfig>:
  * @param  pDownsizeConfig pointer to the DCMIPP_DownsizeTypeDef structure that contains Downsize information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetDownsizeConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                    const DCMIPP_DownsizeTypeDef *pDownsizeConfig)
{
34008a3e:	b480      	push	{r7}
34008a40:	b085      	sub	sp, #20
34008a42:	af00      	add	r7, sp, #0
34008a44:	60f8      	str	r0, [r7, #12]
34008a46:	60b9      	str	r1, [r7, #8]
34008a48:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pDownsizeConfig == NULL))
34008a4a:	68fb      	ldr	r3, [r7, #12]
34008a4c:	2b00      	cmp	r3, #0
34008a4e:	d002      	beq.n	34008a56 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x18>
34008a50:	687b      	ldr	r3, [r7, #4]
34008a52:	2b00      	cmp	r3, #0
34008a54:	d101      	bne.n	34008a5a <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x1c>
  {
    return HAL_ERROR;
34008a56:	2301      	movs	r3, #1
34008a58:	e069      	b.n	34008b2e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->HRatio));
  assert_param(IS_DCMIPP_DOWSIZE_RATIO(pDownsizeConfig->VRatio));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->HSize));
  assert_param(IS_DCMIPP_DOWSIZE_SIZE(pDownsizeConfig->VSize));

  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34008a5a:	68fb      	ldr	r3, [r7, #12]
34008a5c:	791b      	ldrb	r3, [r3, #4]
34008a5e:	b2db      	uxtb	r3, r3
34008a60:	2b02      	cmp	r3, #2
34008a62:	d161      	bne.n	34008b28 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xea>
  {
    if (Pipe == DCMIPP_PIPE1)
34008a64:	68bb      	ldr	r3, [r7, #8]
34008a66:	2b01      	cmp	r3, #1
34008a68:	d12c      	bne.n	34008ac4 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0x86>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P1DSCR, (DCMIPP_P1DSCR_HDIV | DCMIPP_P1DSCR_VDIV),
34008a6a:	68fb      	ldr	r3, [r7, #12]
34008a6c:	681b      	ldr	r3, [r3, #0]
34008a6e:	f8d3 3910 	ldr.w	r3, [r3, #2320]	@ 0x910
34008a72:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
34008a76:	687b      	ldr	r3, [r7, #4]
34008a78:	695a      	ldr	r2, [r3, #20]
34008a7a:	687b      	ldr	r3, [r7, #4]
34008a7c:	691b      	ldr	r3, [r3, #16]
34008a7e:	041b      	lsls	r3, r3, #16
34008a80:	431a      	orrs	r2, r3
34008a82:	68fb      	ldr	r3, [r7, #12]
34008a84:	681b      	ldr	r3, [r3, #0]
34008a86:	430a      	orrs	r2, r1
34008a88:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
                 ((pDownsizeConfig->HDivFactor << DCMIPP_P1DSCR_HDIV_Pos) | \
                  (pDownsizeConfig->VDivFactor << DCMIPP_P1DSCR_VDIV_Pos)));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P1DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P1DSRTIOR_HRATIO_Pos) | \
34008a8c:	687b      	ldr	r3, [r7, #4]
34008a8e:	68d9      	ldr	r1, [r3, #12]
34008a90:	687b      	ldr	r3, [r7, #4]
34008a92:	689b      	ldr	r3, [r3, #8]
34008a94:	041a      	lsls	r2, r3, #16
34008a96:	68fb      	ldr	r3, [r7, #12]
34008a98:	681b      	ldr	r3, [r3, #0]
34008a9a:	430a      	orrs	r2, r1
34008a9c:	f8c3 2914 	str.w	r2, [r3, #2324]	@ 0x914
                (pDownsizeConfig->VRatio << DCMIPP_P1DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P1DSSZR, DCMIPP_P1DSSZR_HSIZE | DCMIPP_P1DSSZR_VSIZE,
34008aa0:	68fb      	ldr	r3, [r7, #12]
34008aa2:	681b      	ldr	r3, [r3, #0]
34008aa4:	f8d3 3918 	ldr.w	r3, [r3, #2328]	@ 0x918
34008aa8:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34008aac:	687b      	ldr	r3, [r7, #4]
34008aae:	685a      	ldr	r2, [r3, #4]
34008ab0:	687b      	ldr	r3, [r7, #4]
34008ab2:	681b      	ldr	r3, [r3, #0]
34008ab4:	041b      	lsls	r3, r3, #16
34008ab6:	431a      	orrs	r2, r3
34008ab8:	68fb      	ldr	r3, [r7, #12]
34008aba:	681b      	ldr	r3, [r3, #0]
34008abc:	430a      	orrs	r2, r1
34008abe:	f8c3 2918 	str.w	r2, [r3, #2328]	@ 0x918
34008ac2:	e033      	b.n	34008b2c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P1DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P1DSSZR_VSIZE_Pos));
    }
    else if (Pipe == DCMIPP_PIPE2)
34008ac4:	68bb      	ldr	r3, [r7, #8]
34008ac6:	2b02      	cmp	r3, #2
34008ac8:	d12c      	bne.n	34008b24 <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xe6>
    {
      /* Set Vertical and Horizontal division */
      MODIFY_REG(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_HDIV | DCMIPP_P2DSCR_VDIV,
34008aca:	68fb      	ldr	r3, [r7, #12]
34008acc:	681b      	ldr	r3, [r3, #0]
34008ace:	f8d3 3d10 	ldr.w	r3, [r3, #3344]	@ 0xd10
34008ad2:	f003 21fc 	and.w	r1, r3, #4227922944	@ 0xfc00fc00
34008ad6:	687b      	ldr	r3, [r7, #4]
34008ad8:	695a      	ldr	r2, [r3, #20]
34008ada:	687b      	ldr	r3, [r7, #4]
34008adc:	691b      	ldr	r3, [r3, #16]
34008ade:	041b      	lsls	r3, r3, #16
34008ae0:	431a      	orrs	r2, r3
34008ae2:	68fb      	ldr	r3, [r7, #12]
34008ae4:	681b      	ldr	r3, [r3, #0]
34008ae6:	430a      	orrs	r2, r1
34008ae8:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
                 (pDownsizeConfig->HDivFactor << DCMIPP_P2DSCR_HDIV_Pos) | \
                 (pDownsizeConfig->VDivFactor << DCMIPP_P2DSCR_VDIV_Pos));

      /* Set Vertical and Horizontal Ratio */
      WRITE_REG(hdcmipp->Instance->P2DSRTIOR, (pDownsizeConfig->HRatio << DCMIPP_P2DSRTIOR_HRATIO_Pos) | \
34008aec:	687b      	ldr	r3, [r7, #4]
34008aee:	68d9      	ldr	r1, [r3, #12]
34008af0:	687b      	ldr	r3, [r7, #4]
34008af2:	689b      	ldr	r3, [r3, #8]
34008af4:	041a      	lsls	r2, r3, #16
34008af6:	68fb      	ldr	r3, [r7, #12]
34008af8:	681b      	ldr	r3, [r3, #0]
34008afa:	430a      	orrs	r2, r1
34008afc:	f8c3 2d14 	str.w	r2, [r3, #3348]	@ 0xd14
                (pDownsizeConfig->VRatio << DCMIPP_P2DSRTIOR_VRATIO_Pos));

      /* Set Downsize Destination size */
      MODIFY_REG(hdcmipp->Instance->P2DSSZR, DCMIPP_P2DSSZR_HSIZE | DCMIPP_P2DSSZR_VSIZE,
34008b00:	68fb      	ldr	r3, [r7, #12]
34008b02:	681b      	ldr	r3, [r3, #0]
34008b04:	f8d3 3d18 	ldr.w	r3, [r3, #3352]	@ 0xd18
34008b08:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
34008b0c:	687b      	ldr	r3, [r7, #4]
34008b0e:	685a      	ldr	r2, [r3, #4]
34008b10:	687b      	ldr	r3, [r7, #4]
34008b12:	681b      	ldr	r3, [r3, #0]
34008b14:	041b      	lsls	r3, r3, #16
34008b16:	431a      	orrs	r2, r3
34008b18:	68fb      	ldr	r3, [r7, #12]
34008b1a:	681b      	ldr	r3, [r3, #0]
34008b1c:	430a      	orrs	r2, r1
34008b1e:	f8c3 2d18 	str.w	r2, [r3, #3352]	@ 0xd18
34008b22:	e003      	b.n	34008b2c <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xee>
                 (pDownsizeConfig->HSize << DCMIPP_P2DSSZR_HSIZE_Pos) | \
                 (pDownsizeConfig->VSize << DCMIPP_P2DSSZR_VSIZE_Pos));
    }
    else
    {
      return HAL_ERROR;
34008b24:	2301      	movs	r3, #1
34008b26:	e002      	b.n	34008b2e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
    }
  }
  else
  {
    return HAL_ERROR;
34008b28:	2301      	movs	r3, #1
34008b2a:	e000      	b.n	34008b2e <HAL_DCMIPP_PIPE_SetDownsizeConfig+0xf0>
  }

  return HAL_OK;
34008b2c:	2300      	movs	r3, #0
}
34008b2e:	4618      	mov	r0, r3
34008b30:	3714      	adds	r7, #20
34008b32:	46bd      	mov	sp, r7
34008b34:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b38:	4770      	bx	lr

34008b3a <HAL_DCMIPP_PIPE_EnableDownsize>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableDownsize(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008b3a:	b480      	push	{r7}
34008b3c:	b083      	sub	sp, #12
34008b3e:	af00      	add	r7, sp, #0
34008b40:	6078      	str	r0, [r7, #4]
34008b42:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
34008b44:	687b      	ldr	r3, [r7, #4]
34008b46:	2b00      	cmp	r3, #0
34008b48:	d101      	bne.n	34008b4e <HAL_DCMIPP_PIPE_EnableDownsize+0x14>
  {
    return HAL_ERROR;
34008b4a:	2301      	movs	r3, #1
34008b4c:	e01e      	b.n	34008b8c <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008b4e:	683b      	ldr	r3, [r7, #0]
34008b50:	2b01      	cmp	r3, #1
34008b52:	d10a      	bne.n	34008b6a <HAL_DCMIPP_PIPE_EnableDownsize+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1DSCR, DCMIPP_P1DSCR_ENABLE);
34008b54:	687b      	ldr	r3, [r7, #4]
34008b56:	681b      	ldr	r3, [r3, #0]
34008b58:	f8d3 2910 	ldr.w	r2, [r3, #2320]	@ 0x910
34008b5c:	687b      	ldr	r3, [r7, #4]
34008b5e:	681b      	ldr	r3, [r3, #0]
34008b60:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34008b64:	f8c3 2910 	str.w	r2, [r3, #2320]	@ 0x910
34008b68:	e00f      	b.n	34008b8a <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34008b6a:	683b      	ldr	r3, [r7, #0]
34008b6c:	2b02      	cmp	r3, #2
34008b6e:	d10a      	bne.n	34008b86 <HAL_DCMIPP_PIPE_EnableDownsize+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2DSCR, DCMIPP_P2DSCR_ENABLE);
34008b70:	687b      	ldr	r3, [r7, #4]
34008b72:	681b      	ldr	r3, [r3, #0]
34008b74:	f8d3 2d10 	ldr.w	r2, [r3, #3344]	@ 0xd10
34008b78:	687b      	ldr	r3, [r7, #4]
34008b7a:	681b      	ldr	r3, [r3, #0]
34008b7c:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
34008b80:	f8c3 2d10 	str.w	r2, [r3, #3344]	@ 0xd10
34008b84:	e001      	b.n	34008b8a <HAL_DCMIPP_PIPE_EnableDownsize+0x50>
  }
  else
  {
    return HAL_ERROR;
34008b86:	2301      	movs	r3, #1
34008b88:	e000      	b.n	34008b8c <HAL_DCMIPP_PIPE_EnableDownsize+0x52>
  }

  return HAL_OK;
34008b8a:	2300      	movs	r3, #0
}
34008b8c:	4618      	mov	r0, r3
34008b8e:	370c      	adds	r7, #12
34008b90:	46bd      	mov	sp, r7
34008b92:	f85d 7b04 	ldr.w	r7, [sp], #4
34008b96:	4770      	bx	lr

34008b98 <HAL_DCMIPP_PIPE_EnableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008b98:	b480      	push	{r7}
34008b9a:	b083      	sub	sp, #12
34008b9c:	af00      	add	r7, sp, #0
34008b9e:	6078      	str	r0, [r7, #4]
34008ba0:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008ba2:	687b      	ldr	r3, [r7, #4]
34008ba4:	2b00      	cmp	r3, #0
34008ba6:	d101      	bne.n	34008bac <HAL_DCMIPP_PIPE_EnableGammaConversion+0x14>
  {
    return HAL_ERROR;
34008ba8:	2301      	movs	r3, #1
34008baa:	e01e      	b.n	34008bea <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008bac:	683b      	ldr	r3, [r7, #0]
34008bae:	2b01      	cmp	r3, #1
34008bb0:	d10a      	bne.n	34008bc8 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x30>
  {
    SET_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
34008bb2:	687b      	ldr	r3, [r7, #4]
34008bb4:	681b      	ldr	r3, [r3, #0]
34008bb6:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
34008bba:	687b      	ldr	r3, [r7, #4]
34008bbc:	681b      	ldr	r3, [r3, #0]
34008bbe:	f042 0201 	orr.w	r2, r2, #1
34008bc2:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
34008bc6:	e00f      	b.n	34008be8 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34008bc8:	683b      	ldr	r3, [r7, #0]
34008bca:	2b02      	cmp	r3, #2
34008bcc:	d10a      	bne.n	34008be4 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x4c>
  {
    SET_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34008bce:	687b      	ldr	r3, [r7, #4]
34008bd0:	681b      	ldr	r3, [r3, #0]
34008bd2:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
34008bd6:	687b      	ldr	r3, [r7, #4]
34008bd8:	681b      	ldr	r3, [r3, #0]
34008bda:	f042 0201 	orr.w	r2, r2, #1
34008bde:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
34008be2:	e001      	b.n	34008be8 <HAL_DCMIPP_PIPE_EnableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
34008be4:	2301      	movs	r3, #1
34008be6:	e000      	b.n	34008bea <HAL_DCMIPP_PIPE_EnableGammaConversion+0x52>
  }

  return HAL_OK;
34008be8:	2300      	movs	r3, #0
}
34008bea:	4618      	mov	r0, r3
34008bec:	370c      	adds	r7, #12
34008bee:	46bd      	mov	sp, r7
34008bf0:	f85d 7b04 	ldr.w	r7, [sp], #4
34008bf4:	4770      	bx	lr

34008bf6 <HAL_DCMIPP_PIPE_DisableGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableGammaConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008bf6:	b480      	push	{r7}
34008bf8:	b083      	sub	sp, #12
34008bfa:	af00      	add	r7, sp, #0
34008bfc:	6078      	str	r0, [r7, #4]
34008bfe:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008c00:	687b      	ldr	r3, [r7, #4]
34008c02:	2b00      	cmp	r3, #0
34008c04:	d101      	bne.n	34008c0a <HAL_DCMIPP_PIPE_DisableGammaConversion+0x14>
  {
    return HAL_ERROR;
34008c06:	2301      	movs	r3, #1
34008c08:	e01e      	b.n	34008c48 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  /* Check Parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008c0a:	683b      	ldr	r3, [r7, #0]
34008c0c:	2b01      	cmp	r3, #1
34008c0e:	d10a      	bne.n	34008c26 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x30>
  {
    CLEAR_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE);
34008c10:	687b      	ldr	r3, [r7, #4]
34008c12:	681b      	ldr	r3, [r3, #0]
34008c14:	f8d3 2970 	ldr.w	r2, [r3, #2416]	@ 0x970
34008c18:	687b      	ldr	r3, [r7, #4]
34008c1a:	681b      	ldr	r3, [r3, #0]
34008c1c:	f022 0201 	bic.w	r2, r2, #1
34008c20:	f8c3 2970 	str.w	r2, [r3, #2416]	@ 0x970
34008c24:	e00f      	b.n	34008c46 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else if (Pipe == DCMIPP_PIPE2)
34008c26:	683b      	ldr	r3, [r7, #0]
34008c28:	2b02      	cmp	r3, #2
34008c2a:	d10a      	bne.n	34008c42 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x4c>
  {
    CLEAR_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE);
34008c2c:	687b      	ldr	r3, [r7, #4]
34008c2e:	681b      	ldr	r3, [r3, #0]
34008c30:	f8d3 2d70 	ldr.w	r2, [r3, #3440]	@ 0xd70
34008c34:	687b      	ldr	r3, [r7, #4]
34008c36:	681b      	ldr	r3, [r3, #0]
34008c38:	f022 0201 	bic.w	r2, r2, #1
34008c3c:	f8c3 2d70 	str.w	r2, [r3, #3440]	@ 0xd70
34008c40:	e001      	b.n	34008c46 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x50>
  }
  else
  {
    return HAL_ERROR;
34008c42:	2301      	movs	r3, #1
34008c44:	e000      	b.n	34008c48 <HAL_DCMIPP_PIPE_DisableGammaConversion+0x52>
  }

  return HAL_OK;
34008c46:	2300      	movs	r3, #0
}
34008c48:	4618      	mov	r0, r3
34008c4a:	370c      	adds	r7, #12
34008c4c:	46bd      	mov	sp, r7
34008c4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008c52:	4770      	bx	lr

34008c54 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledGammaConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008c54:	b480      	push	{r7}
34008c56:	b083      	sub	sp, #12
34008c58:	af00      	add	r7, sp, #0
34008c5a:	6078      	str	r0, [r7, #4]
34008c5c:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008c5e:	683b      	ldr	r3, [r7, #0]
34008c60:	2b01      	cmp	r3, #1
34008c62:	d10b      	bne.n	34008c7c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1GMCR, DCMIPP_P1GMCR_ENABLE) == DCMIPP_P1GMCR_ENABLE) ? 1U : 0U);
34008c64:	687b      	ldr	r3, [r7, #4]
34008c66:	681b      	ldr	r3, [r3, #0]
34008c68:	f8d3 3970 	ldr.w	r3, [r3, #2416]	@ 0x970
34008c6c:	f003 0301 	and.w	r3, r3, #1
34008c70:	2b01      	cmp	r3, #1
34008c72:	d101      	bne.n	34008c78 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x24>
34008c74:	2301      	movs	r3, #1
34008c76:	e011      	b.n	34008c9c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
34008c78:	2300      	movs	r3, #0
34008c7a:	e00f      	b.n	34008c9c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else if (Pipe == DCMIPP_PIPE2)
34008c7c:	683b      	ldr	r3, [r7, #0]
34008c7e:	2b02      	cmp	r3, #2
34008c80:	d10b      	bne.n	34008c9a <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x46>
  {
    return ((READ_BIT(hdcmipp->Instance->P2GMCR, DCMIPP_P2GMCR_ENABLE) == DCMIPP_P2GMCR_ENABLE) ? 1U : 0U);
34008c82:	687b      	ldr	r3, [r7, #4]
34008c84:	681b      	ldr	r3, [r3, #0]
34008c86:	f8d3 3d70 	ldr.w	r3, [r3, #3440]	@ 0xd70
34008c8a:	f003 0301 	and.w	r3, r3, #1
34008c8e:	2b01      	cmp	r3, #1
34008c90:	d101      	bne.n	34008c96 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x42>
34008c92:	2301      	movs	r3, #1
34008c94:	e002      	b.n	34008c9c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
34008c96:	2300      	movs	r3, #0
34008c98:	e000      	b.n	34008c9c <HAL_DCMIPP_PIPE_IsEnabledGammaConversion+0x48>
  }
  else
  {
    /* State Disabled */
    return 0;
34008c9a:	2300      	movs	r3, #0
  }
}
34008c9c:	4618      	mov	r0, r3
34008c9e:	370c      	adds	r7, #12
34008ca0:	46bd      	mov	sp, r7
34008ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ca6:	4770      	bx	lr

34008ca8 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>:
  *         information.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_RawBayer2RGBConfTypeDef *pRawBayer2RGBConfig)
{
34008ca8:	b480      	push	{r7}
34008caa:	b087      	sub	sp, #28
34008cac:	af00      	add	r7, sp, #0
34008cae:	60f8      	str	r0, [r7, #12]
34008cb0:	60b9      	str	r1, [r7, #8]
34008cb2:	607a      	str	r2, [r7, #4]
  uint32_t p1dmcr_reg;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pRawBayer2RGBConfig == NULL))
34008cb4:	68fb      	ldr	r3, [r7, #12]
34008cb6:	2b00      	cmp	r3, #0
34008cb8:	d002      	beq.n	34008cc0 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x18>
34008cba:	687b      	ldr	r3, [r7, #4]
34008cbc:	2b00      	cmp	r3, #0
34008cbe:	d101      	bne.n	34008cc4 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x1c>
  {
    return HAL_ERROR;
34008cc0:	2301      	movs	r3, #1
34008cc2:	e024      	b.n	34008d0e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->PeakStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->VLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->HLineStrength));
  assert_param(IS_DCMIPP_RAWBAYER2RGB_STRENGTH(pRawBayer2RGBConfig->EdgeStrength));

  if (Pipe == DCMIPP_PIPE1)
34008cc4:	68bb      	ldr	r3, [r7, #8]
34008cc6:	2b01      	cmp	r3, #1
34008cc8:	d120      	bne.n	34008d0c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x64>
  {

    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34008cca:	687b      	ldr	r3, [r7, #4]
34008ccc:	689a      	ldr	r2, [r3, #8]
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34008cce:	687b      	ldr	r3, [r7, #4]
34008cd0:	68db      	ldr	r3, [r3, #12]
34008cd2:	041b      	lsls	r3, r3, #16
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34008cd4:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34008cd6:	687b      	ldr	r3, [r7, #4]
34008cd8:	691b      	ldr	r3, [r3, #16]
34008cda:	071b      	lsls	r3, r3, #28
                  (pRawBayer2RGBConfig->PeakStrength << DCMIPP_P1DMCR_PEAK_Pos)     | \
34008cdc:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->VLineStrength << DCMIPP_P1DMCR_LINEV_Pos)   | \
34008cde:	687b      	ldr	r3, [r7, #4]
34008ce0:	681b      	ldr	r3, [r3, #0]
34008ce2:	051b      	lsls	r3, r3, #20
                  (pRawBayer2RGBConfig->EdgeStrength << DCMIPP_P1DMCR_EDGE_Pos)     | \
34008ce4:	431a      	orrs	r2, r3
                  (pRawBayer2RGBConfig->HLineStrength << DCMIPP_P1DMCR_LINEH_Pos));
34008ce6:	687b      	ldr	r3, [r7, #4]
34008ce8:	685b      	ldr	r3, [r3, #4]
34008cea:	061b      	lsls	r3, r3, #24
    p1dmcr_reg = ((pRawBayer2RGBConfig->RawBayerType)                               | \
34008cec:	4313      	orrs	r3, r2
34008cee:	617b      	str	r3, [r7, #20]


    MODIFY_REG(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_TYPE | DCMIPP_P1DMCR_PEAK | DCMIPP_P1DMCR_LINEV | \
34008cf0:	68fb      	ldr	r3, [r7, #12]
34008cf2:	681b      	ldr	r3, [r3, #0]
34008cf4:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
34008cf8:	4b08      	ldr	r3, [pc, #32]	@ (34008d1c <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x74>)
34008cfa:	4013      	ands	r3, r2
34008cfc:	68fa      	ldr	r2, [r7, #12]
34008cfe:	6812      	ldr	r2, [r2, #0]
34008d00:	6979      	ldr	r1, [r7, #20]
34008d02:	430b      	orrs	r3, r1
34008d04:	f8c2 3870 	str.w	r3, [r2, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008d08:	2300      	movs	r3, #0
34008d0a:	e000      	b.n	34008d0e <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig+0x66>
    return HAL_ERROR;
34008d0c:	2301      	movs	r3, #1
}
34008d0e:	4618      	mov	r0, r3
34008d10:	371c      	adds	r7, #28
34008d12:	46bd      	mov	sp, r7
34008d14:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d18:	4770      	bx	lr
34008d1a:	bf00      	nop
34008d1c:	8888fff9 	.word	0x8888fff9

34008d20 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008d20:	b480      	push	{r7}
34008d22:	b083      	sub	sp, #12
34008d24:	af00      	add	r7, sp, #0
34008d26:	6078      	str	r0, [r7, #4]
34008d28:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008d2a:	687b      	ldr	r3, [r7, #4]
34008d2c:	2b00      	cmp	r3, #0
34008d2e:	d101      	bne.n	34008d34 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
34008d30:	2301      	movs	r3, #1
34008d32:	e00f      	b.n	34008d54 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008d34:	683b      	ldr	r3, [r7, #0]
34008d36:	2b01      	cmp	r3, #1
34008d38:	d10b      	bne.n	34008d52 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34008d3a:	687b      	ldr	r3, [r7, #4]
34008d3c:	681b      	ldr	r3, [r3, #0]
34008d3e:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
34008d42:	687b      	ldr	r3, [r7, #4]
34008d44:	681b      	ldr	r3, [r3, #0]
34008d46:	f042 0201 	orr.w	r2, r2, #1
34008d4a:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008d4e:	2300      	movs	r3, #0
34008d50:	e000      	b.n	34008d54 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
34008d52:	2301      	movs	r3, #1
}
34008d54:	4618      	mov	r0, r3
34008d56:	370c      	adds	r7, #12
34008d58:	46bd      	mov	sp, r7
34008d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d5e:	4770      	bx	lr

34008d60 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008d60:	b480      	push	{r7}
34008d62:	b083      	sub	sp, #12
34008d64:	af00      	add	r7, sp, #0
34008d66:	6078      	str	r0, [r7, #4]
34008d68:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008d6a:	687b      	ldr	r3, [r7, #4]
34008d6c:	2b00      	cmp	r3, #0
34008d6e:	d101      	bne.n	34008d74 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x14>
  {
    return HAL_ERROR;
34008d70:	2301      	movs	r3, #1
34008d72:	e00f      	b.n	34008d94 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008d74:	683b      	ldr	r3, [r7, #0]
34008d76:	2b01      	cmp	r3, #1
34008d78:	d10b      	bne.n	34008d92 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1DMCR, DCMIPP_P1DMCR_ENABLE);
34008d7a:	687b      	ldr	r3, [r7, #4]
34008d7c:	681b      	ldr	r3, [r3, #0]
34008d7e:	f8d3 2870 	ldr.w	r2, [r3, #2160]	@ 0x870
34008d82:	687b      	ldr	r3, [r7, #4]
34008d84:	681b      	ldr	r3, [r3, #0]
34008d86:	f022 0201 	bic.w	r2, r2, #1
34008d8a:	f8c3 2870 	str.w	r2, [r3, #2160]	@ 0x870
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008d8e:	2300      	movs	r3, #0
34008d90:	e000      	b.n	34008d94 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB+0x34>
    return HAL_ERROR;
34008d92:	2301      	movs	r3, #1
}
34008d94:	4618      	mov	r0, r3
34008d96:	370c      	adds	r7, #12
34008d98:	46bd      	mov	sp, r7
34008d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
34008d9e:	4770      	bx	lr

34008da0 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>:
  * @param  NbLastLines  number of valid image line to keep after the skipped first lines
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t NbFirstLines, uint32_t NbLastLines)
{
34008da0:	b480      	push	{r7}
34008da2:	b087      	sub	sp, #28
34008da4:	af00      	add	r7, sp, #0
34008da6:	60f8      	str	r0, [r7, #12]
34008da8:	60b9      	str	r1, [r7, #8]
34008daa:	607a      	str	r2, [r7, #4]
34008dac:	603b      	str	r3, [r7, #0]
  uint32_t p1srcr_reg;

  /* Check handles validity */
  if (hdcmipp == NULL)
34008dae:	68fb      	ldr	r3, [r7, #12]
34008db0:	2b00      	cmp	r3, #0
34008db2:	d101      	bne.n	34008db8 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x18>
  {
    return HAL_ERROR;
34008db4:	2301      	movs	r3, #1
34008db6:	e018      	b.n	34008dea <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_NB_FIRST_LINES(NbFirstLines));
  assert_param(IS_DCMIPP_NB_LAST_LINES(NbLastLines));

  if (Pipe == DCMIPP_PIPE1)
34008db8:	68bb      	ldr	r3, [r7, #8]
34008dba:	2b01      	cmp	r3, #1
34008dbc:	d114      	bne.n	34008de8 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x48>
  {
    p1srcr_reg = ((NbFirstLines << DCMIPP_P1SRCR_FIRSTLINEDEL_Pos) | (NbLastLines << DCMIPP_P1SRCR_LASTLINE_Pos));
34008dbe:	687b      	ldr	r3, [r7, #4]
34008dc0:	031b      	lsls	r3, r3, #12
34008dc2:	683a      	ldr	r2, [r7, #0]
34008dc4:	4313      	orrs	r3, r2
34008dc6:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1SRCR, (DCMIPP_P1SRCR_FIRSTLINEDEL | DCMIPP_P1SRCR_LASTLINE), p1srcr_reg);
34008dc8:	68fb      	ldr	r3, [r7, #12]
34008dca:	681b      	ldr	r3, [r3, #0]
34008dcc:	f8d3 3820 	ldr.w	r3, [r3, #2080]	@ 0x820
34008dd0:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34008dd4:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34008dd8:	68fa      	ldr	r2, [r7, #12]
34008dda:	6812      	ldr	r2, [r2, #0]
34008ddc:	6979      	ldr	r1, [r7, #20]
34008dde:	430b      	orrs	r3, r1
34008de0:	f8c2 3820 	str.w	r3, [r2, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008de4:	2300      	movs	r3, #0
34008de6:	e000      	b.n	34008dea <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig+0x4a>
    return HAL_ERROR;
34008de8:	2301      	movs	r3, #1
}
34008dea:	4618      	mov	r0, r3
34008dec:	371c      	adds	r7, #28
34008dee:	46bd      	mov	sp, r7
34008df0:	f85d 7b04 	ldr.w	r7, [sp], #4
34008df4:	4770      	bx	lr

34008df6 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008df6:	b480      	push	{r7}
34008df8:	b083      	sub	sp, #12
34008dfa:	af00      	add	r7, sp, #0
34008dfc:	6078      	str	r0, [r7, #4]
34008dfe:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008e00:	687b      	ldr	r3, [r7, #4]
34008e02:	2b00      	cmp	r3, #0
34008e04:	d101      	bne.n	34008e0a <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
34008e06:	2301      	movs	r3, #1
34008e08:	e00f      	b.n	34008e2a <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
34008e0a:	683b      	ldr	r3, [r7, #0]
34008e0c:	2b01      	cmp	r3, #1
34008e0e:	d10b      	bne.n	34008e28 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34008e10:	687b      	ldr	r3, [r7, #4]
34008e12:	681b      	ldr	r3, [r3, #0]
34008e14:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34008e18:	687b      	ldr	r3, [r7, #4]
34008e1a:	681b      	ldr	r3, [r3, #0]
34008e1c:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34008e20:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008e24:	2300      	movs	r3, #0
34008e26:	e000      	b.n	34008e2a <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic+0x34>
    return HAL_ERROR;
34008e28:	2301      	movs	r3, #1
}
34008e2a:	4618      	mov	r0, r3
34008e2c:	370c      	adds	r7, #12
34008e2e:	46bd      	mov	sp, r7
34008e30:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e34:	4770      	bx	lr

34008e36 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008e36:	b480      	push	{r7}
34008e38:	b083      	sub	sp, #12
34008e3a:	af00      	add	r7, sp, #0
34008e3c:	6078      	str	r0, [r7, #4]
34008e3e:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008e40:	687b      	ldr	r3, [r7, #4]
34008e42:	2b00      	cmp	r3, #0
34008e44:	d101      	bne.n	34008e4a <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x14>
  {
    return HAL_ERROR;
34008e46:	2301      	movs	r3, #1
34008e48:	e00f      	b.n	34008e6a <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
  }

  if (Pipe == DCMIPP_PIPE1)
34008e4a:	683b      	ldr	r3, [r7, #0]
34008e4c:	2b01      	cmp	r3, #1
34008e4e:	d10b      	bne.n	34008e68 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1SRCR, DCMIPP_P1SRCR_CROPEN);
34008e50:	687b      	ldr	r3, [r7, #4]
34008e52:	681b      	ldr	r3, [r3, #0]
34008e54:	f8d3 2820 	ldr.w	r2, [r3, #2080]	@ 0x820
34008e58:	687b      	ldr	r3, [r7, #4]
34008e5a:	681b      	ldr	r3, [r3, #0]
34008e5c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34008e60:	f8c3 2820 	str.w	r2, [r3, #2080]	@ 0x820
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008e64:	2300      	movs	r3, #0
34008e66:	e000      	b.n	34008e6a <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic+0x34>
    return HAL_ERROR;
34008e68:	2301      	movs	r3, #1
}
34008e6a:	4618      	mov	r0, r3
34008e6c:	370c      	adds	r7, #12
34008e6e:	46bd      	mov	sp, r7
34008e70:	f85d 7b04 	ldr.w	r7, [sp], #4
34008e74:	4770      	bx	lr

34008e76 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>:
  * @param  Strength Specifies the removal strength, can be a value from @ref DCMIPP_Bad_Pixel_Removal_Strength
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              uint32_t Strength)
{
34008e76:	b480      	push	{r7}
34008e78:	b085      	sub	sp, #20
34008e7a:	af00      	add	r7, sp, #0
34008e7c:	60f8      	str	r0, [r7, #12]
34008e7e:	60b9      	str	r1, [r7, #8]
34008e80:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008e82:	68fb      	ldr	r3, [r7, #12]
34008e84:	2b00      	cmp	r3, #0
34008e86:	d101      	bne.n	34008e8c <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x16>
  {
    return HAL_ERROR;
34008e88:	2301      	movs	r3, #1
34008e8a:	e012      	b.n	34008eb2 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_BAD_PXL_REMOVAL_STRENGTH(Strength));

  if (Pipe == DCMIPP_PIPE1)
34008e8c:	68bb      	ldr	r3, [r7, #8]
34008e8e:	2b01      	cmp	r3, #1
34008e90:	d10e      	bne.n	34008eb0 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_STRENGTH, Strength << DCMIPP_P1BPRCR_STRENGTH_Pos);
34008e92:	68fb      	ldr	r3, [r7, #12]
34008e94:	681b      	ldr	r3, [r3, #0]
34008e96:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34008e9a:	f023 010e 	bic.w	r1, r3, #14
34008e9e:	687b      	ldr	r3, [r7, #4]
34008ea0:	005a      	lsls	r2, r3, #1
34008ea2:	68fb      	ldr	r3, [r7, #12]
34008ea4:	681b      	ldr	r3, [r3, #0]
34008ea6:	430a      	orrs	r2, r1
34008ea8:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008eac:	2300      	movs	r3, #0
34008eae:	e000      	b.n	34008eb2 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig+0x3c>
    return HAL_ERROR;
34008eb0:	2301      	movs	r3, #1
}
34008eb2:	4618      	mov	r0, r3
34008eb4:	3714      	adds	r7, #20
34008eb6:	46bd      	mov	sp, r7
34008eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
34008ebc:	4770      	bx	lr

34008ebe <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008ebe:	b480      	push	{r7}
34008ec0:	b083      	sub	sp, #12
34008ec2:	af00      	add	r7, sp, #0
34008ec4:	6078      	str	r0, [r7, #4]
34008ec6:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008ec8:	687b      	ldr	r3, [r7, #4]
34008eca:	2b00      	cmp	r3, #0
34008ecc:	d101      	bne.n	34008ed2 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
34008ece:	2301      	movs	r3, #1
34008ed0:	e00f      	b.n	34008ef2 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008ed2:	683b      	ldr	r3, [r7, #0]
34008ed4:	2b01      	cmp	r3, #1
34008ed6:	d10b      	bne.n	34008ef0 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34008ed8:	687b      	ldr	r3, [r7, #4]
34008eda:	681b      	ldr	r3, [r3, #0]
34008edc:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
34008ee0:	687b      	ldr	r3, [r7, #4]
34008ee2:	681b      	ldr	r3, [r3, #0]
34008ee4:	f042 0201 	orr.w	r2, r2, #1
34008ee8:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008eec:	2300      	movs	r3, #0
34008eee:	e000      	b.n	34008ef2 <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
34008ef0:	2301      	movs	r3, #1
}
34008ef2:	4618      	mov	r0, r3
34008ef4:	370c      	adds	r7, #12
34008ef6:	46bd      	mov	sp, r7
34008ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
34008efc:	4770      	bx	lr

34008efe <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008efe:	b480      	push	{r7}
34008f00:	b083      	sub	sp, #12
34008f02:	af00      	add	r7, sp, #0
34008f04:	6078      	str	r0, [r7, #4]
34008f06:	6039      	str	r1, [r7, #0]
  /* Check handles validity */
  if (hdcmipp == NULL)
34008f08:	687b      	ldr	r3, [r7, #4]
34008f0a:	2b00      	cmp	r3, #0
34008f0c:	d101      	bne.n	34008f12 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x14>
  {
    return HAL_ERROR;
34008f0e:	2301      	movs	r3, #1
34008f10:	e00f      	b.n	34008f32 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008f12:	683b      	ldr	r3, [r7, #0]
34008f14:	2b01      	cmp	r3, #1
34008f16:	d10b      	bne.n	34008f30 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE);
34008f18:	687b      	ldr	r3, [r7, #4]
34008f1a:	681b      	ldr	r3, [r3, #0]
34008f1c:	f8d3 2824 	ldr.w	r2, [r3, #2084]	@ 0x824
34008f20:	687b      	ldr	r3, [r7, #4]
34008f22:	681b      	ldr	r3, [r3, #0]
34008f24:	f022 0201 	bic.w	r2, r2, #1
34008f28:	f8c3 2824 	str.w	r2, [r3, #2084]	@ 0x824
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008f2c:	2300      	movs	r3, #0
34008f2e:	e000      	b.n	34008f32 <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval+0x34>
    return HAL_ERROR;
34008f30:	2301      	movs	r3, #1
}
34008f32:	4618      	mov	r0, r3
34008f34:	370c      	adds	r7, #12
34008f36:	46bd      	mov	sp, r7
34008f38:	f85d 7b04 	ldr.w	r7, [sp], #4
34008f3c:	4770      	bx	lr

34008f3e <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval  The strength of the bad pixel removal process.
  */
uint32_t HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008f3e:	b480      	push	{r7}
34008f40:	b083      	sub	sp, #12
34008f42:	af00      	add	r7, sp, #0
34008f44:	6078      	str	r0, [r7, #4]
34008f46:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  return (((READ_REG(hdcmipp->Instance->P1BPRCR)) & DCMIPP_P1BPRCR_STRENGTH) >> DCMIPP_P1BPRCR_STRENGTH_Pos);
34008f48:	687b      	ldr	r3, [r7, #4]
34008f4a:	681b      	ldr	r3, [r3, #0]
34008f4c:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34008f50:	085b      	lsrs	r3, r3, #1
34008f52:	f003 0307 	and.w	r3, r3, #7
}
34008f56:	4618      	mov	r0, r3
34008f58:	370c      	adds	r7, #12
34008f5a:	46bd      	mov	sp, r7
34008f5c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008f60:	4770      	bx	lr

34008f62 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34008f62:	b480      	push	{r7}
34008f64:	b083      	sub	sp, #12
34008f66:	af00      	add	r7, sp, #0
34008f68:	6078      	str	r0, [r7, #4]
34008f6a:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34008f6c:	683b      	ldr	r3, [r7, #0]
34008f6e:	2b01      	cmp	r3, #1
34008f70:	d10b      	bne.n	34008f8a <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1BPRCR, DCMIPP_P1BPRCR_ENABLE) == DCMIPP_P1BPRCR_ENABLE) ? 1U : 0U);
34008f72:	687b      	ldr	r3, [r7, #4]
34008f74:	681b      	ldr	r3, [r3, #0]
34008f76:	f8d3 3824 	ldr.w	r3, [r3, #2084]	@ 0x824
34008f7a:	f003 0301 	and.w	r3, r3, #1
34008f7e:	2b01      	cmp	r3, #1
34008f80:	d101      	bne.n	34008f86 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x24>
34008f82:	2301      	movs	r3, #1
34008f84:	e002      	b.n	34008f8c <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
34008f86:	2300      	movs	r3, #0
34008f88:	e000      	b.n	34008f8c <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
34008f8a:	2300      	movs	r3, #0
  }
}
34008f8c:	4618      	mov	r0, r3
34008f8e:	370c      	adds	r7, #12
34008f90:	46bd      	mov	sp, r7
34008f92:	f85d 7b04 	ldr.w	r7, [sp], #4
34008f96:	4770      	bx	lr

34008f98 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>:
  * @param  pCounter pointer receiving the number of corrected bad pixels
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint32_t *pCounter)
{
34008f98:	b480      	push	{r7}
34008f9a:	b085      	sub	sp, #20
34008f9c:	af00      	add	r7, sp, #0
34008f9e:	60f8      	str	r0, [r7, #12]
34008fa0:	60b9      	str	r1, [r7, #8]
34008fa2:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
34008fa4:	68fb      	ldr	r3, [r7, #12]
34008fa6:	2b00      	cmp	r3, #0
34008fa8:	d002      	beq.n	34008fb0 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x18>
34008faa:	687b      	ldr	r3, [r7, #4]
34008fac:	2b00      	cmp	r3, #0
34008fae:	d101      	bne.n	34008fb4 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x1c>
  {
    return HAL_ERROR;
34008fb0:	2301      	movs	r3, #1
34008fb2:	e00f      	b.n	34008fd4 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  /* Check the DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34008fb4:	68fb      	ldr	r3, [r7, #12]
34008fb6:	791b      	ldrb	r3, [r3, #4]
34008fb8:	b2db      	uxtb	r3, r3
34008fba:	2b02      	cmp	r3, #2
34008fbc:	d109      	bne.n	34008fd2 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3a>
  {
    *pCounter = READ_REG(hdcmipp->Instance->P1BPRSR & DCMIPP_P1BPRSR_BADCNT);
34008fbe:	68fb      	ldr	r3, [r7, #12]
34008fc0:	681b      	ldr	r3, [r3, #0]
34008fc2:	f8d3 3828 	ldr.w	r3, [r3, #2088]	@ 0x828
34008fc6:	f3c3 020b 	ubfx	r2, r3, #0, #12
34008fca:	687b      	ldr	r3, [r7, #4]
34008fcc:	601a      	str	r2, [r3, #0]
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34008fce:	2300      	movs	r3, #0
34008fd0:	e000      	b.n	34008fd4 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter+0x3c>
    return HAL_ERROR;
34008fd2:	2301      	movs	r3, #1
}
34008fd4:	4618      	mov	r0, r3
34008fd6:	3714      	adds	r7, #20
34008fd8:	46bd      	mov	sp, r7
34008fda:	f85d 7b04 	ldr.w	r7, [sp], #4
34008fde:	4770      	bx	lr

34008fe0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPColorConversionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                              const DCMIPP_ColorConversionConfTypeDef
                                                              *pColorConversionConfig)
{
34008fe0:	b480      	push	{r7}
34008fe2:	b087      	sub	sp, #28
34008fe4:	af00      	add	r7, sp, #0
34008fe6:	60f8      	str	r0, [r7, #12]
34008fe8:	60b9      	str	r1, [r7, #8]
34008fea:	607a      	str	r2, [r7, #4]
  uint32_t p1cccr_reg;
  uint16_t tmp1;
  uint16_t tmp2;

  /* Check handles validity */
  if ((hdcmipp == NULL) || (pColorConversionConfig == NULL))
34008fec:	68fb      	ldr	r3, [r7, #12]
34008fee:	2b00      	cmp	r3, #0
34008ff0:	d002      	beq.n	34008ff8 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x18>
34008ff2:	687b      	ldr	r3, [r7, #4]
34008ff4:	2b00      	cmp	r3, #0
34008ff6:	d101      	bne.n	34008ffc <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c>
  {
    return HAL_ERROR;
34008ff8:	2301      	movs	r3, #1
34008ffa:	e14b      	b.n	34009294 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BR));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BG));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BB));
  assert_param(IS_DCMIPP_COLOR_CONVERSION_COEF(pColorConversionConfig->BA));

  if (Pipe == DCMIPP_PIPE1)
34008ffc:	68bb      	ldr	r3, [r7, #8]
34008ffe:	2b01      	cmp	r3, #1
34009000:	f040 8147 	bne.w	34009292 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b2>
  {
    /* Set Clamp and Type */
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
34009004:	687b      	ldr	r3, [r7, #4]
34009006:	781b      	ldrb	r3, [r3, #0]
34009008:	009b      	lsls	r3, r3, #2
                 ((uint32_t)pColorConversionConfig->OutputSamplesType);
3400900a:	687a      	ldr	r2, [r7, #4]
3400900c:	7852      	ldrb	r2, [r2, #1]
    p1cccr_reg = ((uint32_t)pColorConversionConfig->ClampOutputSamples << DCMIPP_P1CCCR_CLAMP_Pos) | \
3400900e:	4313      	orrs	r3, r2
34009010:	617b      	str	r3, [r7, #20]

    MODIFY_REG(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_CLAMP | DCMIPP_P1CCCR_TYPE, p1cccr_reg);
34009012:	68fb      	ldr	r3, [r7, #12]
34009014:	681b      	ldr	r3, [r3, #0]
34009016:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
3400901a:	f023 0106 	bic.w	r1, r3, #6
3400901e:	68fb      	ldr	r3, [r7, #12]
34009020:	681b      	ldr	r3, [r3, #0]
34009022:	697a      	ldr	r2, [r7, #20]
34009024:	430a      	orrs	r2, r1
34009026:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RR);
3400902a:	687b      	ldr	r3, [r7, #4]
3400902c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
34009030:	2b00      	cmp	r3, #0
34009032:	da07      	bge.n	34009044 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x64>
34009034:	687b      	ldr	r3, [r7, #4]
34009036:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
3400903a:	b29b      	uxth	r3, r3
3400903c:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009040:	b29b      	uxth	r3, r3
34009042:	e003      	b.n	3400904c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x6c>
34009044:	687b      	ldr	r3, [r7, #4]
34009046:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
3400904a:	b29b      	uxth	r3, r3
3400904c:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RG);
3400904e:	687b      	ldr	r3, [r7, #4]
34009050:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
34009054:	2b00      	cmp	r3, #0
34009056:	da07      	bge.n	34009068 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x88>
34009058:	687b      	ldr	r3, [r7, #4]
3400905a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
3400905e:	b29b      	uxth	r3, r3
34009060:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009064:	b29b      	uxth	r3, r3
34009066:	e003      	b.n	34009070 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x90>
34009068:	687b      	ldr	r3, [r7, #4]
3400906a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
3400906e:	b29b      	uxth	r3, r3
34009070:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    MODIFY_REG(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR | DCMIPP_P1CCRR1_RG,
34009072:	68fb      	ldr	r3, [r7, #12]
34009074:	681b      	ldr	r3, [r3, #0]
34009076:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
3400907a:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
3400907e:	8a7a      	ldrh	r2, [r7, #18]
34009080:	8a3b      	ldrh	r3, [r7, #16]
34009082:	041b      	lsls	r3, r3, #16
34009084:	431a      	orrs	r2, r3
34009086:	68fb      	ldr	r3, [r7, #12]
34009088:	681b      	ldr	r3, [r3, #0]
3400908a:	430a      	orrs	r2, r1
3400908c:	f8c3 2884 	str.w	r2, [r3, #2180]	@ 0x884
               (((uint32_t)tmp1) << DCMIPP_P1CCRR1_RR_Pos) | (((uint32_t)tmp2) << DCMIPP_P1CCRR1_RG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->RB);
34009090:	687b      	ldr	r3, [r7, #4]
34009092:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
34009096:	2b00      	cmp	r3, #0
34009098:	da07      	bge.n	340090aa <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xca>
3400909a:	687b      	ldr	r3, [r7, #4]
3400909c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
340090a0:	b29b      	uxth	r3, r3
340090a2:	f3c3 030a 	ubfx	r3, r3, #0, #11
340090a6:	b29b      	uxth	r3, r3
340090a8:	e003      	b.n	340090b2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xd2>
340090aa:	687b      	ldr	r3, [r7, #4]
340090ac:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
340090b0:	b29b      	uxth	r3, r3
340090b2:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->RA);
340090b4:	687b      	ldr	r3, [r7, #4]
340090b6:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
340090ba:	2b00      	cmp	r3, #0
340090bc:	da07      	bge.n	340090ce <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xee>
340090be:	687b      	ldr	r3, [r7, #4]
340090c0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
340090c4:	b29b      	uxth	r3, r3
340090c6:	f3c3 0309 	ubfx	r3, r3, #0, #10
340090ca:	b29b      	uxth	r3, r3
340090cc:	e003      	b.n	340090d6 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0xf6>
340090ce:	687b      	ldr	r3, [r7, #4]
340090d0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
340090d4:	b29b      	uxth	r3, r3
340090d6:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB | DCMIPP_P1CCRR2_RA,
340090d8:	68fb      	ldr	r3, [r7, #12]
340090da:	681b      	ldr	r3, [r3, #0]
340090dc:	f8d3 2888 	ldr.w	r2, [r3, #2184]	@ 0x888
340090e0:	4b6f      	ldr	r3, [pc, #444]	@ (340092a0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
340090e2:	4013      	ands	r3, r2
340090e4:	8a79      	ldrh	r1, [r7, #18]
340090e6:	8a3a      	ldrh	r2, [r7, #16]
340090e8:	0412      	lsls	r2, r2, #16
340090ea:	4311      	orrs	r1, r2
340090ec:	68fa      	ldr	r2, [r7, #12]
340090ee:	6812      	ldr	r2, [r2, #0]
340090f0:	430b      	orrs	r3, r1
340090f2:	f8c2 3888 	str.w	r3, [r2, #2184]	@ 0x888
               ((uint32_t)tmp1 << DCMIPP_P1CCRR2_RB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCRR2_RA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GG);
340090f6:	687b      	ldr	r3, [r7, #4]
340090f8:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
340090fc:	2b00      	cmp	r3, #0
340090fe:	da07      	bge.n	34009110 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x130>
34009100:	687b      	ldr	r3, [r7, #4]
34009102:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
34009106:	b29b      	uxth	r3, r3
34009108:	f3c3 030a 	ubfx	r3, r3, #0, #11
3400910c:	b29b      	uxth	r3, r3
3400910e:	e003      	b.n	34009118 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x138>
34009110:	687b      	ldr	r3, [r7, #4]
34009112:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
34009116:	b29b      	uxth	r3, r3
34009118:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GR);
3400911a:	687b      	ldr	r3, [r7, #4]
3400911c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
34009120:	2b00      	cmp	r3, #0
34009122:	da07      	bge.n	34009134 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x154>
34009124:	687b      	ldr	r3, [r7, #4]
34009126:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
3400912a:	b29b      	uxth	r3, r3
3400912c:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009130:	b29b      	uxth	r3, r3
34009132:	e003      	b.n	3400913c <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x15c>
34009134:	687b      	ldr	r3, [r7, #4]
34009136:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
3400913a:	b29b      	uxth	r3, r3
3400913c:	823b      	strh	r3, [r7, #16]


    /* Set Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR | DCMIPP_P1CCGR1_GG,
3400913e:	68fb      	ldr	r3, [r7, #12]
34009140:	681b      	ldr	r3, [r3, #0]
34009142:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
34009146:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
3400914a:	8a7b      	ldrh	r3, [r7, #18]
3400914c:	041a      	lsls	r2, r3, #16
3400914e:	8a3b      	ldrh	r3, [r7, #16]
34009150:	431a      	orrs	r2, r3
34009152:	68fb      	ldr	r3, [r7, #12]
34009154:	681b      	ldr	r3, [r3, #0]
34009156:	430a      	orrs	r2, r1
34009158:	f8c3 288c 	str.w	r2, [r3, #2188]	@ 0x88c
               ((uint32_t)tmp1 << DCMIPP_P1CCGR1_GG_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR1_GR_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->GB);
3400915c:	687b      	ldr	r3, [r7, #4]
3400915e:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
34009162:	2b00      	cmp	r3, #0
34009164:	da07      	bge.n	34009176 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x196>
34009166:	687b      	ldr	r3, [r7, #4]
34009168:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
3400916c:	b29b      	uxth	r3, r3
3400916e:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009172:	b29b      	uxth	r3, r3
34009174:	e003      	b.n	3400917e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x19e>
34009176:	687b      	ldr	r3, [r7, #4]
34009178:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
3400917c:	b29b      	uxth	r3, r3
3400917e:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->GA);
34009180:	687b      	ldr	r3, [r7, #4]
34009182:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
34009186:	2b00      	cmp	r3, #0
34009188:	da07      	bge.n	3400919a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1ba>
3400918a:	687b      	ldr	r3, [r7, #4]
3400918c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
34009190:	b29b      	uxth	r3, r3
34009192:	f3c3 0309 	ubfx	r3, r3, #0, #10
34009196:	b29b      	uxth	r3, r3
34009198:	e003      	b.n	340091a2 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1c2>
3400919a:	687b      	ldr	r3, [r7, #4]
3400919c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
340091a0:	b29b      	uxth	r3, r3
340091a2:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB | DCMIPP_P1CCGR2_GA,
340091a4:	68fb      	ldr	r3, [r7, #12]
340091a6:	681b      	ldr	r3, [r3, #0]
340091a8:	f8d3 2890 	ldr.w	r2, [r3, #2192]	@ 0x890
340091ac:	4b3c      	ldr	r3, [pc, #240]	@ (340092a0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
340091ae:	4013      	ands	r3, r2
340091b0:	8a79      	ldrh	r1, [r7, #18]
340091b2:	8a3a      	ldrh	r2, [r7, #16]
340091b4:	0412      	lsls	r2, r2, #16
340091b6:	4311      	orrs	r1, r2
340091b8:	68fa      	ldr	r2, [r7, #12]
340091ba:	6812      	ldr	r2, [r2, #0]
340091bc:	430b      	orrs	r3, r1
340091be:	f8c2 3890 	str.w	r3, [r2, #2192]	@ 0x890
               ((uint32_t)tmp1 << DCMIPP_P1CCGR2_GB_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCGR2_GA_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BR);
340091c2:	687b      	ldr	r3, [r7, #4]
340091c4:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
340091c8:	2b00      	cmp	r3, #0
340091ca:	da07      	bge.n	340091dc <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x1fc>
340091cc:	687b      	ldr	r3, [r7, #4]
340091ce:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
340091d2:	b29b      	uxth	r3, r3
340091d4:	f3c3 030a 	ubfx	r3, r3, #0, #11
340091d8:	b29b      	uxth	r3, r3
340091da:	e003      	b.n	340091e4 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x204>
340091dc:	687b      	ldr	r3, [r7, #4]
340091de:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
340091e2:	b29b      	uxth	r3, r3
340091e4:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BG);
340091e6:	687b      	ldr	r3, [r7, #4]
340091e8:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
340091ec:	2b00      	cmp	r3, #0
340091ee:	da07      	bge.n	34009200 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x220>
340091f0:	687b      	ldr	r3, [r7, #4]
340091f2:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
340091f6:	b29b      	uxth	r3, r3
340091f8:	f3c3 030a 	ubfx	r3, r3, #0, #11
340091fc:	b29b      	uxth	r3, r3
340091fe:	e003      	b.n	34009208 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x228>
34009200:	687b      	ldr	r3, [r7, #4]
34009202:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
34009206:	b29b      	uxth	r3, r3
34009208:	823b      	strh	r3, [r7, #16]

    /* Set Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    MODIFY_REG(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR | DCMIPP_P1CCBR1_BG,
3400920a:	68fb      	ldr	r3, [r7, #12]
3400920c:	681b      	ldr	r3, [r3, #0]
3400920e:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
34009212:	f003 21f8 	and.w	r1, r3, #4160813056	@ 0xf800f800
34009216:	8a7a      	ldrh	r2, [r7, #18]
34009218:	8a3b      	ldrh	r3, [r7, #16]
3400921a:	041b      	lsls	r3, r3, #16
3400921c:	431a      	orrs	r2, r3
3400921e:	68fb      	ldr	r3, [r7, #12]
34009220:	681b      	ldr	r3, [r3, #0]
34009222:	430a      	orrs	r2, r1
34009224:	f8c3 2894 	str.w	r2, [r3, #2196]	@ 0x894
               ((uint32_t)tmp1 << DCMIPP_P1CCBR1_BR_Pos) | ((uint32_t)tmp2 << DCMIPP_P1CCBR1_BG_Pos));

    tmp1 = MATRIX_VALUE11((uint16_t)pColorConversionConfig->BB);
34009228:	687b      	ldr	r3, [r7, #4]
3400922a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
3400922e:	2b00      	cmp	r3, #0
34009230:	da07      	bge.n	34009242 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x262>
34009232:	687b      	ldr	r3, [r7, #4]
34009234:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
34009238:	b29b      	uxth	r3, r3
3400923a:	f3c3 030a 	ubfx	r3, r3, #0, #11
3400923e:	b29b      	uxth	r3, r3
34009240:	e003      	b.n	3400924a <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x26a>
34009242:	687b      	ldr	r3, [r7, #4]
34009244:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
34009248:	b29b      	uxth	r3, r3
3400924a:	827b      	strh	r3, [r7, #18]
    tmp2 = MATRIX_VALUE10((uint16_t)pColorConversionConfig->BA);
3400924c:	687b      	ldr	r3, [r7, #4]
3400924e:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
34009252:	2b00      	cmp	r3, #0
34009254:	da07      	bge.n	34009266 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x286>
34009256:	687b      	ldr	r3, [r7, #4]
34009258:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
3400925c:	b29b      	uxth	r3, r3
3400925e:	f3c3 0309 	ubfx	r3, r3, #0, #10
34009262:	b29b      	uxth	r3, r3
34009264:	e003      	b.n	3400926e <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x28e>
34009266:	687b      	ldr	r3, [r7, #4]
34009268:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
3400926c:	b29b      	uxth	r3, r3
3400926e:	823b      	strh	r3, [r7, #16]

    MODIFY_REG(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB | DCMIPP_P1CCBR2_BA,
34009270:	68fb      	ldr	r3, [r7, #12]
34009272:	681b      	ldr	r3, [r3, #0]
34009274:	f8d3 2898 	ldr.w	r2, [r3, #2200]	@ 0x898
34009278:	4b09      	ldr	r3, [pc, #36]	@ (340092a0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2c0>)
3400927a:	4013      	ands	r3, r2
3400927c:	8a79      	ldrh	r1, [r7, #18]
3400927e:	8a3a      	ldrh	r2, [r7, #16]
34009280:	0412      	lsls	r2, r2, #16
34009282:	4311      	orrs	r1, r2
34009284:	68fa      	ldr	r2, [r7, #12]
34009286:	6812      	ldr	r2, [r2, #0]
34009288:	430b      	orrs	r3, r1
3400928a:	f8c2 3898 	str.w	r3, [r2, #2200]	@ 0x898
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400928e:	2300      	movs	r3, #0
34009290:	e000      	b.n	34009294 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig+0x2b4>
    return HAL_ERROR;
34009292:	2301      	movs	r3, #1
}
34009294:	4618      	mov	r0, r3
34009296:	371c      	adds	r7, #28
34009298:	46bd      	mov	sp, r7
3400929a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400929e:	4770      	bx	lr
340092a0:	fc00f800 	.word	0xfc00f800

340092a4 <HAL_DCMIPP_PIPE_EnableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340092a4:	b480      	push	{r7}
340092a6:	b083      	sub	sp, #12
340092a8:	af00      	add	r7, sp, #0
340092aa:	6078      	str	r0, [r7, #4]
340092ac:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340092ae:	687b      	ldr	r3, [r7, #4]
340092b0:	2b00      	cmp	r3, #0
340092b2:	d101      	bne.n	340092b8 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x14>
  {
    return HAL_ERROR;
340092b4:	2301      	movs	r3, #1
340092b6:	e00f      	b.n	340092d8 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340092b8:	683b      	ldr	r3, [r7, #0]
340092ba:	2b01      	cmp	r3, #1
340092bc:	d10b      	bne.n	340092d6 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340092be:	687b      	ldr	r3, [r7, #4]
340092c0:	681b      	ldr	r3, [r3, #0]
340092c2:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
340092c6:	687b      	ldr	r3, [r7, #4]
340092c8:	681b      	ldr	r3, [r3, #0]
340092ca:	f042 0201 	orr.w	r2, r2, #1
340092ce:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340092d2:	2300      	movs	r3, #0
340092d4:	e000      	b.n	340092d8 <HAL_DCMIPP_PIPE_EnableISPColorConversion+0x34>
    return HAL_ERROR;
340092d6:	2301      	movs	r3, #1
}
340092d8:	4618      	mov	r0, r3
340092da:	370c      	adds	r7, #12
340092dc:	46bd      	mov	sp, r7
340092de:	f85d 7b04 	ldr.w	r7, [sp], #4
340092e2:	4770      	bx	lr

340092e4 <HAL_DCMIPP_PIPE_DisableISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPColorConversion(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340092e4:	b480      	push	{r7}
340092e6:	b083      	sub	sp, #12
340092e8:	af00      	add	r7, sp, #0
340092ea:	6078      	str	r0, [r7, #4]
340092ec:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340092ee:	687b      	ldr	r3, [r7, #4]
340092f0:	2b00      	cmp	r3, #0
340092f2:	d101      	bne.n	340092f8 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x14>
  {
    return HAL_ERROR;
340092f4:	2301      	movs	r3, #1
340092f6:	e00f      	b.n	34009318 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340092f8:	683b      	ldr	r3, [r7, #0]
340092fa:	2b01      	cmp	r3, #1
340092fc:	d10b      	bne.n	34009316 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE);
340092fe:	687b      	ldr	r3, [r7, #4]
34009300:	681b      	ldr	r3, [r3, #0]
34009302:	f8d3 2880 	ldr.w	r2, [r3, #2176]	@ 0x880
34009306:	687b      	ldr	r3, [r7, #4]
34009308:	681b      	ldr	r3, [r3, #0]
3400930a:	f022 0201 	bic.w	r2, r2, #1
3400930e:	f8c3 2880 	str.w	r2, [r3, #2176]	@ 0x880
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34009312:	2300      	movs	r3, #0
34009314:	e000      	b.n	34009318 <HAL_DCMIPP_PIPE_DisableISPColorConversion+0x34>
    return HAL_ERROR;
34009316:	2301      	movs	r3, #1
}
34009318:	4618      	mov	r0, r3
3400931a:	370c      	adds	r7, #12
3400931c:	46bd      	mov	sp, r7
3400931e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009322:	4770      	bx	lr

34009324 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                    const DCMIPP_BlackLevelConfTypeDef
                                                                    *pBlackLevelConfig)
{
34009324:	b480      	push	{r7}
34009326:	b085      	sub	sp, #20
34009328:	af00      	add	r7, sp, #0
3400932a:	60f8      	str	r0, [r7, #12]
3400932c:	60b9      	str	r1, [r7, #8]
3400932e:	607a      	str	r2, [r7, #4]
  /* Check handles validity */
  if ((hdcmipp == NULL) || (pBlackLevelConfig == NULL))
34009330:	68fb      	ldr	r3, [r7, #12]
34009332:	2b00      	cmp	r3, #0
34009334:	d002      	beq.n	3400933c <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x18>
34009336:	687b      	ldr	r3, [r7, #4]
34009338:	2b00      	cmp	r3, #0
3400933a:	d101      	bne.n	34009340 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x1c>
  {
    return HAL_ERROR;
3400933c:	2301      	movs	r3, #1
3400933e:	e01a      	b.n	34009376 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009340:	68bb      	ldr	r3, [r7, #8]
34009342:	2b01      	cmp	r3, #1
34009344:	d116      	bne.n	34009374 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x50>
  {
    MODIFY_REG(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_BLCR | DCMIPP_P1BLCCR_BLCG | DCMIPP_P1BLCCR_BLCB,
34009346:	68fb      	ldr	r3, [r7, #12]
34009348:	681b      	ldr	r3, [r3, #0]
3400934a:	f8d3 3840 	ldr.w	r3, [r3, #2112]	@ 0x840
3400934e:	b2d9      	uxtb	r1, r3
34009350:	687b      	ldr	r3, [r7, #4]
34009352:	781b      	ldrb	r3, [r3, #0]
34009354:	061a      	lsls	r2, r3, #24
34009356:	687b      	ldr	r3, [r7, #4]
34009358:	785b      	ldrb	r3, [r3, #1]
3400935a:	041b      	lsls	r3, r3, #16
3400935c:	431a      	orrs	r2, r3
3400935e:	687b      	ldr	r3, [r7, #4]
34009360:	789b      	ldrb	r3, [r3, #2]
34009362:	021b      	lsls	r3, r3, #8
34009364:	431a      	orrs	r2, r3
34009366:	68fb      	ldr	r3, [r7, #12]
34009368:	681b      	ldr	r3, [r3, #0]
3400936a:	430a      	orrs	r2, r1
3400936c:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34009370:	2300      	movs	r3, #0
34009372:	e000      	b.n	34009376 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig+0x52>
    return HAL_ERROR;
34009374:	2301      	movs	r3, #1
}
34009376:	4618      	mov	r0, r3
34009378:	3714      	adds	r7, #20
3400937a:	46bd      	mov	sp, r7
3400937c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009380:	4770      	bx	lr

34009382 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009382:	b480      	push	{r7}
34009384:	b083      	sub	sp, #12
34009386:	af00      	add	r7, sp, #0
34009388:	6078      	str	r0, [r7, #4]
3400938a:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3400938c:	687b      	ldr	r3, [r7, #4]
3400938e:	2b00      	cmp	r3, #0
34009390:	d101      	bne.n	34009396 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
34009392:	2301      	movs	r3, #1
34009394:	e00f      	b.n	340093b6 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009396:	683b      	ldr	r3, [r7, #0]
34009398:	2b01      	cmp	r3, #1
3400939a:	d10b      	bne.n	340093b4 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
3400939c:	687b      	ldr	r3, [r7, #4]
3400939e:	681b      	ldr	r3, [r3, #0]
340093a0:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
340093a4:	687b      	ldr	r3, [r7, #4]
340093a6:	681b      	ldr	r3, [r3, #0]
340093a8:	f042 0201 	orr.w	r2, r2, #1
340093ac:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340093b0:	2300      	movs	r3, #0
340093b2:	e000      	b.n	340093b6 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
340093b4:	2301      	movs	r3, #1
}
340093b6:	4618      	mov	r0, r3
340093b8:	370c      	adds	r7, #12
340093ba:	46bd      	mov	sp, r7
340093bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340093c0:	4770      	bx	lr

340093c2 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340093c2:	b480      	push	{r7}
340093c4:	b083      	sub	sp, #12
340093c6:	af00      	add	r7, sp, #0
340093c8:	6078      	str	r0, [r7, #4]
340093ca:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340093cc:	687b      	ldr	r3, [r7, #4]
340093ce:	2b00      	cmp	r3, #0
340093d0:	d101      	bne.n	340093d6 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x14>
  {
    return HAL_ERROR;
340093d2:	2301      	movs	r3, #1
340093d4:	e00f      	b.n	340093f6 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340093d6:	683b      	ldr	r3, [r7, #0]
340093d8:	2b01      	cmp	r3, #1
340093da:	d10b      	bne.n	340093f4 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1BLCCR, DCMIPP_P1BLCCR_ENABLE);
340093dc:	687b      	ldr	r3, [r7, #4]
340093de:	681b      	ldr	r3, [r3, #0]
340093e0:	f8d3 2840 	ldr.w	r2, [r3, #2112]	@ 0x840
340093e4:	687b      	ldr	r3, [r7, #4]
340093e6:	681b      	ldr	r3, [r3, #0]
340093e8:	f022 0201 	bic.w	r2, r2, #1
340093ec:	f8c3 2840 	str.w	r2, [r3, #2112]	@ 0x840
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340093f0:	2300      	movs	r3, #0
340093f2:	e000      	b.n	340093f6 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration+0x34>
    return HAL_ERROR;
340093f4:	2301      	movs	r3, #1
}
340093f6:	4618      	mov	r0, r3
340093f8:	370c      	adds	r7, #12
340093fa:	46bd      	mov	sp, r7
340093fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34009400:	4770      	bx	lr

34009402 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>:
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                  uint8_t ModuleID, const
                                                                  DCMIPP_StatisticExtractionConfTypeDef
                                                                  *pStatisticExtractionConfig)
{
34009402:	b480      	push	{r7}
34009404:	b087      	sub	sp, #28
34009406:	af00      	add	r7, sp, #0
34009408:	60f8      	str	r0, [r7, #12]
3400940a:	60b9      	str	r1, [r7, #8]
3400940c:	603b      	str	r3, [r7, #0]
3400940e:	4613      	mov	r3, r2
34009410:	71fb      	strb	r3, [r7, #7]
  uint32_t p1stxcr_reg;

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionConfig == NULL))
34009412:	68fb      	ldr	r3, [r7, #12]
34009414:	2b00      	cmp	r3, #0
34009416:	d002      	beq.n	3400941e <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x1c>
34009418:	683b      	ldr	r3, [r7, #0]
3400941a:	2b00      	cmp	r3, #0
3400941c:	d101      	bne.n	34009422 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x20>
  {
    return HAL_ERROR;
3400941e:	2301      	movs	r3, #1
34009420:	e03b      	b.n	3400949a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_BINS(pStatisticExtractionConfig->Bins));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_SOURCE(pStatisticExtractionConfig->Source));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODE(pStatisticExtractionConfig->Mode));

  if (Pipe == DCMIPP_PIPE1)
34009422:	68bb      	ldr	r3, [r7, #8]
34009424:	2b01      	cmp	r3, #1
34009426:	d135      	bne.n	34009494 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x92>
  {
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34009428:	683b      	ldr	r3, [r7, #0]
3400942a:	681a      	ldr	r2, [r3, #0]
3400942c:	683b      	ldr	r3, [r7, #0]
3400942e:	685b      	ldr	r3, [r3, #4]
34009430:	431a      	orrs	r2, r3
                  (pStatisticExtractionConfig->Bins);
34009432:	683b      	ldr	r3, [r7, #0]
34009434:	689b      	ldr	r3, [r3, #8]
    p1stxcr_reg = (pStatisticExtractionConfig->Mode) | (pStatisticExtractionConfig->Source) | \
34009436:	4313      	orrs	r3, r2
34009438:	617b      	str	r3, [r7, #20]

    switch (ModuleID)
3400943a:	79fb      	ldrb	r3, [r7, #7]
3400943c:	2b01      	cmp	r3, #1
3400943e:	d002      	beq.n	34009446 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x44>
34009440:	2b02      	cmp	r3, #2
34009442:	d00d      	beq.n	34009460 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x5e>
34009444:	e019      	b.n	3400947a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x78>
    {
      case DCMIPP_STATEXT_MODULE1:
        MODIFY_REG(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_BINS | DCMIPP_P1ST1CR_SRC | \
34009446:	68fb      	ldr	r3, [r7, #12]
34009448:	681b      	ldr	r3, [r3, #0]
3400944a:	f8d3 3850 	ldr.w	r3, [r3, #2128]	@ 0x850
3400944e:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34009452:	68fb      	ldr	r3, [r7, #12]
34009454:	681b      	ldr	r3, [r3, #0]
34009456:	697a      	ldr	r2, [r7, #20]
34009458:	430a      	orrs	r2, r1
3400945a:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
                   DCMIPP_P1ST1CR_MODE, p1stxcr_reg);
        break;
3400945e:	e01b      	b.n	34009498 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      case DCMIPP_STATEXT_MODULE2:
        MODIFY_REG(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_BINS | DCMIPP_P1ST2CR_SRC | \
34009460:	68fb      	ldr	r3, [r7, #12]
34009462:	681b      	ldr	r3, [r3, #0]
34009464:	f8d3 3854 	ldr.w	r3, [r3, #2132]	@ 0x854
34009468:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
3400946c:	68fb      	ldr	r3, [r7, #12]
3400946e:	681b      	ldr	r3, [r3, #0]
34009470:	697a      	ldr	r2, [r7, #20]
34009472:	430a      	orrs	r2, r1
34009474:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
                   DCMIPP_P1ST2CR_MODE, p1stxcr_reg);
        break;
34009478:	e00e      	b.n	34009498 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        MODIFY_REG(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_BINS | DCMIPP_P1ST3CR_SRC | \
3400947a:	68fb      	ldr	r3, [r7, #12]
3400947c:	681b      	ldr	r3, [r3, #0]
3400947e:	f8d3 3858 	ldr.w	r3, [r3, #2136]	@ 0x858
34009482:	f023 01fc 	bic.w	r1, r3, #252	@ 0xfc
34009486:	68fb      	ldr	r3, [r7, #12]
34009488:	681b      	ldr	r3, [r3, #0]
3400948a:	697a      	ldr	r2, [r7, #20]
3400948c:	430a      	orrs	r2, r1
3400948e:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
                   DCMIPP_P1ST3CR_MODE, p1stxcr_reg);
        break;
34009492:	e001      	b.n	34009498 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x96>
    }
  }
  else
  {
    return HAL_ERROR;
34009494:	2301      	movs	r3, #1
34009496:	e000      	b.n	3400949a <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig+0x98>
  }

  return HAL_OK;
34009498:	2300      	movs	r3, #0
}
3400949a:	4618      	mov	r0, r3
3400949c:	371c      	adds	r7, #28
3400949e:	46bd      	mov	sp, r7
340094a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340094a4:	4770      	bx	lr

340094a6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                      const DCMIPP_StatisticExtractionAreaConfTypeDef
                                                                      *pStatisticExtractionAreaConfig)
{
340094a6:	b480      	push	{r7}
340094a8:	b085      	sub	sp, #20
340094aa:	af00      	add	r7, sp, #0
340094ac:	60f8      	str	r0, [r7, #12]
340094ae:	60b9      	str	r1, [r7, #8]
340094b0:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pStatisticExtractionAreaConfig == NULL))
340094b2:	68fb      	ldr	r3, [r7, #12]
340094b4:	2b00      	cmp	r3, #0
340094b6:	d002      	beq.n	340094be <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x18>
340094b8:	687b      	ldr	r3, [r7, #4]
340094ba:	2b00      	cmp	r3, #0
340094bc:	d101      	bne.n	340094c2 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x1c>
  {
    return HAL_ERROR;
340094be:	2301      	movs	r3, #1
340094c0:	e027      	b.n	34009512 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->HStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_START(pStatisticExtractionAreaConfig->VStart));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->HSize));
  assert_param(IS_DCMIPP_PIPE_STAT_EXTRACTION_SIZE(pStatisticExtractionAreaConfig->VSize));

  if (Pipe == DCMIPP_PIPE1)
340094c2:	68bb      	ldr	r3, [r7, #8]
340094c4:	2b01      	cmp	r3, #1
340094c6:	d123      	bne.n	34009510 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6a>
  {
    MODIFY_REG(hdcmipp->Instance->P1STSTR, DCMIPP_P1STSTR_HSTART | DCMIPP_P1STSTR_VSTART,
340094c8:	68fb      	ldr	r3, [r7, #12]
340094ca:	681b      	ldr	r3, [r3, #0]
340094cc:	f8d3 385c 	ldr.w	r3, [r3, #2140]	@ 0x85c
340094d0:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
340094d4:	687b      	ldr	r3, [r7, #4]
340094d6:	685a      	ldr	r2, [r3, #4]
340094d8:	687b      	ldr	r3, [r7, #4]
340094da:	681b      	ldr	r3, [r3, #0]
340094dc:	041b      	lsls	r3, r3, #16
340094de:	431a      	orrs	r2, r3
340094e0:	68fb      	ldr	r3, [r7, #12]
340094e2:	681b      	ldr	r3, [r3, #0]
340094e4:	430a      	orrs	r2, r1
340094e6:	f8c3 285c 	str.w	r2, [r3, #2140]	@ 0x85c
               (pStatisticExtractionAreaConfig->HStart << DCMIPP_P1STSTR_HSTART_Pos) | \
               (pStatisticExtractionAreaConfig->VStart << DCMIPP_P1STSTR_VSTART_Pos));

    MODIFY_REG(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_HSIZE | DCMIPP_P1STSZR_VSIZE,
340094ea:	68fb      	ldr	r3, [r7, #12]
340094ec:	681b      	ldr	r3, [r3, #0]
340094ee:	f8d3 3860 	ldr.w	r3, [r3, #2144]	@ 0x860
340094f2:	f003 21f0 	and.w	r1, r3, #4026593280	@ 0xf000f000
340094f6:	687b      	ldr	r3, [r7, #4]
340094f8:	68da      	ldr	r2, [r3, #12]
340094fa:	687b      	ldr	r3, [r7, #4]
340094fc:	689b      	ldr	r3, [r3, #8]
340094fe:	041b      	lsls	r3, r3, #16
34009500:	431a      	orrs	r2, r3
34009502:	68fb      	ldr	r3, [r7, #12]
34009504:	681b      	ldr	r3, [r3, #0]
34009506:	430a      	orrs	r2, r1
34009508:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400950c:	2300      	movs	r3, #0
3400950e:	e000      	b.n	34009512 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig+0x6c>
    return HAL_ERROR;
34009510:	2301      	movs	r3, #1
}
34009512:	4618      	mov	r0, r3
34009514:	3714      	adds	r7, #20
34009516:	46bd      	mov	sp, r7
34009518:	f85d 7b04 	ldr.w	r7, [sp], #4
3400951c:	4770      	bx	lr

3400951e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>:
  * @param  ModuleID  Specifies the Module ID, can be a value from @ref DCMIPP_Statistics_Extraction_Module_ID.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                               uint8_t ModuleID)
{
3400951e:	b480      	push	{r7}
34009520:	b085      	sub	sp, #20
34009522:	af00      	add	r7, sp, #0
34009524:	60f8      	str	r0, [r7, #12]
34009526:	60b9      	str	r1, [r7, #8]
34009528:	4613      	mov	r3, r2
3400952a:	71fb      	strb	r3, [r7, #7]
  /* Check handle validity */
  if (hdcmipp == NULL)
3400952c:	68fb      	ldr	r3, [r7, #12]
3400952e:	2b00      	cmp	r3, #0
34009530:	d101      	bne.n	34009536 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x18>
  {
    return HAL_ERROR;
34009532:	2301      	movs	r3, #1
34009534:	e02c      	b.n	34009590 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34009536:	68bb      	ldr	r3, [r7, #8]
34009538:	2b01      	cmp	r3, #1
3400953a:	d126      	bne.n	3400958a <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x6c>
  {
    switch (ModuleID)
3400953c:	79fb      	ldrb	r3, [r7, #7]
3400953e:	2b01      	cmp	r3, #1
34009540:	d002      	beq.n	34009548 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x2a>
34009542:	2b02      	cmp	r3, #2
34009544:	d00b      	beq.n	3400955e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x40>
34009546:	e015      	b.n	34009574 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x56>
    {
      case DCMIPP_STATEXT_MODULE1:
        SET_BIT(hdcmipp->Instance->P1ST1CR, DCMIPP_P1ST1CR_ENABLE);
34009548:	68fb      	ldr	r3, [r7, #12]
3400954a:	681b      	ldr	r3, [r3, #0]
3400954c:	f8d3 2850 	ldr.w	r2, [r3, #2128]	@ 0x850
34009550:	68fb      	ldr	r3, [r7, #12]
34009552:	681b      	ldr	r3, [r3, #0]
34009554:	f042 0201 	orr.w	r2, r2, #1
34009558:	f8c3 2850 	str.w	r2, [r3, #2128]	@ 0x850
        break;
3400955c:	e017      	b.n	3400958e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      case DCMIPP_STATEXT_MODULE2:
        SET_BIT(hdcmipp->Instance->P1ST2CR, DCMIPP_P1ST2CR_ENABLE);
3400955e:	68fb      	ldr	r3, [r7, #12]
34009560:	681b      	ldr	r3, [r3, #0]
34009562:	f8d3 2854 	ldr.w	r2, [r3, #2132]	@ 0x854
34009566:	68fb      	ldr	r3, [r7, #12]
34009568:	681b      	ldr	r3, [r3, #0]
3400956a:	f042 0201 	orr.w	r2, r2, #1
3400956e:	f8c3 2854 	str.w	r2, [r3, #2132]	@ 0x854
        break;
34009572:	e00c      	b.n	3400958e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
      default:
        /* DCMIPP_STATEXT_MODULE3 */
        SET_BIT(hdcmipp->Instance->P1ST3CR, DCMIPP_P1ST3CR_ENABLE);
34009574:	68fb      	ldr	r3, [r7, #12]
34009576:	681b      	ldr	r3, [r3, #0]
34009578:	f8d3 2858 	ldr.w	r2, [r3, #2136]	@ 0x858
3400957c:	68fb      	ldr	r3, [r7, #12]
3400957e:	681b      	ldr	r3, [r3, #0]
34009580:	f042 0201 	orr.w	r2, r2, #1
34009584:	f8c3 2858 	str.w	r2, [r3, #2136]	@ 0x858
        break;
34009588:	e001      	b.n	3400958e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x70>
    }
  }
  else
  {
    return HAL_ERROR;
3400958a:	2301      	movs	r3, #1
3400958c:	e000      	b.n	34009590 <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction+0x72>
  }

  return HAL_OK;
3400958e:	2300      	movs	r3, #0
}
34009590:	4618      	mov	r0, r3
34009592:	3714      	adds	r7, #20
34009594:	46bd      	mov	sp, r7
34009596:	f85d 7b04 	ldr.w	r7, [sp], #4
3400959a:	4770      	bx	lr

3400959c <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3400959c:	b480      	push	{r7}
3400959e:	b083      	sub	sp, #12
340095a0:	af00      	add	r7, sp, #0
340095a2:	6078      	str	r0, [r7, #4]
340095a4:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340095a6:	687b      	ldr	r3, [r7, #4]
340095a8:	2b00      	cmp	r3, #0
340095aa:	d101      	bne.n	340095b0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x14>
  {
    return HAL_ERROR;
340095ac:	2301      	movs	r3, #1
340095ae:	e00f      	b.n	340095d0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340095b0:	683b      	ldr	r3, [r7, #0]
340095b2:	2b01      	cmp	r3, #1
340095b4:	d10b      	bne.n	340095ce <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x32>
  {
    /* Crop line enable */
    SET_BIT(hdcmipp->Instance->P1STSZR, DCMIPP_P1STSZR_CROPEN);
340095b6:	687b      	ldr	r3, [r7, #4]
340095b8:	681b      	ldr	r3, [r3, #0]
340095ba:	f8d3 2860 	ldr.w	r2, [r3, #2144]	@ 0x860
340095be:	687b      	ldr	r3, [r7, #4]
340095c0:	681b      	ldr	r3, [r3, #0]
340095c2:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
340095c6:	f8c3 2860 	str.w	r2, [r3, #2144]	@ 0x860
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340095ca:	2300      	movs	r3, #0
340095cc:	e000      	b.n	340095d0 <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction+0x34>
    return HAL_ERROR;
340095ce:	2301      	movs	r3, #1
}
340095d0:	4618      	mov	r0, r3
340095d2:	370c      	adds	r7, #12
340095d4:	46bd      	mov	sp, r7
340095d6:	f85d 7b04 	ldr.w	r7, [sp], #4
340095da:	4770      	bx	lr

340095dc <HAL_DCMIPP_PIPE_SetISPExposureConfig>:
  * @param  pExposureConfig pointer to the DCMIPP_ExposureConfTypeDef structure that contains the exposure information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPExposureConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       const DCMIPP_ExposureConfTypeDef *pExposureConfig)
{
340095dc:	b480      	push	{r7}
340095de:	b085      	sub	sp, #20
340095e0:	af00      	add	r7, sp, #0
340095e2:	60f8      	str	r0, [r7, #12]
340095e4:	60b9      	str	r1, [r7, #8]
340095e6:	607a      	str	r2, [r7, #4]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pExposureConfig == NULL))
340095e8:	68fb      	ldr	r3, [r7, #12]
340095ea:	2b00      	cmp	r3, #0
340095ec:	d002      	beq.n	340095f4 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x18>
340095ee:	687b      	ldr	r3, [r7, #4]
340095f0:	2b00      	cmp	r3, #0
340095f2:	d101      	bne.n	340095f8 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x1c>
  {
    return HAL_ERROR;
340095f4:	2301      	movs	r3, #1
340095f6:	e02d      	b.n	34009654 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftRed));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftGreen));
  assert_param(IS_DCMIPP_EXPOSURE_SHF(pExposureConfig->ShiftBlue));

  if (Pipe == DCMIPP_PIPE1)
340095f8:	68bb      	ldr	r3, [r7, #8]
340095fa:	2b01      	cmp	r3, #1
340095fc:	d129      	bne.n	34009652 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x76>
  {
    MODIFY_REG(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_SHFR | DCMIPP_P1EXCR1_MULTR,
340095fe:	68fb      	ldr	r3, [r7, #12]
34009600:	681b      	ldr	r3, [r3, #0]
34009602:	f8d3 3844 	ldr.w	r3, [r3, #2116]	@ 0x844
34009606:	f023 43ff 	bic.w	r3, r3, #2139095040	@ 0x7f800000
3400960a:	f423 03e0 	bic.w	r3, r3, #7340032	@ 0x700000
3400960e:	687a      	ldr	r2, [r7, #4]
34009610:	7812      	ldrb	r2, [r2, #0]
34009612:	0711      	lsls	r1, r2, #28
34009614:	687a      	ldr	r2, [r7, #4]
34009616:	7852      	ldrb	r2, [r2, #1]
34009618:	0512      	lsls	r2, r2, #20
3400961a:	4311      	orrs	r1, r2
3400961c:	68fa      	ldr	r2, [r7, #12]
3400961e:	6812      	ldr	r2, [r2, #0]
34009620:	430b      	orrs	r3, r1
34009622:	f8c2 3844 	str.w	r3, [r2, #2116]	@ 0x844
               (((uint32_t)pExposureConfig->ShiftRed << DCMIPP_P1EXCR1_SHFR_Pos) | \
                ((uint32_t)pExposureConfig->MultiplierRed << DCMIPP_P1EXCR1_MULTR_Pos)));

    WRITE_REG(hdcmipp->Instance->P1EXCR2, (((uint32_t)pExposureConfig->ShiftGreen << DCMIPP_P1EXCR2_SHFG_Pos) | \
34009626:	687b      	ldr	r3, [r7, #4]
34009628:	789b      	ldrb	r3, [r3, #2]
3400962a:	071a      	lsls	r2, r3, #28
3400962c:	687b      	ldr	r3, [r7, #4]
3400962e:	78db      	ldrb	r3, [r3, #3]
34009630:	051b      	lsls	r3, r3, #20
34009632:	431a      	orrs	r2, r3
34009634:	687b      	ldr	r3, [r7, #4]
34009636:	791b      	ldrb	r3, [r3, #4]
34009638:	031b      	lsls	r3, r3, #12
3400963a:	ea42 0103 	orr.w	r1, r2, r3
3400963e:	687b      	ldr	r3, [r7, #4]
34009640:	795b      	ldrb	r3, [r3, #5]
34009642:	011a      	lsls	r2, r3, #4
34009644:	68fb      	ldr	r3, [r7, #12]
34009646:	681b      	ldr	r3, [r3, #0]
34009648:	430a      	orrs	r2, r1
3400964a:	f8c3 2848 	str.w	r2, [r3, #2120]	@ 0x848
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400964e:	2300      	movs	r3, #0
34009650:	e000      	b.n	34009654 <HAL_DCMIPP_PIPE_SetISPExposureConfig+0x78>
    return HAL_ERROR;
34009652:	2301      	movs	r3, #1
}
34009654:	4618      	mov	r0, r3
34009656:	3714      	adds	r7, #20
34009658:	46bd      	mov	sp, r7
3400965a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400965e:	4770      	bx	lr

34009660 <HAL_DCMIPP_PIPE_EnableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009660:	b480      	push	{r7}
34009662:	b083      	sub	sp, #12
34009664:	af00      	add	r7, sp, #0
34009666:	6078      	str	r0, [r7, #4]
34009668:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3400966a:	687b      	ldr	r3, [r7, #4]
3400966c:	2b00      	cmp	r3, #0
3400966e:	d101      	bne.n	34009674 <HAL_DCMIPP_PIPE_EnableISPExposure+0x14>
  {
    return HAL_ERROR;
34009670:	2301      	movs	r3, #1
34009672:	e00f      	b.n	34009694 <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009674:	683b      	ldr	r3, [r7, #0]
34009676:	2b01      	cmp	r3, #1
34009678:	d10b      	bne.n	34009692 <HAL_DCMIPP_PIPE_EnableISPExposure+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
3400967a:	687b      	ldr	r3, [r7, #4]
3400967c:	681b      	ldr	r3, [r3, #0]
3400967e:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
34009682:	687b      	ldr	r3, [r7, #4]
34009684:	681b      	ldr	r3, [r3, #0]
34009686:	f042 0201 	orr.w	r2, r2, #1
3400968a:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400968e:	2300      	movs	r3, #0
34009690:	e000      	b.n	34009694 <HAL_DCMIPP_PIPE_EnableISPExposure+0x34>
    return HAL_ERROR;
34009692:	2301      	movs	r3, #1
}
34009694:	4618      	mov	r0, r3
34009696:	370c      	adds	r7, #12
34009698:	46bd      	mov	sp, r7
3400969a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400969e:	4770      	bx	lr

340096a0 <HAL_DCMIPP_PIPE_DisableISPExposure>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPExposure(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340096a0:	b480      	push	{r7}
340096a2:	b083      	sub	sp, #12
340096a4:	af00      	add	r7, sp, #0
340096a6:	6078      	str	r0, [r7, #4]
340096a8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340096aa:	687b      	ldr	r3, [r7, #4]
340096ac:	2b00      	cmp	r3, #0
340096ae:	d101      	bne.n	340096b4 <HAL_DCMIPP_PIPE_DisableISPExposure+0x14>
  {
    return HAL_ERROR;
340096b0:	2301      	movs	r3, #1
340096b2:	e00f      	b.n	340096d4 <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340096b4:	683b      	ldr	r3, [r7, #0]
340096b6:	2b01      	cmp	r3, #1
340096b8:	d10b      	bne.n	340096d2 <HAL_DCMIPP_PIPE_DisableISPExposure+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1EXCR1, DCMIPP_P1EXCR1_ENABLE);
340096ba:	687b      	ldr	r3, [r7, #4]
340096bc:	681b      	ldr	r3, [r3, #0]
340096be:	f8d3 2844 	ldr.w	r2, [r3, #2116]	@ 0x844
340096c2:	687b      	ldr	r3, [r7, #4]
340096c4:	681b      	ldr	r3, [r3, #0]
340096c6:	f022 0201 	bic.w	r2, r2, #1
340096ca:	f8c3 2844 	str.w	r2, [r3, #2116]	@ 0x844
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340096ce:	2300      	movs	r3, #0
340096d0:	e000      	b.n	340096d4 <HAL_DCMIPP_PIPE_DisableISPExposure+0x34>
    return HAL_ERROR;
340096d2:	2301      	movs	r3, #1
}
340096d4:	4618      	mov	r0, r3
340096d6:	370c      	adds	r7, #12
340096d8:	46bd      	mov	sp, r7
340096da:	f85d 7b04 	ldr.w	r7, [sp], #4
340096de:	4770      	bx	lr

340096e0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>:
  * @param  pContrastConfig pointer to the DCMIPP_ContrastConfTypeDef structure that contains contrast information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                           const DCMIPP_ContrastConfTypeDef *pContrastConfig)
{
340096e0:	b480      	push	{r7}
340096e2:	b085      	sub	sp, #20
340096e4:	af00      	add	r7, sp, #0
340096e6:	60f8      	str	r0, [r7, #12]
340096e8:	60b9      	str	r1, [r7, #8]
340096ea:	607a      	str	r2, [r7, #4]
  /* Check handle validity */
  if ((hdcmipp == NULL) || (pContrastConfig == NULL))
340096ec:	68fb      	ldr	r3, [r7, #12]
340096ee:	2b00      	cmp	r3, #0
340096f0:	d002      	beq.n	340096f8 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x18>
340096f2:	687b      	ldr	r3, [r7, #4]
340096f4:	2b00      	cmp	r3, #0
340096f6:	d101      	bne.n	340096fc <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x1c>
  {
    return HAL_ERROR;
340096f8:	2301      	movs	r3, #1
340096fa:	e03b      	b.n	34009774 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_160));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_192));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_224));
  assert_param(IS_DCMIPP_LUMINANCE(pContrastConfig->LUM_256));

  if (Pipe == DCMIPP_PIPE1)
340096fc:	68bb      	ldr	r3, [r7, #8]
340096fe:	2b01      	cmp	r3, #1
34009700:	d137      	bne.n	34009772 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x92>
  {

    MODIFY_REG(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_LUM0,
34009702:	68fb      	ldr	r3, [r7, #12]
34009704:	681b      	ldr	r3, [r3, #0]
34009706:	f8d3 38a0 	ldr.w	r3, [r3, #2208]	@ 0x8a0
3400970a:	f423 41fc 	bic.w	r1, r3, #32256	@ 0x7e00
3400970e:	687b      	ldr	r3, [r7, #4]
34009710:	781b      	ldrb	r3, [r3, #0]
34009712:	025a      	lsls	r2, r3, #9
34009714:	68fb      	ldr	r3, [r7, #12]
34009716:	681b      	ldr	r3, [r3, #0]
34009718:	430a      	orrs	r2, r1
3400971a:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
               (uint32_t)pContrastConfig->LUM_0 << DCMIPP_P1CTCR1_LUM0_Pos);

    WRITE_REG(hdcmipp->Instance->P1CTCR2, (((uint32_t)pContrastConfig->LUM_32 << DCMIPP_P1CTCR2_LUM1_Pos) |
3400971e:	687b      	ldr	r3, [r7, #4]
34009720:	785b      	ldrb	r3, [r3, #1]
34009722:	065a      	lsls	r2, r3, #25
34009724:	687b      	ldr	r3, [r7, #4]
34009726:	789b      	ldrb	r3, [r3, #2]
34009728:	045b      	lsls	r3, r3, #17
3400972a:	431a      	orrs	r2, r3
3400972c:	687b      	ldr	r3, [r7, #4]
3400972e:	78db      	ldrb	r3, [r3, #3]
34009730:	025b      	lsls	r3, r3, #9
34009732:	ea42 0103 	orr.w	r1, r2, r3
34009736:	687b      	ldr	r3, [r7, #4]
34009738:	791b      	ldrb	r3, [r3, #4]
3400973a:	005a      	lsls	r2, r3, #1
3400973c:	68fb      	ldr	r3, [r7, #12]
3400973e:	681b      	ldr	r3, [r3, #0]
34009740:	430a      	orrs	r2, r1
34009742:	f8c3 28a4 	str.w	r2, [r3, #2212]	@ 0x8a4
                                           ((uint32_t)pContrastConfig->LUM_64 << DCMIPP_P1CTCR2_LUM2_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_96 << DCMIPP_P1CTCR2_LUM3_Pos) |
                                           ((uint32_t)pContrastConfig->LUM_128 << DCMIPP_P1CTCR2_LUM4_Pos)));

    WRITE_REG(hdcmipp->Instance->P1CTCR3, (((uint32_t)pContrastConfig->LUM_160 << DCMIPP_P1CTCR3_LUM5_Pos) |
34009746:	687b      	ldr	r3, [r7, #4]
34009748:	795b      	ldrb	r3, [r3, #5]
3400974a:	065a      	lsls	r2, r3, #25
3400974c:	687b      	ldr	r3, [r7, #4]
3400974e:	799b      	ldrb	r3, [r3, #6]
34009750:	045b      	lsls	r3, r3, #17
34009752:	431a      	orrs	r2, r3
34009754:	687b      	ldr	r3, [r7, #4]
34009756:	79db      	ldrb	r3, [r3, #7]
34009758:	025b      	lsls	r3, r3, #9
3400975a:	ea42 0103 	orr.w	r1, r2, r3
3400975e:	687b      	ldr	r3, [r7, #4]
34009760:	7a1b      	ldrb	r3, [r3, #8]
34009762:	005a      	lsls	r2, r3, #1
34009764:	68fb      	ldr	r3, [r7, #12]
34009766:	681b      	ldr	r3, [r3, #0]
34009768:	430a      	orrs	r2, r1
3400976a:	f8c3 28a8 	str.w	r2, [r3, #2216]	@ 0x8a8
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
3400976e:	2300      	movs	r3, #0
34009770:	e000      	b.n	34009774 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig+0x94>
    return HAL_ERROR;
34009772:	2301      	movs	r3, #1
}
34009774:	4618      	mov	r0, r3
34009776:	3714      	adds	r7, #20
34009778:	46bd      	mov	sp, r7
3400977a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400977e:	4770      	bx	lr

34009780 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009780:	b480      	push	{r7}
34009782:	b083      	sub	sp, #12
34009784:	af00      	add	r7, sp, #0
34009786:	6078      	str	r0, [r7, #4]
34009788:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
3400978a:	687b      	ldr	r3, [r7, #4]
3400978c:	2b00      	cmp	r3, #0
3400978e:	d101      	bne.n	34009794 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
34009790:	2301      	movs	r3, #1
34009792:	e00f      	b.n	340097b4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009794:	683b      	ldr	r3, [r7, #0]
34009796:	2b01      	cmp	r3, #1
34009798:	d10b      	bne.n	340097b2 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x32>
  {
    SET_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
3400979a:	687b      	ldr	r3, [r7, #4]
3400979c:	681b      	ldr	r3, [r3, #0]
3400979e:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
340097a2:	687b      	ldr	r3, [r7, #4]
340097a4:	681b      	ldr	r3, [r3, #0]
340097a6:	f042 0201 	orr.w	r2, r2, #1
340097aa:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340097ae:	2300      	movs	r3, #0
340097b0:	e000      	b.n	340097b4 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast+0x34>
    return HAL_ERROR;
340097b2:	2301      	movs	r3, #1
}
340097b4:	4618      	mov	r0, r3
340097b6:	370c      	adds	r7, #12
340097b8:	46bd      	mov	sp, r7
340097ba:	f85d 7b04 	ldr.w	r7, [sp], #4
340097be:	4770      	bx	lr

340097c0 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableISPCtrlContrast(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340097c0:	b480      	push	{r7}
340097c2:	b083      	sub	sp, #12
340097c4:	af00      	add	r7, sp, #0
340097c6:	6078      	str	r0, [r7, #4]
340097c8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if (hdcmipp == NULL)
340097ca:	687b      	ldr	r3, [r7, #4]
340097cc:	2b00      	cmp	r3, #0
340097ce:	d101      	bne.n	340097d4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x14>
  {
    return HAL_ERROR;
340097d0:	2301      	movs	r3, #1
340097d2:	e00f      	b.n	340097f4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
  }

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
340097d4:	683b      	ldr	r3, [r7, #0]
340097d6:	2b01      	cmp	r3, #1
340097d8:	d10b      	bne.n	340097f2 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x32>
  {
    CLEAR_BIT(hdcmipp->Instance->P1CTCR1, DCMIPP_P1CTCR1_ENABLE);
340097da:	687b      	ldr	r3, [r7, #4]
340097dc:	681b      	ldr	r3, [r3, #0]
340097de:	f8d3 28a0 	ldr.w	r2, [r3, #2208]	@ 0x8a0
340097e2:	687b      	ldr	r3, [r7, #4]
340097e4:	681b      	ldr	r3, [r3, #0]
340097e6:	f022 0201 	bic.w	r2, r2, #1
340097ea:	f8c3 28a0 	str.w	r2, [r3, #2208]	@ 0x8a0
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
340097ee:	2300      	movs	r3, #0
340097f0:	e000      	b.n	340097f4 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast+0x34>
    return HAL_ERROR;
340097f2:	2301      	movs	r3, #1
}
340097f4:	4618      	mov	r0, r3
340097f6:	370c      	adds	r7, #12
340097f8:	46bd      	mov	sp, r7
340097fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340097fe:	4770      	bx	lr

34009800 <HAL_DCMIPP_PIPE_SetPitch>:
  * @param  Pipe       Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  LinePitch  the new Pitch value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPitch(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t LinePitch)
{
34009800:	b480      	push	{r7}
34009802:	b085      	sub	sp, #20
34009804:	af00      	add	r7, sp, #0
34009806:	60f8      	str	r0, [r7, #12]
34009808:	60b9      	str	r1, [r7, #8]
3400980a:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
3400980c:	68fb      	ldr	r3, [r7, #12]
3400980e:	2b00      	cmp	r3, #0
34009810:	d101      	bne.n	34009816 <HAL_DCMIPP_PIPE_SetPitch+0x16>
  {
    return HAL_ERROR;
34009812:	2301      	movs	r3, #1
34009814:	e026      	b.n	34009864 <HAL_DCMIPP_PIPE_SetPitch+0x64>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PIPE_PITCH(LinePitch));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34009816:	68bb      	ldr	r3, [r7, #8]
34009818:	2b01      	cmp	r3, #1
3400981a:	d10e      	bne.n	3400983a <HAL_DCMIPP_PIPE_SetPitch+0x3a>
  {
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH, LinePitch << DCMIPP_P1PPM0PR_PITCH_Pos);
3400981c:	68fb      	ldr	r3, [r7, #12]
3400981e:	681b      	ldr	r3, [r3, #0]
34009820:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
34009824:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34009828:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
3400982c:	68fa      	ldr	r2, [r7, #12]
3400982e:	6812      	ldr	r2, [r2, #0]
34009830:	6879      	ldr	r1, [r7, #4]
34009832:	430b      	orrs	r3, r1
34009834:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
34009838:	e013      	b.n	34009862 <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else if (Pipe == DCMIPP_PIPE2)
3400983a:	68bb      	ldr	r3, [r7, #8]
3400983c:	2b02      	cmp	r3, #2
3400983e:	d10e      	bne.n	3400985e <HAL_DCMIPP_PIPE_SetPitch+0x5e>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH, LinePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
34009840:	68fb      	ldr	r3, [r7, #12]
34009842:	681b      	ldr	r3, [r3, #0]
34009844:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
34009848:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
3400984c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34009850:	68fa      	ldr	r2, [r7, #12]
34009852:	6812      	ldr	r2, [r2, #0]
34009854:	6879      	ldr	r1, [r7, #4]
34009856:	430b      	orrs	r3, r1
34009858:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
3400985c:	e001      	b.n	34009862 <HAL_DCMIPP_PIPE_SetPitch+0x62>
  }
  else
  {
    return HAL_ERROR;
3400985e:	2301      	movs	r3, #1
34009860:	e000      	b.n	34009864 <HAL_DCMIPP_PIPE_SetPitch+0x64>
  }

  return HAL_OK;
34009862:	2300      	movs	r3, #0
}
34009864:	4618      	mov	r0, r3
34009866:	3714      	adds	r7, #20
34009868:	46bd      	mov	sp, r7
3400986a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400986e:	4770      	bx	lr

34009870 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>:
  * @param  PixelPackerFormat the new Pixel Packer Format value.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetPixelPackerFormat(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                       uint32_t PixelPackerFormat)
{
34009870:	b480      	push	{r7}
34009872:	b085      	sub	sp, #20
34009874:	af00      	add	r7, sp, #0
34009876:	60f8      	str	r0, [r7, #12]
34009878:	60b9      	str	r1, [r7, #8]
3400987a:	607a      	str	r2, [r7, #4]
  /* Check Parameters */
  if (hdcmipp == NULL)
3400987c:	68fb      	ldr	r3, [r7, #12]
3400987e:	2b00      	cmp	r3, #0
34009880:	d101      	bne.n	34009886 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x16>
  {
    return HAL_ERROR;
34009882:	2301      	movs	r3, #1
34009884:	e022      	b.n	340098cc <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_PIXEL_PACKER_FORMAT(PixelPackerFormat));

  /* Set Pixel Pipe Pitch for the Pipe */
  if (Pipe == DCMIPP_PIPE1)
34009886:	68bb      	ldr	r3, [r7, #8]
34009888:	2b01      	cmp	r3, #1
3400988a:	d10c      	bne.n	340098a6 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x36>
  {
    /* Configure the pixel packer */
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, PixelPackerFormat);
3400988c:	68fb      	ldr	r3, [r7, #12]
3400988e:	681b      	ldr	r3, [r3, #0]
34009890:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34009894:	f023 010f 	bic.w	r1, r3, #15
34009898:	68fb      	ldr	r3, [r7, #12]
3400989a:	681b      	ldr	r3, [r3, #0]
3400989c:	687a      	ldr	r2, [r7, #4]
3400989e:	430a      	orrs	r2, r1
340098a0:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
340098a4:	e011      	b.n	340098ca <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else if (Pipe == DCMIPP_PIPE2)
340098a6:	68bb      	ldr	r3, [r7, #8]
340098a8:	2b02      	cmp	r3, #2
340098aa:	d10c      	bne.n	340098c6 <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x56>
  {
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, PixelPackerFormat);
340098ac:	68fb      	ldr	r3, [r7, #12]
340098ae:	681b      	ldr	r3, [r3, #0]
340098b0:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
340098b4:	f023 010f 	bic.w	r1, r3, #15
340098b8:	68fb      	ldr	r3, [r7, #12]
340098ba:	681b      	ldr	r3, [r3, #0]
340098bc:	687a      	ldr	r2, [r7, #4]
340098be:	430a      	orrs	r2, r1
340098c0:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
340098c4:	e001      	b.n	340098ca <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5a>
  }
  else
  {
    return HAL_ERROR;
340098c6:	2301      	movs	r3, #1
340098c8:	e000      	b.n	340098cc <HAL_DCMIPP_PIPE_SetPixelPackerFormat+0x5c>
  }

  return HAL_OK;
340098ca:	2300      	movs	r3, #0
}
340098cc:	4618      	mov	r0, r3
340098ce:	3714      	adds	r7, #20
340098d0:	46bd      	mov	sp, r7
340098d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340098d6:	4770      	bx	lr

340098d8 <HAL_DCMIPP_PIPE_SetMemoryAddress>:
  * @param  DstAddress the new destination address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_SetMemoryAddress(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t Memory,
                                                   uint32_t DstAddress)
{
340098d8:	b480      	push	{r7}
340098da:	b085      	sub	sp, #20
340098dc:	af00      	add	r7, sp, #0
340098de:	60f8      	str	r0, [r7, #12]
340098e0:	60b9      	str	r1, [r7, #8]
340098e2:	607a      	str	r2, [r7, #4]
340098e4:	603b      	str	r3, [r7, #0]
  /* Check Parameters */
  if (hdcmipp == NULL)
340098e6:	68fb      	ldr	r3, [r7, #12]
340098e8:	2b00      	cmp	r3, #0
340098ea:	d101      	bne.n	340098f0 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x18>
  {
    return HAL_ERROR;
340098ec:	2301      	movs	r3, #1
340098ee:	e043      	b.n	34009978 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xa0>
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_MEMORY_ADDRESS(Memory));

  /* Request Capture for the chosen Pipe */

  if (Pipe == DCMIPP_PIPE0)
340098f0:	68bb      	ldr	r3, [r7, #8]
340098f2:	2b00      	cmp	r3, #0
340098f4:	d119      	bne.n	3400992a <HAL_DCMIPP_PIPE_SetMemoryAddress+0x52>
  {
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
340098f6:	687b      	ldr	r3, [r7, #4]
340098f8:	2b00      	cmp	r3, #0
340098fa:	d105      	bne.n	34009908 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x30>
    {
      /* Set Memory0 destination addresses for pipe0 */
      WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
340098fc:	68fb      	ldr	r3, [r7, #12]
340098fe:	681b      	ldr	r3, [r3, #0]
34009900:	683a      	ldr	r2, [r7, #0]
34009902:	f8c3 25c4 	str.w	r2, [r3, #1476]	@ 0x5c4
34009906:	e036      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
    }
    else
    {
      if ((hdcmipp->Instance->P0PPCR & DCMIPP_P0PPCR_DBM) == DCMIPP_P0PPCR_DBM)
34009908:	68fb      	ldr	r3, [r7, #12]
3400990a:	681b      	ldr	r3, [r3, #0]
3400990c:	f8d3 35c0 	ldr.w	r3, [r3, #1472]	@ 0x5c0
34009910:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34009914:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009918:	d105      	bne.n	34009926 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x4e>
      {
        /* Set Memory1 destination addresses for pipe0 */
        WRITE_REG(hdcmipp->Instance->P0PPM0AR2, DstAddress);
3400991a:	68fb      	ldr	r3, [r7, #12]
3400991c:	681b      	ldr	r3, [r3, #0]
3400991e:	683a      	ldr	r2, [r7, #0]
34009920:	f8c3 25c8 	str.w	r2, [r3, #1480]	@ 0x5c8
34009924:	e027      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
      }
      else
      {
        return HAL_ERROR;
34009926:	2301      	movs	r3, #1
34009928:	e026      	b.n	34009978 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xa0>
      }
    }
  }
  else if (Pipe == DCMIPP_PIPE1)
3400992a:	68bb      	ldr	r3, [r7, #8]
3400992c:	2b01      	cmp	r3, #1
3400992e:	d10e      	bne.n	3400994e <HAL_DCMIPP_PIPE_SetMemoryAddress+0x76>
  {
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
34009930:	687b      	ldr	r3, [r7, #4]
34009932:	2b00      	cmp	r3, #0
34009934:	d105      	bne.n	34009942 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x6a>
    {
      /* Set Memory0 destination addresses for pipe1 */
      WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
34009936:	68fb      	ldr	r3, [r7, #12]
34009938:	681b      	ldr	r3, [r3, #0]
3400993a:	683a      	ldr	r2, [r7, #0]
3400993c:	f8c3 29c4 	str.w	r2, [r3, #2500]	@ 0x9c4
34009940:	e019      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
    }
    else
    {
      /* Set Memory1 destination addresses for pipe1 */
      WRITE_REG(hdcmipp->Instance->P1PPM0AR2, DstAddress);
34009942:	68fb      	ldr	r3, [r7, #12]
34009944:	681b      	ldr	r3, [r3, #0]
34009946:	683a      	ldr	r2, [r7, #0]
34009948:	f8c3 29c8 	str.w	r2, [r3, #2504]	@ 0x9c8
3400994c:	e013      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
    }
  }
  else if (Pipe == DCMIPP_PIPE2)
3400994e:	68bb      	ldr	r3, [r7, #8]
34009950:	2b02      	cmp	r3, #2
34009952:	d10e      	bne.n	34009972 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9a>
  {
    if (Memory == DCMIPP_MEMORY_ADDRESS_0)
34009954:	687b      	ldr	r3, [r7, #4]
34009956:	2b00      	cmp	r3, #0
34009958:	d105      	bne.n	34009966 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x8e>
    {
      /* Set Memory0 destination addresses for pipe2 */
      WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
3400995a:	68fb      	ldr	r3, [r7, #12]
3400995c:	681b      	ldr	r3, [r3, #0]
3400995e:	683a      	ldr	r2, [r7, #0]
34009960:	f8c3 2dc4 	str.w	r2, [r3, #3524]	@ 0xdc4
34009964:	e007      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
    }
    else
    {
      /* Set Memory1 destination addresses for pipe2 */
      WRITE_REG(hdcmipp->Instance->P2PPM0AR2, DstAddress);
34009966:	68fb      	ldr	r3, [r7, #12]
34009968:	681b      	ldr	r3, [r3, #0]
3400996a:	683a      	ldr	r2, [r7, #0]
3400996c:	f8c3 2dc8 	str.w	r2, [r3, #3528]	@ 0xdc8
34009970:	e001      	b.n	34009976 <HAL_DCMIPP_PIPE_SetMemoryAddress+0x9e>
    }
  }
  else
  {
    return HAL_ERROR;
34009972:	2301      	movs	r3, #1
34009974:	e000      	b.n	34009978 <HAL_DCMIPP_PIPE_SetMemoryAddress+0xa0>
  }

  return HAL_OK;
34009976:	2300      	movs	r3, #0

}
34009978:	4618      	mov	r0, r3
3400997a:	3714      	adds	r7, #20
3400997c:	46bd      	mov	sp, r7
3400997e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009982:	4770      	bx	lr

34009984 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_EnableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009984:	b480      	push	{r7}
34009986:	b083      	sub	sp, #12
34009988:	af00      	add	r7, sp, #0
3400998a:	6078      	str	r0, [r7, #4]
3400998c:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
3400998e:	687b      	ldr	r3, [r7, #4]
34009990:	2b00      	cmp	r3, #0
34009992:	d101      	bne.n	34009998 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
34009994:	2301      	movs	r3, #1
34009996:	e023      	b.n	340099e0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34009998:	687b      	ldr	r3, [r7, #4]
3400999a:	791b      	ldrb	r3, [r3, #4]
3400999c:	b2db      	uxtb	r3, r3
3400999e:	2b02      	cmp	r3, #2
340099a0:	d11d      	bne.n	340099de <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
340099a2:	683b      	ldr	r3, [r7, #0]
340099a4:	2b01      	cmp	r3, #1
340099a6:	d10a      	bne.n	340099be <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x3a>
    {
      SET_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
340099a8:	687b      	ldr	r3, [r7, #4]
340099aa:	681b      	ldr	r3, [r3, #0]
340099ac:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
340099b0:	687b      	ldr	r3, [r7, #4]
340099b2:	681b      	ldr	r3, [r3, #0]
340099b4:	f042 0210 	orr.w	r2, r2, #16
340099b8:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
340099bc:	e00f      	b.n	340099de <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
340099be:	683b      	ldr	r3, [r7, #0]
340099c0:	2b02      	cmp	r3, #2
340099c2:	d10a      	bne.n	340099da <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x56>
    {
      SET_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
340099c4:	687b      	ldr	r3, [r7, #4]
340099c6:	681b      	ldr	r3, [r3, #0]
340099c8:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
340099cc:	687b      	ldr	r3, [r7, #4]
340099ce:	681b      	ldr	r3, [r3, #0]
340099d0:	f042 0210 	orr.w	r2, r2, #16
340099d4:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
340099d8:	e001      	b.n	340099de <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
340099da:	2301      	movs	r3, #1
340099dc:	e000      	b.n	340099e0 <HAL_DCMIPP_PIPE_EnableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
340099de:	2300      	movs	r3, #0
}
340099e0:	4618      	mov	r0, r3
340099e2:	370c      	adds	r7, #12
340099e4:	46bd      	mov	sp, r7
340099e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340099ea:	4770      	bx	lr

340099ec <HAL_DCMIPP_PIPE_DisableRedBlueSwap>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_DisableRedBlueSwap(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
340099ec:	b480      	push	{r7}
340099ee:	b083      	sub	sp, #12
340099f0:	af00      	add	r7, sp, #0
340099f2:	6078      	str	r0, [r7, #4]
340099f4:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (hdcmipp == NULL)
340099f6:	687b      	ldr	r3, [r7, #4]
340099f8:	2b00      	cmp	r3, #0
340099fa:	d101      	bne.n	34009a00 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x14>
  {
    return HAL_ERROR;
340099fc:	2301      	movs	r3, #1
340099fe:	e023      	b.n	34009a48 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
  }

  /* Verify DCMIPP State */
  if (hdcmipp->State == HAL_DCMIPP_STATE_READY)
34009a00:	687b      	ldr	r3, [r7, #4]
34009a02:	791b      	ldrb	r3, [r3, #4]
34009a04:	b2db      	uxtb	r3, r3
34009a06:	2b02      	cmp	r3, #2
34009a08:	d11d      	bne.n	34009a46 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
  {
    if (Pipe == DCMIPP_PIPE1)
34009a0a:	683b      	ldr	r3, [r7, #0]
34009a0c:	2b01      	cmp	r3, #1
34009a0e:	d10a      	bne.n	34009a26 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x3a>
    {
      CLEAR_BIT(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_SWAPRB);
34009a10:	687b      	ldr	r3, [r7, #4]
34009a12:	681b      	ldr	r3, [r3, #0]
34009a14:	f8d3 29c0 	ldr.w	r2, [r3, #2496]	@ 0x9c0
34009a18:	687b      	ldr	r3, [r7, #4]
34009a1a:	681b      	ldr	r3, [r3, #0]
34009a1c:	f022 0210 	bic.w	r2, r2, #16
34009a20:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
34009a24:	e00f      	b.n	34009a46 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else if (Pipe == DCMIPP_PIPE2)
34009a26:	683b      	ldr	r3, [r7, #0]
34009a28:	2b02      	cmp	r3, #2
34009a2a:	d10a      	bne.n	34009a42 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x56>
    {
      CLEAR_BIT(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_SWAPRB);
34009a2c:	687b      	ldr	r3, [r7, #4]
34009a2e:	681b      	ldr	r3, [r3, #0]
34009a30:	f8d3 2dc0 	ldr.w	r2, [r3, #3520]	@ 0xdc0
34009a34:	687b      	ldr	r3, [r7, #4]
34009a36:	681b      	ldr	r3, [r3, #0]
34009a38:	f022 0210 	bic.w	r2, r2, #16
34009a3c:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
34009a40:	e001      	b.n	34009a46 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5a>
    }
    else
    {
      return HAL_ERROR;
34009a42:	2301      	movs	r3, #1
34009a44:	e000      	b.n	34009a48 <HAL_DCMIPP_PIPE_DisableRedBlueSwap+0x5c>
    }
  }

  return HAL_OK;
34009a46:	2300      	movs	r3, #0
}
34009a48:	4618      	mov	r0, r3
34009a4a:	370c      	adds	r7, #12
34009a4c:	46bd      	mov	sp, r7
34009a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009a52:	4770      	bx	lr

34009a54 <HAL_DCMIPP_PIPE_CSI_EnableShare>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_CSI_EnableShare(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009a54:	b480      	push	{r7}
34009a56:	b085      	sub	sp, #20
34009a58:	af00      	add	r7, sp, #0
34009a5a:	6078      	str	r0, [r7, #4]
34009a5c:	6039      	str	r1, [r7, #0]
  assert_param(IS_DCMIPP_PIPE(Pipe));
  uint32_t tmp1;
  uint32_t tmp2;

  if (Pipe == DCMIPP_PIPE2)
34009a5e:	683b      	ldr	r3, [r7, #0]
34009a60:	2b02      	cmp	r3, #2
34009a62:	d11d      	bne.n	34009aa0 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4c>
  {
    /* check that Pipe1 and pipe2 are disabled */
    tmp1 = hdcmipp->Instance->P2FSCR;
34009a64:	687b      	ldr	r3, [r7, #4]
34009a66:	681b      	ldr	r3, [r3, #0]
34009a68:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
34009a6c:	60fb      	str	r3, [r7, #12]
    tmp2 = hdcmipp->Instance->P1FSCR;
34009a6e:	687b      	ldr	r3, [r7, #4]
34009a70:	681b      	ldr	r3, [r3, #0]
34009a72:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
34009a76:	60bb      	str	r3, [r7, #8]
    if (((tmp1 & DCMIPP_P2FSCR_PIPEN) == DCMIPP_P2FSCR_PIPEN) || ((tmp2 & DCMIPP_P1FSCR_PIPEN) == DCMIPP_P1FSCR_PIPEN))
34009a78:	68fb      	ldr	r3, [r7, #12]
34009a7a:	2b00      	cmp	r3, #0
34009a7c:	db02      	blt.n	34009a84 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x30>
34009a7e:	68bb      	ldr	r3, [r7, #8]
34009a80:	2b00      	cmp	r3, #0
34009a82:	da01      	bge.n	34009a88 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x34>
    {
      return HAL_ERROR;
34009a84:	2301      	movs	r3, #1
34009a86:	e00c      	b.n	34009aa2 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    }
    else
    {
      /* Pipe2 receives the same data as Pipe1 */
      CLEAR_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEDIFF);
34009a88:	687b      	ldr	r3, [r7, #4]
34009a8a:	681b      	ldr	r3, [r3, #0]
34009a8c:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
34009a90:	687b      	ldr	r3, [r7, #4]
34009a92:	681b      	ldr	r3, [r3, #0]
34009a94:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
34009a98:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
34009a9c:	2300      	movs	r3, #0
34009a9e:	e000      	b.n	34009aa2 <HAL_DCMIPP_PIPE_CSI_EnableShare+0x4e>
    return HAL_ERROR;
34009aa0:	2301      	movs	r3, #1
}
34009aa2:	4618      	mov	r0, r3
34009aa4:	3714      	adds	r7, #20
34009aa6:	46bd      	mov	sp, r7
34009aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
34009aac:	4770      	bx	lr

34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>:
  * @param  pCounter pointer to receive the accumulated value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                                     uint8_t ModuleID, uint32_t *pCounter)
{
34009aae:	b480      	push	{r7}
34009ab0:	b085      	sub	sp, #20
34009ab2:	af00      	add	r7, sp, #0
34009ab4:	60f8      	str	r0, [r7, #12]
34009ab6:	60b9      	str	r1, [r7, #8]
34009ab8:	603b      	str	r3, [r7, #0]
34009aba:	4613      	mov	r3, r2
34009abc:	71fb      	strb	r3, [r7, #7]

  /* Check handle validity */
  if ((hdcmipp == NULL) || (pCounter == NULL))
34009abe:	68fb      	ldr	r3, [r7, #12]
34009ac0:	2b00      	cmp	r3, #0
34009ac2:	d002      	beq.n	34009aca <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x1c>
34009ac4:	683b      	ldr	r3, [r7, #0]
34009ac6:	2b00      	cmp	r3, #0
34009ac8:	d101      	bne.n	34009ace <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x20>
  {
    return HAL_ERROR;
34009aca:	2301      	movs	r3, #1
34009acc:	e02b      	b.n	34009b26 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));
  assert_param(IS_DCMIPP_STAT_EXTRACTION_MODULE(ModuleID));

  if (Pipe == DCMIPP_PIPE1)
34009ace:	68bb      	ldr	r3, [r7, #8]
34009ad0:	2b01      	cmp	r3, #1
34009ad2:	d124      	bne.n	34009b1e <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x70>
  {
    switch (ModuleID)
34009ad4:	79fb      	ldrb	r3, [r7, #7]
34009ad6:	2b03      	cmp	r3, #3
34009ad8:	d018      	beq.n	34009b0c <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x5e>
34009ada:	2b03      	cmp	r3, #3
34009adc:	dc21      	bgt.n	34009b22 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
34009ade:	2b01      	cmp	r3, #1
34009ae0:	d002      	beq.n	34009ae8 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x3a>
34009ae2:	2b02      	cmp	r3, #2
34009ae4:	d009      	beq.n	34009afa <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x4c>
        break;
      case DCMIPP_STATEXT_MODULE3:
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
        break;
      default:
        break;
34009ae6:	e01c      	b.n	34009b22 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x74>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST1SR & DCMIPP_P1ST1SR_ACCU));
34009ae8:	68fb      	ldr	r3, [r7, #12]
34009aea:	681b      	ldr	r3, [r3, #0]
34009aec:	f8d3 3864 	ldr.w	r3, [r3, #2148]	@ 0x864
34009af0:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34009af4:	683b      	ldr	r3, [r7, #0]
34009af6:	601a      	str	r2, [r3, #0]
        break;
34009af8:	e014      	b.n	34009b24 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST2SR & DCMIPP_P1ST2SR_ACCU));
34009afa:	68fb      	ldr	r3, [r7, #12]
34009afc:	681b      	ldr	r3, [r3, #0]
34009afe:	f8d3 3868 	ldr.w	r3, [r3, #2152]	@ 0x868
34009b02:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34009b06:	683b      	ldr	r3, [r7, #0]
34009b08:	601a      	str	r2, [r3, #0]
        break;
34009b0a:	e00b      	b.n	34009b24 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
        *pCounter = (READ_REG(hdcmipp->Instance->P1ST3SR & DCMIPP_P1ST3SR_ACCU));
34009b0c:	68fb      	ldr	r3, [r7, #12]
34009b0e:	681b      	ldr	r3, [r3, #0]
34009b10:	f8d3 386c 	ldr.w	r3, [r3, #2156]	@ 0x86c
34009b14:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
34009b18:	683b      	ldr	r3, [r7, #0]
34009b1a:	601a      	str	r2, [r3, #0]
        break;
34009b1c:	e002      	b.n	34009b24 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x76>
    }
  }
  else
  {
    return HAL_ERROR;
34009b1e:	2301      	movs	r3, #1
34009b20:	e001      	b.n	34009b26 <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter+0x78>
        break;
34009b22:	bf00      	nop
  }

  return HAL_OK;
34009b24:	2300      	movs	r3, #0
}
34009b26:	4618      	mov	r0, r3
34009b28:	3714      	adds	r7, #20
34009b2a:	46bd      	mov	sp, r7
34009b2c:	f85d 7b04 	ldr.w	r7, [sp], #4
34009b30:	4770      	bx	lr

34009b32 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>:
  *                                 filled with the color conversion configuration of the specified pipe.
  * @retval None
  */
void HAL_DCMIPP_PIPE_GetISPColorConversionConfig(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe,
                                                 DCMIPP_ColorConversionConfTypeDef *pColorConversionConfig)
{
34009b32:	b480      	push	{r7}
34009b34:	b087      	sub	sp, #28
34009b36:	af00      	add	r7, sp, #0
34009b38:	60f8      	str	r0, [r7, #12]
34009b3a:	60b9      	str	r1, [r7, #8]
34009b3c:	607a      	str	r2, [r7, #4]
  uint16_t tmp;

  /* Check parameters */
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009b3e:	68bb      	ldr	r3, [r7, #8]
34009b40:	2b01      	cmp	r3, #1
34009b42:	f040 8146 	bne.w	34009dd2 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x2a0>
  {
    tmp = (uint16_t)READ_REG(hdcmipp->Instance->P1CCCR);
34009b46:	68fb      	ldr	r3, [r7, #12]
34009b48:	681b      	ldr	r3, [r3, #0]
34009b4a:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
34009b4e:	82fb      	strh	r3, [r7, #22]

    UNUSED(tmp);

    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
                                                 ? ENABLE : DISABLE;
34009b50:	8afb      	ldrh	r3, [r7, #22]
34009b52:	089b      	lsrs	r3, r3, #2
34009b54:	b2db      	uxtb	r3, r3
34009b56:	f003 0301 	and.w	r3, r3, #1
34009b5a:	b2da      	uxtb	r2, r3
    pColorConversionConfig->ClampOutputSamples = (((tmp & DCMIPP_P1CCCR_CLAMP) >> DCMIPP_P1YUVCR_CLAMP_Pos) != 0U)
34009b5c:	687b      	ldr	r3, [r7, #4]
34009b5e:	701a      	strb	r2, [r3, #0]
    pColorConversionConfig->OutputSamplesType  = (uint8_t)(tmp & DCMIPP_P1CCCR_TYPE);
34009b60:	8afb      	ldrh	r3, [r7, #22]
34009b62:	b2db      	uxtb	r3, r3
34009b64:	f003 0302 	and.w	r3, r3, #2
34009b68:	b2da      	uxtb	r2, r3
34009b6a:	687b      	ldr	r3, [r7, #4]
34009b6c:	705a      	strb	r2, [r3, #1]

    /* Get Coefficient row 1 columns 1 2 3 and the added column of the matrix */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RG) >> DCMIPP_P1CCRR1_RG_Pos);
34009b6e:	68fb      	ldr	r3, [r7, #12]
34009b70:	681b      	ldr	r3, [r3, #0]
34009b72:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
34009b76:	0c1b      	lsrs	r3, r3, #16
34009b78:	b29b      	uxth	r3, r3
34009b7a:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009b7e:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RG = (int16_t)GET_MATRIX_VALUE11(tmp);
34009b80:	8afb      	ldrh	r3, [r7, #22]
34009b82:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009b86:	2b00      	cmp	r3, #0
34009b88:	d007      	beq.n	34009b9a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x68>
34009b8a:	8afb      	ldrh	r3, [r7, #22]
34009b8c:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009b90:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009b94:	b29b      	uxth	r3, r3
34009b96:	b21b      	sxth	r3, r3
34009b98:	e001      	b.n	34009b9e <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x6c>
34009b9a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009b9e:	687a      	ldr	r2, [r7, #4]
34009ba0:	8093      	strh	r3, [r2, #4]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR1, DCMIPP_P1CCRR1_RR) >> DCMIPP_P1CCRR1_RR_Pos);
34009ba2:	68fb      	ldr	r3, [r7, #12]
34009ba4:	681b      	ldr	r3, [r3, #0]
34009ba6:	f8d3 3884 	ldr.w	r3, [r3, #2180]	@ 0x884
34009baa:	b29b      	uxth	r3, r3
34009bac:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009bb0:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RR = (int16_t)GET_MATRIX_VALUE11(tmp);
34009bb2:	8afb      	ldrh	r3, [r7, #22]
34009bb4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009bb8:	2b00      	cmp	r3, #0
34009bba:	d007      	beq.n	34009bcc <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9a>
34009bbc:	8afb      	ldrh	r3, [r7, #22]
34009bbe:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009bc2:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009bc6:	b29b      	uxth	r3, r3
34009bc8:	b21b      	sxth	r3, r3
34009bca:	e001      	b.n	34009bd0 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x9e>
34009bcc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009bd0:	687a      	ldr	r2, [r7, #4]
34009bd2:	8053      	strh	r3, [r2, #2]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RA) >> DCMIPP_P1CCRR2_RA_Pos);
34009bd4:	68fb      	ldr	r3, [r7, #12]
34009bd6:	681b      	ldr	r3, [r3, #0]
34009bd8:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
34009bdc:	0c1b      	lsrs	r3, r3, #16
34009bde:	b29b      	uxth	r3, r3
34009be0:	f3c3 0309 	ubfx	r3, r3, #0, #10
34009be4:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RA = (int16_t)GET_MATRIX_VALUE10(tmp);
34009be6:	8afb      	ldrh	r3, [r7, #22]
34009be8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34009bec:	2b00      	cmp	r3, #0
34009bee:	d007      	beq.n	34009c00 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xce>
34009bf0:	8afb      	ldrh	r3, [r7, #22]
34009bf2:	ea6f 5383 	mvn.w	r3, r3, lsl #22
34009bf6:	ea6f 5393 	mvn.w	r3, r3, lsr #22
34009bfa:	b29b      	uxth	r3, r3
34009bfc:	b21b      	sxth	r3, r3
34009bfe:	e001      	b.n	34009c04 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0xd2>
34009c00:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009c04:	687a      	ldr	r2, [r7, #4]
34009c06:	8113      	strh	r3, [r2, #8]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCRR2, DCMIPP_P1CCRR2_RB) >> DCMIPP_P1CCRR2_RB_Pos);
34009c08:	68fb      	ldr	r3, [r7, #12]
34009c0a:	681b      	ldr	r3, [r3, #0]
34009c0c:	f8d3 3888 	ldr.w	r3, [r3, #2184]	@ 0x888
34009c10:	b29b      	uxth	r3, r3
34009c12:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009c16:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->RB = (int16_t)GET_MATRIX_VALUE11(tmp);
34009c18:	8afb      	ldrh	r3, [r7, #22]
34009c1a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009c1e:	2b00      	cmp	r3, #0
34009c20:	d007      	beq.n	34009c32 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x100>
34009c22:	8afb      	ldrh	r3, [r7, #22]
34009c24:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009c28:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009c2c:	b29b      	uxth	r3, r3
34009c2e:	b21b      	sxth	r3, r3
34009c30:	e001      	b.n	34009c36 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x104>
34009c32:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009c36:	687a      	ldr	r2, [r7, #4]
34009c38:	80d3      	strh	r3, [r2, #6]

    /* Get Coefficient row 2 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GG) >> DCMIPP_P1CCGR1_GG_Pos);
34009c3a:	68fb      	ldr	r3, [r7, #12]
34009c3c:	681b      	ldr	r3, [r3, #0]
34009c3e:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
34009c42:	0c1b      	lsrs	r3, r3, #16
34009c44:	b29b      	uxth	r3, r3
34009c46:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009c4a:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GG = (int16_t)GET_MATRIX_VALUE11(tmp);
34009c4c:	8afb      	ldrh	r3, [r7, #22]
34009c4e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009c52:	2b00      	cmp	r3, #0
34009c54:	d007      	beq.n	34009c66 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x134>
34009c56:	8afb      	ldrh	r3, [r7, #22]
34009c58:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009c5c:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009c60:	b29b      	uxth	r3, r3
34009c62:	b21b      	sxth	r3, r3
34009c64:	e001      	b.n	34009c6a <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x138>
34009c66:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009c6a:	687a      	ldr	r2, [r7, #4]
34009c6c:	8193      	strh	r3, [r2, #12]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR1, DCMIPP_P1CCGR1_GR) >> DCMIPP_P1CCGR1_GR_Pos);
34009c6e:	68fb      	ldr	r3, [r7, #12]
34009c70:	681b      	ldr	r3, [r3, #0]
34009c72:	f8d3 388c 	ldr.w	r3, [r3, #2188]	@ 0x88c
34009c76:	b29b      	uxth	r3, r3
34009c78:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009c7c:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GR = (int16_t)GET_MATRIX_VALUE11(tmp);
34009c7e:	8afb      	ldrh	r3, [r7, #22]
34009c80:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009c84:	2b00      	cmp	r3, #0
34009c86:	d007      	beq.n	34009c98 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x166>
34009c88:	8afb      	ldrh	r3, [r7, #22]
34009c8a:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009c8e:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009c92:	b29b      	uxth	r3, r3
34009c94:	b21b      	sxth	r3, r3
34009c96:	e001      	b.n	34009c9c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x16a>
34009c98:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009c9c:	687a      	ldr	r2, [r7, #4]
34009c9e:	8153      	strh	r3, [r2, #10]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GA) >> DCMIPP_P1CCGR2_GA_Pos);
34009ca0:	68fb      	ldr	r3, [r7, #12]
34009ca2:	681b      	ldr	r3, [r3, #0]
34009ca4:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
34009ca8:	0c1b      	lsrs	r3, r3, #16
34009caa:	b29b      	uxth	r3, r3
34009cac:	f3c3 0309 	ubfx	r3, r3, #0, #10
34009cb0:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GA = (int16_t)GET_MATRIX_VALUE10(tmp);
34009cb2:	8afb      	ldrh	r3, [r7, #22]
34009cb4:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34009cb8:	2b00      	cmp	r3, #0
34009cba:	d007      	beq.n	34009ccc <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19a>
34009cbc:	8afb      	ldrh	r3, [r7, #22]
34009cbe:	ea6f 5383 	mvn.w	r3, r3, lsl #22
34009cc2:	ea6f 5393 	mvn.w	r3, r3, lsr #22
34009cc6:	b29b      	uxth	r3, r3
34009cc8:	b21b      	sxth	r3, r3
34009cca:	e001      	b.n	34009cd0 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x19e>
34009ccc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009cd0:	687a      	ldr	r2, [r7, #4]
34009cd2:	8213      	strh	r3, [r2, #16]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCGR2, DCMIPP_P1CCGR2_GB) >> DCMIPP_P1CCGR2_GB_Pos);
34009cd4:	68fb      	ldr	r3, [r7, #12]
34009cd6:	681b      	ldr	r3, [r3, #0]
34009cd8:	f8d3 3890 	ldr.w	r3, [r3, #2192]	@ 0x890
34009cdc:	b29b      	uxth	r3, r3
34009cde:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009ce2:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->GB = (int16_t)GET_MATRIX_VALUE11(tmp);
34009ce4:	8afb      	ldrh	r3, [r7, #22]
34009ce6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009cea:	2b00      	cmp	r3, #0
34009cec:	d007      	beq.n	34009cfe <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1cc>
34009cee:	8afb      	ldrh	r3, [r7, #22]
34009cf0:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009cf4:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009cf8:	b29b      	uxth	r3, r3
34009cfa:	b21b      	sxth	r3, r3
34009cfc:	e001      	b.n	34009d02 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x1d0>
34009cfe:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009d02:	687a      	ldr	r2, [r7, #4]
34009d04:	81d3      	strh	r3, [r2, #14]

    /* Get Coefficient row 3 columns 1 2 3 and the added column of the matrix  */
    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BA) >> DCMIPP_P1CCBR2_BA_Pos);
34009d06:	68fb      	ldr	r3, [r7, #12]
34009d08:	681b      	ldr	r3, [r3, #0]
34009d0a:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
34009d0e:	0c1b      	lsrs	r3, r3, #16
34009d10:	b29b      	uxth	r3, r3
34009d12:	f3c3 0309 	ubfx	r3, r3, #0, #10
34009d16:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BA = (int16_t)GET_MATRIX_VALUE10(tmp);
34009d18:	8afb      	ldrh	r3, [r7, #22]
34009d1a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34009d1e:	2b00      	cmp	r3, #0
34009d20:	d007      	beq.n	34009d32 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x200>
34009d22:	8afb      	ldrh	r3, [r7, #22]
34009d24:	ea6f 5383 	mvn.w	r3, r3, lsl #22
34009d28:	ea6f 5393 	mvn.w	r3, r3, lsr #22
34009d2c:	b29b      	uxth	r3, r3
34009d2e:	b21b      	sxth	r3, r3
34009d30:	e001      	b.n	34009d36 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x204>
34009d32:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009d36:	687a      	ldr	r2, [r7, #4]
34009d38:	8313      	strh	r3, [r2, #24]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR2, DCMIPP_P1CCBR2_BB) >> DCMIPP_P1CCBR2_BB_Pos);
34009d3a:	68fb      	ldr	r3, [r7, #12]
34009d3c:	681b      	ldr	r3, [r3, #0]
34009d3e:	f8d3 3898 	ldr.w	r3, [r3, #2200]	@ 0x898
34009d42:	b29b      	uxth	r3, r3
34009d44:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009d48:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BB = (int16_t)GET_MATRIX_VALUE11(tmp);
34009d4a:	8afb      	ldrh	r3, [r7, #22]
34009d4c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009d50:	2b00      	cmp	r3, #0
34009d52:	d007      	beq.n	34009d64 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x232>
34009d54:	8afb      	ldrh	r3, [r7, #22]
34009d56:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009d5a:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009d5e:	b29b      	uxth	r3, r3
34009d60:	b21b      	sxth	r3, r3
34009d62:	e001      	b.n	34009d68 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x236>
34009d64:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009d68:	687a      	ldr	r2, [r7, #4]
34009d6a:	82d3      	strh	r3, [r2, #22]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BG) >> DCMIPP_P1CCBR1_BG_Pos);
34009d6c:	68fb      	ldr	r3, [r7, #12]
34009d6e:	681b      	ldr	r3, [r3, #0]
34009d70:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
34009d74:	0c1b      	lsrs	r3, r3, #16
34009d76:	b29b      	uxth	r3, r3
34009d78:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009d7c:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BG = (int16_t)GET_MATRIX_VALUE11(tmp);
34009d7e:	8afb      	ldrh	r3, [r7, #22]
34009d80:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009d84:	2b00      	cmp	r3, #0
34009d86:	d007      	beq.n	34009d98 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x266>
34009d88:	8afb      	ldrh	r3, [r7, #22]
34009d8a:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009d8e:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009d92:	b29b      	uxth	r3, r3
34009d94:	b21b      	sxth	r3, r3
34009d96:	e001      	b.n	34009d9c <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x26a>
34009d98:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009d9c:	687a      	ldr	r2, [r7, #4]
34009d9e:	8293      	strh	r3, [r2, #20]

    tmp = (uint16_t)(READ_FIELD(hdcmipp->Instance->P1CCBR1, DCMIPP_P1CCBR1_BR) >> DCMIPP_P1CCBR1_BR_Pos);
34009da0:	68fb      	ldr	r3, [r7, #12]
34009da2:	681b      	ldr	r3, [r3, #0]
34009da4:	f8d3 3894 	ldr.w	r3, [r3, #2196]	@ 0x894
34009da8:	b29b      	uxth	r3, r3
34009daa:	f3c3 030a 	ubfx	r3, r3, #0, #11
34009dae:	82fb      	strh	r3, [r7, #22]
    pColorConversionConfig->BR = (int16_t)GET_MATRIX_VALUE11(tmp);
34009db0:	8afb      	ldrh	r3, [r7, #22]
34009db2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
34009db6:	2b00      	cmp	r3, #0
34009db8:	d007      	beq.n	34009dca <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x298>
34009dba:	8afb      	ldrh	r3, [r7, #22]
34009dbc:	ea6f 5343 	mvn.w	r3, r3, lsl #21
34009dc0:	ea6f 5353 	mvn.w	r3, r3, lsr #21
34009dc4:	b29b      	uxth	r3, r3
34009dc6:	b21b      	sxth	r3, r3
34009dc8:	e001      	b.n	34009dce <HAL_DCMIPP_PIPE_GetISPColorConversionConfig+0x29c>
34009dca:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
34009dce:	687a      	ldr	r2, [r7, #4]
34009dd0:	8253      	strh	r3, [r2, #18]
  }
}
34009dd2:	bf00      	nop
34009dd4:	371c      	adds	r7, #28
34009dd6:	46bd      	mov	sp, r7
34009dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
34009ddc:	4770      	bx	lr

34009dde <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>:
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @param  Pipe     Pipe to be checked
  * @retval State of bit (1 or 0).
  */
uint32_t HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(const DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
34009dde:	b480      	push	{r7}
34009de0:	b083      	sub	sp, #12
34009de2:	af00      	add	r7, sp, #0
34009de4:	6078      	str	r0, [r7, #4]
34009de6:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_DCMIPP_ALL_INSTANCE(hdcmipp->Instance));
  assert_param(IS_DCMIPP_PIPE(Pipe));

  if (Pipe == DCMIPP_PIPE1)
34009de8:	683b      	ldr	r3, [r7, #0]
34009dea:	2b01      	cmp	r3, #1
34009dec:	d10b      	bne.n	34009e06 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x28>
  {
    return ((READ_BIT(hdcmipp->Instance->P1CCCR, DCMIPP_P1CCCR_ENABLE) == DCMIPP_P1CCCR_ENABLE) ? 1U : 0U);
34009dee:	687b      	ldr	r3, [r7, #4]
34009df0:	681b      	ldr	r3, [r3, #0]
34009df2:	f8d3 3880 	ldr.w	r3, [r3, #2176]	@ 0x880
34009df6:	f003 0301 	and.w	r3, r3, #1
34009dfa:	2b01      	cmp	r3, #1
34009dfc:	d101      	bne.n	34009e02 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x24>
34009dfe:	2301      	movs	r3, #1
34009e00:	e002      	b.n	34009e08 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
34009e02:	2300      	movs	r3, #0
34009e04:	e000      	b.n	34009e08 <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion+0x2a>
  }
  else
  {
    /* State Disabled */
    return 0;
34009e06:	2300      	movs	r3, #0
  }
}
34009e08:	4618      	mov	r0, r3
34009e0a:	370c      	adds	r7, #12
34009e0c:	46bd      	mov	sp, r7
34009e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
34009e12:	4770      	bx	lr

34009e14 <HAL_DCMIPP_GetState>:
  * @brief  Return the DCMIPP state
  * @param  hdcmipp  Pointer to DCMIPP handle
  * @retval HAL state
  */
HAL_DCMIPP_StateTypeDef HAL_DCMIPP_GetState(const DCMIPP_HandleTypeDef *hdcmipp)
{
34009e14:	b480      	push	{r7}
34009e16:	b083      	sub	sp, #12
34009e18:	af00      	add	r7, sp, #0
34009e1a:	6078      	str	r0, [r7, #4]
  return hdcmipp->State;
34009e1c:	687b      	ldr	r3, [r7, #4]
34009e1e:	791b      	ldrb	r3, [r3, #4]
34009e20:	b2db      	uxtb	r3, r3
}
34009e22:	4618      	mov	r0, r3
34009e24:	370c      	adds	r7, #12
34009e26:	46bd      	mov	sp, r7
34009e28:	f85d 7b04 	ldr.w	r7, [sp], #4
34009e2c:	4770      	bx	lr

34009e2e <Pipe_Config>:
  * @param  pPipeConfig pointer to the DCMIPP_PipeConfTypeDef structure that contains
  *                     the configuration information for the pipe.
  * @retval None
  */
static void Pipe_Config(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, const DCMIPP_PipeConfTypeDef *pPipeConfig)
{
34009e2e:	b480      	push	{r7}
34009e30:	b085      	sub	sp, #20
34009e32:	af00      	add	r7, sp, #0
34009e34:	60f8      	str	r0, [r7, #12]
34009e36:	60b9      	str	r1, [r7, #8]
34009e38:	607a      	str	r2, [r7, #4]
  if (Pipe == DCMIPP_PIPE0)
34009e3a:	68bb      	ldr	r3, [r7, #8]
34009e3c:	2b00      	cmp	r3, #0
34009e3e:	d10d      	bne.n	34009e5c <Pipe_Config+0x2e>
  {
    /* Configure Pipe0 */
    /* Configure Frame Rate */
    MODIFY_REG(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_FRATE, pPipeConfig->FrameRate);
34009e40:	68fb      	ldr	r3, [r7, #12]
34009e42:	681b      	ldr	r3, [r3, #0]
34009e44:	f8d3 3500 	ldr.w	r3, [r3, #1280]	@ 0x500
34009e48:	f023 0103 	bic.w	r1, r3, #3
34009e4c:	687b      	ldr	r3, [r7, #4]
34009e4e:	681a      	ldr	r2, [r3, #0]
34009e50:	68fb      	ldr	r3, [r7, #12]
34009e52:	681b      	ldr	r3, [r3, #0]
34009e54:	430a      	orrs	r2, r1
34009e56:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Configure Pixel Pipe Pitch */
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
               pPipeConfig->PixelPipePitch << DCMIPP_P2PPM0PR_PITCH_Pos);
  }
}
34009e5a:	e081      	b.n	34009f60 <Pipe_Config+0x132>
  else if (Pipe == DCMIPP_PIPE1)
34009e5c:	68bb      	ldr	r3, [r7, #8]
34009e5e:	2b01      	cmp	r3, #1
34009e60:	d155      	bne.n	34009f0e <Pipe_Config+0xe0>
    MODIFY_REG(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_FRATE, pPipeConfig->FrameRate);
34009e62:	68fb      	ldr	r3, [r7, #12]
34009e64:	681b      	ldr	r3, [r3, #0]
34009e66:	f8d3 3900 	ldr.w	r3, [r3, #2304]	@ 0x900
34009e6a:	f023 0103 	bic.w	r1, r3, #3
34009e6e:	687b      	ldr	r3, [r7, #4]
34009e70:	681a      	ldr	r2, [r3, #0]
34009e72:	68fb      	ldr	r3, [r7, #12]
34009e74:	681b      	ldr	r3, [r3, #0]
34009e76:	430a      	orrs	r2, r1
34009e78:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    MODIFY_REG(hdcmipp->Instance->P1PPCR, DCMIPP_P1PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34009e7c:	68fb      	ldr	r3, [r7, #12]
34009e7e:	681b      	ldr	r3, [r3, #0]
34009e80:	f8d3 39c0 	ldr.w	r3, [r3, #2496]	@ 0x9c0
34009e84:	f023 010f 	bic.w	r1, r3, #15
34009e88:	687b      	ldr	r3, [r7, #4]
34009e8a:	689a      	ldr	r2, [r3, #8]
34009e8c:	68fb      	ldr	r3, [r7, #12]
34009e8e:	681b      	ldr	r3, [r3, #0]
34009e90:	430a      	orrs	r2, r1
34009e92:	f8c3 29c0 	str.w	r2, [r3, #2496]	@ 0x9c0
    MODIFY_REG(hdcmipp->Instance->P1PPM0PR, DCMIPP_P1PPM0PR_PITCH,
34009e96:	68fb      	ldr	r3, [r7, #12]
34009e98:	681b      	ldr	r3, [r3, #0]
34009e9a:	f8d3 39cc 	ldr.w	r3, [r3, #2508]	@ 0x9cc
34009e9e:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34009ea2:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34009ea6:	687a      	ldr	r2, [r7, #4]
34009ea8:	6851      	ldr	r1, [r2, #4]
34009eaa:	68fa      	ldr	r2, [r7, #12]
34009eac:	6812      	ldr	r2, [r2, #0]
34009eae:	430b      	orrs	r3, r1
34009eb0:	f8c2 39cc 	str.w	r3, [r2, #2508]	@ 0x9cc
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34009eb4:	687b      	ldr	r3, [r7, #4]
34009eb6:	689b      	ldr	r3, [r3, #8]
34009eb8:	2b07      	cmp	r3, #7
34009eba:	d003      	beq.n	34009ec4 <Pipe_Config+0x96>
        (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_2))
34009ebc:	687b      	ldr	r3, [r7, #4]
34009ebe:	689b      	ldr	r3, [r3, #8]
    if ((pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV422_2) ||
34009ec0:	2b08      	cmp	r3, #8
34009ec2:	d10f      	bne.n	34009ee4 <Pipe_Config+0xb6>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34009ec4:	68fb      	ldr	r3, [r7, #12]
34009ec6:	681b      	ldr	r3, [r3, #0]
34009ec8:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
34009ecc:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34009ed0:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34009ed4:	687a      	ldr	r2, [r7, #4]
34009ed6:	6851      	ldr	r1, [r2, #4]
34009ed8:	68fa      	ldr	r2, [r7, #12]
34009eda:	6812      	ldr	r2, [r2, #0]
34009edc:	430b      	orrs	r3, r1
34009ede:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
34009ee2:	e03d      	b.n	34009f60 <Pipe_Config+0x132>
    else if (pPipeConfig->PixelPackerFormat == DCMIPP_PIXEL_PACKER_FORMAT_YUV420_3)
34009ee4:	687b      	ldr	r3, [r7, #4]
34009ee6:	689b      	ldr	r3, [r3, #8]
34009ee8:	2b09      	cmp	r3, #9
34009eea:	d139      	bne.n	34009f60 <Pipe_Config+0x132>
      MODIFY_REG(hdcmipp->Instance->P1PPM1PR, DCMIPP_P1PPM1PR_PITCH,
34009eec:	68fb      	ldr	r3, [r7, #12]
34009eee:	681b      	ldr	r3, [r3, #0]
34009ef0:	f8d3 39dc 	ldr.w	r3, [r3, #2524]	@ 0x9dc
34009ef4:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34009ef8:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34009efc:	687a      	ldr	r2, [r7, #4]
34009efe:	6852      	ldr	r2, [r2, #4]
34009f00:	0851      	lsrs	r1, r2, #1
34009f02:	68fa      	ldr	r2, [r7, #12]
34009f04:	6812      	ldr	r2, [r2, #0]
34009f06:	430b      	orrs	r3, r1
34009f08:	f8c2 39dc 	str.w	r3, [r2, #2524]	@ 0x9dc
}
34009f0c:	e028      	b.n	34009f60 <Pipe_Config+0x132>
    MODIFY_REG(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_FRATE, pPipeConfig->FrameRate);
34009f0e:	68fb      	ldr	r3, [r7, #12]
34009f10:	681b      	ldr	r3, [r3, #0]
34009f12:	f8d3 3d00 	ldr.w	r3, [r3, #3328]	@ 0xd00
34009f16:	f023 0103 	bic.w	r1, r3, #3
34009f1a:	687b      	ldr	r3, [r7, #4]
34009f1c:	681a      	ldr	r2, [r3, #0]
34009f1e:	68fb      	ldr	r3, [r7, #12]
34009f20:	681b      	ldr	r3, [r3, #0]
34009f22:	430a      	orrs	r2, r1
34009f24:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    MODIFY_REG(hdcmipp->Instance->P2PPCR, DCMIPP_P2PPCR_FORMAT, pPipeConfig->PixelPackerFormat);
34009f28:	68fb      	ldr	r3, [r7, #12]
34009f2a:	681b      	ldr	r3, [r3, #0]
34009f2c:	f8d3 3dc0 	ldr.w	r3, [r3, #3520]	@ 0xdc0
34009f30:	f023 010f 	bic.w	r1, r3, #15
34009f34:	687b      	ldr	r3, [r7, #4]
34009f36:	689a      	ldr	r2, [r3, #8]
34009f38:	68fb      	ldr	r3, [r7, #12]
34009f3a:	681b      	ldr	r3, [r3, #0]
34009f3c:	430a      	orrs	r2, r1
34009f3e:	f8c3 2dc0 	str.w	r2, [r3, #3520]	@ 0xdc0
    MODIFY_REG(hdcmipp->Instance->P2PPM0PR, DCMIPP_P2PPM0PR_PITCH,
34009f42:	68fb      	ldr	r3, [r7, #12]
34009f44:	681b      	ldr	r3, [r3, #0]
34009f46:	f8d3 3dcc 	ldr.w	r3, [r3, #3532]	@ 0xdcc
34009f4a:	f423 43ff 	bic.w	r3, r3, #32640	@ 0x7f80
34009f4e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
34009f52:	687a      	ldr	r2, [r7, #4]
34009f54:	6851      	ldr	r1, [r2, #4]
34009f56:	68fa      	ldr	r2, [r7, #12]
34009f58:	6812      	ldr	r2, [r2, #0]
34009f5a:	430b      	orrs	r3, r1
34009f5c:	f8c2 3dcc 	str.w	r3, [r2, #3532]	@ 0xdcc
}
34009f60:	bf00      	nop
34009f62:	3714      	adds	r7, #20
34009f64:	46bd      	mov	sp, r7
34009f66:	f85d 7b04 	ldr.w	r7, [sp], #4
34009f6a:	4770      	bx	lr

34009f6c <DCMIPP_CSI_WritePHYReg>:
  * @param  reg_lsb specifies the testcode LSB in testdin
  * @param  val     specifies the page offset in testdin
  * @retval None
  */
static void DCMIPP_CSI_WritePHYReg(CSI_TypeDef *hcsi, uint32_t reg_msb, uint32_t reg_lsb, uint32_t val)
{
34009f6c:	b480      	push	{r7}
34009f6e:	b085      	sub	sp, #20
34009f70:	af00      	add	r7, sp, #0
34009f72:	60f8      	str	r0, [r7, #12]
34009f74:	60b9      	str	r1, [r7, #8]
34009f76:	607a      	str	r2, [r7, #4]
34009f78:	603b      	str	r3, [r7, #0]
  /* Based on sequence described at section 5.2.3.2 of DesignWave document */
  /* For writing the 4-bit testcode MSBs */
  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34009f7a:	68fb      	ldr	r3, [r7, #12]
34009f7c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009f80:	695b      	ldr	r3, [r3, #20]
34009f82:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34009f86:	68fa      	ldr	r2, [r7, #12]
34009f88:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34009f8c:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34009f8e:	68fb      	ldr	r3, [r7, #12]
34009f90:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009f94:	691b      	ldr	r3, [r3, #16]
34009f96:	f043 0301 	orr.w	r3, r3, #1
34009f9a:	68fa      	ldr	r2, [r7, #12]
34009f9c:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34009fa0:	6113      	str	r3, [r2, #16]

  /* Place 0x00 in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
34009fa2:	68fb      	ldr	r3, [r7, #12]
34009fa4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009fa8:	695b      	ldr	r3, [r3, #20]
34009faa:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
34009fae:	68fa      	ldr	r2, [r7, #12]
34009fb0:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34009fb4:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
34009fb6:	68fb      	ldr	r3, [r7, #12]
34009fb8:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009fbc:	461a      	mov	r2, r3
34009fbe:	2300      	movs	r3, #0
34009fc0:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
34009fc2:	68fb      	ldr	r3, [r7, #12]
34009fc4:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009fc8:	461a      	mov	r2, r3
34009fca:	2300      	movs	r3, #0
34009fcc:	6153      	str	r3, [r2, #20]

  /* Place the 8-bit word corresponding to the testcode MSBs in testdin */
  SET_BIT(hcsi->PTCR1, reg_msb & 0xFFU);
34009fce:	68fb      	ldr	r3, [r7, #12]
34009fd0:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009fd4:	695a      	ldr	r2, [r3, #20]
34009fd6:	68bb      	ldr	r3, [r7, #8]
34009fd8:	b2db      	uxtb	r3, r3
34009fda:	4313      	orrs	r3, r2
34009fdc:	68fa      	ldr	r2, [r7, #12]
34009fde:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34009fe2:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
34009fe4:	68fb      	ldr	r3, [r7, #12]
34009fe6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009fea:	691b      	ldr	r3, [r3, #16]
34009fec:	f043 0301 	orr.w	r3, r3, #1
34009ff0:	68fa      	ldr	r2, [r7, #12]
34009ff2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
34009ff6:	6113      	str	r3, [r2, #16]

  /* For writing the 8-bit testcode LSBs */
  /* Set testclk to low */
  CLEAR_REG(hcsi->PTCR0);
34009ff8:	68fb      	ldr	r3, [r7, #12]
34009ffa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34009ffe:	461a      	mov	r2, r3
3400a000:	2300      	movs	r3, #0
3400a002:	6113      	str	r3, [r2, #16]

  /* Set testen to high */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM);
3400a004:	68fb      	ldr	r3, [r7, #12]
3400a006:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a00a:	695b      	ldr	r3, [r3, #20]
3400a00c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400a010:	68fa      	ldr	r2, [r7, #12]
3400a012:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400a016:	6153      	str	r3, [r2, #20]

  /* Set testclk to high */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
3400a018:	68fb      	ldr	r3, [r7, #12]
3400a01a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a01e:	691b      	ldr	r3, [r3, #16]
3400a020:	f043 0301 	orr.w	r3, r3, #1
3400a024:	68fa      	ldr	r2, [r7, #12]
3400a026:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400a02a:	6113      	str	r3, [r2, #16]

  /* Place the 8-bit word test data in testdin */
  SET_BIT(hcsi->PTCR1, CSI_PTCR1_TWM | (reg_lsb & 0xFFU));
3400a02c:	68fb      	ldr	r3, [r7, #12]
3400a02e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a032:	695a      	ldr	r2, [r3, #20]
3400a034:	687b      	ldr	r3, [r7, #4]
3400a036:	b2db      	uxtb	r3, r3
3400a038:	4313      	orrs	r3, r2
3400a03a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400a03e:	68fa      	ldr	r2, [r7, #12]
3400a040:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400a044:	6153      	str	r3, [r2, #20]

  /* Set testclk to low (with the falling edge on testclk, the testdin signal content is latched internally) */
  CLEAR_REG(hcsi->PTCR0);
3400a046:	68fb      	ldr	r3, [r7, #12]
3400a048:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a04c:	461a      	mov	r2, r3
3400a04e:	2300      	movs	r3, #0
3400a050:	6113      	str	r3, [r2, #16]

  /* Set testen to low */
  CLEAR_REG(hcsi->PTCR1);
3400a052:	68fb      	ldr	r3, [r7, #12]
3400a054:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a058:	461a      	mov	r2, r3
3400a05a:	2300      	movs	r3, #0
3400a05c:	6153      	str	r3, [r2, #20]

  /* For writing the data */
  /* Place the 8-bit word corresponding to the page offset in testdin */
  SET_BIT(hcsi->PTCR1, val & 0xFFU);
3400a05e:	68fb      	ldr	r3, [r7, #12]
3400a060:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a064:	695a      	ldr	r2, [r3, #20]
3400a066:	683b      	ldr	r3, [r7, #0]
3400a068:	b2db      	uxtb	r3, r3
3400a06a:	4313      	orrs	r3, r2
3400a06c:	68fa      	ldr	r2, [r7, #12]
3400a06e:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400a072:	6153      	str	r3, [r2, #20]

  /* Set testclk to high (test data is programmed internally */
  SET_BIT(hcsi->PTCR0, CSI_PTCR0_TCKEN);
3400a074:	68fb      	ldr	r3, [r7, #12]
3400a076:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a07a:	691b      	ldr	r3, [r3, #16]
3400a07c:	f043 0301 	orr.w	r3, r3, #1
3400a080:	68fa      	ldr	r2, [r7, #12]
3400a082:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400a086:	6113      	str	r3, [r2, #16]

  /* Finish by setting testclk to low */
  CLEAR_REG(hcsi->PTCR0);
3400a088:	68fb      	ldr	r3, [r7, #12]
3400a08a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400a08e:	461a      	mov	r2, r3
3400a090:	2300      	movs	r3, #0
3400a092:	6113      	str	r3, [r2, #16]
}
3400a094:	bf00      	nop
3400a096:	3714      	adds	r7, #20
3400a098:	46bd      	mov	sp, r7
3400a09a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a09e:	4770      	bx	lr

3400a0a0 <DCMIPP_SetConfig>:
  * @param  DstAddress  Specifies the destination memory address for the captured data.
  * @param  CaptureMode Specifies the capture mode to be set for the pipe.
  * @retval None
  */
static void DCMIPP_SetConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t DstAddress, uint32_t CaptureMode)
{
3400a0a0:	b480      	push	{r7}
3400a0a2:	b085      	sub	sp, #20
3400a0a4:	af00      	add	r7, sp, #0
3400a0a6:	60f8      	str	r0, [r7, #12]
3400a0a8:	60b9      	str	r1, [r7, #8]
3400a0aa:	607a      	str	r2, [r7, #4]
3400a0ac:	603b      	str	r3, [r7, #0]
  if (Pipe == DCMIPP_PIPE0)
3400a0ae:	68bb      	ldr	r3, [r7, #8]
3400a0b0:	2b00      	cmp	r3, #0
3400a0b2:	d121      	bne.n	3400a0f8 <DCMIPP_SetConfig+0x58>
  {
    /* Update the DCMIPP pipe State */
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400a0b4:	68fa      	ldr	r2, [r7, #12]
3400a0b6:	68bb      	ldr	r3, [r7, #8]
3400a0b8:	4413      	add	r3, r2
3400a0ba:	3305      	adds	r3, #5
3400a0bc:	2202      	movs	r2, #2
3400a0be:	701a      	strb	r2, [r3, #0]

    /* Set the capture mode */
    hdcmipp->Instance->P0FCTCR |= CaptureMode;
3400a0c0:	68fb      	ldr	r3, [r7, #12]
3400a0c2:	681b      	ldr	r3, [r3, #0]
3400a0c4:	f8d3 1500 	ldr.w	r1, [r3, #1280]	@ 0x500
3400a0c8:	68fb      	ldr	r3, [r7, #12]
3400a0ca:	681b      	ldr	r3, [r3, #0]
3400a0cc:	683a      	ldr	r2, [r7, #0]
3400a0ce:	430a      	orrs	r2, r1
3400a0d0:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500

    /* Set the destination address */
    WRITE_REG(hdcmipp->Instance->P0PPM0AR1, DstAddress);
3400a0d4:	68fb      	ldr	r3, [r7, #12]
3400a0d6:	681b      	ldr	r3, [r3, #0]
3400a0d8:	687a      	ldr	r2, [r7, #4]
3400a0da:	f8c3 25c4 	str.w	r2, [r3, #1476]	@ 0x5c4

    /* Enable all required interrupts lines for the PIPE0 */
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE0_FRAME | DCMIPP_IT_PIPE0_VSYNC | DCMIPP_IT_PIPE0_OVR |
3400a0de:	68fb      	ldr	r3, [r7, #12]
3400a0e0:	681b      	ldr	r3, [r3, #0]
3400a0e2:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
3400a0e6:	68fa      	ldr	r2, [r7, #12]
3400a0e8:	6812      	ldr	r2, [r2, #0]
3400a0ea:	f443 4306 	orr.w	r3, r3, #34304	@ 0x8600
3400a0ee:	f043 0320 	orr.w	r3, r3, #32
3400a0f2:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0

    /* Enable all required interrupts lines for the PIPE2 */
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
                           DCMIPP_IT_AXI_TRANSFER_ERROR);
  }
}
3400a0f6:	e045      	b.n	3400a184 <DCMIPP_SetConfig+0xe4>
  else if (Pipe == DCMIPP_PIPE1)
3400a0f8:	68bb      	ldr	r3, [r7, #8]
3400a0fa:	2b01      	cmp	r3, #1
3400a0fc:	d121      	bne.n	3400a142 <DCMIPP_SetConfig+0xa2>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400a0fe:	68fa      	ldr	r2, [r7, #12]
3400a100:	68bb      	ldr	r3, [r7, #8]
3400a102:	4413      	add	r3, r2
3400a104:	3305      	adds	r3, #5
3400a106:	2202      	movs	r2, #2
3400a108:	701a      	strb	r2, [r3, #0]
    hdcmipp->Instance->P1FCTCR |= CaptureMode;
3400a10a:	68fb      	ldr	r3, [r7, #12]
3400a10c:	681b      	ldr	r3, [r3, #0]
3400a10e:	f8d3 1900 	ldr.w	r1, [r3, #2304]	@ 0x900
3400a112:	68fb      	ldr	r3, [r7, #12]
3400a114:	681b      	ldr	r3, [r3, #0]
3400a116:	683a      	ldr	r2, [r7, #0]
3400a118:	430a      	orrs	r2, r1
3400a11a:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
    WRITE_REG(hdcmipp->Instance->P1PPM0AR1, DstAddress);
3400a11e:	68fb      	ldr	r3, [r7, #12]
3400a120:	681b      	ldr	r3, [r3, #0]
3400a122:	687a      	ldr	r2, [r7, #4]
3400a124:	f8c3 29c4 	str.w	r2, [r3, #2500]	@ 0x9c4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE1_FRAME  | DCMIPP_IT_PIPE1_OVR | DCMIPP_IT_PIPE1_VSYNC |
3400a128:	68fb      	ldr	r3, [r7, #12]
3400a12a:	681b      	ldr	r3, [r3, #0]
3400a12c:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
3400a130:	68fa      	ldr	r2, [r7, #12]
3400a132:	6812      	ldr	r2, [r2, #0]
3400a134:	f443 0306 	orr.w	r3, r3, #8781824	@ 0x860000
3400a138:	f043 0320 	orr.w	r3, r3, #32
3400a13c:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0
}
3400a140:	e020      	b.n	3400a184 <DCMIPP_SetConfig+0xe4>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400a142:	68fa      	ldr	r2, [r7, #12]
3400a144:	68bb      	ldr	r3, [r7, #8]
3400a146:	4413      	add	r3, r2
3400a148:	3305      	adds	r3, #5
3400a14a:	2202      	movs	r2, #2
3400a14c:	701a      	strb	r2, [r3, #0]
    hdcmipp->Instance->P2FCTCR |= CaptureMode;
3400a14e:	68fb      	ldr	r3, [r7, #12]
3400a150:	681b      	ldr	r3, [r3, #0]
3400a152:	f8d3 1d00 	ldr.w	r1, [r3, #3328]	@ 0xd00
3400a156:	68fb      	ldr	r3, [r7, #12]
3400a158:	681b      	ldr	r3, [r3, #0]
3400a15a:	683a      	ldr	r2, [r7, #0]
3400a15c:	430a      	orrs	r2, r1
3400a15e:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
    WRITE_REG(hdcmipp->Instance->P2PPM0AR1, DstAddress);
3400a162:	68fb      	ldr	r3, [r7, #12]
3400a164:	681b      	ldr	r3, [r3, #0]
3400a166:	687a      	ldr	r2, [r7, #4]
3400a168:	f8c3 2dc4 	str.w	r2, [r3, #3524]	@ 0xdc4
    __HAL_DCMIPP_ENABLE_IT(hdcmipp, DCMIPP_IT_PIPE2_FRAME | DCMIPP_IT_PIPE2_OVR | DCMIPP_IT_PIPE2_VSYNC |
3400a16c:	68fb      	ldr	r3, [r7, #12]
3400a16e:	681b      	ldr	r3, [r3, #0]
3400a170:	f8d3 33f0 	ldr.w	r3, [r3, #1008]	@ 0x3f0
3400a174:	68fa      	ldr	r2, [r7, #12]
3400a176:	6812      	ldr	r2, [r2, #0]
3400a178:	f043 4306 	orr.w	r3, r3, #2248146944	@ 0x86000000
3400a17c:	f043 0320 	orr.w	r3, r3, #32
3400a180:	f8c2 33f0 	str.w	r3, [r2, #1008]	@ 0x3f0
}
3400a184:	bf00      	nop
3400a186:	3714      	adds	r7, #20
3400a188:	46bd      	mov	sp, r7
3400a18a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a18e:	4770      	bx	lr

3400a190 <DCMIPP_EnableCapture>:
  * @param  hdcmipp     Pointer to DCMIPP handle
  * @param  Pipe        Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @retval None
  */
static void DCMIPP_EnableCapture(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3400a190:	b480      	push	{r7}
3400a192:	b083      	sub	sp, #12
3400a194:	af00      	add	r7, sp, #0
3400a196:	6078      	str	r0, [r7, #4]
3400a198:	6039      	str	r1, [r7, #0]
  if (Pipe == DCMIPP_PIPE0)
3400a19a:	683b      	ldr	r3, [r7, #0]
3400a19c:	2b00      	cmp	r3, #0
3400a19e:	d114      	bne.n	3400a1ca <DCMIPP_EnableCapture+0x3a>
  {
    /* Activate the Pipe */
    SET_BIT(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_PIPEN);
3400a1a0:	687b      	ldr	r3, [r7, #4]
3400a1a2:	681b      	ldr	r3, [r3, #0]
3400a1a4:	f8d3 2404 	ldr.w	r2, [r3, #1028]	@ 0x404
3400a1a8:	687b      	ldr	r3, [r7, #4]
3400a1aa:	681b      	ldr	r3, [r3, #0]
3400a1ac:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400a1b0:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404

    /* Start the capture */
    SET_BIT(hdcmipp->Instance->P0FCTCR, DCMIPP_P0FCTCR_CPTREQ);
3400a1b4:	687b      	ldr	r3, [r7, #4]
3400a1b6:	681b      	ldr	r3, [r3, #0]
3400a1b8:	f8d3 2500 	ldr.w	r2, [r3, #1280]	@ 0x500
3400a1bc:	687b      	ldr	r3, [r7, #4]
3400a1be:	681b      	ldr	r3, [r3, #0]
3400a1c0:	f042 0208 	orr.w	r2, r2, #8
3400a1c4:	f8c3 2500 	str.w	r2, [r3, #1280]	@ 0x500
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);

    /* Start the capture */
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
  }
}
3400a1c8:	e031      	b.n	3400a22e <DCMIPP_EnableCapture+0x9e>
  else if (Pipe == DCMIPP_PIPE1)
3400a1ca:	683b      	ldr	r3, [r7, #0]
3400a1cc:	2b01      	cmp	r3, #1
3400a1ce:	d11a      	bne.n	3400a206 <DCMIPP_EnableCapture+0x76>
    hdcmipp->PipeState[Pipe] = HAL_DCMIPP_PIPE_STATE_BUSY;
3400a1d0:	687a      	ldr	r2, [r7, #4]
3400a1d2:	683b      	ldr	r3, [r7, #0]
3400a1d4:	4413      	add	r3, r2
3400a1d6:	3305      	adds	r3, #5
3400a1d8:	2202      	movs	r2, #2
3400a1da:	701a      	strb	r2, [r3, #0]
    SET_BIT(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_PIPEN);
3400a1dc:	687b      	ldr	r3, [r7, #4]
3400a1de:	681b      	ldr	r3, [r3, #0]
3400a1e0:	f8d3 2804 	ldr.w	r2, [r3, #2052]	@ 0x804
3400a1e4:	687b      	ldr	r3, [r7, #4]
3400a1e6:	681b      	ldr	r3, [r3, #0]
3400a1e8:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400a1ec:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
    SET_BIT(hdcmipp->Instance->P1FCTCR, DCMIPP_P1FCTCR_CPTREQ);
3400a1f0:	687b      	ldr	r3, [r7, #4]
3400a1f2:	681b      	ldr	r3, [r3, #0]
3400a1f4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	@ 0x900
3400a1f8:	687b      	ldr	r3, [r7, #4]
3400a1fa:	681b      	ldr	r3, [r3, #0]
3400a1fc:	f042 0208 	orr.w	r2, r2, #8
3400a200:	f8c3 2900 	str.w	r2, [r3, #2304]	@ 0x900
}
3400a204:	e013      	b.n	3400a22e <DCMIPP_EnableCapture+0x9e>
    SET_BIT(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_PIPEN);
3400a206:	687b      	ldr	r3, [r7, #4]
3400a208:	681b      	ldr	r3, [r3, #0]
3400a20a:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	@ 0xc04
3400a20e:	687b      	ldr	r3, [r7, #4]
3400a210:	681b      	ldr	r3, [r3, #0]
3400a212:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
3400a216:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    SET_BIT(hdcmipp->Instance->P2FCTCR, DCMIPP_P2FCTCR_CPTREQ);
3400a21a:	687b      	ldr	r3, [r7, #4]
3400a21c:	681b      	ldr	r3, [r3, #0]
3400a21e:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	@ 0xd00
3400a222:	687b      	ldr	r3, [r7, #4]
3400a224:	681b      	ldr	r3, [r3, #0]
3400a226:	f042 0208 	orr.w	r2, r2, #8
3400a22a:	f8c3 2d00 	str.w	r2, [r3, #3328]	@ 0xd00
}
3400a22e:	bf00      	nop
3400a230:	370c      	adds	r7, #12
3400a232:	46bd      	mov	sp, r7
3400a234:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a238:	4770      	bx	lr
	...

3400a23c <DCMIPP_CSI_SetVCConfig>:
  * @param  hdcmipp         Pointer to DCMIPP handle
  * @param  Pipe            Specifies the DCMIPP pipe, can be a value from @ref DCMIPP_Pipes
  * @param  VirtualChannel  Specifies the virtual channel, can be a value from @ref DCMIPP_Virtual_Channel
  */
static HAL_StatusTypeDef DCMIPP_CSI_SetVCConfig(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe, uint32_t VirtualChannel)
{
3400a23c:	b580      	push	{r7, lr}
3400a23e:	b086      	sub	sp, #24
3400a240:	af00      	add	r7, sp, #0
3400a242:	60f8      	str	r0, [r7, #12]
3400a244:	60b9      	str	r1, [r7, #8]
3400a246:	607a      	str	r2, [r7, #4]
  CSI_TypeDef *csi_instance;
  csi_instance = CSI;
3400a248:	4b48      	ldr	r3, [pc, #288]	@ (3400a36c <DCMIPP_CSI_SetVCConfig+0x130>)
3400a24a:	617b      	str	r3, [r7, #20]
  uint32_t tickstart;

  /* Set Virtual Channel ID for the selected Pipe */
  if (Pipe == DCMIPP_PIPE0)
3400a24c:	68bb      	ldr	r3, [r7, #8]
3400a24e:	2b00      	cmp	r3, #0
3400a250:	d10d      	bne.n	3400a26e <DCMIPP_CSI_SetVCConfig+0x32>
  {
    MODIFY_REG(hdcmipp->Instance->P0FSCR, DCMIPP_P0FSCR_VC, VirtualChannel << DCMIPP_P0FSCR_VC_Pos);
3400a252:	68fb      	ldr	r3, [r7, #12]
3400a254:	681b      	ldr	r3, [r3, #0]
3400a256:	f8d3 3404 	ldr.w	r3, [r3, #1028]	@ 0x404
3400a25a:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
3400a25e:	687b      	ldr	r3, [r7, #4]
3400a260:	04da      	lsls	r2, r3, #19
3400a262:	68fb      	ldr	r3, [r7, #12]
3400a264:	681b      	ldr	r3, [r3, #0]
3400a266:	430a      	orrs	r2, r1
3400a268:	f8c3 2404 	str.w	r2, [r3, #1028]	@ 0x404
3400a26c:	e026      	b.n	3400a2bc <DCMIPP_CSI_SetVCConfig+0x80>
  }
  else if (Pipe == DCMIPP_PIPE1)
3400a26e:	68bb      	ldr	r3, [r7, #8]
3400a270:	2b01      	cmp	r3, #1
3400a272:	d10d      	bne.n	3400a290 <DCMIPP_CSI_SetVCConfig+0x54>
  {
    MODIFY_REG(hdcmipp->Instance->P1FSCR, DCMIPP_P1FSCR_VC, VirtualChannel << DCMIPP_P1FSCR_VC_Pos);
3400a274:	68fb      	ldr	r3, [r7, #12]
3400a276:	681b      	ldr	r3, [r3, #0]
3400a278:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
3400a27c:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
3400a280:	687b      	ldr	r3, [r7, #4]
3400a282:	04da      	lsls	r2, r3, #19
3400a284:	68fb      	ldr	r3, [r7, #12]
3400a286:	681b      	ldr	r3, [r3, #0]
3400a288:	430a      	orrs	r2, r1
3400a28a:	f8c3 2804 	str.w	r2, [r3, #2052]	@ 0x804
3400a28e:	e015      	b.n	3400a2bc <DCMIPP_CSI_SetVCConfig+0x80>
  }
  else
  {
    /* Those bit fields are meaningful when PIPEDIFF = 1: Pipe1, Pipe2 is fully independent */
    if ((hdcmipp->Instance->P1FSCR & DCMIPP_P1FSCR_PIPEDIFF) == DCMIPP_P1FSCR_PIPEDIFF)
3400a290:	68fb      	ldr	r3, [r7, #12]
3400a292:	681b      	ldr	r3, [r3, #0]
3400a294:	f8d3 3804 	ldr.w	r3, [r3, #2052]	@ 0x804
3400a298:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400a29c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400a2a0:	d10c      	bne.n	3400a2bc <DCMIPP_CSI_SetVCConfig+0x80>
    {
      /* Set Virtual Channel ID and DTIDA for Pipe2 */
      MODIFY_REG(hdcmipp->Instance->P2FSCR, DCMIPP_P2FSCR_VC, VirtualChannel << DCMIPP_P2FSCR_VC_Pos);
3400a2a2:	68fb      	ldr	r3, [r7, #12]
3400a2a4:	681b      	ldr	r3, [r3, #0]
3400a2a6:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	@ 0xc04
3400a2aa:	f423 11c0 	bic.w	r1, r3, #1572864	@ 0x180000
3400a2ae:	687b      	ldr	r3, [r7, #4]
3400a2b0:	04da      	lsls	r2, r3, #19
3400a2b2:	68fb      	ldr	r3, [r7, #12]
3400a2b4:	681b      	ldr	r3, [r3, #0]
3400a2b6:	430a      	orrs	r2, r1
3400a2b8:	f8c3 2c04 	str.w	r2, [r3, #3076]	@ 0xc04
    }
  }

  /* Enable the selected virtual channel */
  switch (VirtualChannel)
3400a2bc:	687b      	ldr	r3, [r7, #4]
3400a2be:	2b03      	cmp	r3, #3
3400a2c0:	d017      	beq.n	3400a2f2 <DCMIPP_CSI_SetVCConfig+0xb6>
3400a2c2:	687b      	ldr	r3, [r7, #4]
3400a2c4:	2b03      	cmp	r3, #3
3400a2c6:	d81b      	bhi.n	3400a300 <DCMIPP_CSI_SetVCConfig+0xc4>
3400a2c8:	687b      	ldr	r3, [r7, #4]
3400a2ca:	2b01      	cmp	r3, #1
3400a2cc:	d003      	beq.n	3400a2d6 <DCMIPP_CSI_SetVCConfig+0x9a>
3400a2ce:	687b      	ldr	r3, [r7, #4]
3400a2d0:	2b02      	cmp	r3, #2
3400a2d2:	d007      	beq.n	3400a2e4 <DCMIPP_CSI_SetVCConfig+0xa8>
3400a2d4:	e014      	b.n	3400a300 <DCMIPP_CSI_SetVCConfig+0xc4>
  {
    case DCMIPP_VIRTUAL_CHANNEL1:
      SET_BIT(csi_instance->CR, CSI_CR_VC1START);
3400a2d6:	697b      	ldr	r3, [r7, #20]
3400a2d8:	681b      	ldr	r3, [r3, #0]
3400a2da:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
3400a2de:	697b      	ldr	r3, [r7, #20]
3400a2e0:	601a      	str	r2, [r3, #0]
      break;
3400a2e2:	e014      	b.n	3400a30e <DCMIPP_CSI_SetVCConfig+0xd2>
    case DCMIPP_VIRTUAL_CHANNEL2:
      SET_BIT(csi_instance->CR, CSI_CR_VC2START);
3400a2e4:	697b      	ldr	r3, [r7, #20]
3400a2e6:	681b      	ldr	r3, [r3, #0]
3400a2e8:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
3400a2ec:	697b      	ldr	r3, [r7, #20]
3400a2ee:	601a      	str	r2, [r3, #0]
      break;
3400a2f0:	e00d      	b.n	3400a30e <DCMIPP_CSI_SetVCConfig+0xd2>
    case DCMIPP_VIRTUAL_CHANNEL3:
      SET_BIT(csi_instance->CR, CSI_CR_VC3START);
3400a2f2:	697b      	ldr	r3, [r7, #20]
3400a2f4:	681b      	ldr	r3, [r3, #0]
3400a2f6:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
3400a2fa:	697b      	ldr	r3, [r7, #20]
3400a2fc:	601a      	str	r2, [r3, #0]
      break;
3400a2fe:	e006      	b.n	3400a30e <DCMIPP_CSI_SetVCConfig+0xd2>
    default:
      /* DCMIPP_VIRTUAL_CHANNEL0: */
      SET_BIT(csi_instance->CR, CSI_CR_VC0START);
3400a300:	697b      	ldr	r3, [r7, #20]
3400a302:	681b      	ldr	r3, [r3, #0]
3400a304:	f043 0204 	orr.w	r2, r3, #4
3400a308:	697b      	ldr	r3, [r7, #20]
3400a30a:	601a      	str	r2, [r3, #0]
      break;
3400a30c:	bf00      	nop
  }

  /* wait for the selected virtual channel active state */
  tickstart = HAL_GetTick();
3400a30e:	f7fa fc8e 	bl	34004c2e <HAL_GetTick>
3400a312:	6138      	str	r0, [r7, #16]
  do
  {
    if ((HAL_GetTick() - tickstart) > DCMIPP_TIMEOUT)
3400a314:	f7fa fc8b 	bl	34004c2e <HAL_GetTick>
3400a318:	4602      	mov	r2, r0
3400a31a:	693b      	ldr	r3, [r7, #16]
3400a31c:	1ad3      	subs	r3, r2, r3
3400a31e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
3400a322:	d901      	bls.n	3400a328 <DCMIPP_CSI_SetVCConfig+0xec>
    {
      return HAL_ERROR;
3400a324:	2301      	movs	r3, #1
3400a326:	e01c      	b.n	3400a362 <DCMIPP_CSI_SetVCConfig+0x126>
    }
  } while ((csi_instance->SR0 & (CSI_SR0_VC0STATEF << VirtualChannel)) != (CSI_SR0_VC0STATEF << VirtualChannel));
3400a328:	697b      	ldr	r3, [r7, #20]
3400a32a:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
3400a32e:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
3400a332:	687b      	ldr	r3, [r7, #4]
3400a334:	fa01 f303 	lsl.w	r3, r1, r3
3400a338:	401a      	ands	r2, r3
3400a33a:	f44f 3100 	mov.w	r1, #131072	@ 0x20000
3400a33e:	687b      	ldr	r3, [r7, #4]
3400a340:	fa01 f303 	lsl.w	r3, r1, r3
3400a344:	429a      	cmp	r2, r3
3400a346:	d1e5      	bne.n	3400a314 <DCMIPP_CSI_SetVCConfig+0xd8>

  /* Enable the SOF and EOF interrupts for the selected virtual channel */
  __HAL_DCMIPP_CSI_ENABLE_IT(csi_instance, (DCMIPP_CSI_IT_EOF0 << VirtualChannel) | \
3400a348:	697b      	ldr	r3, [r7, #20]
3400a34a:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400a34e:	f44f 5188 	mov.w	r1, #4352	@ 0x1100
3400a352:	687b      	ldr	r3, [r7, #4]
3400a354:	fa01 f303 	lsl.w	r3, r1, r3
3400a358:	431a      	orrs	r2, r3
3400a35a:	697b      	ldr	r3, [r7, #20]
3400a35c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
                             (DCMIPP_CSI_IT_SOF0 << VirtualChannel));
  return HAL_OK;
3400a360:	2300      	movs	r3, #0
}
3400a362:	4618      	mov	r0, r3
3400a364:	3718      	adds	r7, #24
3400a366:	46bd      	mov	sp, r7
3400a368:	bd80      	pop	{r7, pc}
3400a36a:	bf00      	nop
3400a36c:	58006000 	.word	0x58006000

3400a370 <HAL_DMA_Abort>:
  *         is suspended while a data transfer is on-going, the current data will be transferred and the channel will be
  *         effectively suspended only after the transfer of any on-going data is finished.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *const hdma)
{
3400a370:	b580      	push	{r7, lr}
3400a372:	b084      	sub	sp, #16
3400a374:	af00      	add	r7, sp, #0
3400a376:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart =  HAL_GetTick();
3400a378:	f7fa fc59 	bl	34004c2e <HAL_GetTick>
3400a37c:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
3400a37e:	687b      	ldr	r3, [r7, #4]
3400a380:	2b00      	cmp	r3, #0
3400a382:	d101      	bne.n	3400a388 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
3400a384:	2301      	movs	r3, #1
3400a386:	e06b      	b.n	3400a460 <HAL_DMA_Abort+0xf0>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
3400a388:	687b      	ldr	r3, [r7, #4]
3400a38a:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
3400a38e:	b2db      	uxtb	r3, r3
3400a390:	2b02      	cmp	r3, #2
3400a392:	d008      	beq.n	3400a3a6 <HAL_DMA_Abort+0x36>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
3400a394:	687b      	ldr	r3, [r7, #4]
3400a396:	2220      	movs	r2, #32
3400a398:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
3400a39a:	687b      	ldr	r3, [r7, #4]
3400a39c:	2200      	movs	r2, #0
3400a39e:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    return HAL_ERROR;
3400a3a2:	2301      	movs	r3, #1
3400a3a4:	e05c      	b.n	3400a460 <HAL_DMA_Abort+0xf0>
  }
  else
  {
    /* Suspend the channel */
    hdma->Instance->CCR |= DMA_CCR_SUSP;
3400a3a6:	687b      	ldr	r3, [r7, #4]
3400a3a8:	681b      	ldr	r3, [r3, #0]
3400a3aa:	695a      	ldr	r2, [r3, #20]
3400a3ac:	687b      	ldr	r3, [r7, #4]
3400a3ae:	681b      	ldr	r3, [r3, #0]
3400a3b0:	f042 0204 	orr.w	r2, r2, #4
3400a3b4:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_SUSPEND;
3400a3b6:	687b      	ldr	r3, [r7, #4]
3400a3b8:	2205      	movs	r2, #5
3400a3ba:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check if the DMA Channel is suspended */
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
3400a3be:	e020      	b.n	3400a402 <HAL_DMA_Abort+0x92>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
3400a3c0:	f7fa fc35 	bl	34004c2e <HAL_GetTick>
3400a3c4:	4602      	mov	r2, r0
3400a3c6:	68fb      	ldr	r3, [r7, #12]
3400a3c8:	1ad3      	subs	r3, r2, r3
3400a3ca:	2b05      	cmp	r3, #5
3400a3cc:	d919      	bls.n	3400a402 <HAL_DMA_Abort+0x92>
      {
        /* Update the DMA channel error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
3400a3ce:	687b      	ldr	r3, [r7, #4]
3400a3d0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400a3d2:	f043 0210 	orr.w	r2, r3, #16
3400a3d6:	687b      	ldr	r3, [r7, #4]
3400a3d8:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_ERROR;
3400a3da:	687b      	ldr	r3, [r7, #4]
3400a3dc:	2203      	movs	r2, #3
3400a3de:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
3400a3e2:	687b      	ldr	r3, [r7, #4]
3400a3e4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400a3e6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400a3ea:	2b00      	cmp	r3, #0
3400a3ec:	d003      	beq.n	3400a3f6 <HAL_DMA_Abort+0x86>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
3400a3ee:	687b      	ldr	r3, [r7, #4]
3400a3f0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a3f2:	2201      	movs	r2, #1
3400a3f4:	731a      	strb	r2, [r3, #12]
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
3400a3f6:	687b      	ldr	r3, [r7, #4]
3400a3f8:	2200      	movs	r2, #0
3400a3fa:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        return HAL_ERROR;
3400a3fe:	2301      	movs	r3, #1
3400a400:	e02e      	b.n	3400a460 <HAL_DMA_Abort+0xf0>
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
3400a402:	687b      	ldr	r3, [r7, #4]
3400a404:	681b      	ldr	r3, [r3, #0]
3400a406:	691b      	ldr	r3, [r3, #16]
3400a408:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400a40c:	2b00      	cmp	r3, #0
3400a40e:	d0d7      	beq.n	3400a3c0 <HAL_DMA_Abort+0x50>
      }
    }

    /* Reset the channel */
    hdma->Instance->CCR |= DMA_CCR_RESET;
3400a410:	687b      	ldr	r3, [r7, #4]
3400a412:	681b      	ldr	r3, [r3, #0]
3400a414:	695a      	ldr	r2, [r3, #20]
3400a416:	687b      	ldr	r3, [r7, #4]
3400a418:	681b      	ldr	r3, [r3, #0]
3400a41a:	f042 0202 	orr.w	r2, r2, #2
3400a41e:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
3400a420:	687b      	ldr	r3, [r7, #4]
3400a422:	2204      	movs	r2, #4
3400a424:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Clear all status flags */
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
3400a428:	687b      	ldr	r3, [r7, #4]
3400a42a:	681b      	ldr	r3, [r3, #0]
3400a42c:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
3400a430:	60da      	str	r2, [r3, #12]
                                DMA_FLAG_TO));

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
3400a432:	687b      	ldr	r3, [r7, #4]
3400a434:	2201      	movs	r2, #1
3400a436:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
3400a43a:	687b      	ldr	r3, [r7, #4]
3400a43c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3400a43e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400a442:	2b00      	cmp	r3, #0
3400a444:	d007      	beq.n	3400a456 <HAL_DMA_Abort+0xe6>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
3400a446:	687b      	ldr	r3, [r7, #4]
3400a448:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a44a:	2201      	movs	r2, #1
3400a44c:	731a      	strb	r2, [r3, #12]

      /* Clear remaining data size to ensure loading linked-list from memory next start */
      hdma->Instance->CBR1 = 0U;
3400a44e:	687b      	ldr	r3, [r7, #4]
3400a450:	681b      	ldr	r3, [r3, #0]
3400a452:	2200      	movs	r2, #0
3400a454:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
3400a456:	687b      	ldr	r3, [r7, #4]
3400a458:	2200      	movs	r2, #0
3400a45a:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
  }

  return HAL_OK;
3400a45e:	2300      	movs	r3, #0
}
3400a460:	4618      	mov	r0, r3
3400a462:	3710      	adds	r7, #16
3400a464:	46bd      	mov	sp, r7
3400a466:	bd80      	pop	{r7, pc}

3400a468 <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
3400a468:	b580      	push	{r7, lr}
3400a46a:	b082      	sub	sp, #8
3400a46c:	af00      	add	r7, sp, #0
3400a46e:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
3400a470:	687b      	ldr	r3, [r7, #4]
3400a472:	2b00      	cmp	r3, #0
3400a474:	d101      	bne.n	3400a47a <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
3400a476:	2301      	movs	r3, #1
3400a478:	e053      	b.n	3400a522 <HAL_DMA2D_Init+0xba>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
3400a47a:	687b      	ldr	r3, [r7, #4]
3400a47c:	f893 3061 	ldrb.w	r3, [r3, #97]	@ 0x61
3400a480:	b2db      	uxtb	r3, r3
3400a482:	2b00      	cmp	r3, #0
3400a484:	d106      	bne.n	3400a494 <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
3400a486:	687b      	ldr	r3, [r7, #4]
3400a488:	2200      	movs	r2, #0
3400a48a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
3400a48e:	6878      	ldr	r0, [r7, #4]
3400a490:	f7fa f8b0 	bl	340045f4 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3400a494:	687b      	ldr	r3, [r7, #4]
3400a496:	2202      	movs	r2, #2
3400a498:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
3400a49c:	687b      	ldr	r3, [r7, #4]
3400a49e:	681b      	ldr	r3, [r3, #0]
3400a4a0:	681b      	ldr	r3, [r3, #0]
3400a4a2:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400a4a6:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400a4aa:	687a      	ldr	r2, [r7, #4]
3400a4ac:	6851      	ldr	r1, [r2, #4]
3400a4ae:	687a      	ldr	r2, [r7, #4]
3400a4b0:	69d2      	ldr	r2, [r2, #28]
3400a4b2:	4311      	orrs	r1, r2
3400a4b4:	687a      	ldr	r2, [r7, #4]
3400a4b6:	6812      	ldr	r2, [r2, #0]
3400a4b8:	430b      	orrs	r3, r1
3400a4ba:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
3400a4bc:	687b      	ldr	r3, [r7, #4]
3400a4be:	681b      	ldr	r3, [r3, #0]
3400a4c0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400a4c2:	f423 7383 	bic.w	r3, r3, #262	@ 0x106
3400a4c6:	f023 0301 	bic.w	r3, r3, #1
3400a4ca:	687a      	ldr	r2, [r7, #4]
3400a4cc:	6891      	ldr	r1, [r2, #8]
3400a4ce:	687a      	ldr	r2, [r7, #4]
3400a4d0:	6992      	ldr	r2, [r2, #24]
3400a4d2:	4311      	orrs	r1, r2
3400a4d4:	687a      	ldr	r2, [r7, #4]
3400a4d6:	6812      	ldr	r2, [r2, #0]
3400a4d8:	430b      	orrs	r3, r1
3400a4da:	6353      	str	r3, [r2, #52]	@ 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
3400a4dc:	687b      	ldr	r3, [r7, #4]
3400a4de:	681b      	ldr	r3, [r3, #0]
3400a4e0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400a4e2:	0c1b      	lsrs	r3, r3, #16
3400a4e4:	041b      	lsls	r3, r3, #16
3400a4e6:	687a      	ldr	r2, [r7, #4]
3400a4e8:	68d1      	ldr	r1, [r2, #12]
3400a4ea:	687a      	ldr	r2, [r7, #4]
3400a4ec:	6812      	ldr	r2, [r2, #0]
3400a4ee:	430b      	orrs	r3, r1
3400a4f0:	6413      	str	r3, [r2, #64]	@ 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
3400a4f2:	687b      	ldr	r3, [r7, #4]
3400a4f4:	681b      	ldr	r3, [r3, #0]
3400a4f6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400a4f8:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
3400a4fc:	687b      	ldr	r3, [r7, #4]
3400a4fe:	691b      	ldr	r3, [r3, #16]
3400a500:	051a      	lsls	r2, r3, #20
3400a502:	687b      	ldr	r3, [r7, #4]
3400a504:	695b      	ldr	r3, [r3, #20]
3400a506:	055b      	lsls	r3, r3, #21
3400a508:	431a      	orrs	r2, r3
3400a50a:	687b      	ldr	r3, [r7, #4]
3400a50c:	681b      	ldr	r3, [r3, #0]
3400a50e:	430a      	orrs	r2, r1
3400a510:	635a      	str	r2, [r3, #52]	@ 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
3400a512:	687b      	ldr	r3, [r7, #4]
3400a514:	2200      	movs	r2, #0
3400a516:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
3400a518:	687b      	ldr	r3, [r7, #4]
3400a51a:	2201      	movs	r2, #1
3400a51c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  return HAL_OK;
3400a520:	2300      	movs	r3, #0
}
3400a522:	4618      	mov	r0, r3
3400a524:	3708      	adds	r7, #8
3400a526:	46bd      	mov	sp, r7
3400a528:	bd80      	pop	{r7, pc}

3400a52a <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
3400a52a:	b580      	push	{r7, lr}
3400a52c:	b086      	sub	sp, #24
3400a52e:	af02      	add	r7, sp, #8
3400a530:	60f8      	str	r0, [r7, #12]
3400a532:	60b9      	str	r1, [r7, #8]
3400a534:	607a      	str	r2, [r7, #4]
3400a536:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
3400a538:	68fb      	ldr	r3, [r7, #12]
3400a53a:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
3400a53e:	2b01      	cmp	r3, #1
3400a540:	d101      	bne.n	3400a546 <HAL_DMA2D_Start+0x1c>
3400a542:	2302      	movs	r3, #2
3400a544:	e018      	b.n	3400a578 <HAL_DMA2D_Start+0x4e>
3400a546:	68fb      	ldr	r3, [r7, #12]
3400a548:	2201      	movs	r2, #1
3400a54a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3400a54e:	68fb      	ldr	r3, [r7, #12]
3400a550:	2202      	movs	r2, #2
3400a552:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
3400a556:	69bb      	ldr	r3, [r7, #24]
3400a558:	9300      	str	r3, [sp, #0]
3400a55a:	683b      	ldr	r3, [r7, #0]
3400a55c:	687a      	ldr	r2, [r7, #4]
3400a55e:	68b9      	ldr	r1, [r7, #8]
3400a560:	68f8      	ldr	r0, [r7, #12]
3400a562:	f000 f9a5 	bl	3400a8b0 <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
3400a566:	68fb      	ldr	r3, [r7, #12]
3400a568:	681b      	ldr	r3, [r3, #0]
3400a56a:	681a      	ldr	r2, [r3, #0]
3400a56c:	68fb      	ldr	r3, [r7, #12]
3400a56e:	681b      	ldr	r3, [r3, #0]
3400a570:	f042 0201 	orr.w	r2, r2, #1
3400a574:	601a      	str	r2, [r3, #0]

  return HAL_OK;
3400a576:	2300      	movs	r3, #0
}
3400a578:	4618      	mov	r0, r3
3400a57a:	3710      	adds	r7, #16
3400a57c:	46bd      	mov	sp, r7
3400a57e:	bd80      	pop	{r7, pc}

3400a580 <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
3400a580:	b580      	push	{r7, lr}
3400a582:	b086      	sub	sp, #24
3400a584:	af00      	add	r7, sp, #0
3400a586:	6078      	str	r0, [r7, #4]
3400a588:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
3400a58a:	2300      	movs	r3, #0
3400a58c:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
3400a58e:	687b      	ldr	r3, [r7, #4]
3400a590:	681b      	ldr	r3, [r3, #0]
3400a592:	681b      	ldr	r3, [r3, #0]
3400a594:	f003 0301 	and.w	r3, r3, #1
3400a598:	2b00      	cmp	r3, #0
3400a59a:	d056      	beq.n	3400a64a <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
3400a59c:	f7fa fb47 	bl	34004c2e <HAL_GetTick>
3400a5a0:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
3400a5a2:	e04b      	b.n	3400a63c <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
3400a5a4:	687b      	ldr	r3, [r7, #4]
3400a5a6:	681b      	ldr	r3, [r3, #0]
3400a5a8:	685b      	ldr	r3, [r3, #4]
3400a5aa:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
3400a5ac:	68fb      	ldr	r3, [r7, #12]
3400a5ae:	f003 0321 	and.w	r3, r3, #33	@ 0x21
3400a5b2:	2b00      	cmp	r3, #0
3400a5b4:	d023      	beq.n	3400a5fe <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
3400a5b6:	68fb      	ldr	r3, [r7, #12]
3400a5b8:	f003 0320 	and.w	r3, r3, #32
3400a5bc:	2b00      	cmp	r3, #0
3400a5be:	d005      	beq.n	3400a5cc <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3400a5c0:	687b      	ldr	r3, [r7, #4]
3400a5c2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a5c4:	f043 0202 	orr.w	r2, r3, #2
3400a5c8:	687b      	ldr	r3, [r7, #4]
3400a5ca:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
3400a5cc:	68fb      	ldr	r3, [r7, #12]
3400a5ce:	f003 0301 	and.w	r3, r3, #1
3400a5d2:	2b00      	cmp	r3, #0
3400a5d4:	d005      	beq.n	3400a5e2 <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
3400a5d6:	687b      	ldr	r3, [r7, #4]
3400a5d8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a5da:	f043 0201 	orr.w	r2, r3, #1
3400a5de:	687b      	ldr	r3, [r7, #4]
3400a5e0:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400a5e2:	687b      	ldr	r3, [r7, #4]
3400a5e4:	681b      	ldr	r3, [r3, #0]
3400a5e6:	2221      	movs	r2, #33	@ 0x21
3400a5e8:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
3400a5ea:	687b      	ldr	r3, [r7, #4]
3400a5ec:	2204      	movs	r2, #4
3400a5ee:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
3400a5f2:	687b      	ldr	r3, [r7, #4]
3400a5f4:	2200      	movs	r2, #0
3400a5f6:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
3400a5fa:	2301      	movs	r3, #1
3400a5fc:	e0a5      	b.n	3400a74a <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
3400a5fe:	683b      	ldr	r3, [r7, #0]
3400a600:	f1b3 3fff 	cmp.w	r3, #4294967295
3400a604:	d01a      	beq.n	3400a63c <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400a606:	f7fa fb12 	bl	34004c2e <HAL_GetTick>
3400a60a:	4602      	mov	r2, r0
3400a60c:	697b      	ldr	r3, [r7, #20]
3400a60e:	1ad3      	subs	r3, r2, r3
3400a610:	683a      	ldr	r2, [r7, #0]
3400a612:	429a      	cmp	r2, r3
3400a614:	d302      	bcc.n	3400a61c <HAL_DMA2D_PollForTransfer+0x9c>
3400a616:	683b      	ldr	r3, [r7, #0]
3400a618:	2b00      	cmp	r3, #0
3400a61a:	d10f      	bne.n	3400a63c <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
3400a61c:	687b      	ldr	r3, [r7, #4]
3400a61e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a620:	f043 0220 	orr.w	r2, r3, #32
3400a624:	687b      	ldr	r3, [r7, #4]
3400a626:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
3400a628:	687b      	ldr	r3, [r7, #4]
3400a62a:	2203      	movs	r2, #3
3400a62c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
3400a630:	687b      	ldr	r3, [r7, #4]
3400a632:	2200      	movs	r2, #0
3400a634:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
3400a638:	2303      	movs	r3, #3
3400a63a:	e086      	b.n	3400a74a <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
3400a63c:	687b      	ldr	r3, [r7, #4]
3400a63e:	681b      	ldr	r3, [r3, #0]
3400a640:	685b      	ldr	r3, [r3, #4]
3400a642:	f003 0302 	and.w	r3, r3, #2
3400a646:	2b00      	cmp	r3, #0
3400a648:	d0ac      	beq.n	3400a5a4 <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
3400a64a:	687b      	ldr	r3, [r7, #4]
3400a64c:	681b      	ldr	r3, [r3, #0]
3400a64e:	69db      	ldr	r3, [r3, #28]
3400a650:	f003 0320 	and.w	r3, r3, #32
3400a654:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
3400a656:	687b      	ldr	r3, [r7, #4]
3400a658:	681b      	ldr	r3, [r3, #0]
3400a65a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400a65c:	f003 0320 	and.w	r3, r3, #32
3400a660:	693a      	ldr	r2, [r7, #16]
3400a662:	4313      	orrs	r3, r2
3400a664:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
3400a666:	693b      	ldr	r3, [r7, #16]
3400a668:	2b00      	cmp	r3, #0
3400a66a:	d061      	beq.n	3400a730 <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
3400a66c:	f7fa fadf 	bl	34004c2e <HAL_GetTick>
3400a670:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
3400a672:	e056      	b.n	3400a722 <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
3400a674:	687b      	ldr	r3, [r7, #4]
3400a676:	681b      	ldr	r3, [r3, #0]
3400a678:	685b      	ldr	r3, [r3, #4]
3400a67a:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
3400a67c:	68fb      	ldr	r3, [r7, #12]
3400a67e:	f003 0329 	and.w	r3, r3, #41	@ 0x29
3400a682:	2b00      	cmp	r3, #0
3400a684:	d02e      	beq.n	3400a6e4 <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
3400a686:	68fb      	ldr	r3, [r7, #12]
3400a688:	f003 0308 	and.w	r3, r3, #8
3400a68c:	2b00      	cmp	r3, #0
3400a68e:	d005      	beq.n	3400a69c <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
3400a690:	687b      	ldr	r3, [r7, #4]
3400a692:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a694:	f043 0204 	orr.w	r2, r3, #4
3400a698:	687b      	ldr	r3, [r7, #4]
3400a69a:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
3400a69c:	68fb      	ldr	r3, [r7, #12]
3400a69e:	f003 0320 	and.w	r3, r3, #32
3400a6a2:	2b00      	cmp	r3, #0
3400a6a4:	d005      	beq.n	3400a6b2 <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3400a6a6:	687b      	ldr	r3, [r7, #4]
3400a6a8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a6aa:	f043 0202 	orr.w	r2, r3, #2
3400a6ae:	687b      	ldr	r3, [r7, #4]
3400a6b0:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
3400a6b2:	68fb      	ldr	r3, [r7, #12]
3400a6b4:	f003 0301 	and.w	r3, r3, #1
3400a6b8:	2b00      	cmp	r3, #0
3400a6ba:	d005      	beq.n	3400a6c8 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
3400a6bc:	687b      	ldr	r3, [r7, #4]
3400a6be:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a6c0:	f043 0201 	orr.w	r2, r3, #1
3400a6c4:	687b      	ldr	r3, [r7, #4]
3400a6c6:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400a6c8:	687b      	ldr	r3, [r7, #4]
3400a6ca:	681b      	ldr	r3, [r3, #0]
3400a6cc:	2229      	movs	r2, #41	@ 0x29
3400a6ce:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
3400a6d0:	687b      	ldr	r3, [r7, #4]
3400a6d2:	2204      	movs	r2, #4
3400a6d4:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
3400a6d8:	687b      	ldr	r3, [r7, #4]
3400a6da:	2200      	movs	r2, #0
3400a6dc:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
3400a6e0:	2301      	movs	r3, #1
3400a6e2:	e032      	b.n	3400a74a <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
3400a6e4:	683b      	ldr	r3, [r7, #0]
3400a6e6:	f1b3 3fff 	cmp.w	r3, #4294967295
3400a6ea:	d01a      	beq.n	3400a722 <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400a6ec:	f7fa fa9f 	bl	34004c2e <HAL_GetTick>
3400a6f0:	4602      	mov	r2, r0
3400a6f2:	697b      	ldr	r3, [r7, #20]
3400a6f4:	1ad3      	subs	r3, r2, r3
3400a6f6:	683a      	ldr	r2, [r7, #0]
3400a6f8:	429a      	cmp	r2, r3
3400a6fa:	d302      	bcc.n	3400a702 <HAL_DMA2D_PollForTransfer+0x182>
3400a6fc:	683b      	ldr	r3, [r7, #0]
3400a6fe:	2b00      	cmp	r3, #0
3400a700:	d10f      	bne.n	3400a722 <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
3400a702:	687b      	ldr	r3, [r7, #4]
3400a704:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400a706:	f043 0220 	orr.w	r2, r3, #32
3400a70a:	687b      	ldr	r3, [r7, #4]
3400a70c:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
3400a70e:	687b      	ldr	r3, [r7, #4]
3400a710:	2203      	movs	r2, #3
3400a712:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
3400a716:	687b      	ldr	r3, [r7, #4]
3400a718:	2200      	movs	r2, #0
3400a71a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
3400a71e:	2303      	movs	r3, #3
3400a720:	e013      	b.n	3400a74a <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
3400a722:	687b      	ldr	r3, [r7, #4]
3400a724:	681b      	ldr	r3, [r3, #0]
3400a726:	685b      	ldr	r3, [r3, #4]
3400a728:	f003 0310 	and.w	r3, r3, #16
3400a72c:	2b00      	cmp	r3, #0
3400a72e:	d0a1      	beq.n	3400a674 <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
3400a730:	687b      	ldr	r3, [r7, #4]
3400a732:	681b      	ldr	r3, [r3, #0]
3400a734:	2212      	movs	r2, #18
3400a736:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
3400a738:	687b      	ldr	r3, [r7, #4]
3400a73a:	2201      	movs	r2, #1
3400a73c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
3400a740:	687b      	ldr	r3, [r7, #4]
3400a742:	2200      	movs	r2, #0
3400a744:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
3400a748:	2300      	movs	r3, #0
}
3400a74a:	4618      	mov	r0, r3
3400a74c:	3718      	adds	r7, #24
3400a74e:	46bd      	mov	sp, r7
3400a750:	bd80      	pop	{r7, pc}
	...

3400a754 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
3400a754:	b480      	push	{r7}
3400a756:	b087      	sub	sp, #28
3400a758:	af00      	add	r7, sp, #0
3400a75a:	6078      	str	r0, [r7, #4]
3400a75c:	6039      	str	r1, [r7, #0]
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if (hdma2d->Init.Mode != DMA2D_R2M)
3400a75e:	687b      	ldr	r3, [r7, #4]
3400a760:	685b      	ldr	r3, [r3, #4]
3400a762:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
    }
  }
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));

  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
3400a766:	683b      	ldr	r3, [r7, #0]
3400a768:	2b01      	cmp	r3, #1
  {
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
3400a76a:	687b      	ldr	r3, [r7, #4]
3400a76c:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
3400a770:	2b01      	cmp	r3, #1
3400a772:	d101      	bne.n	3400a778 <HAL_DMA2D_ConfigLayer+0x24>
3400a774:	2302      	movs	r3, #2
3400a776:	e092      	b.n	3400a89e <HAL_DMA2D_ConfigLayer+0x14a>
3400a778:	687b      	ldr	r3, [r7, #4]
3400a77a:	2201      	movs	r2, #1
3400a77c:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
3400a780:	687b      	ldr	r3, [r7, #4]
3400a782:	2202      	movs	r2, #2
3400a784:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
3400a788:	683a      	ldr	r2, [r7, #0]
3400a78a:	4613      	mov	r3, r2
3400a78c:	00db      	lsls	r3, r3, #3
3400a78e:	1a9b      	subs	r3, r3, r2
3400a790:	009b      	lsls	r3, r3, #2
3400a792:	3328      	adds	r3, #40	@ 0x28
3400a794:	687a      	ldr	r2, [r7, #4]
3400a796:	4413      	add	r3, r2
3400a798:	60fb      	str	r3, [r7, #12]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400a79a:	68fb      	ldr	r3, [r7, #12]
3400a79c:	685a      	ldr	r2, [r3, #4]
3400a79e:	68fb      	ldr	r3, [r7, #12]
3400a7a0:	689b      	ldr	r3, [r3, #8]
3400a7a2:	041b      	lsls	r3, r3, #16
3400a7a4:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3400a7a6:	68fb      	ldr	r3, [r7, #12]
3400a7a8:	691b      	ldr	r3, [r3, #16]
3400a7aa:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400a7ac:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
3400a7ae:	68fb      	ldr	r3, [r7, #12]
3400a7b0:	695b      	ldr	r3, [r3, #20]
3400a7b2:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
3400a7b4:	4313      	orrs	r3, r2
3400a7b6:	613b      	str	r3, [r7, #16]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
3400a7b8:	4b3c      	ldr	r3, [pc, #240]	@ (3400a8ac <HAL_DMA2D_ConfigLayer+0x158>)
3400a7ba:	617b      	str	r3, [r7, #20]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
3400a7bc:	68fb      	ldr	r3, [r7, #12]
3400a7be:	685b      	ldr	r3, [r3, #4]
3400a7c0:	2b0a      	cmp	r3, #10
3400a7c2:	d003      	beq.n	3400a7cc <HAL_DMA2D_ConfigLayer+0x78>
3400a7c4:	68fb      	ldr	r3, [r7, #12]
3400a7c6:	685b      	ldr	r3, [r3, #4]
3400a7c8:	2b09      	cmp	r3, #9
3400a7ca:	d107      	bne.n	3400a7dc <HAL_DMA2D_ConfigLayer+0x88>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
3400a7cc:	68fb      	ldr	r3, [r7, #12]
3400a7ce:	68db      	ldr	r3, [r3, #12]
3400a7d0:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
3400a7d4:	693a      	ldr	r2, [r7, #16]
3400a7d6:	4313      	orrs	r3, r2
3400a7d8:	613b      	str	r3, [r7, #16]
3400a7da:	e005      	b.n	3400a7e8 <HAL_DMA2D_ConfigLayer+0x94>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
3400a7dc:	68fb      	ldr	r3, [r7, #12]
3400a7de:	68db      	ldr	r3, [r3, #12]
3400a7e0:	061b      	lsls	r3, r3, #24
3400a7e2:	693a      	ldr	r2, [r7, #16]
3400a7e4:	4313      	orrs	r3, r2
3400a7e6:	613b      	str	r3, [r7, #16]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
3400a7e8:	683b      	ldr	r3, [r7, #0]
3400a7ea:	2b00      	cmp	r3, #0
3400a7ec:	d120      	bne.n	3400a830 <HAL_DMA2D_ConfigLayer+0xdc>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
3400a7ee:	687b      	ldr	r3, [r7, #4]
3400a7f0:	681b      	ldr	r3, [r3, #0]
3400a7f2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400a7f4:	697b      	ldr	r3, [r7, #20]
3400a7f6:	43db      	mvns	r3, r3
3400a7f8:	ea02 0103 	and.w	r1, r2, r3
3400a7fc:	687b      	ldr	r3, [r7, #4]
3400a7fe:	681b      	ldr	r3, [r3, #0]
3400a800:	693a      	ldr	r2, [r7, #16]
3400a802:	430a      	orrs	r2, r1
3400a804:	625a      	str	r2, [r3, #36]	@ 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
3400a806:	687b      	ldr	r3, [r7, #4]
3400a808:	681b      	ldr	r3, [r3, #0]
3400a80a:	68fa      	ldr	r2, [r7, #12]
3400a80c:	6812      	ldr	r2, [r2, #0]
3400a80e:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
3400a810:	68fb      	ldr	r3, [r7, #12]
3400a812:	685b      	ldr	r3, [r3, #4]
3400a814:	2b0a      	cmp	r3, #10
3400a816:	d003      	beq.n	3400a820 <HAL_DMA2D_ConfigLayer+0xcc>
3400a818:	68fb      	ldr	r3, [r7, #12]
3400a81a:	685b      	ldr	r3, [r3, #4]
3400a81c:	2b09      	cmp	r3, #9
3400a81e:	d135      	bne.n	3400a88c <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
3400a820:	68fb      	ldr	r3, [r7, #12]
3400a822:	68da      	ldr	r2, [r3, #12]
3400a824:	687b      	ldr	r3, [r7, #4]
3400a826:	681b      	ldr	r3, [r3, #0]
3400a828:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
3400a82c:	629a      	str	r2, [r3, #40]	@ 0x28
3400a82e:	e02d      	b.n	3400a88c <HAL_DMA2D_ConfigLayer+0x138>
  }
  /* Configure the foreground DMA2D layer */
  else
  {

    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
3400a830:	68fb      	ldr	r3, [r7, #12]
3400a832:	685b      	ldr	r3, [r3, #4]
3400a834:	2b0b      	cmp	r3, #11
3400a836:	d109      	bne.n	3400a84c <HAL_DMA2D_ConfigLayer+0xf8>
    {
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
3400a838:	68fb      	ldr	r3, [r7, #12]
3400a83a:	699b      	ldr	r3, [r3, #24]
3400a83c:	049b      	lsls	r3, r3, #18
3400a83e:	693a      	ldr	r2, [r7, #16]
3400a840:	4313      	orrs	r3, r2
3400a842:	613b      	str	r3, [r7, #16]
      regMask  |= DMA2D_FGPFCCR_CSS;
3400a844:	697b      	ldr	r3, [r7, #20]
3400a846:	f443 2340 	orr.w	r3, r3, #786432	@ 0xc0000
3400a84a:	617b      	str	r3, [r7, #20]
    }

    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
3400a84c:	687b      	ldr	r3, [r7, #4]
3400a84e:	681b      	ldr	r3, [r3, #0]
3400a850:	69da      	ldr	r2, [r3, #28]
3400a852:	697b      	ldr	r3, [r7, #20]
3400a854:	43db      	mvns	r3, r3
3400a856:	ea02 0103 	and.w	r1, r2, r3
3400a85a:	687b      	ldr	r3, [r7, #4]
3400a85c:	681b      	ldr	r3, [r3, #0]
3400a85e:	693a      	ldr	r2, [r7, #16]
3400a860:	430a      	orrs	r2, r1
3400a862:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
3400a864:	687b      	ldr	r3, [r7, #4]
3400a866:	681b      	ldr	r3, [r3, #0]
3400a868:	68fa      	ldr	r2, [r7, #12]
3400a86a:	6812      	ldr	r2, [r2, #0]
3400a86c:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
3400a86e:	68fb      	ldr	r3, [r7, #12]
3400a870:	685b      	ldr	r3, [r3, #4]
3400a872:	2b0a      	cmp	r3, #10
3400a874:	d003      	beq.n	3400a87e <HAL_DMA2D_ConfigLayer+0x12a>
3400a876:	68fb      	ldr	r3, [r7, #12]
3400a878:	685b      	ldr	r3, [r3, #4]
3400a87a:	2b09      	cmp	r3, #9
3400a87c:	d106      	bne.n	3400a88c <HAL_DMA2D_ConfigLayer+0x138>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
3400a87e:	68fb      	ldr	r3, [r7, #12]
3400a880:	68da      	ldr	r2, [r3, #12]
3400a882:	687b      	ldr	r3, [r7, #4]
3400a884:	681b      	ldr	r3, [r3, #0]
3400a886:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
3400a88a:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
3400a88c:	687b      	ldr	r3, [r7, #4]
3400a88e:	2201      	movs	r2, #1
3400a890:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
3400a894:	687b      	ldr	r3, [r7, #4]
3400a896:	2200      	movs	r2, #0
3400a898:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
3400a89c:	2300      	movs	r3, #0
}
3400a89e:	4618      	mov	r0, r3
3400a8a0:	371c      	adds	r7, #28
3400a8a2:	46bd      	mov	sp, r7
3400a8a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a8a8:	4770      	bx	lr
3400a8aa:	bf00      	nop
3400a8ac:	ff33000f 	.word	0xff33000f

3400a8b0 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
3400a8b0:	b480      	push	{r7}
3400a8b2:	b08b      	sub	sp, #44	@ 0x2c
3400a8b4:	af00      	add	r7, sp, #0
3400a8b6:	60f8      	str	r0, [r7, #12]
3400a8b8:	60b9      	str	r1, [r7, #8]
3400a8ba:	607a      	str	r2, [r7, #4]
3400a8bc:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
3400a8be:	68fb      	ldr	r3, [r7, #12]
3400a8c0:	681b      	ldr	r3, [r3, #0]
3400a8c2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a8c4:	f003 4140 	and.w	r1, r3, #3221225472	@ 0xc0000000
3400a8c8:	683b      	ldr	r3, [r7, #0]
3400a8ca:	041a      	lsls	r2, r3, #16
3400a8cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400a8ce:	431a      	orrs	r2, r3
3400a8d0:	68fb      	ldr	r3, [r7, #12]
3400a8d2:	681b      	ldr	r3, [r3, #0]
3400a8d4:	430a      	orrs	r2, r1
3400a8d6:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
3400a8d8:	68fb      	ldr	r3, [r7, #12]
3400a8da:	681b      	ldr	r3, [r3, #0]
3400a8dc:	687a      	ldr	r2, [r7, #4]
3400a8de:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
3400a8e0:	68fb      	ldr	r3, [r7, #12]
3400a8e2:	685b      	ldr	r3, [r3, #4]
3400a8e4:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400a8e8:	d174      	bne.n	3400a9d4 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
3400a8ea:	68bb      	ldr	r3, [r7, #8]
3400a8ec:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
3400a8f0:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
3400a8f2:	68bb      	ldr	r3, [r7, #8]
3400a8f4:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
3400a8f8:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
3400a8fa:	68bb      	ldr	r3, [r7, #8]
3400a8fc:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
3400a900:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
3400a902:	68bb      	ldr	r3, [r7, #8]
3400a904:	b2db      	uxtb	r3, r3
3400a906:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
3400a908:	68fb      	ldr	r3, [r7, #12]
3400a90a:	689b      	ldr	r3, [r3, #8]
3400a90c:	2b00      	cmp	r3, #0
3400a90e:	d108      	bne.n	3400a922 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
3400a910:	69ba      	ldr	r2, [r7, #24]
3400a912:	69fb      	ldr	r3, [r7, #28]
3400a914:	431a      	orrs	r2, r3
3400a916:	6a3b      	ldr	r3, [r7, #32]
3400a918:	4313      	orrs	r3, r2
3400a91a:	697a      	ldr	r2, [r7, #20]
3400a91c:	4313      	orrs	r3, r2
3400a91e:	627b      	str	r3, [r7, #36]	@ 0x24
3400a920:	e053      	b.n	3400a9ca <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
3400a922:	68fb      	ldr	r3, [r7, #12]
3400a924:	689b      	ldr	r3, [r3, #8]
3400a926:	2b01      	cmp	r3, #1
3400a928:	d106      	bne.n	3400a938 <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
3400a92a:	69ba      	ldr	r2, [r7, #24]
3400a92c:	69fb      	ldr	r3, [r7, #28]
3400a92e:	4313      	orrs	r3, r2
3400a930:	697a      	ldr	r2, [r7, #20]
3400a932:	4313      	orrs	r3, r2
3400a934:	627b      	str	r3, [r7, #36]	@ 0x24
3400a936:	e048      	b.n	3400a9ca <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
3400a938:	68fb      	ldr	r3, [r7, #12]
3400a93a:	689b      	ldr	r3, [r3, #8]
3400a93c:	2b02      	cmp	r3, #2
3400a93e:	d111      	bne.n	3400a964 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
3400a940:	69fb      	ldr	r3, [r7, #28]
3400a942:	0cdb      	lsrs	r3, r3, #19
3400a944:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
3400a946:	69bb      	ldr	r3, [r7, #24]
3400a948:	0a9b      	lsrs	r3, r3, #10
3400a94a:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
3400a94c:	697b      	ldr	r3, [r7, #20]
3400a94e:	08db      	lsrs	r3, r3, #3
3400a950:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
3400a952:	69bb      	ldr	r3, [r7, #24]
3400a954:	015a      	lsls	r2, r3, #5
3400a956:	69fb      	ldr	r3, [r7, #28]
3400a958:	02db      	lsls	r3, r3, #11
3400a95a:	4313      	orrs	r3, r2
3400a95c:	697a      	ldr	r2, [r7, #20]
3400a95e:	4313      	orrs	r3, r2
3400a960:	627b      	str	r3, [r7, #36]	@ 0x24
3400a962:	e032      	b.n	3400a9ca <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
3400a964:	68fb      	ldr	r3, [r7, #12]
3400a966:	689b      	ldr	r3, [r3, #8]
3400a968:	2b03      	cmp	r3, #3
3400a96a:	d117      	bne.n	3400a99c <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
3400a96c:	6a3b      	ldr	r3, [r7, #32]
3400a96e:	0fdb      	lsrs	r3, r3, #31
3400a970:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
3400a972:	69fb      	ldr	r3, [r7, #28]
3400a974:	0cdb      	lsrs	r3, r3, #19
3400a976:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
3400a978:	69bb      	ldr	r3, [r7, #24]
3400a97a:	0adb      	lsrs	r3, r3, #11
3400a97c:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
3400a97e:	697b      	ldr	r3, [r7, #20]
3400a980:	08db      	lsrs	r3, r3, #3
3400a982:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
3400a984:	69bb      	ldr	r3, [r7, #24]
3400a986:	015a      	lsls	r2, r3, #5
3400a988:	69fb      	ldr	r3, [r7, #28]
3400a98a:	029b      	lsls	r3, r3, #10
3400a98c:	431a      	orrs	r2, r3
3400a98e:	6a3b      	ldr	r3, [r7, #32]
3400a990:	03db      	lsls	r3, r3, #15
3400a992:	4313      	orrs	r3, r2
3400a994:	697a      	ldr	r2, [r7, #20]
3400a996:	4313      	orrs	r3, r2
3400a998:	627b      	str	r3, [r7, #36]	@ 0x24
3400a99a:	e016      	b.n	3400a9ca <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
3400a99c:	6a3b      	ldr	r3, [r7, #32]
3400a99e:	0f1b      	lsrs	r3, r3, #28
3400a9a0:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
3400a9a2:	69fb      	ldr	r3, [r7, #28]
3400a9a4:	0d1b      	lsrs	r3, r3, #20
3400a9a6:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
3400a9a8:	69bb      	ldr	r3, [r7, #24]
3400a9aa:	0b1b      	lsrs	r3, r3, #12
3400a9ac:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
3400a9ae:	697b      	ldr	r3, [r7, #20]
3400a9b0:	091b      	lsrs	r3, r3, #4
3400a9b2:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
3400a9b4:	69bb      	ldr	r3, [r7, #24]
3400a9b6:	011a      	lsls	r2, r3, #4
3400a9b8:	69fb      	ldr	r3, [r7, #28]
3400a9ba:	021b      	lsls	r3, r3, #8
3400a9bc:	431a      	orrs	r2, r3
3400a9be:	6a3b      	ldr	r3, [r7, #32]
3400a9c0:	031b      	lsls	r3, r3, #12
3400a9c2:	4313      	orrs	r3, r2
3400a9c4:	697a      	ldr	r2, [r7, #20]
3400a9c6:	4313      	orrs	r3, r2
3400a9c8:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
3400a9ca:	68fb      	ldr	r3, [r7, #12]
3400a9cc:	681b      	ldr	r3, [r3, #0]
3400a9ce:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3400a9d0:	639a      	str	r2, [r3, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
3400a9d2:	e00d      	b.n	3400a9f0 <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
3400a9d4:	68fb      	ldr	r3, [r7, #12]
3400a9d6:	685b      	ldr	r3, [r3, #4]
3400a9d8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3400a9dc:	d104      	bne.n	3400a9e8 <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
3400a9de:	68fb      	ldr	r3, [r7, #12]
3400a9e0:	681b      	ldr	r3, [r3, #0]
3400a9e2:	68ba      	ldr	r2, [r7, #8]
3400a9e4:	615a      	str	r2, [r3, #20]
}
3400a9e6:	e003      	b.n	3400a9f0 <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
3400a9e8:	68fb      	ldr	r3, [r7, #12]
3400a9ea:	681b      	ldr	r3, [r3, #0]
3400a9ec:	68ba      	ldr	r2, [r7, #8]
3400a9ee:	60da      	str	r2, [r3, #12]
}
3400a9f0:	bf00      	nop
3400a9f2:	372c      	adds	r7, #44	@ 0x2c
3400a9f4:	46bd      	mov	sp, r7
3400a9f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400a9fa:	4770      	bx	lr

3400a9fc <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
3400a9fc:	b480      	push	{r7}
3400a9fe:	b087      	sub	sp, #28
3400aa00:	af00      	add	r7, sp, #0
3400aa02:	6078      	str	r0, [r7, #4]
3400aa04:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
3400aa06:	2300      	movs	r3, #0
3400aa08:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3400aa0a:	e180      	b.n	3400ad0e <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
3400aa0c:	683b      	ldr	r3, [r7, #0]
3400aa0e:	681a      	ldr	r2, [r3, #0]
3400aa10:	2101      	movs	r1, #1
3400aa12:	697b      	ldr	r3, [r7, #20]
3400aa14:	fa01 f303 	lsl.w	r3, r1, r3
3400aa18:	4013      	ands	r3, r2
3400aa1a:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
3400aa1c:	68fb      	ldr	r3, [r7, #12]
3400aa1e:	2b00      	cmp	r3, #0
3400aa20:	f000 8172 	beq.w	3400ad08 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
3400aa24:	683b      	ldr	r3, [r7, #0]
3400aa26:	685b      	ldr	r3, [r3, #4]
3400aa28:	f003 0303 	and.w	r3, r3, #3
3400aa2c:	2b01      	cmp	r3, #1
3400aa2e:	d005      	beq.n	3400aa3c <HAL_GPIO_Init+0x40>
3400aa30:	683b      	ldr	r3, [r7, #0]
3400aa32:	685b      	ldr	r3, [r3, #4]
3400aa34:	f003 0303 	and.w	r3, r3, #3
3400aa38:	2b02      	cmp	r3, #2
3400aa3a:	d130      	bne.n	3400aa9e <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
3400aa3c:	687b      	ldr	r3, [r7, #4]
3400aa3e:	689b      	ldr	r3, [r3, #8]
3400aa40:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400aa42:	697b      	ldr	r3, [r7, #20]
3400aa44:	005b      	lsls	r3, r3, #1
3400aa46:	2203      	movs	r2, #3
3400aa48:	fa02 f303 	lsl.w	r3, r2, r3
3400aa4c:	43db      	mvns	r3, r3
3400aa4e:	693a      	ldr	r2, [r7, #16]
3400aa50:	4013      	ands	r3, r2
3400aa52:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400aa54:	683b      	ldr	r3, [r7, #0]
3400aa56:	68da      	ldr	r2, [r3, #12]
3400aa58:	697b      	ldr	r3, [r7, #20]
3400aa5a:	005b      	lsls	r3, r3, #1
3400aa5c:	fa02 f303 	lsl.w	r3, r2, r3
3400aa60:	693a      	ldr	r2, [r7, #16]
3400aa62:	4313      	orrs	r3, r2
3400aa64:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
3400aa66:	687b      	ldr	r3, [r7, #4]
3400aa68:	693a      	ldr	r2, [r7, #16]
3400aa6a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
3400aa6c:	687b      	ldr	r3, [r7, #4]
3400aa6e:	685b      	ldr	r3, [r3, #4]
3400aa70:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
3400aa72:	2201      	movs	r2, #1
3400aa74:	697b      	ldr	r3, [r7, #20]
3400aa76:	fa02 f303 	lsl.w	r3, r2, r3
3400aa7a:	43db      	mvns	r3, r3
3400aa7c:	693a      	ldr	r2, [r7, #16]
3400aa7e:	4013      	ands	r3, r2
3400aa80:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
3400aa82:	683b      	ldr	r3, [r7, #0]
3400aa84:	685b      	ldr	r3, [r3, #4]
3400aa86:	091b      	lsrs	r3, r3, #4
3400aa88:	f003 0201 	and.w	r2, r3, #1
3400aa8c:	697b      	ldr	r3, [r7, #20]
3400aa8e:	fa02 f303 	lsl.w	r3, r2, r3
3400aa92:	693a      	ldr	r2, [r7, #16]
3400aa94:	4313      	orrs	r3, r2
3400aa96:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
3400aa98:	687b      	ldr	r3, [r7, #4]
3400aa9a:	693a      	ldr	r2, [r7, #16]
3400aa9c:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400aa9e:	683b      	ldr	r3, [r7, #0]
3400aaa0:	685b      	ldr	r3, [r3, #4]
3400aaa2:	f003 0303 	and.w	r3, r3, #3
3400aaa6:	2b03      	cmp	r3, #3
3400aaa8:	d109      	bne.n	3400aabe <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3400aaaa:	683b      	ldr	r3, [r7, #0]
3400aaac:	685b      	ldr	r3, [r3, #4]
3400aaae:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
3400aab2:	2b03      	cmp	r3, #3
3400aab4:	d11b      	bne.n	3400aaee <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
3400aab6:	683b      	ldr	r3, [r7, #0]
3400aab8:	689b      	ldr	r3, [r3, #8]
3400aaba:	2b01      	cmp	r3, #1
3400aabc:	d017      	beq.n	3400aaee <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
3400aabe:	687b      	ldr	r3, [r7, #4]
3400aac0:	68db      	ldr	r3, [r3, #12]
3400aac2:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
3400aac4:	697b      	ldr	r3, [r7, #20]
3400aac6:	005b      	lsls	r3, r3, #1
3400aac8:	2203      	movs	r2, #3
3400aaca:	fa02 f303 	lsl.w	r3, r2, r3
3400aace:	43db      	mvns	r3, r3
3400aad0:	693a      	ldr	r2, [r7, #16]
3400aad2:	4013      	ands	r3, r2
3400aad4:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
3400aad6:	683b      	ldr	r3, [r7, #0]
3400aad8:	689a      	ldr	r2, [r3, #8]
3400aada:	697b      	ldr	r3, [r7, #20]
3400aadc:	005b      	lsls	r3, r3, #1
3400aade:	fa02 f303 	lsl.w	r3, r2, r3
3400aae2:	693a      	ldr	r2, [r7, #16]
3400aae4:	4313      	orrs	r3, r2
3400aae6:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
3400aae8:	687b      	ldr	r3, [r7, #4]
3400aaea:	693a      	ldr	r2, [r7, #16]
3400aaec:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
3400aaee:	683b      	ldr	r3, [r7, #0]
3400aaf0:	685b      	ldr	r3, [r3, #4]
3400aaf2:	f003 0303 	and.w	r3, r3, #3
3400aaf6:	2b02      	cmp	r3, #2
3400aaf8:	d123      	bne.n	3400ab42 <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
3400aafa:	697b      	ldr	r3, [r7, #20]
3400aafc:	08da      	lsrs	r2, r3, #3
3400aafe:	687b      	ldr	r3, [r7, #4]
3400ab00:	3208      	adds	r2, #8
3400ab02:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3400ab06:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3400ab08:	697b      	ldr	r3, [r7, #20]
3400ab0a:	f003 0307 	and.w	r3, r3, #7
3400ab0e:	009b      	lsls	r3, r3, #2
3400ab10:	220f      	movs	r2, #15
3400ab12:	fa02 f303 	lsl.w	r3, r2, r3
3400ab16:	43db      	mvns	r3, r3
3400ab18:	693a      	ldr	r2, [r7, #16]
3400ab1a:	4013      	ands	r3, r2
3400ab1c:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
3400ab1e:	683b      	ldr	r3, [r7, #0]
3400ab20:	691a      	ldr	r2, [r3, #16]
3400ab22:	697b      	ldr	r3, [r7, #20]
3400ab24:	f003 0307 	and.w	r3, r3, #7
3400ab28:	009b      	lsls	r3, r3, #2
3400ab2a:	fa02 f303 	lsl.w	r3, r2, r3
3400ab2e:	693a      	ldr	r2, [r7, #16]
3400ab30:	4313      	orrs	r3, r2
3400ab32:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
3400ab34:	697b      	ldr	r3, [r7, #20]
3400ab36:	08da      	lsrs	r2, r3, #3
3400ab38:	687b      	ldr	r3, [r7, #4]
3400ab3a:	3208      	adds	r2, #8
3400ab3c:	6939      	ldr	r1, [r7, #16]
3400ab3e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
3400ab42:	687b      	ldr	r3, [r7, #4]
3400ab44:	681b      	ldr	r3, [r3, #0]
3400ab46:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
3400ab48:	697b      	ldr	r3, [r7, #20]
3400ab4a:	005b      	lsls	r3, r3, #1
3400ab4c:	2203      	movs	r2, #3
3400ab4e:	fa02 f303 	lsl.w	r3, r2, r3
3400ab52:	43db      	mvns	r3, r3
3400ab54:	693a      	ldr	r2, [r7, #16]
3400ab56:	4013      	ands	r3, r2
3400ab58:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
3400ab5a:	683b      	ldr	r3, [r7, #0]
3400ab5c:	685b      	ldr	r3, [r3, #4]
3400ab5e:	f003 0203 	and.w	r2, r3, #3
3400ab62:	697b      	ldr	r3, [r7, #20]
3400ab64:	005b      	lsls	r3, r3, #1
3400ab66:	fa02 f303 	lsl.w	r3, r2, r3
3400ab6a:	693a      	ldr	r2, [r7, #16]
3400ab6c:	4313      	orrs	r3, r2
3400ab6e:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
3400ab70:	687b      	ldr	r3, [r7, #4]
3400ab72:	693a      	ldr	r2, [r7, #16]
3400ab74:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
3400ab76:	683b      	ldr	r3, [r7, #0]
3400ab78:	685b      	ldr	r3, [r3, #4]
3400ab7a:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
3400ab7e:	2b00      	cmp	r3, #0
3400ab80:	f000 80c2 	beq.w	3400ad08 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
3400ab84:	4a69      	ldr	r2, [pc, #420]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ab86:	697b      	ldr	r3, [r7, #20]
3400ab88:	089b      	lsrs	r3, r3, #2
3400ab8a:	3318      	adds	r3, #24
3400ab8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400ab90:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400ab92:	697b      	ldr	r3, [r7, #20]
3400ab94:	f003 0303 	and.w	r3, r3, #3
3400ab98:	00db      	lsls	r3, r3, #3
3400ab9a:	220f      	movs	r2, #15
3400ab9c:	fa02 f303 	lsl.w	r3, r2, r3
3400aba0:	43db      	mvns	r3, r3
3400aba2:	693a      	ldr	r2, [r7, #16]
3400aba4:	4013      	ands	r3, r2
3400aba6:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400aba8:	687b      	ldr	r3, [r7, #4]
3400abaa:	4a61      	ldr	r2, [pc, #388]	@ (3400ad30 <HAL_GPIO_Init+0x334>)
3400abac:	4293      	cmp	r3, r2
3400abae:	d043      	beq.n	3400ac38 <HAL_GPIO_Init+0x23c>
3400abb0:	687b      	ldr	r3, [r7, #4]
3400abb2:	4a60      	ldr	r2, [pc, #384]	@ (3400ad34 <HAL_GPIO_Init+0x338>)
3400abb4:	4293      	cmp	r3, r2
3400abb6:	d03d      	beq.n	3400ac34 <HAL_GPIO_Init+0x238>
3400abb8:	687b      	ldr	r3, [r7, #4]
3400abba:	4a5f      	ldr	r2, [pc, #380]	@ (3400ad38 <HAL_GPIO_Init+0x33c>)
3400abbc:	4293      	cmp	r3, r2
3400abbe:	d037      	beq.n	3400ac30 <HAL_GPIO_Init+0x234>
3400abc0:	687b      	ldr	r3, [r7, #4]
3400abc2:	4a5e      	ldr	r2, [pc, #376]	@ (3400ad3c <HAL_GPIO_Init+0x340>)
3400abc4:	4293      	cmp	r3, r2
3400abc6:	d031      	beq.n	3400ac2c <HAL_GPIO_Init+0x230>
3400abc8:	687b      	ldr	r3, [r7, #4]
3400abca:	4a5d      	ldr	r2, [pc, #372]	@ (3400ad40 <HAL_GPIO_Init+0x344>)
3400abcc:	4293      	cmp	r3, r2
3400abce:	d02b      	beq.n	3400ac28 <HAL_GPIO_Init+0x22c>
3400abd0:	687b      	ldr	r3, [r7, #4]
3400abd2:	4a5c      	ldr	r2, [pc, #368]	@ (3400ad44 <HAL_GPIO_Init+0x348>)
3400abd4:	4293      	cmp	r3, r2
3400abd6:	d025      	beq.n	3400ac24 <HAL_GPIO_Init+0x228>
3400abd8:	687b      	ldr	r3, [r7, #4]
3400abda:	4a5b      	ldr	r2, [pc, #364]	@ (3400ad48 <HAL_GPIO_Init+0x34c>)
3400abdc:	4293      	cmp	r3, r2
3400abde:	d01f      	beq.n	3400ac20 <HAL_GPIO_Init+0x224>
3400abe0:	687b      	ldr	r3, [r7, #4]
3400abe2:	4a5a      	ldr	r2, [pc, #360]	@ (3400ad4c <HAL_GPIO_Init+0x350>)
3400abe4:	4293      	cmp	r3, r2
3400abe6:	d019      	beq.n	3400ac1c <HAL_GPIO_Init+0x220>
3400abe8:	687b      	ldr	r3, [r7, #4]
3400abea:	4a59      	ldr	r2, [pc, #356]	@ (3400ad50 <HAL_GPIO_Init+0x354>)
3400abec:	4293      	cmp	r3, r2
3400abee:	d013      	beq.n	3400ac18 <HAL_GPIO_Init+0x21c>
3400abf0:	687b      	ldr	r3, [r7, #4]
3400abf2:	4a58      	ldr	r2, [pc, #352]	@ (3400ad54 <HAL_GPIO_Init+0x358>)
3400abf4:	4293      	cmp	r3, r2
3400abf6:	d00d      	beq.n	3400ac14 <HAL_GPIO_Init+0x218>
3400abf8:	687b      	ldr	r3, [r7, #4]
3400abfa:	4a57      	ldr	r2, [pc, #348]	@ (3400ad58 <HAL_GPIO_Init+0x35c>)
3400abfc:	4293      	cmp	r3, r2
3400abfe:	d007      	beq.n	3400ac10 <HAL_GPIO_Init+0x214>
3400ac00:	687b      	ldr	r3, [r7, #4]
3400ac02:	4a56      	ldr	r2, [pc, #344]	@ (3400ad5c <HAL_GPIO_Init+0x360>)
3400ac04:	4293      	cmp	r3, r2
3400ac06:	d101      	bne.n	3400ac0c <HAL_GPIO_Init+0x210>
3400ac08:	230b      	movs	r3, #11
3400ac0a:	e016      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac0c:	2310      	movs	r3, #16
3400ac0e:	e014      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac10:	230a      	movs	r3, #10
3400ac12:	e012      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac14:	2309      	movs	r3, #9
3400ac16:	e010      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac18:	2308      	movs	r3, #8
3400ac1a:	e00e      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac1c:	2307      	movs	r3, #7
3400ac1e:	e00c      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac20:	2306      	movs	r3, #6
3400ac22:	e00a      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac24:	2305      	movs	r3, #5
3400ac26:	e008      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac28:	2304      	movs	r3, #4
3400ac2a:	e006      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac2c:	2303      	movs	r3, #3
3400ac2e:	e004      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac30:	2302      	movs	r3, #2
3400ac32:	e002      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac34:	2301      	movs	r3, #1
3400ac36:	e000      	b.n	3400ac3a <HAL_GPIO_Init+0x23e>
3400ac38:	2300      	movs	r3, #0
3400ac3a:	697a      	ldr	r2, [r7, #20]
3400ac3c:	f002 0203 	and.w	r2, r2, #3
3400ac40:	00d2      	lsls	r2, r2, #3
3400ac42:	4093      	lsls	r3, r2
3400ac44:	693a      	ldr	r2, [r7, #16]
3400ac46:	4313      	orrs	r3, r2
3400ac48:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
3400ac4a:	4938      	ldr	r1, [pc, #224]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ac4c:	697b      	ldr	r3, [r7, #20]
3400ac4e:	089b      	lsrs	r3, r3, #2
3400ac50:	3318      	adds	r3, #24
3400ac52:	693a      	ldr	r2, [r7, #16]
3400ac54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
3400ac58:	4b34      	ldr	r3, [pc, #208]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ac5a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400ac5e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400ac60:	68fb      	ldr	r3, [r7, #12]
3400ac62:	43db      	mvns	r3, r3
3400ac64:	693a      	ldr	r2, [r7, #16]
3400ac66:	4013      	ands	r3, r2
3400ac68:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
3400ac6a:	683b      	ldr	r3, [r7, #0]
3400ac6c:	685b      	ldr	r3, [r3, #4]
3400ac6e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400ac72:	2b00      	cmp	r3, #0
3400ac74:	d003      	beq.n	3400ac7e <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
3400ac76:	693a      	ldr	r2, [r7, #16]
3400ac78:	68fb      	ldr	r3, [r7, #12]
3400ac7a:	4313      	orrs	r3, r2
3400ac7c:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
3400ac7e:	4a2b      	ldr	r2, [pc, #172]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ac80:	693b      	ldr	r3, [r7, #16]
3400ac82:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
3400ac86:	4b29      	ldr	r3, [pc, #164]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ac88:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400ac8c:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400ac8e:	68fb      	ldr	r3, [r7, #12]
3400ac90:	43db      	mvns	r3, r3
3400ac92:	693a      	ldr	r2, [r7, #16]
3400ac94:	4013      	ands	r3, r2
3400ac96:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
3400ac98:	683b      	ldr	r3, [r7, #0]
3400ac9a:	685b      	ldr	r3, [r3, #4]
3400ac9c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400aca0:	2b00      	cmp	r3, #0
3400aca2:	d003      	beq.n	3400acac <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
3400aca4:	693a      	ldr	r2, [r7, #16]
3400aca6:	68fb      	ldr	r3, [r7, #12]
3400aca8:	4313      	orrs	r3, r2
3400acaa:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
3400acac:	4a1f      	ldr	r2, [pc, #124]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400acae:	693b      	ldr	r3, [r7, #16]
3400acb0:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
3400acb4:	4b1d      	ldr	r3, [pc, #116]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400acb6:	681b      	ldr	r3, [r3, #0]
3400acb8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400acba:	68fb      	ldr	r3, [r7, #12]
3400acbc:	43db      	mvns	r3, r3
3400acbe:	693a      	ldr	r2, [r7, #16]
3400acc0:	4013      	ands	r3, r2
3400acc2:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
3400acc4:	683b      	ldr	r3, [r7, #0]
3400acc6:	685b      	ldr	r3, [r3, #4]
3400acc8:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400accc:	2b00      	cmp	r3, #0
3400acce:	d003      	beq.n	3400acd8 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
3400acd0:	693a      	ldr	r2, [r7, #16]
3400acd2:	68fb      	ldr	r3, [r7, #12]
3400acd4:	4313      	orrs	r3, r2
3400acd6:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
3400acd8:	4a14      	ldr	r2, [pc, #80]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400acda:	693b      	ldr	r3, [r7, #16]
3400acdc:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
3400acde:	4b13      	ldr	r3, [pc, #76]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ace0:	685b      	ldr	r3, [r3, #4]
3400ace2:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
3400ace4:	68fb      	ldr	r3, [r7, #12]
3400ace6:	43db      	mvns	r3, r3
3400ace8:	693a      	ldr	r2, [r7, #16]
3400acea:	4013      	ands	r3, r2
3400acec:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
3400acee:	683b      	ldr	r3, [r7, #0]
3400acf0:	685b      	ldr	r3, [r3, #4]
3400acf2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400acf6:	2b00      	cmp	r3, #0
3400acf8:	d003      	beq.n	3400ad02 <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
3400acfa:	693a      	ldr	r2, [r7, #16]
3400acfc:	68fb      	ldr	r3, [r7, #12]
3400acfe:	4313      	orrs	r3, r2
3400ad00:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
3400ad02:	4a0a      	ldr	r2, [pc, #40]	@ (3400ad2c <HAL_GPIO_Init+0x330>)
3400ad04:	693b      	ldr	r3, [r7, #16]
3400ad06:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
3400ad08:	697b      	ldr	r3, [r7, #20]
3400ad0a:	3301      	adds	r3, #1
3400ad0c:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
3400ad0e:	683b      	ldr	r3, [r7, #0]
3400ad10:	681a      	ldr	r2, [r3, #0]
3400ad12:	697b      	ldr	r3, [r7, #20]
3400ad14:	fa22 f303 	lsr.w	r3, r2, r3
3400ad18:	2b00      	cmp	r3, #0
3400ad1a:	f47f ae77 	bne.w	3400aa0c <HAL_GPIO_Init+0x10>
  }
}
3400ad1e:	bf00      	nop
3400ad20:	bf00      	nop
3400ad22:	371c      	adds	r7, #28
3400ad24:	46bd      	mov	sp, r7
3400ad26:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ad2a:	4770      	bx	lr
3400ad2c:	56025000 	.word	0x56025000
3400ad30:	56020000 	.word	0x56020000
3400ad34:	56020400 	.word	0x56020400
3400ad38:	56020800 	.word	0x56020800
3400ad3c:	56020c00 	.word	0x56020c00
3400ad40:	56021000 	.word	0x56021000
3400ad44:	56021400 	.word	0x56021400
3400ad48:	56021800 	.word	0x56021800
3400ad4c:	56021c00 	.word	0x56021c00
3400ad50:	56023400 	.word	0x56023400
3400ad54:	56023800 	.word	0x56023800
3400ad58:	56023c00 	.word	0x56023c00
3400ad5c:	56024000 	.word	0x56024000

3400ad60 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
3400ad60:	b480      	push	{r7}
3400ad62:	b087      	sub	sp, #28
3400ad64:	af00      	add	r7, sp, #0
3400ad66:	6078      	str	r0, [r7, #4]
3400ad68:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
3400ad6a:	2300      	movs	r3, #0
3400ad6c:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
3400ad6e:	e10f      	b.n	3400af90 <HAL_GPIO_DeInit+0x230>
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1uL << position);
3400ad70:	2201      	movs	r2, #1
3400ad72:	697b      	ldr	r3, [r7, #20]
3400ad74:	fa02 f303 	lsl.w	r3, r2, r3
3400ad78:	683a      	ldr	r2, [r7, #0]
3400ad7a:	4013      	ands	r3, r2
3400ad7c:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00u)
3400ad7e:	693b      	ldr	r3, [r7, #16]
3400ad80:	2b00      	cmp	r3, #0
3400ad82:	f000 8102 	beq.w	3400af8a <HAL_GPIO_DeInit+0x22a>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = EXTI->EXTICR[position >> 2u];
3400ad86:	4a89      	ldr	r2, [pc, #548]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ad88:	697b      	ldr	r3, [r7, #20]
3400ad8a:	089b      	lsrs	r3, r3, #2
3400ad8c:	3318      	adds	r3, #24
3400ad8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400ad92:	60fb      	str	r3, [r7, #12]
      tmp &= (0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
3400ad94:	697b      	ldr	r3, [r7, #20]
3400ad96:	f003 0303 	and.w	r3, r3, #3
3400ad9a:	00db      	lsls	r3, r3, #3
3400ad9c:	220f      	movs	r2, #15
3400ad9e:	fa02 f303 	lsl.w	r3, r2, r3
3400ada2:	68fa      	ldr	r2, [r7, #12]
3400ada4:	4013      	ands	r3, r2
3400ada6:	60fb      	str	r3, [r7, #12]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos)))
3400ada8:	687b      	ldr	r3, [r7, #4]
3400adaa:	4a81      	ldr	r2, [pc, #516]	@ (3400afb0 <HAL_GPIO_DeInit+0x250>)
3400adac:	4293      	cmp	r3, r2
3400adae:	d043      	beq.n	3400ae38 <HAL_GPIO_DeInit+0xd8>
3400adb0:	687b      	ldr	r3, [r7, #4]
3400adb2:	4a80      	ldr	r2, [pc, #512]	@ (3400afb4 <HAL_GPIO_DeInit+0x254>)
3400adb4:	4293      	cmp	r3, r2
3400adb6:	d03d      	beq.n	3400ae34 <HAL_GPIO_DeInit+0xd4>
3400adb8:	687b      	ldr	r3, [r7, #4]
3400adba:	4a7f      	ldr	r2, [pc, #508]	@ (3400afb8 <HAL_GPIO_DeInit+0x258>)
3400adbc:	4293      	cmp	r3, r2
3400adbe:	d037      	beq.n	3400ae30 <HAL_GPIO_DeInit+0xd0>
3400adc0:	687b      	ldr	r3, [r7, #4]
3400adc2:	4a7e      	ldr	r2, [pc, #504]	@ (3400afbc <HAL_GPIO_DeInit+0x25c>)
3400adc4:	4293      	cmp	r3, r2
3400adc6:	d031      	beq.n	3400ae2c <HAL_GPIO_DeInit+0xcc>
3400adc8:	687b      	ldr	r3, [r7, #4]
3400adca:	4a7d      	ldr	r2, [pc, #500]	@ (3400afc0 <HAL_GPIO_DeInit+0x260>)
3400adcc:	4293      	cmp	r3, r2
3400adce:	d02b      	beq.n	3400ae28 <HAL_GPIO_DeInit+0xc8>
3400add0:	687b      	ldr	r3, [r7, #4]
3400add2:	4a7c      	ldr	r2, [pc, #496]	@ (3400afc4 <HAL_GPIO_DeInit+0x264>)
3400add4:	4293      	cmp	r3, r2
3400add6:	d025      	beq.n	3400ae24 <HAL_GPIO_DeInit+0xc4>
3400add8:	687b      	ldr	r3, [r7, #4]
3400adda:	4a7b      	ldr	r2, [pc, #492]	@ (3400afc8 <HAL_GPIO_DeInit+0x268>)
3400addc:	4293      	cmp	r3, r2
3400adde:	d01f      	beq.n	3400ae20 <HAL_GPIO_DeInit+0xc0>
3400ade0:	687b      	ldr	r3, [r7, #4]
3400ade2:	4a7a      	ldr	r2, [pc, #488]	@ (3400afcc <HAL_GPIO_DeInit+0x26c>)
3400ade4:	4293      	cmp	r3, r2
3400ade6:	d019      	beq.n	3400ae1c <HAL_GPIO_DeInit+0xbc>
3400ade8:	687b      	ldr	r3, [r7, #4]
3400adea:	4a79      	ldr	r2, [pc, #484]	@ (3400afd0 <HAL_GPIO_DeInit+0x270>)
3400adec:	4293      	cmp	r3, r2
3400adee:	d013      	beq.n	3400ae18 <HAL_GPIO_DeInit+0xb8>
3400adf0:	687b      	ldr	r3, [r7, #4]
3400adf2:	4a78      	ldr	r2, [pc, #480]	@ (3400afd4 <HAL_GPIO_DeInit+0x274>)
3400adf4:	4293      	cmp	r3, r2
3400adf6:	d00d      	beq.n	3400ae14 <HAL_GPIO_DeInit+0xb4>
3400adf8:	687b      	ldr	r3, [r7, #4]
3400adfa:	4a77      	ldr	r2, [pc, #476]	@ (3400afd8 <HAL_GPIO_DeInit+0x278>)
3400adfc:	4293      	cmp	r3, r2
3400adfe:	d007      	beq.n	3400ae10 <HAL_GPIO_DeInit+0xb0>
3400ae00:	687b      	ldr	r3, [r7, #4]
3400ae02:	4a76      	ldr	r2, [pc, #472]	@ (3400afdc <HAL_GPIO_DeInit+0x27c>)
3400ae04:	4293      	cmp	r3, r2
3400ae06:	d101      	bne.n	3400ae0c <HAL_GPIO_DeInit+0xac>
3400ae08:	230b      	movs	r3, #11
3400ae0a:	e016      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae0c:	2310      	movs	r3, #16
3400ae0e:	e014      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae10:	230a      	movs	r3, #10
3400ae12:	e012      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae14:	2309      	movs	r3, #9
3400ae16:	e010      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae18:	2308      	movs	r3, #8
3400ae1a:	e00e      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae1c:	2307      	movs	r3, #7
3400ae1e:	e00c      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae20:	2306      	movs	r3, #6
3400ae22:	e00a      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae24:	2305      	movs	r3, #5
3400ae26:	e008      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae28:	2304      	movs	r3, #4
3400ae2a:	e006      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae2c:	2303      	movs	r3, #3
3400ae2e:	e004      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae30:	2302      	movs	r3, #2
3400ae32:	e002      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae34:	2301      	movs	r3, #1
3400ae36:	e000      	b.n	3400ae3a <HAL_GPIO_DeInit+0xda>
3400ae38:	2300      	movs	r3, #0
3400ae3a:	697a      	ldr	r2, [r7, #20]
3400ae3c:	f002 0203 	and.w	r2, r2, #3
3400ae40:	00d2      	lsls	r2, r2, #3
3400ae42:	4093      	lsls	r3, r2
3400ae44:	68fa      	ldr	r2, [r7, #12]
3400ae46:	429a      	cmp	r2, r3
3400ae48:	d136      	bne.n	3400aeb8 <HAL_GPIO_DeInit+0x158>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
3400ae4a:	4b58      	ldr	r3, [pc, #352]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae4c:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
3400ae50:	693b      	ldr	r3, [r7, #16]
3400ae52:	43db      	mvns	r3, r3
3400ae54:	4955      	ldr	r1, [pc, #340]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae56:	4013      	ands	r3, r2
3400ae58:	f8c1 3080 	str.w	r3, [r1, #128]	@ 0x80
        EXTI->EMR1 &= ~(iocurrent);
3400ae5c:	4b53      	ldr	r3, [pc, #332]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae5e:	f8d3 2084 	ldr.w	r2, [r3, #132]	@ 0x84
3400ae62:	693b      	ldr	r3, [r7, #16]
3400ae64:	43db      	mvns	r3, r3
3400ae66:	4951      	ldr	r1, [pc, #324]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae68:	4013      	ands	r3, r2
3400ae6a:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        EXTI->RTSR1 &= ~(iocurrent);
3400ae6e:	4b4f      	ldr	r3, [pc, #316]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae70:	681a      	ldr	r2, [r3, #0]
3400ae72:	693b      	ldr	r3, [r7, #16]
3400ae74:	43db      	mvns	r3, r3
3400ae76:	494d      	ldr	r1, [pc, #308]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae78:	4013      	ands	r3, r2
3400ae7a:	600b      	str	r3, [r1, #0]
        EXTI->FTSR1 &= ~(iocurrent);
3400ae7c:	4b4b      	ldr	r3, [pc, #300]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae7e:	685a      	ldr	r2, [r3, #4]
3400ae80:	693b      	ldr	r3, [r7, #16]
3400ae82:	43db      	mvns	r3, r3
3400ae84:	4949      	ldr	r1, [pc, #292]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae86:	4013      	ands	r3, r2
3400ae88:	604b      	str	r3, [r1, #4]

        tmp = 0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos);
3400ae8a:	697b      	ldr	r3, [r7, #20]
3400ae8c:	f003 0303 	and.w	r3, r3, #3
3400ae90:	00db      	lsls	r3, r3, #3
3400ae92:	220f      	movs	r2, #15
3400ae94:	fa02 f303 	lsl.w	r3, r2, r3
3400ae98:	60fb      	str	r3, [r7, #12]
        EXTI->EXTICR[position >> 2u] &= ~tmp;
3400ae9a:	4a44      	ldr	r2, [pc, #272]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400ae9c:	697b      	ldr	r3, [r7, #20]
3400ae9e:	089b      	lsrs	r3, r3, #2
3400aea0:	3318      	adds	r3, #24
3400aea2:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
3400aea6:	68fb      	ldr	r3, [r7, #12]
3400aea8:	43da      	mvns	r2, r3
3400aeaa:	4840      	ldr	r0, [pc, #256]	@ (3400afac <HAL_GPIO_DeInit+0x24c>)
3400aeac:	697b      	ldr	r3, [r7, #20]
3400aeae:	089b      	lsrs	r3, r3, #2
3400aeb0:	400a      	ands	r2, r1
3400aeb2:	3318      	adds	r3, #24
3400aeb4:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
3400aeb8:	687b      	ldr	r3, [r7, #4]
3400aeba:	681a      	ldr	r2, [r3, #0]
3400aebc:	697b      	ldr	r3, [r7, #20]
3400aebe:	005b      	lsls	r3, r3, #1
3400aec0:	2103      	movs	r1, #3
3400aec2:	fa01 f303 	lsl.w	r3, r1, r3
3400aec6:	431a      	orrs	r2, r3
3400aec8:	687b      	ldr	r3, [r7, #4]
3400aeca:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos)) ;
3400aecc:	697b      	ldr	r3, [r7, #20]
3400aece:	08da      	lsrs	r2, r3, #3
3400aed0:	687b      	ldr	r3, [r7, #4]
3400aed2:	3208      	adds	r2, #8
3400aed4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3400aed8:	697b      	ldr	r3, [r7, #20]
3400aeda:	f003 0307 	and.w	r3, r3, #7
3400aede:	009b      	lsls	r3, r3, #2
3400aee0:	220f      	movs	r2, #15
3400aee2:	fa02 f303 	lsl.w	r3, r2, r3
3400aee6:	43db      	mvns	r3, r3
3400aee8:	697a      	ldr	r2, [r7, #20]
3400aeea:	08d2      	lsrs	r2, r2, #3
3400aeec:	4019      	ands	r1, r3
3400aeee:	687b      	ldr	r3, [r7, #4]
3400aef0:	3208      	adds	r2, #8
3400aef2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
3400aef6:	687b      	ldr	r3, [r7, #4]
3400aef8:	689a      	ldr	r2, [r3, #8]
3400aefa:	697b      	ldr	r3, [r7, #20]
3400aefc:	005b      	lsls	r3, r3, #1
3400aefe:	2103      	movs	r1, #3
3400af00:	fa01 f303 	lsl.w	r3, r1, r3
3400af04:	43db      	mvns	r3, r3
3400af06:	401a      	ands	r2, r3
3400af08:	687b      	ldr	r3, [r7, #4]
3400af0a:	609a      	str	r2, [r3, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
3400af0c:	687b      	ldr	r3, [r7, #4]
3400af0e:	685a      	ldr	r2, [r3, #4]
3400af10:	2101      	movs	r1, #1
3400af12:	697b      	ldr	r3, [r7, #20]
3400af14:	fa01 f303 	lsl.w	r3, r1, r3
3400af18:	43db      	mvns	r3, r3
3400af1a:	401a      	ands	r2, r3
3400af1c:	687b      	ldr	r3, [r7, #4]
3400af1e:	605a      	str	r2, [r3, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
3400af20:	687b      	ldr	r3, [r7, #4]
3400af22:	68da      	ldr	r2, [r3, #12]
3400af24:	697b      	ldr	r3, [r7, #20]
3400af26:	005b      	lsls	r3, r3, #1
3400af28:	2103      	movs	r1, #3
3400af2a:	fa01 f303 	lsl.w	r3, r1, r3
3400af2e:	43db      	mvns	r3, r3
3400af30:	401a      	ands	r2, r3
3400af32:	687b      	ldr	r3, [r7, #4]
3400af34:	60da      	str	r2, [r3, #12]

      /* Reset delay settings for the current IO */
      GPIOx->DELAYR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_DELAYRL_DLY1_Pos)) ;
3400af36:	697b      	ldr	r3, [r7, #20]
3400af38:	08da      	lsrs	r2, r3, #3
3400af3a:	687b      	ldr	r3, [r7, #4]
3400af3c:	3210      	adds	r2, #16
3400af3e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3400af42:	697b      	ldr	r3, [r7, #20]
3400af44:	f003 0307 	and.w	r3, r3, #7
3400af48:	009b      	lsls	r3, r3, #2
3400af4a:	220f      	movs	r2, #15
3400af4c:	fa02 f303 	lsl.w	r3, r2, r3
3400af50:	43db      	mvns	r3, r3
3400af52:	697a      	ldr	r2, [r7, #20]
3400af54:	08d2      	lsrs	r2, r2, #3
3400af56:	4019      	ands	r1, r3
3400af58:	687b      	ldr	r3, [r7, #4]
3400af5a:	3210      	adds	r2, #16
3400af5c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Reset control settings for the current IO */
      GPIOx->ADVCFGR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * GPIO_ADVCFGRL_1_Pos)) ;
3400af60:	697b      	ldr	r3, [r7, #20]
3400af62:	08da      	lsrs	r2, r3, #3
3400af64:	687b      	ldr	r3, [r7, #4]
3400af66:	3212      	adds	r2, #18
3400af68:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
3400af6c:	697b      	ldr	r3, [r7, #20]
3400af6e:	f003 0307 	and.w	r3, r3, #7
3400af72:	009b      	lsls	r3, r3, #2
3400af74:	220f      	movs	r2, #15
3400af76:	fa02 f303 	lsl.w	r3, r2, r3
3400af7a:	43db      	mvns	r3, r3
3400af7c:	697a      	ldr	r2, [r7, #20]
3400af7e:	08d2      	lsrs	r2, r2, #3
3400af80:	4019      	ands	r1, r3
3400af82:	687b      	ldr	r3, [r7, #4]
3400af84:	3212      	adds	r2, #18
3400af86:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    position++;
3400af8a:	697b      	ldr	r3, [r7, #20]
3400af8c:	3301      	adds	r3, #1
3400af8e:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00u)
3400af90:	683a      	ldr	r2, [r7, #0]
3400af92:	697b      	ldr	r3, [r7, #20]
3400af94:	fa22 f303 	lsr.w	r3, r2, r3
3400af98:	2b00      	cmp	r3, #0
3400af9a:	f47f aee9 	bne.w	3400ad70 <HAL_GPIO_DeInit+0x10>
  }
}
3400af9e:	bf00      	nop
3400afa0:	bf00      	nop
3400afa2:	371c      	adds	r7, #28
3400afa4:	46bd      	mov	sp, r7
3400afa6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400afaa:	4770      	bx	lr
3400afac:	56025000 	.word	0x56025000
3400afb0:	56020000 	.word	0x56020000
3400afb4:	56020400 	.word	0x56020400
3400afb8:	56020800 	.word	0x56020800
3400afbc:	56020c00 	.word	0x56020c00
3400afc0:	56021000 	.word	0x56021000
3400afc4:	56021400 	.word	0x56021400
3400afc8:	56021800 	.word	0x56021800
3400afcc:	56021c00 	.word	0x56021c00
3400afd0:	56023400 	.word	0x56023400
3400afd4:	56023800 	.word	0x56023800
3400afd8:	56023c00 	.word	0x56023c00
3400afdc:	56024000 	.word	0x56024000

3400afe0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
3400afe0:	b480      	push	{r7}
3400afe2:	b083      	sub	sp, #12
3400afe4:	af00      	add	r7, sp, #0
3400afe6:	6078      	str	r0, [r7, #4]
3400afe8:	460b      	mov	r3, r1
3400afea:	807b      	strh	r3, [r7, #2]
3400afec:	4613      	mov	r3, r2
3400afee:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
3400aff0:	787b      	ldrb	r3, [r7, #1]
3400aff2:	2b00      	cmp	r3, #0
3400aff4:	d003      	beq.n	3400affe <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
3400aff6:	887a      	ldrh	r2, [r7, #2]
3400aff8:	687b      	ldr	r3, [r7, #4]
3400affa:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
3400affc:	e002      	b.n	3400b004 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
3400affe:	887a      	ldrh	r2, [r7, #2]
3400b000:	687b      	ldr	r3, [r7, #4]
3400b002:	629a      	str	r2, [r3, #40]	@ 0x28
}
3400b004:	bf00      	nop
3400b006:	370c      	adds	r7, #12
3400b008:	46bd      	mov	sp, r7
3400b00a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b00e:	4770      	bx	lr

3400b010 <HAL_GPIO_ConfigPinAttributes>:
  *            @arg @ref GPIO_PIN_SEC          Secure-only access
  *            @arg @ref GPIO_PIN_NSEC         Secure/Non-secure access
  * @retval None.
  */
void HAL_GPIO_ConfigPinAttributes(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, uint32_t PinAttributes)
{
3400b010:	b480      	push	{r7}
3400b012:	b087      	sub	sp, #28
3400b014:	af00      	add	r7, sp, #0
3400b016:	60f8      	str	r0, [r7, #12]
3400b018:	460b      	mov	r3, r1
3400b01a:	607a      	str	r2, [r7, #4]
3400b01c:	817b      	strh	r3, [r7, #10]
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ATTRIBUTES(PinAttributes));

#if defined CPU_IN_SECURE_STATE
  /* Configure the port pins */
  sec = GPIOx->SECCFGR;
3400b01e:	68fb      	ldr	r3, [r7, #12]
3400b020:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400b022:	617b      	str	r3, [r7, #20]
  if ((PinAttributes & GPIO_PIN_SEC) == GPIO_PIN_SEC)
3400b024:	687a      	ldr	r2, [r7, #4]
3400b026:	f240 1301 	movw	r3, #257	@ 0x101
3400b02a:	4013      	ands	r3, r2
3400b02c:	f240 1201 	movw	r2, #257	@ 0x101
3400b030:	4293      	cmp	r3, r2
3400b032:	d104      	bne.n	3400b03e <HAL_GPIO_ConfigPinAttributes+0x2e>
  {
    sec |= (uint32_t)GPIO_Pin;
3400b034:	897b      	ldrh	r3, [r7, #10]
3400b036:	697a      	ldr	r2, [r7, #20]
3400b038:	4313      	orrs	r3, r2
3400b03a:	617b      	str	r3, [r7, #20]
3400b03c:	e009      	b.n	3400b052 <HAL_GPIO_ConfigPinAttributes+0x42>
  }
  else if ((PinAttributes & GPIO_PIN_NSEC) == GPIO_PIN_NSEC)
3400b03e:	687b      	ldr	r3, [r7, #4]
3400b040:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400b044:	2b00      	cmp	r3, #0
3400b046:	d004      	beq.n	3400b052 <HAL_GPIO_ConfigPinAttributes+0x42>
  {
    sec &= ~((uint32_t)GPIO_Pin);
3400b048:	897b      	ldrh	r3, [r7, #10]
3400b04a:	43db      	mvns	r3, r3
3400b04c:	697a      	ldr	r2, [r7, #20]
3400b04e:	4013      	ands	r3, r2
3400b050:	617b      	str	r3, [r7, #20]
  }
  else
  {
    /* do nothing */
  }
  GPIOx->SECCFGR = sec;
3400b052:	68fb      	ldr	r3, [r7, #12]
3400b054:	697a      	ldr	r2, [r7, #20]
3400b056:	631a      	str	r2, [r3, #48]	@ 0x30
#endif /* CPU_IN_SECURE_STATE */

  priv = GPIOx->PRIVCFGR;
3400b058:	68fb      	ldr	r3, [r7, #12]
3400b05a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400b05c:	613b      	str	r3, [r7, #16]
  if ((PinAttributes & GPIO_PIN_PRIV) == GPIO_PIN_PRIV)
3400b05e:	687a      	ldr	r2, [r7, #4]
3400b060:	f240 2302 	movw	r3, #514	@ 0x202
3400b064:	4013      	ands	r3, r2
3400b066:	f240 2202 	movw	r2, #514	@ 0x202
3400b06a:	4293      	cmp	r3, r2
3400b06c:	d104      	bne.n	3400b078 <HAL_GPIO_ConfigPinAttributes+0x68>
  {
    priv |= (uint32_t)GPIO_Pin;
3400b06e:	897b      	ldrh	r3, [r7, #10]
3400b070:	693a      	ldr	r2, [r7, #16]
3400b072:	4313      	orrs	r3, r2
3400b074:	613b      	str	r3, [r7, #16]
3400b076:	e009      	b.n	3400b08c <HAL_GPIO_ConfigPinAttributes+0x7c>
  }
  else if ((PinAttributes & GPIO_PIN_NPRIV) == GPIO_PIN_NPRIV)
3400b078:	687b      	ldr	r3, [r7, #4]
3400b07a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400b07e:	2b00      	cmp	r3, #0
3400b080:	d004      	beq.n	3400b08c <HAL_GPIO_ConfigPinAttributes+0x7c>
  {
    priv &= ~((uint32_t)GPIO_Pin);
3400b082:	897b      	ldrh	r3, [r7, #10]
3400b084:	43db      	mvns	r3, r3
3400b086:	693a      	ldr	r2, [r7, #16]
3400b088:	4013      	ands	r3, r2
3400b08a:	613b      	str	r3, [r7, #16]
  else
  {
    /* do nothing */
  }

  GPIOx->PRIVCFGR = priv;
3400b08c:	68fb      	ldr	r3, [r7, #12]
3400b08e:	693a      	ldr	r2, [r7, #16]
3400b090:	635a      	str	r2, [r3, #52]	@ 0x34
}
3400b092:	bf00      	nop
3400b094:	371c      	adds	r7, #28
3400b096:	46bd      	mov	sp, r7
3400b098:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b09c:	4770      	bx	lr

3400b09e <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
3400b09e:	b580      	push	{r7, lr}
3400b0a0:	b082      	sub	sp, #8
3400b0a2:	af00      	add	r7, sp, #0
3400b0a4:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
3400b0a6:	687b      	ldr	r3, [r7, #4]
3400b0a8:	2b00      	cmp	r3, #0
3400b0aa:	d101      	bne.n	3400b0b0 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
3400b0ac:	2301      	movs	r3, #1
3400b0ae:	e08d      	b.n	3400b1cc <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
3400b0b0:	687b      	ldr	r3, [r7, #4]
3400b0b2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400b0b6:	b2db      	uxtb	r3, r3
3400b0b8:	2b00      	cmp	r3, #0
3400b0ba:	d106      	bne.n	3400b0ca <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
3400b0bc:	687b      	ldr	r3, [r7, #4]
3400b0be:	2200      	movs	r2, #0
3400b0c0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
3400b0c4:	6878      	ldr	r0, [r7, #4]
3400b0c6:	f7f9 faa7 	bl	34004618 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
3400b0ca:	687b      	ldr	r3, [r7, #4]
3400b0cc:	2224      	movs	r2, #36	@ 0x24
3400b0ce:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
3400b0d2:	687b      	ldr	r3, [r7, #4]
3400b0d4:	681b      	ldr	r3, [r3, #0]
3400b0d6:	681a      	ldr	r2, [r3, #0]
3400b0d8:	687b      	ldr	r3, [r7, #4]
3400b0da:	681b      	ldr	r3, [r3, #0]
3400b0dc:	f022 0201 	bic.w	r2, r2, #1
3400b0e0:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
3400b0e2:	687b      	ldr	r3, [r7, #4]
3400b0e4:	685a      	ldr	r2, [r3, #4]
3400b0e6:	687b      	ldr	r3, [r7, #4]
3400b0e8:	681b      	ldr	r3, [r3, #0]
3400b0ea:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
3400b0ee:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
3400b0f0:	687b      	ldr	r3, [r7, #4]
3400b0f2:	681b      	ldr	r3, [r3, #0]
3400b0f4:	689a      	ldr	r2, [r3, #8]
3400b0f6:	687b      	ldr	r3, [r7, #4]
3400b0f8:	681b      	ldr	r3, [r3, #0]
3400b0fa:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400b0fe:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
3400b100:	687b      	ldr	r3, [r7, #4]
3400b102:	68db      	ldr	r3, [r3, #12]
3400b104:	2b01      	cmp	r3, #1
3400b106:	d107      	bne.n	3400b118 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
3400b108:	687b      	ldr	r3, [r7, #4]
3400b10a:	689a      	ldr	r2, [r3, #8]
3400b10c:	687b      	ldr	r3, [r7, #4]
3400b10e:	681b      	ldr	r3, [r3, #0]
3400b110:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
3400b114:	609a      	str	r2, [r3, #8]
3400b116:	e006      	b.n	3400b126 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
3400b118:	687b      	ldr	r3, [r7, #4]
3400b11a:	689a      	ldr	r2, [r3, #8]
3400b11c:	687b      	ldr	r3, [r7, #4]
3400b11e:	681b      	ldr	r3, [r3, #0]
3400b120:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
3400b124:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400b126:	687b      	ldr	r3, [r7, #4]
3400b128:	68db      	ldr	r3, [r3, #12]
3400b12a:	2b02      	cmp	r3, #2
3400b12c:	d108      	bne.n	3400b140 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400b12e:	687b      	ldr	r3, [r7, #4]
3400b130:	681b      	ldr	r3, [r3, #0]
3400b132:	685a      	ldr	r2, [r3, #4]
3400b134:	687b      	ldr	r3, [r7, #4]
3400b136:	681b      	ldr	r3, [r3, #0]
3400b138:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
3400b13c:	605a      	str	r2, [r3, #4]
3400b13e:	e007      	b.n	3400b150 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400b140:	687b      	ldr	r3, [r7, #4]
3400b142:	681b      	ldr	r3, [r3, #0]
3400b144:	685a      	ldr	r2, [r3, #4]
3400b146:	687b      	ldr	r3, [r7, #4]
3400b148:	681b      	ldr	r3, [r3, #0]
3400b14a:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
3400b14e:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
3400b150:	687b      	ldr	r3, [r7, #4]
3400b152:	681b      	ldr	r3, [r3, #0]
3400b154:	685b      	ldr	r3, [r3, #4]
3400b156:	687a      	ldr	r2, [r7, #4]
3400b158:	6812      	ldr	r2, [r2, #0]
3400b15a:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
3400b15e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400b162:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
3400b164:	687b      	ldr	r3, [r7, #4]
3400b166:	681b      	ldr	r3, [r3, #0]
3400b168:	68da      	ldr	r2, [r3, #12]
3400b16a:	687b      	ldr	r3, [r7, #4]
3400b16c:	681b      	ldr	r3, [r3, #0]
3400b16e:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400b172:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3400b174:	687b      	ldr	r3, [r7, #4]
3400b176:	691a      	ldr	r2, [r3, #16]
3400b178:	687b      	ldr	r3, [r7, #4]
3400b17a:	695b      	ldr	r3, [r3, #20]
3400b17c:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
3400b180:	687b      	ldr	r3, [r7, #4]
3400b182:	699b      	ldr	r3, [r3, #24]
3400b184:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
3400b186:	687b      	ldr	r3, [r7, #4]
3400b188:	681b      	ldr	r3, [r3, #0]
3400b18a:	430a      	orrs	r2, r1
3400b18c:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
3400b18e:	687b      	ldr	r3, [r7, #4]
3400b190:	69d9      	ldr	r1, [r3, #28]
3400b192:	687b      	ldr	r3, [r7, #4]
3400b194:	6a1a      	ldr	r2, [r3, #32]
3400b196:	687b      	ldr	r3, [r7, #4]
3400b198:	681b      	ldr	r3, [r3, #0]
3400b19a:	430a      	orrs	r2, r1
3400b19c:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
3400b19e:	687b      	ldr	r3, [r7, #4]
3400b1a0:	681b      	ldr	r3, [r3, #0]
3400b1a2:	681a      	ldr	r2, [r3, #0]
3400b1a4:	687b      	ldr	r3, [r7, #4]
3400b1a6:	681b      	ldr	r3, [r3, #0]
3400b1a8:	f042 0201 	orr.w	r2, r2, #1
3400b1ac:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400b1ae:	687b      	ldr	r3, [r7, #4]
3400b1b0:	2200      	movs	r2, #0
3400b1b2:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
3400b1b4:	687b      	ldr	r3, [r7, #4]
3400b1b6:	2220      	movs	r2, #32
3400b1b8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3400b1bc:	687b      	ldr	r3, [r7, #4]
3400b1be:	2200      	movs	r2, #0
3400b1c0:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3400b1c2:	687b      	ldr	r3, [r7, #4]
3400b1c4:	2200      	movs	r2, #0
3400b1c6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
3400b1ca:	2300      	movs	r3, #0
}
3400b1cc:	4618      	mov	r0, r3
3400b1ce:	3708      	adds	r7, #8
3400b1d0:	46bd      	mov	sp, r7
3400b1d2:	bd80      	pop	{r7, pc}

3400b1d4 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
3400b1d4:	b580      	push	{r7, lr}
3400b1d6:	b082      	sub	sp, #8
3400b1d8:	af00      	add	r7, sp, #0
3400b1da:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
3400b1dc:	687b      	ldr	r3, [r7, #4]
3400b1de:	2b00      	cmp	r3, #0
3400b1e0:	d101      	bne.n	3400b1e6 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
3400b1e2:	2301      	movs	r3, #1
3400b1e4:	e021      	b.n	3400b22a <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
3400b1e6:	687b      	ldr	r3, [r7, #4]
3400b1e8:	2224      	movs	r2, #36	@ 0x24
3400b1ea:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
3400b1ee:	687b      	ldr	r3, [r7, #4]
3400b1f0:	681b      	ldr	r3, [r3, #0]
3400b1f2:	681a      	ldr	r2, [r3, #0]
3400b1f4:	687b      	ldr	r3, [r7, #4]
3400b1f6:	681b      	ldr	r3, [r3, #0]
3400b1f8:	f022 0201 	bic.w	r2, r2, #1
3400b1fc:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
3400b1fe:	6878      	ldr	r0, [r7, #4]
3400b200:	f7f9 fa72 	bl	340046e8 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400b204:	687b      	ldr	r3, [r7, #4]
3400b206:	2200      	movs	r2, #0
3400b208:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
3400b20a:	687b      	ldr	r3, [r7, #4]
3400b20c:	2200      	movs	r2, #0
3400b20e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
3400b212:	687b      	ldr	r3, [r7, #4]
3400b214:	2200      	movs	r2, #0
3400b216:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
3400b218:	687b      	ldr	r3, [r7, #4]
3400b21a:	2200      	movs	r2, #0
3400b21c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
3400b220:	687b      	ldr	r3, [r7, #4]
3400b222:	2200      	movs	r2, #0
3400b224:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
3400b228:	2300      	movs	r3, #0
}
3400b22a:	4618      	mov	r0, r3
3400b22c:	3708      	adds	r7, #8
3400b22e:	46bd      	mov	sp, r7
3400b230:	bd80      	pop	{r7, pc}
	...

3400b234 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3400b234:	b580      	push	{r7, lr}
3400b236:	b088      	sub	sp, #32
3400b238:	af02      	add	r7, sp, #8
3400b23a:	60f8      	str	r0, [r7, #12]
3400b23c:	4608      	mov	r0, r1
3400b23e:	4611      	mov	r1, r2
3400b240:	461a      	mov	r2, r3
3400b242:	4603      	mov	r3, r0
3400b244:	817b      	strh	r3, [r7, #10]
3400b246:	460b      	mov	r3, r1
3400b248:	813b      	strh	r3, [r7, #8]
3400b24a:	4613      	mov	r3, r2
3400b24c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
3400b24e:	68fb      	ldr	r3, [r7, #12]
3400b250:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400b254:	b2db      	uxtb	r3, r3
3400b256:	2b20      	cmp	r3, #32
3400b258:	f040 80f9 	bne.w	3400b44e <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
3400b25c:	6a3b      	ldr	r3, [r7, #32]
3400b25e:	2b00      	cmp	r3, #0
3400b260:	d002      	beq.n	3400b268 <HAL_I2C_Mem_Write+0x34>
3400b262:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
3400b264:	2b00      	cmp	r3, #0
3400b266:	d105      	bne.n	3400b274 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
3400b268:	68fb      	ldr	r3, [r7, #12]
3400b26a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400b26e:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
3400b270:	2301      	movs	r3, #1
3400b272:	e0ed      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
3400b274:	68fb      	ldr	r3, [r7, #12]
3400b276:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400b27a:	2b01      	cmp	r3, #1
3400b27c:	d101      	bne.n	3400b282 <HAL_I2C_Mem_Write+0x4e>
3400b27e:	2302      	movs	r3, #2
3400b280:	e0e6      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
3400b282:	68fb      	ldr	r3, [r7, #12]
3400b284:	2201      	movs	r2, #1
3400b286:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
3400b28a:	f7f9 fcd0 	bl	34004c2e <HAL_GetTick>
3400b28e:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3400b290:	697b      	ldr	r3, [r7, #20]
3400b292:	9300      	str	r3, [sp, #0]
3400b294:	2319      	movs	r3, #25
3400b296:	2201      	movs	r2, #1
3400b298:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400b29c:	68f8      	ldr	r0, [r7, #12]
3400b29e:	f000 fac3 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b2a2:	4603      	mov	r3, r0
3400b2a4:	2b00      	cmp	r3, #0
3400b2a6:	d001      	beq.n	3400b2ac <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
3400b2a8:	2301      	movs	r3, #1
3400b2aa:	e0d1      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
3400b2ac:	68fb      	ldr	r3, [r7, #12]
3400b2ae:	2221      	movs	r2, #33	@ 0x21
3400b2b0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3400b2b4:	68fb      	ldr	r3, [r7, #12]
3400b2b6:	2240      	movs	r2, #64	@ 0x40
3400b2b8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400b2bc:	68fb      	ldr	r3, [r7, #12]
3400b2be:	2200      	movs	r2, #0
3400b2c0:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3400b2c2:	68fb      	ldr	r3, [r7, #12]
3400b2c4:	6a3a      	ldr	r2, [r7, #32]
3400b2c6:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
3400b2c8:	68fb      	ldr	r3, [r7, #12]
3400b2ca:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
3400b2cc:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
3400b2ce:	68fb      	ldr	r3, [r7, #12]
3400b2d0:	2200      	movs	r2, #0
3400b2d2:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3400b2d4:	88f8      	ldrh	r0, [r7, #6]
3400b2d6:	893a      	ldrh	r2, [r7, #8]
3400b2d8:	8979      	ldrh	r1, [r7, #10]
3400b2da:	697b      	ldr	r3, [r7, #20]
3400b2dc:	9301      	str	r3, [sp, #4]
3400b2de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b2e0:	9300      	str	r3, [sp, #0]
3400b2e2:	4603      	mov	r3, r0
3400b2e4:	68f8      	ldr	r0, [r7, #12]
3400b2e6:	f000 f9d3 	bl	3400b690 <I2C_RequestMemoryWrite>
3400b2ea:	4603      	mov	r3, r0
3400b2ec:	2b00      	cmp	r3, #0
3400b2ee:	d005      	beq.n	3400b2fc <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
3400b2f0:	68fb      	ldr	r3, [r7, #12]
3400b2f2:	2200      	movs	r2, #0
3400b2f4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
3400b2f8:	2301      	movs	r3, #1
3400b2fa:	e0a9      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400b2fc:	68fb      	ldr	r3, [r7, #12]
3400b2fe:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b300:	b29b      	uxth	r3, r3
3400b302:	2bff      	cmp	r3, #255	@ 0xff
3400b304:	d90e      	bls.n	3400b324 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3400b306:	68fb      	ldr	r3, [r7, #12]
3400b308:	22ff      	movs	r2, #255	@ 0xff
3400b30a:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
3400b30c:	68fb      	ldr	r3, [r7, #12]
3400b30e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b310:	b2da      	uxtb	r2, r3
3400b312:	8979      	ldrh	r1, [r7, #10]
3400b314:	2300      	movs	r3, #0
3400b316:	9300      	str	r3, [sp, #0]
3400b318:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400b31c:	68f8      	ldr	r0, [r7, #12]
3400b31e:	f000 fc47 	bl	3400bbb0 <I2C_TransferConfig>
3400b322:	e00f      	b.n	3400b344 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
3400b324:	68fb      	ldr	r3, [r7, #12]
3400b326:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b328:	b29a      	uxth	r2, r3
3400b32a:	68fb      	ldr	r3, [r7, #12]
3400b32c:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
3400b32e:	68fb      	ldr	r3, [r7, #12]
3400b330:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b332:	b2da      	uxtb	r2, r3
3400b334:	8979      	ldrh	r1, [r7, #10]
3400b336:	2300      	movs	r3, #0
3400b338:	9300      	str	r3, [sp, #0]
3400b33a:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3400b33e:	68f8      	ldr	r0, [r7, #12]
3400b340:	f000 fc36 	bl	3400bbb0 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400b344:	697a      	ldr	r2, [r7, #20]
3400b346:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400b348:	68f8      	ldr	r0, [r7, #12]
3400b34a:	f000 fac6 	bl	3400b8da <I2C_WaitOnTXISFlagUntilTimeout>
3400b34e:	4603      	mov	r3, r0
3400b350:	2b00      	cmp	r3, #0
3400b352:	d001      	beq.n	3400b358 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
3400b354:	2301      	movs	r3, #1
3400b356:	e07b      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
3400b358:	68fb      	ldr	r3, [r7, #12]
3400b35a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b35c:	781a      	ldrb	r2, [r3, #0]
3400b35e:	68fb      	ldr	r3, [r7, #12]
3400b360:	681b      	ldr	r3, [r3, #0]
3400b362:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3400b364:	68fb      	ldr	r3, [r7, #12]
3400b366:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b368:	1c5a      	adds	r2, r3, #1
3400b36a:	68fb      	ldr	r3, [r7, #12]
3400b36c:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
3400b36e:	68fb      	ldr	r3, [r7, #12]
3400b370:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b372:	b29b      	uxth	r3, r3
3400b374:	3b01      	subs	r3, #1
3400b376:	b29a      	uxth	r2, r3
3400b378:	68fb      	ldr	r3, [r7, #12]
3400b37a:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
3400b37c:	68fb      	ldr	r3, [r7, #12]
3400b37e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b380:	3b01      	subs	r3, #1
3400b382:	b29a      	uxth	r2, r3
3400b384:	68fb      	ldr	r3, [r7, #12]
3400b386:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400b388:	68fb      	ldr	r3, [r7, #12]
3400b38a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b38c:	b29b      	uxth	r3, r3
3400b38e:	2b00      	cmp	r3, #0
3400b390:	d034      	beq.n	3400b3fc <HAL_I2C_Mem_Write+0x1c8>
3400b392:	68fb      	ldr	r3, [r7, #12]
3400b394:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b396:	2b00      	cmp	r3, #0
3400b398:	d130      	bne.n	3400b3fc <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3400b39a:	697b      	ldr	r3, [r7, #20]
3400b39c:	9300      	str	r3, [sp, #0]
3400b39e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b3a0:	2200      	movs	r2, #0
3400b3a2:	2180      	movs	r1, #128	@ 0x80
3400b3a4:	68f8      	ldr	r0, [r7, #12]
3400b3a6:	f000 fa3f 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b3aa:	4603      	mov	r3, r0
3400b3ac:	2b00      	cmp	r3, #0
3400b3ae:	d001      	beq.n	3400b3b4 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
3400b3b0:	2301      	movs	r3, #1
3400b3b2:	e04d      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400b3b4:	68fb      	ldr	r3, [r7, #12]
3400b3b6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b3b8:	b29b      	uxth	r3, r3
3400b3ba:	2bff      	cmp	r3, #255	@ 0xff
3400b3bc:	d90e      	bls.n	3400b3dc <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3400b3be:	68fb      	ldr	r3, [r7, #12]
3400b3c0:	22ff      	movs	r2, #255	@ 0xff
3400b3c2:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3400b3c4:	68fb      	ldr	r3, [r7, #12]
3400b3c6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b3c8:	b2da      	uxtb	r2, r3
3400b3ca:	8979      	ldrh	r1, [r7, #10]
3400b3cc:	2300      	movs	r3, #0
3400b3ce:	9300      	str	r3, [sp, #0]
3400b3d0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400b3d4:	68f8      	ldr	r0, [r7, #12]
3400b3d6:	f000 fbeb 	bl	3400bbb0 <I2C_TransferConfig>
3400b3da:	e00f      	b.n	3400b3fc <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3400b3dc:	68fb      	ldr	r3, [r7, #12]
3400b3de:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b3e0:	b29a      	uxth	r2, r3
3400b3e2:	68fb      	ldr	r3, [r7, #12]
3400b3e4:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400b3e6:	68fb      	ldr	r3, [r7, #12]
3400b3e8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b3ea:	b2da      	uxtb	r2, r3
3400b3ec:	8979      	ldrh	r1, [r7, #10]
3400b3ee:	2300      	movs	r3, #0
3400b3f0:	9300      	str	r3, [sp, #0]
3400b3f2:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3400b3f6:	68f8      	ldr	r0, [r7, #12]
3400b3f8:	f000 fbda 	bl	3400bbb0 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
3400b3fc:	68fb      	ldr	r3, [r7, #12]
3400b3fe:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b400:	b29b      	uxth	r3, r3
3400b402:	2b00      	cmp	r3, #0
3400b404:	d19e      	bne.n	3400b344 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400b406:	697a      	ldr	r2, [r7, #20]
3400b408:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400b40a:	68f8      	ldr	r0, [r7, #12]
3400b40c:	f000 faac 	bl	3400b968 <I2C_WaitOnSTOPFlagUntilTimeout>
3400b410:	4603      	mov	r3, r0
3400b412:	2b00      	cmp	r3, #0
3400b414:	d001      	beq.n	3400b41a <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
3400b416:	2301      	movs	r3, #1
3400b418:	e01a      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400b41a:	68fb      	ldr	r3, [r7, #12]
3400b41c:	681b      	ldr	r3, [r3, #0]
3400b41e:	2220      	movs	r2, #32
3400b420:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3400b422:	68fb      	ldr	r3, [r7, #12]
3400b424:	681b      	ldr	r3, [r3, #0]
3400b426:	6859      	ldr	r1, [r3, #4]
3400b428:	68fb      	ldr	r3, [r7, #12]
3400b42a:	681a      	ldr	r2, [r3, #0]
3400b42c:	4b0a      	ldr	r3, [pc, #40]	@ (3400b458 <HAL_I2C_Mem_Write+0x224>)
3400b42e:	400b      	ands	r3, r1
3400b430:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
3400b432:	68fb      	ldr	r3, [r7, #12]
3400b434:	2220      	movs	r2, #32
3400b436:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3400b43a:	68fb      	ldr	r3, [r7, #12]
3400b43c:	2200      	movs	r2, #0
3400b43e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400b442:	68fb      	ldr	r3, [r7, #12]
3400b444:	2200      	movs	r2, #0
3400b446:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3400b44a:	2300      	movs	r3, #0
3400b44c:	e000      	b.n	3400b450 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
3400b44e:	2302      	movs	r3, #2
  }
}
3400b450:	4618      	mov	r0, r3
3400b452:	3718      	adds	r7, #24
3400b454:	46bd      	mov	sp, r7
3400b456:	bd80      	pop	{r7, pc}
3400b458:	fe00e800 	.word	0xfe00e800

3400b45c <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
3400b45c:	b580      	push	{r7, lr}
3400b45e:	b088      	sub	sp, #32
3400b460:	af02      	add	r7, sp, #8
3400b462:	60f8      	str	r0, [r7, #12]
3400b464:	4608      	mov	r0, r1
3400b466:	4611      	mov	r1, r2
3400b468:	461a      	mov	r2, r3
3400b46a:	4603      	mov	r3, r0
3400b46c:	817b      	strh	r3, [r7, #10]
3400b46e:	460b      	mov	r3, r1
3400b470:	813b      	strh	r3, [r7, #8]
3400b472:	4613      	mov	r3, r2
3400b474:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
3400b476:	68fb      	ldr	r3, [r7, #12]
3400b478:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400b47c:	b2db      	uxtb	r3, r3
3400b47e:	2b20      	cmp	r3, #32
3400b480:	f040 80fd 	bne.w	3400b67e <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
3400b484:	6a3b      	ldr	r3, [r7, #32]
3400b486:	2b00      	cmp	r3, #0
3400b488:	d002      	beq.n	3400b490 <HAL_I2C_Mem_Read+0x34>
3400b48a:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
3400b48c:	2b00      	cmp	r3, #0
3400b48e:	d105      	bne.n	3400b49c <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
3400b490:	68fb      	ldr	r3, [r7, #12]
3400b492:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400b496:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
3400b498:	2301      	movs	r3, #1
3400b49a:	e0f1      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
3400b49c:	68fb      	ldr	r3, [r7, #12]
3400b49e:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400b4a2:	2b01      	cmp	r3, #1
3400b4a4:	d101      	bne.n	3400b4aa <HAL_I2C_Mem_Read+0x4e>
3400b4a6:	2302      	movs	r3, #2
3400b4a8:	e0ea      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
3400b4aa:	68fb      	ldr	r3, [r7, #12]
3400b4ac:	2201      	movs	r2, #1
3400b4ae:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
3400b4b2:	f7f9 fbbc 	bl	34004c2e <HAL_GetTick>
3400b4b6:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
3400b4b8:	697b      	ldr	r3, [r7, #20]
3400b4ba:	9300      	str	r3, [sp, #0]
3400b4bc:	2319      	movs	r3, #25
3400b4be:	2201      	movs	r2, #1
3400b4c0:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400b4c4:	68f8      	ldr	r0, [r7, #12]
3400b4c6:	f000 f9af 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b4ca:	4603      	mov	r3, r0
3400b4cc:	2b00      	cmp	r3, #0
3400b4ce:	d001      	beq.n	3400b4d4 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
3400b4d0:	2301      	movs	r3, #1
3400b4d2:	e0d5      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
3400b4d4:	68fb      	ldr	r3, [r7, #12]
3400b4d6:	2222      	movs	r2, #34	@ 0x22
3400b4d8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
3400b4dc:	68fb      	ldr	r3, [r7, #12]
3400b4de:	2240      	movs	r2, #64	@ 0x40
3400b4e0:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
3400b4e4:	68fb      	ldr	r3, [r7, #12]
3400b4e6:	2200      	movs	r2, #0
3400b4e8:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
3400b4ea:	68fb      	ldr	r3, [r7, #12]
3400b4ec:	6a3a      	ldr	r2, [r7, #32]
3400b4ee:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
3400b4f0:	68fb      	ldr	r3, [r7, #12]
3400b4f2:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
3400b4f4:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
3400b4f6:	68fb      	ldr	r3, [r7, #12]
3400b4f8:	2200      	movs	r2, #0
3400b4fa:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
3400b4fc:	88f8      	ldrh	r0, [r7, #6]
3400b4fe:	893a      	ldrh	r2, [r7, #8]
3400b500:	8979      	ldrh	r1, [r7, #10]
3400b502:	697b      	ldr	r3, [r7, #20]
3400b504:	9301      	str	r3, [sp, #4]
3400b506:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b508:	9300      	str	r3, [sp, #0]
3400b50a:	4603      	mov	r3, r0
3400b50c:	68f8      	ldr	r0, [r7, #12]
3400b50e:	f000 f913 	bl	3400b738 <I2C_RequestMemoryRead>
3400b512:	4603      	mov	r3, r0
3400b514:	2b00      	cmp	r3, #0
3400b516:	d005      	beq.n	3400b524 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
3400b518:	68fb      	ldr	r3, [r7, #12]
3400b51a:	2200      	movs	r2, #0
3400b51c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
3400b520:	2301      	movs	r3, #1
3400b522:	e0ad      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400b524:	68fb      	ldr	r3, [r7, #12]
3400b526:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b528:	b29b      	uxth	r3, r3
3400b52a:	2bff      	cmp	r3, #255	@ 0xff
3400b52c:	d90e      	bls.n	3400b54c <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
3400b52e:	68fb      	ldr	r3, [r7, #12]
3400b530:	22ff      	movs	r2, #255	@ 0xff
3400b532:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
3400b534:	68fb      	ldr	r3, [r7, #12]
3400b536:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b538:	b2da      	uxtb	r2, r3
3400b53a:	8979      	ldrh	r1, [r7, #10]
3400b53c:	4b52      	ldr	r3, [pc, #328]	@ (3400b688 <HAL_I2C_Mem_Read+0x22c>)
3400b53e:	9300      	str	r3, [sp, #0]
3400b540:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400b544:	68f8      	ldr	r0, [r7, #12]
3400b546:	f000 fb33 	bl	3400bbb0 <I2C_TransferConfig>
3400b54a:	e00f      	b.n	3400b56c <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
3400b54c:	68fb      	ldr	r3, [r7, #12]
3400b54e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b550:	b29a      	uxth	r2, r3
3400b552:	68fb      	ldr	r3, [r7, #12]
3400b554:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400b556:	68fb      	ldr	r3, [r7, #12]
3400b558:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b55a:	b2da      	uxtb	r2, r3
3400b55c:	8979      	ldrh	r1, [r7, #10]
3400b55e:	4b4a      	ldr	r3, [pc, #296]	@ (3400b688 <HAL_I2C_Mem_Read+0x22c>)
3400b560:	9300      	str	r3, [sp, #0]
3400b562:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3400b566:	68f8      	ldr	r0, [r7, #12]
3400b568:	f000 fb22 	bl	3400bbb0 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
3400b56c:	697b      	ldr	r3, [r7, #20]
3400b56e:	9300      	str	r3, [sp, #0]
3400b570:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b572:	2200      	movs	r2, #0
3400b574:	2104      	movs	r1, #4
3400b576:	68f8      	ldr	r0, [r7, #12]
3400b578:	f000 f956 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b57c:	4603      	mov	r3, r0
3400b57e:	2b00      	cmp	r3, #0
3400b580:	d001      	beq.n	3400b586 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
3400b582:	2301      	movs	r3, #1
3400b584:	e07c      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
3400b586:	68fb      	ldr	r3, [r7, #12]
3400b588:	681b      	ldr	r3, [r3, #0]
3400b58a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3400b58c:	68fb      	ldr	r3, [r7, #12]
3400b58e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b590:	b2d2      	uxtb	r2, r2
3400b592:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3400b594:	68fb      	ldr	r3, [r7, #12]
3400b596:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400b598:	1c5a      	adds	r2, r3, #1
3400b59a:	68fb      	ldr	r3, [r7, #12]
3400b59c:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
3400b59e:	68fb      	ldr	r3, [r7, #12]
3400b5a0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b5a2:	3b01      	subs	r3, #1
3400b5a4:	b29a      	uxth	r2, r3
3400b5a6:	68fb      	ldr	r3, [r7, #12]
3400b5a8:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
3400b5aa:	68fb      	ldr	r3, [r7, #12]
3400b5ac:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b5ae:	b29b      	uxth	r3, r3
3400b5b0:	3b01      	subs	r3, #1
3400b5b2:	b29a      	uxth	r2, r3
3400b5b4:	68fb      	ldr	r3, [r7, #12]
3400b5b6:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
3400b5b8:	68fb      	ldr	r3, [r7, #12]
3400b5ba:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b5bc:	b29b      	uxth	r3, r3
3400b5be:	2b00      	cmp	r3, #0
3400b5c0:	d034      	beq.n	3400b62c <HAL_I2C_Mem_Read+0x1d0>
3400b5c2:	68fb      	ldr	r3, [r7, #12]
3400b5c4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b5c6:	2b00      	cmp	r3, #0
3400b5c8:	d130      	bne.n	3400b62c <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
3400b5ca:	697b      	ldr	r3, [r7, #20]
3400b5cc:	9300      	str	r3, [sp, #0]
3400b5ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400b5d0:	2200      	movs	r2, #0
3400b5d2:	2180      	movs	r1, #128	@ 0x80
3400b5d4:	68f8      	ldr	r0, [r7, #12]
3400b5d6:	f000 f927 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b5da:	4603      	mov	r3, r0
3400b5dc:	2b00      	cmp	r3, #0
3400b5de:	d001      	beq.n	3400b5e4 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
3400b5e0:	2301      	movs	r3, #1
3400b5e2:	e04d      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400b5e4:	68fb      	ldr	r3, [r7, #12]
3400b5e6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b5e8:	b29b      	uxth	r3, r3
3400b5ea:	2bff      	cmp	r3, #255	@ 0xff
3400b5ec:	d90e      	bls.n	3400b60c <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
3400b5ee:	68fb      	ldr	r3, [r7, #12]
3400b5f0:	22ff      	movs	r2, #255	@ 0xff
3400b5f2:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
3400b5f4:	68fb      	ldr	r3, [r7, #12]
3400b5f6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b5f8:	b2da      	uxtb	r2, r3
3400b5fa:	8979      	ldrh	r1, [r7, #10]
3400b5fc:	2300      	movs	r3, #0
3400b5fe:	9300      	str	r3, [sp, #0]
3400b600:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400b604:	68f8      	ldr	r0, [r7, #12]
3400b606:	f000 fad3 	bl	3400bbb0 <I2C_TransferConfig>
3400b60a:	e00f      	b.n	3400b62c <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
3400b60c:	68fb      	ldr	r3, [r7, #12]
3400b60e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b610:	b29a      	uxth	r2, r3
3400b612:	68fb      	ldr	r3, [r7, #12]
3400b614:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
3400b616:	68fb      	ldr	r3, [r7, #12]
3400b618:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400b61a:	b2da      	uxtb	r2, r3
3400b61c:	8979      	ldrh	r1, [r7, #10]
3400b61e:	2300      	movs	r3, #0
3400b620:	9300      	str	r3, [sp, #0]
3400b622:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
3400b626:	68f8      	ldr	r0, [r7, #12]
3400b628:	f000 fac2 	bl	3400bbb0 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
3400b62c:	68fb      	ldr	r3, [r7, #12]
3400b62e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400b630:	b29b      	uxth	r3, r3
3400b632:	2b00      	cmp	r3, #0
3400b634:	d19a      	bne.n	3400b56c <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
3400b636:	697a      	ldr	r2, [r7, #20]
3400b638:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400b63a:	68f8      	ldr	r0, [r7, #12]
3400b63c:	f000 f994 	bl	3400b968 <I2C_WaitOnSTOPFlagUntilTimeout>
3400b640:	4603      	mov	r3, r0
3400b642:	2b00      	cmp	r3, #0
3400b644:	d001      	beq.n	3400b64a <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
3400b646:	2301      	movs	r3, #1
3400b648:	e01a      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400b64a:	68fb      	ldr	r3, [r7, #12]
3400b64c:	681b      	ldr	r3, [r3, #0]
3400b64e:	2220      	movs	r2, #32
3400b650:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3400b652:	68fb      	ldr	r3, [r7, #12]
3400b654:	681b      	ldr	r3, [r3, #0]
3400b656:	6859      	ldr	r1, [r3, #4]
3400b658:	68fb      	ldr	r3, [r7, #12]
3400b65a:	681a      	ldr	r2, [r3, #0]
3400b65c:	4b0b      	ldr	r3, [pc, #44]	@ (3400b68c <HAL_I2C_Mem_Read+0x230>)
3400b65e:	400b      	ands	r3, r1
3400b660:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
3400b662:	68fb      	ldr	r3, [r7, #12]
3400b664:	2220      	movs	r2, #32
3400b666:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
3400b66a:	68fb      	ldr	r3, [r7, #12]
3400b66c:	2200      	movs	r2, #0
3400b66e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400b672:	68fb      	ldr	r3, [r7, #12]
3400b674:	2200      	movs	r2, #0
3400b676:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3400b67a:	2300      	movs	r3, #0
3400b67c:	e000      	b.n	3400b680 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
3400b67e:	2302      	movs	r3, #2
  }
}
3400b680:	4618      	mov	r0, r3
3400b682:	3718      	adds	r7, #24
3400b684:	46bd      	mov	sp, r7
3400b686:	bd80      	pop	{r7, pc}
3400b688:	80002400 	.word	0x80002400
3400b68c:	fe00e800 	.word	0xfe00e800

3400b690 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
3400b690:	b580      	push	{r7, lr}
3400b692:	b086      	sub	sp, #24
3400b694:	af02      	add	r7, sp, #8
3400b696:	60f8      	str	r0, [r7, #12]
3400b698:	4608      	mov	r0, r1
3400b69a:	4611      	mov	r1, r2
3400b69c:	461a      	mov	r2, r3
3400b69e:	4603      	mov	r3, r0
3400b6a0:	817b      	strh	r3, [r7, #10]
3400b6a2:	460b      	mov	r3, r1
3400b6a4:	813b      	strh	r3, [r7, #8]
3400b6a6:	4613      	mov	r3, r2
3400b6a8:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
3400b6aa:	88fb      	ldrh	r3, [r7, #6]
3400b6ac:	b2da      	uxtb	r2, r3
3400b6ae:	8979      	ldrh	r1, [r7, #10]
3400b6b0:	4b20      	ldr	r3, [pc, #128]	@ (3400b734 <I2C_RequestMemoryWrite+0xa4>)
3400b6b2:	9300      	str	r3, [sp, #0]
3400b6b4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
3400b6b8:	68f8      	ldr	r0, [r7, #12]
3400b6ba:	f000 fa79 	bl	3400bbb0 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400b6be:	69fa      	ldr	r2, [r7, #28]
3400b6c0:	69b9      	ldr	r1, [r7, #24]
3400b6c2:	68f8      	ldr	r0, [r7, #12]
3400b6c4:	f000 f909 	bl	3400b8da <I2C_WaitOnTXISFlagUntilTimeout>
3400b6c8:	4603      	mov	r3, r0
3400b6ca:	2b00      	cmp	r3, #0
3400b6cc:	d001      	beq.n	3400b6d2 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
3400b6ce:	2301      	movs	r3, #1
3400b6d0:	e02c      	b.n	3400b72c <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400b6d2:	88fb      	ldrh	r3, [r7, #6]
3400b6d4:	2b01      	cmp	r3, #1
3400b6d6:	d105      	bne.n	3400b6e4 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400b6d8:	893b      	ldrh	r3, [r7, #8]
3400b6da:	b2da      	uxtb	r2, r3
3400b6dc:	68fb      	ldr	r3, [r7, #12]
3400b6de:	681b      	ldr	r3, [r3, #0]
3400b6e0:	629a      	str	r2, [r3, #40]	@ 0x28
3400b6e2:	e015      	b.n	3400b710 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3400b6e4:	893b      	ldrh	r3, [r7, #8]
3400b6e6:	0a1b      	lsrs	r3, r3, #8
3400b6e8:	b29b      	uxth	r3, r3
3400b6ea:	b2da      	uxtb	r2, r3
3400b6ec:	68fb      	ldr	r3, [r7, #12]
3400b6ee:	681b      	ldr	r3, [r3, #0]
3400b6f0:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400b6f2:	69fa      	ldr	r2, [r7, #28]
3400b6f4:	69b9      	ldr	r1, [r7, #24]
3400b6f6:	68f8      	ldr	r0, [r7, #12]
3400b6f8:	f000 f8ef 	bl	3400b8da <I2C_WaitOnTXISFlagUntilTimeout>
3400b6fc:	4603      	mov	r3, r0
3400b6fe:	2b00      	cmp	r3, #0
3400b700:	d001      	beq.n	3400b706 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
3400b702:	2301      	movs	r3, #1
3400b704:	e012      	b.n	3400b72c <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400b706:	893b      	ldrh	r3, [r7, #8]
3400b708:	b2da      	uxtb	r2, r3
3400b70a:	68fb      	ldr	r3, [r7, #12]
3400b70c:	681b      	ldr	r3, [r3, #0]
3400b70e:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
3400b710:	69fb      	ldr	r3, [r7, #28]
3400b712:	9300      	str	r3, [sp, #0]
3400b714:	69bb      	ldr	r3, [r7, #24]
3400b716:	2200      	movs	r2, #0
3400b718:	2180      	movs	r1, #128	@ 0x80
3400b71a:	68f8      	ldr	r0, [r7, #12]
3400b71c:	f000 f884 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b720:	4603      	mov	r3, r0
3400b722:	2b00      	cmp	r3, #0
3400b724:	d001      	beq.n	3400b72a <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
3400b726:	2301      	movs	r3, #1
3400b728:	e000      	b.n	3400b72c <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
3400b72a:	2300      	movs	r3, #0
}
3400b72c:	4618      	mov	r0, r3
3400b72e:	3710      	adds	r7, #16
3400b730:	46bd      	mov	sp, r7
3400b732:	bd80      	pop	{r7, pc}
3400b734:	80002000 	.word	0x80002000

3400b738 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
3400b738:	b580      	push	{r7, lr}
3400b73a:	b086      	sub	sp, #24
3400b73c:	af02      	add	r7, sp, #8
3400b73e:	60f8      	str	r0, [r7, #12]
3400b740:	4608      	mov	r0, r1
3400b742:	4611      	mov	r1, r2
3400b744:	461a      	mov	r2, r3
3400b746:	4603      	mov	r3, r0
3400b748:	817b      	strh	r3, [r7, #10]
3400b74a:	460b      	mov	r3, r1
3400b74c:	813b      	strh	r3, [r7, #8]
3400b74e:	4613      	mov	r3, r2
3400b750:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
3400b752:	88fb      	ldrh	r3, [r7, #6]
3400b754:	b2da      	uxtb	r2, r3
3400b756:	8979      	ldrh	r1, [r7, #10]
3400b758:	4b20      	ldr	r3, [pc, #128]	@ (3400b7dc <I2C_RequestMemoryRead+0xa4>)
3400b75a:	9300      	str	r3, [sp, #0]
3400b75c:	2300      	movs	r3, #0
3400b75e:	68f8      	ldr	r0, [r7, #12]
3400b760:	f000 fa26 	bl	3400bbb0 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400b764:	69fa      	ldr	r2, [r7, #28]
3400b766:	69b9      	ldr	r1, [r7, #24]
3400b768:	68f8      	ldr	r0, [r7, #12]
3400b76a:	f000 f8b6 	bl	3400b8da <I2C_WaitOnTXISFlagUntilTimeout>
3400b76e:	4603      	mov	r3, r0
3400b770:	2b00      	cmp	r3, #0
3400b772:	d001      	beq.n	3400b778 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
3400b774:	2301      	movs	r3, #1
3400b776:	e02c      	b.n	3400b7d2 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
3400b778:	88fb      	ldrh	r3, [r7, #6]
3400b77a:	2b01      	cmp	r3, #1
3400b77c:	d105      	bne.n	3400b78a <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400b77e:	893b      	ldrh	r3, [r7, #8]
3400b780:	b2da      	uxtb	r2, r3
3400b782:	68fb      	ldr	r3, [r7, #12]
3400b784:	681b      	ldr	r3, [r3, #0]
3400b786:	629a      	str	r2, [r3, #40]	@ 0x28
3400b788:	e015      	b.n	3400b7b6 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
3400b78a:	893b      	ldrh	r3, [r7, #8]
3400b78c:	0a1b      	lsrs	r3, r3, #8
3400b78e:	b29b      	uxth	r3, r3
3400b790:	b2da      	uxtb	r2, r3
3400b792:	68fb      	ldr	r3, [r7, #12]
3400b794:	681b      	ldr	r3, [r3, #0]
3400b796:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
3400b798:	69fa      	ldr	r2, [r7, #28]
3400b79a:	69b9      	ldr	r1, [r7, #24]
3400b79c:	68f8      	ldr	r0, [r7, #12]
3400b79e:	f000 f89c 	bl	3400b8da <I2C_WaitOnTXISFlagUntilTimeout>
3400b7a2:	4603      	mov	r3, r0
3400b7a4:	2b00      	cmp	r3, #0
3400b7a6:	d001      	beq.n	3400b7ac <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
3400b7a8:	2301      	movs	r3, #1
3400b7aa:	e012      	b.n	3400b7d2 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
3400b7ac:	893b      	ldrh	r3, [r7, #8]
3400b7ae:	b2da      	uxtb	r2, r3
3400b7b0:	68fb      	ldr	r3, [r7, #12]
3400b7b2:	681b      	ldr	r3, [r3, #0]
3400b7b4:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
3400b7b6:	69fb      	ldr	r3, [r7, #28]
3400b7b8:	9300      	str	r3, [sp, #0]
3400b7ba:	69bb      	ldr	r3, [r7, #24]
3400b7bc:	2200      	movs	r2, #0
3400b7be:	2140      	movs	r1, #64	@ 0x40
3400b7c0:	68f8      	ldr	r0, [r7, #12]
3400b7c2:	f000 f831 	bl	3400b828 <I2C_WaitOnFlagUntilTimeout>
3400b7c6:	4603      	mov	r3, r0
3400b7c8:	2b00      	cmp	r3, #0
3400b7ca:	d001      	beq.n	3400b7d0 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
3400b7cc:	2301      	movs	r3, #1
3400b7ce:	e000      	b.n	3400b7d2 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
3400b7d0:	2300      	movs	r3, #0
}
3400b7d2:	4618      	mov	r0, r3
3400b7d4:	3710      	adds	r7, #16
3400b7d6:	46bd      	mov	sp, r7
3400b7d8:	bd80      	pop	{r7, pc}
3400b7da:	bf00      	nop
3400b7dc:	80002000 	.word	0x80002000

3400b7e0 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
3400b7e0:	b480      	push	{r7}
3400b7e2:	b083      	sub	sp, #12
3400b7e4:	af00      	add	r7, sp, #0
3400b7e6:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
3400b7e8:	687b      	ldr	r3, [r7, #4]
3400b7ea:	681b      	ldr	r3, [r3, #0]
3400b7ec:	699b      	ldr	r3, [r3, #24]
3400b7ee:	f003 0302 	and.w	r3, r3, #2
3400b7f2:	2b02      	cmp	r3, #2
3400b7f4:	d103      	bne.n	3400b7fe <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
3400b7f6:	687b      	ldr	r3, [r7, #4]
3400b7f8:	681b      	ldr	r3, [r3, #0]
3400b7fa:	2200      	movs	r2, #0
3400b7fc:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
3400b7fe:	687b      	ldr	r3, [r7, #4]
3400b800:	681b      	ldr	r3, [r3, #0]
3400b802:	699b      	ldr	r3, [r3, #24]
3400b804:	f003 0301 	and.w	r3, r3, #1
3400b808:	2b01      	cmp	r3, #1
3400b80a:	d007      	beq.n	3400b81c <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
3400b80c:	687b      	ldr	r3, [r7, #4]
3400b80e:	681b      	ldr	r3, [r3, #0]
3400b810:	699a      	ldr	r2, [r3, #24]
3400b812:	687b      	ldr	r3, [r7, #4]
3400b814:	681b      	ldr	r3, [r3, #0]
3400b816:	f042 0201 	orr.w	r2, r2, #1
3400b81a:	619a      	str	r2, [r3, #24]
  }
}
3400b81c:	bf00      	nop
3400b81e:	370c      	adds	r7, #12
3400b820:	46bd      	mov	sp, r7
3400b822:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b826:	4770      	bx	lr

3400b828 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
3400b828:	b580      	push	{r7, lr}
3400b82a:	b084      	sub	sp, #16
3400b82c:	af00      	add	r7, sp, #0
3400b82e:	60f8      	str	r0, [r7, #12]
3400b830:	60b9      	str	r1, [r7, #8]
3400b832:	603b      	str	r3, [r7, #0]
3400b834:	4613      	mov	r3, r2
3400b836:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3400b838:	e03b      	b.n	3400b8b2 <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3400b83a:	69ba      	ldr	r2, [r7, #24]
3400b83c:	6839      	ldr	r1, [r7, #0]
3400b83e:	68f8      	ldr	r0, [r7, #12]
3400b840:	f000 f8d6 	bl	3400b9f0 <I2C_IsErrorOccurred>
3400b844:	4603      	mov	r3, r0
3400b846:	2b00      	cmp	r3, #0
3400b848:	d001      	beq.n	3400b84e <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
3400b84a:	2301      	movs	r3, #1
3400b84c:	e041      	b.n	3400b8d2 <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3400b84e:	683b      	ldr	r3, [r7, #0]
3400b850:	f1b3 3fff 	cmp.w	r3, #4294967295
3400b854:	d02d      	beq.n	3400b8b2 <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400b856:	f7f9 f9ea 	bl	34004c2e <HAL_GetTick>
3400b85a:	4602      	mov	r2, r0
3400b85c:	69bb      	ldr	r3, [r7, #24]
3400b85e:	1ad3      	subs	r3, r2, r3
3400b860:	683a      	ldr	r2, [r7, #0]
3400b862:	429a      	cmp	r2, r3
3400b864:	d302      	bcc.n	3400b86c <I2C_WaitOnFlagUntilTimeout+0x44>
3400b866:	683b      	ldr	r3, [r7, #0]
3400b868:	2b00      	cmp	r3, #0
3400b86a:	d122      	bne.n	3400b8b2 <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3400b86c:	68fb      	ldr	r3, [r7, #12]
3400b86e:	681b      	ldr	r3, [r3, #0]
3400b870:	699a      	ldr	r2, [r3, #24]
3400b872:	68bb      	ldr	r3, [r7, #8]
3400b874:	4013      	ands	r3, r2
3400b876:	68ba      	ldr	r2, [r7, #8]
3400b878:	429a      	cmp	r2, r3
3400b87a:	bf0c      	ite	eq
3400b87c:	2301      	moveq	r3, #1
3400b87e:	2300      	movne	r3, #0
3400b880:	b2db      	uxtb	r3, r3
3400b882:	461a      	mov	r2, r3
3400b884:	79fb      	ldrb	r3, [r7, #7]
3400b886:	429a      	cmp	r2, r3
3400b888:	d113      	bne.n	3400b8b2 <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3400b88a:	68fb      	ldr	r3, [r7, #12]
3400b88c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b88e:	f043 0220 	orr.w	r2, r3, #32
3400b892:	68fb      	ldr	r3, [r7, #12]
3400b894:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3400b896:	68fb      	ldr	r3, [r7, #12]
3400b898:	2220      	movs	r2, #32
3400b89a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
3400b89e:	68fb      	ldr	r3, [r7, #12]
3400b8a0:	2200      	movs	r2, #0
3400b8a2:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3400b8a6:	68fb      	ldr	r3, [r7, #12]
3400b8a8:	2200      	movs	r2, #0
3400b8aa:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
3400b8ae:	2301      	movs	r3, #1
3400b8b0:	e00f      	b.n	3400b8d2 <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
3400b8b2:	68fb      	ldr	r3, [r7, #12]
3400b8b4:	681b      	ldr	r3, [r3, #0]
3400b8b6:	699a      	ldr	r2, [r3, #24]
3400b8b8:	68bb      	ldr	r3, [r7, #8]
3400b8ba:	4013      	ands	r3, r2
3400b8bc:	68ba      	ldr	r2, [r7, #8]
3400b8be:	429a      	cmp	r2, r3
3400b8c0:	bf0c      	ite	eq
3400b8c2:	2301      	moveq	r3, #1
3400b8c4:	2300      	movne	r3, #0
3400b8c6:	b2db      	uxtb	r3, r3
3400b8c8:	461a      	mov	r2, r3
3400b8ca:	79fb      	ldrb	r3, [r7, #7]
3400b8cc:	429a      	cmp	r2, r3
3400b8ce:	d0b4      	beq.n	3400b83a <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
3400b8d0:	2300      	movs	r3, #0
}
3400b8d2:	4618      	mov	r0, r3
3400b8d4:	3710      	adds	r7, #16
3400b8d6:	46bd      	mov	sp, r7
3400b8d8:	bd80      	pop	{r7, pc}

3400b8da <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3400b8da:	b580      	push	{r7, lr}
3400b8dc:	b084      	sub	sp, #16
3400b8de:	af00      	add	r7, sp, #0
3400b8e0:	60f8      	str	r0, [r7, #12]
3400b8e2:	60b9      	str	r1, [r7, #8]
3400b8e4:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3400b8e6:	e033      	b.n	3400b950 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3400b8e8:	687a      	ldr	r2, [r7, #4]
3400b8ea:	68b9      	ldr	r1, [r7, #8]
3400b8ec:	68f8      	ldr	r0, [r7, #12]
3400b8ee:	f000 f87f 	bl	3400b9f0 <I2C_IsErrorOccurred>
3400b8f2:	4603      	mov	r3, r0
3400b8f4:	2b00      	cmp	r3, #0
3400b8f6:	d001      	beq.n	3400b8fc <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
3400b8f8:	2301      	movs	r3, #1
3400b8fa:	e031      	b.n	3400b960 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
3400b8fc:	68bb      	ldr	r3, [r7, #8]
3400b8fe:	f1b3 3fff 	cmp.w	r3, #4294967295
3400b902:	d025      	beq.n	3400b950 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400b904:	f7f9 f993 	bl	34004c2e <HAL_GetTick>
3400b908:	4602      	mov	r2, r0
3400b90a:	687b      	ldr	r3, [r7, #4]
3400b90c:	1ad3      	subs	r3, r2, r3
3400b90e:	68ba      	ldr	r2, [r7, #8]
3400b910:	429a      	cmp	r2, r3
3400b912:	d302      	bcc.n	3400b91a <I2C_WaitOnTXISFlagUntilTimeout+0x40>
3400b914:	68bb      	ldr	r3, [r7, #8]
3400b916:	2b00      	cmp	r3, #0
3400b918:	d11a      	bne.n	3400b950 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3400b91a:	68fb      	ldr	r3, [r7, #12]
3400b91c:	681b      	ldr	r3, [r3, #0]
3400b91e:	699b      	ldr	r3, [r3, #24]
3400b920:	f003 0302 	and.w	r3, r3, #2
3400b924:	2b02      	cmp	r3, #2
3400b926:	d013      	beq.n	3400b950 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3400b928:	68fb      	ldr	r3, [r7, #12]
3400b92a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b92c:	f043 0220 	orr.w	r2, r3, #32
3400b930:	68fb      	ldr	r3, [r7, #12]
3400b932:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
3400b934:	68fb      	ldr	r3, [r7, #12]
3400b936:	2220      	movs	r2, #32
3400b938:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
3400b93c:	68fb      	ldr	r3, [r7, #12]
3400b93e:	2200      	movs	r2, #0
3400b940:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3400b944:	68fb      	ldr	r3, [r7, #12]
3400b946:	2200      	movs	r2, #0
3400b948:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
3400b94c:	2301      	movs	r3, #1
3400b94e:	e007      	b.n	3400b960 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
3400b950:	68fb      	ldr	r3, [r7, #12]
3400b952:	681b      	ldr	r3, [r3, #0]
3400b954:	699b      	ldr	r3, [r3, #24]
3400b956:	f003 0302 	and.w	r3, r3, #2
3400b95a:	2b02      	cmp	r3, #2
3400b95c:	d1c4      	bne.n	3400b8e8 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
3400b95e:	2300      	movs	r3, #0
}
3400b960:	4618      	mov	r0, r3
3400b962:	3710      	adds	r7, #16
3400b964:	46bd      	mov	sp, r7
3400b966:	bd80      	pop	{r7, pc}

3400b968 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
3400b968:	b580      	push	{r7, lr}
3400b96a:	b084      	sub	sp, #16
3400b96c:	af00      	add	r7, sp, #0
3400b96e:	60f8      	str	r0, [r7, #12]
3400b970:	60b9      	str	r1, [r7, #8]
3400b972:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400b974:	e02f      	b.n	3400b9d6 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
3400b976:	687a      	ldr	r2, [r7, #4]
3400b978:	68b9      	ldr	r1, [r7, #8]
3400b97a:	68f8      	ldr	r0, [r7, #12]
3400b97c:	f000 f838 	bl	3400b9f0 <I2C_IsErrorOccurred>
3400b980:	4603      	mov	r3, r0
3400b982:	2b00      	cmp	r3, #0
3400b984:	d001      	beq.n	3400b98a <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
3400b986:	2301      	movs	r3, #1
3400b988:	e02d      	b.n	3400b9e6 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
3400b98a:	f7f9 f950 	bl	34004c2e <HAL_GetTick>
3400b98e:	4602      	mov	r2, r0
3400b990:	687b      	ldr	r3, [r7, #4]
3400b992:	1ad3      	subs	r3, r2, r3
3400b994:	68ba      	ldr	r2, [r7, #8]
3400b996:	429a      	cmp	r2, r3
3400b998:	d302      	bcc.n	3400b9a0 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
3400b99a:	68bb      	ldr	r3, [r7, #8]
3400b99c:	2b00      	cmp	r3, #0
3400b99e:	d11a      	bne.n	3400b9d6 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400b9a0:	68fb      	ldr	r3, [r7, #12]
3400b9a2:	681b      	ldr	r3, [r3, #0]
3400b9a4:	699b      	ldr	r3, [r3, #24]
3400b9a6:	f003 0320 	and.w	r3, r3, #32
3400b9aa:	2b20      	cmp	r3, #32
3400b9ac:	d013      	beq.n	3400b9d6 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
3400b9ae:	68fb      	ldr	r3, [r7, #12]
3400b9b0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400b9b2:	f043 0220 	orr.w	r2, r3, #32
3400b9b6:	68fb      	ldr	r3, [r7, #12]
3400b9b8:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
3400b9ba:	68fb      	ldr	r3, [r7, #12]
3400b9bc:	2220      	movs	r2, #32
3400b9be:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
3400b9c2:	68fb      	ldr	r3, [r7, #12]
3400b9c4:	2200      	movs	r2, #0
3400b9c6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
3400b9ca:	68fb      	ldr	r3, [r7, #12]
3400b9cc:	2200      	movs	r2, #0
3400b9ce:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
3400b9d2:	2301      	movs	r3, #1
3400b9d4:	e007      	b.n	3400b9e6 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400b9d6:	68fb      	ldr	r3, [r7, #12]
3400b9d8:	681b      	ldr	r3, [r3, #0]
3400b9da:	699b      	ldr	r3, [r3, #24]
3400b9dc:	f003 0320 	and.w	r3, r3, #32
3400b9e0:	2b20      	cmp	r3, #32
3400b9e2:	d1c8      	bne.n	3400b976 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
3400b9e4:	2300      	movs	r3, #0
}
3400b9e6:	4618      	mov	r0, r3
3400b9e8:	3710      	adds	r7, #16
3400b9ea:	46bd      	mov	sp, r7
3400b9ec:	bd80      	pop	{r7, pc}
	...

3400b9f0 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
3400b9f0:	b580      	push	{r7, lr}
3400b9f2:	b08a      	sub	sp, #40	@ 0x28
3400b9f4:	af00      	add	r7, sp, #0
3400b9f6:	60f8      	str	r0, [r7, #12]
3400b9f8:	60b9      	str	r1, [r7, #8]
3400b9fa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
3400b9fc:	2300      	movs	r3, #0
3400b9fe:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
3400ba02:	68fb      	ldr	r3, [r7, #12]
3400ba04:	681b      	ldr	r3, [r3, #0]
3400ba06:	699b      	ldr	r3, [r3, #24]
3400ba08:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
3400ba0a:	2300      	movs	r3, #0
3400ba0c:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
3400ba0e:	687b      	ldr	r3, [r7, #4]
3400ba10:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
3400ba12:	69bb      	ldr	r3, [r7, #24]
3400ba14:	f003 0310 	and.w	r3, r3, #16
3400ba18:	2b00      	cmp	r3, #0
3400ba1a:	d068      	beq.n	3400baee <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3400ba1c:	68fb      	ldr	r3, [r7, #12]
3400ba1e:	681b      	ldr	r3, [r3, #0]
3400ba20:	2210      	movs	r2, #16
3400ba22:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
3400ba24:	e049      	b.n	3400baba <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
3400ba26:	68bb      	ldr	r3, [r7, #8]
3400ba28:	f1b3 3fff 	cmp.w	r3, #4294967295
3400ba2c:	d045      	beq.n	3400baba <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
3400ba2e:	f7f9 f8fe 	bl	34004c2e <HAL_GetTick>
3400ba32:	4602      	mov	r2, r0
3400ba34:	69fb      	ldr	r3, [r7, #28]
3400ba36:	1ad3      	subs	r3, r2, r3
3400ba38:	68ba      	ldr	r2, [r7, #8]
3400ba3a:	429a      	cmp	r2, r3
3400ba3c:	d302      	bcc.n	3400ba44 <I2C_IsErrorOccurred+0x54>
3400ba3e:	68bb      	ldr	r3, [r7, #8]
3400ba40:	2b00      	cmp	r3, #0
3400ba42:	d13a      	bne.n	3400baba <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
3400ba44:	68fb      	ldr	r3, [r7, #12]
3400ba46:	681b      	ldr	r3, [r3, #0]
3400ba48:	685b      	ldr	r3, [r3, #4]
3400ba4a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400ba4e:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
3400ba50:	68fb      	ldr	r3, [r7, #12]
3400ba52:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
3400ba56:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
3400ba58:	68fb      	ldr	r3, [r7, #12]
3400ba5a:	681b      	ldr	r3, [r3, #0]
3400ba5c:	699b      	ldr	r3, [r3, #24]
3400ba5e:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400ba62:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
3400ba66:	d121      	bne.n	3400baac <I2C_IsErrorOccurred+0xbc>
3400ba68:	697b      	ldr	r3, [r7, #20]
3400ba6a:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3400ba6e:	d01d      	beq.n	3400baac <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
3400ba70:	7cfb      	ldrb	r3, [r7, #19]
3400ba72:	2b20      	cmp	r3, #32
3400ba74:	d01a      	beq.n	3400baac <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
3400ba76:	68fb      	ldr	r3, [r7, #12]
3400ba78:	681b      	ldr	r3, [r3, #0]
3400ba7a:	685a      	ldr	r2, [r3, #4]
3400ba7c:	68fb      	ldr	r3, [r7, #12]
3400ba7e:	681b      	ldr	r3, [r3, #0]
3400ba80:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
3400ba84:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
3400ba86:	f7f9 f8d2 	bl	34004c2e <HAL_GetTick>
3400ba8a:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400ba8c:	e00e      	b.n	3400baac <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
3400ba8e:	f7f9 f8ce 	bl	34004c2e <HAL_GetTick>
3400ba92:	4602      	mov	r2, r0
3400ba94:	69fb      	ldr	r3, [r7, #28]
3400ba96:	1ad3      	subs	r3, r2, r3
3400ba98:	2b19      	cmp	r3, #25
3400ba9a:	d907      	bls.n	3400baac <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
3400ba9c:	6a3b      	ldr	r3, [r7, #32]
3400ba9e:	f043 0320 	orr.w	r3, r3, #32
3400baa2:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
3400baa4:	2301      	movs	r3, #1
3400baa6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
3400baaa:	e006      	b.n	3400baba <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
3400baac:	68fb      	ldr	r3, [r7, #12]
3400baae:	681b      	ldr	r3, [r3, #0]
3400bab0:	699b      	ldr	r3, [r3, #24]
3400bab2:	f003 0320 	and.w	r3, r3, #32
3400bab6:	2b20      	cmp	r3, #32
3400bab8:	d1e9      	bne.n	3400ba8e <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
3400baba:	68fb      	ldr	r3, [r7, #12]
3400babc:	681b      	ldr	r3, [r3, #0]
3400babe:	699b      	ldr	r3, [r3, #24]
3400bac0:	f003 0320 	and.w	r3, r3, #32
3400bac4:	2b20      	cmp	r3, #32
3400bac6:	d003      	beq.n	3400bad0 <I2C_IsErrorOccurred+0xe0>
3400bac8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400bacc:	2b00      	cmp	r3, #0
3400bace:	d0aa      	beq.n	3400ba26 <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
3400bad0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400bad4:	2b00      	cmp	r3, #0
3400bad6:	d103      	bne.n	3400bae0 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
3400bad8:	68fb      	ldr	r3, [r7, #12]
3400bada:	681b      	ldr	r3, [r3, #0]
3400badc:	2220      	movs	r2, #32
3400bade:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
3400bae0:	6a3b      	ldr	r3, [r7, #32]
3400bae2:	f043 0304 	orr.w	r3, r3, #4
3400bae6:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
3400bae8:	2301      	movs	r3, #1
3400baea:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
3400baee:	68fb      	ldr	r3, [r7, #12]
3400baf0:	681b      	ldr	r3, [r3, #0]
3400baf2:	699b      	ldr	r3, [r3, #24]
3400baf4:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
3400baf6:	69bb      	ldr	r3, [r7, #24]
3400baf8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400bafc:	2b00      	cmp	r3, #0
3400bafe:	d00b      	beq.n	3400bb18 <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
3400bb00:	6a3b      	ldr	r3, [r7, #32]
3400bb02:	f043 0301 	orr.w	r3, r3, #1
3400bb06:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
3400bb08:	68fb      	ldr	r3, [r7, #12]
3400bb0a:	681b      	ldr	r3, [r3, #0]
3400bb0c:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400bb10:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3400bb12:	2301      	movs	r3, #1
3400bb14:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
3400bb18:	69bb      	ldr	r3, [r7, #24]
3400bb1a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400bb1e:	2b00      	cmp	r3, #0
3400bb20:	d00b      	beq.n	3400bb3a <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
3400bb22:	6a3b      	ldr	r3, [r7, #32]
3400bb24:	f043 0308 	orr.w	r3, r3, #8
3400bb28:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
3400bb2a:	68fb      	ldr	r3, [r7, #12]
3400bb2c:	681b      	ldr	r3, [r3, #0]
3400bb2e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
3400bb32:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3400bb34:	2301      	movs	r3, #1
3400bb36:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
3400bb3a:	69bb      	ldr	r3, [r7, #24]
3400bb3c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400bb40:	2b00      	cmp	r3, #0
3400bb42:	d00b      	beq.n	3400bb5c <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
3400bb44:	6a3b      	ldr	r3, [r7, #32]
3400bb46:	f043 0302 	orr.w	r3, r3, #2
3400bb4a:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
3400bb4c:	68fb      	ldr	r3, [r7, #12]
3400bb4e:	681b      	ldr	r3, [r3, #0]
3400bb50:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400bb54:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
3400bb56:	2301      	movs	r3, #1
3400bb58:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
3400bb5c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400bb60:	2b00      	cmp	r3, #0
3400bb62:	d01c      	beq.n	3400bb9e <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
3400bb64:	68f8      	ldr	r0, [r7, #12]
3400bb66:	f7ff fe3b 	bl	3400b7e0 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
3400bb6a:	68fb      	ldr	r3, [r7, #12]
3400bb6c:	681b      	ldr	r3, [r3, #0]
3400bb6e:	6859      	ldr	r1, [r3, #4]
3400bb70:	68fb      	ldr	r3, [r7, #12]
3400bb72:	681a      	ldr	r2, [r3, #0]
3400bb74:	4b0d      	ldr	r3, [pc, #52]	@ (3400bbac <I2C_IsErrorOccurred+0x1bc>)
3400bb76:	400b      	ands	r3, r1
3400bb78:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
3400bb7a:	68fb      	ldr	r3, [r7, #12]
3400bb7c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3400bb7e:	6a3b      	ldr	r3, [r7, #32]
3400bb80:	431a      	orrs	r2, r3
3400bb82:	68fb      	ldr	r3, [r7, #12]
3400bb84:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
3400bb86:	68fb      	ldr	r3, [r7, #12]
3400bb88:	2220      	movs	r2, #32
3400bb8a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
3400bb8e:	68fb      	ldr	r3, [r7, #12]
3400bb90:	2200      	movs	r2, #0
3400bb92:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400bb96:	68fb      	ldr	r3, [r7, #12]
3400bb98:	2200      	movs	r2, #0
3400bb9a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
3400bb9e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3400bba2:	4618      	mov	r0, r3
3400bba4:	3728      	adds	r7, #40	@ 0x28
3400bba6:	46bd      	mov	sp, r7
3400bba8:	bd80      	pop	{r7, pc}
3400bbaa:	bf00      	nop
3400bbac:	fe00e800 	.word	0xfe00e800

3400bbb0 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
3400bbb0:	b480      	push	{r7}
3400bbb2:	b087      	sub	sp, #28
3400bbb4:	af00      	add	r7, sp, #0
3400bbb6:	60f8      	str	r0, [r7, #12]
3400bbb8:	607b      	str	r3, [r7, #4]
3400bbba:	460b      	mov	r3, r1
3400bbbc:	817b      	strh	r3, [r7, #10]
3400bbbe:	4613      	mov	r3, r2
3400bbc0:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3400bbc2:	897b      	ldrh	r3, [r7, #10]
3400bbc4:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3400bbc8:	7a7b      	ldrb	r3, [r7, #9]
3400bbca:	041b      	lsls	r3, r3, #16
3400bbcc:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3400bbd0:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
3400bbd2:	687b      	ldr	r3, [r7, #4]
3400bbd4:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
3400bbd6:	6a3b      	ldr	r3, [r7, #32]
3400bbd8:	4313      	orrs	r3, r2
3400bbda:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400bbde:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
3400bbe0:	68fb      	ldr	r3, [r7, #12]
3400bbe2:	681b      	ldr	r3, [r3, #0]
3400bbe4:	685a      	ldr	r2, [r3, #4]
3400bbe6:	6a3b      	ldr	r3, [r7, #32]
3400bbe8:	0d5b      	lsrs	r3, r3, #21
3400bbea:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
3400bbee:	4b08      	ldr	r3, [pc, #32]	@ (3400bc10 <I2C_TransferConfig+0x60>)
3400bbf0:	430b      	orrs	r3, r1
3400bbf2:	43db      	mvns	r3, r3
3400bbf4:	ea02 0103 	and.w	r1, r2, r3
3400bbf8:	68fb      	ldr	r3, [r7, #12]
3400bbfa:	681b      	ldr	r3, [r3, #0]
3400bbfc:	697a      	ldr	r2, [r7, #20]
3400bbfe:	430a      	orrs	r2, r1
3400bc00:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
3400bc02:	bf00      	nop
3400bc04:	371c      	adds	r7, #28
3400bc06:	46bd      	mov	sp, r7
3400bc08:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bc0c:	4770      	bx	lr
3400bc0e:	bf00      	nop
3400bc10:	03ff63ff 	.word	0x03ff63ff

3400bc14 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
3400bc14:	b480      	push	{r7}
3400bc16:	b083      	sub	sp, #12
3400bc18:	af00      	add	r7, sp, #0
3400bc1a:	6078      	str	r0, [r7, #4]
3400bc1c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
3400bc1e:	687b      	ldr	r3, [r7, #4]
3400bc20:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400bc24:	b2db      	uxtb	r3, r3
3400bc26:	2b20      	cmp	r3, #32
3400bc28:	d138      	bne.n	3400bc9c <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3400bc2a:	687b      	ldr	r3, [r7, #4]
3400bc2c:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400bc30:	2b01      	cmp	r3, #1
3400bc32:	d101      	bne.n	3400bc38 <HAL_I2CEx_ConfigAnalogFilter+0x24>
3400bc34:	2302      	movs	r3, #2
3400bc36:	e032      	b.n	3400bc9e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
3400bc38:	687b      	ldr	r3, [r7, #4]
3400bc3a:	2201      	movs	r2, #1
3400bc3c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
3400bc40:	687b      	ldr	r3, [r7, #4]
3400bc42:	2224      	movs	r2, #36	@ 0x24
3400bc44:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3400bc48:	687b      	ldr	r3, [r7, #4]
3400bc4a:	681b      	ldr	r3, [r3, #0]
3400bc4c:	681a      	ldr	r2, [r3, #0]
3400bc4e:	687b      	ldr	r3, [r7, #4]
3400bc50:	681b      	ldr	r3, [r3, #0]
3400bc52:	f022 0201 	bic.w	r2, r2, #1
3400bc56:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
3400bc58:	687b      	ldr	r3, [r7, #4]
3400bc5a:	681b      	ldr	r3, [r3, #0]
3400bc5c:	681a      	ldr	r2, [r3, #0]
3400bc5e:	687b      	ldr	r3, [r7, #4]
3400bc60:	681b      	ldr	r3, [r3, #0]
3400bc62:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
3400bc66:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
3400bc68:	687b      	ldr	r3, [r7, #4]
3400bc6a:	681b      	ldr	r3, [r3, #0]
3400bc6c:	6819      	ldr	r1, [r3, #0]
3400bc6e:	687b      	ldr	r3, [r7, #4]
3400bc70:	681b      	ldr	r3, [r3, #0]
3400bc72:	683a      	ldr	r2, [r7, #0]
3400bc74:	430a      	orrs	r2, r1
3400bc76:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
3400bc78:	687b      	ldr	r3, [r7, #4]
3400bc7a:	681b      	ldr	r3, [r3, #0]
3400bc7c:	681a      	ldr	r2, [r3, #0]
3400bc7e:	687b      	ldr	r3, [r7, #4]
3400bc80:	681b      	ldr	r3, [r3, #0]
3400bc82:	f042 0201 	orr.w	r2, r2, #1
3400bc86:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
3400bc88:	687b      	ldr	r3, [r7, #4]
3400bc8a:	2220      	movs	r2, #32
3400bc8c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400bc90:	687b      	ldr	r3, [r7, #4]
3400bc92:	2200      	movs	r2, #0
3400bc94:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3400bc98:	2300      	movs	r3, #0
3400bc9a:	e000      	b.n	3400bc9e <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
3400bc9c:	2302      	movs	r3, #2
  }
}
3400bc9e:	4618      	mov	r0, r3
3400bca0:	370c      	adds	r7, #12
3400bca2:	46bd      	mov	sp, r7
3400bca4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bca8:	4770      	bx	lr

3400bcaa <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
3400bcaa:	b480      	push	{r7}
3400bcac:	b085      	sub	sp, #20
3400bcae:	af00      	add	r7, sp, #0
3400bcb0:	6078      	str	r0, [r7, #4]
3400bcb2:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
3400bcb4:	687b      	ldr	r3, [r7, #4]
3400bcb6:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400bcba:	b2db      	uxtb	r3, r3
3400bcbc:	2b20      	cmp	r3, #32
3400bcbe:	d139      	bne.n	3400bd34 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
3400bcc0:	687b      	ldr	r3, [r7, #4]
3400bcc2:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400bcc6:	2b01      	cmp	r3, #1
3400bcc8:	d101      	bne.n	3400bcce <HAL_I2CEx_ConfigDigitalFilter+0x24>
3400bcca:	2302      	movs	r3, #2
3400bccc:	e033      	b.n	3400bd36 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
3400bcce:	687b      	ldr	r3, [r7, #4]
3400bcd0:	2201      	movs	r2, #1
3400bcd2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
3400bcd6:	687b      	ldr	r3, [r7, #4]
3400bcd8:	2224      	movs	r2, #36	@ 0x24
3400bcda:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
3400bcde:	687b      	ldr	r3, [r7, #4]
3400bce0:	681b      	ldr	r3, [r3, #0]
3400bce2:	681a      	ldr	r2, [r3, #0]
3400bce4:	687b      	ldr	r3, [r7, #4]
3400bce6:	681b      	ldr	r3, [r3, #0]
3400bce8:	f022 0201 	bic.w	r2, r2, #1
3400bcec:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
3400bcee:	687b      	ldr	r3, [r7, #4]
3400bcf0:	681b      	ldr	r3, [r3, #0]
3400bcf2:	681b      	ldr	r3, [r3, #0]
3400bcf4:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
3400bcf6:	68fb      	ldr	r3, [r7, #12]
3400bcf8:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
3400bcfc:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
3400bcfe:	683b      	ldr	r3, [r7, #0]
3400bd00:	021b      	lsls	r3, r3, #8
3400bd02:	68fa      	ldr	r2, [r7, #12]
3400bd04:	4313      	orrs	r3, r2
3400bd06:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
3400bd08:	687b      	ldr	r3, [r7, #4]
3400bd0a:	681b      	ldr	r3, [r3, #0]
3400bd0c:	68fa      	ldr	r2, [r7, #12]
3400bd0e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
3400bd10:	687b      	ldr	r3, [r7, #4]
3400bd12:	681b      	ldr	r3, [r3, #0]
3400bd14:	681a      	ldr	r2, [r3, #0]
3400bd16:	687b      	ldr	r3, [r7, #4]
3400bd18:	681b      	ldr	r3, [r3, #0]
3400bd1a:	f042 0201 	orr.w	r2, r2, #1
3400bd1e:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
3400bd20:	687b      	ldr	r3, [r7, #4]
3400bd22:	2220      	movs	r2, #32
3400bd24:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
3400bd28:	687b      	ldr	r3, [r7, #4]
3400bd2a:	2200      	movs	r2, #0
3400bd2c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
3400bd30:	2300      	movs	r3, #0
3400bd32:	e000      	b.n	3400bd36 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
3400bd34:	2302      	movs	r3, #2
  }
}
3400bd36:	4618      	mov	r0, r3
3400bd38:	3714      	adds	r7, #20
3400bd3a:	46bd      	mov	sp, r7
3400bd3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bd40:	4770      	bx	lr

3400bd42 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
3400bd42:	b580      	push	{r7, lr}
3400bd44:	b084      	sub	sp, #16
3400bd46:	af00      	add	r7, sp, #0
3400bd48:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
3400bd4a:	687b      	ldr	r3, [r7, #4]
3400bd4c:	2b00      	cmp	r3, #0
3400bd4e:	d101      	bne.n	3400bd54 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
3400bd50:	2301      	movs	r3, #1
3400bd52:	e09d      	b.n	3400be90 <HAL_LTDC_Init+0x14e>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
3400bd54:	687b      	ldr	r3, [r7, #4]
3400bd56:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
3400bd5a:	b2db      	uxtb	r3, r3
3400bd5c:	2b00      	cmp	r3, #0
3400bd5e:	d106      	bne.n	3400bd6e <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
3400bd60:	687b      	ldr	r3, [r7, #4]
3400bd62:	2200      	movs	r2, #0
3400bd64:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
3400bd68:	6878      	ldr	r0, [r7, #4]
3400bd6a:	f7f8 fcdb 	bl	34004724 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3400bd6e:	687b      	ldr	r3, [r7, #4]
3400bd70:	2202      	movs	r2, #2
3400bd72:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
3400bd76:	687b      	ldr	r3, [r7, #4]
3400bd78:	681b      	ldr	r3, [r3, #0]
3400bd7a:	699a      	ldr	r2, [r3, #24]
3400bd7c:	687b      	ldr	r3, [r7, #4]
3400bd7e:	681b      	ldr	r3, [r3, #0]
3400bd80:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
3400bd84:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3400bd86:	687b      	ldr	r3, [r7, #4]
3400bd88:	681b      	ldr	r3, [r3, #0]
3400bd8a:	6999      	ldr	r1, [r3, #24]
3400bd8c:	687b      	ldr	r3, [r7, #4]
3400bd8e:	685a      	ldr	r2, [r3, #4]
3400bd90:	687b      	ldr	r3, [r7, #4]
3400bd92:	689b      	ldr	r3, [r3, #8]
3400bd94:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
3400bd96:	687b      	ldr	r3, [r7, #4]
3400bd98:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3400bd9a:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
3400bd9c:	687b      	ldr	r3, [r7, #4]
3400bd9e:	691b      	ldr	r3, [r3, #16]
3400bda0:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
3400bda2:	687b      	ldr	r3, [r7, #4]
3400bda4:	681b      	ldr	r3, [r3, #0]
3400bda6:	430a      	orrs	r2, r1
3400bda8:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
3400bdaa:	687b      	ldr	r3, [r7, #4]
3400bdac:	695b      	ldr	r3, [r3, #20]
3400bdae:	041b      	lsls	r3, r3, #16
3400bdb0:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
3400bdb2:	687b      	ldr	r3, [r7, #4]
3400bdb4:	6999      	ldr	r1, [r3, #24]
3400bdb6:	687b      	ldr	r3, [r7, #4]
3400bdb8:	681b      	ldr	r3, [r3, #0]
3400bdba:	68fa      	ldr	r2, [r7, #12]
3400bdbc:	430a      	orrs	r2, r1
3400bdbe:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
3400bdc0:	687b      	ldr	r3, [r7, #4]
3400bdc2:	69db      	ldr	r3, [r3, #28]
3400bdc4:	041b      	lsls	r3, r3, #16
3400bdc6:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
3400bdc8:	687b      	ldr	r3, [r7, #4]
3400bdca:	6a19      	ldr	r1, [r3, #32]
3400bdcc:	687b      	ldr	r3, [r7, #4]
3400bdce:	681b      	ldr	r3, [r3, #0]
3400bdd0:	68fa      	ldr	r2, [r7, #12]
3400bdd2:	430a      	orrs	r2, r1
3400bdd4:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
3400bdd6:	687b      	ldr	r3, [r7, #4]
3400bdd8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400bdda:	041b      	lsls	r3, r3, #16
3400bddc:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
3400bdde:	687b      	ldr	r3, [r7, #4]
3400bde0:	6a99      	ldr	r1, [r3, #40]	@ 0x28
3400bde2:	687b      	ldr	r3, [r7, #4]
3400bde4:	681b      	ldr	r3, [r3, #0]
3400bde6:	68fa      	ldr	r2, [r7, #12]
3400bde8:	430a      	orrs	r2, r1
3400bdea:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
3400bdec:	687b      	ldr	r3, [r7, #4]
3400bdee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400bdf0:	041b      	lsls	r3, r3, #16
3400bdf2:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
3400bdf4:	687b      	ldr	r3, [r7, #4]
3400bdf6:	6b19      	ldr	r1, [r3, #48]	@ 0x30
3400bdf8:	687b      	ldr	r3, [r7, #4]
3400bdfa:	681b      	ldr	r3, [r3, #0]
3400bdfc:	68fa      	ldr	r2, [r7, #12]
3400bdfe:	430a      	orrs	r2, r1
3400be00:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
3400be02:	687b      	ldr	r3, [r7, #4]
3400be04:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
3400be08:	021b      	lsls	r3, r3, #8
3400be0a:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
3400be0c:	687b      	ldr	r3, [r7, #4]
3400be0e:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3400be12:	041b      	lsls	r3, r3, #16
3400be14:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
3400be16:	687b      	ldr	r3, [r7, #4]
3400be18:	681b      	ldr	r3, [r3, #0]
3400be1a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3400be1c:	687b      	ldr	r3, [r7, #4]
3400be1e:	681b      	ldr	r3, [r3, #0]
3400be20:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
3400be24:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
3400be26:	687b      	ldr	r3, [r7, #4]
3400be28:	681b      	ldr	r3, [r3, #0]
3400be2a:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
3400be2c:	68ba      	ldr	r2, [r7, #8]
3400be2e:	68fb      	ldr	r3, [r7, #12]
3400be30:	4313      	orrs	r3, r2
3400be32:	687a      	ldr	r2, [r7, #4]
3400be34:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
3400be38:	431a      	orrs	r2, r3
3400be3a:	687b      	ldr	r3, [r7, #4]
3400be3c:	681b      	ldr	r3, [r3, #0]
3400be3e:	430a      	orrs	r2, r1
3400be40:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
3400be42:	687b      	ldr	r3, [r7, #4]
3400be44:	681b      	ldr	r3, [r3, #0]
3400be46:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400be4a:	461a      	mov	r2, r3
3400be4c:	2304      	movs	r3, #4
3400be4e:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
3400be50:	687b      	ldr	r3, [r7, #4]
3400be52:	681b      	ldr	r3, [r3, #0]
3400be54:	f503 7300 	add.w	r3, r3, #512	@ 0x200
3400be58:	461a      	mov	r2, r3
3400be5a:	2304      	movs	r3, #4
3400be5c:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
3400be5e:	687b      	ldr	r3, [r7, #4]
3400be60:	681b      	ldr	r3, [r3, #0]
3400be62:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
3400be64:	687b      	ldr	r3, [r7, #4]
3400be66:	681b      	ldr	r3, [r3, #0]
3400be68:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
3400be6c:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
3400be6e:	687b      	ldr	r3, [r7, #4]
3400be70:	681b      	ldr	r3, [r3, #0]
3400be72:	699a      	ldr	r2, [r3, #24]
3400be74:	687b      	ldr	r3, [r7, #4]
3400be76:	681b      	ldr	r3, [r3, #0]
3400be78:	f042 0201 	orr.w	r2, r2, #1
3400be7c:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
3400be7e:	687b      	ldr	r3, [r7, #4]
3400be80:	2200      	movs	r2, #0
3400be82:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
3400be86:	687b      	ldr	r3, [r7, #4]
3400be88:	2201      	movs	r2, #1
3400be8a:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
3400be8e:	2300      	movs	r3, #0
}
3400be90:	4618      	mov	r0, r3
3400be92:	3710      	adds	r7, #16
3400be94:	46bd      	mov	sp, r7
3400be96:	bd80      	pop	{r7, pc}

3400be98 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
3400be98:	b5b0      	push	{r4, r5, r7, lr}
3400be9a:	b086      	sub	sp, #24
3400be9c:	af02      	add	r7, sp, #8
3400be9e:	60f8      	str	r0, [r7, #12]
3400bea0:	60b9      	str	r1, [r7, #8]
3400bea2:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
3400bea4:	68fb      	ldr	r3, [r7, #12]
3400bea6:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
3400beaa:	2b01      	cmp	r3, #1
3400beac:	d101      	bne.n	3400beb2 <HAL_LTDC_ConfigLayer+0x1a>
3400beae:	2302      	movs	r3, #2
3400beb0:	e052      	b.n	3400bf58 <HAL_LTDC_ConfigLayer+0xc0>
3400beb2:	68fb      	ldr	r3, [r7, #12]
3400beb4:	2201      	movs	r2, #1
3400beb6:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3400beba:	68fb      	ldr	r3, [r7, #12]
3400bebc:	2202      	movs	r2, #2
3400bebe:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
3400bec2:	68fa      	ldr	r2, [r7, #12]
3400bec4:	687b      	ldr	r3, [r7, #4]
3400bec6:	2134      	movs	r1, #52	@ 0x34
3400bec8:	fb01 f303 	mul.w	r3, r1, r3
3400becc:	4413      	add	r3, r2
3400bece:	f103 0238 	add.w	r2, r3, #56	@ 0x38
3400bed2:	68bb      	ldr	r3, [r7, #8]
3400bed4:	4614      	mov	r4, r2
3400bed6:	461d      	mov	r5, r3
3400bed8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400beda:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400bedc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400bede:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400bee0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400bee2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400bee4:	682b      	ldr	r3, [r5, #0]
3400bee6:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
3400bee8:	6879      	ldr	r1, [r7, #4]
3400beea:	68f8      	ldr	r0, [r7, #12]
3400beec:	f001 fb22 	bl	3400d534 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
3400bef0:	6879      	ldr	r1, [r7, #4]
3400bef2:	68f8      	ldr	r0, [r7, #12]
3400bef4:	f001 fa76 	bl	3400d3e4 <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
3400bef8:	68fb      	ldr	r3, [r7, #12]
3400befa:	681b      	ldr	r3, [r3, #0]
3400befc:	461a      	mov	r2, r3
3400befe:	687b      	ldr	r3, [r7, #4]
3400bf00:	021b      	lsls	r3, r3, #8
3400bf02:	4413      	add	r3, r2
3400bf04:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400bf08:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400bf0a:	68fa      	ldr	r2, [r7, #12]
3400bf0c:	6812      	ldr	r2, [r2, #0]
3400bf0e:	4611      	mov	r1, r2
3400bf10:	687a      	ldr	r2, [r7, #4]
3400bf12:	0212      	lsls	r2, r2, #8
3400bf14:	440a      	add	r2, r1
3400bf16:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400bf1a:	f023 0308 	bic.w	r3, r3, #8
3400bf1e:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
3400bf20:	687b      	ldr	r3, [r7, #4]
3400bf22:	9300      	str	r3, [sp, #0]
3400bf24:	2303      	movs	r3, #3
3400bf26:	2200      	movs	r2, #0
3400bf28:	2100      	movs	r1, #0
3400bf2a:	68f8      	ldr	r0, [r7, #12]
3400bf2c:	f000 fbce 	bl	3400c6cc <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
3400bf30:	68fb      	ldr	r3, [r7, #12]
3400bf32:	681b      	ldr	r3, [r3, #0]
3400bf34:	461a      	mov	r2, r3
3400bf36:	687b      	ldr	r3, [r7, #4]
3400bf38:	021b      	lsls	r3, r3, #8
3400bf3a:	4413      	add	r3, r2
3400bf3c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400bf40:	461a      	mov	r2, r3
3400bf42:	2305      	movs	r3, #5
3400bf44:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
3400bf46:	68fb      	ldr	r3, [r7, #12]
3400bf48:	2201      	movs	r2, #1
3400bf4a:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
3400bf4e:	68fb      	ldr	r3, [r7, #12]
3400bf50:	2200      	movs	r2, #0
3400bf52:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
3400bf56:	2300      	movs	r3, #0
}
3400bf58:	4618      	mov	r0, r3
3400bf5a:	3710      	adds	r7, #16
3400bf5c:	46bd      	mov	sp, r7
3400bf5e:	bdb0      	pop	{r4, r5, r7, pc}

3400bf60 <HAL_LTDC_ReloadLayer>:
  *                 - LTDC_LAYER_2: Reload configuration for layer 2.
  * @note   User application may resort to HAL_LTDC_ReloadEventCallback() at reload interrupt generation.
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ReloadLayer(LTDC_HandleTypeDef *hltdc, uint32_t ReloadType, uint32_t LayerIdx)
{
3400bf60:	b480      	push	{r7}
3400bf62:	b085      	sub	sp, #20
3400bf64:	af00      	add	r7, sp, #0
3400bf66:	60f8      	str	r0, [r7, #12]
3400bf68:	60b9      	str	r1, [r7, #8]
3400bf6a:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_LTDC_RELOAD(ReloadType));

  /* Process locked */
  __HAL_LOCK(hltdc);
3400bf6c:	68fb      	ldr	r3, [r7, #12]
3400bf6e:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
3400bf72:	2b01      	cmp	r3, #1
3400bf74:	d101      	bne.n	3400bf7a <HAL_LTDC_ReloadLayer+0x1a>
3400bf76:	2302      	movs	r3, #2
3400bf78:	e025      	b.n	3400bfc6 <HAL_LTDC_ReloadLayer+0x66>
3400bf7a:	68fb      	ldr	r3, [r7, #12]
3400bf7c:	2201      	movs	r2, #1
3400bf7e:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3400bf82:	68fb      	ldr	r3, [r7, #12]
3400bf84:	2202      	movs	r2, #2
3400bf86:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Enable the Reload interrupt */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_RR);
3400bf8a:	68fb      	ldr	r3, [r7, #12]
3400bf8c:	681b      	ldr	r3, [r3, #0]
3400bf8e:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
3400bf90:	68fb      	ldr	r3, [r7, #12]
3400bf92:	681b      	ldr	r3, [r3, #0]
3400bf94:	f042 0208 	orr.w	r2, r2, #8
3400bf98:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Apply Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, ReloadType | LTDC_LxRCR_GRMSK);
3400bf9a:	68fb      	ldr	r3, [r7, #12]
3400bf9c:	681b      	ldr	r3, [r3, #0]
3400bf9e:	461a      	mov	r2, r3
3400bfa0:	687b      	ldr	r3, [r7, #4]
3400bfa2:	021b      	lsls	r3, r3, #8
3400bfa4:	4413      	add	r3, r2
3400bfa6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400bfaa:	461a      	mov	r2, r3
3400bfac:	68bb      	ldr	r3, [r7, #8]
3400bfae:	f043 0304 	orr.w	r3, r3, #4
3400bfb2:	6093      	str	r3, [r2, #8]

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
3400bfb4:	68fb      	ldr	r3, [r7, #12]
3400bfb6:	2201      	movs	r2, #1
3400bfb8:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
3400bfbc:	68fb      	ldr	r3, [r7, #12]
3400bfbe:	2200      	movs	r2, #0
3400bfc0:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
3400bfc4:	2300      	movs	r3, #0
}
3400bfc6:	4618      	mov	r0, r3
3400bfc8:	3714      	adds	r7, #20
3400bfca:	46bd      	mov	sp, r7
3400bfcc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bfd0:	4770      	bx	lr

3400bfd2 <HAL_LTDC_SetAddress_NoReload>:
  *                   This parameter can be one of the following values:
  *                   LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1).
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetAddress_NoReload(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
3400bfd2:	b580      	push	{r7, lr}
3400bfd4:	b08a      	sub	sp, #40	@ 0x28
3400bfd6:	af02      	add	r7, sp, #8
3400bfd8:	60f8      	str	r0, [r7, #12]
3400bfda:	60b9      	str	r1, [r7, #8]
3400bfdc:	607a      	str	r2, [r7, #4]
  uint32_t aux0Addr = 0U;
3400bfde:	2300      	movs	r3, #0
3400bfe0:	61fb      	str	r3, [r7, #28]
  uint32_t aux1Addr = 0U;
3400bfe2:	2300      	movs	r3, #0
3400bfe4:	61bb      	str	r3, [r7, #24]
  uint32_t mirror = 0U;
3400bfe6:	2300      	movs	r3, #0
3400bfe8:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Process locked */
  __HAL_LOCK(hltdc);
3400bfea:	68fb      	ldr	r3, [r7, #12]
3400bfec:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
3400bff0:	2b01      	cmp	r3, #1
3400bff2:	d101      	bne.n	3400bff8 <HAL_LTDC_SetAddress_NoReload+0x26>
3400bff4:	2302      	movs	r3, #2
3400bff6:	e02e      	b.n	3400c056 <HAL_LTDC_SetAddress_NoReload+0x84>
3400bff8:	68fb      	ldr	r3, [r7, #12]
3400bffa:	2201      	movs	r2, #1
3400bffc:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
3400c000:	68fb      	ldr	r3, [r7, #12]
3400c002:	2202      	movs	r2, #2
3400c004:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Get previous user configuration */
  LTDC_RetrieveUserConfig(hltdc, &mirror, &aux0Addr, &aux1Addr, LayerIdx);
3400c008:	f107 0018 	add.w	r0, r7, #24
3400c00c:	f107 021c 	add.w	r2, r7, #28
3400c010:	f107 0114 	add.w	r1, r7, #20
3400c014:	687b      	ldr	r3, [r7, #4]
3400c016:	9300      	str	r3, [sp, #0]
3400c018:	4603      	mov	r3, r0
3400c01a:	68f8      	ldr	r0, [r7, #12]
3400c01c:	f000 f81f 	bl	3400c05e <LTDC_RetrieveUserConfig>

  /* Reconfigure the Address */
  hltdc->LayerCfg[LayerIdx].FBStartAdress = Address;
3400c020:	68fa      	ldr	r2, [r7, #12]
3400c022:	687b      	ldr	r3, [r7, #4]
3400c024:	2134      	movs	r1, #52	@ 0x34
3400c026:	fb01 f303 	mul.w	r3, r1, r3
3400c02a:	4413      	add	r3, r2
3400c02c:	335c      	adds	r3, #92	@ 0x5c
3400c02e:	68ba      	ldr	r2, [r7, #8]
3400c030:	601a      	str	r2, [r3, #0]

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, 0, 0, mirror, LayerIdx);
3400c032:	697a      	ldr	r2, [r7, #20]
3400c034:	687b      	ldr	r3, [r7, #4]
3400c036:	9300      	str	r3, [sp, #0]
3400c038:	4613      	mov	r3, r2
3400c03a:	2200      	movs	r2, #0
3400c03c:	2100      	movs	r1, #0
3400c03e:	68f8      	ldr	r0, [r7, #12]
3400c040:	f000 fb44 	bl	3400c6cc <LTDC_SetConfig>

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
3400c044:	68fb      	ldr	r3, [r7, #12]
3400c046:	2201      	movs	r2, #1
3400c048:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
3400c04c:	68fb      	ldr	r3, [r7, #12]
3400c04e:	2200      	movs	r2, #0
3400c050:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
3400c054:	2300      	movs	r3, #0
}
3400c056:	4618      	mov	r0, r3
3400c058:	3720      	adds	r7, #32
3400c05a:	46bd      	mov	sp, r7
3400c05c:	bd80      	pop	{r7, pc}

3400c05e <LTDC_RetrieveUserConfig>:
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
  */
static void LTDC_RetrieveUserConfig(LTDC_HandleTypeDef *hltdc, uint32_t *Mirror, uint32_t *Aux0Addr,
                                    uint32_t *Aux1Addr, uint32_t LayerIdx)
{
3400c05e:	b4b0      	push	{r4, r5, r7}
3400c060:	b089      	sub	sp, #36	@ 0x24
3400c062:	af00      	add	r7, sp, #0
3400c064:	60f8      	str	r0, [r7, #12]
3400c066:	60b9      	str	r1, [r7, #8]
3400c068:	607a      	str	r2, [r7, #4]
3400c06a:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  const uint32_t hmirror = ((LTDC_LAYER(hltdc, LayerIdx)->CR) & LTDC_LxCR_HMEN_Msk);
3400c06c:	68fb      	ldr	r3, [r7, #12]
3400c06e:	681b      	ldr	r3, [r3, #0]
3400c070:	461a      	mov	r2, r3
3400c072:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c074:	021b      	lsls	r3, r3, #8
3400c076:	4413      	add	r3, r2
3400c078:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c07c:	68db      	ldr	r3, [r3, #12]
3400c07e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400c082:	61bb      	str	r3, [r7, #24]
  const uint32_t pitchSign = (LTDC_LAYER(hltdc, LayerIdx)->CFBLR & LTDC_LxCFBLR_CFBP) & LTDC_PITCH_SIGN_MSK;
3400c084:	68fb      	ldr	r3, [r7, #12]
3400c086:	681b      	ldr	r3, [r3, #0]
3400c088:	461a      	mov	r2, r3
3400c08a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c08c:	021b      	lsls	r3, r3, #8
3400c08e:	4413      	add	r3, r2
3400c090:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c094:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400c096:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400c09a:	617b      	str	r3, [r7, #20]

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c09c:	68fa      	ldr	r2, [r7, #12]
3400c09e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c0a0:	2134      	movs	r1, #52	@ 0x34
3400c0a2:	fb01 f303 	mul.w	r3, r1, r3
3400c0a6:	4413      	add	r3, r2
3400c0a8:	3348      	adds	r3, #72	@ 0x48
3400c0aa:	681b      	ldr	r3, [r3, #0]
3400c0ac:	2b03      	cmp	r3, #3
3400c0ae:	d821      	bhi.n	3400c0f4 <LTDC_RetrieveUserConfig+0x96>
3400c0b0:	e025      	b.n	3400c0fe <LTDC_RetrieveUserConfig+0xa0>
3400c0b2:	3b04      	subs	r3, #4
3400c0b4:	2201      	movs	r2, #1
3400c0b6:	fa02 f303 	lsl.w	r3, r2, r3
3400c0ba:	f240 229b 	movw	r2, #667	@ 0x29b
3400c0be:	401a      	ands	r2, r3
3400c0c0:	2a00      	cmp	r2, #0
3400c0c2:	bf14      	ite	ne
3400c0c4:	2201      	movne	r2, #1
3400c0c6:	2200      	moveq	r2, #0
3400c0c8:	b2d2      	uxtb	r2, r2
3400c0ca:	2a00      	cmp	r2, #0
3400c0cc:	d11d      	bne.n	3400c10a <LTDC_RetrieveUserConfig+0xac>
3400c0ce:	f403 7280 	and.w	r2, r3, #256	@ 0x100
3400c0d2:	2a00      	cmp	r2, #0
3400c0d4:	bf14      	ite	ne
3400c0d6:	2201      	movne	r2, #1
3400c0d8:	2200      	moveq	r2, #0
3400c0da:	b2d2      	uxtb	r2, r2
3400c0dc:	2a00      	cmp	r2, #0
3400c0de:	d117      	bne.n	3400c110 <LTDC_RetrieveUserConfig+0xb2>
3400c0e0:	f003 0304 	and.w	r3, r3, #4
3400c0e4:	2b00      	cmp	r3, #0
3400c0e6:	bf14      	ite	ne
3400c0e8:	2301      	movne	r3, #1
3400c0ea:	2300      	moveq	r3, #0
3400c0ec:	b2db      	uxtb	r3, r3
3400c0ee:	2b00      	cmp	r3, #0
3400c0f0:	d108      	bne.n	3400c104 <LTDC_RetrieveUserConfig+0xa6>
3400c0f2:	e01b      	b.n	3400c12c <LTDC_RetrieveUserConfig+0xce>
3400c0f4:	2b0d      	cmp	r3, #13
3400c0f6:	d819      	bhi.n	3400c12c <LTDC_RetrieveUserConfig+0xce>
3400c0f8:	2b04      	cmp	r3, #4
3400c0fa:	d2da      	bcs.n	3400c0b2 <LTDC_RetrieveUserConfig+0x54>
3400c0fc:	e016      	b.n	3400c12c <LTDC_RetrieveUserConfig+0xce>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3400c0fe:	2304      	movs	r3, #4
3400c100:	61fb      	str	r3, [r7, #28]
      break;
3400c102:	e016      	b.n	3400c132 <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
3400c104:	2303      	movs	r3, #3
3400c106:	61fb      	str	r3, [r7, #28]
      break;
3400c108:	e013      	b.n	3400c132 <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3400c10a:	2302      	movs	r3, #2
3400c10c:	61fb      	str	r3, [r7, #28]
      break;
3400c10e:	e010      	b.n	3400c132 <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = ((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos;
3400c110:	68fb      	ldr	r3, [r7, #12]
3400c112:	681b      	ldr	r3, [r3, #0]
3400c114:	461a      	mov	r2, r3
3400c116:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c118:	021b      	lsls	r3, r3, #8
3400c11a:	4413      	add	r3, r2
3400c11c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c120:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c122:	0c9b      	lsrs	r3, r3, #18
3400c124:	f003 0307 	and.w	r3, r3, #7
3400c128:	61fb      	str	r3, [r7, #28]
      break;
3400c12a:	e002      	b.n	3400c132 <LTDC_RetrieveUserConfig+0xd4>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3400c12c:	2301      	movs	r3, #1
3400c12e:	61fb      	str	r3, [r7, #28]
      break;
3400c130:	bf00      	nop
  }

  if ((pitchSign == 0U) && (hmirror == 0U))
3400c132:	697b      	ldr	r3, [r7, #20]
3400c134:	2b00      	cmp	r3, #0
3400c136:	d12d      	bne.n	3400c194 <LTDC_RetrieveUserConfig+0x136>
3400c138:	69bb      	ldr	r3, [r7, #24]
3400c13a:	2b00      	cmp	r3, #0
3400c13c:	d12a      	bne.n	3400c194 <LTDC_RetrieveUserConfig+0x136>
  {
    *Mirror = LTDC_MIRROR_NONE;
3400c13e:	68bb      	ldr	r3, [r7, #8]
3400c140:	2203      	movs	r2, #3
3400c142:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR;
3400c144:	68fb      	ldr	r3, [r7, #12]
3400c146:	681b      	ldr	r3, [r3, #0]
3400c148:	461a      	mov	r2, r3
3400c14a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c14c:	021b      	lsls	r3, r3, #8
3400c14e:	4413      	add	r3, r2
3400c150:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c154:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3400c156:	68f9      	ldr	r1, [r7, #12]
3400c158:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c15a:	2034      	movs	r0, #52	@ 0x34
3400c15c:	fb00 f303 	mul.w	r3, r0, r3
3400c160:	440b      	add	r3, r1
3400c162:	335c      	adds	r3, #92	@ 0x5c
3400c164:	601a      	str	r2, [r3, #0]
    *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R;
3400c166:	68fb      	ldr	r3, [r7, #12]
3400c168:	681b      	ldr	r3, [r3, #0]
3400c16a:	461a      	mov	r2, r3
3400c16c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c16e:	021b      	lsls	r3, r3, #8
3400c170:	4413      	add	r3, r2
3400c172:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c176:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400c178:	687b      	ldr	r3, [r7, #4]
3400c17a:	601a      	str	r2, [r3, #0]
    *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R;
3400c17c:	68fb      	ldr	r3, [r7, #12]
3400c17e:	681b      	ldr	r3, [r3, #0]
3400c180:	461a      	mov	r2, r3
3400c182:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c184:	021b      	lsls	r3, r3, #8
3400c186:	4413      	add	r3, r2
3400c188:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c18c:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3400c18e:	683b      	ldr	r3, [r7, #0]
3400c190:	601a      	str	r2, [r3, #0]
3400c192:	e296      	b.n	3400c6c2 <LTDC_RetrieveUserConfig+0x664>
  }
  else if ((pitchSign == 0U) && (hmirror == LTDC_LxCR_HMEN))
3400c194:	697b      	ldr	r3, [r7, #20]
3400c196:	2b00      	cmp	r3, #0
3400c198:	f040 80a8 	bne.w	3400c2ec <LTDC_RetrieveUserConfig+0x28e>
3400c19c:	69bb      	ldr	r3, [r7, #24]
3400c19e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400c1a2:	f040 80a3 	bne.w	3400c2ec <LTDC_RetrieveUserConfig+0x28e>
  {
    *Mirror = LTDC_MIRROR_HORIZONTAL;
3400c1a6:	68bb      	ldr	r3, [r7, #8]
3400c1a8:	2200      	movs	r2, #0
3400c1aa:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c1ac:	68fb      	ldr	r3, [r7, #12]
3400c1ae:	681b      	ldr	r3, [r3, #0]
3400c1b0:	461a      	mov	r2, r3
3400c1b2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c1b4:	021b      	lsls	r3, r3, #8
3400c1b6:	4413      	add	r3, r2
3400c1b8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c1bc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c1be:	68f9      	ldr	r1, [r7, #12]
3400c1c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c1c2:	2034      	movs	r0, #52	@ 0x34
3400c1c4:	fb00 f303 	mul.w	r3, r0, r3
3400c1c8:	440b      	add	r3, r1
3400c1ca:	333c      	adds	r3, #60	@ 0x3c
3400c1cc:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
3400c1ce:	68f8      	ldr	r0, [r7, #12]
3400c1d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c1d2:	2434      	movs	r4, #52	@ 0x34
3400c1d4:	fb04 f303 	mul.w	r3, r4, r3
3400c1d8:	4403      	add	r3, r0
3400c1da:	3338      	adds	r3, #56	@ 0x38
3400c1dc:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c1de:	1acb      	subs	r3, r1, r3
3400c1e0:	69f9      	ldr	r1, [r7, #28]
3400c1e2:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c1e6:	1ad3      	subs	r3, r2, r3
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
3400c1e8:	1c5a      	adds	r2, r3, #1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c1ea:	68f9      	ldr	r1, [r7, #12]
3400c1ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c1ee:	2034      	movs	r0, #52	@ 0x34
3400c1f0:	fb00 f303 	mul.w	r3, r0, r3
3400c1f4:	440b      	add	r3, r1
3400c1f6:	335c      	adds	r3, #92	@ 0x5c
3400c1f8:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c1fa:	68fa      	ldr	r2, [r7, #12]
3400c1fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c1fe:	2134      	movs	r1, #52	@ 0x34
3400c200:	fb01 f303 	mul.w	r3, r1, r3
3400c204:	4413      	add	r3, r2
3400c206:	3348      	adds	r3, #72	@ 0x48
3400c208:	681b      	ldr	r3, [r3, #0]
3400c20a:	f240 120d 	movw	r2, #269	@ 0x10d
3400c20e:	4293      	cmp	r3, r2
3400c210:	d004      	beq.n	3400c21c <LTDC_RetrieveUserConfig+0x1be>
3400c212:	f240 220d 	movw	r2, #525	@ 0x20d
3400c216:	4293      	cmp	r3, r2
3400c218:	d022      	beq.n	3400c260 <LTDC_RetrieveUserConfig+0x202>
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
        break;
      default:
        /* Nothing to do */
        break;
3400c21a:	e066      	b.n	3400c2ea <LTDC_RetrieveUserConfig+0x28c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c21c:	68fb      	ldr	r3, [r7, #12]
3400c21e:	681b      	ldr	r3, [r3, #0]
3400c220:	461a      	mov	r2, r3
3400c222:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c224:	021b      	lsls	r3, r3, #8
3400c226:	4413      	add	r3, r2
3400c228:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c22c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                    (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c22e:	68f9      	ldr	r1, [r7, #12]
3400c230:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c232:	2034      	movs	r0, #52	@ 0x34
3400c234:	fb00 f303 	mul.w	r3, r0, r3
3400c238:	440b      	add	r3, r1
3400c23a:	333c      	adds	r3, #60	@ 0x3c
3400c23c:	6819      	ldr	r1, [r3, #0]
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
3400c23e:	68f8      	ldr	r0, [r7, #12]
3400c240:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c242:	2434      	movs	r4, #52	@ 0x34
3400c244:	fb04 f303 	mul.w	r3, r4, r3
3400c248:	4403      	add	r3, r0
3400c24a:	3338      	adds	r3, #56	@ 0x38
3400c24c:	681b      	ldr	r3, [r3, #0]
                    (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c24e:	1acb      	subs	r3, r1, r3
3400c250:	69f9      	ldr	r1, [r7, #28]
3400c252:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c256:	1ad3      	subs	r3, r2, r3
                               hltdc->LayerCfg[LayerIdx].WindowX0)) + 1U;
3400c258:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c25a:	687b      	ldr	r3, [r7, #4]
3400c25c:	601a      	str	r2, [r3, #0]
        break;
3400c25e:	e044      	b.n	3400c2ea <LTDC_RetrieveUserConfig+0x28c>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c260:	68fb      	ldr	r3, [r7, #12]
3400c262:	681b      	ldr	r3, [r3, #0]
3400c264:	461a      	mov	r2, r3
3400c266:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c268:	021b      	lsls	r3, r3, #8
3400c26a:	4413      	add	r3, r2
3400c26c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c270:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c272:	68f9      	ldr	r1, [r7, #12]
3400c274:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c276:	2034      	movs	r0, #52	@ 0x34
3400c278:	fb00 f303 	mul.w	r3, r0, r3
3400c27c:	440b      	add	r3, r1
3400c27e:	333c      	adds	r3, #60	@ 0x3c
3400c280:	6819      	ldr	r1, [r3, #0]
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c282:	68f8      	ldr	r0, [r7, #12]
3400c284:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c286:	2434      	movs	r4, #52	@ 0x34
3400c288:	fb04 f303 	mul.w	r3, r4, r3
3400c28c:	4403      	add	r3, r0
3400c28e:	3338      	adds	r3, #56	@ 0x38
3400c290:	681b      	ldr	r3, [r3, #0]
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c292:	1acb      	subs	r3, r1, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c294:	085b      	lsrs	r3, r3, #1
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c296:	69f9      	ldr	r1, [r7, #28]
3400c298:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c29c:	1ad3      	subs	r3, r2, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c29e:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - \
3400c2a0:	687b      	ldr	r3, [r7, #4]
3400c2a2:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
3400c2a4:	68fb      	ldr	r3, [r7, #12]
3400c2a6:	681b      	ldr	r3, [r3, #0]
3400c2a8:	461a      	mov	r2, r3
3400c2aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c2ac:	021b      	lsls	r3, r3, #8
3400c2ae:	4413      	add	r3, r2
3400c2b0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c2b4:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c2b6:	68f9      	ldr	r1, [r7, #12]
3400c2b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c2ba:	2034      	movs	r0, #52	@ 0x34
3400c2bc:	fb00 f303 	mul.w	r3, r0, r3
3400c2c0:	440b      	add	r3, r1
3400c2c2:	333c      	adds	r3, #60	@ 0x3c
3400c2c4:	6819      	ldr	r1, [r3, #0]
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c2c6:	68f8      	ldr	r0, [r7, #12]
3400c2c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c2ca:	2434      	movs	r4, #52	@ 0x34
3400c2cc:	fb04 f303 	mul.w	r3, r4, r3
3400c2d0:	4403      	add	r3, r0
3400c2d2:	3338      	adds	r3, #56	@ 0x38
3400c2d4:	681b      	ldr	r3, [r3, #0]
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c2d6:	1acb      	subs	r3, r1, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c2d8:	085b      	lsrs	r3, r3, #1
                    (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c2da:	69f9      	ldr	r1, [r7, #28]
3400c2dc:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
3400c2e0:	1ad3      	subs	r3, r2, r3
                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) + 1U;
3400c2e2:	1c5a      	adds	r2, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - \
3400c2e4:	683b      	ldr	r3, [r7, #0]
3400c2e6:	601a      	str	r2, [r3, #0]
        break;
3400c2e8:	bf00      	nop
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c2ea:	e1ea      	b.n	3400c6c2 <LTDC_RetrieveUserConfig+0x664>
    }

  }
  else if ((pitchSign != 0U) && (hmirror == 0U))
3400c2ec:	697b      	ldr	r3, [r7, #20]
3400c2ee:	2b00      	cmp	r3, #0
3400c2f0:	f000 80f6 	beq.w	3400c4e0 <LTDC_RetrieveUserConfig+0x482>
3400c2f4:	69bb      	ldr	r3, [r7, #24]
3400c2f6:	2b00      	cmp	r3, #0
3400c2f8:	f040 80f2 	bne.w	3400c4e0 <LTDC_RetrieveUserConfig+0x482>
  {
    *Mirror = LTDC_MIRROR_VERTICAL;
3400c2fc:	68bb      	ldr	r3, [r7, #8]
3400c2fe:	2201      	movs	r2, #1
3400c300:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c302:	68fb      	ldr	r3, [r7, #12]
3400c304:	681b      	ldr	r3, [r3, #0]
3400c306:	461a      	mov	r2, r3
3400c308:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c30a:	021b      	lsls	r3, r3, #8
3400c30c:	4413      	add	r3, r2
3400c30e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c312:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c314:	68f9      	ldr	r1, [r7, #12]
3400c316:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c318:	2034      	movs	r0, #52	@ 0x34
3400c31a:	fb00 f303 	mul.w	r3, r0, r3
3400c31e:	440b      	add	r3, r1
3400c320:	333c      	adds	r3, #60	@ 0x3c
3400c322:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c324:	68f8      	ldr	r0, [r7, #12]
3400c326:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c328:	2434      	movs	r4, #52	@ 0x34
3400c32a:	fb04 f303 	mul.w	r3, r4, r3
3400c32e:	4403      	add	r3, r0
3400c330:	3338      	adds	r3, #56	@ 0x38
3400c332:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c334:	1acb      	subs	r3, r1, r3
3400c336:	69f9      	ldr	r1, [r7, #28]
3400c338:	fb01 f303 	mul.w	r3, r1, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c33c:	68f8      	ldr	r0, [r7, #12]
3400c33e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c340:	2434      	movs	r4, #52	@ 0x34
3400c342:	fb04 f101 	mul.w	r1, r4, r1
3400c346:	4401      	add	r1, r0
3400c348:	3144      	adds	r1, #68	@ 0x44
3400c34a:	6808      	ldr	r0, [r1, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400c34c:	68fc      	ldr	r4, [r7, #12]
3400c34e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c350:	2534      	movs	r5, #52	@ 0x34
3400c352:	fb05 f101 	mul.w	r1, r5, r1
3400c356:	4421      	add	r1, r4
3400c358:	3140      	adds	r1, #64	@ 0x40
3400c35a:	6809      	ldr	r1, [r1, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c35c:	1a41      	subs	r1, r0, r1
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400c35e:	3901      	subs	r1, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c360:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c364:	1ad2      	subs	r2, r2, r3
3400c366:	68f9      	ldr	r1, [r7, #12]
3400c368:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c36a:	2034      	movs	r0, #52	@ 0x34
3400c36c:	fb00 f303 	mul.w	r3, r0, r3
3400c370:	440b      	add	r3, r1
3400c372:	335c      	adds	r3, #92	@ 0x5c
3400c374:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c376:	68fa      	ldr	r2, [r7, #12]
3400c378:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c37a:	2134      	movs	r1, #52	@ 0x34
3400c37c:	fb01 f303 	mul.w	r3, r1, r3
3400c380:	4413      	add	r3, r2
3400c382:	3348      	adds	r3, #72	@ 0x48
3400c384:	681b      	ldr	r3, [r3, #0]
3400c386:	f240 120d 	movw	r2, #269	@ 0x10d
3400c38a:	4293      	cmp	r3, r2
3400c38c:	d004      	beq.n	3400c398 <LTDC_RetrieveUserConfig+0x33a>
3400c38e:	f240 220d 	movw	r2, #525	@ 0x20d
3400c392:	4293      	cmp	r3, r2
3400c394:	d036      	beq.n	3400c404 <LTDC_RetrieveUserConfig+0x3a6>
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
        break;
      default:
        /* Nothing to do */
        break;
3400c396:	e0a2      	b.n	3400c4de <LTDC_RetrieveUserConfig+0x480>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c398:	68fb      	ldr	r3, [r7, #12]
3400c39a:	681b      	ldr	r3, [r3, #0]
3400c39c:	461a      	mov	r2, r3
3400c39e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c3a0:	021b      	lsls	r3, r3, #8
3400c3a2:	4413      	add	r3, r2
3400c3a4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c3a8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c3aa:	68f9      	ldr	r1, [r7, #12]
3400c3ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c3ae:	2034      	movs	r0, #52	@ 0x34
3400c3b0:	fb00 f303 	mul.w	r3, r0, r3
3400c3b4:	440b      	add	r3, r1
3400c3b6:	333c      	adds	r3, #60	@ 0x3c
3400c3b8:	6819      	ldr	r1, [r3, #0]
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c3ba:	68f8      	ldr	r0, [r7, #12]
3400c3bc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c3be:	2434      	movs	r4, #52	@ 0x34
3400c3c0:	fb04 f303 	mul.w	r3, r4, r3
3400c3c4:	4403      	add	r3, r0
3400c3c6:	3338      	adds	r3, #56	@ 0x38
3400c3c8:	681b      	ldr	r3, [r3, #0]
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c3ca:	1acb      	subs	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c3cc:	69f9      	ldr	r1, [r7, #28]
3400c3ce:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c3d2:	68f8      	ldr	r0, [r7, #12]
3400c3d4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c3d6:	2434      	movs	r4, #52	@ 0x34
3400c3d8:	fb04 f101 	mul.w	r1, r4, r1
3400c3dc:	4401      	add	r1, r0
3400c3de:	3144      	adds	r1, #68	@ 0x44
3400c3e0:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c3e2:	68fc      	ldr	r4, [r7, #12]
3400c3e4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c3e6:	2534      	movs	r5, #52	@ 0x34
3400c3e8:	fb05 f101 	mul.w	r1, r5, r1
3400c3ec:	4421      	add	r1, r4
3400c3ee:	3140      	adds	r1, #64	@ 0x40
3400c3f0:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c3f2:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c3f4:	0849      	lsrs	r1, r1, #1
3400c3f6:	3901      	subs	r1, #1
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c3f8:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c3fc:	1ad2      	subs	r2, r2, r3
3400c3fe:	687b      	ldr	r3, [r7, #4]
3400c400:	601a      	str	r2, [r3, #0]
        break;
3400c402:	e06c      	b.n	3400c4de <LTDC_RetrieveUserConfig+0x480>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c404:	68fb      	ldr	r3, [r7, #12]
3400c406:	681b      	ldr	r3, [r3, #0]
3400c408:	461a      	mov	r2, r3
3400c40a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c40c:	021b      	lsls	r3, r3, #8
3400c40e:	4413      	add	r3, r2
3400c410:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c414:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c416:	68f9      	ldr	r1, [r7, #12]
3400c418:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c41a:	2034      	movs	r0, #52	@ 0x34
3400c41c:	fb00 f303 	mul.w	r3, r0, r3
3400c420:	440b      	add	r3, r1
3400c422:	333c      	adds	r3, #60	@ 0x3c
3400c424:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c426:	68f8      	ldr	r0, [r7, #12]
3400c428:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c42a:	2434      	movs	r4, #52	@ 0x34
3400c42c:	fb04 f303 	mul.w	r3, r4, r3
3400c430:	4403      	add	r3, r0
3400c432:	3338      	adds	r3, #56	@ 0x38
3400c434:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c436:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c438:	085b      	lsrs	r3, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c43a:	69f9      	ldr	r1, [r7, #28]
3400c43c:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c440:	68f8      	ldr	r0, [r7, #12]
3400c442:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c444:	2434      	movs	r4, #52	@ 0x34
3400c446:	fb04 f101 	mul.w	r1, r4, r1
3400c44a:	4401      	add	r1, r0
3400c44c:	3144      	adds	r1, #68	@ 0x44
3400c44e:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c450:	68fc      	ldr	r4, [r7, #12]
3400c452:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c454:	2534      	movs	r5, #52	@ 0x34
3400c456:	fb05 f101 	mul.w	r1, r5, r1
3400c45a:	4421      	add	r1, r4
3400c45c:	3140      	adds	r1, #64	@ 0x40
3400c45e:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c460:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c462:	0849      	lsrs	r1, r1, #1
3400c464:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c466:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c46a:	1ad2      	subs	r2, r2, r3
3400c46c:	687b      	ldr	r3, [r7, #4]
3400c46e:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c470:	68fb      	ldr	r3, [r7, #12]
3400c472:	681b      	ldr	r3, [r3, #0]
3400c474:	461a      	mov	r2, r3
3400c476:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c478:	021b      	lsls	r3, r3, #8
3400c47a:	4413      	add	r3, r2
3400c47c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c480:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c482:	68f9      	ldr	r1, [r7, #12]
3400c484:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c486:	2034      	movs	r0, #52	@ 0x34
3400c488:	fb00 f303 	mul.w	r3, r0, r3
3400c48c:	440b      	add	r3, r1
3400c48e:	333c      	adds	r3, #60	@ 0x3c
3400c490:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c492:	68f8      	ldr	r0, [r7, #12]
3400c494:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c496:	2434      	movs	r4, #52	@ 0x34
3400c498:	fb04 f303 	mul.w	r3, r4, r3
3400c49c:	4403      	add	r3, r0
3400c49e:	3338      	adds	r3, #56	@ 0x38
3400c4a0:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c4a2:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c4a4:	085b      	lsrs	r3, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c4a6:	69f9      	ldr	r1, [r7, #28]
3400c4a8:	fb01 f303 	mul.w	r3, r1, r3
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c4ac:	68f8      	ldr	r0, [r7, #12]
3400c4ae:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c4b0:	2434      	movs	r4, #52	@ 0x34
3400c4b2:	fb04 f101 	mul.w	r1, r4, r1
3400c4b6:	4401      	add	r1, r0
3400c4b8:	3144      	adds	r1, #68	@ 0x44
3400c4ba:	6808      	ldr	r0, [r1, #0]
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c4bc:	68fc      	ldr	r4, [r7, #12]
3400c4be:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c4c0:	2534      	movs	r5, #52	@ 0x34
3400c4c2:	fb05 f101 	mul.w	r1, r5, r1
3400c4c6:	4421      	add	r1, r4
3400c4c8:	3140      	adds	r1, #64	@ 0x40
3400c4ca:	6809      	ldr	r1, [r1, #0]
                                                           (((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c4cc:	1a41      	subs	r1, r0, r1
                                                              hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400c4ce:	0849      	lsrs	r1, r1, #1
3400c4d0:	3901      	subs	r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c4d2:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c4d6:	1ad2      	subs	r2, r2, r3
3400c4d8:	683b      	ldr	r3, [r7, #0]
3400c4da:	601a      	str	r2, [r3, #0]
        break;
3400c4dc:	bf00      	nop
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c4de:	e0f0      	b.n	3400c6c2 <LTDC_RetrieveUserConfig+0x664>
    }
  }

  else
  {
    *Mirror = LTDC_MIRROR_HORIZONTAL_VERTICAL;
3400c4e0:	68bb      	ldr	r3, [r7, #8]
3400c4e2:	2202      	movs	r2, #2
3400c4e4:	601a      	str	r2, [r3, #0]
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c4e6:	68fb      	ldr	r3, [r7, #12]
3400c4e8:	681b      	ldr	r3, [r3, #0]
3400c4ea:	461a      	mov	r2, r3
3400c4ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c4ee:	021b      	lsls	r3, r3, #8
3400c4f0:	4413      	add	r3, r2
3400c4f2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c4f6:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c4f8:	68f9      	ldr	r1, [r7, #12]
3400c4fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c4fc:	2034      	movs	r0, #52	@ 0x34
3400c4fe:	fb00 f303 	mul.w	r3, r0, r3
3400c502:	440b      	add	r3, r1
3400c504:	333c      	adds	r3, #60	@ 0x3c
3400c506:	6819      	ldr	r1, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c508:	68f8      	ldr	r0, [r7, #12]
3400c50a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c50c:	2434      	movs	r4, #52	@ 0x34
3400c50e:	fb04 f303 	mul.w	r3, r4, r3
3400c512:	4403      	add	r3, r0
3400c514:	3338      	adds	r3, #56	@ 0x38
3400c516:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c518:	1acb      	subs	r3, r1, r3
3400c51a:	69f9      	ldr	r1, [r7, #28]
3400c51c:	fb01 f303 	mul.w	r3, r1, r3
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c520:	68f8      	ldr	r0, [r7, #12]
3400c522:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c524:	2434      	movs	r4, #52	@ 0x34
3400c526:	fb04 f101 	mul.w	r1, r4, r1
3400c52a:	4401      	add	r1, r0
3400c52c:	3144      	adds	r1, #68	@ 0x44
3400c52e:	6808      	ldr	r0, [r1, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
3400c530:	68fc      	ldr	r4, [r7, #12]
3400c532:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c534:	2534      	movs	r5, #52	@ 0x34
3400c536:	fb05 f101 	mul.w	r1, r5, r1
3400c53a:	4421      	add	r1, r4
3400c53c:	3140      	adds	r1, #64	@ 0x40
3400c53e:	6809      	ldr	r1, [r1, #0]
                                               (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c540:	1a41      	subs	r1, r0, r1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c542:	fb01 f303 	mul.w	r3, r1, r3
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c546:	1ad3      	subs	r3, r2, r3
                                                hltdc->LayerCfg[LayerIdx].WindowY0)) + 1U;
3400c548:	1c5a      	adds	r2, r3, #1
    hltdc->LayerCfg[LayerIdx].FBStartAdress = LTDC_LAYER(hltdc, LayerIdx)->CFBAR - \
3400c54a:	68f9      	ldr	r1, [r7, #12]
3400c54c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c54e:	2034      	movs	r0, #52	@ 0x34
3400c550:	fb00 f303 	mul.w	r3, r0, r3
3400c554:	440b      	add	r3, r1
3400c556:	335c      	adds	r3, #92	@ 0x5c
3400c558:	601a      	str	r2, [r3, #0]
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c55a:	68fa      	ldr	r2, [r7, #12]
3400c55c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c55e:	2134      	movs	r1, #52	@ 0x34
3400c560:	fb01 f303 	mul.w	r3, r1, r3
3400c564:	4413      	add	r3, r2
3400c566:	3348      	adds	r3, #72	@ 0x48
3400c568:	681b      	ldr	r3, [r3, #0]
3400c56a:	f240 120d 	movw	r2, #269	@ 0x10d
3400c56e:	4293      	cmp	r3, r2
3400c570:	d004      	beq.n	3400c57c <LTDC_RetrieveUserConfig+0x51e>
3400c572:	f240 220d 	movw	r2, #525	@ 0x20d
3400c576:	4293      	cmp	r3, r2
3400c578:	d036      	beq.n	3400c5e8 <LTDC_RetrieveUserConfig+0x58a>
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
        break;
      default:
        /* Nothing to do */
        break;
3400c57a:	e0a2      	b.n	3400c6c2 <LTDC_RetrieveUserConfig+0x664>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c57c:	68fb      	ldr	r3, [r7, #12]
3400c57e:	681b      	ldr	r3, [r3, #0]
3400c580:	461a      	mov	r2, r3
3400c582:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c584:	021b      	lsls	r3, r3, #8
3400c586:	4413      	add	r3, r2
3400c588:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c58c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c58e:	68f9      	ldr	r1, [r7, #12]
3400c590:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c592:	2034      	movs	r0, #52	@ 0x34
3400c594:	fb00 f303 	mul.w	r3, r0, r3
3400c598:	440b      	add	r3, r1
3400c59a:	333c      	adds	r3, #60	@ 0x3c
3400c59c:	6819      	ldr	r1, [r3, #0]
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c59e:	68f8      	ldr	r0, [r7, #12]
3400c5a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c5a2:	2434      	movs	r4, #52	@ 0x34
3400c5a4:	fb04 f303 	mul.w	r3, r4, r3
3400c5a8:	4403      	add	r3, r0
3400c5aa:	3338      	adds	r3, #56	@ 0x38
3400c5ac:	681b      	ldr	r3, [r3, #0]
                                                           (hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c5ae:	1acb      	subs	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c5b0:	69f9      	ldr	r1, [r7, #28]
3400c5b2:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c5b6:	68f8      	ldr	r0, [r7, #12]
3400c5b8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c5ba:	2434      	movs	r4, #52	@ 0x34
3400c5bc:	fb04 f101 	mul.w	r1, r4, r1
3400c5c0:	4401      	add	r1, r0
3400c5c2:	3144      	adds	r1, #68	@ 0x44
3400c5c4:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c5c6:	68fc      	ldr	r4, [r7, #12]
3400c5c8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c5ca:	2534      	movs	r5, #52	@ 0x34
3400c5cc:	fb05 f101 	mul.w	r1, r5, r1
3400c5d0:	4421      	add	r1, r4
3400c5d2:	3140      	adds	r1, #64	@ 0x40
3400c5d4:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c5d6:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c5d8:	0849      	lsrs	r1, r1, #1
                                                            hltdc->LayerCfg[LayerIdx].WindowX0) * \
3400c5da:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c5de:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c5e0:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c5e2:	687b      	ldr	r3, [r7, #4]
3400c5e4:	601a      	str	r2, [r3, #0]
        break;
3400c5e6:	e06c      	b.n	3400c6c2 <LTDC_RetrieveUserConfig+0x664>
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c5e8:	68fb      	ldr	r3, [r7, #12]
3400c5ea:	681b      	ldr	r3, [r3, #0]
3400c5ec:	461a      	mov	r2, r3
3400c5ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c5f0:	021b      	lsls	r3, r3, #8
3400c5f2:	4413      	add	r3, r2
3400c5f4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c5f8:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c5fa:	68f9      	ldr	r1, [r7, #12]
3400c5fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c5fe:	2034      	movs	r0, #52	@ 0x34
3400c600:	fb00 f303 	mul.w	r3, r0, r3
3400c604:	440b      	add	r3, r1
3400c606:	333c      	adds	r3, #60	@ 0x3c
3400c608:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c60a:	68f8      	ldr	r0, [r7, #12]
3400c60c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c60e:	2434      	movs	r4, #52	@ 0x34
3400c610:	fb04 f303 	mul.w	r3, r4, r3
3400c614:	4403      	add	r3, r0
3400c616:	3338      	adds	r3, #56	@ 0x38
3400c618:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c61a:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c61c:	085b      	lsrs	r3, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c61e:	69f9      	ldr	r1, [r7, #28]
3400c620:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c624:	68f8      	ldr	r0, [r7, #12]
3400c626:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c628:	2434      	movs	r4, #52	@ 0x34
3400c62a:	fb04 f101 	mul.w	r1, r4, r1
3400c62e:	4401      	add	r1, r0
3400c630:	3144      	adds	r1, #68	@ 0x44
3400c632:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c634:	68fc      	ldr	r4, [r7, #12]
3400c636:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c638:	2534      	movs	r5, #52	@ 0x34
3400c63a:	fb05 f101 	mul.w	r1, r5, r1
3400c63e:	4421      	add	r1, r4
3400c640:	3140      	adds	r1, #64	@ 0x40
3400c642:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c644:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c646:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c648:	fb01 f303 	mul.w	r3, r1, r3
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c64c:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c64e:	1c5a      	adds	r2, r3, #1
        *Aux0Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA0R - (stride * \
3400c650:	687b      	ldr	r3, [r7, #4]
3400c652:	601a      	str	r2, [r3, #0]
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c654:	68fb      	ldr	r3, [r7, #12]
3400c656:	681b      	ldr	r3, [r3, #0]
3400c658:	461a      	mov	r2, r3
3400c65a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c65c:	021b      	lsls	r3, r3, #8
3400c65e:	4413      	add	r3, r2
3400c660:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c664:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c666:	68f9      	ldr	r1, [r7, #12]
3400c668:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c66a:	2034      	movs	r0, #52	@ 0x34
3400c66c:	fb00 f303 	mul.w	r3, r0, r3
3400c670:	440b      	add	r3, r1
3400c672:	333c      	adds	r3, #60	@ 0x3c
3400c674:	6819      	ldr	r1, [r3, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c676:	68f8      	ldr	r0, [r7, #12]
3400c678:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400c67a:	2434      	movs	r4, #52	@ 0x34
3400c67c:	fb04 f303 	mul.w	r3, r4, r3
3400c680:	4403      	add	r3, r0
3400c682:	3338      	adds	r3, #56	@ 0x38
3400c684:	681b      	ldr	r3, [r3, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowX1 - \
3400c686:	1acb      	subs	r3, r1, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c688:	085b      	lsrs	r3, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c68a:	69f9      	ldr	r1, [r7, #28]
3400c68c:	fb01 f303 	mul.w	r3, r1, r3
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c690:	68f8      	ldr	r0, [r7, #12]
3400c692:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c694:	2434      	movs	r4, #52	@ 0x34
3400c696:	fb04 f101 	mul.w	r1, r4, r1
3400c69a:	4401      	add	r1, r0
3400c69c:	3144      	adds	r1, #68	@ 0x44
3400c69e:	6808      	ldr	r0, [r1, #0]
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c6a0:	68fc      	ldr	r4, [r7, #12]
3400c6a2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
3400c6a4:	2534      	movs	r5, #52	@ 0x34
3400c6a6:	fb05 f101 	mul.w	r1, r5, r1
3400c6aa:	4421      	add	r1, r4
3400c6ac:	3140      	adds	r1, #64	@ 0x40
3400c6ae:	6809      	ldr	r1, [r1, #0]
                                                           ((hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400c6b0:	1a41      	subs	r1, r0, r1
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c6b2:	0849      	lsrs	r1, r1, #1
                                                             hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * \
3400c6b4:	fb01 f303 	mul.w	r3, r1, r3
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c6b8:	1ad3      	subs	r3, r2, r3
                                                             hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) + 1U;
3400c6ba:	1c5a      	adds	r2, r3, #1
        *Aux1Addr = LTDC_LAYER(hltdc, LayerIdx)->AFBA1R - (stride * \
3400c6bc:	683b      	ldr	r3, [r7, #0]
3400c6be:	601a      	str	r2, [r3, #0]
        break;
3400c6c0:	bf00      	nop
    }
  }
}
3400c6c2:	bf00      	nop
3400c6c4:	3724      	adds	r7, #36	@ 0x24
3400c6c6:	46bd      	mov	sp, r7
3400c6c8:	bcb0      	pop	{r4, r5, r7}
3400c6ca:	4770      	bx	lr

3400c6cc <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
3400c6cc:	b4b0      	push	{r4, r5, r7}
3400c6ce:	b087      	sub	sp, #28
3400c6d0:	af00      	add	r7, sp, #0
3400c6d2:	60f8      	str	r0, [r7, #12]
3400c6d4:	60b9      	str	r1, [r7, #8]
3400c6d6:	607a      	str	r2, [r7, #4]
3400c6d8:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
3400c6da:	68fb      	ldr	r3, [r7, #12]
3400c6dc:	681b      	ldr	r3, [r3, #0]
3400c6de:	461a      	mov	r2, r3
3400c6e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c6e2:	021b      	lsls	r3, r3, #8
3400c6e4:	4413      	add	r3, r2
3400c6e6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c6ea:	4618      	mov	r0, r3
3400c6ec:	68fa      	ldr	r2, [r7, #12]
3400c6ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c6f0:	2134      	movs	r1, #52	@ 0x34
3400c6f2:	fb01 f303 	mul.w	r3, r1, r3
3400c6f6:	4413      	add	r3, r2
3400c6f8:	3364      	adds	r3, #100	@ 0x64
3400c6fa:	681b      	ldr	r3, [r3, #0]
3400c6fc:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c6fe:	68fa      	ldr	r2, [r7, #12]
3400c700:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c702:	2134      	movs	r1, #52	@ 0x34
3400c704:	fb01 f303 	mul.w	r3, r1, r3
3400c708:	4413      	add	r3, r2
3400c70a:	3348      	adds	r3, #72	@ 0x48
3400c70c:	681b      	ldr	r3, [r3, #0]
3400c70e:	2b03      	cmp	r3, #3
3400c710:	d821      	bhi.n	3400c756 <LTDC_SetConfig+0x8a>
3400c712:	e025      	b.n	3400c760 <LTDC_SetConfig+0x94>
3400c714:	3b04      	subs	r3, #4
3400c716:	2201      	movs	r2, #1
3400c718:	fa02 f303 	lsl.w	r3, r2, r3
3400c71c:	f240 229b 	movw	r2, #667	@ 0x29b
3400c720:	401a      	ands	r2, r3
3400c722:	2a00      	cmp	r2, #0
3400c724:	bf14      	ite	ne
3400c726:	2201      	movne	r2, #1
3400c728:	2200      	moveq	r2, #0
3400c72a:	b2d2      	uxtb	r2, r2
3400c72c:	2a00      	cmp	r2, #0
3400c72e:	d11d      	bne.n	3400c76c <LTDC_SetConfig+0xa0>
3400c730:	f403 7280 	and.w	r2, r3, #256	@ 0x100
3400c734:	2a00      	cmp	r2, #0
3400c736:	bf14      	ite	ne
3400c738:	2201      	movne	r2, #1
3400c73a:	2200      	moveq	r2, #0
3400c73c:	b2d2      	uxtb	r2, r2
3400c73e:	2a00      	cmp	r2, #0
3400c740:	d117      	bne.n	3400c772 <LTDC_SetConfig+0xa6>
3400c742:	f003 0304 	and.w	r3, r3, #4
3400c746:	2b00      	cmp	r3, #0
3400c748:	bf14      	ite	ne
3400c74a:	2301      	movne	r3, #1
3400c74c:	2300      	moveq	r3, #0
3400c74e:	b2db      	uxtb	r3, r3
3400c750:	2b00      	cmp	r3, #0
3400c752:	d108      	bne.n	3400c766 <LTDC_SetConfig+0x9a>
3400c754:	e01b      	b.n	3400c78e <LTDC_SetConfig+0xc2>
3400c756:	2b0d      	cmp	r3, #13
3400c758:	d819      	bhi.n	3400c78e <LTDC_SetConfig+0xc2>
3400c75a:	2b04      	cmp	r3, #4
3400c75c:	d2da      	bcs.n	3400c714 <LTDC_SetConfig+0x48>
3400c75e:	e016      	b.n	3400c78e <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
3400c760:	2304      	movs	r3, #4
3400c762:	617b      	str	r3, [r7, #20]
      break;
3400c764:	e016      	b.n	3400c794 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
3400c766:	2303      	movs	r3, #3
3400c768:	617b      	str	r3, [r7, #20]
      break;
3400c76a:	e013      	b.n	3400c794 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3400c76c:	2302      	movs	r3, #2
3400c76e:	617b      	str	r3, [r7, #20]
      break;
3400c770:	e010      	b.n	3400c794 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
3400c772:	68fb      	ldr	r3, [r7, #12]
3400c774:	681b      	ldr	r3, [r3, #0]
3400c776:	461a      	mov	r2, r3
3400c778:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c77a:	021b      	lsls	r3, r3, #8
3400c77c:	4413      	add	r3, r2
3400c77e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c782:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
3400c784:	0c9b      	lsrs	r3, r3, #18
3400c786:	f003 0307 	and.w	r3, r3, #7
3400c78a:	617b      	str	r3, [r7, #20]
      break;
3400c78c:	e002      	b.n	3400c794 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3400c78e:	2301      	movs	r3, #1
3400c790:	617b      	str	r3, [r7, #20]
      break;
3400c792:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
3400c794:	68fa      	ldr	r2, [r7, #12]
3400c796:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c798:	2134      	movs	r1, #52	@ 0x34
3400c79a:	fb01 f303 	mul.w	r3, r1, r3
3400c79e:	4413      	add	r3, r2
3400c7a0:	333c      	adds	r3, #60	@ 0x3c
3400c7a2:	681a      	ldr	r2, [r3, #0]
3400c7a4:	68fb      	ldr	r3, [r7, #12]
3400c7a6:	681b      	ldr	r3, [r3, #0]
3400c7a8:	68db      	ldr	r3, [r3, #12]
3400c7aa:	0c1b      	lsrs	r3, r3, #16
3400c7ac:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400c7b0:	4413      	add	r3, r2
3400c7b2:	041b      	lsls	r3, r3, #16
3400c7b4:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400c7b6:	68fa      	ldr	r2, [r7, #12]
3400c7b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c7ba:	2134      	movs	r1, #52	@ 0x34
3400c7bc:	fb01 f303 	mul.w	r3, r1, r3
3400c7c0:	4413      	add	r3, r2
3400c7c2:	3338      	adds	r3, #56	@ 0x38
3400c7c4:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400c7c6:	68fb      	ldr	r3, [r7, #12]
3400c7c8:	681b      	ldr	r3, [r3, #0]
3400c7ca:	68db      	ldr	r3, [r3, #12]
3400c7cc:	0c1b      	lsrs	r3, r3, #16
3400c7ce:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400c7d2:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400c7d4:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400c7d6:	68fb      	ldr	r3, [r7, #12]
3400c7d8:	681b      	ldr	r3, [r3, #0]
3400c7da:	4619      	mov	r1, r3
3400c7dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c7de:	021b      	lsls	r3, r3, #8
3400c7e0:	440b      	add	r3, r1
3400c7e2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c7e6:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
3400c7e8:	693b      	ldr	r3, [r7, #16]
3400c7ea:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
3400c7ec:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
3400c7ee:	68fa      	ldr	r2, [r7, #12]
3400c7f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c7f2:	2134      	movs	r1, #52	@ 0x34
3400c7f4:	fb01 f303 	mul.w	r3, r1, r3
3400c7f8:	4413      	add	r3, r2
3400c7fa:	3344      	adds	r3, #68	@ 0x44
3400c7fc:	681a      	ldr	r2, [r3, #0]
3400c7fe:	68fb      	ldr	r3, [r7, #12]
3400c800:	681b      	ldr	r3, [r3, #0]
3400c802:	68db      	ldr	r3, [r3, #12]
3400c804:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400c808:	4413      	add	r3, r2
3400c80a:	041b      	lsls	r3, r3, #16
3400c80c:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400c80e:	68fa      	ldr	r2, [r7, #12]
3400c810:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c812:	2134      	movs	r1, #52	@ 0x34
3400c814:	fb01 f303 	mul.w	r3, r1, r3
3400c818:	4413      	add	r3, r2
3400c81a:	3340      	adds	r3, #64	@ 0x40
3400c81c:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400c81e:	68fb      	ldr	r3, [r7, #12]
3400c820:	681b      	ldr	r3, [r3, #0]
3400c822:	68db      	ldr	r3, [r3, #12]
3400c824:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400c828:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400c82a:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400c82c:	68fb      	ldr	r3, [r7, #12]
3400c82e:	681b      	ldr	r3, [r3, #0]
3400c830:	4619      	mov	r1, r3
3400c832:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c834:	021b      	lsls	r3, r3, #8
3400c836:	440b      	add	r3, r1
3400c838:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c83c:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400c83e:	693b      	ldr	r3, [r7, #16]
3400c840:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
3400c842:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
3400c844:	683b      	ldr	r3, [r7, #0]
3400c846:	2b03      	cmp	r3, #3
3400c848:	f040 80fb 	bne.w	3400ca42 <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3400c84c:	68fb      	ldr	r3, [r7, #12]
3400c84e:	681b      	ldr	r3, [r3, #0]
3400c850:	461a      	mov	r2, r3
3400c852:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c854:	021b      	lsls	r3, r3, #8
3400c856:	4413      	add	r3, r2
3400c858:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c85c:	4618      	mov	r0, r3
3400c85e:	68fa      	ldr	r2, [r7, #12]
3400c860:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c862:	2134      	movs	r1, #52	@ 0x34
3400c864:	fb01 f303 	mul.w	r3, r1, r3
3400c868:	4413      	add	r3, r2
3400c86a:	335c      	adds	r3, #92	@ 0x5c
3400c86c:	681b      	ldr	r3, [r3, #0]
3400c86e:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400c870:	68fa      	ldr	r2, [r7, #12]
3400c872:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c874:	2134      	movs	r1, #52	@ 0x34
3400c876:	fb01 f303 	mul.w	r3, r1, r3
3400c87a:	4413      	add	r3, r2
3400c87c:	3348      	adds	r3, #72	@ 0x48
3400c87e:	681b      	ldr	r3, [r3, #0]
3400c880:	f240 120d 	movw	r2, #269	@ 0x10d
3400c884:	4293      	cmp	r3, r2
3400c886:	d004      	beq.n	3400c892 <LTDC_SetConfig+0x1c6>
3400c888:	f240 220d 	movw	r2, #525	@ 0x20d
3400c88c:	4293      	cmp	r3, r2
3400c88e:	d043      	beq.n	3400c918 <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
3400c890:	e092      	b.n	3400c9b8 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400c892:	68fb      	ldr	r3, [r7, #12]
3400c894:	681b      	ldr	r3, [r3, #0]
3400c896:	461a      	mov	r2, r3
3400c898:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c89a:	021b      	lsls	r3, r3, #8
3400c89c:	4413      	add	r3, r2
3400c89e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c8a2:	461a      	mov	r2, r3
3400c8a4:	68bb      	ldr	r3, [r7, #8]
3400c8a6:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400c8a8:	68fa      	ldr	r2, [r7, #12]
3400c8aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8ac:	2134      	movs	r1, #52	@ 0x34
3400c8ae:	fb01 f303 	mul.w	r3, r1, r3
3400c8b2:	4413      	add	r3, r2
3400c8b4:	3360      	adds	r3, #96	@ 0x60
3400c8b6:	681b      	ldr	r3, [r3, #0]
3400c8b8:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400c8ba:	68f9      	ldr	r1, [r7, #12]
3400c8bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8be:	2034      	movs	r0, #52	@ 0x34
3400c8c0:	fb00 f303 	mul.w	r3, r0, r3
3400c8c4:	440b      	add	r3, r1
3400c8c6:	333c      	adds	r3, #60	@ 0x3c
3400c8c8:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3400c8ca:	68f8      	ldr	r0, [r7, #12]
3400c8cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8ce:	2434      	movs	r4, #52	@ 0x34
3400c8d0:	fb04 f303 	mul.w	r3, r4, r3
3400c8d4:	4403      	add	r3, r0
3400c8d6:	3338      	adds	r3, #56	@ 0x38
3400c8d8:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400c8da:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3400c8dc:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400c8de:	68f9      	ldr	r1, [r7, #12]
3400c8e0:	6809      	ldr	r1, [r1, #0]
3400c8e2:	4608      	mov	r0, r1
3400c8e4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400c8e6:	0209      	lsls	r1, r1, #8
3400c8e8:	4401      	add	r1, r0
3400c8ea:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400c8ee:	4313      	orrs	r3, r2
3400c8f0:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3400c8f2:	68fa      	ldr	r2, [r7, #12]
3400c8f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c8f6:	2134      	movs	r1, #52	@ 0x34
3400c8f8:	fb01 f303 	mul.w	r3, r1, r3
3400c8fc:	4413      	add	r3, r2
3400c8fe:	3364      	adds	r3, #100	@ 0x64
3400c900:	681b      	ldr	r3, [r3, #0]
3400c902:	68fa      	ldr	r2, [r7, #12]
3400c904:	6812      	ldr	r2, [r2, #0]
3400c906:	4611      	mov	r1, r2
3400c908:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400c90a:	0212      	lsls	r2, r2, #8
3400c90c:	440a      	add	r2, r1
3400c90e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400c912:	085b      	lsrs	r3, r3, #1
3400c914:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400c916:	e04f      	b.n	3400c9b8 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
3400c918:	68fb      	ldr	r3, [r7, #12]
3400c91a:	681b      	ldr	r3, [r3, #0]
3400c91c:	461a      	mov	r2, r3
3400c91e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c920:	021b      	lsls	r3, r3, #8
3400c922:	4413      	add	r3, r2
3400c924:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c928:	461a      	mov	r2, r3
3400c92a:	68bb      	ldr	r3, [r7, #8]
3400c92c:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
3400c92e:	68fb      	ldr	r3, [r7, #12]
3400c930:	681b      	ldr	r3, [r3, #0]
3400c932:	461a      	mov	r2, r3
3400c934:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c936:	021b      	lsls	r3, r3, #8
3400c938:	4413      	add	r3, r2
3400c93a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400c93e:	461a      	mov	r2, r3
3400c940:	687b      	ldr	r3, [r7, #4]
3400c942:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400c944:	68fa      	ldr	r2, [r7, #12]
3400c946:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c948:	2134      	movs	r1, #52	@ 0x34
3400c94a:	fb01 f303 	mul.w	r3, r1, r3
3400c94e:	4413      	add	r3, r2
3400c950:	3360      	adds	r3, #96	@ 0x60
3400c952:	681b      	ldr	r3, [r3, #0]
3400c954:	085b      	lsrs	r3, r3, #1
3400c956:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400c958:	68f9      	ldr	r1, [r7, #12]
3400c95a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c95c:	2034      	movs	r0, #52	@ 0x34
3400c95e:	fb00 f303 	mul.w	r3, r0, r3
3400c962:	440b      	add	r3, r1
3400c964:	333c      	adds	r3, #60	@ 0x3c
3400c966:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400c968:	68f8      	ldr	r0, [r7, #12]
3400c96a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c96c:	2434      	movs	r4, #52	@ 0x34
3400c96e:	fb04 f303 	mul.w	r3, r4, r3
3400c972:	4403      	add	r3, r0
3400c974:	3338      	adds	r3, #56	@ 0x38
3400c976:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400c978:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400c97a:	085b      	lsrs	r3, r3, #1
3400c97c:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400c97e:	68f9      	ldr	r1, [r7, #12]
3400c980:	6809      	ldr	r1, [r1, #0]
3400c982:	4608      	mov	r0, r1
3400c984:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400c986:	0209      	lsls	r1, r1, #8
3400c988:	4401      	add	r1, r0
3400c98a:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400c98e:	4313      	orrs	r3, r2
3400c990:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
3400c992:	68fa      	ldr	r2, [r7, #12]
3400c994:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c996:	2134      	movs	r1, #52	@ 0x34
3400c998:	fb01 f303 	mul.w	r3, r1, r3
3400c99c:	4413      	add	r3, r2
3400c99e:	3364      	adds	r3, #100	@ 0x64
3400c9a0:	681b      	ldr	r3, [r3, #0]
3400c9a2:	68fa      	ldr	r2, [r7, #12]
3400c9a4:	6812      	ldr	r2, [r2, #0]
3400c9a6:	4611      	mov	r1, r2
3400c9a8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400c9aa:	0212      	lsls	r2, r2, #8
3400c9ac:	440a      	add	r2, r1
3400c9ae:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400c9b2:	085b      	lsrs	r3, r3, #1
3400c9b4:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400c9b6:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400c9b8:	68fa      	ldr	r2, [r7, #12]
3400c9ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c9bc:	2134      	movs	r1, #52	@ 0x34
3400c9be:	fb01 f303 	mul.w	r3, r1, r3
3400c9c2:	4413      	add	r3, r2
3400c9c4:	3360      	adds	r3, #96	@ 0x60
3400c9c6:	681b      	ldr	r3, [r3, #0]
3400c9c8:	697a      	ldr	r2, [r7, #20]
3400c9ca:	fb02 f303 	mul.w	r3, r2, r3
3400c9ce:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
3400c9d0:	68f9      	ldr	r1, [r7, #12]
3400c9d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c9d4:	2034      	movs	r0, #52	@ 0x34
3400c9d6:	fb00 f303 	mul.w	r3, r0, r3
3400c9da:	440b      	add	r3, r1
3400c9dc:	333c      	adds	r3, #60	@ 0x3c
3400c9de:	6819      	ldr	r1, [r3, #0]
3400c9e0:	68f8      	ldr	r0, [r7, #12]
3400c9e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400c9e4:	2434      	movs	r4, #52	@ 0x34
3400c9e6:	fb04 f303 	mul.w	r3, r4, r3
3400c9ea:	4403      	add	r3, r0
3400c9ec:	3338      	adds	r3, #56	@ 0x38
3400c9ee:	681b      	ldr	r3, [r3, #0]
3400c9f0:	1acb      	subs	r3, r1, r3
3400c9f2:	6979      	ldr	r1, [r7, #20]
3400c9f4:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
3400c9f8:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400c9fa:	68f9      	ldr	r1, [r7, #12]
3400c9fc:	6809      	ldr	r1, [r1, #0]
3400c9fe:	4608      	mov	r0, r1
3400ca00:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400ca02:	0209      	lsls	r1, r1, #8
3400ca04:	4401      	add	r1, r0
3400ca06:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400ca0a:	4313      	orrs	r3, r2
3400ca0c:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3400ca0e:	68fb      	ldr	r3, [r7, #12]
3400ca10:	681b      	ldr	r3, [r3, #0]
3400ca12:	461a      	mov	r2, r3
3400ca14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ca16:	021b      	lsls	r3, r3, #8
3400ca18:	4413      	add	r3, r2
3400ca1a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ca1e:	68db      	ldr	r3, [r3, #12]
3400ca20:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3400ca24:	f023 0301 	bic.w	r3, r3, #1
3400ca28:	68fa      	ldr	r2, [r7, #12]
3400ca2a:	6812      	ldr	r2, [r2, #0]
3400ca2c:	4611      	mov	r1, r2
3400ca2e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ca30:	0212      	lsls	r2, r2, #8
3400ca32:	440a      	add	r2, r1
3400ca34:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ca38:	f043 0301 	orr.w	r3, r3, #1
3400ca3c:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
3400ca3e:	f000 bccc 	b.w	3400d3da <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
3400ca42:	683b      	ldr	r3, [r7, #0]
3400ca44:	2b00      	cmp	r3, #0
3400ca46:	f040 814e 	bne.w	3400cce6 <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400ca4a:	68fa      	ldr	r2, [r7, #12]
3400ca4c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ca4e:	2134      	movs	r1, #52	@ 0x34
3400ca50:	fb01 f303 	mul.w	r3, r1, r3
3400ca54:	4413      	add	r3, r2
3400ca56:	335c      	adds	r3, #92	@ 0x5c
3400ca58:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ca5a:	68f9      	ldr	r1, [r7, #12]
3400ca5c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ca5e:	2034      	movs	r0, #52	@ 0x34
3400ca60:	fb00 f303 	mul.w	r3, r0, r3
3400ca64:	440b      	add	r3, r1
3400ca66:	333c      	adds	r3, #60	@ 0x3c
3400ca68:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400ca6a:	68f8      	ldr	r0, [r7, #12]
3400ca6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ca6e:	2434      	movs	r4, #52	@ 0x34
3400ca70:	fb04 f303 	mul.w	r3, r4, r3
3400ca74:	4403      	add	r3, r0
3400ca76:	3338      	adds	r3, #56	@ 0x38
3400ca78:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ca7a:	1acb      	subs	r3, r1, r3
3400ca7c:	6979      	ldr	r1, [r7, #20]
3400ca7e:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400ca82:	4413      	add	r3, r2
3400ca84:	68fa      	ldr	r2, [r7, #12]
3400ca86:	6812      	ldr	r2, [r2, #0]
3400ca88:	4611      	mov	r1, r2
3400ca8a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ca8c:	0212      	lsls	r2, r2, #8
3400ca8e:	440a      	add	r2, r1
3400ca90:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400ca94:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400ca96:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400ca98:	68fa      	ldr	r2, [r7, #12]
3400ca9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ca9c:	2134      	movs	r1, #52	@ 0x34
3400ca9e:	fb01 f303 	mul.w	r3, r1, r3
3400caa2:	4413      	add	r3, r2
3400caa4:	3348      	adds	r3, #72	@ 0x48
3400caa6:	681b      	ldr	r3, [r3, #0]
3400caa8:	f240 120d 	movw	r2, #269	@ 0x10d
3400caac:	4293      	cmp	r3, r2
3400caae:	d004      	beq.n	3400caba <LTDC_SetConfig+0x3ee>
3400cab0:	f240 220d 	movw	r2, #525	@ 0x20d
3400cab4:	4293      	cmp	r3, r2
3400cab6:	d058      	beq.n	3400cb6a <LTDC_SetConfig+0x49e>
        break;
3400cab8:	e0d3      	b.n	3400cc62 <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400caba:	68fa      	ldr	r2, [r7, #12]
3400cabc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cabe:	2134      	movs	r1, #52	@ 0x34
3400cac0:	fb01 f303 	mul.w	r3, r1, r3
3400cac4:	4413      	add	r3, r2
3400cac6:	333c      	adds	r3, #60	@ 0x3c
3400cac8:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400caca:	68f9      	ldr	r1, [r7, #12]
3400cacc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cace:	2034      	movs	r0, #52	@ 0x34
3400cad0:	fb00 f303 	mul.w	r3, r0, r3
3400cad4:	440b      	add	r3, r1
3400cad6:	3338      	adds	r3, #56	@ 0x38
3400cad8:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cada:	1ad3      	subs	r3, r2, r3
3400cadc:	697a      	ldr	r2, [r7, #20]
3400cade:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400cae2:	68bb      	ldr	r3, [r7, #8]
3400cae4:	4413      	add	r3, r2
3400cae6:	68fa      	ldr	r2, [r7, #12]
3400cae8:	6812      	ldr	r2, [r2, #0]
3400caea:	4611      	mov	r1, r2
3400caec:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400caee:	0212      	lsls	r2, r2, #8
3400caf0:	440a      	add	r2, r1
3400caf2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400caf6:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400caf8:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400cafa:	68fa      	ldr	r2, [r7, #12]
3400cafc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cafe:	2134      	movs	r1, #52	@ 0x34
3400cb00:	fb01 f303 	mul.w	r3, r1, r3
3400cb04:	4413      	add	r3, r2
3400cb06:	3360      	adds	r3, #96	@ 0x60
3400cb08:	681b      	ldr	r3, [r3, #0]
3400cb0a:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
3400cb0c:	68f9      	ldr	r1, [r7, #12]
3400cb0e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cb10:	2034      	movs	r0, #52	@ 0x34
3400cb12:	fb00 f303 	mul.w	r3, r0, r3
3400cb16:	440b      	add	r3, r1
3400cb18:	333c      	adds	r3, #60	@ 0x3c
3400cb1a:	6819      	ldr	r1, [r3, #0]
3400cb1c:	68f8      	ldr	r0, [r7, #12]
3400cb1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cb20:	2434      	movs	r4, #52	@ 0x34
3400cb22:	fb04 f303 	mul.w	r3, r4, r3
3400cb26:	4403      	add	r3, r0
3400cb28:	3338      	adds	r3, #56	@ 0x38
3400cb2a:	681b      	ldr	r3, [r3, #0]
3400cb2c:	1acb      	subs	r3, r1, r3
3400cb2e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
3400cb30:	68f9      	ldr	r1, [r7, #12]
3400cb32:	6809      	ldr	r1, [r1, #0]
3400cb34:	4608      	mov	r0, r1
3400cb36:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cb38:	0209      	lsls	r1, r1, #8
3400cb3a:	4401      	add	r1, r0
3400cb3c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400cb40:	4313      	orrs	r3, r2
3400cb42:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
3400cb44:	68fa      	ldr	r2, [r7, #12]
3400cb46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cb48:	2134      	movs	r1, #52	@ 0x34
3400cb4a:	fb01 f303 	mul.w	r3, r1, r3
3400cb4e:	4413      	add	r3, r2
3400cb50:	3364      	adds	r3, #100	@ 0x64
3400cb52:	681b      	ldr	r3, [r3, #0]
3400cb54:	68fa      	ldr	r2, [r7, #12]
3400cb56:	6812      	ldr	r2, [r2, #0]
3400cb58:	4611      	mov	r1, r2
3400cb5a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cb5c:	0212      	lsls	r2, r2, #8
3400cb5e:	440a      	add	r2, r1
3400cb60:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400cb64:	085b      	lsrs	r3, r3, #1
3400cb66:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400cb68:	e07b      	b.n	3400cc62 <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cb6a:	68fa      	ldr	r2, [r7, #12]
3400cb6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cb6e:	2134      	movs	r1, #52	@ 0x34
3400cb70:	fb01 f303 	mul.w	r3, r1, r3
3400cb74:	4413      	add	r3, r2
3400cb76:	333c      	adds	r3, #60	@ 0x3c
3400cb78:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cb7a:	68f9      	ldr	r1, [r7, #12]
3400cb7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cb7e:	2034      	movs	r0, #52	@ 0x34
3400cb80:	fb00 f303 	mul.w	r3, r0, r3
3400cb84:	440b      	add	r3, r1
3400cb86:	3338      	adds	r3, #56	@ 0x38
3400cb88:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cb8a:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cb8c:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cb8e:	697a      	ldr	r2, [r7, #20]
3400cb90:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400cb94:	68bb      	ldr	r3, [r7, #8]
3400cb96:	4413      	add	r3, r2
3400cb98:	68fa      	ldr	r2, [r7, #12]
3400cb9a:	6812      	ldr	r2, [r2, #0]
3400cb9c:	4611      	mov	r1, r2
3400cb9e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cba0:	0212      	lsls	r2, r2, #8
3400cba2:	440a      	add	r2, r1
3400cba4:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cba8:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400cbaa:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cbac:	68fa      	ldr	r2, [r7, #12]
3400cbae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cbb0:	2134      	movs	r1, #52	@ 0x34
3400cbb2:	fb01 f303 	mul.w	r3, r1, r3
3400cbb6:	4413      	add	r3, r2
3400cbb8:	333c      	adds	r3, #60	@ 0x3c
3400cbba:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cbbc:	68f9      	ldr	r1, [r7, #12]
3400cbbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cbc0:	2034      	movs	r0, #52	@ 0x34
3400cbc2:	fb00 f303 	mul.w	r3, r0, r3
3400cbc6:	440b      	add	r3, r1
3400cbc8:	3338      	adds	r3, #56	@ 0x38
3400cbca:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cbcc:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cbce:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cbd0:	697a      	ldr	r2, [r7, #20]
3400cbd2:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400cbd6:	687b      	ldr	r3, [r7, #4]
3400cbd8:	4413      	add	r3, r2
3400cbda:	68fa      	ldr	r2, [r7, #12]
3400cbdc:	6812      	ldr	r2, [r2, #0]
3400cbde:	4611      	mov	r1, r2
3400cbe0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cbe2:	0212      	lsls	r2, r2, #8
3400cbe4:	440a      	add	r2, r1
3400cbe6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400cbea:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400cbec:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400cbee:	68fa      	ldr	r2, [r7, #12]
3400cbf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cbf2:	2134      	movs	r1, #52	@ 0x34
3400cbf4:	fb01 f303 	mul.w	r3, r1, r3
3400cbf8:	4413      	add	r3, r2
3400cbfa:	3360      	adds	r3, #96	@ 0x60
3400cbfc:	681b      	ldr	r3, [r3, #0]
3400cbfe:	085b      	lsrs	r3, r3, #1
3400cc00:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cc02:	68f9      	ldr	r1, [r7, #12]
3400cc04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc06:	2034      	movs	r0, #52	@ 0x34
3400cc08:	fb00 f303 	mul.w	r3, r0, r3
3400cc0c:	440b      	add	r3, r1
3400cc0e:	333c      	adds	r3, #60	@ 0x3c
3400cc10:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400cc12:	68f8      	ldr	r0, [r7, #12]
3400cc14:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc16:	2434      	movs	r4, #52	@ 0x34
3400cc18:	fb04 f303 	mul.w	r3, r4, r3
3400cc1c:	4403      	add	r3, r0
3400cc1e:	3338      	adds	r3, #56	@ 0x38
3400cc20:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cc22:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400cc24:	085b      	lsrs	r3, r3, #1
3400cc26:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400cc28:	68f9      	ldr	r1, [r7, #12]
3400cc2a:	6809      	ldr	r1, [r1, #0]
3400cc2c:	4608      	mov	r0, r1
3400cc2e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cc30:	0209      	lsls	r1, r1, #8
3400cc32:	4401      	add	r1, r0
3400cc34:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400cc38:	4313      	orrs	r3, r2
3400cc3a:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400cc3c:	68fa      	ldr	r2, [r7, #12]
3400cc3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc40:	2134      	movs	r1, #52	@ 0x34
3400cc42:	fb01 f303 	mul.w	r3, r1, r3
3400cc46:	4413      	add	r3, r2
3400cc48:	3364      	adds	r3, #100	@ 0x64
3400cc4a:	681b      	ldr	r3, [r3, #0]
3400cc4c:	68fa      	ldr	r2, [r7, #12]
3400cc4e:	6812      	ldr	r2, [r2, #0]
3400cc50:	4611      	mov	r1, r2
3400cc52:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cc54:	0212      	lsls	r2, r2, #8
3400cc56:	440a      	add	r2, r1
3400cc58:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400cc5c:	085b      	lsrs	r3, r3, #1
3400cc5e:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400cc60:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400cc62:	68fa      	ldr	r2, [r7, #12]
3400cc64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc66:	2134      	movs	r1, #52	@ 0x34
3400cc68:	fb01 f303 	mul.w	r3, r1, r3
3400cc6c:	4413      	add	r3, r2
3400cc6e:	3360      	adds	r3, #96	@ 0x60
3400cc70:	681b      	ldr	r3, [r3, #0]
3400cc72:	697a      	ldr	r2, [r7, #20]
3400cc74:	fb02 f303 	mul.w	r3, r2, r3
3400cc78:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cc7a:	68f9      	ldr	r1, [r7, #12]
3400cc7c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc7e:	2034      	movs	r0, #52	@ 0x34
3400cc80:	fb00 f303 	mul.w	r3, r0, r3
3400cc84:	440b      	add	r3, r1
3400cc86:	333c      	adds	r3, #60	@ 0x3c
3400cc88:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400cc8a:	68f8      	ldr	r0, [r7, #12]
3400cc8c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cc8e:	2434      	movs	r4, #52	@ 0x34
3400cc90:	fb04 f303 	mul.w	r3, r4, r3
3400cc94:	4403      	add	r3, r0
3400cc96:	3338      	adds	r3, #56	@ 0x38
3400cc98:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cc9a:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400cc9c:	6979      	ldr	r1, [r7, #20]
3400cc9e:	fb01 f303 	mul.w	r3, r1, r3
3400cca2:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
3400cca4:	68f9      	ldr	r1, [r7, #12]
3400cca6:	6809      	ldr	r1, [r1, #0]
3400cca8:	4608      	mov	r0, r1
3400ccaa:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400ccac:	0209      	lsls	r1, r1, #8
3400ccae:	4401      	add	r1, r0
3400ccb0:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400ccb4:	4313      	orrs	r3, r2
3400ccb6:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3400ccb8:	68fb      	ldr	r3, [r7, #12]
3400ccba:	681b      	ldr	r3, [r3, #0]
3400ccbc:	461a      	mov	r2, r3
3400ccbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ccc0:	021b      	lsls	r3, r3, #8
3400ccc2:	4413      	add	r3, r2
3400ccc4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ccc8:	68db      	ldr	r3, [r3, #12]
3400ccca:	68fa      	ldr	r2, [r7, #12]
3400cccc:	6812      	ldr	r2, [r2, #0]
3400ccce:	4611      	mov	r1, r2
3400ccd0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ccd2:	0212      	lsls	r2, r2, #8
3400ccd4:	440a      	add	r2, r1
3400ccd6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ccda:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400ccde:	f043 0301 	orr.w	r3, r3, #1
3400cce2:	60d3      	str	r3, [r2, #12]
}
3400cce4:	e379      	b.n	3400d3da <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
3400cce6:	683b      	ldr	r3, [r7, #0]
3400cce8:	2b01      	cmp	r3, #1
3400ccea:	f040 81b4 	bne.w	3400d056 <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400ccee:	68fa      	ldr	r2, [r7, #12]
3400ccf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ccf2:	2134      	movs	r1, #52	@ 0x34
3400ccf4:	fb01 f303 	mul.w	r3, r1, r3
3400ccf8:	4413      	add	r3, r2
3400ccfa:	335c      	adds	r3, #92	@ 0x5c
3400ccfc:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ccfe:	68f9      	ldr	r1, [r7, #12]
3400cd00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cd02:	2034      	movs	r0, #52	@ 0x34
3400cd04:	fb00 f303 	mul.w	r3, r0, r3
3400cd08:	440b      	add	r3, r1
3400cd0a:	333c      	adds	r3, #60	@ 0x3c
3400cd0c:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400cd0e:	68f8      	ldr	r0, [r7, #12]
3400cd10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cd12:	2434      	movs	r4, #52	@ 0x34
3400cd14:	fb04 f303 	mul.w	r3, r4, r3
3400cd18:	4403      	add	r3, r0
3400cd1a:	3338      	adds	r3, #56	@ 0x38
3400cd1c:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cd1e:	1acb      	subs	r3, r1, r3
3400cd20:	6979      	ldr	r1, [r7, #20]
3400cd22:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cd26:	68f8      	ldr	r0, [r7, #12]
3400cd28:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cd2a:	2434      	movs	r4, #52	@ 0x34
3400cd2c:	fb04 f101 	mul.w	r1, r4, r1
3400cd30:	4401      	add	r1, r0
3400cd32:	3144      	adds	r1, #68	@ 0x44
3400cd34:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400cd36:	68fc      	ldr	r4, [r7, #12]
3400cd38:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cd3a:	2534      	movs	r5, #52	@ 0x34
3400cd3c:	fb05 f101 	mul.w	r1, r5, r1
3400cd40:	4421      	add	r1, r4
3400cd42:	3140      	adds	r1, #64	@ 0x40
3400cd44:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cd46:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
3400cd48:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400cd4a:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400cd4e:	68f9      	ldr	r1, [r7, #12]
3400cd50:	6809      	ldr	r1, [r1, #0]
3400cd52:	4608      	mov	r0, r1
3400cd54:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cd56:	0209      	lsls	r1, r1, #8
3400cd58:	4401      	add	r1, r0
3400cd5a:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400cd5e:	4413      	add	r3, r2
3400cd60:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400cd62:	68fa      	ldr	r2, [r7, #12]
3400cd64:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cd66:	2134      	movs	r1, #52	@ 0x34
3400cd68:	fb01 f303 	mul.w	r3, r1, r3
3400cd6c:	4413      	add	r3, r2
3400cd6e:	3348      	adds	r3, #72	@ 0x48
3400cd70:	681b      	ldr	r3, [r3, #0]
3400cd72:	f240 120d 	movw	r2, #269	@ 0x10d
3400cd76:	4293      	cmp	r3, r2
3400cd78:	d004      	beq.n	3400cd84 <LTDC_SetConfig+0x6b8>
3400cd7a:	f240 220d 	movw	r2, #525	@ 0x20d
3400cd7e:	4293      	cmp	r3, r2
3400cd80:	d075      	beq.n	3400ce6e <LTDC_SetConfig+0x7a2>
        break;
3400cd82:	e122      	b.n	3400cfca <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cd84:	68fa      	ldr	r2, [r7, #12]
3400cd86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cd88:	2134      	movs	r1, #52	@ 0x34
3400cd8a:	fb01 f303 	mul.w	r3, r1, r3
3400cd8e:	4413      	add	r3, r2
3400cd90:	333c      	adds	r3, #60	@ 0x3c
3400cd92:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400cd94:	68f9      	ldr	r1, [r7, #12]
3400cd96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cd98:	2034      	movs	r0, #52	@ 0x34
3400cd9a:	fb00 f303 	mul.w	r3, r0, r3
3400cd9e:	440b      	add	r3, r1
3400cda0:	3338      	adds	r3, #56	@ 0x38
3400cda2:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cda4:	1ad3      	subs	r3, r2, r3
3400cda6:	697a      	ldr	r2, [r7, #20]
3400cda8:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cdac:	68f9      	ldr	r1, [r7, #12]
3400cdae:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cdb0:	2034      	movs	r0, #52	@ 0x34
3400cdb2:	fb00 f202 	mul.w	r2, r0, r2
3400cdb6:	440a      	add	r2, r1
3400cdb8:	3244      	adds	r2, #68	@ 0x44
3400cdba:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400cdbc:	68f8      	ldr	r0, [r7, #12]
3400cdbe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cdc0:	2434      	movs	r4, #52	@ 0x34
3400cdc2:	fb04 f202 	mul.w	r2, r4, r2
3400cdc6:	4402      	add	r2, r0
3400cdc8:	3240      	adds	r2, #64	@ 0x40
3400cdca:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cdcc:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400cdce:	0852      	lsrs	r2, r2, #1
3400cdd0:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400cdd2:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400cdd6:	68fb      	ldr	r3, [r7, #12]
3400cdd8:	681b      	ldr	r3, [r3, #0]
3400cdda:	4619      	mov	r1, r3
3400cddc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cdde:	021b      	lsls	r3, r3, #8
3400cde0:	440b      	add	r3, r1
3400cde2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400cde6:	4619      	mov	r1, r3
3400cde8:	68bb      	ldr	r3, [r7, #8]
3400cdea:	4413      	add	r3, r2
3400cdec:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400cdee:	68fa      	ldr	r2, [r7, #12]
3400cdf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cdf2:	2134      	movs	r1, #52	@ 0x34
3400cdf4:	fb01 f303 	mul.w	r3, r1, r3
3400cdf8:	4413      	add	r3, r2
3400cdfa:	3360      	adds	r3, #96	@ 0x60
3400cdfc:	681b      	ldr	r3, [r3, #0]
3400cdfe:	697a      	ldr	r2, [r7, #20]
3400ce00:	fb02 f303 	mul.w	r3, r2, r3
3400ce04:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400ce08:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ce0a:	68f9      	ldr	r1, [r7, #12]
3400ce0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ce0e:	2034      	movs	r0, #52	@ 0x34
3400ce10:	fb00 f303 	mul.w	r3, r0, r3
3400ce14:	440b      	add	r3, r1
3400ce16:	333c      	adds	r3, #60	@ 0x3c
3400ce18:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3400ce1a:	68f8      	ldr	r0, [r7, #12]
3400ce1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ce1e:	2434      	movs	r4, #52	@ 0x34
3400ce20:	fb04 f303 	mul.w	r3, r4, r3
3400ce24:	4403      	add	r3, r0
3400ce26:	3338      	adds	r3, #56	@ 0x38
3400ce28:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ce2a:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
3400ce2c:	6979      	ldr	r1, [r7, #20]
3400ce2e:	fb01 f303 	mul.w	r3, r1, r3
3400ce32:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400ce34:	68f9      	ldr	r1, [r7, #12]
3400ce36:	6809      	ldr	r1, [r1, #0]
3400ce38:	4608      	mov	r0, r1
3400ce3a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400ce3c:	0209      	lsls	r1, r1, #8
3400ce3e:	4401      	add	r1, r0
3400ce40:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400ce44:	4313      	orrs	r3, r2
3400ce46:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400ce48:	68fa      	ldr	r2, [r7, #12]
3400ce4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ce4c:	2134      	movs	r1, #52	@ 0x34
3400ce4e:	fb01 f303 	mul.w	r3, r1, r3
3400ce52:	4413      	add	r3, r2
3400ce54:	3364      	adds	r3, #100	@ 0x64
3400ce56:	681b      	ldr	r3, [r3, #0]
3400ce58:	68fa      	ldr	r2, [r7, #12]
3400ce5a:	6812      	ldr	r2, [r2, #0]
3400ce5c:	4611      	mov	r1, r2
3400ce5e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ce60:	0212      	lsls	r2, r2, #8
3400ce62:	440a      	add	r2, r1
3400ce64:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400ce68:	085b      	lsrs	r3, r3, #1
3400ce6a:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400ce6c:	e0ad      	b.n	3400cfca <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ce6e:	68fa      	ldr	r2, [r7, #12]
3400ce70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ce72:	2134      	movs	r1, #52	@ 0x34
3400ce74:	fb01 f303 	mul.w	r3, r1, r3
3400ce78:	4413      	add	r3, r2
3400ce7a:	333c      	adds	r3, #60	@ 0x3c
3400ce7c:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ce7e:	68f9      	ldr	r1, [r7, #12]
3400ce80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ce82:	2034      	movs	r0, #52	@ 0x34
3400ce84:	fb00 f303 	mul.w	r3, r0, r3
3400ce88:	440b      	add	r3, r1
3400ce8a:	3338      	adds	r3, #56	@ 0x38
3400ce8c:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ce8e:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ce90:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ce92:	697a      	ldr	r2, [r7, #20]
3400ce94:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400ce98:	68f9      	ldr	r1, [r7, #12]
3400ce9a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ce9c:	2034      	movs	r0, #52	@ 0x34
3400ce9e:	fb00 f202 	mul.w	r2, r0, r2
3400cea2:	440a      	add	r2, r1
3400cea4:	3244      	adds	r2, #68	@ 0x44
3400cea6:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400cea8:	68f8      	ldr	r0, [r7, #12]
3400ceaa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ceac:	2434      	movs	r4, #52	@ 0x34
3400ceae:	fb04 f202 	mul.w	r2, r4, r2
3400ceb2:	4402      	add	r2, r0
3400ceb4:	3240      	adds	r2, #64	@ 0x40
3400ceb6:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400ceb8:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400ceba:	0852      	lsrs	r2, r2, #1
3400cebc:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400cebe:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400cec2:	68fb      	ldr	r3, [r7, #12]
3400cec4:	681b      	ldr	r3, [r3, #0]
3400cec6:	4619      	mov	r1, r3
3400cec8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ceca:	021b      	lsls	r3, r3, #8
3400cecc:	440b      	add	r3, r1
3400cece:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400ced2:	4619      	mov	r1, r3
3400ced4:	68bb      	ldr	r3, [r7, #8]
3400ced6:	4413      	add	r3, r2
3400ced8:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400ceda:	68fa      	ldr	r2, [r7, #12]
3400cedc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cede:	2134      	movs	r1, #52	@ 0x34
3400cee0:	fb01 f303 	mul.w	r3, r1, r3
3400cee4:	4413      	add	r3, r2
3400cee6:	333c      	adds	r3, #60	@ 0x3c
3400cee8:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400ceea:	68f9      	ldr	r1, [r7, #12]
3400ceec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400ceee:	2034      	movs	r0, #52	@ 0x34
3400cef0:	fb00 f303 	mul.w	r3, r0, r3
3400cef4:	440b      	add	r3, r1
3400cef6:	3338      	adds	r3, #56	@ 0x38
3400cef8:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cefa:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400cefc:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cefe:	697a      	ldr	r2, [r7, #20]
3400cf00:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cf04:	68f9      	ldr	r1, [r7, #12]
3400cf06:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cf08:	2034      	movs	r0, #52	@ 0x34
3400cf0a:	fb00 f202 	mul.w	r2, r0, r2
3400cf0e:	440a      	add	r2, r1
3400cf10:	3244      	adds	r2, #68	@ 0x44
3400cf12:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400cf14:	68f8      	ldr	r0, [r7, #12]
3400cf16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cf18:	2434      	movs	r4, #52	@ 0x34
3400cf1a:	fb04 f202 	mul.w	r2, r4, r2
3400cf1e:	4402      	add	r2, r0
3400cf20:	3240      	adds	r2, #64	@ 0x40
3400cf22:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400cf24:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400cf26:	0852      	lsrs	r2, r2, #1
3400cf28:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400cf2a:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400cf2e:	68fb      	ldr	r3, [r7, #12]
3400cf30:	681b      	ldr	r3, [r3, #0]
3400cf32:	4619      	mov	r1, r3
3400cf34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cf36:	021b      	lsls	r3, r3, #8
3400cf38:	440b      	add	r3, r1
3400cf3a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400cf3e:	4619      	mov	r1, r3
3400cf40:	687b      	ldr	r3, [r7, #4]
3400cf42:	4413      	add	r3, r2
3400cf44:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400cf46:	68fa      	ldr	r2, [r7, #12]
3400cf48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cf4a:	2134      	movs	r1, #52	@ 0x34
3400cf4c:	fb01 f303 	mul.w	r3, r1, r3
3400cf50:	4413      	add	r3, r2
3400cf52:	3360      	adds	r3, #96	@ 0x60
3400cf54:	681b      	ldr	r3, [r3, #0]
3400cf56:	085b      	lsrs	r3, r3, #1
3400cf58:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400cf5c:	697a      	ldr	r2, [r7, #20]
3400cf5e:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
3400cf62:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cf64:	68f9      	ldr	r1, [r7, #12]
3400cf66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cf68:	2034      	movs	r0, #52	@ 0x34
3400cf6a:	fb00 f303 	mul.w	r3, r0, r3
3400cf6e:	440b      	add	r3, r1
3400cf70:	333c      	adds	r3, #60	@ 0x3c
3400cf72:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400cf74:	68f8      	ldr	r0, [r7, #12]
3400cf76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cf78:	2434      	movs	r4, #52	@ 0x34
3400cf7a:	fb04 f303 	mul.w	r3, r4, r3
3400cf7e:	4403      	add	r3, r0
3400cf80:	3338      	adds	r3, #56	@ 0x38
3400cf82:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cf84:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400cf86:	085b      	lsrs	r3, r3, #1
3400cf88:	6979      	ldr	r1, [r7, #20]
3400cf8a:	fb01 f303 	mul.w	r3, r1, r3
3400cf8e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400cf90:	68f9      	ldr	r1, [r7, #12]
3400cf92:	6809      	ldr	r1, [r1, #0]
3400cf94:	4608      	mov	r0, r1
3400cf96:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400cf98:	0209      	lsls	r1, r1, #8
3400cf9a:	4401      	add	r1, r0
3400cf9c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
3400cfa0:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
3400cfa2:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400cfa4:	68fa      	ldr	r2, [r7, #12]
3400cfa6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cfa8:	2134      	movs	r1, #52	@ 0x34
3400cfaa:	fb01 f303 	mul.w	r3, r1, r3
3400cfae:	4413      	add	r3, r2
3400cfb0:	3364      	adds	r3, #100	@ 0x64
3400cfb2:	681b      	ldr	r3, [r3, #0]
3400cfb4:	68fa      	ldr	r2, [r7, #12]
3400cfb6:	6812      	ldr	r2, [r2, #0]
3400cfb8:	4611      	mov	r1, r2
3400cfba:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400cfbc:	0212      	lsls	r2, r2, #8
3400cfbe:	440a      	add	r2, r1
3400cfc0:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400cfc4:	085b      	lsrs	r3, r3, #1
3400cfc6:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400cfc8:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400cfca:	68fa      	ldr	r2, [r7, #12]
3400cfcc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cfce:	2134      	movs	r1, #52	@ 0x34
3400cfd0:	fb01 f303 	mul.w	r3, r1, r3
3400cfd4:	4413      	add	r3, r2
3400cfd6:	3360      	adds	r3, #96	@ 0x60
3400cfd8:	681b      	ldr	r3, [r3, #0]
3400cfda:	697a      	ldr	r2, [r7, #20]
3400cfdc:	fb02 f303 	mul.w	r3, r2, r3
3400cfe0:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400cfe4:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400cfe6:	68f9      	ldr	r1, [r7, #12]
3400cfe8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cfea:	2034      	movs	r0, #52	@ 0x34
3400cfec:	fb00 f303 	mul.w	r3, r0, r3
3400cff0:	440b      	add	r3, r1
3400cff2:	333c      	adds	r3, #60	@ 0x3c
3400cff4:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400cff6:	68f8      	ldr	r0, [r7, #12]
3400cff8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400cffa:	2434      	movs	r4, #52	@ 0x34
3400cffc:	fb04 f303 	mul.w	r3, r4, r3
3400d000:	4403      	add	r3, r0
3400d002:	3338      	adds	r3, #56	@ 0x38
3400d004:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d006:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400d008:	6979      	ldr	r1, [r7, #20]
3400d00a:	fb01 f303 	mul.w	r3, r1, r3
3400d00e:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400d010:	68f9      	ldr	r1, [r7, #12]
3400d012:	6809      	ldr	r1, [r1, #0]
3400d014:	4608      	mov	r0, r1
3400d016:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d018:	0209      	lsls	r1, r1, #8
3400d01a:	4401      	add	r1, r0
3400d01c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400d020:	4313      	orrs	r3, r2
3400d022:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
3400d024:	68fb      	ldr	r3, [r7, #12]
3400d026:	681b      	ldr	r3, [r3, #0]
3400d028:	461a      	mov	r2, r3
3400d02a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d02c:	021b      	lsls	r3, r3, #8
3400d02e:	4413      	add	r3, r2
3400d030:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d034:	68db      	ldr	r3, [r3, #12]
3400d036:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3400d03a:	f023 0301 	bic.w	r3, r3, #1
3400d03e:	68fa      	ldr	r2, [r7, #12]
3400d040:	6812      	ldr	r2, [r2, #0]
3400d042:	4611      	mov	r1, r2
3400d044:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d046:	0212      	lsls	r2, r2, #8
3400d048:	440a      	add	r2, r1
3400d04a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d04e:	f043 0301 	orr.w	r3, r3, #1
3400d052:	60d3      	str	r3, [r2, #12]
}
3400d054:	e1c1      	b.n	3400d3da <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400d056:	68fa      	ldr	r2, [r7, #12]
3400d058:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d05a:	2134      	movs	r1, #52	@ 0x34
3400d05c:	fb01 f303 	mul.w	r3, r1, r3
3400d060:	4413      	add	r3, r2
3400d062:	335c      	adds	r3, #92	@ 0x5c
3400d064:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d066:	68f9      	ldr	r1, [r7, #12]
3400d068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d06a:	2034      	movs	r0, #52	@ 0x34
3400d06c:	fb00 f303 	mul.w	r3, r0, r3
3400d070:	440b      	add	r3, r1
3400d072:	333c      	adds	r3, #60	@ 0x3c
3400d074:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400d076:	68f8      	ldr	r0, [r7, #12]
3400d078:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d07a:	2434      	movs	r4, #52	@ 0x34
3400d07c:	fb04 f303 	mul.w	r3, r4, r3
3400d080:	4403      	add	r3, r0
3400d082:	3338      	adds	r3, #56	@ 0x38
3400d084:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d086:	1acb      	subs	r3, r1, r3
3400d088:	6979      	ldr	r1, [r7, #20]
3400d08a:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400d08e:	68f8      	ldr	r0, [r7, #12]
3400d090:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d092:	2434      	movs	r4, #52	@ 0x34
3400d094:	fb04 f101 	mul.w	r1, r4, r1
3400d098:	4401      	add	r1, r0
3400d09a:	3144      	adds	r1, #68	@ 0x44
3400d09c:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3400d09e:	68fc      	ldr	r4, [r7, #12]
3400d0a0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d0a2:	2534      	movs	r5, #52	@ 0x34
3400d0a4:	fb05 f101 	mul.w	r1, r5, r1
3400d0a8:	4421      	add	r1, r4
3400d0aa:	3140      	adds	r1, #64	@ 0x40
3400d0ac:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400d0ae:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400d0b0:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400d0b4:	4413      	add	r3, r2
3400d0b6:	68fa      	ldr	r2, [r7, #12]
3400d0b8:	6812      	ldr	r2, [r2, #0]
3400d0ba:	4611      	mov	r1, r2
3400d0bc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d0be:	0212      	lsls	r2, r2, #8
3400d0c0:	440a      	add	r2, r1
3400d0c2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3400d0c6:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400d0c8:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400d0ca:	68fa      	ldr	r2, [r7, #12]
3400d0cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d0ce:	2134      	movs	r1, #52	@ 0x34
3400d0d0:	fb01 f303 	mul.w	r3, r1, r3
3400d0d4:	4413      	add	r3, r2
3400d0d6:	3348      	adds	r3, #72	@ 0x48
3400d0d8:	681b      	ldr	r3, [r3, #0]
3400d0da:	f240 120d 	movw	r2, #269	@ 0x10d
3400d0de:	4293      	cmp	r3, r2
3400d0e0:	d004      	beq.n	3400d0ec <LTDC_SetConfig+0xa20>
3400d0e2:	f240 220d 	movw	r2, #525	@ 0x20d
3400d0e6:	4293      	cmp	r3, r2
3400d0e8:	d074      	beq.n	3400d1d4 <LTDC_SetConfig+0xb08>
        break;
3400d0ea:	e133      	b.n	3400d354 <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d0ec:	68fa      	ldr	r2, [r7, #12]
3400d0ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d0f0:	2134      	movs	r1, #52	@ 0x34
3400d0f2:	fb01 f303 	mul.w	r3, r1, r3
3400d0f6:	4413      	add	r3, r2
3400d0f8:	333c      	adds	r3, #60	@ 0x3c
3400d0fa:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400d0fc:	68f9      	ldr	r1, [r7, #12]
3400d0fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d100:	2034      	movs	r0, #52	@ 0x34
3400d102:	fb00 f303 	mul.w	r3, r0, r3
3400d106:	440b      	add	r3, r1
3400d108:	3338      	adds	r3, #56	@ 0x38
3400d10a:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d10c:	1ad3      	subs	r3, r2, r3
3400d10e:	697a      	ldr	r2, [r7, #20]
3400d110:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d114:	68f9      	ldr	r1, [r7, #12]
3400d116:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d118:	2034      	movs	r0, #52	@ 0x34
3400d11a:	fb00 f202 	mul.w	r2, r0, r2
3400d11e:	440a      	add	r2, r1
3400d120:	3244      	adds	r2, #68	@ 0x44
3400d122:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d124:	68f8      	ldr	r0, [r7, #12]
3400d126:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d128:	2434      	movs	r4, #52	@ 0x34
3400d12a:	fb04 f202 	mul.w	r2, r4, r2
3400d12e:	4402      	add	r2, r0
3400d130:	3240      	adds	r2, #64	@ 0x40
3400d132:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d134:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d136:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
3400d138:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400d13c:	68bb      	ldr	r3, [r7, #8]
3400d13e:	4413      	add	r3, r2
3400d140:	68fa      	ldr	r2, [r7, #12]
3400d142:	6812      	ldr	r2, [r2, #0]
3400d144:	4611      	mov	r1, r2
3400d146:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d148:	0212      	lsls	r2, r2, #8
3400d14a:	440a      	add	r2, r1
3400d14c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d150:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400d152:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400d154:	68fa      	ldr	r2, [r7, #12]
3400d156:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d158:	2134      	movs	r1, #52	@ 0x34
3400d15a:	fb01 f303 	mul.w	r3, r1, r3
3400d15e:	4413      	add	r3, r2
3400d160:	3360      	adds	r3, #96	@ 0x60
3400d162:	681b      	ldr	r3, [r3, #0]
3400d164:	697a      	ldr	r2, [r7, #20]
3400d166:	fb02 f303 	mul.w	r3, r2, r3
3400d16a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400d16e:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d170:	68f9      	ldr	r1, [r7, #12]
3400d172:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d174:	2034      	movs	r0, #52	@ 0x34
3400d176:	fb00 f303 	mul.w	r3, r0, r3
3400d17a:	440b      	add	r3, r1
3400d17c:	333c      	adds	r3, #60	@ 0x3c
3400d17e:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3400d180:	68f8      	ldr	r0, [r7, #12]
3400d182:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d184:	2434      	movs	r4, #52	@ 0x34
3400d186:	fb04 f303 	mul.w	r3, r4, r3
3400d18a:	4403      	add	r3, r0
3400d18c:	3338      	adds	r3, #56	@ 0x38
3400d18e:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d190:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
3400d192:	6979      	ldr	r1, [r7, #20]
3400d194:	fb01 f303 	mul.w	r3, r1, r3
3400d198:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
3400d19a:	68f9      	ldr	r1, [r7, #12]
3400d19c:	6809      	ldr	r1, [r1, #0]
3400d19e:	4608      	mov	r0, r1
3400d1a0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d1a2:	0209      	lsls	r1, r1, #8
3400d1a4:	4401      	add	r1, r0
3400d1a6:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400d1aa:	4313      	orrs	r3, r2
3400d1ac:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400d1ae:	68fa      	ldr	r2, [r7, #12]
3400d1b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d1b2:	2134      	movs	r1, #52	@ 0x34
3400d1b4:	fb01 f303 	mul.w	r3, r1, r3
3400d1b8:	4413      	add	r3, r2
3400d1ba:	3364      	adds	r3, #100	@ 0x64
3400d1bc:	681b      	ldr	r3, [r3, #0]
3400d1be:	68fa      	ldr	r2, [r7, #12]
3400d1c0:	6812      	ldr	r2, [r2, #0]
3400d1c2:	4611      	mov	r1, r2
3400d1c4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d1c6:	0212      	lsls	r2, r2, #8
3400d1c8:	440a      	add	r2, r1
3400d1ca:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d1ce:	085b      	lsrs	r3, r3, #1
3400d1d0:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400d1d2:	e0bf      	b.n	3400d354 <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d1d4:	68fa      	ldr	r2, [r7, #12]
3400d1d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d1d8:	2134      	movs	r1, #52	@ 0x34
3400d1da:	fb01 f303 	mul.w	r3, r1, r3
3400d1de:	4413      	add	r3, r2
3400d1e0:	333c      	adds	r3, #60	@ 0x3c
3400d1e2:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d1e4:	68f9      	ldr	r1, [r7, #12]
3400d1e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d1e8:	2034      	movs	r0, #52	@ 0x34
3400d1ea:	fb00 f303 	mul.w	r3, r0, r3
3400d1ee:	440b      	add	r3, r1
3400d1f0:	3338      	adds	r3, #56	@ 0x38
3400d1f2:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d1f4:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d1f6:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d1f8:	697a      	ldr	r2, [r7, #20]
3400d1fa:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d1fe:	68f9      	ldr	r1, [r7, #12]
3400d200:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d202:	2034      	movs	r0, #52	@ 0x34
3400d204:	fb00 f202 	mul.w	r2, r0, r2
3400d208:	440a      	add	r2, r1
3400d20a:	3244      	adds	r2, #68	@ 0x44
3400d20c:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d20e:	68f8      	ldr	r0, [r7, #12]
3400d210:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d212:	2434      	movs	r4, #52	@ 0x34
3400d214:	fb04 f202 	mul.w	r2, r4, r2
3400d218:	4402      	add	r2, r0
3400d21a:	3240      	adds	r2, #64	@ 0x40
3400d21c:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d21e:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d220:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d222:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400d226:	68bb      	ldr	r3, [r7, #8]
3400d228:	4413      	add	r3, r2
3400d22a:	68fa      	ldr	r2, [r7, #12]
3400d22c:	6812      	ldr	r2, [r2, #0]
3400d22e:	4611      	mov	r1, r2
3400d230:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d232:	0212      	lsls	r2, r2, #8
3400d234:	440a      	add	r2, r1
3400d236:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d23a:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400d23c:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d23e:	68fa      	ldr	r2, [r7, #12]
3400d240:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d242:	2134      	movs	r1, #52	@ 0x34
3400d244:	fb01 f303 	mul.w	r3, r1, r3
3400d248:	4413      	add	r3, r2
3400d24a:	333c      	adds	r3, #60	@ 0x3c
3400d24c:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d24e:	68f9      	ldr	r1, [r7, #12]
3400d250:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d252:	2034      	movs	r0, #52	@ 0x34
3400d254:	fb00 f303 	mul.w	r3, r0, r3
3400d258:	440b      	add	r3, r1
3400d25a:	3338      	adds	r3, #56	@ 0x38
3400d25c:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d25e:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d260:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d262:	697a      	ldr	r2, [r7, #20]
3400d264:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d268:	68f9      	ldr	r1, [r7, #12]
3400d26a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d26c:	2034      	movs	r0, #52	@ 0x34
3400d26e:	fb00 f202 	mul.w	r2, r0, r2
3400d272:	440a      	add	r2, r1
3400d274:	3244      	adds	r2, #68	@ 0x44
3400d276:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d278:	68f8      	ldr	r0, [r7, #12]
3400d27a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d27c:	2434      	movs	r4, #52	@ 0x34
3400d27e:	fb04 f202 	mul.w	r2, r4, r2
3400d282:	4402      	add	r2, r0
3400d284:	3240      	adds	r2, #64	@ 0x40
3400d286:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400d288:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d28a:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400d28c:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400d290:	687b      	ldr	r3, [r7, #4]
3400d292:	4413      	add	r3, r2
3400d294:	68fa      	ldr	r2, [r7, #12]
3400d296:	6812      	ldr	r2, [r2, #0]
3400d298:	4611      	mov	r1, r2
3400d29a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d29c:	0212      	lsls	r2, r2, #8
3400d29e:	440a      	add	r2, r1
3400d2a0:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
3400d2a4:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
3400d2a6:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400d2a8:	68fa      	ldr	r2, [r7, #12]
3400d2aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d2ac:	2134      	movs	r1, #52	@ 0x34
3400d2ae:	fb01 f303 	mul.w	r3, r1, r3
3400d2b2:	4413      	add	r3, r2
3400d2b4:	3360      	adds	r3, #96	@ 0x60
3400d2b6:	681b      	ldr	r3, [r3, #0]
3400d2b8:	085b      	lsrs	r3, r3, #1
3400d2ba:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400d2be:	697a      	ldr	r2, [r7, #20]
3400d2c0:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
3400d2c4:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d2c6:	68f9      	ldr	r1, [r7, #12]
3400d2c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d2ca:	2034      	movs	r0, #52	@ 0x34
3400d2cc:	fb00 f303 	mul.w	r3, r0, r3
3400d2d0:	440b      	add	r3, r1
3400d2d2:	333c      	adds	r3, #60	@ 0x3c
3400d2d4:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400d2d6:	68f8      	ldr	r0, [r7, #12]
3400d2d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d2da:	2434      	movs	r4, #52	@ 0x34
3400d2dc:	fb04 f303 	mul.w	r3, r4, r3
3400d2e0:	4403      	add	r3, r0
3400d2e2:	3338      	adds	r3, #56	@ 0x38
3400d2e4:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d2e6:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
3400d2e8:	085b      	lsrs	r3, r3, #1
3400d2ea:	6979      	ldr	r1, [r7, #20]
3400d2ec:	fb01 f303 	mul.w	r3, r1, r3
3400d2f0:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400d2f2:	68f9      	ldr	r1, [r7, #12]
3400d2f4:	6809      	ldr	r1, [r1, #0]
3400d2f6:	4608      	mov	r0, r1
3400d2f8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d2fa:	0209      	lsls	r1, r1, #8
3400d2fc:	4401      	add	r1, r0
3400d2fe:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
3400d302:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
3400d304:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
3400d306:	68fb      	ldr	r3, [r7, #12]
3400d308:	681b      	ldr	r3, [r3, #0]
3400d30a:	461a      	mov	r2, r3
3400d30c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d30e:	021b      	lsls	r3, r3, #8
3400d310:	4413      	add	r3, r2
3400d312:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d316:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400d318:	68fa      	ldr	r2, [r7, #12]
3400d31a:	6812      	ldr	r2, [r2, #0]
3400d31c:	4611      	mov	r1, r2
3400d31e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d320:	0212      	lsls	r2, r2, #8
3400d322:	440a      	add	r2, r1
3400d324:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d328:	0c1b      	lsrs	r3, r3, #16
3400d32a:	041b      	lsls	r3, r3, #16
3400d32c:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400d32e:	68fa      	ldr	r2, [r7, #12]
3400d330:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d332:	2134      	movs	r1, #52	@ 0x34
3400d334:	fb01 f303 	mul.w	r3, r1, r3
3400d338:	4413      	add	r3, r2
3400d33a:	3364      	adds	r3, #100	@ 0x64
3400d33c:	681b      	ldr	r3, [r3, #0]
3400d33e:	68fa      	ldr	r2, [r7, #12]
3400d340:	6812      	ldr	r2, [r2, #0]
3400d342:	4611      	mov	r1, r2
3400d344:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d346:	0212      	lsls	r2, r2, #8
3400d348:	440a      	add	r2, r1
3400d34a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d34e:	085b      	lsrs	r3, r3, #1
3400d350:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400d352:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400d354:	68fa      	ldr	r2, [r7, #12]
3400d356:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d358:	2134      	movs	r1, #52	@ 0x34
3400d35a:	fb01 f303 	mul.w	r3, r1, r3
3400d35e:	4413      	add	r3, r2
3400d360:	3360      	adds	r3, #96	@ 0x60
3400d362:	681b      	ldr	r3, [r3, #0]
3400d364:	697a      	ldr	r2, [r7, #20]
3400d366:	fb02 f303 	mul.w	r3, r2, r3
3400d36a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400d36e:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d370:	68f9      	ldr	r1, [r7, #12]
3400d372:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d374:	2034      	movs	r0, #52	@ 0x34
3400d376:	fb00 f303 	mul.w	r3, r0, r3
3400d37a:	440b      	add	r3, r1
3400d37c:	333c      	adds	r3, #60	@ 0x3c
3400d37e:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400d380:	68f8      	ldr	r0, [r7, #12]
3400d382:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d384:	2434      	movs	r4, #52	@ 0x34
3400d386:	fb04 f303 	mul.w	r3, r4, r3
3400d38a:	4403      	add	r3, r0
3400d38c:	3338      	adds	r3, #56	@ 0x38
3400d38e:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400d390:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
3400d392:	6979      	ldr	r1, [r7, #20]
3400d394:	fb01 f303 	mul.w	r3, r1, r3
3400d398:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400d39a:	68f9      	ldr	r1, [r7, #12]
3400d39c:	6809      	ldr	r1, [r1, #0]
3400d39e:	4608      	mov	r0, r1
3400d3a0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400d3a2:	0209      	lsls	r1, r1, #8
3400d3a4:	4401      	add	r1, r0
3400d3a6:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400d3aa:	4313      	orrs	r3, r2
3400d3ac:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
3400d3ae:	68fb      	ldr	r3, [r7, #12]
3400d3b0:	681b      	ldr	r3, [r3, #0]
3400d3b2:	461a      	mov	r2, r3
3400d3b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d3b6:	021b      	lsls	r3, r3, #8
3400d3b8:	4413      	add	r3, r2
3400d3ba:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d3be:	68db      	ldr	r3, [r3, #12]
3400d3c0:	68fa      	ldr	r2, [r7, #12]
3400d3c2:	6812      	ldr	r2, [r2, #0]
3400d3c4:	4611      	mov	r1, r2
3400d3c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400d3c8:	0212      	lsls	r2, r2, #8
3400d3ca:	440a      	add	r2, r1
3400d3cc:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d3d0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400d3d4:	f043 0301 	orr.w	r3, r3, #1
3400d3d8:	60d3      	str	r3, [r2, #12]
}
3400d3da:	bf00      	nop
3400d3dc:	371c      	adds	r7, #28
3400d3de:	46bd      	mov	sp, r7
3400d3e0:	bcb0      	pop	{r4, r5, r7}
3400d3e2:	4770      	bx	lr

3400d3e4 <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3400d3e4:	b480      	push	{r7}
3400d3e6:	b087      	sub	sp, #28
3400d3e8:	af00      	add	r7, sp, #0
3400d3ea:	6078      	str	r0, [r7, #4]
3400d3ec:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
3400d3ee:	687a      	ldr	r2, [r7, #4]
3400d3f0:	683b      	ldr	r3, [r7, #0]
3400d3f2:	2134      	movs	r1, #52	@ 0x34
3400d3f4:	fb01 f303 	mul.w	r3, r1, r3
3400d3f8:	4413      	add	r3, r2
3400d3fa:	3369      	adds	r3, #105	@ 0x69
3400d3fc:	781b      	ldrb	r3, [r3, #0]
3400d3fe:	021b      	lsls	r3, r3, #8
3400d400:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
3400d402:	687a      	ldr	r2, [r7, #4]
3400d404:	683b      	ldr	r3, [r7, #0]
3400d406:	2134      	movs	r1, #52	@ 0x34
3400d408:	fb01 f303 	mul.w	r3, r1, r3
3400d40c:	4413      	add	r3, r2
3400d40e:	336a      	adds	r3, #106	@ 0x6a
3400d410:	781b      	ldrb	r3, [r3, #0]
3400d412:	041b      	lsls	r3, r3, #16
3400d414:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
3400d416:	687a      	ldr	r2, [r7, #4]
3400d418:	683b      	ldr	r3, [r7, #0]
3400d41a:	2134      	movs	r1, #52	@ 0x34
3400d41c:	fb01 f303 	mul.w	r3, r1, r3
3400d420:	4413      	add	r3, r2
3400d422:	3350      	adds	r3, #80	@ 0x50
3400d424:	681b      	ldr	r3, [r3, #0]
3400d426:	061b      	lsls	r3, r3, #24
3400d428:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
3400d42a:	687a      	ldr	r2, [r7, #4]
3400d42c:	683b      	ldr	r3, [r7, #0]
3400d42e:	2134      	movs	r1, #52	@ 0x34
3400d430:	fb01 f303 	mul.w	r3, r1, r3
3400d434:	4413      	add	r3, r2
3400d436:	3368      	adds	r3, #104	@ 0x68
3400d438:	781b      	ldrb	r3, [r3, #0]
3400d43a:	461a      	mov	r2, r3
3400d43c:	697b      	ldr	r3, [r7, #20]
3400d43e:	431a      	orrs	r2, r3
3400d440:	693b      	ldr	r3, [r7, #16]
3400d442:	431a      	orrs	r2, r3
3400d444:	687b      	ldr	r3, [r7, #4]
3400d446:	681b      	ldr	r3, [r3, #0]
3400d448:	4619      	mov	r1, r3
3400d44a:	683b      	ldr	r3, [r7, #0]
3400d44c:	021b      	lsls	r3, r3, #8
3400d44e:	440b      	add	r3, r1
3400d450:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d454:	4619      	mov	r1, r3
3400d456:	68fb      	ldr	r3, [r7, #12]
3400d458:	4313      	orrs	r3, r2
3400d45a:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
3400d45c:	687b      	ldr	r3, [r7, #4]
3400d45e:	681b      	ldr	r3, [r3, #0]
3400d460:	461a      	mov	r2, r3
3400d462:	683b      	ldr	r3, [r7, #0]
3400d464:	021b      	lsls	r3, r3, #8
3400d466:	4413      	add	r3, r2
3400d468:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d46c:	6a1b      	ldr	r3, [r3, #32]
3400d46e:	687a      	ldr	r2, [r7, #4]
3400d470:	6812      	ldr	r2, [r2, #0]
3400d472:	4611      	mov	r1, r2
3400d474:	683a      	ldr	r2, [r7, #0]
3400d476:	0212      	lsls	r2, r2, #8
3400d478:	440a      	add	r2, r1
3400d47a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400d47e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
3400d482:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
3400d484:	687b      	ldr	r3, [r7, #4]
3400d486:	681b      	ldr	r3, [r3, #0]
3400d488:	461a      	mov	r2, r3
3400d48a:	683b      	ldr	r3, [r7, #0]
3400d48c:	021b      	lsls	r3, r3, #8
3400d48e:	4413      	add	r3, r2
3400d490:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d494:	4618      	mov	r0, r3
3400d496:	687a      	ldr	r2, [r7, #4]
3400d498:	683b      	ldr	r3, [r7, #0]
3400d49a:	2134      	movs	r1, #52	@ 0x34
3400d49c:	fb01 f303 	mul.w	r3, r1, r3
3400d4a0:	4413      	add	r3, r2
3400d4a2:	334c      	adds	r3, #76	@ 0x4c
3400d4a4:	681b      	ldr	r3, [r3, #0]
3400d4a6:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
3400d4a8:	687b      	ldr	r3, [r7, #4]
3400d4aa:	681b      	ldr	r3, [r3, #0]
3400d4ac:	461a      	mov	r2, r3
3400d4ae:	683b      	ldr	r3, [r7, #0]
3400d4b0:	021b      	lsls	r3, r3, #8
3400d4b2:	4413      	add	r3, r2
3400d4b4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d4b8:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400d4ba:	687b      	ldr	r3, [r7, #4]
3400d4bc:	681b      	ldr	r3, [r3, #0]
3400d4be:	4619      	mov	r1, r3
3400d4c0:	683b      	ldr	r3, [r7, #0]
3400d4c2:	021b      	lsls	r3, r3, #8
3400d4c4:	440b      	add	r3, r1
3400d4c6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d4ca:	4619      	mov	r1, r3
3400d4cc:	4b18      	ldr	r3, [pc, #96]	@ (3400d530 <LTDC_SetCompositionConfig+0x14c>)
3400d4ce:	4013      	ands	r3, r2
3400d4d0:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
3400d4d2:	687b      	ldr	r3, [r7, #4]
3400d4d4:	681b      	ldr	r3, [r3, #0]
3400d4d6:	461a      	mov	r2, r3
3400d4d8:	683b      	ldr	r3, [r7, #0]
3400d4da:	021b      	lsls	r3, r3, #8
3400d4dc:	4413      	add	r3, r2
3400d4de:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d4e2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400d4e4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400d4e8:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400d4ea:	687a      	ldr	r2, [r7, #4]
3400d4ec:	683b      	ldr	r3, [r7, #0]
3400d4ee:	2134      	movs	r1, #52	@ 0x34
3400d4f0:	fb01 f303 	mul.w	r3, r1, r3
3400d4f4:	4413      	add	r3, r2
3400d4f6:	3354      	adds	r3, #84	@ 0x54
3400d4f8:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400d4fa:	6879      	ldr	r1, [r7, #4]
3400d4fc:	683b      	ldr	r3, [r7, #0]
3400d4fe:	2034      	movs	r0, #52	@ 0x34
3400d500:	fb00 f303 	mul.w	r3, r0, r3
3400d504:	440b      	add	r3, r1
3400d506:	3358      	adds	r3, #88	@ 0x58
3400d508:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400d50a:	431a      	orrs	r2, r3
3400d50c:	687b      	ldr	r3, [r7, #4]
3400d50e:	681b      	ldr	r3, [r3, #0]
3400d510:	4619      	mov	r1, r3
3400d512:	683b      	ldr	r3, [r7, #0]
3400d514:	021b      	lsls	r3, r3, #8
3400d516:	440b      	add	r3, r1
3400d518:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d51c:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
3400d51e:	697b      	ldr	r3, [r7, #20]
3400d520:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
3400d522:	628b      	str	r3, [r1, #40]	@ 0x28
}
3400d524:	bf00      	nop
3400d526:	371c      	adds	r7, #28
3400d528:	46bd      	mov	sp, r7
3400d52a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d52e:	4770      	bx	lr
3400d530:	fffef8f8 	.word	0xfffef8f8

3400d534 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
3400d534:	b480      	push	{r7}
3400d536:	b08d      	sub	sp, #52	@ 0x34
3400d538:	af00      	add	r7, sp, #0
3400d53a:	6078      	str	r0, [r7, #4]
3400d53c:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
3400d53e:	2300      	movs	r3, #0
3400d540:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
3400d542:	2300      	movs	r3, #0
3400d544:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
3400d546:	2300      	movs	r3, #0
3400d548:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
3400d54a:	2300      	movs	r3, #0
3400d54c:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
3400d54e:	2300      	movs	r3, #0
3400d550:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
3400d552:	2300      	movs	r3, #0
3400d554:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
3400d556:	2300      	movs	r3, #0
3400d558:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
3400d55a:	2300      	movs	r3, #0
3400d55c:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
3400d55e:	2300      	movs	r3, #0
3400d560:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400d562:	687a      	ldr	r2, [r7, #4]
3400d564:	683b      	ldr	r3, [r7, #0]
3400d566:	2134      	movs	r1, #52	@ 0x34
3400d568:	fb01 f303 	mul.w	r3, r1, r3
3400d56c:	4413      	add	r3, r2
3400d56e:	3348      	adds	r3, #72	@ 0x48
3400d570:	681b      	ldr	r3, [r3, #0]
3400d572:	3b07      	subs	r3, #7
3400d574:	2b04      	cmp	r3, #4
3400d576:	d86c      	bhi.n	3400d652 <LTDC_SetPredefFormat+0x11e>
3400d578:	a201      	add	r2, pc, #4	@ (adr r2, 3400d580 <LTDC_SetPredefFormat+0x4c>)
3400d57a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400d57e:	bf00      	nop
3400d580:	3400d595 	.word	0x3400d595
3400d584:	3400d5bb 	.word	0x3400d5bb
3400d588:	3400d5e1 	.word	0x3400d5e1
3400d58c:	3400d607 	.word	0x3400d607
3400d590:	3400d62d 	.word	0x3400d62d
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
3400d594:	2302      	movs	r3, #2
3400d596:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
3400d598:	2301      	movs	r3, #1
3400d59a:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
3400d59c:	230f      	movs	r3, #15
3400d59e:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
3400d5a0:	2305      	movs	r3, #5
3400d5a2:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
3400d5a4:	230a      	movs	r3, #10
3400d5a6:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
3400d5a8:	2305      	movs	r3, #5
3400d5aa:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
3400d5ac:	2305      	movs	r3, #5
3400d5ae:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
3400d5b0:	2305      	movs	r3, #5
3400d5b2:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400d5b4:	2300      	movs	r3, #0
3400d5b6:	617b      	str	r3, [r7, #20]
      break;
3400d5b8:	e04c      	b.n	3400d654 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
3400d5ba:	2302      	movs	r3, #2
3400d5bc:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3400d5be:	2304      	movs	r3, #4
3400d5c0:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
3400d5c2:	230c      	movs	r3, #12
3400d5c4:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3400d5c6:	2304      	movs	r3, #4
3400d5c8:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
3400d5ca:	2308      	movs	r3, #8
3400d5cc:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3400d5ce:	2304      	movs	r3, #4
3400d5d0:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
3400d5d2:	2304      	movs	r3, #4
3400d5d4:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3400d5d6:	2304      	movs	r3, #4
3400d5d8:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400d5da:	2300      	movs	r3, #0
3400d5dc:	617b      	str	r3, [r7, #20]
      break;
3400d5de:	e039      	b.n	3400d654 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
3400d5e0:	2301      	movs	r3, #1
3400d5e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
3400d5e4:	2300      	movs	r3, #0
3400d5e6:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
3400d5e8:	2300      	movs	r3, #0
3400d5ea:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3400d5ec:	2308      	movs	r3, #8
3400d5ee:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400d5f0:	2300      	movs	r3, #0
3400d5f2:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3400d5f4:	2308      	movs	r3, #8
3400d5f6:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400d5f8:	2300      	movs	r3, #0
3400d5fa:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3400d5fc:	2308      	movs	r3, #8
3400d5fe:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400d600:	2300      	movs	r3, #0
3400d602:	617b      	str	r3, [r7, #20]
      break;
3400d604:	e026      	b.n	3400d654 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
3400d606:	2301      	movs	r3, #1
3400d608:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
3400d60a:	2304      	movs	r3, #4
3400d60c:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
3400d60e:	2304      	movs	r3, #4
3400d610:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
3400d612:	2304      	movs	r3, #4
3400d614:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400d616:	2300      	movs	r3, #0
3400d618:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
3400d61a:	2304      	movs	r3, #4
3400d61c:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400d61e:	2300      	movs	r3, #0
3400d620:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
3400d622:	2304      	movs	r3, #4
3400d624:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400d626:	2300      	movs	r3, #0
3400d628:	617b      	str	r3, [r7, #20]
      break;
3400d62a:	e013      	b.n	3400d654 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
3400d62c:	2302      	movs	r3, #2
3400d62e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
3400d630:	2308      	movs	r3, #8
3400d632:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
3400d634:	2308      	movs	r3, #8
3400d636:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
3400d638:	2308      	movs	r3, #8
3400d63a:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
3400d63c:	2300      	movs	r3, #0
3400d63e:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
3400d640:	2308      	movs	r3, #8
3400d642:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
3400d644:	2300      	movs	r3, #0
3400d646:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
3400d648:	2308      	movs	r3, #8
3400d64a:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
3400d64c:	2300      	movs	r3, #0
3400d64e:	617b      	str	r3, [r7, #20]
      break;
3400d650:	e000      	b.n	3400d654 <LTDC_SetPredefFormat+0x120>
    default:
      break;
3400d652:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400d654:	687a      	ldr	r2, [r7, #4]
3400d656:	683b      	ldr	r3, [r7, #0]
3400d658:	2134      	movs	r1, #52	@ 0x34
3400d65a:	fb01 f303 	mul.w	r3, r1, r3
3400d65e:	4413      	add	r3, r2
3400d660:	3348      	adds	r3, #72	@ 0x48
3400d662:	681b      	ldr	r3, [r3, #0]
3400d664:	2b06      	cmp	r3, #6
3400d666:	d903      	bls.n	3400d670 <LTDC_SetPredefFormat+0x13c>
3400d668:	3b07      	subs	r3, #7
3400d66a:	2b04      	cmp	r3, #4
3400d66c:	d860      	bhi.n	3400d730 <LTDC_SetPredefFormat+0x1fc>
3400d66e:	e028      	b.n	3400d6c2 <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
3400d670:	687b      	ldr	r3, [r7, #4]
3400d672:	681b      	ldr	r3, [r3, #0]
3400d674:	461a      	mov	r2, r3
3400d676:	683b      	ldr	r3, [r7, #0]
3400d678:	021b      	lsls	r3, r3, #8
3400d67a:	4413      	add	r3, r2
3400d67c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d680:	4618      	mov	r0, r3
3400d682:	687a      	ldr	r2, [r7, #4]
3400d684:	683b      	ldr	r3, [r7, #0]
3400d686:	2134      	movs	r1, #52	@ 0x34
3400d688:	fb01 f303 	mul.w	r3, r1, r3
3400d68c:	4413      	add	r3, r2
3400d68e:	3348      	adds	r3, #72	@ 0x48
3400d690:	681b      	ldr	r3, [r3, #0]
3400d692:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
3400d694:	687b      	ldr	r3, [r7, #4]
3400d696:	681b      	ldr	r3, [r3, #0]
3400d698:	461a      	mov	r2, r3
3400d69a:	683b      	ldr	r3, [r7, #0]
3400d69c:	021b      	lsls	r3, r3, #8
3400d69e:	4413      	add	r3, r2
3400d6a0:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d6a4:	461a      	mov	r2, r3
3400d6a6:	2300      	movs	r3, #0
3400d6a8:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
3400d6aa:	687b      	ldr	r3, [r7, #4]
3400d6ac:	681b      	ldr	r3, [r3, #0]
3400d6ae:	461a      	mov	r2, r3
3400d6b0:	683b      	ldr	r3, [r7, #0]
3400d6b2:	021b      	lsls	r3, r3, #8
3400d6b4:	4413      	add	r3, r2
3400d6b6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d6ba:	461a      	mov	r2, r3
3400d6bc:	2300      	movs	r3, #0
3400d6be:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
3400d6c0:	e037      	b.n	3400d732 <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
3400d6c2:	687b      	ldr	r3, [r7, #4]
3400d6c4:	681b      	ldr	r3, [r3, #0]
3400d6c6:	461a      	mov	r2, r3
3400d6c8:	683b      	ldr	r3, [r7, #0]
3400d6ca:	021b      	lsls	r3, r3, #8
3400d6cc:	4413      	add	r3, r2
3400d6ce:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d6d2:	461a      	mov	r2, r3
3400d6d4:	2307      	movs	r3, #7
3400d6d6:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400d6d8:	6a3b      	ldr	r3, [r7, #32]
3400d6da:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3400d6dc:	69fb      	ldr	r3, [r7, #28]
3400d6de:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400d6e0:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3400d6e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400d6e4:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
3400d6e6:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400d6e8:	687b      	ldr	r3, [r7, #4]
3400d6ea:	681b      	ldr	r3, [r3, #0]
3400d6ec:	4619      	mov	r1, r3
3400d6ee:	683b      	ldr	r3, [r7, #0]
3400d6f0:	021b      	lsls	r3, r3, #8
3400d6f2:	440b      	add	r3, r1
3400d6f4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d6f8:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
3400d6fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400d6fc:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
3400d6fe:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400d700:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400d702:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3400d704:	69bb      	ldr	r3, [r7, #24]
3400d706:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400d708:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3400d70a:	697b      	ldr	r3, [r7, #20]
3400d70c:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
3400d70e:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400d710:	693b      	ldr	r3, [r7, #16]
3400d712:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
3400d714:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400d716:	687b      	ldr	r3, [r7, #4]
3400d718:	681b      	ldr	r3, [r3, #0]
3400d71a:	4619      	mov	r1, r3
3400d71c:	683b      	ldr	r3, [r7, #0]
3400d71e:	021b      	lsls	r3, r3, #8
3400d720:	440b      	add	r3, r1
3400d722:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400d726:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
3400d728:	68fb      	ldr	r3, [r7, #12]
3400d72a:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
3400d72c:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
3400d72e:	e000      	b.n	3400d732 <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
3400d730:	bf00      	nop
  }
}
3400d732:	bf00      	nop
3400d734:	3734      	adds	r7, #52	@ 0x34
3400d736:	46bd      	mov	sp, r7
3400d738:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d73c:	4770      	bx	lr
3400d73e:	bf00      	nop

3400d740 <HAL_PWR_ConfigAttributes>:
  * @param  Attributes : Specifies the available attribute(s).
  *                      This parameter can be one of PWR_ATTRIBUTES.
  * @retval None.
  */
void HAL_PWR_ConfigAttributes(uint32_t Item, uint32_t Attributes)
{
3400d740:	b480      	push	{r7}
3400d742:	b083      	sub	sp, #12
3400d744:	af00      	add	r7, sp, #0
3400d746:	6078      	str	r0, [r7, #4]
3400d748:	6039      	str	r1, [r7, #0]
  assert_param(IS_PWR_ITEMS_ATTRIBUTES(Item));
  assert_param(IS_PWR_ATTRIBUTES(Attributes));

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Secure item management (TZEN = 1) */
  if ((Attributes & PWR_ITEM_ATTR_SEC_PRIV_MASK) == PWR_ITEM_ATTR_SEC_PRIV_MASK)
3400d74a:	683b      	ldr	r3, [r7, #0]
3400d74c:	f003 0320 	and.w	r3, r3, #32
3400d750:	2b00      	cmp	r3, #0
3400d752:	d01f      	beq.n	3400d794 <HAL_PWR_ConfigAttributes+0x54>
  {
    /* Privilege item management */
    if ((Attributes & PWR_SEC_PRIV) == PWR_SEC_PRIV)
3400d754:	683b      	ldr	r3, [r7, #0]
3400d756:	f003 0322 	and.w	r3, r3, #34	@ 0x22
3400d75a:	2b22      	cmp	r3, #34	@ 0x22
3400d75c:	d10c      	bne.n	3400d778 <HAL_PWR_ConfigAttributes+0x38>
    {
      SET_BIT(PWR_S->SECCFGR, Item);
3400d75e:	4b21      	ldr	r3, [pc, #132]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d760:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400d762:	4920      	ldr	r1, [pc, #128]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d764:	687b      	ldr	r3, [r7, #4]
3400d766:	4313      	orrs	r3, r2
3400d768:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3400d76a:	4b1e      	ldr	r3, [pc, #120]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d76c:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3400d76e:	491d      	ldr	r1, [pc, #116]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d770:	687b      	ldr	r3, [r7, #4]
3400d772:	4313      	orrs	r3, r2
3400d774:	674b      	str	r3, [r1, #116]	@ 0x74
    {
      CLEAR_BIT(PWR->PRIVCFGR, Item);
    }
  }
#endif /* __ARM_FEATURE_CMSE */
}
3400d776:	e02e      	b.n	3400d7d6 <HAL_PWR_ConfigAttributes+0x96>
      SET_BIT(PWR_S->SECCFGR, Item);
3400d778:	4b1a      	ldr	r3, [pc, #104]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d77a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400d77c:	4919      	ldr	r1, [pc, #100]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d77e:	687b      	ldr	r3, [r7, #4]
3400d780:	4313      	orrs	r3, r2
3400d782:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3400d784:	4b17      	ldr	r3, [pc, #92]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d786:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3400d788:	687b      	ldr	r3, [r7, #4]
3400d78a:	43db      	mvns	r3, r3
3400d78c:	4915      	ldr	r1, [pc, #84]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d78e:	4013      	ands	r3, r2
3400d790:	674b      	str	r3, [r1, #116]	@ 0x74
}
3400d792:	e020      	b.n	3400d7d6 <HAL_PWR_ConfigAttributes+0x96>
    if ((Attributes & PWR_NSEC_PRIV) == PWR_NSEC_PRIV)
3400d794:	683b      	ldr	r3, [r7, #0]
3400d796:	f003 0311 	and.w	r3, r3, #17
3400d79a:	2b11      	cmp	r3, #17
3400d79c:	d10d      	bne.n	3400d7ba <HAL_PWR_ConfigAttributes+0x7a>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3400d79e:	4b11      	ldr	r3, [pc, #68]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7a0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400d7a2:	687b      	ldr	r3, [r7, #4]
3400d7a4:	43db      	mvns	r3, r3
3400d7a6:	490f      	ldr	r1, [pc, #60]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7a8:	4013      	ands	r3, r2
3400d7aa:	670b      	str	r3, [r1, #112]	@ 0x70
      SET_BIT(PWR->PRIVCFGR, Item);
3400d7ac:	4b0d      	ldr	r3, [pc, #52]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7ae:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3400d7b0:	490c      	ldr	r1, [pc, #48]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7b2:	687b      	ldr	r3, [r7, #4]
3400d7b4:	4313      	orrs	r3, r2
3400d7b6:	674b      	str	r3, [r1, #116]	@ 0x74
}
3400d7b8:	e00d      	b.n	3400d7d6 <HAL_PWR_ConfigAttributes+0x96>
      CLEAR_BIT(PWR_S->SECCFGR, Item);
3400d7ba:	4b0a      	ldr	r3, [pc, #40]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7bc:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400d7be:	687b      	ldr	r3, [r7, #4]
3400d7c0:	43db      	mvns	r3, r3
3400d7c2:	4908      	ldr	r1, [pc, #32]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7c4:	4013      	ands	r3, r2
3400d7c6:	670b      	str	r3, [r1, #112]	@ 0x70
      CLEAR_BIT(PWR->PRIVCFGR, Item);
3400d7c8:	4b06      	ldr	r3, [pc, #24]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7ca:	6f5a      	ldr	r2, [r3, #116]	@ 0x74
3400d7cc:	687b      	ldr	r3, [r7, #4]
3400d7ce:	43db      	mvns	r3, r3
3400d7d0:	4904      	ldr	r1, [pc, #16]	@ (3400d7e4 <HAL_PWR_ConfigAttributes+0xa4>)
3400d7d2:	4013      	ands	r3, r2
3400d7d4:	674b      	str	r3, [r1, #116]	@ 0x74
}
3400d7d6:	bf00      	nop
3400d7d8:	370c      	adds	r7, #12
3400d7da:	46bd      	mov	sp, r7
3400d7dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d7e0:	4770      	bx	lr
3400d7e2:	bf00      	nop
3400d7e4:	56024800 	.word	0x56024800

3400d7e8 <HAL_PWREx_ConfigSupply>:
  * @note: The power supply configuration is not reset by wakeup from Standby mode and
  *        application reset, but only reset by VDD POR.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply(uint32_t SupplySource)
{
3400d7e8:	b580      	push	{r7, lr}
3400d7ea:	b084      	sub	sp, #16
3400d7ec:	af00      	add	r7, sp, #0
3400d7ee:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_PWR_SUPPLY(SupplySource));

  /* Set the power supply configuration */
  MODIFY_REG(PWR->CR1, PWR_SUPPLY_CONFIG_MASK, SupplySource);
3400d7f0:	4b10      	ldr	r3, [pc, #64]	@ (3400d834 <HAL_PWREx_ConfigSupply+0x4c>)
3400d7f2:	681b      	ldr	r3, [r3, #0]
3400d7f4:	f023 0204 	bic.w	r2, r3, #4
3400d7f8:	490e      	ldr	r1, [pc, #56]	@ (3400d834 <HAL_PWREx_ConfigSupply+0x4c>)
3400d7fa:	687b      	ldr	r3, [r7, #4]
3400d7fc:	4313      	orrs	r3, r2
3400d7fe:	600b      	str	r3, [r1, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
3400d800:	f7f7 fa15 	bl	34004c2e <HAL_GetTick>
3400d804:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3400d806:	e009      	b.n	3400d81c <HAL_PWREx_ConfigSupply+0x34>
  {
    if ((HAL_GetTick() - tickstart) > PWR_FLAG_SETTING_DELAY)
3400d808:	f7f7 fa11 	bl	34004c2e <HAL_GetTick>
3400d80c:	4602      	mov	r2, r0
3400d80e:	68fb      	ldr	r3, [r7, #12]
3400d810:	1ad3      	subs	r3, r2, r3
3400d812:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
3400d816:	d901      	bls.n	3400d81c <HAL_PWREx_ConfigSupply+0x34>
    {
      return HAL_ERROR;
3400d818:	2301      	movs	r3, #1
3400d81a:	e006      	b.n	3400d82a <HAL_PWREx_ConfigSupply+0x42>
  while ((PWR->VOSCR & PWR_VOSCR_ACTVOSRDY) == 0U)
3400d81c:	4b05      	ldr	r3, [pc, #20]	@ (3400d834 <HAL_PWREx_ConfigSupply+0x4c>)
3400d81e:	6a1b      	ldr	r3, [r3, #32]
3400d820:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400d824:	2b00      	cmp	r3, #0
3400d826:	d0ef      	beq.n	3400d808 <HAL_PWREx_ConfigSupply+0x20>
    }
  }

  return HAL_OK;
3400d828:	2300      	movs	r3, #0
}
3400d82a:	4618      	mov	r0, r3
3400d82c:	3710      	adds	r7, #16
3400d82e:	46bd      	mov	sp, r7
3400d830:	bd80      	pop	{r7, pc}
3400d832:	bf00      	nop
3400d834:	56024800 	.word	0x56024800

3400d838 <HAL_PWREx_ConfigVddIORange>:
  * @note   Setting this configuration while VDDIOx is in 3v3 range
  *         damages the device.
  * @retval None.
  */
void HAL_PWREx_ConfigVddIORange(uint32_t VddIOPort, uint32_t VoltageRange)
{
3400d838:	b480      	push	{r7}
3400d83a:	b083      	sub	sp, #12
3400d83c:	af00      	add	r7, sp, #0
3400d83e:	6078      	str	r0, [r7, #4]
3400d840:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_PWR_VDDIO(VddIOPort));
  assert_param(IS_PWR_VDDIO_RANGE(VoltageRange));

  switch (VddIOPort)
3400d842:	687b      	ldr	r3, [r7, #4]
3400d844:	2b04      	cmp	r3, #4
3400d846:	d83f      	bhi.n	3400d8c8 <HAL_PWREx_ConfigVddIORange+0x90>
3400d848:	a201      	add	r2, pc, #4	@ (adr r2, 3400d850 <HAL_PWREx_ConfigVddIORange+0x18>)
3400d84a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400d84e:	bf00      	nop
3400d850:	3400d865 	.word	0x3400d865
3400d854:	3400d879 	.word	0x3400d879
3400d858:	3400d88d 	.word	0x3400d88d
3400d85c:	3400d8a1 	.word	0x3400d8a1
3400d860:	3400d8b5 	.word	0x3400d8b5
  {
    case PWR_VDDIO:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIOVRSEL, VoltageRange << PWR_SVMCR3_VDDIOVRSEL_Pos);
3400d864:	4b1c      	ldr	r3, [pc, #112]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d866:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d868:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400d86c:	683b      	ldr	r3, [r7, #0]
3400d86e:	061b      	lsls	r3, r3, #24
3400d870:	4919      	ldr	r1, [pc, #100]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d872:	4313      	orrs	r3, r2
3400d874:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400d876:	e028      	b.n	3400d8ca <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO2:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO2VRSEL, VoltageRange << PWR_SVMCR3_VDDIO2VRSEL_Pos);
3400d878:	4b17      	ldr	r3, [pc, #92]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d87a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d87c:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
3400d880:	683b      	ldr	r3, [r7, #0]
3400d882:	065b      	lsls	r3, r3, #25
3400d884:	4914      	ldr	r1, [pc, #80]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d886:	4313      	orrs	r3, r2
3400d888:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400d88a:	e01e      	b.n	3400d8ca <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO3:
      MODIFY_REG(PWR->SVMCR3, PWR_SVMCR3_VDDIO3VRSEL, VoltageRange << PWR_SVMCR3_VDDIO3VRSEL_Pos);
3400d88c:	4b12      	ldr	r3, [pc, #72]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d88e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d890:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
3400d894:	683b      	ldr	r3, [r7, #0]
3400d896:	069b      	lsls	r3, r3, #26
3400d898:	490f      	ldr	r1, [pc, #60]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d89a:	4313      	orrs	r3, r2
3400d89c:	63cb      	str	r3, [r1, #60]	@ 0x3c
      break;
3400d89e:	e014      	b.n	3400d8ca <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO4:
      MODIFY_REG(PWR->SVMCR1, PWR_SVMCR1_VDDIO4VRSEL, VoltageRange << PWR_SVMCR1_VDDIO4VRSEL_Pos);
3400d8a0:	4b0d      	ldr	r3, [pc, #52]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d8a2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400d8a4:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400d8a8:	683b      	ldr	r3, [r7, #0]
3400d8aa:	061b      	lsls	r3, r3, #24
3400d8ac:	490a      	ldr	r1, [pc, #40]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d8ae:	4313      	orrs	r3, r2
3400d8b0:	634b      	str	r3, [r1, #52]	@ 0x34
      break;
3400d8b2:	e00a      	b.n	3400d8ca <HAL_PWREx_ConfigVddIORange+0x92>

    case PWR_VDDIO5:
      MODIFY_REG(PWR->SVMCR2, PWR_SVMCR2_VDDIO5VRSEL, VoltageRange << PWR_SVMCR2_VDDIO5VRSEL_Pos);
3400d8b4:	4b08      	ldr	r3, [pc, #32]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d8b6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400d8b8:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400d8bc:	683b      	ldr	r3, [r7, #0]
3400d8be:	061b      	lsls	r3, r3, #24
3400d8c0:	4905      	ldr	r1, [pc, #20]	@ (3400d8d8 <HAL_PWREx_ConfigVddIORange+0xa0>)
3400d8c2:	4313      	orrs	r3, r2
3400d8c4:	638b      	str	r3, [r1, #56]	@ 0x38
      break;
3400d8c6:	e000      	b.n	3400d8ca <HAL_PWREx_ConfigVddIORange+0x92>

    default:
      break;
3400d8c8:	bf00      	nop
  }
}
3400d8ca:	bf00      	nop
3400d8cc:	370c      	adds	r7, #12
3400d8ce:	46bd      	mov	sp, r7
3400d8d0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8d4:	4770      	bx	lr
3400d8d6:	bf00      	nop
3400d8d8:	56024800 	.word	0x56024800

3400d8dc <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
3400d8dc:	b480      	push	{r7}
3400d8de:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
3400d8e0:	4b05      	ldr	r3, [pc, #20]	@ (3400d8f8 <HAL_PWREx_EnableVddIO2+0x1c>)
3400d8e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d8e4:	4a04      	ldr	r2, [pc, #16]	@ (3400d8f8 <HAL_PWREx_EnableVddIO2+0x1c>)
3400d8e6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400d8ea:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400d8ec:	bf00      	nop
3400d8ee:	46bd      	mov	sp, r7
3400d8f0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8f4:	4770      	bx	lr
3400d8f6:	bf00      	nop
3400d8f8:	56024800 	.word	0x56024800

3400d8fc <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
3400d8fc:	b480      	push	{r7}
3400d8fe:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
3400d900:	4b05      	ldr	r3, [pc, #20]	@ (3400d918 <HAL_PWREx_EnableVddIO3+0x1c>)
3400d902:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400d904:	4a04      	ldr	r2, [pc, #16]	@ (3400d918 <HAL_PWREx_EnableVddIO3+0x1c>)
3400d906:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400d90a:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
3400d90c:	bf00      	nop
3400d90e:	46bd      	mov	sp, r7
3400d910:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d914:	4770      	bx	lr
3400d916:	bf00      	nop
3400d918:	56024800 	.word	0x56024800

3400d91c <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
3400d91c:	b480      	push	{r7}
3400d91e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
3400d920:	4b05      	ldr	r3, [pc, #20]	@ (3400d938 <HAL_PWREx_EnableVddIO4+0x1c>)
3400d922:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400d924:	4a04      	ldr	r2, [pc, #16]	@ (3400d938 <HAL_PWREx_EnableVddIO4+0x1c>)
3400d926:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400d92a:	6353      	str	r3, [r2, #52]	@ 0x34
}
3400d92c:	bf00      	nop
3400d92e:	46bd      	mov	sp, r7
3400d930:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d934:	4770      	bx	lr
3400d936:	bf00      	nop
3400d938:	56024800 	.word	0x56024800

3400d93c <HAL_RAMCFG_Init>:
  *                   the configuration information for the specified RAMCFG
  *                   instance.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_RAMCFG_Init(RAMCFG_HandleTypeDef *hramcfg)
{
3400d93c:	b580      	push	{r7, lr}
3400d93e:	b082      	sub	sp, #8
3400d940:	af00      	add	r7, sp, #0
3400d942:	6078      	str	r0, [r7, #4]
  /* Check the RAMCFG peripheral handle */
  if (hramcfg == NULL)
3400d944:	687b      	ldr	r3, [r7, #4]
3400d946:	2b00      	cmp	r3, #0
3400d948:	d101      	bne.n	3400d94e <HAL_RAMCFG_Init+0x12>
  {
    return HAL_ERROR;
3400d94a:	2301      	movs	r3, #1
3400d94c:	e026      	b.n	3400d99c <HAL_RAMCFG_Init+0x60>

  /* Check the parameters */
  assert_param(IS_RAMCFG_ALL_INSTANCE(hramcfg->Instance));

  /* Update RAMCFG peripheral state */
  hramcfg->State = HAL_RAMCFG_STATE_BUSY;
3400d94e:	687b      	ldr	r3, [r7, #4]
3400d950:	2202      	movs	r2, #2
3400d952:	711a      	strb	r2, [r3, #4]
  }

  /* Init the low level hardware */
  hramcfg->MspInitCallback(hramcfg);
#else
  HAL_RAMCFG_MspInit(hramcfg);
3400d954:	6878      	ldr	r0, [r7, #4]
3400d956:	f7f6 ffdb 	bl	34004910 <HAL_RAMCFG_MspInit>
#endif /* USE_HAL_RAMCFG_REGISTER_CALLBACKS */

  /* Disable the ECC Address latch */
  hramcfg->Instance->CR &= ~(RAMCFG_CR_ALE);
3400d95a:	687b      	ldr	r3, [r7, #4]
3400d95c:	681b      	ldr	r3, [r3, #0]
3400d95e:	681a      	ldr	r2, [r3, #0]
3400d960:	687b      	ldr	r3, [r7, #4]
3400d962:	681b      	ldr	r3, [r3, #0]
3400d964:	f022 0210 	bic.w	r2, r2, #16
3400d968:	601a      	str	r2, [r3, #0]

  /* Disable all RAMCFG interrupts */
  __HAL_RAMCFG_DISABLE_IT(hramcfg, RAMCFG_IT_ALL);
3400d96a:	687b      	ldr	r3, [r7, #4]
3400d96c:	681b      	ldr	r3, [r3, #0]
3400d96e:	685a      	ldr	r2, [r3, #4]
3400d970:	687b      	ldr	r3, [r7, #4]
3400d972:	681b      	ldr	r3, [r3, #0]
3400d974:	f022 0203 	bic.w	r2, r2, #3
3400d978:	605a      	str	r2, [r3, #4]

  /* Clear RAMCFG monitor flags */
  __HAL_RAMCFG_CLEAR_FLAG(hramcfg, RAMCFG_FLAGS_ALL);
3400d97a:	687b      	ldr	r3, [r7, #4]
3400d97c:	681b      	ldr	r3, [r3, #0]
3400d97e:	695b      	ldr	r3, [r3, #20]
3400d980:	687a      	ldr	r2, [r7, #4]
3400d982:	6812      	ldr	r2, [r2, #0]
3400d984:	f443 7381 	orr.w	r3, r3, #258	@ 0x102
3400d988:	f043 0301 	orr.w	r3, r3, #1
3400d98c:	6153      	str	r3, [r2, #20]

  /* Initialize the RAMCFG error code */
  hramcfg->ErrorCode = HAL_RAMCFG_ERROR_NONE;
3400d98e:	687b      	ldr	r3, [r7, #4]
3400d990:	2200      	movs	r2, #0
3400d992:	609a      	str	r2, [r3, #8]

  /* Initialize the RAMCFG state */
  hramcfg->State = HAL_RAMCFG_STATE_READY;
3400d994:	687b      	ldr	r3, [r7, #4]
3400d996:	2201      	movs	r2, #1
3400d998:	711a      	strb	r2, [r3, #4]

  return HAL_OK;
3400d99a:	2300      	movs	r3, #0
}
3400d99c:	4618      	mov	r0, r3
3400d99e:	3708      	adds	r7, #8
3400d9a0:	46bd      	mov	sp, r7
3400d9a2:	bd80      	pop	{r7, pc}

3400d9a4 <HAL_RAMCFG_EnableAXISRAM>:
  *                   contains the configuration information for the
  *                   specified RAMCFG instance.
  * @retval None.
  */
void HAL_RAMCFG_EnableAXISRAM(const RAMCFG_HandleTypeDef *hramcfg)
{
3400d9a4:	b480      	push	{r7}
3400d9a6:	b083      	sub	sp, #12
3400d9a8:	af00      	add	r7, sp, #0
3400d9aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RAMCFG_AXISRAM_POWERDOWN_INSTANCE(hramcfg->Instance));

  /* AXISRAMi power on */
  CLEAR_BIT(hramcfg->Instance->CR, RAMCFG_AXISRAM_POWERDOWN);
3400d9ac:	687b      	ldr	r3, [r7, #4]
3400d9ae:	681b      	ldr	r3, [r3, #0]
3400d9b0:	681a      	ldr	r2, [r3, #0]
3400d9b2:	687b      	ldr	r3, [r7, #4]
3400d9b4:	681b      	ldr	r3, [r3, #0]
3400d9b6:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
3400d9ba:	601a      	str	r2, [r3, #0]
}
3400d9bc:	bf00      	nop
3400d9be:	370c      	adds	r7, #12
3400d9c0:	46bd      	mov	sp, r7
3400d9c2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d9c6:	4770      	bx	lr

3400d9c8 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll SR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
3400d9c8:	b480      	push	{r7}
3400d9ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400d9cc:	4b06      	ldr	r3, [pc, #24]	@ (3400d9e8 <LL_RCC_HSE_IsReady+0x20>)
3400d9ce:	685b      	ldr	r3, [r3, #4]
3400d9d0:	f003 0310 	and.w	r3, r3, #16
3400d9d4:	2b00      	cmp	r3, #0
3400d9d6:	d001      	beq.n	3400d9dc <LL_RCC_HSE_IsReady+0x14>
3400d9d8:	2301      	movs	r3, #1
3400d9da:	e000      	b.n	3400d9de <LL_RCC_HSE_IsReady+0x16>
3400d9dc:	2300      	movs	r3, #0
}
3400d9de:	4618      	mov	r0, r3
3400d9e0:	46bd      	mov	sp, r7
3400d9e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d9e6:	4770      	bx	lr
3400d9e8:	56028000 	.word	0x56028000

3400d9ec <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI oscillator
  * @rmtoll CSR          HSIONS        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
3400d9ec:	b480      	push	{r7}
3400d9ee:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_HSIONS);
3400d9f0:	4b04      	ldr	r3, [pc, #16]	@ (3400da04 <LL_RCC_HSI_Enable+0x18>)
3400d9f2:	2208      	movs	r2, #8
3400d9f4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400d9f8:	bf00      	nop
3400d9fa:	46bd      	mov	sp, r7
3400d9fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da00:	4770      	bx	lr
3400da02:	bf00      	nop
3400da04:	56028000 	.word	0x56028000

3400da08 <LL_RCC_HSI_Disable>:
  * @brief  Disable HSI oscillator
  * @rmtoll CCR          HSIONC        LL_RCC_HSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Disable(void)
{
3400da08:	b480      	push	{r7}
3400da0a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_HSIONC);
3400da0c:	4b05      	ldr	r3, [pc, #20]	@ (3400da24 <LL_RCC_HSI_Disable+0x1c>)
3400da0e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400da12:	461a      	mov	r2, r3
3400da14:	2308      	movs	r3, #8
3400da16:	6013      	str	r3, [r2, #0]
}
3400da18:	bf00      	nop
3400da1a:	46bd      	mov	sp, r7
3400da1c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da20:	4770      	bx	lr
3400da22:	bf00      	nop
3400da24:	56028000 	.word	0x56028000

3400da28 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll SR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
3400da28:	b480      	push	{r7}
3400da2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400da2c:	4b06      	ldr	r3, [pc, #24]	@ (3400da48 <LL_RCC_HSI_IsReady+0x20>)
3400da2e:	685b      	ldr	r3, [r3, #4]
3400da30:	f003 0308 	and.w	r3, r3, #8
3400da34:	2b00      	cmp	r3, #0
3400da36:	d001      	beq.n	3400da3c <LL_RCC_HSI_IsReady+0x14>
3400da38:	2301      	movs	r3, #1
3400da3a:	e000      	b.n	3400da3e <LL_RCC_HSI_IsReady+0x16>
3400da3c:	2300      	movs	r3, #0
}
3400da3e:	4618      	mov	r0, r3
3400da40:	46bd      	mov	sp, r7
3400da42:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da46:	4770      	bx	lr
3400da48:	56028000 	.word	0x56028000

3400da4c <LL_RCC_HSI_SetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_HSI_SetDivider(uint32_t Divider)
{
3400da4c:	b480      	push	{r7}
3400da4e:	b083      	sub	sp, #12
3400da50:	af00      	add	r7, sp, #0
3400da52:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSIDIV, Divider);
3400da54:	4b06      	ldr	r3, [pc, #24]	@ (3400da70 <LL_RCC_HSI_SetDivider+0x24>)
3400da56:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400da58:	f423 72c0 	bic.w	r2, r3, #384	@ 0x180
3400da5c:	4904      	ldr	r1, [pc, #16]	@ (3400da70 <LL_RCC_HSI_SetDivider+0x24>)
3400da5e:	687b      	ldr	r3, [r7, #4]
3400da60:	4313      	orrs	r3, r2
3400da62:	648b      	str	r3, [r1, #72]	@ 0x48
}
3400da64:	bf00      	nop
3400da66:	370c      	adds	r7, #12
3400da68:	46bd      	mov	sp, r7
3400da6a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da6e:	4770      	bx	lr
3400da70:	56028000 	.word	0x56028000

3400da74 <LL_RCC_HSI_GetDivider>:
  *         @arg @ref LL_RCC_HSI_DIV_2
  *         @arg @ref LL_RCC_HSI_DIV_4
  *         @arg @ref LL_RCC_HSI_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_GetDivider(void)
{
3400da74:	b480      	push	{r7}
3400da76:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400da78:	4b04      	ldr	r3, [pc, #16]	@ (3400da8c <LL_RCC_HSI_GetDivider+0x18>)
3400da7a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400da7c:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3400da80:	4618      	mov	r0, r3
3400da82:	46bd      	mov	sp, r7
3400da84:	f85d 7b04 	ldr.w	r7, [sp], #4
3400da88:	4770      	bx	lr
3400da8a:	bf00      	nop
3400da8c:	56028000 	.word	0x56028000

3400da90 <LL_RCC_HSI_SetCalibTrimming>:
  * @rmtoll HSICFGR      HSITRIM       LL_RCC_HSI_SetCalibTrimming
  * @param  Value This parameter can be a value between 0 and 63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_SetCalibTrimming(uint32_t Value)
{
3400da90:	b480      	push	{r7}
3400da92:	b083      	sub	sp, #12
3400da94:	af00      	add	r7, sp, #0
3400da96:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->HSICFGR, RCC_HSICFGR_HSITRIM, Value << RCC_HSICFGR_HSITRIM_Pos);
3400da98:	4b07      	ldr	r3, [pc, #28]	@ (3400dab8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3400da9a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400da9c:	f423 02fe 	bic.w	r2, r3, #8323072	@ 0x7f0000
3400daa0:	687b      	ldr	r3, [r7, #4]
3400daa2:	041b      	lsls	r3, r3, #16
3400daa4:	4904      	ldr	r1, [pc, #16]	@ (3400dab8 <LL_RCC_HSI_SetCalibTrimming+0x28>)
3400daa6:	4313      	orrs	r3, r2
3400daa8:	648b      	str	r3, [r1, #72]	@ 0x48
}
3400daaa:	bf00      	nop
3400daac:	370c      	adds	r7, #12
3400daae:	46bd      	mov	sp, r7
3400dab0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dab4:	4770      	bx	lr
3400dab6:	bf00      	nop
3400dab8:	56028000 	.word	0x56028000

3400dabc <LL_RCC_MSI_Enable>:
  * @brief  Enable MSI oscillator
  * @rmtoll CSR          MSIONS        LL_RCC_MSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Enable(void)
{
3400dabc:	b480      	push	{r7}
3400dabe:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_MSIONS);
3400dac0:	4b04      	ldr	r3, [pc, #16]	@ (3400dad4 <LL_RCC_MSI_Enable+0x18>)
3400dac2:	2204      	movs	r2, #4
3400dac4:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400dac8:	bf00      	nop
3400daca:	46bd      	mov	sp, r7
3400dacc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dad0:	4770      	bx	lr
3400dad2:	bf00      	nop
3400dad4:	56028000 	.word	0x56028000

3400dad8 <LL_RCC_MSI_Disable>:
  * @brief  Disable MSI oscillator
  * @rmtoll CCR          MSIONC        LL_RCC_MSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_Disable(void)
{
3400dad8:	b480      	push	{r7}
3400dada:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_MSIONC);
3400dadc:	4b05      	ldr	r3, [pc, #20]	@ (3400daf4 <LL_RCC_MSI_Disable+0x1c>)
3400dade:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400dae2:	461a      	mov	r2, r3
3400dae4:	2304      	movs	r3, #4
3400dae6:	6013      	str	r3, [r2, #0]
}
3400dae8:	bf00      	nop
3400daea:	46bd      	mov	sp, r7
3400daec:	f85d 7b04 	ldr.w	r7, [sp], #4
3400daf0:	4770      	bx	lr
3400daf2:	bf00      	nop
3400daf4:	56028000 	.word	0x56028000

3400daf8 <LL_RCC_MSI_IsReady>:
  * @brief  Check if MSI clock is ready
  * @rmtoll SR           MSIRDY        LL_RCC_MSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsReady(void)
{
3400daf8:	b480      	push	{r7}
3400dafa:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400dafc:	4b06      	ldr	r3, [pc, #24]	@ (3400db18 <LL_RCC_MSI_IsReady+0x20>)
3400dafe:	685b      	ldr	r3, [r3, #4]
3400db00:	f003 0304 	and.w	r3, r3, #4
3400db04:	2b00      	cmp	r3, #0
3400db06:	d001      	beq.n	3400db0c <LL_RCC_MSI_IsReady+0x14>
3400db08:	2301      	movs	r3, #1
3400db0a:	e000      	b.n	3400db0e <LL_RCC_MSI_IsReady+0x16>
3400db0c:	2300      	movs	r3, #0
}
3400db0e:	4618      	mov	r0, r3
3400db10:	46bd      	mov	sp, r7
3400db12:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db16:	4770      	bx	lr
3400db18:	56028000 	.word	0x56028000

3400db1c <LL_RCC_MSI_SetFrequency>:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  * @retval None.
  */
__STATIC_INLINE void LL_RCC_MSI_SetFrequency(uint32_t Value)
{
3400db1c:	b480      	push	{r7}
3400db1e:	b083      	sub	sp, #12
3400db20:	af00      	add	r7, sp, #0
3400db22:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL, Value);
3400db24:	4b06      	ldr	r3, [pc, #24]	@ (3400db40 <LL_RCC_MSI_SetFrequency+0x24>)
3400db26:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400db28:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
3400db2c:	4904      	ldr	r1, [pc, #16]	@ (3400db40 <LL_RCC_MSI_SetFrequency+0x24>)
3400db2e:	687b      	ldr	r3, [r7, #4]
3400db30:	4313      	orrs	r3, r2
3400db32:	644b      	str	r3, [r1, #68]	@ 0x44
}
3400db34:	bf00      	nop
3400db36:	370c      	adds	r7, #12
3400db38:	46bd      	mov	sp, r7
3400db3a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db3e:	4770      	bx	lr
3400db40:	56028000 	.word	0x56028000

3400db44 <LL_RCC_MSI_GetFrequency>:
  * @retval can be one of the following values:
  *         @arg @ref LL_RCC_MSI_FREQ_4MHZ
  *         @arg @ref LL_RCC_MSI_FREQ_16MHZ
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetFrequency(void)
{
3400db44:	b480      	push	{r7}
3400db46:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400db48:	4b04      	ldr	r3, [pc, #16]	@ (3400db5c <LL_RCC_MSI_GetFrequency+0x18>)
3400db4a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400db4c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3400db50:	4618      	mov	r0, r3
3400db52:	46bd      	mov	sp, r7
3400db54:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db58:	4770      	bx	lr
3400db5a:	bf00      	nop
3400db5c:	56028000 	.word	0x56028000

3400db60 <LL_RCC_MSI_SetCalibTrimming>:
  * @rmtoll MSICFGR      MSITRIM       LL_RCC_MSI_SetCalibTrimming
  * @param  Value can be a value between 0 and 31
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetCalibTrimming(uint32_t Value)
{
3400db60:	b480      	push	{r7}
3400db62:	b083      	sub	sp, #12
3400db64:	af00      	add	r7, sp, #0
3400db66:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->MSICFGR, RCC_MSICFGR_MSITRIM, Value << RCC_MSICFGR_MSITRIM_Pos);
3400db68:	4b07      	ldr	r3, [pc, #28]	@ (3400db88 <LL_RCC_MSI_SetCalibTrimming+0x28>)
3400db6a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400db6c:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
3400db70:	687b      	ldr	r3, [r7, #4]
3400db72:	041b      	lsls	r3, r3, #16
3400db74:	4904      	ldr	r1, [pc, #16]	@ (3400db88 <LL_RCC_MSI_SetCalibTrimming+0x28>)
3400db76:	4313      	orrs	r3, r2
3400db78:	644b      	str	r3, [r1, #68]	@ 0x44
}
3400db7a:	bf00      	nop
3400db7c:	370c      	adds	r7, #12
3400db7e:	46bd      	mov	sp, r7
3400db80:	f85d 7b04 	ldr.w	r7, [sp], #4
3400db84:	4770      	bx	lr
3400db86:	bf00      	nop
3400db88:	56028000 	.word	0x56028000

3400db8c <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
3400db8c:	b480      	push	{r7}
3400db8e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400db90:	4b06      	ldr	r3, [pc, #24]	@ (3400dbac <LL_RCC_LSE_IsReady+0x20>)
3400db92:	685b      	ldr	r3, [r3, #4]
3400db94:	f003 0302 	and.w	r3, r3, #2
3400db98:	2b00      	cmp	r3, #0
3400db9a:	d001      	beq.n	3400dba0 <LL_RCC_LSE_IsReady+0x14>
3400db9c:	2301      	movs	r3, #1
3400db9e:	e000      	b.n	3400dba2 <LL_RCC_LSE_IsReady+0x16>
3400dba0:	2300      	movs	r3, #0
}
3400dba2:	4618      	mov	r0, r3
3400dba4:	46bd      	mov	sp, r7
3400dba6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbaa:	4770      	bx	lr
3400dbac:	56028000 	.word	0x56028000

3400dbb0 <LL_RCC_LSI_Enable>:
  * @brief  Enable LSI Oscillator
  * @rmtoll CSR          LSIONS        LL_RCC_LSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Enable(void)
{
3400dbb0:	b480      	push	{r7}
3400dbb2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CSR, RCC_CSR_LSIONS);
3400dbb4:	4b04      	ldr	r3, [pc, #16]	@ (3400dbc8 <LL_RCC_LSI_Enable+0x18>)
3400dbb6:	2201      	movs	r2, #1
3400dbb8:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
}
3400dbbc:	bf00      	nop
3400dbbe:	46bd      	mov	sp, r7
3400dbc0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbc4:	4770      	bx	lr
3400dbc6:	bf00      	nop
3400dbc8:	56028000 	.word	0x56028000

3400dbcc <LL_RCC_LSI_Disable>:
  * @brief  Disable LSI Oscillator
  * @rmtoll CCR          LSIONC        LL_RCC_LSI_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSI_Disable(void)
{
3400dbcc:	b480      	push	{r7}
3400dbce:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->CCR, RCC_CCR_LSIONC);
3400dbd0:	4b05      	ldr	r3, [pc, #20]	@ (3400dbe8 <LL_RCC_LSI_Disable+0x1c>)
3400dbd2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400dbd6:	461a      	mov	r2, r3
3400dbd8:	2301      	movs	r3, #1
3400dbda:	6013      	str	r3, [r2, #0]
}
3400dbdc:	bf00      	nop
3400dbde:	46bd      	mov	sp, r7
3400dbe0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dbe4:	4770      	bx	lr
3400dbe6:	bf00      	nop
3400dbe8:	56028000 	.word	0x56028000

3400dbec <LL_RCC_LSI_IsReady>:
  * @brief  Check if LSI is Ready
  * @rmtoll SR           LSIRDY        LL_RCC_LSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSI_IsReady(void)
{
3400dbec:	b480      	push	{r7}
3400dbee:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400dbf0:	4b04      	ldr	r3, [pc, #16]	@ (3400dc04 <LL_RCC_LSI_IsReady+0x18>)
3400dbf2:	685b      	ldr	r3, [r3, #4]
3400dbf4:	f003 0301 	and.w	r3, r3, #1
}
3400dbf8:	4618      	mov	r0, r3
3400dbfa:	46bd      	mov	sp, r7
3400dbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc00:	4770      	bx	lr
3400dc02:	bf00      	nop
3400dc04:	56028000 	.word	0x56028000

3400dc08 <LL_RCC_GetCpuClkSource>:
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_CPU_CLKSOURCE_STATUS_IC1
  */
__STATIC_INLINE uint32_t LL_RCC_GetCpuClkSource(void)
{
3400dc08:	b480      	push	{r7}
3400dc0a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_CPUSWS));
3400dc0c:	4b04      	ldr	r3, [pc, #16]	@ (3400dc20 <LL_RCC_GetCpuClkSource+0x18>)
3400dc0e:	6a1b      	ldr	r3, [r3, #32]
3400dc10:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3400dc14:	4618      	mov	r0, r3
3400dc16:	46bd      	mov	sp, r7
3400dc18:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc1c:	4770      	bx	lr
3400dc1e:	bf00      	nop
3400dc20:	56028000 	.word	0x56028000

3400dc24 <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_MSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_IC2_IC6_IC11
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
3400dc24:	b480      	push	{r7}
3400dc26:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR1, RCC_CFGR1_SYSSWS));
3400dc28:	4b04      	ldr	r3, [pc, #16]	@ (3400dc3c <LL_RCC_GetSysClkSource+0x18>)
3400dc2a:	6a1b      	ldr	r3, [r3, #32]
3400dc2c:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400dc30:	4618      	mov	r0, r3
3400dc32:	46bd      	mov	sp, r7
3400dc34:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc38:	4770      	bx	lr
3400dc3a:	bf00      	nop
3400dc3c:	56028000 	.word	0x56028000

3400dc40 <LL_RCC_PLL1_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_GetSource(void)
{
3400dc40:	b480      	push	{r7}
3400dc42:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400dc44:	4b04      	ldr	r3, [pc, #16]	@ (3400dc58 <LL_RCC_PLL1_GetSource+0x18>)
3400dc46:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc4a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dc4e:	4618      	mov	r0, r3
3400dc50:	46bd      	mov	sp, r7
3400dc52:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc56:	4770      	bx	lr
3400dc58:	56028000 	.word	0x56028000

3400dc5c <LL_RCC_PLL1_IsReady>:
  * @brief  Check if PLL1 Ready
  * @rmtoll SR           PLL1RDY         LL_RCC_PLL1_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsReady(void)
{
3400dc5c:	b480      	push	{r7}
3400dc5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400dc60:	4b07      	ldr	r3, [pc, #28]	@ (3400dc80 <LL_RCC_PLL1_IsReady+0x24>)
3400dc62:	685b      	ldr	r3, [r3, #4]
3400dc64:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400dc68:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400dc6c:	d101      	bne.n	3400dc72 <LL_RCC_PLL1_IsReady+0x16>
3400dc6e:	2301      	movs	r3, #1
3400dc70:	e000      	b.n	3400dc74 <LL_RCC_PLL1_IsReady+0x18>
3400dc72:	2300      	movs	r3, #0
}
3400dc74:	4618      	mov	r0, r3
3400dc76:	46bd      	mov	sp, r7
3400dc78:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dc7c:	4770      	bx	lr
3400dc7e:	bf00      	nop
3400dc80:	56028000 	.word	0x56028000

3400dc84 <LL_RCC_PLL1_IsEnabledBypass>:
  * @brief  Check if PLL1 bypass is enabled
  * @rmtoll PLL1CFGR1    PLL1BYP         LL_RCC_PLL1_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL1_IsEnabledBypass(void)
{
3400dc84:	b480      	push	{r7}
3400dc86:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400dc88:	4b07      	ldr	r3, [pc, #28]	@ (3400dca8 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3400dc8a:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400dc8e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dc92:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dc96:	d101      	bne.n	3400dc9c <LL_RCC_PLL1_IsEnabledBypass+0x18>
3400dc98:	2301      	movs	r3, #1
3400dc9a:	e000      	b.n	3400dc9e <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3400dc9c:	2300      	movs	r3, #0
}
3400dc9e:	4618      	mov	r0, r3
3400dca0:	46bd      	mov	sp, r7
3400dca2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dca6:	4770      	bx	lr
3400dca8:	56028000 	.word	0x56028000

3400dcac <LL_RCC_PLL2_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_GetSource(void)
{
3400dcac:	b480      	push	{r7}
3400dcae:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400dcb0:	4b04      	ldr	r3, [pc, #16]	@ (3400dcc4 <LL_RCC_PLL2_GetSource+0x18>)
3400dcb2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400dcb6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dcba:	4618      	mov	r0, r3
3400dcbc:	46bd      	mov	sp, r7
3400dcbe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dcc2:	4770      	bx	lr
3400dcc4:	56028000 	.word	0x56028000

3400dcc8 <LL_RCC_PLL2_IsReady>:
  * @brief  Check if PLL2 Ready
  * @rmtoll SR           PLL2RDY         LL_RCC_PLL2_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsReady(void)
{
3400dcc8:	b480      	push	{r7}
3400dcca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400dccc:	4b07      	ldr	r3, [pc, #28]	@ (3400dcec <LL_RCC_PLL2_IsReady+0x24>)
3400dcce:	685b      	ldr	r3, [r3, #4]
3400dcd0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400dcd4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400dcd8:	d101      	bne.n	3400dcde <LL_RCC_PLL2_IsReady+0x16>
3400dcda:	2301      	movs	r3, #1
3400dcdc:	e000      	b.n	3400dce0 <LL_RCC_PLL2_IsReady+0x18>
3400dcde:	2300      	movs	r3, #0
}
3400dce0:	4618      	mov	r0, r3
3400dce2:	46bd      	mov	sp, r7
3400dce4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dce8:	4770      	bx	lr
3400dcea:	bf00      	nop
3400dcec:	56028000 	.word	0x56028000

3400dcf0 <LL_RCC_PLL2_IsEnabledBypass>:
  * @brief  Check if PLL2 bypass is enabled
  * @rmtoll PLL2CFGR1    PLL2BYP         LL_RCC_PLL2_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL2_IsEnabledBypass(void)
{
3400dcf0:	b480      	push	{r7}
3400dcf2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400dcf4:	4b07      	ldr	r3, [pc, #28]	@ (3400dd14 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400dcf6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400dcfa:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dcfe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dd02:	d101      	bne.n	3400dd08 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3400dd04:	2301      	movs	r3, #1
3400dd06:	e000      	b.n	3400dd0a <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3400dd08:	2300      	movs	r3, #0
}
3400dd0a:	4618      	mov	r0, r3
3400dd0c:	46bd      	mov	sp, r7
3400dd0e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd12:	4770      	bx	lr
3400dd14:	56028000 	.word	0x56028000

3400dd18 <LL_RCC_PLL3_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_GetSource(void)
{
3400dd18:	b480      	push	{r7}
3400dd1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400dd1c:	4b04      	ldr	r3, [pc, #16]	@ (3400dd30 <LL_RCC_PLL3_GetSource+0x18>)
3400dd1e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400dd22:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dd26:	4618      	mov	r0, r3
3400dd28:	46bd      	mov	sp, r7
3400dd2a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd2e:	4770      	bx	lr
3400dd30:	56028000 	.word	0x56028000

3400dd34 <LL_RCC_PLL3_IsReady>:
  * @brief  Check if PLL3 Ready
  * @rmtoll SR           PLL3RDY         LL_RCC_PLL3_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsReady(void)
{
3400dd34:	b480      	push	{r7}
3400dd36:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400dd38:	4b07      	ldr	r3, [pc, #28]	@ (3400dd58 <LL_RCC_PLL3_IsReady+0x24>)
3400dd3a:	685b      	ldr	r3, [r3, #4]
3400dd3c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400dd40:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400dd44:	d101      	bne.n	3400dd4a <LL_RCC_PLL3_IsReady+0x16>
3400dd46:	2301      	movs	r3, #1
3400dd48:	e000      	b.n	3400dd4c <LL_RCC_PLL3_IsReady+0x18>
3400dd4a:	2300      	movs	r3, #0
}
3400dd4c:	4618      	mov	r0, r3
3400dd4e:	46bd      	mov	sp, r7
3400dd50:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd54:	4770      	bx	lr
3400dd56:	bf00      	nop
3400dd58:	56028000 	.word	0x56028000

3400dd5c <LL_RCC_PLL3_IsEnabledBypass>:
  * @brief  Check if PLL3 bypass is enabled
  * @rmtoll PLL3CFGR1    PLL3BYP         LL_RCC_PLL3_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL3_IsEnabledBypass(void)
{
3400dd5c:	b480      	push	{r7}
3400dd5e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400dd60:	4b07      	ldr	r3, [pc, #28]	@ (3400dd80 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3400dd62:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400dd66:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400dd6a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400dd6e:	d101      	bne.n	3400dd74 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3400dd70:	2301      	movs	r3, #1
3400dd72:	e000      	b.n	3400dd76 <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3400dd74:	2300      	movs	r3, #0
}
3400dd76:	4618      	mov	r0, r3
3400dd78:	46bd      	mov	sp, r7
3400dd7a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd7e:	4770      	bx	lr
3400dd80:	56028000 	.word	0x56028000

3400dd84 <LL_RCC_PLL4_GetSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  *         @arg @ref LL_RCC_PLLSOURCE_I2S_CKIN
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_GetSource(void)
{
3400dd84:	b480      	push	{r7}
3400dd86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
3400dd88:	4b04      	ldr	r3, [pc, #16]	@ (3400dd9c <LL_RCC_PLL4_GetSource+0x18>)
3400dd8a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400dd8e:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400dd92:	4618      	mov	r0, r3
3400dd94:	46bd      	mov	sp, r7
3400dd96:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd9a:	4770      	bx	lr
3400dd9c:	56028000 	.word	0x56028000

3400dda0 <LL_RCC_PLL4_IsReady>:
  * @brief  Check if PLL4 Ready
  * @rmtoll SR           PLL4RDY         LL_RCC_PLL4_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsReady(void)
{
3400dda0:	b480      	push	{r7}
3400dda2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3400dda4:	4b07      	ldr	r3, [pc, #28]	@ (3400ddc4 <LL_RCC_PLL4_IsReady+0x24>)
3400dda6:	685b      	ldr	r3, [r3, #4]
3400dda8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400ddac:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
3400ddb0:	d101      	bne.n	3400ddb6 <LL_RCC_PLL4_IsReady+0x16>
3400ddb2:	2301      	movs	r3, #1
3400ddb4:	e000      	b.n	3400ddb8 <LL_RCC_PLL4_IsReady+0x18>
3400ddb6:	2300      	movs	r3, #0
}
3400ddb8:	4618      	mov	r0, r3
3400ddba:	46bd      	mov	sp, r7
3400ddbc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ddc0:	4770      	bx	lr
3400ddc2:	bf00      	nop
3400ddc4:	56028000 	.word	0x56028000

3400ddc8 <LL_RCC_PLL4_IsEnabledBypass>:
  * @brief  Check if PLL4 bypass is enabled
  * @rmtoll PLL4CFGR1    PLL4BYP         LL_RCC_PLL4_IsEnabledBypass
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL4_IsEnabledBypass(void)
{
3400ddc8:	b480      	push	{r7}
3400ddca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
3400ddcc:	4b07      	ldr	r3, [pc, #28]	@ (3400ddec <LL_RCC_PLL4_IsEnabledBypass+0x24>)
3400ddce:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3400ddd2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400ddd6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400ddda:	d101      	bne.n	3400dde0 <LL_RCC_PLL4_IsEnabledBypass+0x18>
3400dddc:	2301      	movs	r3, #1
3400ddde:	e000      	b.n	3400dde2 <LL_RCC_PLL4_IsEnabledBypass+0x1a>
3400dde0:	2300      	movs	r3, #0
}
3400dde2:	4618      	mov	r0, r3
3400dde4:	46bd      	mov	sp, r7
3400dde6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ddea:	4770      	bx	lr
3400ddec:	56028000 	.word	0x56028000

3400ddf0 <LL_RCC_IC1_Enable>:
  * @brief  Enable IC1
  * @rmtoll DIVENSR      IC1ENS        LL_RCC_IC1_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC1_Enable(void)
{
3400ddf0:	b480      	push	{r7}
3400ddf2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC1ENS);
3400ddf4:	4b04      	ldr	r3, [pc, #16]	@ (3400de08 <LL_RCC_IC1_Enable+0x18>)
3400ddf6:	2201      	movs	r2, #1
3400ddf8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400ddfc:	bf00      	nop
3400ddfe:	46bd      	mov	sp, r7
3400de00:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de04:	4770      	bx	lr
3400de06:	bf00      	nop
3400de08:	56028000 	.word	0x56028000

3400de0c <LL_RCC_IC1_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetSource(void)
{
3400de0c:	b480      	push	{r7}
3400de0e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL));
3400de10:	4b04      	ldr	r3, [pc, #16]	@ (3400de24 <LL_RCC_IC1_GetSource+0x18>)
3400de12:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400de16:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400de1a:	4618      	mov	r0, r3
3400de1c:	46bd      	mov	sp, r7
3400de1e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de22:	4770      	bx	lr
3400de24:	56028000 	.word	0x56028000

3400de28 <LL_RCC_IC1_GetDivider>:
  * @brief  Get IC1 divider
  * @rmtoll IC1CFGR      IC1INT        LL_RCC_IC1_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC1_GetDivider(void)
{
3400de28:	b480      	push	{r7}
3400de2a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL);
3400de2c:	4b05      	ldr	r3, [pc, #20]	@ (3400de44 <LL_RCC_IC1_GetDivider+0x1c>)
3400de2e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400de32:	0c1b      	lsrs	r3, r3, #16
3400de34:	b2db      	uxtb	r3, r3
3400de36:	3301      	adds	r3, #1
}
3400de38:	4618      	mov	r0, r3
3400de3a:	46bd      	mov	sp, r7
3400de3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de40:	4770      	bx	lr
3400de42:	bf00      	nop
3400de44:	56028000 	.word	0x56028000

3400de48 <LL_RCC_IC2_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetSource(void)
{
3400de48:	b480      	push	{r7}
3400de4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2SEL));
3400de4c:	4b04      	ldr	r3, [pc, #16]	@ (3400de60 <LL_RCC_IC2_GetSource+0x18>)
3400de4e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400de52:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400de56:	4618      	mov	r0, r3
3400de58:	46bd      	mov	sp, r7
3400de5a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de5e:	4770      	bx	lr
3400de60:	56028000 	.word	0x56028000

3400de64 <LL_RCC_IC2_GetDivider>:
  * @brief  Get IC2 divider
  * @rmtoll IC2CFGR      IC2INT        LL_RCC_IC2_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC2_GetDivider(void)
{
3400de64:	b480      	push	{r7}
3400de66:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC2CFGR, RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1UL);
3400de68:	4b05      	ldr	r3, [pc, #20]	@ (3400de80 <LL_RCC_IC2_GetDivider+0x1c>)
3400de6a:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400de6e:	0c1b      	lsrs	r3, r3, #16
3400de70:	b2db      	uxtb	r3, r3
3400de72:	3301      	adds	r3, #1
}
3400de74:	4618      	mov	r0, r3
3400de76:	46bd      	mov	sp, r7
3400de78:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de7c:	4770      	bx	lr
3400de7e:	bf00      	nop
3400de80:	56028000 	.word	0x56028000

3400de84 <LL_RCC_IC6_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC6_GetSource(void)
{
3400de84:	b480      	push	{r7}
3400de86:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC6CFGR, RCC_IC6CFGR_IC6SEL));
3400de88:	4b04      	ldr	r3, [pc, #16]	@ (3400de9c <LL_RCC_IC6_GetSource+0x18>)
3400de8a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400de8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400de92:	4618      	mov	r0, r3
3400de94:	46bd      	mov	sp, r7
3400de96:	f85d 7b04 	ldr.w	r7, [sp], #4
3400de9a:	4770      	bx	lr
3400de9c:	56028000 	.word	0x56028000

3400dea0 <LL_RCC_IC11_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC11_GetSource(void)
{
3400dea0:	b480      	push	{r7}
3400dea2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC11CFGR, RCC_IC11CFGR_IC11SEL));
3400dea4:	4b04      	ldr	r3, [pc, #16]	@ (3400deb8 <LL_RCC_IC11_GetSource+0x18>)
3400dea6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400deaa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3400deae:	4618      	mov	r0, r3
3400deb0:	46bd      	mov	sp, r7
3400deb2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400deb6:	4770      	bx	lr
3400deb8:	56028000 	.word	0x56028000

3400debc <HAL_RCC_OscConfig>:
  * @note   This function does not protect the MCOxSEL, the PERSEL and the PPPSEL glitch-free muxes
  *         (Mux selection cannot be changed if selected input clock is inactive).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *pRCC_OscInitStruct)
{
3400debc:	b580      	push	{r7, lr}
3400debe:	b0a2      	sub	sp, #136	@ 0x88
3400dec0:	af00      	add	r7, sp, #0
3400dec2:	6078      	str	r0, [r7, #4]
  uint32_t pll3src;
  uint32_t pll4src;
  uint32_t rccsr;

  /* Check Null pointer */
  if (pRCC_OscInitStruct == NULL)
3400dec4:	687b      	ldr	r3, [r7, #4]
3400dec6:	2b00      	cmp	r3, #0
3400dec8:	d101      	bne.n	3400dece <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
3400deca:	2301      	movs	r3, #1
3400decc:	e3d1      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(pRCC_OscInitStruct->OscillatorType));

  cpuclksrc = LL_RCC_GetCpuClkSource();
3400dece:	f7ff fe9b 	bl	3400dc08 <LL_RCC_GetCpuClkSource>
3400ded2:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
  sysclksrc = LL_RCC_GetSysClkSource();
3400ded6:	f7ff fea5 	bl	3400dc24 <LL_RCC_GetSysClkSource>
3400deda:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
  pll1src = LL_RCC_PLL1_GetSource();
3400dede:	f7ff feaf 	bl	3400dc40 <LL_RCC_PLL1_GetSource>
3400dee2:	67f8      	str	r0, [r7, #124]	@ 0x7c
  pll2src = LL_RCC_PLL2_GetSource();
3400dee4:	f7ff fee2 	bl	3400dcac <LL_RCC_PLL2_GetSource>
3400dee8:	67b8      	str	r0, [r7, #120]	@ 0x78
  pll3src = LL_RCC_PLL3_GetSource();
3400deea:	f7ff ff15 	bl	3400dd18 <LL_RCC_PLL3_GetSource>
3400deee:	6778      	str	r0, [r7, #116]	@ 0x74
  pll4src = LL_RCC_PLL4_GetSource();
3400def0:	f7ff ff48 	bl	3400dd84 <LL_RCC_PLL4_GetSource>
3400def4:	6738      	str	r0, [r7, #112]	@ 0x70
  rccsr = RCC->SR;
3400def6:	4b91      	ldr	r3, [pc, #580]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400def8:	685b      	ldr	r3, [r3, #4]
3400defa:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /*------------------------------- HSE Configuration ------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
3400defc:	687b      	ldr	r3, [r7, #4]
3400defe:	681b      	ldr	r3, [r3, #0]
3400df00:	f003 0301 	and.w	r3, r3, #1
3400df04:	2b00      	cmp	r3, #0
3400df06:	f000 80a8 	beq.w	3400e05a <HAL_RCC_OscConfig+0x19e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(pRCC_OscInitStruct->HSEState));

    /* When the HSE is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSE) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSE) ||
3400df0a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400df0e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400df12:	d028      	beq.n	3400df66 <HAL_RCC_OscConfig+0xaa>
3400df14:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400df18:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df1c:	d023      	beq.n	3400df66 <HAL_RCC_OscConfig+0xaa>
3400df1e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400df20:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df24:	d104      	bne.n	3400df30 <HAL_RCC_OscConfig+0x74>
        ((pll1src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400df26:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400df28:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400df2c:	2b00      	cmp	r3, #0
3400df2e:	d11a      	bne.n	3400df66 <HAL_RCC_OscConfig+0xaa>
3400df30:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400df32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df36:	d104      	bne.n	3400df42 <HAL_RCC_OscConfig+0x86>
        ((pll2src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400df38:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400df3a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400df3e:	2b00      	cmp	r3, #0
3400df40:	d111      	bne.n	3400df66 <HAL_RCC_OscConfig+0xaa>
3400df42:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400df44:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df48:	d104      	bne.n	3400df54 <HAL_RCC_OscConfig+0x98>
        ((pll3src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400df4a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400df4c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400df50:	2b00      	cmp	r3, #0
3400df52:	d108      	bne.n	3400df66 <HAL_RCC_OscConfig+0xaa>
3400df54:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400df56:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400df5a:	d10a      	bne.n	3400df72 <HAL_RCC_OscConfig+0xb6>
        ((pll4src == LL_RCC_PLLSOURCE_HSE) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400df5c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400df5e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400df62:	2b00      	cmp	r3, #0
3400df64:	d005      	beq.n	3400df72 <HAL_RCC_OscConfig+0xb6>
    {
      if (pRCC_OscInitStruct->HSEState == RCC_HSE_OFF)
3400df66:	687b      	ldr	r3, [r7, #4]
3400df68:	685b      	ldr	r3, [r3, #4]
3400df6a:	2b00      	cmp	r3, #0
3400df6c:	d175      	bne.n	3400e05a <HAL_RCC_OscConfig+0x19e>
      {
        return HAL_ERROR;
3400df6e:	2301      	movs	r3, #1
3400df70:	e37f      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      /* HSE ON , nothing to do */
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(pRCC_OscInitStruct->HSEState);
3400df72:	687b      	ldr	r3, [r7, #4]
3400df74:	685b      	ldr	r3, [r3, #4]
3400df76:	2b10      	cmp	r3, #16
3400df78:	d104      	bne.n	3400df84 <HAL_RCC_OscConfig+0xc8>
3400df7a:	4b70      	ldr	r3, [pc, #448]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400df7c:	2210      	movs	r2, #16
3400df7e:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400df82:	e043      	b.n	3400e00c <HAL_RCC_OscConfig+0x150>
3400df84:	687b      	ldr	r3, [r7, #4]
3400df86:	685b      	ldr	r3, [r3, #4]
3400df88:	2b00      	cmp	r3, #0
3400df8a:	d10c      	bne.n	3400dfa6 <HAL_RCC_OscConfig+0xea>
3400df8c:	4b6b      	ldr	r3, [pc, #428]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400df8e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400df92:	461a      	mov	r2, r3
3400df94:	2310      	movs	r3, #16
3400df96:	6013      	str	r3, [r2, #0]
3400df98:	4b68      	ldr	r3, [pc, #416]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400df9a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400df9c:	4a67      	ldr	r2, [pc, #412]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400df9e:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3400dfa2:	6553      	str	r3, [r2, #84]	@ 0x54
3400dfa4:	e032      	b.n	3400e00c <HAL_RCC_OscConfig+0x150>
3400dfa6:	687b      	ldr	r3, [r7, #4]
3400dfa8:	685b      	ldr	r3, [r3, #4]
3400dfaa:	f248 0210 	movw	r2, #32784	@ 0x8010
3400dfae:	4293      	cmp	r3, r2
3400dfb0:	d110      	bne.n	3400dfd4 <HAL_RCC_OscConfig+0x118>
3400dfb2:	4b62      	ldr	r3, [pc, #392]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfb4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400dfb6:	4a61      	ldr	r2, [pc, #388]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfb8:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400dfbc:	6553      	str	r3, [r2, #84]	@ 0x54
3400dfbe:	4b5f      	ldr	r3, [pc, #380]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfc0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400dfc2:	4a5e      	ldr	r2, [pc, #376]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfc4:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400dfc8:	6553      	str	r3, [r2, #84]	@ 0x54
3400dfca:	4b5c      	ldr	r3, [pc, #368]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfcc:	2210      	movs	r2, #16
3400dfce:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400dfd2:	e01b      	b.n	3400e00c <HAL_RCC_OscConfig+0x150>
3400dfd4:	687b      	ldr	r3, [r7, #4]
3400dfd6:	685b      	ldr	r3, [r3, #4]
3400dfd8:	4a59      	ldr	r2, [pc, #356]	@ (3400e140 <HAL_RCC_OscConfig+0x284>)
3400dfda:	4293      	cmp	r3, r2
3400dfdc:	d10a      	bne.n	3400dff4 <HAL_RCC_OscConfig+0x138>
3400dfde:	4b57      	ldr	r3, [pc, #348]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfe0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400dfe2:	4a56      	ldr	r2, [pc, #344]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfe4:	f443 33c0 	orr.w	r3, r3, #98304	@ 0x18000
3400dfe8:	6553      	str	r3, [r2, #84]	@ 0x54
3400dfea:	4b54      	ldr	r3, [pc, #336]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dfec:	2210      	movs	r2, #16
3400dfee:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400dff2:	e00b      	b.n	3400e00c <HAL_RCC_OscConfig+0x150>
3400dff4:	4b51      	ldr	r3, [pc, #324]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400dff6:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400dffa:	461a      	mov	r2, r3
3400dffc:	2310      	movs	r3, #16
3400dffe:	6013      	str	r3, [r2, #0]
3400e000:	4b4e      	ldr	r3, [pc, #312]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400e002:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400e004:	4a4d      	ldr	r2, [pc, #308]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400e006:	f423 33c0 	bic.w	r3, r3, #98304	@ 0x18000
3400e00a:	6553      	str	r3, [r2, #84]	@ 0x54

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400e00c:	f7f6 fe0f 	bl	34004c2e <HAL_GetTick>
3400e010:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Check the HSE State */
      if (pRCC_OscInitStruct->HSEState != RCC_HSE_OFF)
3400e012:	687b      	ldr	r3, [r7, #4]
3400e014:	685b      	ldr	r3, [r3, #4]
3400e016:	2b00      	cmp	r3, #0
3400e018:	d019      	beq.n	3400e04e <HAL_RCC_OscConfig+0x192>
      {
        /* Wait till HSE is ready */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3400e01a:	e008      	b.n	3400e02e <HAL_RCC_OscConfig+0x172>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3400e01c:	f7f6 fe07 	bl	34004c2e <HAL_GetTick>
3400e020:	4602      	mov	r2, r0
3400e022:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e024:	1ad3      	subs	r3, r2, r3
3400e026:	2b64      	cmp	r3, #100	@ 0x64
3400e028:	d901      	bls.n	3400e02e <HAL_RCC_OscConfig+0x172>
          {
            return HAL_TIMEOUT;
3400e02a:	2303      	movs	r3, #3
3400e02c:	e321      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) == 0U)
3400e02e:	4b43      	ldr	r3, [pc, #268]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400e030:	685b      	ldr	r3, [r3, #4]
3400e032:	f003 0310 	and.w	r3, r3, #16
3400e036:	2b00      	cmp	r3, #0
3400e038:	d0f0      	beq.n	3400e01c <HAL_RCC_OscConfig+0x160>
3400e03a:	e00e      	b.n	3400e05a <HAL_RCC_OscConfig+0x19e>
      else
      {
        /* Wait till HSE is disabled */
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSE_TIMEOUT_VALUE)
3400e03c:	f7f6 fdf7 	bl	34004c2e <HAL_GetTick>
3400e040:	4602      	mov	r2, r0
3400e042:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e044:	1ad3      	subs	r3, r2, r3
3400e046:	2b64      	cmp	r3, #100	@ 0x64
3400e048:	d901      	bls.n	3400e04e <HAL_RCC_OscConfig+0x192>
          {
            return HAL_TIMEOUT;
3400e04a:	2303      	movs	r3, #3
3400e04c:	e311      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        while (READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0U)
3400e04e:	4b3b      	ldr	r3, [pc, #236]	@ (3400e13c <HAL_RCC_OscConfig+0x280>)
3400e050:	685b      	ldr	r3, [r3, #4]
3400e052:	f003 0310 	and.w	r3, r3, #16
3400e056:	2b00      	cmp	r3, #0
3400e058:	d1f0      	bne.n	3400e03c <HAL_RCC_OscConfig+0x180>
      }
    }
  }

  /*----------------------------- HSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
3400e05a:	687b      	ldr	r3, [r7, #4]
3400e05c:	681b      	ldr	r3, [r3, #0]
3400e05e:	f003 0302 	and.w	r3, r3, #2
3400e062:	2b00      	cmp	r3, #0
3400e064:	d073      	beq.n	3400e14e <HAL_RCC_OscConfig+0x292>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(pRCC_OscInitStruct->HSIState));

    /* When the HSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_HSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_HSI) ||
3400e066:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e06a:	2b00      	cmp	r3, #0
3400e06c:	d023      	beq.n	3400e0b6 <HAL_RCC_OscConfig+0x1fa>
3400e06e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e072:	2b00      	cmp	r3, #0
3400e074:	d01f      	beq.n	3400e0b6 <HAL_RCC_OscConfig+0x1fa>
3400e076:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400e078:	2b00      	cmp	r3, #0
3400e07a:	d104      	bne.n	3400e086 <HAL_RCC_OscConfig+0x1ca>
        ((pll1src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400e07c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e07e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400e082:	2b00      	cmp	r3, #0
3400e084:	d117      	bne.n	3400e0b6 <HAL_RCC_OscConfig+0x1fa>
3400e086:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400e088:	2b00      	cmp	r3, #0
3400e08a:	d104      	bne.n	3400e096 <HAL_RCC_OscConfig+0x1da>
        ((pll2src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400e08c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e08e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400e092:	2b00      	cmp	r3, #0
3400e094:	d10f      	bne.n	3400e0b6 <HAL_RCC_OscConfig+0x1fa>
3400e096:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400e098:	2b00      	cmp	r3, #0
3400e09a:	d104      	bne.n	3400e0a6 <HAL_RCC_OscConfig+0x1ea>
        ((pll3src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400e09c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e09e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400e0a2:	2b00      	cmp	r3, #0
3400e0a4:	d107      	bne.n	3400e0b6 <HAL_RCC_OscConfig+0x1fa>
3400e0a6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400e0a8:	2b00      	cmp	r3, #0
3400e0aa:	d115      	bne.n	3400e0d8 <HAL_RCC_OscConfig+0x21c>
        ((pll4src == LL_RCC_PLLSOURCE_HSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400e0ac:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e0ae:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400e0b2:	2b00      	cmp	r3, #0
3400e0b4:	d010      	beq.n	3400e0d8 <HAL_RCC_OscConfig+0x21c>
    {
      /* When HSI is used as system clock it will not be disabled */
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3400e0b6:	687b      	ldr	r3, [r7, #4]
3400e0b8:	68db      	ldr	r3, [r3, #12]
3400e0ba:	2b00      	cmp	r3, #0
3400e0bc:	d101      	bne.n	3400e0c2 <HAL_RCC_OscConfig+0x206>
      {
        return HAL_ERROR;
3400e0be:	2301      	movs	r3, #1
3400e0c0:	e2d7      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3400e0c2:	687b      	ldr	r3, [r7, #4]
3400e0c4:	691b      	ldr	r3, [r3, #16]
3400e0c6:	4618      	mov	r0, r3
3400e0c8:	f7ff fcc0 	bl	3400da4c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3400e0cc:	687b      	ldr	r3, [r7, #4]
3400e0ce:	695b      	ldr	r3, [r3, #20]
3400e0d0:	4618      	mov	r0, r3
3400e0d2:	f7ff fcdd 	bl	3400da90 <LL_RCC_HSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->HSIState == RCC_HSI_OFF)
3400e0d6:	e03a      	b.n	3400e14e <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Check the HSI State */
      if (pRCC_OscInitStruct->HSIState != RCC_HSI_OFF)
3400e0d8:	687b      	ldr	r3, [r7, #4]
3400e0da:	68db      	ldr	r3, [r3, #12]
3400e0dc:	2b00      	cmp	r3, #0
3400e0de:	d01e      	beq.n	3400e11e <HAL_RCC_OscConfig+0x262>
        /* Check the parameters */
        assert_param(IS_RCC_HSI_DIV(pRCC_OscInitStruct->HSIDiv));
        assert_param(IS_RCC_HSI_CALIBRATION_VALUE(pRCC_OscInitStruct->HSICalibrationValue));

        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
3400e0e0:	f7ff fc84 	bl	3400d9ec <LL_RCC_HSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400e0e4:	f7f6 fda3 	bl	34004c2e <HAL_GetTick>
3400e0e8:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is ready */
        while (LL_RCC_HSI_IsReady() == 0U)
3400e0ea:	e008      	b.n	3400e0fe <HAL_RCC_OscConfig+0x242>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3400e0ec:	f7f6 fd9f 	bl	34004c2e <HAL_GetTick>
3400e0f0:	4602      	mov	r2, r0
3400e0f2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e0f4:	1ad3      	subs	r3, r2, r3
3400e0f6:	2b01      	cmp	r3, #1
3400e0f8:	d901      	bls.n	3400e0fe <HAL_RCC_OscConfig+0x242>
          {
            return HAL_TIMEOUT;
3400e0fa:	2303      	movs	r3, #3
3400e0fc:	e2b9      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_HSI_IsReady() == 0U)
3400e0fe:	f7ff fc93 	bl	3400da28 <LL_RCC_HSI_IsReady>
3400e102:	4603      	mov	r3, r0
3400e104:	2b00      	cmp	r3, #0
3400e106:	d0f1      	beq.n	3400e0ec <HAL_RCC_OscConfig+0x230>
          }
        }

        /* Set the HSI Divider */
        __HAL_RCC_HSI_DIVIDER_CONFIG(pRCC_OscInitStruct->HSIDiv);
3400e108:	687b      	ldr	r3, [r7, #4]
3400e10a:	691b      	ldr	r3, [r3, #16]
3400e10c:	4618      	mov	r0, r3
3400e10e:	f7ff fc9d 	bl	3400da4c <LL_RCC_HSI_SetDivider>
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->HSICalibrationValue);
3400e112:	687b      	ldr	r3, [r7, #4]
3400e114:	695b      	ldr	r3, [r3, #20]
3400e116:	4618      	mov	r0, r3
3400e118:	f7ff fcba 	bl	3400da90 <LL_RCC_HSI_SetCalibTrimming>
3400e11c:	e017      	b.n	3400e14e <HAL_RCC_OscConfig+0x292>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
3400e11e:	f7ff fc73 	bl	3400da08 <LL_RCC_HSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400e122:	f7f6 fd84 	bl	34004c2e <HAL_GetTick>
3400e126:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till HSI is disabled */
        while (LL_RCC_HSI_IsReady() != 0U)
3400e128:	e00c      	b.n	3400e144 <HAL_RCC_OscConfig+0x288>
        {
          if ((HAL_GetTick() - tickstart) > RCC_HSI_TIMEOUT_VALUE)
3400e12a:	f7f6 fd80 	bl	34004c2e <HAL_GetTick>
3400e12e:	4602      	mov	r2, r0
3400e130:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e132:	1ad3      	subs	r3, r2, r3
3400e134:	2b01      	cmp	r3, #1
3400e136:	d905      	bls.n	3400e144 <HAL_RCC_OscConfig+0x288>
          {
            return HAL_TIMEOUT;
3400e138:	2303      	movs	r3, #3
3400e13a:	e29a      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
3400e13c:	56028000 	.word	0x56028000
3400e140:	00018010 	.word	0x00018010
        while (LL_RCC_HSI_IsReady() != 0U)
3400e144:	f7ff fc70 	bl	3400da28 <LL_RCC_HSI_IsReady>
3400e148:	4603      	mov	r3, r0
3400e14a:	2b00      	cmp	r3, #0
3400e14c:	d1ed      	bne.n	3400e12a <HAL_RCC_OscConfig+0x26e>
      }
    }
  }

  /*----------------------------- MSI Configuration --------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
3400e14e:	687b      	ldr	r3, [r7, #4]
3400e150:	681b      	ldr	r3, [r3, #0]
3400e152:	f003 0310 	and.w	r3, r3, #16
3400e156:	2b00      	cmp	r3, #0
3400e158:	d070      	beq.n	3400e23c <HAL_RCC_OscConfig+0x380>
    /* Check the parameters */
    assert_param(IS_RCC_MSI(pRCC_OscInitStruct->MSIState));

    /* When the MSI is used as cpu/system bus clock or clock source for any PLL, it is not allowed to be disabled */
    /* but just to update the MSI calibration value */
    if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_MSI) || (sysclksrc == RCC_SYSCLKSOURCE_STATUS_MSI) ||
3400e15a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e15e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400e162:	d028      	beq.n	3400e1b6 <HAL_RCC_OscConfig+0x2fa>
3400e164:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e168:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e16c:	d023      	beq.n	3400e1b6 <HAL_RCC_OscConfig+0x2fa>
3400e16e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
3400e170:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e174:	d104      	bne.n	3400e180 <HAL_RCC_OscConfig+0x2c4>
        ((pll1src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL1RDY) == RCC_SR_PLL1RDY))) ||
3400e176:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e178:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400e17c:	2b00      	cmp	r3, #0
3400e17e:	d11a      	bne.n	3400e1b6 <HAL_RCC_OscConfig+0x2fa>
3400e180:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
3400e182:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e186:	d104      	bne.n	3400e192 <HAL_RCC_OscConfig+0x2d6>
        ((pll2src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL2RDY) == RCC_SR_PLL2RDY))) ||
3400e188:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e18a:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400e18e:	2b00      	cmp	r3, #0
3400e190:	d111      	bne.n	3400e1b6 <HAL_RCC_OscConfig+0x2fa>
3400e192:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
3400e194:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e198:	d104      	bne.n	3400e1a4 <HAL_RCC_OscConfig+0x2e8>
        ((pll3src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL3RDY) == RCC_SR_PLL3RDY))) ||
3400e19a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e19c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400e1a0:	2b00      	cmp	r3, #0
3400e1a2:	d108      	bne.n	3400e1b6 <HAL_RCC_OscConfig+0x2fa>
3400e1a4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400e1a6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e1aa:	d110      	bne.n	3400e1ce <HAL_RCC_OscConfig+0x312>
        ((pll4src == LL_RCC_PLLSOURCE_MSI) && (((rccsr & RCC_SR_PLL4RDY) == RCC_SR_PLL4RDY))))
3400e1ac:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400e1ae:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400e1b2:	2b00      	cmp	r3, #0
3400e1b4:	d00b      	beq.n	3400e1ce <HAL_RCC_OscConfig+0x312>
    {
      /* When MSI is used as system clock it will not disabled */
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3400e1b6:	687b      	ldr	r3, [r7, #4]
3400e1b8:	69db      	ldr	r3, [r3, #28]
3400e1ba:	2b00      	cmp	r3, #0
3400e1bc:	d101      	bne.n	3400e1c2 <HAL_RCC_OscConfig+0x306>
      {
        return HAL_ERROR;
3400e1be:	2301      	movs	r3, #1
3400e1c0:	e257      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      {
        /* Check the parameters */
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3400e1c2:	687b      	ldr	r3, [r7, #4]
3400e1c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e1c6:	4618      	mov	r0, r3
3400e1c8:	f7ff fcca 	bl	3400db60 <LL_RCC_MSI_SetCalibTrimming>
      if (pRCC_OscInitStruct->MSIState == RCC_MSI_OFF)
3400e1cc:	e036      	b.n	3400e23c <HAL_RCC_OscConfig+0x380>
      }
    }
    else
    {
      /* Check the MSI State */
      if ((pRCC_OscInitStruct->MSIState) != RCC_MSI_OFF)
3400e1ce:	687b      	ldr	r3, [r7, #4]
3400e1d0:	69db      	ldr	r3, [r3, #28]
3400e1d2:	2b00      	cmp	r3, #0
3400e1d4:	d01e      	beq.n	3400e214 <HAL_RCC_OscConfig+0x358>
        /* Check the parameters */
        assert_param(IS_RCC_MSI_FREQUENCY(pRCC_OscInitStruct->MSIFrequency));
        assert_param(IS_RCC_MSI_CALIBRATION_VALUE(pRCC_OscInitStruct->MSICalibrationValue));

        /* Set the frequency */
        __HAL_RCC_MSI_FREQUENCY_CONFIG(pRCC_OscInitStruct->MSIFrequency);
3400e1d6:	687b      	ldr	r3, [r7, #4]
3400e1d8:	6a1b      	ldr	r3, [r3, #32]
3400e1da:	4618      	mov	r0, r3
3400e1dc:	f7ff fc9e 	bl	3400db1c <LL_RCC_MSI_SetFrequency>

        /* Enable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_ENABLE();
3400e1e0:	f7ff fc6c 	bl	3400dabc <LL_RCC_MSI_Enable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400e1e4:	f7f6 fd23 	bl	34004c2e <HAL_GetTick>
3400e1e8:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is ready */
        while (LL_RCC_MSI_IsReady() == 0U)
3400e1ea:	e008      	b.n	3400e1fe <HAL_RCC_OscConfig+0x342>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3400e1ec:	f7f6 fd1f 	bl	34004c2e <HAL_GetTick>
3400e1f0:	4602      	mov	r2, r0
3400e1f2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e1f4:	1ad3      	subs	r3, r2, r3
3400e1f6:	2b01      	cmp	r3, #1
3400e1f8:	d901      	bls.n	3400e1fe <HAL_RCC_OscConfig+0x342>
          {
            return HAL_TIMEOUT;
3400e1fa:	2303      	movs	r3, #3
3400e1fc:	e239      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() == 0U)
3400e1fe:	f7ff fc7b 	bl	3400daf8 <LL_RCC_MSI_IsReady>
3400e202:	4603      	mov	r3, r0
3400e204:	2b00      	cmp	r3, #0
3400e206:	d0f1      	beq.n	3400e1ec <HAL_RCC_OscConfig+0x330>
          }
        }

        /* Adjusts the Internal High Speed oscillator (MSI) calibration value.*/
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(pRCC_OscInitStruct->MSICalibrationValue);
3400e208:	687b      	ldr	r3, [r7, #4]
3400e20a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e20c:	4618      	mov	r0, r3
3400e20e:	f7ff fca7 	bl	3400db60 <LL_RCC_MSI_SetCalibTrimming>
3400e212:	e013      	b.n	3400e23c <HAL_RCC_OscConfig+0x380>
      }
      else
      {
        /* Ignore MSI frequency and calibration values in disable case */
        /* Disable the Internal High Speed oscillator (MSI). */
        __HAL_RCC_MSI_DISABLE();
3400e214:	f7ff fc60 	bl	3400dad8 <LL_RCC_MSI_Disable>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
3400e218:	f7f6 fd09 	bl	34004c2e <HAL_GetTick>
3400e21c:	66b8      	str	r0, [r7, #104]	@ 0x68

        /* Wait till MSI is disabled */
        while (LL_RCC_MSI_IsReady() != 0U)
3400e21e:	e008      	b.n	3400e232 <HAL_RCC_OscConfig+0x376>
        {
          if ((HAL_GetTick() - tickstart) > RCC_MSI_TIMEOUT_VALUE)
3400e220:	f7f6 fd05 	bl	34004c2e <HAL_GetTick>
3400e224:	4602      	mov	r2, r0
3400e226:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e228:	1ad3      	subs	r3, r2, r3
3400e22a:	2b01      	cmp	r3, #1
3400e22c:	d901      	bls.n	3400e232 <HAL_RCC_OscConfig+0x376>
          {
            return HAL_TIMEOUT;
3400e22e:	2303      	movs	r3, #3
3400e230:	e21f      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
        while (LL_RCC_MSI_IsReady() != 0U)
3400e232:	f7ff fc61 	bl	3400daf8 <LL_RCC_MSI_IsReady>
3400e236:	4603      	mov	r3, r0
3400e238:	2b00      	cmp	r3, #0
3400e23a:	d1f1      	bne.n	3400e220 <HAL_RCC_OscConfig+0x364>
      }
    }
  }

  /*------------------------------ LSI Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
3400e23c:	687b      	ldr	r3, [r7, #4]
3400e23e:	681b      	ldr	r3, [r3, #0]
3400e240:	f003 0308 	and.w	r3, r3, #8
3400e244:	2b00      	cmp	r3, #0
3400e246:	d02c      	beq.n	3400e2a2 <HAL_RCC_OscConfig+0x3e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(pRCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((pRCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
3400e248:	687b      	ldr	r3, [r7, #4]
3400e24a:	699b      	ldr	r3, [r3, #24]
3400e24c:	2b00      	cmp	r3, #0
3400e24e:	d014      	beq.n	3400e27a <HAL_RCC_OscConfig+0x3be>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
3400e250:	f7ff fcae 	bl	3400dbb0 <LL_RCC_LSI_Enable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400e254:	f7f6 fceb 	bl	34004c2e <HAL_GetTick>
3400e258:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() == 0U)
3400e25a:	e008      	b.n	3400e26e <HAL_RCC_OscConfig+0x3b2>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3400e25c:	f7f6 fce7 	bl	34004c2e <HAL_GetTick>
3400e260:	4602      	mov	r2, r0
3400e262:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e264:	1ad3      	subs	r3, r2, r3
3400e266:	2b01      	cmp	r3, #1
3400e268:	d901      	bls.n	3400e26e <HAL_RCC_OscConfig+0x3b2>
        {
          return HAL_TIMEOUT;
3400e26a:	2303      	movs	r3, #3
3400e26c:	e201      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() == 0U)
3400e26e:	f7ff fcbd 	bl	3400dbec <LL_RCC_LSI_IsReady>
3400e272:	4603      	mov	r3, r0
3400e274:	2b00      	cmp	r3, #0
3400e276:	d0f1      	beq.n	3400e25c <HAL_RCC_OscConfig+0x3a0>
3400e278:	e013      	b.n	3400e2a2 <HAL_RCC_OscConfig+0x3e6>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
3400e27a:	f7ff fca7 	bl	3400dbcc <LL_RCC_LSI_Disable>

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400e27e:	f7f6 fcd6 	bl	34004c2e <HAL_GetTick>
3400e282:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSI is ready */
      while (LL_RCC_LSI_IsReady() != 0U)
3400e284:	e008      	b.n	3400e298 <HAL_RCC_OscConfig+0x3dc>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSI_TIMEOUT_VALUE)
3400e286:	f7f6 fcd2 	bl	34004c2e <HAL_GetTick>
3400e28a:	4602      	mov	r2, r0
3400e28c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e28e:	1ad3      	subs	r3, r2, r3
3400e290:	2b01      	cmp	r3, #1
3400e292:	d901      	bls.n	3400e298 <HAL_RCC_OscConfig+0x3dc>
        {
          return HAL_TIMEOUT;
3400e294:	2303      	movs	r3, #3
3400e296:	e1ec      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSI_IsReady() != 0U)
3400e298:	f7ff fca8 	bl	3400dbec <LL_RCC_LSI_IsReady>
3400e29c:	4603      	mov	r3, r0
3400e29e:	2b00      	cmp	r3, #0
3400e2a0:	d1f1      	bne.n	3400e286 <HAL_RCC_OscConfig+0x3ca>
      }
    }
  }

  /*------------------------------ LSE Configuration -------------------------*/
  if (((pRCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
3400e2a2:	687b      	ldr	r3, [r7, #4]
3400e2a4:	681b      	ldr	r3, [r3, #0]
3400e2a6:	f003 0304 	and.w	r3, r3, #4
3400e2aa:	2b00      	cmp	r3, #0
3400e2ac:	f000 808c 	beq.w	3400e3c8 <HAL_RCC_OscConfig+0x50c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(pRCC_OscInitStruct->LSEState));

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(pRCC_OscInitStruct->LSEState);
3400e2b0:	687b      	ldr	r3, [r7, #4]
3400e2b2:	689b      	ldr	r3, [r3, #8]
3400e2b4:	2b02      	cmp	r3, #2
3400e2b6:	d104      	bne.n	3400e2c2 <HAL_RCC_OscConfig+0x406>
3400e2b8:	4b96      	ldr	r3, [pc, #600]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2ba:	2202      	movs	r2, #2
3400e2bc:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400e2c0:	e055      	b.n	3400e36e <HAL_RCC_OscConfig+0x4b2>
3400e2c2:	687b      	ldr	r3, [r7, #4]
3400e2c4:	689b      	ldr	r3, [r3, #8]
3400e2c6:	2b00      	cmp	r3, #0
3400e2c8:	d112      	bne.n	3400e2f0 <HAL_RCC_OscConfig+0x434>
3400e2ca:	4b92      	ldr	r3, [pc, #584]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2cc:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400e2d0:	461a      	mov	r2, r3
3400e2d2:	2302      	movs	r3, #2
3400e2d4:	6013      	str	r3, [r2, #0]
3400e2d6:	4b8f      	ldr	r3, [pc, #572]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e2da:	4a8e      	ldr	r2, [pc, #568]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2dc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400e2e0:	6413      	str	r3, [r2, #64]	@ 0x40
3400e2e2:	4b8c      	ldr	r3, [pc, #560]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2e4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e2e6:	4a8b      	ldr	r2, [pc, #556]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2e8:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400e2ec:	6413      	str	r3, [r2, #64]	@ 0x40
3400e2ee:	e03e      	b.n	3400e36e <HAL_RCC_OscConfig+0x4b2>
3400e2f0:	687b      	ldr	r3, [r7, #4]
3400e2f2:	689b      	ldr	r3, [r3, #8]
3400e2f4:	f248 0202 	movw	r2, #32770	@ 0x8002
3400e2f8:	4293      	cmp	r3, r2
3400e2fa:	d110      	bne.n	3400e31e <HAL_RCC_OscConfig+0x462>
3400e2fc:	4b85      	ldr	r3, [pc, #532]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e2fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e300:	4a84      	ldr	r2, [pc, #528]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e302:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400e306:	6413      	str	r3, [r2, #64]	@ 0x40
3400e308:	4b82      	ldr	r3, [pc, #520]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e30a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e30c:	4a81      	ldr	r2, [pc, #516]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e30e:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400e312:	6413      	str	r3, [r2, #64]	@ 0x40
3400e314:	4b7f      	ldr	r3, [pc, #508]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e316:	2202      	movs	r2, #2
3400e318:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400e31c:	e027      	b.n	3400e36e <HAL_RCC_OscConfig+0x4b2>
3400e31e:	687b      	ldr	r3, [r7, #4]
3400e320:	689b      	ldr	r3, [r3, #8]
3400e322:	4a7d      	ldr	r2, [pc, #500]	@ (3400e518 <HAL_RCC_OscConfig+0x65c>)
3400e324:	4293      	cmp	r3, r2
3400e326:	d110      	bne.n	3400e34a <HAL_RCC_OscConfig+0x48e>
3400e328:	4b7a      	ldr	r3, [pc, #488]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e32a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e32c:	4a79      	ldr	r2, [pc, #484]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e32e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
3400e332:	6413      	str	r3, [r2, #64]	@ 0x40
3400e334:	4b77      	ldr	r3, [pc, #476]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e336:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e338:	4a76      	ldr	r2, [pc, #472]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e33a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
3400e33e:	6413      	str	r3, [r2, #64]	@ 0x40
3400e340:	4b74      	ldr	r3, [pc, #464]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e342:	2202      	movs	r2, #2
3400e344:	f8c3 2800 	str.w	r2, [r3, #2048]	@ 0x800
3400e348:	e011      	b.n	3400e36e <HAL_RCC_OscConfig+0x4b2>
3400e34a:	4b72      	ldr	r3, [pc, #456]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e34c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3400e350:	461a      	mov	r2, r3
3400e352:	2302      	movs	r3, #2
3400e354:	6013      	str	r3, [r2, #0]
3400e356:	4b6f      	ldr	r3, [pc, #444]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e358:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e35a:	4a6e      	ldr	r2, [pc, #440]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e35c:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
3400e360:	6413      	str	r3, [r2, #64]	@ 0x40
3400e362:	4b6c      	ldr	r3, [pc, #432]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e364:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400e366:	4a6b      	ldr	r2, [pc, #428]	@ (3400e514 <HAL_RCC_OscConfig+0x658>)
3400e368:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
3400e36c:	6413      	str	r3, [r2, #64]	@ 0x40
    /* Check the LSE State */
    if ((pRCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
3400e36e:	687b      	ldr	r3, [r7, #4]
3400e370:	689b      	ldr	r3, [r3, #8]
3400e372:	2b00      	cmp	r3, #0
3400e374:	d014      	beq.n	3400e3a0 <HAL_RCC_OscConfig+0x4e4>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400e376:	f7f6 fc5a 	bl	34004c2e <HAL_GetTick>
3400e37a:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is ready */
      while (LL_RCC_LSE_IsReady() == 0U)
3400e37c:	e00a      	b.n	3400e394 <HAL_RCC_OscConfig+0x4d8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400e37e:	f7f6 fc56 	bl	34004c2e <HAL_GetTick>
3400e382:	4602      	mov	r2, r0
3400e384:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e386:	1ad3      	subs	r3, r2, r3
3400e388:	f241 3288 	movw	r2, #5000	@ 0x1388
3400e38c:	4293      	cmp	r3, r2
3400e38e:	d901      	bls.n	3400e394 <HAL_RCC_OscConfig+0x4d8>
        {
          return HAL_TIMEOUT;
3400e390:	2303      	movs	r3, #3
3400e392:	e16e      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() == 0U)
3400e394:	f7ff fbfa 	bl	3400db8c <LL_RCC_LSE_IsReady>
3400e398:	4603      	mov	r3, r0
3400e39a:	2b00      	cmp	r3, #0
3400e39c:	d0ef      	beq.n	3400e37e <HAL_RCC_OscConfig+0x4c2>
3400e39e:	e013      	b.n	3400e3c8 <HAL_RCC_OscConfig+0x50c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400e3a0:	f7f6 fc45 	bl	34004c2e <HAL_GetTick>
3400e3a4:	66b8      	str	r0, [r7, #104]	@ 0x68

      /* Wait till LSE is disabled */
      while (LL_RCC_LSE_IsReady() != 0U)
3400e3a6:	e00a      	b.n	3400e3be <HAL_RCC_OscConfig+0x502>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400e3a8:	f7f6 fc41 	bl	34004c2e <HAL_GetTick>
3400e3ac:	4602      	mov	r2, r0
3400e3ae:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3400e3b0:	1ad3      	subs	r3, r2, r3
3400e3b2:	f241 3288 	movw	r2, #5000	@ 0x1388
3400e3b6:	4293      	cmp	r3, r2
3400e3b8:	d901      	bls.n	3400e3be <HAL_RCC_OscConfig+0x502>
        {
          return HAL_TIMEOUT;
3400e3ba:	2303      	movs	r3, #3
3400e3bc:	e159      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      while (LL_RCC_LSE_IsReady() != 0U)
3400e3be:	f7ff fbe5 	bl	3400db8c <LL_RCC_LSE_IsReady>
3400e3c2:	4603      	mov	r3, r0
3400e3c4:	2b00      	cmp	r3, #0
3400e3c6:	d1ef      	bne.n	3400e3a8 <HAL_RCC_OscConfig+0x4ec>

  /*-------------------------------- PLL1 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL1.PLLState));

  if (pRCC_OscInitStruct->PLL1.PLLState != RCC_PLL_NONE)
3400e3c8:	687b      	ldr	r3, [r7, #4]
3400e3ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400e3cc:	2b00      	cmp	r3, #0
3400e3ce:	d04c      	beq.n	3400e46a <HAL_RCC_OscConfig+0x5ae>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1));
3400e3d0:	687b      	ldr	r3, [r7, #4]
3400e3d2:	3328      	adds	r3, #40	@ 0x28
3400e3d4:	4619      	mov	r1, r3
3400e3d6:	2000      	movs	r0, #0
3400e3d8:	f000 fe22 	bl	3400f020 <RCC_PLL_IsNewConfig>
3400e3dc:	6678      	str	r0, [r7, #100]	@ 0x64
    uint32_t pll1_ready = LL_RCC_PLL1_IsReady();
3400e3de:	f7ff fc3d 	bl	3400dc5c <LL_RCC_PLL1_IsReady>
3400e3e2:	6638      	str	r0, [r7, #96]	@ 0x60
    if (new_pll_config == 1U)
3400e3e4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3400e3e6:	2b01      	cmp	r3, #1
3400e3e8:	d130      	bne.n	3400e44c <HAL_RCC_OscConfig+0x590>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400e3ea:	f7ff fd0f 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400e3ee:	65f8      	str	r0, [r7, #92]	@ 0x5c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400e3f0:	f7ff fd2a 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400e3f4:	65b8      	str	r0, [r7, #88]	@ 0x58
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400e3f6:	f7ff fd45 	bl	3400de84 <LL_RCC_IC6_GetSource>
3400e3fa:	6578      	str	r0, [r7, #84]	@ 0x54
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400e3fc:	f7ff fd50 	bl	3400dea0 <LL_RCC_IC11_GetSource>
3400e400:	6538      	str	r0, [r7, #80]	@ 0x50
      /* PLL1 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL1))
3400e402:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e406:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400e40a:	d104      	bne.n	3400e416 <HAL_RCC_OscConfig+0x55a>
3400e40c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3400e40e:	2b00      	cmp	r3, #0
3400e410:	d101      	bne.n	3400e416 <HAL_RCC_OscConfig+0x55a>
      {
        return HAL_ERROR;
3400e412:	2301      	movs	r3, #1
3400e414:	e12d      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL1 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400e416:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e41a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e41e:	d10a      	bne.n	3400e436 <HAL_RCC_OscConfig+0x57a>
3400e420:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
3400e422:	2b00      	cmp	r3, #0
3400e424:	d005      	beq.n	3400e432 <HAL_RCC_OscConfig+0x576>
3400e426:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3400e428:	2b00      	cmp	r3, #0
3400e42a:	d002      	beq.n	3400e432 <HAL_RCC_OscConfig+0x576>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL1) ||
3400e42c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3400e42e:	2b00      	cmp	r3, #0
3400e430:	d101      	bne.n	3400e436 <HAL_RCC_OscConfig+0x57a>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL1)))
      {
        return HAL_ERROR;
3400e432:	2301      	movs	r3, #1
3400e434:	e11d      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL1 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL1_CONFIG, &(pRCC_OscInitStruct->PLL1)) != HAL_OK)
3400e436:	687b      	ldr	r3, [r7, #4]
3400e438:	3328      	adds	r3, #40	@ 0x28
3400e43a:	4619      	mov	r1, r3
3400e43c:	2000      	movs	r0, #0
3400e43e:	f000 fc93 	bl	3400ed68 <RCC_PLL_Config>
3400e442:	4603      	mov	r3, r0
3400e444:	2b00      	cmp	r3, #0
3400e446:	d010      	beq.n	3400e46a <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3400e448:	2301      	movs	r3, #1
3400e44a:	e112      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL1.PLLState == RCC_PLL_ON) && (pll1_ready == 0U))
3400e44c:	687b      	ldr	r3, [r7, #4]
3400e44e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400e450:	2b02      	cmp	r3, #2
3400e452:	d10a      	bne.n	3400e46a <HAL_RCC_OscConfig+0x5ae>
3400e454:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3400e456:	2b00      	cmp	r3, #0
3400e458:	d107      	bne.n	3400e46a <HAL_RCC_OscConfig+0x5ae>
    {
      if (RCC_PLL_Enable(RCC_PLL1_CONFIG) != HAL_OK)
3400e45a:	2000      	movs	r0, #0
3400e45c:	f000 fdb4 	bl	3400efc8 <RCC_PLL_Enable>
3400e460:	4603      	mov	r3, r0
3400e462:	2b00      	cmp	r3, #0
3400e464:	d001      	beq.n	3400e46a <HAL_RCC_OscConfig+0x5ae>
      {
        return HAL_ERROR;
3400e466:	2301      	movs	r3, #1
3400e468:	e103      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL2 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL2.PLLState));

  if (pRCC_OscInitStruct->PLL2.PLLState != RCC_PLL_NONE)
3400e46a:	687b      	ldr	r3, [r7, #4]
3400e46c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e46e:	2b00      	cmp	r3, #0
3400e470:	d054      	beq.n	3400e51c <HAL_RCC_OscConfig+0x660>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2));
3400e472:	687b      	ldr	r3, [r7, #4]
3400e474:	3344      	adds	r3, #68	@ 0x44
3400e476:	4619      	mov	r1, r3
3400e478:	2001      	movs	r0, #1
3400e47a:	f000 fdd1 	bl	3400f020 <RCC_PLL_IsNewConfig>
3400e47e:	64f8      	str	r0, [r7, #76]	@ 0x4c
    uint32_t pll2_ready = LL_RCC_PLL2_IsReady();
3400e480:	f7ff fc22 	bl	3400dcc8 <LL_RCC_PLL2_IsReady>
3400e484:	64b8      	str	r0, [r7, #72]	@ 0x48
    if (new_pll_config == 1U)
3400e486:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400e488:	2b01      	cmp	r3, #1
3400e48a:	d134      	bne.n	3400e4f6 <HAL_RCC_OscConfig+0x63a>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400e48c:	f7ff fcbe 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400e490:	6478      	str	r0, [r7, #68]	@ 0x44
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400e492:	f7ff fcd9 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400e496:	6438      	str	r0, [r7, #64]	@ 0x40
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400e498:	f7ff fcf4 	bl	3400de84 <LL_RCC_IC6_GetSource>
3400e49c:	63f8      	str	r0, [r7, #60]	@ 0x3c
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400e49e:	f7ff fcff 	bl	3400dea0 <LL_RCC_IC11_GetSource>
3400e4a2:	63b8      	str	r0, [r7, #56]	@ 0x38
      /* PLL2 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL2))
3400e4a4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e4a8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400e4ac:	d105      	bne.n	3400e4ba <HAL_RCC_OscConfig+0x5fe>
3400e4ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400e4b0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e4b4:	d101      	bne.n	3400e4ba <HAL_RCC_OscConfig+0x5fe>
      {
        return HAL_ERROR;
3400e4b6:	2301      	movs	r3, #1
3400e4b8:	e0db      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }

      /* PLL2 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400e4ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e4be:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e4c2:	d10d      	bne.n	3400e4e0 <HAL_RCC_OscConfig+0x624>
3400e4c4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400e4c6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e4ca:	d007      	beq.n	3400e4dc <HAL_RCC_OscConfig+0x620>
3400e4cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400e4ce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e4d2:	d003      	beq.n	3400e4dc <HAL_RCC_OscConfig+0x620>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL2) ||
3400e4d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3400e4d6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400e4da:	d101      	bne.n	3400e4e0 <HAL_RCC_OscConfig+0x624>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL2)))
      {
        return HAL_ERROR;
3400e4dc:	2301      	movs	r3, #1
3400e4de:	e0c8      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL2 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL2_CONFIG, &(pRCC_OscInitStruct->PLL2)) != HAL_OK)
3400e4e0:	687b      	ldr	r3, [r7, #4]
3400e4e2:	3344      	adds	r3, #68	@ 0x44
3400e4e4:	4619      	mov	r1, r3
3400e4e6:	2001      	movs	r0, #1
3400e4e8:	f000 fc3e 	bl	3400ed68 <RCC_PLL_Config>
3400e4ec:	4603      	mov	r3, r0
3400e4ee:	2b00      	cmp	r3, #0
3400e4f0:	d014      	beq.n	3400e51c <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3400e4f2:	2301      	movs	r3, #1
3400e4f4:	e0bd      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL2.PLLState == RCC_PLL_ON) && (pll2_ready == 0U))
3400e4f6:	687b      	ldr	r3, [r7, #4]
3400e4f8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400e4fa:	2b02      	cmp	r3, #2
3400e4fc:	d10e      	bne.n	3400e51c <HAL_RCC_OscConfig+0x660>
3400e4fe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400e500:	2b00      	cmp	r3, #0
3400e502:	d10b      	bne.n	3400e51c <HAL_RCC_OscConfig+0x660>
    {
      if (RCC_PLL_Enable(RCC_PLL2_CONFIG) != HAL_OK)
3400e504:	2001      	movs	r0, #1
3400e506:	f000 fd5f 	bl	3400efc8 <RCC_PLL_Enable>
3400e50a:	4603      	mov	r3, r0
3400e50c:	2b00      	cmp	r3, #0
3400e50e:	d005      	beq.n	3400e51c <HAL_RCC_OscConfig+0x660>
      {
        return HAL_ERROR;
3400e510:	2301      	movs	r3, #1
3400e512:	e0ae      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
3400e514:	56028000 	.word	0x56028000
3400e518:	00018002 	.word	0x00018002

  /*-------------------------------- PLL3 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL3.PLLState));

  if (pRCC_OscInitStruct->PLL3.PLLState != RCC_PLL_NONE)
3400e51c:	687b      	ldr	r3, [r7, #4]
3400e51e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400e520:	2b00      	cmp	r3, #0
3400e522:	d050      	beq.n	3400e5c6 <HAL_RCC_OscConfig+0x70a>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3));
3400e524:	687b      	ldr	r3, [r7, #4]
3400e526:	3360      	adds	r3, #96	@ 0x60
3400e528:	4619      	mov	r1, r3
3400e52a:	2002      	movs	r0, #2
3400e52c:	f000 fd78 	bl	3400f020 <RCC_PLL_IsNewConfig>
3400e530:	6378      	str	r0, [r7, #52]	@ 0x34
    uint32_t pll3_ready = LL_RCC_PLL1_IsReady();
3400e532:	f7ff fb93 	bl	3400dc5c <LL_RCC_PLL1_IsReady>
3400e536:	6338      	str	r0, [r7, #48]	@ 0x30
    if (new_pll_config == 1U)
3400e538:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3400e53a:	2b01      	cmp	r3, #1
3400e53c:	d134      	bne.n	3400e5a8 <HAL_RCC_OscConfig+0x6ec>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400e53e:	f7ff fc65 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400e542:	62f8      	str	r0, [r7, #44]	@ 0x2c
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400e544:	f7ff fc80 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400e548:	62b8      	str	r0, [r7, #40]	@ 0x28
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400e54a:	f7ff fc9b 	bl	3400de84 <LL_RCC_IC6_GetSource>
3400e54e:	6278      	str	r0, [r7, #36]	@ 0x24
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400e550:	f7ff fca6 	bl	3400dea0 <LL_RCC_IC11_GetSource>
3400e554:	6238      	str	r0, [r7, #32]
      /* PLL3 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL3))
3400e556:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e55a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400e55e:	d105      	bne.n	3400e56c <HAL_RCC_OscConfig+0x6b0>
3400e560:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400e562:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e566:	d101      	bne.n	3400e56c <HAL_RCC_OscConfig+0x6b0>
      {
        return HAL_ERROR;
3400e568:	2301      	movs	r3, #1
3400e56a:	e082      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400e56c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e570:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e574:	d10d      	bne.n	3400e592 <HAL_RCC_OscConfig+0x6d6>
3400e576:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400e578:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e57c:	d007      	beq.n	3400e58e <HAL_RCC_OscConfig+0x6d2>
3400e57e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400e580:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e584:	d003      	beq.n	3400e58e <HAL_RCC_OscConfig+0x6d2>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL3) ||
3400e586:	6a3b      	ldr	r3, [r7, #32]
3400e588:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400e58c:	d101      	bne.n	3400e592 <HAL_RCC_OscConfig+0x6d6>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL3)))
      {
        return HAL_ERROR;
3400e58e:	2301      	movs	r3, #1
3400e590:	e06f      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL3 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL3_CONFIG, &(pRCC_OscInitStruct->PLL3)) != HAL_OK)
3400e592:	687b      	ldr	r3, [r7, #4]
3400e594:	3360      	adds	r3, #96	@ 0x60
3400e596:	4619      	mov	r1, r3
3400e598:	2002      	movs	r0, #2
3400e59a:	f000 fbe5 	bl	3400ed68 <RCC_PLL_Config>
3400e59e:	4603      	mov	r3, r0
3400e5a0:	2b00      	cmp	r3, #0
3400e5a2:	d010      	beq.n	3400e5c6 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3400e5a4:	2301      	movs	r3, #1
3400e5a6:	e064      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL3.PLLState == RCC_PLL_ON) && (pll3_ready == 0U))
3400e5a8:	687b      	ldr	r3, [r7, #4]
3400e5aa:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400e5ac:	2b02      	cmp	r3, #2
3400e5ae:	d10a      	bne.n	3400e5c6 <HAL_RCC_OscConfig+0x70a>
3400e5b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400e5b2:	2b00      	cmp	r3, #0
3400e5b4:	d107      	bne.n	3400e5c6 <HAL_RCC_OscConfig+0x70a>
    {
      if (RCC_PLL_Enable(RCC_PLL3_CONFIG) != HAL_OK)
3400e5b6:	2002      	movs	r0, #2
3400e5b8:	f000 fd06 	bl	3400efc8 <RCC_PLL_Enable>
3400e5bc:	4603      	mov	r3, r0
3400e5be:	2b00      	cmp	r3, #0
3400e5c0:	d001      	beq.n	3400e5c6 <HAL_RCC_OscConfig+0x70a>
      {
        return HAL_ERROR;
3400e5c2:	2301      	movs	r3, #1
3400e5c4:	e055      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>

  /*-------------------------------- PLL4 Configuration ----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(pRCC_OscInitStruct->PLL4.PLLState));

  if (pRCC_OscInitStruct->PLL4.PLLState != RCC_PLL_NONE)
3400e5c6:	687b      	ldr	r3, [r7, #4]
3400e5c8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400e5ca:	2b00      	cmp	r3, #0
3400e5cc:	d050      	beq.n	3400e670 <HAL_RCC_OscConfig+0x7b4>
  {
    uint32_t new_pll_config = RCC_PLL_IsNewConfig(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4));
3400e5ce:	687b      	ldr	r3, [r7, #4]
3400e5d0:	337c      	adds	r3, #124	@ 0x7c
3400e5d2:	4619      	mov	r1, r3
3400e5d4:	2003      	movs	r0, #3
3400e5d6:	f000 fd23 	bl	3400f020 <RCC_PLL_IsNewConfig>
3400e5da:	61f8      	str	r0, [r7, #28]
    uint32_t pll4_ready = LL_RCC_PLL4_IsReady();
3400e5dc:	f7ff fbe0 	bl	3400dda0 <LL_RCC_PLL4_IsReady>
3400e5e0:	61b8      	str	r0, [r7, #24]

    if (new_pll_config == 1U)
3400e5e2:	69fb      	ldr	r3, [r7, #28]
3400e5e4:	2b01      	cmp	r3, #1
3400e5e6:	d134      	bne.n	3400e652 <HAL_RCC_OscConfig+0x796>
    {
      uint32_t ic1src = LL_RCC_IC1_GetSource();
3400e5e8:	f7ff fc10 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400e5ec:	6178      	str	r0, [r7, #20]
      uint32_t ic2src = LL_RCC_IC2_GetSource();
3400e5ee:	f7ff fc2b 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400e5f2:	6138      	str	r0, [r7, #16]
      uint32_t ic6src = LL_RCC_IC6_GetSource();
3400e5f4:	f7ff fc46 	bl	3400de84 <LL_RCC_IC6_GetSource>
3400e5f8:	60f8      	str	r0, [r7, #12]
      uint32_t ic11src = LL_RCC_IC11_GetSource();
3400e5fa:	f7ff fc51 	bl	3400dea0 <LL_RCC_IC11_GetSource>
3400e5fe:	60b8      	str	r0, [r7, #8]
      /* PLL4 should not be disabled / reconfigured if used for IC1 (cpuclksrc) - return HAL_ERROR */
      if ((cpuclksrc == RCC_CPUCLKSOURCE_STATUS_IC1) && (ic1src == LL_RCC_ICCLKSOURCE_PLL4))
3400e600:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3400e604:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400e608:	d105      	bne.n	3400e616 <HAL_RCC_OscConfig+0x75a>
3400e60a:	697b      	ldr	r3, [r7, #20]
3400e60c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e610:	d101      	bne.n	3400e616 <HAL_RCC_OscConfig+0x75a>
      {
        return HAL_ERROR;
3400e612:	2301      	movs	r3, #1
3400e614:	e02d      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 should not be disabled / reconfigured if used for IC2, IC6 or IC11 (sysclksrc) - return HAL_ERROR  */
      if ((sysclksrc == RCC_SYSCLKSOURCE_STATUS_IC2_IC6_IC11) && ((ic2src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400e616:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
3400e61a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e61e:	d10d      	bne.n	3400e63c <HAL_RCC_OscConfig+0x780>
3400e620:	693b      	ldr	r3, [r7, #16]
3400e622:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e626:	d007      	beq.n	3400e638 <HAL_RCC_OscConfig+0x77c>
3400e628:	68fb      	ldr	r3, [r7, #12]
3400e62a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e62e:	d003      	beq.n	3400e638 <HAL_RCC_OscConfig+0x77c>
                                                                  (ic6src == LL_RCC_ICCLKSOURCE_PLL4) ||
3400e630:	68bb      	ldr	r3, [r7, #8]
3400e632:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400e636:	d101      	bne.n	3400e63c <HAL_RCC_OscConfig+0x780>
                                                                  (ic11src == LL_RCC_ICCLKSOURCE_PLL4)))
      {
        return HAL_ERROR;
3400e638:	2301      	movs	r3, #1
3400e63a:	e01a      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
      /* PLL4 is not used, it can be configured */
      if (RCC_PLL_Config(RCC_PLL4_CONFIG, &(pRCC_OscInitStruct->PLL4)) != HAL_OK)
3400e63c:	687b      	ldr	r3, [r7, #4]
3400e63e:	337c      	adds	r3, #124	@ 0x7c
3400e640:	4619      	mov	r1, r3
3400e642:	2003      	movs	r0, #3
3400e644:	f000 fb90 	bl	3400ed68 <RCC_PLL_Config>
3400e648:	4603      	mov	r3, r0
3400e64a:	2b00      	cmp	r3, #0
3400e64c:	d010      	beq.n	3400e670 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3400e64e:	2301      	movs	r3, #1
3400e650:	e00f      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
      }
    }
    else if ((pRCC_OscInitStruct->PLL4.PLLState == RCC_PLL_ON) && (pll4_ready == 0U))
3400e652:	687b      	ldr	r3, [r7, #4]
3400e654:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400e656:	2b02      	cmp	r3, #2
3400e658:	d10a      	bne.n	3400e670 <HAL_RCC_OscConfig+0x7b4>
3400e65a:	69bb      	ldr	r3, [r7, #24]
3400e65c:	2b00      	cmp	r3, #0
3400e65e:	d107      	bne.n	3400e670 <HAL_RCC_OscConfig+0x7b4>
    {
      if (RCC_PLL_Enable(RCC_PLL4_CONFIG) != HAL_OK)
3400e660:	2003      	movs	r0, #3
3400e662:	f000 fcb1 	bl	3400efc8 <RCC_PLL_Enable>
3400e666:	4603      	mov	r3, r0
3400e668:	2b00      	cmp	r3, #0
3400e66a:	d001      	beq.n	3400e670 <HAL_RCC_OscConfig+0x7b4>
      {
        return HAL_ERROR;
3400e66c:	2301      	movs	r3, #1
3400e66e:	e000      	b.n	3400e672 <HAL_RCC_OscConfig+0x7b6>
    {
      /* Nothing to do */
    }
  }

  return HAL_OK;
3400e670:	2300      	movs	r3, #0
}
3400e672:	4618      	mov	r0, r3
3400e674:	3788      	adds	r7, #136	@ 0x88
3400e676:	46bd      	mov	sp, r7
3400e678:	bd80      	pop	{r7, pc}
3400e67a:	bf00      	nop

3400e67c <HAL_RCC_ClockConfig>:
  *         You can use HAL_RCC_GetClockConfig() function to know which clock is
  *         currently used as system clock source.
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3400e67c:	b580      	push	{r7, lr}
3400e67e:	b084      	sub	sp, #16
3400e680:	af00      	add	r7, sp, #0
3400e682:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check Null pointer */
  if (pRCC_ClkInitStruct == NULL)
3400e684:	687b      	ldr	r3, [r7, #4]
3400e686:	2b00      	cmp	r3, #0
3400e688:	d101      	bne.n	3400e68e <HAL_RCC_ClockConfig+0x12>
  {
    return HAL_ERROR;
3400e68a:	2301      	movs	r3, #1
3400e68c:	e1f2      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
  assert_param(IS_RCC_CLOCKTYPE(pRCC_ClkInitStruct->ClockType));

  /* Increasing the BUS frequency divider ? */

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400e68e:	687b      	ldr	r3, [r7, #4]
3400e690:	681b      	ldr	r3, [r3, #0]
3400e692:	f003 0308 	and.w	r3, r3, #8
3400e696:	2b00      	cmp	r3, #0
3400e698:	d010      	beq.n	3400e6bc <HAL_RCC_ClockConfig+0x40>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400e69a:	687b      	ldr	r3, [r7, #4]
3400e69c:	691a      	ldr	r2, [r3, #16]
3400e69e:	4ba3      	ldr	r3, [pc, #652]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e6a2:	f003 0307 	and.w	r3, r3, #7
3400e6a6:	429a      	cmp	r2, r3
3400e6a8:	d908      	bls.n	3400e6bc <HAL_RCC_ClockConfig+0x40>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400e6aa:	4ba0      	ldr	r3, [pc, #640]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6ac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e6ae:	f023 0207 	bic.w	r2, r3, #7
3400e6b2:	687b      	ldr	r3, [r7, #4]
3400e6b4:	691b      	ldr	r3, [r3, #16]
3400e6b6:	499d      	ldr	r1, [pc, #628]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6b8:	4313      	orrs	r3, r2
3400e6ba:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400e6bc:	687b      	ldr	r3, [r7, #4]
3400e6be:	681b      	ldr	r3, [r3, #0]
3400e6c0:	f003 0310 	and.w	r3, r3, #16
3400e6c4:	2b00      	cmp	r3, #0
3400e6c6:	d010      	beq.n	3400e6ea <HAL_RCC_ClockConfig+0x6e>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400e6c8:	687b      	ldr	r3, [r7, #4]
3400e6ca:	695a      	ldr	r2, [r3, #20]
3400e6cc:	4b97      	ldr	r3, [pc, #604]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e6d0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400e6d4:	429a      	cmp	r2, r3
3400e6d6:	d908      	bls.n	3400e6ea <HAL_RCC_ClockConfig+0x6e>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400e6d8:	4b94      	ldr	r3, [pc, #592]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6da:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e6dc:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3400e6e0:	687b      	ldr	r3, [r7, #4]
3400e6e2:	695b      	ldr	r3, [r3, #20]
3400e6e4:	4991      	ldr	r1, [pc, #580]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6e6:	4313      	orrs	r3, r2
3400e6e8:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400e6ea:	687b      	ldr	r3, [r7, #4]
3400e6ec:	681b      	ldr	r3, [r3, #0]
3400e6ee:	f003 0320 	and.w	r3, r3, #32
3400e6f2:	2b00      	cmp	r3, #0
3400e6f4:	d010      	beq.n	3400e718 <HAL_RCC_ClockConfig+0x9c>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400e6f6:	687b      	ldr	r3, [r7, #4]
3400e6f8:	699a      	ldr	r2, [r3, #24]
3400e6fa:	4b8c      	ldr	r3, [pc, #560]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e6fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e6fe:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400e702:	429a      	cmp	r2, r3
3400e704:	d908      	bls.n	3400e718 <HAL_RCC_ClockConfig+0x9c>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400e706:	4b89      	ldr	r3, [pc, #548]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e708:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e70a:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3400e70e:	687b      	ldr	r3, [r7, #4]
3400e710:	699b      	ldr	r3, [r3, #24]
3400e712:	4986      	ldr	r1, [pc, #536]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e714:	4313      	orrs	r3, r2
3400e716:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400e718:	687b      	ldr	r3, [r7, #4]
3400e71a:	681b      	ldr	r3, [r3, #0]
3400e71c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400e720:	2b00      	cmp	r3, #0
3400e722:	d010      	beq.n	3400e746 <HAL_RCC_ClockConfig+0xca>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) > (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400e724:	687b      	ldr	r3, [r7, #4]
3400e726:	69da      	ldr	r2, [r3, #28]
3400e728:	4b80      	ldr	r3, [pc, #512]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e72a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e72c:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400e730:	429a      	cmp	r2, r3
3400e732:	d908      	bls.n	3400e746 <HAL_RCC_ClockConfig+0xca>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400e734:	4b7d      	ldr	r3, [pc, #500]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e736:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e738:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400e73c:	687b      	ldr	r3, [r7, #4]
3400e73e:	69db      	ldr	r3, [r3, #28]
3400e740:	497a      	ldr	r1, [pc, #488]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e742:	4313      	orrs	r3, r2
3400e744:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400e746:	687b      	ldr	r3, [r7, #4]
3400e748:	681b      	ldr	r3, [r3, #0]
3400e74a:	f003 0304 	and.w	r3, r3, #4
3400e74e:	2b00      	cmp	r3, #0
3400e750:	d010      	beq.n	3400e774 <HAL_RCC_ClockConfig+0xf8>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) > (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400e752:	687b      	ldr	r3, [r7, #4]
3400e754:	68da      	ldr	r2, [r3, #12]
3400e756:	4b75      	ldr	r3, [pc, #468]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e758:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e75a:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400e75e:	429a      	cmp	r2, r3
3400e760:	d908      	bls.n	3400e774 <HAL_RCC_ClockConfig+0xf8>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400e762:	4b72      	ldr	r3, [pc, #456]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e764:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e766:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3400e76a:	687b      	ldr	r3, [r7, #4]
3400e76c:	68db      	ldr	r3, [r3, #12]
3400e76e:	496f      	ldr	r1, [pc, #444]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e770:	4313      	orrs	r3, r2
3400e772:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*------------------------- CPUCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_CPUCLK) == RCC_CLOCKTYPE_CPUCLK)
3400e774:	687b      	ldr	r3, [r7, #4]
3400e776:	681b      	ldr	r3, [r3, #0]
3400e778:	f003 0301 	and.w	r3, r3, #1
3400e77c:	2b00      	cmp	r3, #0
3400e77e:	d063      	beq.n	3400e848 <HAL_RCC_ClockConfig+0x1cc>
  {
    assert_param(IS_RCC_CPUCLKSOURCE(pRCC_ClkInitStruct->CPUCLKSource));

    /* HSE is selected as CPU Clock Source */
    if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_HSE)
3400e780:	687b      	ldr	r3, [r7, #4]
3400e782:	685b      	ldr	r3, [r3, #4]
3400e784:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
3400e788:	d106      	bne.n	3400e798 <HAL_RCC_ClockConfig+0x11c>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3400e78a:	f7ff f91d 	bl	3400d9c8 <LL_RCC_HSE_IsReady>
3400e78e:	4603      	mov	r3, r0
3400e790:	2b00      	cmp	r3, #0
3400e792:	d134      	bne.n	3400e7fe <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3400e794:	2301      	movs	r3, #1
3400e796:	e16d      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_IC1)
3400e798:	687b      	ldr	r3, [r7, #4]
3400e79a:	685b      	ldr	r3, [r3, #4]
3400e79c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3400e7a0:	d11a      	bne.n	3400e7d8 <HAL_RCC_ClockConfig+0x15c>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC1Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC1Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC1 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC1_GetSource(), pRCC_ClkInitStruct->IC1Selection.ClockSelection) != 1U)
3400e7a2:	f7ff fb33 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400e7a6:	4602      	mov	r2, r0
3400e7a8:	687b      	ldr	r3, [r7, #4]
3400e7aa:	6a1b      	ldr	r3, [r3, #32]
3400e7ac:	4619      	mov	r1, r3
3400e7ae:	4610      	mov	r0, r2
3400e7b0:	f000 fcea 	bl	3400f188 <RCC_IC_CheckPLLSources>
3400e7b4:	4603      	mov	r3, r0
3400e7b6:	2b01      	cmp	r3, #1
3400e7b8:	d001      	beq.n	3400e7be <HAL_RCC_ClockConfig+0x142>
      {
        return HAL_ERROR;
3400e7ba:	2301      	movs	r3, #1
3400e7bc:	e15a      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC1 source and divider */
      WRITE_REG(RCC->IC1CFGR, pRCC_ClkInitStruct->IC1Selection.ClockSelection | \
3400e7be:	687b      	ldr	r3, [r7, #4]
3400e7c0:	6a1a      	ldr	r2, [r3, #32]
3400e7c2:	687b      	ldr	r3, [r7, #4]
3400e7c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e7c6:	3b01      	subs	r3, #1
3400e7c8:	041b      	lsls	r3, r3, #16
3400e7ca:	4958      	ldr	r1, [pc, #352]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e7cc:	4313      	orrs	r3, r2
3400e7ce:	f8c1 30c4 	str.w	r3, [r1, #196]	@ 0xc4
                ((pRCC_ClkInitStruct->IC1Selection.ClockDivider - 1U) << RCC_IC1CFGR_IC1INT_Pos));

      /* Enable IC1 */
      LL_RCC_IC1_Enable();
3400e7d2:	f7ff fb0d 	bl	3400ddf0 <LL_RCC_IC1_Enable>
3400e7d6:	e012      	b.n	3400e7fe <HAL_RCC_ClockConfig+0x182>
    }
    /* MSI is selected as CPU Clock Source */
    else if (pRCC_ClkInitStruct->CPUCLKSource == RCC_CPUCLKSOURCE_MSI)
3400e7d8:	687b      	ldr	r3, [r7, #4]
3400e7da:	685b      	ldr	r3, [r3, #4]
3400e7dc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3400e7e0:	d106      	bne.n	3400e7f0 <HAL_RCC_ClockConfig+0x174>
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3400e7e2:	f7ff f989 	bl	3400daf8 <LL_RCC_MSI_IsReady>
3400e7e6:	4603      	mov	r3, r0
3400e7e8:	2b00      	cmp	r3, #0
3400e7ea:	d108      	bne.n	3400e7fe <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3400e7ec:	2301      	movs	r3, #1
3400e7ee:	e141      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
    }
    /* HSI is selected as CPU Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3400e7f0:	f7ff f91a 	bl	3400da28 <LL_RCC_HSI_IsReady>
3400e7f4:	4603      	mov	r3, r0
3400e7f6:	2b00      	cmp	r3, #0
3400e7f8:	d101      	bne.n	3400e7fe <HAL_RCC_ClockConfig+0x182>
      {
        return HAL_ERROR;
3400e7fa:	2301      	movs	r3, #1
3400e7fc:	e13a      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the CPU clock */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_CPUSW, pRCC_ClkInitStruct->CPUCLKSource);
3400e7fe:	4b4b      	ldr	r3, [pc, #300]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e800:	6a1b      	ldr	r3, [r3, #32]
3400e802:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
3400e806:	687b      	ldr	r3, [r7, #4]
3400e808:	685b      	ldr	r3, [r3, #4]
3400e80a:	4948      	ldr	r1, [pc, #288]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e80c:	4313      	orrs	r3, r2
3400e80e:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400e810:	f7f6 fa0d 	bl	34004c2e <HAL_GetTick>
3400e814:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400e816:	e00a      	b.n	3400e82e <HAL_RCC_ClockConfig+0x1b2>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400e818:	f7f6 fa09 	bl	34004c2e <HAL_GetTick>
3400e81c:	4602      	mov	r2, r0
3400e81e:	68fb      	ldr	r3, [r7, #12]
3400e820:	1ad3      	subs	r3, r2, r3
3400e822:	f241 3288 	movw	r2, #5000	@ 0x1388
3400e826:	4293      	cmp	r3, r2
3400e828:	d901      	bls.n	3400e82e <HAL_RCC_ClockConfig+0x1b2>
      {
        return HAL_TIMEOUT;
3400e82a:	2303      	movs	r3, #3
3400e82c:	e122      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_CPUCLK_SOURCE() != (pRCC_ClkInitStruct->CPUCLKSource << 4U))
3400e82e:	f7ff f9eb 	bl	3400dc08 <LL_RCC_GetCpuClkSource>
3400e832:	4602      	mov	r2, r0
3400e834:	687b      	ldr	r3, [r7, #4]
3400e836:	685b      	ldr	r3, [r3, #4]
3400e838:	011b      	lsls	r3, r3, #4
3400e83a:	429a      	cmp	r2, r3
3400e83c:	d1ec      	bne.n	3400e818 <HAL_RCC_ClockConfig+0x19c>
      }
    }

    /* Update the SystemCoreClock global variable with CPU clock */
    SystemCoreClock = HAL_RCC_GetCpuClockFreq();
3400e83e:	f000 f921 	bl	3400ea84 <HAL_RCC_GetCpuClockFreq>
3400e842:	4603      	mov	r3, r0
3400e844:	4a3a      	ldr	r2, [pc, #232]	@ (3400e930 <HAL_RCC_ClockConfig+0x2b4>)
3400e846:	6013      	str	r3, [r2, #0]

  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if ((pRCC_ClkInitStruct->ClockType & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
3400e848:	687b      	ldr	r3, [r7, #4]
3400e84a:	681b      	ldr	r3, [r3, #0]
3400e84c:	f003 0302 	and.w	r3, r3, #2
3400e850:	2b00      	cmp	r3, #0
3400e852:	f000 8096 	beq.w	3400e982 <HAL_RCC_ClockConfig+0x306>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(pRCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System bus clock source */
    if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
3400e856:	687b      	ldr	r3, [r7, #4]
3400e858:	689b      	ldr	r3, [r3, #8]
3400e85a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3400e85e:	d106      	bne.n	3400e86e <HAL_RCC_ClockConfig+0x1f2>
    {
      /* Check the HSE ready flag */
      if (LL_RCC_HSE_IsReady() == 0U)
3400e860:	f7ff f8b2 	bl	3400d9c8 <LL_RCC_HSE_IsReady>
3400e864:	4603      	mov	r3, r0
3400e866:	2b00      	cmp	r3, #0
3400e868:	d16b      	bne.n	3400e942 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3400e86a:	2301      	movs	r3, #1
3400e86c:	e102      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
    }
    /* PLL output is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_IC2_IC6_IC11)
3400e86e:	687b      	ldr	r3, [r7, #4]
3400e870:	689b      	ldr	r3, [r3, #8]
3400e872:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
3400e876:	d14d      	bne.n	3400e914 <HAL_RCC_ClockConfig+0x298>
      assert_param(IS_RCC_ICCLKSOURCE(pRCC_ClkInitStruct->IC11Selection.ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(pRCC_ClkInitStruct->IC11Selection.ClockDivider));

      /* ICx clock switch requires both origin and destination clock source to be active */
      /* Check IC2/IC6/IC11 origin and target clock sources availability */
      if (RCC_IC_CheckPLLSources(LL_RCC_IC2_GetSource(), pRCC_ClkInitStruct->IC2Selection.ClockSelection) != 1U)
3400e878:	f7ff fae6 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400e87c:	4602      	mov	r2, r0
3400e87e:	687b      	ldr	r3, [r7, #4]
3400e880:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3400e882:	4619      	mov	r1, r3
3400e884:	4610      	mov	r0, r2
3400e886:	f000 fc7f 	bl	3400f188 <RCC_IC_CheckPLLSources>
3400e88a:	4603      	mov	r3, r0
3400e88c:	2b01      	cmp	r3, #1
3400e88e:	d001      	beq.n	3400e894 <HAL_RCC_ClockConfig+0x218>
      {
        return HAL_ERROR;
3400e890:	2301      	movs	r3, #1
3400e892:	e0ef      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC6_GetSource(), pRCC_ClkInitStruct->IC6Selection.ClockSelection) != 1U)
3400e894:	f7ff faf6 	bl	3400de84 <LL_RCC_IC6_GetSource>
3400e898:	4602      	mov	r2, r0
3400e89a:	687b      	ldr	r3, [r7, #4]
3400e89c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400e89e:	4619      	mov	r1, r3
3400e8a0:	4610      	mov	r0, r2
3400e8a2:	f000 fc71 	bl	3400f188 <RCC_IC_CheckPLLSources>
3400e8a6:	4603      	mov	r3, r0
3400e8a8:	2b01      	cmp	r3, #1
3400e8aa:	d001      	beq.n	3400e8b0 <HAL_RCC_ClockConfig+0x234>
      {
        return HAL_ERROR;
3400e8ac:	2301      	movs	r3, #1
3400e8ae:	e0e1      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
      if (RCC_IC_CheckPLLSources(LL_RCC_IC11_GetSource(), pRCC_ClkInitStruct->IC11Selection.ClockSelection) != 1U)
3400e8b0:	f7ff faf6 	bl	3400dea0 <LL_RCC_IC11_GetSource>
3400e8b4:	4602      	mov	r2, r0
3400e8b6:	687b      	ldr	r3, [r7, #4]
3400e8b8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400e8ba:	4619      	mov	r1, r3
3400e8bc:	4610      	mov	r0, r2
3400e8be:	f000 fc63 	bl	3400f188 <RCC_IC_CheckPLLSources>
3400e8c2:	4603      	mov	r3, r0
3400e8c4:	2b01      	cmp	r3, #1
3400e8c6:	d001      	beq.n	3400e8cc <HAL_RCC_ClockConfig+0x250>
      {
        return HAL_ERROR;
3400e8c8:	2301      	movs	r3, #1
3400e8ca:	e0d3      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }

      /* Configure IC2, IC6 and IC11 sources and dividers */
      WRITE_REG(RCC->IC2CFGR, pRCC_ClkInitStruct->IC2Selection.ClockSelection | \
3400e8cc:	687b      	ldr	r3, [r7, #4]
3400e8ce:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400e8d0:	687b      	ldr	r3, [r7, #4]
3400e8d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400e8d4:	3b01      	subs	r3, #1
3400e8d6:	041b      	lsls	r3, r3, #16
3400e8d8:	4914      	ldr	r1, [pc, #80]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e8da:	4313      	orrs	r3, r2
3400e8dc:	f8c1 30c8 	str.w	r3, [r1, #200]	@ 0xc8
                ((pRCC_ClkInitStruct->IC2Selection.ClockDivider - 1U) << RCC_IC2CFGR_IC2INT_Pos));
      WRITE_REG(RCC->IC6CFGR, pRCC_ClkInitStruct->IC6Selection.ClockSelection | \
3400e8e0:	687b      	ldr	r3, [r7, #4]
3400e8e2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400e8e4:	687b      	ldr	r3, [r7, #4]
3400e8e6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400e8e8:	3b01      	subs	r3, #1
3400e8ea:	041b      	lsls	r3, r3, #16
3400e8ec:	490f      	ldr	r1, [pc, #60]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e8ee:	4313      	orrs	r3, r2
3400e8f0:	f8c1 30d8 	str.w	r3, [r1, #216]	@ 0xd8
                ((pRCC_ClkInitStruct->IC6Selection.ClockDivider - 1U) << RCC_IC6CFGR_IC6INT_Pos));
      WRITE_REG(RCC->IC11CFGR, pRCC_ClkInitStruct->IC11Selection.ClockSelection | \
3400e8f4:	687b      	ldr	r3, [r7, #4]
3400e8f6:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3400e8f8:	687b      	ldr	r3, [r7, #4]
3400e8fa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400e8fc:	3b01      	subs	r3, #1
3400e8fe:	041b      	lsls	r3, r3, #16
3400e900:	490a      	ldr	r1, [pc, #40]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e902:	4313      	orrs	r3, r2
3400e904:	f8c1 30ec 	str.w	r3, [r1, #236]	@ 0xec
                ((pRCC_ClkInitStruct->IC11Selection.ClockDivider - 1U) << RCC_IC11CFGR_IC11INT_Pos));

      /* Require to have IC2, IC6 and IC11 outputs enabled */
      WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC2ENS | RCC_DIVENSR_IC6ENS | RCC_DIVENSR_IC11ENS);
3400e908:	4b08      	ldr	r3, [pc, #32]	@ (3400e92c <HAL_RCC_ClockConfig+0x2b0>)
3400e90a:	f240 4222 	movw	r2, #1058	@ 0x422
3400e90e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
3400e912:	e016      	b.n	3400e942 <HAL_RCC_ClockConfig+0x2c6>
    }
    /* HSI is selected as System bus clock source */
    else if (pRCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
3400e914:	687b      	ldr	r3, [r7, #4]
3400e916:	689b      	ldr	r3, [r3, #8]
3400e918:	2b00      	cmp	r3, #0
3400e91a:	d10b      	bne.n	3400e934 <HAL_RCC_ClockConfig+0x2b8>
    {
      /* Check the HSI ready flag */
      if (LL_RCC_HSI_IsReady() == 0U)
3400e91c:	f7ff f884 	bl	3400da28 <LL_RCC_HSI_IsReady>
3400e920:	4603      	mov	r3, r0
3400e922:	2b00      	cmp	r3, #0
3400e924:	d10d      	bne.n	3400e942 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3400e926:	2301      	movs	r3, #1
3400e928:	e0a4      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
3400e92a:	bf00      	nop
3400e92c:	56028000 	.word	0x56028000
3400e930:	340413c0 	.word	0x340413c0
    }
    /* MSI is selected as System bus clock source */
    else
    {
      /* Check the MSI ready flag */
      if (LL_RCC_MSI_IsReady() == 0U)
3400e934:	f7ff f8e0 	bl	3400daf8 <LL_RCC_MSI_IsReady>
3400e938:	4603      	mov	r3, r0
3400e93a:	2b00      	cmp	r3, #0
3400e93c:	d101      	bne.n	3400e942 <HAL_RCC_ClockConfig+0x2c6>
      {
        return HAL_ERROR;
3400e93e:	2301      	movs	r3, #1
3400e940:	e098      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
      }
    }

    /* Switch the system bus clocks */
    MODIFY_REG(RCC->CFGR1, RCC_CFGR1_SYSSW, pRCC_ClkInitStruct->SYSCLKSource);
3400e942:	4b4e      	ldr	r3, [pc, #312]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e944:	6a1b      	ldr	r3, [r3, #32]
3400e946:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400e94a:	687b      	ldr	r3, [r7, #4]
3400e94c:	689b      	ldr	r3, [r3, #8]
3400e94e:	494b      	ldr	r1, [pc, #300]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e950:	4313      	orrs	r3, r2
3400e952:	620b      	str	r3, [r1, #32]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400e954:	f7f6 f96b 	bl	34004c2e <HAL_GetTick>
3400e958:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3400e95a:	e00a      	b.n	3400e972 <HAL_RCC_ClockConfig+0x2f6>
    {
      if ((HAL_GetTick() - tickstart) > RCC_CLOCKSWITCH_TIMEOUT_VALUE)
3400e95c:	f7f6 f967 	bl	34004c2e <HAL_GetTick>
3400e960:	4602      	mov	r2, r0
3400e962:	68fb      	ldr	r3, [r7, #12]
3400e964:	1ad3      	subs	r3, r2, r3
3400e966:	f241 3288 	movw	r2, #5000	@ 0x1388
3400e96a:	4293      	cmp	r3, r2
3400e96c:	d901      	bls.n	3400e972 <HAL_RCC_ClockConfig+0x2f6>
      {
        return HAL_TIMEOUT;
3400e96e:	2303      	movs	r3, #3
3400e970:	e080      	b.n	3400ea74 <HAL_RCC_ClockConfig+0x3f8>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (pRCC_ClkInitStruct->SYSCLKSource << 4U))
3400e972:	f7ff f957 	bl	3400dc24 <LL_RCC_GetSysClkSource>
3400e976:	4602      	mov	r2, r0
3400e978:	687b      	ldr	r3, [r7, #4]
3400e97a:	689b      	ldr	r3, [r3, #8]
3400e97c:	011b      	lsls	r3, r3, #4
3400e97e:	429a      	cmp	r2, r3
3400e980:	d1ec      	bne.n	3400e95c <HAL_RCC_ClockConfig+0x2e0>
  }

  /* Decreasing the BUS frequency divider ? */

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
3400e982:	687b      	ldr	r3, [r7, #4]
3400e984:	681b      	ldr	r3, [r3, #0]
3400e986:	f003 0304 	and.w	r3, r3, #4
3400e98a:	2b00      	cmp	r3, #0
3400e98c:	d010      	beq.n	3400e9b0 <HAL_RCC_ClockConfig+0x334>
  {
    assert_param(IS_RCC_HCLK(pRCC_ClkInitStruct->AHBCLKDivider));
    if ((pRCC_ClkInitStruct->AHBCLKDivider) < (RCC->CFGR2 & RCC_CFGR2_HPRE))
3400e98e:	687b      	ldr	r3, [r7, #4]
3400e990:	68da      	ldr	r2, [r3, #12]
3400e992:	4b3a      	ldr	r3, [pc, #232]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e994:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e996:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
3400e99a:	429a      	cmp	r2, r3
3400e99c:	d208      	bcs.n	3400e9b0 <HAL_RCC_ClockConfig+0x334>
    {
      /* Set the new HCLK clock divider */
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_HPRE, pRCC_ClkInitStruct->AHBCLKDivider);
3400e99e:	4b37      	ldr	r3, [pc, #220]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9a0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e9a2:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
3400e9a6:	687b      	ldr	r3, [r7, #4]
3400e9a8:	68db      	ldr	r3, [r3, #12]
3400e9aa:	4934      	ldr	r1, [pc, #208]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9ac:	4313      	orrs	r3, r2
3400e9ae:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
3400e9b0:	687b      	ldr	r3, [r7, #4]
3400e9b2:	681b      	ldr	r3, [r3, #0]
3400e9b4:	f003 0308 	and.w	r3, r3, #8
3400e9b8:	2b00      	cmp	r3, #0
3400e9ba:	d010      	beq.n	3400e9de <HAL_RCC_ClockConfig+0x362>
  {
    assert_param(IS_RCC_PCLK1(pRCC_ClkInitStruct->APB1CLKDivider));
    if ((pRCC_ClkInitStruct->APB1CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE1))
3400e9bc:	687b      	ldr	r3, [r7, #4]
3400e9be:	691a      	ldr	r2, [r3, #16]
3400e9c0:	4b2e      	ldr	r3, [pc, #184]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e9c4:	f003 0307 	and.w	r3, r3, #7
3400e9c8:	429a      	cmp	r2, r3
3400e9ca:	d208      	bcs.n	3400e9de <HAL_RCC_ClockConfig+0x362>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE1, (pRCC_ClkInitStruct->APB1CLKDivider));
3400e9cc:	4b2b      	ldr	r3, [pc, #172]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e9d0:	f023 0207 	bic.w	r2, r3, #7
3400e9d4:	687b      	ldr	r3, [r7, #4]
3400e9d6:	691b      	ldr	r3, [r3, #16]
3400e9d8:	4928      	ldr	r1, [pc, #160]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9da:	4313      	orrs	r3, r2
3400e9dc:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
3400e9de:	687b      	ldr	r3, [r7, #4]
3400e9e0:	681b      	ldr	r3, [r3, #0]
3400e9e2:	f003 0310 	and.w	r3, r3, #16
3400e9e6:	2b00      	cmp	r3, #0
3400e9e8:	d010      	beq.n	3400ea0c <HAL_RCC_ClockConfig+0x390>
  {
    assert_param(IS_RCC_PCLK2(pRCC_ClkInitStruct->APB2CLKDivider));
    if ((pRCC_ClkInitStruct->APB2CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE2))
3400e9ea:	687b      	ldr	r3, [r7, #4]
3400e9ec:	695a      	ldr	r2, [r3, #20]
3400e9ee:	4b23      	ldr	r3, [pc, #140]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9f0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e9f2:	f003 0370 	and.w	r3, r3, #112	@ 0x70
3400e9f6:	429a      	cmp	r2, r3
3400e9f8:	d208      	bcs.n	3400ea0c <HAL_RCC_ClockConfig+0x390>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE2, (pRCC_ClkInitStruct->APB2CLKDivider));
3400e9fa:	4b20      	ldr	r3, [pc, #128]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400e9fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400e9fe:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
3400ea02:	687b      	ldr	r3, [r7, #4]
3400ea04:	695b      	ldr	r3, [r3, #20]
3400ea06:	491d      	ldr	r1, [pc, #116]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea08:	4313      	orrs	r3, r2
3400ea0a:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK4 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK4) == RCC_CLOCKTYPE_PCLK4)
3400ea0c:	687b      	ldr	r3, [r7, #4]
3400ea0e:	681b      	ldr	r3, [r3, #0]
3400ea10:	f003 0320 	and.w	r3, r3, #32
3400ea14:	2b00      	cmp	r3, #0
3400ea16:	d010      	beq.n	3400ea3a <HAL_RCC_ClockConfig+0x3be>
  {
    assert_param(IS_RCC_PCLK4(pRCC_ClkInitStruct->APB4CLKDivider));
    if ((pRCC_ClkInitStruct->APB4CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE4))
3400ea18:	687b      	ldr	r3, [r7, #4]
3400ea1a:	699a      	ldr	r2, [r3, #24]
3400ea1c:	4b17      	ldr	r3, [pc, #92]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea1e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ea20:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
3400ea24:	429a      	cmp	r2, r3
3400ea26:	d208      	bcs.n	3400ea3a <HAL_RCC_ClockConfig+0x3be>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE4, (pRCC_ClkInitStruct->APB4CLKDivider));
3400ea28:	4b14      	ldr	r3, [pc, #80]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea2a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ea2c:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
3400ea30:	687b      	ldr	r3, [r7, #4]
3400ea32:	699b      	ldr	r3, [r3, #24]
3400ea34:	4911      	ldr	r1, [pc, #68]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea36:	4313      	orrs	r3, r2
3400ea38:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /*-------------------------- PCLK5 Configuration ---------------------------*/
  if (((pRCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK5) == RCC_CLOCKTYPE_PCLK5)
3400ea3a:	687b      	ldr	r3, [r7, #4]
3400ea3c:	681b      	ldr	r3, [r3, #0]
3400ea3e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400ea42:	2b00      	cmp	r3, #0
3400ea44:	d010      	beq.n	3400ea68 <HAL_RCC_ClockConfig+0x3ec>
  {
    assert_param(IS_RCC_PCLK5(pRCC_ClkInitStruct->APB5CLKDivider));
    if ((pRCC_ClkInitStruct->APB5CLKDivider) < (RCC->CFGR2 & RCC_CFGR2_PPRE5))
3400ea46:	687b      	ldr	r3, [r7, #4]
3400ea48:	69da      	ldr	r2, [r3, #28]
3400ea4a:	4b0c      	ldr	r3, [pc, #48]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea4c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ea4e:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
3400ea52:	429a      	cmp	r2, r3
3400ea54:	d208      	bcs.n	3400ea68 <HAL_RCC_ClockConfig+0x3ec>
    {
      MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PPRE5, (pRCC_ClkInitStruct->APB5CLKDivider));
3400ea56:	4b09      	ldr	r3, [pc, #36]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea58:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ea5a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400ea5e:	687b      	ldr	r3, [r7, #4]
3400ea60:	69db      	ldr	r3, [r3, #28]
3400ea62:	4906      	ldr	r1, [pc, #24]	@ (3400ea7c <HAL_RCC_ClockConfig+0x400>)
3400ea64:	4313      	orrs	r3, r2
3400ea66:	624b      	str	r3, [r1, #36]	@ 0x24
    }
  }

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(uwTickPrio);
3400ea68:	4b05      	ldr	r3, [pc, #20]	@ (3400ea80 <HAL_RCC_ClockConfig+0x404>)
3400ea6a:	681b      	ldr	r3, [r3, #0]
3400ea6c:	4618      	mov	r0, r3
3400ea6e:	f7f6 f8d3 	bl	34004c18 <HAL_InitTick>
3400ea72:	4603      	mov	r3, r0
}
3400ea74:	4618      	mov	r0, r3
3400ea76:	3710      	adds	r7, #16
3400ea78:	46bd      	mov	sp, r7
3400ea7a:	bd80      	pop	{r7, pc}
3400ea7c:	56028000 	.word	0x56028000
3400ea80:	340413c4 	.word	0x340413c4

3400ea84 <HAL_RCC_GetCpuClockFreq>:
  *         will be incorrect.
  *
  * @retval CPUCLK frequency
  */
uint32_t HAL_RCC_GetCpuClockFreq(void)
{
3400ea84:	b580      	push	{r7, lr}
3400ea86:	b082      	sub	sp, #8
3400ea88:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3400ea8a:	2300      	movs	r3, #0
3400ea8c:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetCpuClkSource())
3400ea8e:	f7ff f8bb 	bl	3400dc08 <LL_RCC_GetCpuClkSource>
3400ea92:	4603      	mov	r3, r0
3400ea94:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400ea98:	d025      	beq.n	3400eae6 <HAL_RCC_GetCpuClockFreq+0x62>
3400ea9a:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3400ea9e:	d860      	bhi.n	3400eb62 <HAL_RCC_GetCpuClockFreq+0xde>
3400eaa0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400eaa4:	d01c      	beq.n	3400eae0 <HAL_RCC_GetCpuClockFreq+0x5c>
3400eaa6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3400eaaa:	d85a      	bhi.n	3400eb62 <HAL_RCC_GetCpuClockFreq+0xde>
3400eaac:	2b00      	cmp	r3, #0
3400eaae:	d003      	beq.n	3400eab8 <HAL_RCC_GetCpuClockFreq+0x34>
3400eab0:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3400eab4:	d009      	beq.n	3400eaca <HAL_RCC_GetCpuClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400eab6:	e054      	b.n	3400eb62 <HAL_RCC_GetCpuClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400eab8:	f7fe ffdc 	bl	3400da74 <LL_RCC_HSI_GetDivider>
3400eabc:	4603      	mov	r3, r0
3400eabe:	09db      	lsrs	r3, r3, #7
3400eac0:	4a2b      	ldr	r2, [pc, #172]	@ (3400eb70 <HAL_RCC_GetCpuClockFreq+0xec>)
3400eac2:	fa22 f303 	lsr.w	r3, r2, r3
3400eac6:	607b      	str	r3, [r7, #4]
      break;
3400eac8:	e04c      	b.n	3400eb64 <HAL_RCC_GetCpuClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3400eaca:	f7ff f83b 	bl	3400db44 <LL_RCC_MSI_GetFrequency>
3400eace:	4603      	mov	r3, r0
3400ead0:	2b00      	cmp	r3, #0
3400ead2:	d102      	bne.n	3400eada <HAL_RCC_GetCpuClockFreq+0x56>
        frequency = MSI_VALUE;
3400ead4:	4b27      	ldr	r3, [pc, #156]	@ (3400eb74 <HAL_RCC_GetCpuClockFreq+0xf0>)
3400ead6:	607b      	str	r3, [r7, #4]
      break;
3400ead8:	e044      	b.n	3400eb64 <HAL_RCC_GetCpuClockFreq+0xe0>
        frequency = 16000000UL;
3400eada:	4b27      	ldr	r3, [pc, #156]	@ (3400eb78 <HAL_RCC_GetCpuClockFreq+0xf4>)
3400eadc:	607b      	str	r3, [r7, #4]
      break;
3400eade:	e041      	b.n	3400eb64 <HAL_RCC_GetCpuClockFreq+0xe0>
      frequency = HSE_VALUE;
3400eae0:	4b26      	ldr	r3, [pc, #152]	@ (3400eb7c <HAL_RCC_GetCpuClockFreq+0xf8>)
3400eae2:	607b      	str	r3, [r7, #4]
      break;
3400eae4:	e03e      	b.n	3400eb64 <HAL_RCC_GetCpuClockFreq+0xe0>
      ic_divider = LL_RCC_IC1_GetDivider();
3400eae6:	f7ff f99f 	bl	3400de28 <LL_RCC_IC1_GetDivider>
3400eaea:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC1_GetSource())
3400eaec:	f7ff f98e 	bl	3400de0c <LL_RCC_IC1_GetSource>
3400eaf0:	4603      	mov	r3, r0
3400eaf2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eaf6:	d029      	beq.n	3400eb4c <HAL_RCC_GetCpuClockFreq+0xc8>
3400eaf8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eafc:	d82f      	bhi.n	3400eb5e <HAL_RCC_GetCpuClockFreq+0xda>
3400eafe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eb02:	d01a      	beq.n	3400eb3a <HAL_RCC_GetCpuClockFreq+0xb6>
3400eb04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eb08:	d829      	bhi.n	3400eb5e <HAL_RCC_GetCpuClockFreq+0xda>
3400eb0a:	2b00      	cmp	r3, #0
3400eb0c:	d003      	beq.n	3400eb16 <HAL_RCC_GetCpuClockFreq+0x92>
3400eb0e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400eb12:	d009      	beq.n	3400eb28 <HAL_RCC_GetCpuClockFreq+0xa4>
          break;
3400eb14:	e023      	b.n	3400eb5e <HAL_RCC_GetCpuClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400eb16:	f004 feab 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
3400eb1a:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400eb1c:	687a      	ldr	r2, [r7, #4]
3400eb1e:	683b      	ldr	r3, [r7, #0]
3400eb20:	fbb2 f3f3 	udiv	r3, r2, r3
3400eb24:	607b      	str	r3, [r7, #4]
          break;
3400eb26:	e01b      	b.n	3400eb60 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400eb28:	f004 fee8 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3400eb2c:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400eb2e:	687a      	ldr	r2, [r7, #4]
3400eb30:	683b      	ldr	r3, [r7, #0]
3400eb32:	fbb2 f3f3 	udiv	r3, r2, r3
3400eb36:	607b      	str	r3, [r7, #4]
          break;
3400eb38:	e012      	b.n	3400eb60 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400eb3a:	f004 ff25 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3400eb3e:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400eb40:	687a      	ldr	r2, [r7, #4]
3400eb42:	683b      	ldr	r3, [r7, #0]
3400eb44:	fbb2 f3f3 	udiv	r3, r2, r3
3400eb48:	607b      	str	r3, [r7, #4]
          break;
3400eb4a:	e009      	b.n	3400eb60 <HAL_RCC_GetCpuClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400eb4c:	f004 ff62 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3400eb50:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400eb52:	687a      	ldr	r2, [r7, #4]
3400eb54:	683b      	ldr	r3, [r7, #0]
3400eb56:	fbb2 f3f3 	udiv	r3, r2, r3
3400eb5a:	607b      	str	r3, [r7, #4]
          break;
3400eb5c:	e000      	b.n	3400eb60 <HAL_RCC_GetCpuClockFreq+0xdc>
          break;
3400eb5e:	bf00      	nop
      break;
3400eb60:	e000      	b.n	3400eb64 <HAL_RCC_GetCpuClockFreq+0xe0>
      break;
3400eb62:	bf00      	nop
  }

  return frequency;
3400eb64:	687b      	ldr	r3, [r7, #4]
}
3400eb66:	4618      	mov	r0, r3
3400eb68:	3708      	adds	r7, #8
3400eb6a:	46bd      	mov	sp, r7
3400eb6c:	bd80      	pop	{r7, pc}
3400eb6e:	bf00      	nop
3400eb70:	03d09000 	.word	0x03d09000
3400eb74:	003d0900 	.word	0x003d0900
3400eb78:	00f42400 	.word	0x00f42400
3400eb7c:	02dc6c00 	.word	0x02dc6c00

3400eb80 <HAL_RCC_GetSysClockFreq>:
  *         will be incorrect.
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
3400eb80:	b580      	push	{r7, lr}
3400eb82:	b082      	sub	sp, #8
3400eb84:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
3400eb86:	2300      	movs	r3, #0
3400eb88:	607b      	str	r3, [r7, #4]
  uint32_t ic_divider;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
3400eb8a:	f7ff f84b 	bl	3400dc24 <LL_RCC_GetSysClkSource>
3400eb8e:	4603      	mov	r3, r0
3400eb90:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eb94:	d025      	beq.n	3400ebe2 <HAL_RCC_GetSysClockFreq+0x62>
3400eb96:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400eb9a:	d860      	bhi.n	3400ec5e <HAL_RCC_GetSysClockFreq+0xde>
3400eb9c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eba0:	d01c      	beq.n	3400ebdc <HAL_RCC_GetSysClockFreq+0x5c>
3400eba2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400eba6:	d85a      	bhi.n	3400ec5e <HAL_RCC_GetSysClockFreq+0xde>
3400eba8:	2b00      	cmp	r3, #0
3400ebaa:	d003      	beq.n	3400ebb4 <HAL_RCC_GetSysClockFreq+0x34>
3400ebac:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ebb0:	d009      	beq.n	3400ebc6 <HAL_RCC_GetSysClockFreq+0x46>
      }
      break;

    default:
      /* Unexpected case */
      break;
3400ebb2:	e054      	b.n	3400ec5e <HAL_RCC_GetSysClockFreq+0xde>
      frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
3400ebb4:	f7fe ff5e 	bl	3400da74 <LL_RCC_HSI_GetDivider>
3400ebb8:	4603      	mov	r3, r0
3400ebba:	09db      	lsrs	r3, r3, #7
3400ebbc:	4a2b      	ldr	r2, [pc, #172]	@ (3400ec6c <HAL_RCC_GetSysClockFreq+0xec>)
3400ebbe:	fa22 f303 	lsr.w	r3, r2, r3
3400ebc2:	607b      	str	r3, [r7, #4]
      break;
3400ebc4:	e04c      	b.n	3400ec60 <HAL_RCC_GetSysClockFreq+0xe0>
      if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
3400ebc6:	f7fe ffbd 	bl	3400db44 <LL_RCC_MSI_GetFrequency>
3400ebca:	4603      	mov	r3, r0
3400ebcc:	2b00      	cmp	r3, #0
3400ebce:	d102      	bne.n	3400ebd6 <HAL_RCC_GetSysClockFreq+0x56>
        frequency = MSI_VALUE;
3400ebd0:	4b27      	ldr	r3, [pc, #156]	@ (3400ec70 <HAL_RCC_GetSysClockFreq+0xf0>)
3400ebd2:	607b      	str	r3, [r7, #4]
      break;
3400ebd4:	e044      	b.n	3400ec60 <HAL_RCC_GetSysClockFreq+0xe0>
        frequency = 16000000UL;
3400ebd6:	4b27      	ldr	r3, [pc, #156]	@ (3400ec74 <HAL_RCC_GetSysClockFreq+0xf4>)
3400ebd8:	607b      	str	r3, [r7, #4]
      break;
3400ebda:	e041      	b.n	3400ec60 <HAL_RCC_GetSysClockFreq+0xe0>
      frequency = HSE_VALUE;
3400ebdc:	4b26      	ldr	r3, [pc, #152]	@ (3400ec78 <HAL_RCC_GetSysClockFreq+0xf8>)
3400ebde:	607b      	str	r3, [r7, #4]
      break;
3400ebe0:	e03e      	b.n	3400ec60 <HAL_RCC_GetSysClockFreq+0xe0>
      ic_divider = LL_RCC_IC2_GetDivider();
3400ebe2:	f7ff f93f 	bl	3400de64 <LL_RCC_IC2_GetDivider>
3400ebe6:	6038      	str	r0, [r7, #0]
      switch (LL_RCC_IC2_GetSource())
3400ebe8:	f7ff f92e 	bl	3400de48 <LL_RCC_IC2_GetSource>
3400ebec:	4603      	mov	r3, r0
3400ebee:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ebf2:	d029      	beq.n	3400ec48 <HAL_RCC_GetSysClockFreq+0xc8>
3400ebf4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400ebf8:	d82f      	bhi.n	3400ec5a <HAL_RCC_GetSysClockFreq+0xda>
3400ebfa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ebfe:	d01a      	beq.n	3400ec36 <HAL_RCC_GetSysClockFreq+0xb6>
3400ec00:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400ec04:	d829      	bhi.n	3400ec5a <HAL_RCC_GetSysClockFreq+0xda>
3400ec06:	2b00      	cmp	r3, #0
3400ec08:	d003      	beq.n	3400ec12 <HAL_RCC_GetSysClockFreq+0x92>
3400ec0a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400ec0e:	d009      	beq.n	3400ec24 <HAL_RCC_GetSysClockFreq+0xa4>
          break;
3400ec10:	e023      	b.n	3400ec5a <HAL_RCC_GetSysClockFreq+0xda>
          frequency = HAL_RCCEx_GetPLL1CLKFreq();
3400ec12:	f004 fe2d 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
3400ec16:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400ec18:	687a      	ldr	r2, [r7, #4]
3400ec1a:	683b      	ldr	r3, [r7, #0]
3400ec1c:	fbb2 f3f3 	udiv	r3, r2, r3
3400ec20:	607b      	str	r3, [r7, #4]
          break;
3400ec22:	e01b      	b.n	3400ec5c <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL2CLKFreq();
3400ec24:	f004 fe6a 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3400ec28:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400ec2a:	687a      	ldr	r2, [r7, #4]
3400ec2c:	683b      	ldr	r3, [r7, #0]
3400ec2e:	fbb2 f3f3 	udiv	r3, r2, r3
3400ec32:	607b      	str	r3, [r7, #4]
          break;
3400ec34:	e012      	b.n	3400ec5c <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL3CLKFreq();
3400ec36:	f004 fea7 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3400ec3a:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400ec3c:	687a      	ldr	r2, [r7, #4]
3400ec3e:	683b      	ldr	r3, [r7, #0]
3400ec40:	fbb2 f3f3 	udiv	r3, r2, r3
3400ec44:	607b      	str	r3, [r7, #4]
          break;
3400ec46:	e009      	b.n	3400ec5c <HAL_RCC_GetSysClockFreq+0xdc>
          frequency = HAL_RCCEx_GetPLL4CLKFreq();
3400ec48:	f004 fee4 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3400ec4c:	6078      	str	r0, [r7, #4]
          frequency = frequency / ic_divider;
3400ec4e:	687a      	ldr	r2, [r7, #4]
3400ec50:	683b      	ldr	r3, [r7, #0]
3400ec52:	fbb2 f3f3 	udiv	r3, r2, r3
3400ec56:	607b      	str	r3, [r7, #4]
          break;
3400ec58:	e000      	b.n	3400ec5c <HAL_RCC_GetSysClockFreq+0xdc>
          break;
3400ec5a:	bf00      	nop
      break;
3400ec5c:	e000      	b.n	3400ec60 <HAL_RCC_GetSysClockFreq+0xe0>
      break;
3400ec5e:	bf00      	nop
  }

  return frequency;
3400ec60:	687b      	ldr	r3, [r7, #4]
}
3400ec62:	4618      	mov	r0, r3
3400ec64:	3708      	adds	r7, #8
3400ec66:	46bd      	mov	sp, r7
3400ec68:	bd80      	pop	{r7, pc}
3400ec6a:	bf00      	nop
3400ec6c:	03d09000 	.word	0x03d09000
3400ec70:	003d0900 	.word	0x003d0900
3400ec74:	00f42400 	.word	0x00f42400
3400ec78:	02dc6c00 	.word	0x02dc6c00

3400ec7c <HAL_RCC_GetClockConfig>:
  * @param  pRCC_ClkInitStruct  Pointer to an RCC_ClkInitTypeDef structure that
  *         will return the configuration.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *pRCC_ClkInitStruct)
{
3400ec7c:	b480      	push	{r7}
3400ec7e:	b085      	sub	sp, #20
3400ec80:	af00      	add	r7, sp, #0
3400ec82:	6078      	str	r0, [r7, #4]
  uint32_t cfgr_value;

  /* Set all possible values for the Clock type parameter --------------------*/
  pRCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_CPUCLK | RCC_CLOCKTYPE_SYSCLK | \
3400ec84:	687b      	ldr	r3, [r7, #4]
3400ec86:	227f      	movs	r2, #127	@ 0x7f
3400ec88:	601a      	str	r2, [r3, #0]
                                  RCC_CLOCKTYPE_HCLK   | \
                                  RCC_CLOCKTYPE_PCLK1  | RCC_CLOCKTYPE_PCLK2 | \
                                  RCC_CLOCKTYPE_PCLK4  | RCC_CLOCKTYPE_PCLK5;

  /* Get the configuration register 1 value */
  cfgr_value = RCC->CFGR1;
3400ec8a:	4b36      	ldr	r3, [pc, #216]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ec8c:	6a1b      	ldr	r3, [r3, #32]
3400ec8e:	60fb      	str	r3, [r7, #12]

  /* Get the active CPU source -----------------------------------------------*/
  pRCC_ClkInitStruct->CPUCLKSource = (cfgr_value & RCC_CFGR1_CPUSWS) >> 4U;
3400ec90:	68fb      	ldr	r3, [r7, #12]
3400ec92:	091b      	lsrs	r3, r3, #4
3400ec94:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
3400ec98:	687b      	ldr	r3, [r7, #4]
3400ec9a:	605a      	str	r2, [r3, #4]

  /* Get the active SYSCLK bus source ----------------------------------------*/
  pRCC_ClkInitStruct->SYSCLKSource = (cfgr_value & RCC_CFGR1_SYSSWS) >> 4U;
3400ec9c:	68fb      	ldr	r3, [r7, #12]
3400ec9e:	091b      	lsrs	r3, r3, #4
3400eca0:	f003 7240 	and.w	r2, r3, #50331648	@ 0x3000000
3400eca4:	687b      	ldr	r3, [r7, #4]
3400eca6:	609a      	str	r2, [r3, #8]

  /* Get the configuration register 2 value */
  cfgr_value = RCC->CFGR2;
3400eca8:	4b2e      	ldr	r3, [pc, #184]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ecaa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400ecac:	60fb      	str	r3, [r7, #12]

  /* Get the HCLK configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->AHBCLKDivider = (cfgr_value & RCC_CFGR2_HPRE);
3400ecae:	68fb      	ldr	r3, [r7, #12]
3400ecb0:	f403 02e0 	and.w	r2, r3, #7340032	@ 0x700000
3400ecb4:	687b      	ldr	r3, [r7, #4]
3400ecb6:	60da      	str	r2, [r3, #12]

  /* Get the APB1 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB1CLKDivider = (cfgr_value & RCC_CFGR2_PPRE1);
3400ecb8:	68fb      	ldr	r3, [r7, #12]
3400ecba:	f003 0207 	and.w	r2, r3, #7
3400ecbe:	687b      	ldr	r3, [r7, #4]
3400ecc0:	611a      	str	r2, [r3, #16]

  /* Get the APB2 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB2CLKDivider = (cfgr_value & RCC_CFGR2_PPRE2);
3400ecc2:	68fb      	ldr	r3, [r7, #12]
3400ecc4:	f003 0270 	and.w	r2, r3, #112	@ 0x70
3400ecc8:	687b      	ldr	r3, [r7, #4]
3400ecca:	615a      	str	r2, [r3, #20]

  /* Get the APB4 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB4CLKDivider = (cfgr_value & RCC_CFGR2_PPRE4);
3400eccc:	68fb      	ldr	r3, [r7, #12]
3400ecce:	f403 42e0 	and.w	r2, r3, #28672	@ 0x7000
3400ecd2:	687b      	ldr	r3, [r7, #4]
3400ecd4:	619a      	str	r2, [r3, #24]

  /* Get the APB5 configuration ----------------------------------------------*/
  pRCC_ClkInitStruct->APB5CLKDivider = (cfgr_value & RCC_CFGR2_PPRE5);
3400ecd6:	68fb      	ldr	r3, [r7, #12]
3400ecd8:	f403 22e0 	and.w	r2, r3, #458752	@ 0x70000
3400ecdc:	687b      	ldr	r3, [r7, #4]
3400ecde:	61da      	str	r2, [r3, #28]

  /* Get the IC1 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC1CFGR;
3400ece0:	4b20      	ldr	r3, [pc, #128]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ece2:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3400ece6:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC1Selection.ClockSelection = cfgr_value & RCC_IC1CFGR_IC1SEL;
3400ece8:	68fb      	ldr	r3, [r7, #12]
3400ecea:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3400ecee:	687b      	ldr	r3, [r7, #4]
3400ecf0:	621a      	str	r2, [r3, #32]
  pRCC_ClkInitStruct->IC1Selection.ClockDivider = ((cfgr_value & RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1U;
3400ecf2:	68fb      	ldr	r3, [r7, #12]
3400ecf4:	0c1b      	lsrs	r3, r3, #16
3400ecf6:	b2db      	uxtb	r3, r3
3400ecf8:	1c5a      	adds	r2, r3, #1
3400ecfa:	687b      	ldr	r3, [r7, #4]
3400ecfc:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Get the IC2 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC2CFGR;
3400ecfe:	4b19      	ldr	r3, [pc, #100]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ed00:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
3400ed04:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC2Selection.ClockSelection = cfgr_value & RCC_IC2CFGR_IC2SEL;
3400ed06:	68fb      	ldr	r3, [r7, #12]
3400ed08:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3400ed0c:	687b      	ldr	r3, [r7, #4]
3400ed0e:	629a      	str	r2, [r3, #40]	@ 0x28
  pRCC_ClkInitStruct->IC2Selection.ClockDivider = ((cfgr_value & RCC_IC2CFGR_IC2INT) >> RCC_IC2CFGR_IC2INT_Pos) + 1U;
3400ed10:	68fb      	ldr	r3, [r7, #12]
3400ed12:	0c1b      	lsrs	r3, r3, #16
3400ed14:	b2db      	uxtb	r3, r3
3400ed16:	1c5a      	adds	r2, r3, #1
3400ed18:	687b      	ldr	r3, [r7, #4]
3400ed1a:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Get the IC6 configuration -----------------------------------------------*/
  cfgr_value = RCC->IC6CFGR;
3400ed1c:	4b11      	ldr	r3, [pc, #68]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ed1e:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400ed22:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC6Selection.ClockSelection = cfgr_value & RCC_IC6CFGR_IC6SEL;
3400ed24:	68fb      	ldr	r3, [r7, #12]
3400ed26:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3400ed2a:	687b      	ldr	r3, [r7, #4]
3400ed2c:	631a      	str	r2, [r3, #48]	@ 0x30
  pRCC_ClkInitStruct->IC6Selection.ClockDivider = ((cfgr_value & RCC_IC6CFGR_IC6INT) >> RCC_IC6CFGR_IC6INT_Pos) + 1U;
3400ed2e:	68fb      	ldr	r3, [r7, #12]
3400ed30:	0c1b      	lsrs	r3, r3, #16
3400ed32:	b2db      	uxtb	r3, r3
3400ed34:	1c5a      	adds	r2, r3, #1
3400ed36:	687b      	ldr	r3, [r7, #4]
3400ed38:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Get the IC11 configuration ----------------------------------------------*/
  cfgr_value = RCC->IC11CFGR;
3400ed3a:	4b0a      	ldr	r3, [pc, #40]	@ (3400ed64 <HAL_RCC_GetClockConfig+0xe8>)
3400ed3c:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
3400ed40:	60fb      	str	r3, [r7, #12]
  pRCC_ClkInitStruct->IC11Selection.ClockSelection = cfgr_value & RCC_IC11CFGR_IC11SEL;
3400ed42:	68fb      	ldr	r3, [r7, #12]
3400ed44:	f003 5240 	and.w	r2, r3, #805306368	@ 0x30000000
3400ed48:	687b      	ldr	r3, [r7, #4]
3400ed4a:	639a      	str	r2, [r3, #56]	@ 0x38
  pRCC_ClkInitStruct->IC11Selection.ClockDivider = ((cfgr_value & RCC_IC11CFGR_IC11INT) >> RCC_IC11CFGR_IC11INT_Pos) + 1U;
3400ed4c:	68fb      	ldr	r3, [r7, #12]
3400ed4e:	0c1b      	lsrs	r3, r3, #16
3400ed50:	b2db      	uxtb	r3, r3
3400ed52:	1c5a      	adds	r2, r3, #1
3400ed54:	687b      	ldr	r3, [r7, #4]
3400ed56:	63da      	str	r2, [r3, #60]	@ 0x3c
}
3400ed58:	bf00      	nop
3400ed5a:	3714      	adds	r7, #20
3400ed5c:	46bd      	mov	sp, r7
3400ed5e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ed62:	4770      	bx	lr
3400ed64:	56028000 	.word	0x56028000

3400ed68 <RCC_PLL_Config>:
  * @note   PLL is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Config(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3400ed68:	b580      	push	{r7, lr}
3400ed6a:	b088      	sub	sp, #32
3400ed6c:	af00      	add	r7, sp, #0
3400ed6e:	6078      	str	r0, [r7, #4]
3400ed70:	6039      	str	r1, [r7, #0]
  __IO uint32_t *p_rcc_pll_cfgr1_reg;
  __IO uint32_t *p_rcc_pll_cfgr2_reg;
  __IO uint32_t *p_rcc_pll_cfgr3_reg;
  HAL_StatusTypeDef ret = HAL_OK;
3400ed72:	2300      	movs	r3, #0
3400ed74:	77fb      	strb	r3, [r7, #31]
  uint32_t tickstart;

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400ed76:	687b      	ldr	r3, [r7, #4]
3400ed78:	011a      	lsls	r2, r3, #4
3400ed7a:	4b8e      	ldr	r3, [pc, #568]	@ (3400efb4 <RCC_PLL_Config+0x24c>)
3400ed7c:	4413      	add	r3, r2
3400ed7e:	61bb      	str	r3, [r7, #24]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400ed80:	687b      	ldr	r3, [r7, #4]
3400ed82:	011a      	lsls	r2, r3, #4
3400ed84:	4b8c      	ldr	r3, [pc, #560]	@ (3400efb8 <RCC_PLL_Config+0x250>)
3400ed86:	4413      	add	r3, r2
3400ed88:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3400ed8a:	687b      	ldr	r3, [r7, #4]
3400ed8c:	011a      	lsls	r2, r3, #4
3400ed8e:	4b8b      	ldr	r3, [pc, #556]	@ (3400efbc <RCC_PLL_Config+0x254>)
3400ed90:	4413      	add	r3, r2
3400ed92:	613b      	str	r3, [r7, #16]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */
  if (pPLLInit->PLLState == RCC_PLL_ON)
3400ed94:	683b      	ldr	r3, [r7, #0]
3400ed96:	681b      	ldr	r3, [r3, #0]
3400ed98:	2b02      	cmp	r3, #2
3400ed9a:	f040 8091 	bne.w	3400eec0 <RCC_PLL_Config+0x158>
    assert_param(IS_RCC_PLLN_VALUE(pPLLInit->PLLN));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP1));
    assert_param(IS_RCC_PLLP_VALUE(pPLLInit->PLLP2));

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400ed9e:	4a88      	ldr	r2, [pc, #544]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400eda0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400eda4:	687b      	ldr	r3, [r7, #4]
3400eda6:	fa01 f303 	lsl.w	r3, r1, r3
3400edaa:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400edae:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400edb0:	f7f5 ff3d 	bl	34004c2e <HAL_GetTick>
3400edb4:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400edb6:	e008      	b.n	3400edca <RCC_PLL_Config+0x62>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400edb8:	f7f5 ff39 	bl	34004c2e <HAL_GetTick>
3400edbc:	4602      	mov	r2, r0
3400edbe:	68fb      	ldr	r3, [r7, #12]
3400edc0:	1ad3      	subs	r3, r2, r3
3400edc2:	2b01      	cmp	r3, #1
3400edc4:	d901      	bls.n	3400edca <RCC_PLL_Config+0x62>
      {
        return HAL_TIMEOUT;
3400edc6:	2303      	movs	r3, #3
3400edc8:	e0f0      	b.n	3400efac <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400edca:	4b7d      	ldr	r3, [pc, #500]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400edcc:	685a      	ldr	r2, [r3, #4]
3400edce:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400edd2:	687b      	ldr	r3, [r7, #4]
3400edd4:	fa01 f303 	lsl.w	r3, r1, r3
3400edd8:	401a      	ands	r2, r3
3400edda:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400edde:	687b      	ldr	r3, [r7, #4]
3400ede0:	fa01 f303 	lsl.w	r3, r1, r3
3400ede4:	429a      	cmp	r2, r3
3400ede6:	d0e7      	beq.n	3400edb8 <RCC_PLL_Config+0x50>
      }
    }

    /* Ensure PLLxMODSSDIS='1' */
    SET_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODSSDIS);
3400ede8:	693b      	ldr	r3, [r7, #16]
3400edea:	681b      	ldr	r3, [r3, #0]
3400edec:	f043 0204 	orr.w	r2, r3, #4
3400edf0:	693b      	ldr	r3, [r7, #16]
3400edf2:	601a      	str	r2, [r3, #0]

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3400edf4:	69bb      	ldr	r3, [r7, #24]
3400edf6:	681b      	ldr	r3, [r3, #0]
3400edf8:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3400edfc:	69bb      	ldr	r3, [r7, #24]
3400edfe:	601a      	str	r2, [r3, #0]

    /* Configure the PLLx clock source, multiplication and division factors. */
    MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN), \
3400ee00:	69bb      	ldr	r3, [r7, #24]
3400ee02:	681a      	ldr	r2, [r3, #0]
3400ee04:	4b6f      	ldr	r3, [pc, #444]	@ (3400efc4 <RCC_PLL_Config+0x25c>)
3400ee06:	4013      	ands	r3, r2
3400ee08:	683a      	ldr	r2, [r7, #0]
3400ee0a:	6851      	ldr	r1, [r2, #4]
3400ee0c:	683a      	ldr	r2, [r7, #0]
3400ee0e:	6892      	ldr	r2, [r2, #8]
3400ee10:	0512      	lsls	r2, r2, #20
3400ee12:	4311      	orrs	r1, r2
3400ee14:	683a      	ldr	r2, [r7, #0]
3400ee16:	6912      	ldr	r2, [r2, #16]
3400ee18:	0212      	lsls	r2, r2, #8
3400ee1a:	430a      	orrs	r2, r1
3400ee1c:	431a      	orrs	r2, r3
3400ee1e:	69bb      	ldr	r3, [r7, #24]
3400ee20:	601a      	str	r2, [r3, #0]
               (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
                | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)));
    MODIFY_REG(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2), \
3400ee22:	693b      	ldr	r3, [r7, #16]
3400ee24:	681b      	ldr	r3, [r3, #0]
3400ee26:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
3400ee2a:	683b      	ldr	r3, [r7, #0]
3400ee2c:	695b      	ldr	r3, [r3, #20]
3400ee2e:	06d9      	lsls	r1, r3, #27
3400ee30:	683b      	ldr	r3, [r7, #0]
3400ee32:	699b      	ldr	r3, [r3, #24]
3400ee34:	061b      	lsls	r3, r3, #24
3400ee36:	430b      	orrs	r3, r1
3400ee38:	431a      	orrs	r2, r3
3400ee3a:	693b      	ldr	r3, [r7, #16]
3400ee3c:	601a      	str	r2, [r3, #0]
               ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)));

    /* Configure PLLx DIVNFRAC */
    MODIFY_REG(*p_rcc_pll_cfgr2_reg, RCC_PLL1CFGR2_PLL1DIVNFRAC, \
3400ee3e:	697b      	ldr	r3, [r7, #20]
3400ee40:	681b      	ldr	r3, [r3, #0]
3400ee42:	f003 427f 	and.w	r2, r3, #4278190080	@ 0xff000000
3400ee46:	683b      	ldr	r3, [r7, #0]
3400ee48:	68db      	ldr	r3, [r3, #12]
3400ee4a:	431a      	orrs	r2, r3
3400ee4c:	697b      	ldr	r3, [r7, #20]
3400ee4e:	601a      	str	r2, [r3, #0]
               pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);

    /* Clear PLLxMODDSEN (Also clear in Fractional Mode to ensure the latch of updated FRAC value when set again) */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1MODDSEN);
3400ee50:	693b      	ldr	r3, [r7, #16]
3400ee52:	681b      	ldr	r3, [r3, #0]
3400ee54:	f023 0208 	bic.w	r2, r3, #8
3400ee58:	693b      	ldr	r3, [r7, #16]
3400ee5a:	601a      	str	r2, [r3, #0]

    /* Fractional Mode specificities Management */
    if (pPLLInit->PLLFractional != 0U)
3400ee5c:	683b      	ldr	r3, [r7, #0]
3400ee5e:	68db      	ldr	r3, [r3, #12]
3400ee60:	2b00      	cmp	r3, #0
3400ee62:	d005      	beq.n	3400ee70 <RCC_PLL_Config+0x108>
    {
      /* Set PLLxMODDSEN and DACEN */
      SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODDSEN | RCC_PLL1CFGR3_PLL1DACEN));
3400ee64:	693b      	ldr	r3, [r7, #16]
3400ee66:	681b      	ldr	r3, [r3, #0]
3400ee68:	f043 020a 	orr.w	r2, r3, #10
3400ee6c:	693b      	ldr	r3, [r7, #16]
3400ee6e:	601a      	str	r2, [r3, #0]
    }

    /* Ensure PLLxMODSSRST='1' and Enable PLLx post divider output */
    SET_BIT(*p_rcc_pll_cfgr3_reg, (RCC_PLL1CFGR3_PLL1MODSSRST | RCC_PLL1CFGR3_PLL1PDIVEN));
3400ee70:	693b      	ldr	r3, [r7, #16]
3400ee72:	681b      	ldr	r3, [r3, #0]
3400ee74:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3400ee78:	f043 0301 	orr.w	r3, r3, #1
3400ee7c:	693a      	ldr	r2, [r7, #16]
3400ee7e:	6013      	str	r3, [r2, #0]

    /* Enable the PLLx */
    WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400ee80:	4a4f      	ldr	r2, [pc, #316]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400ee82:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ee86:	687b      	ldr	r3, [r7, #4]
3400ee88:	fa01 f303 	lsl.w	r3, r1, r3
3400ee8c:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400ee90:	f7f5 fecd 	bl	34004c2e <HAL_GetTick>
3400ee94:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is ready */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400ee96:	e008      	b.n	3400eeaa <RCC_PLL_Config+0x142>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400ee98:	f7f5 fec9 	bl	34004c2e <HAL_GetTick>
3400ee9c:	4602      	mov	r2, r0
3400ee9e:	68fb      	ldr	r3, [r7, #12]
3400eea0:	1ad3      	subs	r3, r2, r3
3400eea2:	2b01      	cmp	r3, #1
3400eea4:	d901      	bls.n	3400eeaa <RCC_PLL_Config+0x142>
      {
        return HAL_TIMEOUT;
3400eea6:	2303      	movs	r3, #3
3400eea8:	e080      	b.n	3400efac <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400eeaa:	4b45      	ldr	r3, [pc, #276]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400eeac:	685a      	ldr	r2, [r3, #4]
3400eeae:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400eeb2:	687b      	ldr	r3, [r7, #4]
3400eeb4:	fa01 f303 	lsl.w	r3, r1, r3
3400eeb8:	4013      	ands	r3, r2
3400eeba:	2b00      	cmp	r3, #0
3400eebc:	d0ec      	beq.n	3400ee98 <RCC_PLL_Config+0x130>
3400eebe:	e074      	b.n	3400efaa <RCC_PLL_Config+0x242>
      }
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_BYPASS)
3400eec0:	683b      	ldr	r3, [r7, #0]
3400eec2:	681b      	ldr	r3, [r3, #0]
3400eec4:	2b03      	cmp	r3, #3
3400eec6:	d13b      	bne.n	3400ef40 <RCC_PLL_Config+0x1d8>
  {
    assert_param(IS_RCC_PLLSOURCE(pPLLInit->PLLSource));

    /* Check selected source is ready */
    if (RCC_PLL_Source_IsReady(pPLLInit->PLLSource) == 1U)
3400eec8:	683b      	ldr	r3, [r7, #0]
3400eeca:	685b      	ldr	r3, [r3, #4]
3400eecc:	4618      	mov	r0, r3
3400eece:	f000 f921 	bl	3400f114 <RCC_PLL_Source_IsReady>
3400eed2:	4603      	mov	r3, r0
3400eed4:	2b01      	cmp	r3, #1
3400eed6:	d130      	bne.n	3400ef3a <RCC_PLL_Config+0x1d2>
    {
      /* Ensure PLLx is disabled */
      WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400eed8:	4a39      	ldr	r2, [pc, #228]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400eeda:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400eede:	687b      	ldr	r3, [r7, #4]
3400eee0:	fa01 f303 	lsl.w	r3, r1, r3
3400eee4:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400eee8:	6013      	str	r3, [r2, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
3400eeea:	f7f5 fea0 	bl	34004c2e <HAL_GetTick>
3400eeee:	60f8      	str	r0, [r7, #12]

      /* Wait till PLLx is disabled */
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400eef0:	e008      	b.n	3400ef04 <RCC_PLL_Config+0x19c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400eef2:	f7f5 fe9c 	bl	34004c2e <HAL_GetTick>
3400eef6:	4602      	mov	r2, r0
3400eef8:	68fb      	ldr	r3, [r7, #12]
3400eefa:	1ad3      	subs	r3, r2, r3
3400eefc:	2b01      	cmp	r3, #1
3400eefe:	d901      	bls.n	3400ef04 <RCC_PLL_Config+0x19c>
        {
          return HAL_TIMEOUT;
3400ef00:	2303      	movs	r3, #3
3400ef02:	e053      	b.n	3400efac <RCC_PLL_Config+0x244>
      while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400ef04:	4b2e      	ldr	r3, [pc, #184]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400ef06:	685a      	ldr	r2, [r3, #4]
3400ef08:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ef0c:	687b      	ldr	r3, [r7, #4]
3400ef0e:	fa01 f303 	lsl.w	r3, r1, r3
3400ef12:	401a      	ands	r2, r3
3400ef14:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ef18:	687b      	ldr	r3, [r7, #4]
3400ef1a:	fa01 f303 	lsl.w	r3, r1, r3
3400ef1e:	429a      	cmp	r2, r3
3400ef20:	d0e7      	beq.n	3400eef2 <RCC_PLL_Config+0x18a>
        }
      }

      /* Set bypass mode with selected source */
      MODIFY_REG(*p_rcc_pll_cfgr1_reg, (RCC_PLL1CFGR1_PLL1BYP | RCC_PLL1CFGR1_PLL1SEL), \
3400ef22:	69bb      	ldr	r3, [r7, #24]
3400ef24:	681b      	ldr	r3, [r3, #0]
3400ef26:	f023 42f0 	bic.w	r2, r3, #2013265920	@ 0x78000000
3400ef2a:	683b      	ldr	r3, [r7, #0]
3400ef2c:	685b      	ldr	r3, [r3, #4]
3400ef2e:	4313      	orrs	r3, r2
3400ef30:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
3400ef34:	69bb      	ldr	r3, [r7, #24]
3400ef36:	601a      	str	r2, [r3, #0]
3400ef38:	e037      	b.n	3400efaa <RCC_PLL_Config+0x242>
                 (RCC_PLL1CFGR1_PLL1BYP | pPLLInit->PLLSource));
    }
    else
    {
      ret = HAL_ERROR;
3400ef3a:	2301      	movs	r3, #1
3400ef3c:	77fb      	strb	r3, [r7, #31]
3400ef3e:	e034      	b.n	3400efaa <RCC_PLL_Config+0x242>
    }
  }
  else if (pPLLInit->PLLState == RCC_PLL_OFF)
3400ef40:	683b      	ldr	r3, [r7, #0]
3400ef42:	681b      	ldr	r3, [r3, #0]
3400ef44:	2b01      	cmp	r3, #1
3400ef46:	d130      	bne.n	3400efaa <RCC_PLL_Config+0x242>
  {
    /* Disable PLLx post divider output */
    CLEAR_BIT(*p_rcc_pll_cfgr3_reg, RCC_PLL1CFGR3_PLL1PDIVEN);
3400ef48:	693b      	ldr	r3, [r7, #16]
3400ef4a:	681b      	ldr	r3, [r3, #0]
3400ef4c:	f023 4280 	bic.w	r2, r3, #1073741824	@ 0x40000000
3400ef50:	693b      	ldr	r3, [r7, #16]
3400ef52:	601a      	str	r2, [r3, #0]

    /* Ensure PLLx is disabled */
    WRITE_REG(RCC->CCR, RCC_CCR_PLL1ONC << PLLnumber);
3400ef54:	4a1a      	ldr	r2, [pc, #104]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400ef56:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ef5a:	687b      	ldr	r3, [r7, #4]
3400ef5c:	fa01 f303 	lsl.w	r3, r1, r3
3400ef60:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
3400ef64:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
3400ef66:	f7f5 fe62 	bl	34004c2e <HAL_GetTick>
3400ef6a:	60f8      	str	r0, [r7, #12]

    /* Wait till PLLx is disabled */
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400ef6c:	e008      	b.n	3400ef80 <RCC_PLL_Config+0x218>
    {
      if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400ef6e:	f7f5 fe5e 	bl	34004c2e <HAL_GetTick>
3400ef72:	4602      	mov	r2, r0
3400ef74:	68fb      	ldr	r3, [r7, #12]
3400ef76:	1ad3      	subs	r3, r2, r3
3400ef78:	2b01      	cmp	r3, #1
3400ef7a:	d901      	bls.n	3400ef80 <RCC_PLL_Config+0x218>
      {
        return HAL_TIMEOUT;
3400ef7c:	2303      	movs	r3, #3
3400ef7e:	e015      	b.n	3400efac <RCC_PLL_Config+0x244>
    while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400ef80:	4b0f      	ldr	r3, [pc, #60]	@ (3400efc0 <RCC_PLL_Config+0x258>)
3400ef82:	685a      	ldr	r2, [r3, #4]
3400ef84:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ef88:	687b      	ldr	r3, [r7, #4]
3400ef8a:	fa01 f303 	lsl.w	r3, r1, r3
3400ef8e:	401a      	ands	r2, r3
3400ef90:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400ef94:	687b      	ldr	r3, [r7, #4]
3400ef96:	fa01 f303 	lsl.w	r3, r1, r3
3400ef9a:	429a      	cmp	r2, r3
3400ef9c:	d0e7      	beq.n	3400ef6e <RCC_PLL_Config+0x206>
      }
    }

    /* Clear bypass mode */
    CLEAR_BIT(*p_rcc_pll_cfgr1_reg, RCC_PLL1CFGR1_PLL1BYP);
3400ef9e:	69bb      	ldr	r3, [r7, #24]
3400efa0:	681b      	ldr	r3, [r3, #0]
3400efa2:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
3400efa6:	69bb      	ldr	r3, [r7, #24]
3400efa8:	601a      	str	r2, [r3, #0]
  else
  {
    /* Nothing to do */
  }

  return ret;
3400efaa:	7ffb      	ldrb	r3, [r7, #31]
}
3400efac:	4618      	mov	r0, r3
3400efae:	3720      	adds	r7, #32
3400efb0:	46bd      	mov	sp, r7
3400efb2:	bd80      	pop	{r7, pc}
3400efb4:	56028080 	.word	0x56028080
3400efb8:	56028084 	.word	0x56028084
3400efbc:	56028088 	.word	0x56028088
3400efc0:	56028000 	.word	0x56028000
3400efc4:	8c0000ff 	.word	0x8c0000ff

3400efc8 <RCC_PLL_Enable>:
  * @param  PLLnumber PLL number to enable
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_PLL_Enable(uint32_t PLLnumber)
{
3400efc8:	b580      	push	{r7, lr}
3400efca:	b084      	sub	sp, #16
3400efcc:	af00      	add	r7, sp, #0
3400efce:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
3400efd0:	2300      	movs	r3, #0
3400efd2:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart;

  /* Enable the PLLx */
  WRITE_REG(RCC->CSR, RCC_CSR_PLL1ONS << PLLnumber);
3400efd4:	4a11      	ldr	r2, [pc, #68]	@ (3400f01c <RCC_PLL_Enable+0x54>)
3400efd6:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400efda:	687b      	ldr	r3, [r7, #4]
3400efdc:	fa01 f303 	lsl.w	r3, r1, r3
3400efe0:	f8c2 3800 	str.w	r3, [r2, #2048]	@ 0x800

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
3400efe4:	f7f5 fe23 	bl	34004c2e <HAL_GetTick>
3400efe8:	60b8      	str	r0, [r7, #8]

  /* Wait till PLLx is ready */
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400efea:	e008      	b.n	3400effe <RCC_PLL_Enable+0x36>
  {
    if ((HAL_GetTick() - tickstart) > RCC_PLL_TIMEOUT_VALUE)
3400efec:	f7f5 fe1f 	bl	34004c2e <HAL_GetTick>
3400eff0:	4602      	mov	r2, r0
3400eff2:	68bb      	ldr	r3, [r7, #8]
3400eff4:	1ad3      	subs	r3, r2, r3
3400eff6:	2b01      	cmp	r3, #1
3400eff8:	d901      	bls.n	3400effe <RCC_PLL_Enable+0x36>
    {
      return HAL_TIMEOUT;
3400effa:	2303      	movs	r3, #3
3400effc:	e00a      	b.n	3400f014 <RCC_PLL_Enable+0x4c>
  while (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == 0U)
3400effe:	4b07      	ldr	r3, [pc, #28]	@ (3400f01c <RCC_PLL_Enable+0x54>)
3400f000:	685a      	ldr	r2, [r3, #4]
3400f002:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400f006:	687b      	ldr	r3, [r7, #4]
3400f008:	fa01 f303 	lsl.w	r3, r1, r3
3400f00c:	4013      	ands	r3, r2
3400f00e:	2b00      	cmp	r3, #0
3400f010:	d0ec      	beq.n	3400efec <RCC_PLL_Enable+0x24>
    }
  }

  return ret;
3400f012:	7bfb      	ldrb	r3, [r7, #15]
}
3400f014:	4618      	mov	r0, r3
3400f016:	3710      	adds	r7, #16
3400f018:	46bd      	mov	sp, r7
3400f01a:	bd80      	pop	{r7, pc}
3400f01c:	56028000 	.word	0x56028000

3400f020 <RCC_PLL_IsNewConfig>:
  * @param  pPLLInit Pointer to an RCC_PLLInitTypeDef structure that
  *                  contains the configuration parameters.  *
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_IsNewConfig(uint32_t PLLnumber, const RCC_PLLInitTypeDef *pPLLInit)
{
3400f020:	b480      	push	{r7}
3400f022:	b089      	sub	sp, #36	@ 0x24
3400f024:	af00      	add	r7, sp, #0
3400f026:	6078      	str	r0, [r7, #4]
3400f028:	6039      	str	r1, [r7, #0]
  __IO const uint32_t *p_rcc_pll_cfgr1_reg, *p_rcc_pll_cfgr2_reg, *p_rcc_pll_cfgr3_reg;
  uint32_t ret = 0U;
3400f02a:	2300      	movs	r3, #0
3400f02c:	61fb      	str	r3, [r7, #28]

  /* No assert since done in calling function */

  p_rcc_pll_cfgr1_reg = &(RCC->PLL1CFGR1) + (((uint32_t)0x4) * PLLnumber);
3400f02e:	687b      	ldr	r3, [r7, #4]
3400f030:	011a      	lsls	r2, r3, #4
3400f032:	4b34      	ldr	r3, [pc, #208]	@ (3400f104 <RCC_PLL_IsNewConfig+0xe4>)
3400f034:	4413      	add	r3, r2
3400f036:	617b      	str	r3, [r7, #20]
  p_rcc_pll_cfgr2_reg = &(RCC->PLL1CFGR2) + (((uint32_t)0x4) * PLLnumber);
3400f038:	687b      	ldr	r3, [r7, #4]
3400f03a:	011a      	lsls	r2, r3, #4
3400f03c:	4b32      	ldr	r3, [pc, #200]	@ (3400f108 <RCC_PLL_IsNewConfig+0xe8>)
3400f03e:	4413      	add	r3, r2
3400f040:	613b      	str	r3, [r7, #16]
  p_rcc_pll_cfgr3_reg = &(RCC->PLL1CFGR3) + (((uint32_t)0x4) * PLLnumber);
3400f042:	687b      	ldr	r3, [r7, #4]
3400f044:	011a      	lsls	r2, r3, #4
3400f046:	4b31      	ldr	r3, [pc, #196]	@ (3400f10c <RCC_PLL_IsNewConfig+0xec>)
3400f048:	4413      	add	r3, r2
3400f04a:	60fb      	str	r3, [r7, #12]

  /* !!! WARNING: ONLY INTEGER AND FRACTIONAL MODES MANAGED TODAY !!! */

  /* Check for PLLCFGR1, PLLCFGR2 and PLLCFGR3 parameters updates */
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400f04c:	697b      	ldr	r3, [r7, #20]
3400f04e:	681b      	ldr	r3, [r3, #0]
3400f050:	f023 430c 	bic.w	r3, r3, #2348810240	@ 0x8c000000
3400f054:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
      (pPLLInit->PLLSource | (pPLLInit->PLLM << RCC_PLL1CFGR1_PLL1DIVM_Pos) \
3400f058:	683a      	ldr	r2, [r7, #0]
3400f05a:	6851      	ldr	r1, [r2, #4]
3400f05c:	683a      	ldr	r2, [r7, #0]
3400f05e:	6892      	ldr	r2, [r2, #8]
3400f060:	0512      	lsls	r2, r2, #20
3400f062:	4311      	orrs	r1, r2
       | (pPLLInit->PLLN << RCC_PLL1CFGR1_PLL1DIVN_Pos)))
3400f064:	683a      	ldr	r2, [r7, #0]
3400f066:	6912      	ldr	r2, [r2, #16]
3400f068:	0212      	lsls	r2, r2, #8
3400f06a:	430a      	orrs	r2, r1
  if ((*p_rcc_pll_cfgr1_reg & (RCC_PLL1CFGR1_PLL1SEL | RCC_PLL1CFGR1_PLL1DIVM | RCC_PLL1CFGR1_PLL1DIVN)) != \
3400f06c:	4293      	cmp	r3, r2
3400f06e:	d002      	beq.n	3400f076 <RCC_PLL_IsNewConfig+0x56>
  {
    ret = 1U; /* New PLL configuration */
3400f070:	2301      	movs	r3, #1
3400f072:	61fb      	str	r3, [r7, #28]
3400f074:	e03e      	b.n	3400f0f4 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3400f076:	693b      	ldr	r3, [r7, #16]
3400f078:	681b      	ldr	r3, [r3, #0]
3400f07a:	f023 427f 	bic.w	r2, r3, #4278190080	@ 0xff000000
           (pPLLInit->PLLFractional << RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos))
3400f07e:	683b      	ldr	r3, [r7, #0]
3400f080:	68db      	ldr	r3, [r3, #12]
  else if ((*p_rcc_pll_cfgr2_reg & RCC_PLL1CFGR2_PLL1DIVNFRAC) != \
3400f082:	429a      	cmp	r2, r3
3400f084:	d002      	beq.n	3400f08c <RCC_PLL_IsNewConfig+0x6c>
  {
    ret = 1U; /* New PLL configuration */
3400f086:	2301      	movs	r3, #1
3400f088:	61fb      	str	r3, [r7, #28]
3400f08a:	e033      	b.n	3400f0f4 <RCC_PLL_IsNewConfig+0xd4>
  }
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400f08c:	68fb      	ldr	r3, [r7, #12]
3400f08e:	681b      	ldr	r3, [r3, #0]
3400f090:	f003 527c 	and.w	r2, r3, #1056964608	@ 0x3f000000
           ((pPLLInit->PLLP1 << RCC_PLL1CFGR3_PLL1PDIV1_Pos) | (pPLLInit->PLLP2 << RCC_PLL1CFGR3_PLL1PDIV2_Pos)))
3400f094:	683b      	ldr	r3, [r7, #0]
3400f096:	695b      	ldr	r3, [r3, #20]
3400f098:	06d9      	lsls	r1, r3, #27
3400f09a:	683b      	ldr	r3, [r7, #0]
3400f09c:	699b      	ldr	r3, [r3, #24]
3400f09e:	061b      	lsls	r3, r3, #24
3400f0a0:	430b      	orrs	r3, r1
  else if ((*p_rcc_pll_cfgr3_reg & (RCC_PLL1CFGR3_PLL1PDIV1 | RCC_PLL1CFGR3_PLL1PDIV2)) != \
3400f0a2:	429a      	cmp	r2, r3
3400f0a4:	d002      	beq.n	3400f0ac <RCC_PLL_IsNewConfig+0x8c>
  {
    ret = 1U; /* New PLL configuration */
3400f0a6:	2301      	movs	r3, #1
3400f0a8:	61fb      	str	r3, [r7, #28]
3400f0aa:	e023      	b.n	3400f0f4 <RCC_PLL_IsNewConfig+0xd4>
  {
    /* Mode change detection*/
    uint32_t pllState;

    /* Get current Mode*/
    if (READ_BIT(RCC->SR, (RCC_SR_PLL1RDY << PLLnumber)) == (RCC_SR_PLL1RDY << PLLnumber))
3400f0ac:	4b18      	ldr	r3, [pc, #96]	@ (3400f110 <RCC_PLL_IsNewConfig+0xf0>)
3400f0ae:	685a      	ldr	r2, [r3, #4]
3400f0b0:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400f0b4:	687b      	ldr	r3, [r7, #4]
3400f0b6:	fa01 f303 	lsl.w	r3, r1, r3
3400f0ba:	401a      	ands	r2, r3
3400f0bc:	f44f 7180 	mov.w	r1, #256	@ 0x100
3400f0c0:	687b      	ldr	r3, [r7, #4]
3400f0c2:	fa01 f303 	lsl.w	r3, r1, r3
3400f0c6:	429a      	cmp	r2, r3
3400f0c8:	d102      	bne.n	3400f0d0 <RCC_PLL_IsNewConfig+0xb0>
    {
      pllState = RCC_PLL_ON;
3400f0ca:	2302      	movs	r3, #2
3400f0cc:	61bb      	str	r3, [r7, #24]
3400f0ce:	e00a      	b.n	3400f0e6 <RCC_PLL_IsNewConfig+0xc6>
    }
    else
    {
      if ((*p_rcc_pll_cfgr1_reg & RCC_PLL1CFGR1_PLL1BYP) != 0UL)
3400f0d0:	697b      	ldr	r3, [r7, #20]
3400f0d2:	681b      	ldr	r3, [r3, #0]
3400f0d4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400f0d8:	2b00      	cmp	r3, #0
3400f0da:	d002      	beq.n	3400f0e2 <RCC_PLL_IsNewConfig+0xc2>
      {
        pllState = RCC_PLL_BYPASS;
3400f0dc:	2303      	movs	r3, #3
3400f0de:	61bb      	str	r3, [r7, #24]
3400f0e0:	e001      	b.n	3400f0e6 <RCC_PLL_IsNewConfig+0xc6>
      }
      else
      {
        pllState = RCC_PLL_OFF;
3400f0e2:	2301      	movs	r3, #1
3400f0e4:	61bb      	str	r3, [r7, #24]
      }
    }

    /* Compare with new mode */
    if (pllState != pPLLInit->PLLState)
3400f0e6:	683b      	ldr	r3, [r7, #0]
3400f0e8:	681b      	ldr	r3, [r3, #0]
3400f0ea:	69ba      	ldr	r2, [r7, #24]
3400f0ec:	429a      	cmp	r2, r3
3400f0ee:	d001      	beq.n	3400f0f4 <RCC_PLL_IsNewConfig+0xd4>
    {
      ret = 1U; /* New PLL configuration */
3400f0f0:	2301      	movs	r3, #1
3400f0f2:	61fb      	str	r3, [r7, #28]
    }
  }

  return ret;
3400f0f4:	69fb      	ldr	r3, [r7, #28]
}
3400f0f6:	4618      	mov	r0, r3
3400f0f8:	3724      	adds	r7, #36	@ 0x24
3400f0fa:	46bd      	mov	sp, r7
3400f0fc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f100:	4770      	bx	lr
3400f102:	bf00      	nop
3400f104:	56028080 	.word	0x56028080
3400f108:	56028084 	.word	0x56028084
3400f10c:	56028088 	.word	0x56028088
3400f110:	56028000 	.word	0x56028000

3400f114 <RCC_PLL_Source_IsReady>:
  * @brief  Check whether the PLL source is ready
  * @param  PLLSource PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_PLL_Source_IsReady(uint32_t PLLSource)
{
3400f114:	b580      	push	{r7, lr}
3400f116:	b084      	sub	sp, #16
3400f118:	af00      	add	r7, sp, #0
3400f11a:	6078      	str	r0, [r7, #4]
  uint32_t ret = 1U;
3400f11c:	2301      	movs	r3, #1
3400f11e:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  switch (PLLSource)
3400f120:	687b      	ldr	r3, [r7, #4]
3400f122:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f126:	d01b      	beq.n	3400f160 <RCC_PLL_Source_IsReady+0x4c>
3400f128:	687b      	ldr	r3, [r7, #4]
3400f12a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f12e:	d81f      	bhi.n	3400f170 <RCC_PLL_Source_IsReady+0x5c>
3400f130:	687b      	ldr	r3, [r7, #4]
3400f132:	2b00      	cmp	r3, #0
3400f134:	d004      	beq.n	3400f140 <RCC_PLL_Source_IsReady+0x2c>
3400f136:	687b      	ldr	r3, [r7, #4]
3400f138:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f13c:	d008      	beq.n	3400f150 <RCC_PLL_Source_IsReady+0x3c>
        ret = 0U;
      }
      break;
    case RCC_PLLSOURCE_PIN:
    default:
      break;
3400f13e:	e017      	b.n	3400f170 <RCC_PLL_Source_IsReady+0x5c>
      if (LL_RCC_HSI_IsReady() == 0U)
3400f140:	f7fe fc72 	bl	3400da28 <LL_RCC_HSI_IsReady>
3400f144:	4603      	mov	r3, r0
3400f146:	2b00      	cmp	r3, #0
3400f148:	d114      	bne.n	3400f174 <RCC_PLL_Source_IsReady+0x60>
        ret = 0U;
3400f14a:	2300      	movs	r3, #0
3400f14c:	60fb      	str	r3, [r7, #12]
      break;
3400f14e:	e011      	b.n	3400f174 <RCC_PLL_Source_IsReady+0x60>
      if (LL_RCC_MSI_IsReady() == 0U)
3400f150:	f7fe fcd2 	bl	3400daf8 <LL_RCC_MSI_IsReady>
3400f154:	4603      	mov	r3, r0
3400f156:	2b00      	cmp	r3, #0
3400f158:	d10e      	bne.n	3400f178 <RCC_PLL_Source_IsReady+0x64>
        ret = 0U;
3400f15a:	2300      	movs	r3, #0
3400f15c:	60fb      	str	r3, [r7, #12]
      break;
3400f15e:	e00b      	b.n	3400f178 <RCC_PLL_Source_IsReady+0x64>
      if (LL_RCC_HSE_IsReady() == 0U)
3400f160:	f7fe fc32 	bl	3400d9c8 <LL_RCC_HSE_IsReady>
3400f164:	4603      	mov	r3, r0
3400f166:	2b00      	cmp	r3, #0
3400f168:	d108      	bne.n	3400f17c <RCC_PLL_Source_IsReady+0x68>
        ret = 0U;
3400f16a:	2300      	movs	r3, #0
3400f16c:	60fb      	str	r3, [r7, #12]
      break;
3400f16e:	e005      	b.n	3400f17c <RCC_PLL_Source_IsReady+0x68>
      break;
3400f170:	bf00      	nop
3400f172:	e004      	b.n	3400f17e <RCC_PLL_Source_IsReady+0x6a>
      break;
3400f174:	bf00      	nop
3400f176:	e002      	b.n	3400f17e <RCC_PLL_Source_IsReady+0x6a>
      break;
3400f178:	bf00      	nop
3400f17a:	e000      	b.n	3400f17e <RCC_PLL_Source_IsReady+0x6a>
      break;
3400f17c:	bf00      	nop
  }

  return ret;
3400f17e:	68fb      	ldr	r3, [r7, #12]
}
3400f180:	4618      	mov	r0, r3
3400f182:	3710      	adds	r7, #16
3400f184:	46bd      	mov	sp, r7
3400f186:	bd80      	pop	{r7, pc}

3400f188 <RCC_IC_CheckPLLSources>:
  * @param  PLLSource1 First PLL source
  * @param  PLLSource2 Second PLL source
  * @retval 1 if success else 0
  */
static uint32_t RCC_IC_CheckPLLSources(uint32_t PLLSource1, uint32_t PLLSource2)
{
3400f188:	b580      	push	{r7, lr}
3400f18a:	b084      	sub	sp, #16
3400f18c:	af00      	add	r7, sp, #0
3400f18e:	6078      	str	r0, [r7, #4]
3400f190:	6039      	str	r1, [r7, #0]
  uint32_t ret = 1U;
3400f192:	2301      	movs	r3, #1
3400f194:	60fb      	str	r3, [r7, #12]

  /* No assert since done in calling function */

  /* Check PLLSource1 clock source */
  switch (PLLSource1)
3400f196:	687b      	ldr	r3, [r7, #4]
3400f198:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f19c:	d03a      	beq.n	3400f214 <RCC_IC_CheckPLLSources+0x8c>
3400f19e:	687b      	ldr	r3, [r7, #4]
3400f1a0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f1a4:	d843      	bhi.n	3400f22e <RCC_IC_CheckPLLSources+0xa6>
3400f1a6:	687b      	ldr	r3, [r7, #4]
3400f1a8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f1ac:	d025      	beq.n	3400f1fa <RCC_IC_CheckPLLSources+0x72>
3400f1ae:	687b      	ldr	r3, [r7, #4]
3400f1b0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f1b4:	d83b      	bhi.n	3400f22e <RCC_IC_CheckPLLSources+0xa6>
3400f1b6:	687b      	ldr	r3, [r7, #4]
3400f1b8:	2b00      	cmp	r3, #0
3400f1ba:	d004      	beq.n	3400f1c6 <RCC_IC_CheckPLLSources+0x3e>
3400f1bc:	687b      	ldr	r3, [r7, #4]
3400f1be:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f1c2:	d00d      	beq.n	3400f1e0 <RCC_IC_CheckPLLSources+0x58>
3400f1c4:	e033      	b.n	3400f22e <RCC_IC_CheckPLLSources+0xa6>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3400f1c6:	f7fe fd49 	bl	3400dc5c <LL_RCC_PLL1_IsReady>
3400f1ca:	4603      	mov	r3, r0
3400f1cc:	2b00      	cmp	r3, #0
3400f1ce:	d131      	bne.n	3400f234 <RCC_IC_CheckPLLSources+0xac>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3400f1d0:	f7fe fd58 	bl	3400dc84 <LL_RCC_PLL1_IsEnabledBypass>
3400f1d4:	4603      	mov	r3, r0
3400f1d6:	2b00      	cmp	r3, #0
3400f1d8:	d12c      	bne.n	3400f234 <RCC_IC_CheckPLLSources+0xac>
        {
          ret = 0U;
3400f1da:	2300      	movs	r3, #0
3400f1dc:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f1de:	e029      	b.n	3400f234 <RCC_IC_CheckPLLSources+0xac>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3400f1e0:	f7fe fd72 	bl	3400dcc8 <LL_RCC_PLL2_IsReady>
3400f1e4:	4603      	mov	r3, r0
3400f1e6:	2b00      	cmp	r3, #0
3400f1e8:	d126      	bne.n	3400f238 <RCC_IC_CheckPLLSources+0xb0>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3400f1ea:	f7fe fd81 	bl	3400dcf0 <LL_RCC_PLL2_IsEnabledBypass>
3400f1ee:	4603      	mov	r3, r0
3400f1f0:	2b00      	cmp	r3, #0
3400f1f2:	d121      	bne.n	3400f238 <RCC_IC_CheckPLLSources+0xb0>
        {
          ret = 0U;
3400f1f4:	2300      	movs	r3, #0
3400f1f6:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f1f8:	e01e      	b.n	3400f238 <RCC_IC_CheckPLLSources+0xb0>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3400f1fa:	f7fe fd9b 	bl	3400dd34 <LL_RCC_PLL3_IsReady>
3400f1fe:	4603      	mov	r3, r0
3400f200:	2b00      	cmp	r3, #0
3400f202:	d11b      	bne.n	3400f23c <RCC_IC_CheckPLLSources+0xb4>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3400f204:	f7fe fdaa 	bl	3400dd5c <LL_RCC_PLL3_IsEnabledBypass>
3400f208:	4603      	mov	r3, r0
3400f20a:	2b00      	cmp	r3, #0
3400f20c:	d116      	bne.n	3400f23c <RCC_IC_CheckPLLSources+0xb4>
        {
          ret = 0U;
3400f20e:	2300      	movs	r3, #0
3400f210:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f212:	e013      	b.n	3400f23c <RCC_IC_CheckPLLSources+0xb4>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3400f214:	f7fe fdc4 	bl	3400dda0 <LL_RCC_PLL4_IsReady>
3400f218:	4603      	mov	r3, r0
3400f21a:	2b00      	cmp	r3, #0
3400f21c:	d110      	bne.n	3400f240 <RCC_IC_CheckPLLSources+0xb8>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3400f21e:	f7fe fdd3 	bl	3400ddc8 <LL_RCC_PLL4_IsEnabledBypass>
3400f222:	4603      	mov	r3, r0
3400f224:	2b00      	cmp	r3, #0
3400f226:	d10b      	bne.n	3400f240 <RCC_IC_CheckPLLSources+0xb8>
        {
          ret = 0U;
3400f228:	2300      	movs	r3, #0
3400f22a:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f22c:	e008      	b.n	3400f240 <RCC_IC_CheckPLLSources+0xb8>
    default:
      /* Unexpected */
      ret = 0U;
3400f22e:	2300      	movs	r3, #0
3400f230:	60fb      	str	r3, [r7, #12]
      break;
3400f232:	e006      	b.n	3400f242 <RCC_IC_CheckPLLSources+0xba>
      break;
3400f234:	bf00      	nop
3400f236:	e004      	b.n	3400f242 <RCC_IC_CheckPLLSources+0xba>
      break;
3400f238:	bf00      	nop
3400f23a:	e002      	b.n	3400f242 <RCC_IC_CheckPLLSources+0xba>
      break;
3400f23c:	bf00      	nop
3400f23e:	e000      	b.n	3400f242 <RCC_IC_CheckPLLSources+0xba>
      break;
3400f240:	bf00      	nop
  }

  /* Check PLLSource2 clock source */
  switch (PLLSource2)
3400f242:	683b      	ldr	r3, [r7, #0]
3400f244:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f248:	d03a      	beq.n	3400f2c0 <RCC_IC_CheckPLLSources+0x138>
3400f24a:	683b      	ldr	r3, [r7, #0]
3400f24c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400f250:	d843      	bhi.n	3400f2da <RCC_IC_CheckPLLSources+0x152>
3400f252:	683b      	ldr	r3, [r7, #0]
3400f254:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f258:	d025      	beq.n	3400f2a6 <RCC_IC_CheckPLLSources+0x11e>
3400f25a:	683b      	ldr	r3, [r7, #0]
3400f25c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400f260:	d83b      	bhi.n	3400f2da <RCC_IC_CheckPLLSources+0x152>
3400f262:	683b      	ldr	r3, [r7, #0]
3400f264:	2b00      	cmp	r3, #0
3400f266:	d004      	beq.n	3400f272 <RCC_IC_CheckPLLSources+0xea>
3400f268:	683b      	ldr	r3, [r7, #0]
3400f26a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3400f26e:	d00d      	beq.n	3400f28c <RCC_IC_CheckPLLSources+0x104>
3400f270:	e033      	b.n	3400f2da <RCC_IC_CheckPLLSources+0x152>
  {
    case LL_RCC_ICCLKSOURCE_PLL1:
      if (LL_RCC_PLL1_IsReady() == 0U)
3400f272:	f7fe fcf3 	bl	3400dc5c <LL_RCC_PLL1_IsReady>
3400f276:	4603      	mov	r3, r0
3400f278:	2b00      	cmp	r3, #0
3400f27a:	d131      	bne.n	3400f2e0 <RCC_IC_CheckPLLSources+0x158>
      {
        if (LL_RCC_PLL1_IsEnabledBypass() == 0U)
3400f27c:	f7fe fd02 	bl	3400dc84 <LL_RCC_PLL1_IsEnabledBypass>
3400f280:	4603      	mov	r3, r0
3400f282:	2b00      	cmp	r3, #0
3400f284:	d12c      	bne.n	3400f2e0 <RCC_IC_CheckPLLSources+0x158>
        {
          ret = 0U;
3400f286:	2300      	movs	r3, #0
3400f288:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f28a:	e029      	b.n	3400f2e0 <RCC_IC_CheckPLLSources+0x158>
    case LL_RCC_ICCLKSOURCE_PLL2:
      if (LL_RCC_PLL2_IsReady() == 0U)
3400f28c:	f7fe fd1c 	bl	3400dcc8 <LL_RCC_PLL2_IsReady>
3400f290:	4603      	mov	r3, r0
3400f292:	2b00      	cmp	r3, #0
3400f294:	d126      	bne.n	3400f2e4 <RCC_IC_CheckPLLSources+0x15c>
      {
        if (LL_RCC_PLL2_IsEnabledBypass() == 0U)
3400f296:	f7fe fd2b 	bl	3400dcf0 <LL_RCC_PLL2_IsEnabledBypass>
3400f29a:	4603      	mov	r3, r0
3400f29c:	2b00      	cmp	r3, #0
3400f29e:	d121      	bne.n	3400f2e4 <RCC_IC_CheckPLLSources+0x15c>
        {
          ret = 0U;
3400f2a0:	2300      	movs	r3, #0
3400f2a2:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f2a4:	e01e      	b.n	3400f2e4 <RCC_IC_CheckPLLSources+0x15c>
    case LL_RCC_ICCLKSOURCE_PLL3:
      if (LL_RCC_PLL3_IsReady() == 0U)
3400f2a6:	f7fe fd45 	bl	3400dd34 <LL_RCC_PLL3_IsReady>
3400f2aa:	4603      	mov	r3, r0
3400f2ac:	2b00      	cmp	r3, #0
3400f2ae:	d11b      	bne.n	3400f2e8 <RCC_IC_CheckPLLSources+0x160>
      {
        if (LL_RCC_PLL3_IsEnabledBypass() == 0U)
3400f2b0:	f7fe fd54 	bl	3400dd5c <LL_RCC_PLL3_IsEnabledBypass>
3400f2b4:	4603      	mov	r3, r0
3400f2b6:	2b00      	cmp	r3, #0
3400f2b8:	d116      	bne.n	3400f2e8 <RCC_IC_CheckPLLSources+0x160>
        {
          ret = 0U;
3400f2ba:	2300      	movs	r3, #0
3400f2bc:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f2be:	e013      	b.n	3400f2e8 <RCC_IC_CheckPLLSources+0x160>
    case LL_RCC_ICCLKSOURCE_PLL4:
      if (LL_RCC_PLL4_IsReady() == 0U)
3400f2c0:	f7fe fd6e 	bl	3400dda0 <LL_RCC_PLL4_IsReady>
3400f2c4:	4603      	mov	r3, r0
3400f2c6:	2b00      	cmp	r3, #0
3400f2c8:	d110      	bne.n	3400f2ec <RCC_IC_CheckPLLSources+0x164>
      {
        if (LL_RCC_PLL4_IsEnabledBypass() == 0U)
3400f2ca:	f7fe fd7d 	bl	3400ddc8 <LL_RCC_PLL4_IsEnabledBypass>
3400f2ce:	4603      	mov	r3, r0
3400f2d0:	2b00      	cmp	r3, #0
3400f2d2:	d10b      	bne.n	3400f2ec <RCC_IC_CheckPLLSources+0x164>
        {
          ret = 0U;
3400f2d4:	2300      	movs	r3, #0
3400f2d6:	60fb      	str	r3, [r7, #12]
        }
      }
      break;
3400f2d8:	e008      	b.n	3400f2ec <RCC_IC_CheckPLLSources+0x164>
    default:
      /* Unexpected */
      ret = 0U;
3400f2da:	2300      	movs	r3, #0
3400f2dc:	60fb      	str	r3, [r7, #12]
      break;
3400f2de:	e006      	b.n	3400f2ee <RCC_IC_CheckPLLSources+0x166>
      break;
3400f2e0:	bf00      	nop
3400f2e2:	e004      	b.n	3400f2ee <RCC_IC_CheckPLLSources+0x166>
      break;
3400f2e4:	bf00      	nop
3400f2e6:	e002      	b.n	3400f2ee <RCC_IC_CheckPLLSources+0x166>
      break;
3400f2e8:	bf00      	nop
3400f2ea:	e000      	b.n	3400f2ee <RCC_IC_CheckPLLSources+0x166>
      break;
3400f2ec:	bf00      	nop
  }

  return ret;
3400f2ee:	68fb      	ldr	r3, [r7, #12]
}
3400f2f0:	4618      	mov	r0, r3
3400f2f2:	3710      	adds	r7, #16
3400f2f4:	46bd      	mov	sp, r7
3400f2f6:	bd80      	pop	{r7, pc}

3400f2f8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
{
3400f2f8:	b480      	push	{r7}
3400f2fa:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400f2fc:	4b05      	ldr	r3, [pc, #20]	@ (3400f314 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3400f2fe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f300:	4a04      	ldr	r2, [pc, #16]	@ (3400f314 <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3400f302:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400f306:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400f308:	bf00      	nop
3400f30a:	46bd      	mov	sp, r7
3400f30c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f310:	4770      	bx	lr
3400f312:	bf00      	nop
3400f314:	56028000 	.word	0x56028000

3400f318 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
{
3400f318:	b480      	push	{r7}
3400f31a:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
3400f31c:	4b05      	ldr	r3, [pc, #20]	@ (3400f334 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3400f31e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f320:	4a04      	ldr	r2, [pc, #16]	@ (3400f334 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
3400f322:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
3400f326:	6553      	str	r3, [r2, #84]	@ 0x54
}
3400f328:	bf00      	nop
3400f32a:	46bd      	mov	sp, r7
3400f32c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f330:	4770      	bx	lr
3400f332:	bf00      	nop
3400f334:	56028000 	.word	0x56028000

3400f338 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>:
{
3400f338:	b480      	push	{r7}
3400f33a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL) == RCC_HSECFGR_HSEDIV2SEL) ? 1UL : 0UL);
3400f33c:	4b06      	ldr	r3, [pc, #24]	@ (3400f358 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x20>)
3400f33e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400f340:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400f344:	2b40      	cmp	r3, #64	@ 0x40
3400f346:	d101      	bne.n	3400f34c <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x14>
3400f348:	2301      	movs	r3, #1
3400f34a:	e000      	b.n	3400f34e <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock+0x16>
3400f34c:	2300      	movs	r3, #0
}
3400f34e:	4618      	mov	r0, r3
3400f350:	46bd      	mov	sp, r7
3400f352:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f356:	4770      	bx	lr
3400f358:	56028000 	.word	0x56028000

3400f35c <LL_RCC_HSE_IsReady>:
{
3400f35c:	b480      	push	{r7}
3400f35e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSERDY) != 0UL) ? 1UL : 0UL);
3400f360:	4b06      	ldr	r3, [pc, #24]	@ (3400f37c <LL_RCC_HSE_IsReady+0x20>)
3400f362:	685b      	ldr	r3, [r3, #4]
3400f364:	f003 0310 	and.w	r3, r3, #16
3400f368:	2b00      	cmp	r3, #0
3400f36a:	d001      	beq.n	3400f370 <LL_RCC_HSE_IsReady+0x14>
3400f36c:	2301      	movs	r3, #1
3400f36e:	e000      	b.n	3400f372 <LL_RCC_HSE_IsReady+0x16>
3400f370:	2300      	movs	r3, #0
}
3400f372:	4618      	mov	r0, r3
3400f374:	46bd      	mov	sp, r7
3400f376:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f37a:	4770      	bx	lr
3400f37c:	56028000 	.word	0x56028000

3400f380 <LL_RCC_HSI_IsReady>:
{
3400f380:	b480      	push	{r7}
3400f382:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_HSIRDY) != 0UL) ? 1UL : 0UL);
3400f384:	4b06      	ldr	r3, [pc, #24]	@ (3400f3a0 <LL_RCC_HSI_IsReady+0x20>)
3400f386:	685b      	ldr	r3, [r3, #4]
3400f388:	f003 0308 	and.w	r3, r3, #8
3400f38c:	2b00      	cmp	r3, #0
3400f38e:	d001      	beq.n	3400f394 <LL_RCC_HSI_IsReady+0x14>
3400f390:	2301      	movs	r3, #1
3400f392:	e000      	b.n	3400f396 <LL_RCC_HSI_IsReady+0x16>
3400f394:	2300      	movs	r3, #0
}
3400f396:	4618      	mov	r0, r3
3400f398:	46bd      	mov	sp, r7
3400f39a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f39e:	4770      	bx	lr
3400f3a0:	56028000 	.word	0x56028000

3400f3a4 <LL_RCC_HSI_GetDivider>:
{
3400f3a4:	b480      	push	{r7}
3400f3a6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->HSICFGR, RCC_HSICFGR_HSIDIV));
3400f3a8:	4b04      	ldr	r3, [pc, #16]	@ (3400f3bc <LL_RCC_HSI_GetDivider+0x18>)
3400f3aa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400f3ac:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
}
3400f3b0:	4618      	mov	r0, r3
3400f3b2:	46bd      	mov	sp, r7
3400f3b4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f3b8:	4770      	bx	lr
3400f3ba:	bf00      	nop
3400f3bc:	56028000 	.word	0x56028000

3400f3c0 <LL_RCC_MSI_IsReady>:
{
3400f3c0:	b480      	push	{r7}
3400f3c2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_MSIRDY) != 0UL) ? 1UL : 0UL);
3400f3c4:	4b06      	ldr	r3, [pc, #24]	@ (3400f3e0 <LL_RCC_MSI_IsReady+0x20>)
3400f3c6:	685b      	ldr	r3, [r3, #4]
3400f3c8:	f003 0304 	and.w	r3, r3, #4
3400f3cc:	2b00      	cmp	r3, #0
3400f3ce:	d001      	beq.n	3400f3d4 <LL_RCC_MSI_IsReady+0x14>
3400f3d0:	2301      	movs	r3, #1
3400f3d2:	e000      	b.n	3400f3d6 <LL_RCC_MSI_IsReady+0x16>
3400f3d4:	2300      	movs	r3, #0
}
3400f3d6:	4618      	mov	r0, r3
3400f3d8:	46bd      	mov	sp, r7
3400f3da:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f3de:	4770      	bx	lr
3400f3e0:	56028000 	.word	0x56028000

3400f3e4 <LL_RCC_MSI_GetFrequency>:
{
3400f3e4:	b480      	push	{r7}
3400f3e6:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL));
3400f3e8:	4b04      	ldr	r3, [pc, #16]	@ (3400f3fc <LL_RCC_MSI_GetFrequency+0x18>)
3400f3ea:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400f3ec:	f403 7300 	and.w	r3, r3, #512	@ 0x200
}
3400f3f0:	4618      	mov	r0, r3
3400f3f2:	46bd      	mov	sp, r7
3400f3f4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f3f8:	4770      	bx	lr
3400f3fa:	bf00      	nop
3400f3fc:	56028000 	.word	0x56028000

3400f400 <LL_RCC_LSE_IsReady>:
{
3400f400:	b480      	push	{r7}
3400f402:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
3400f404:	4b06      	ldr	r3, [pc, #24]	@ (3400f420 <LL_RCC_LSE_IsReady+0x20>)
3400f406:	685b      	ldr	r3, [r3, #4]
3400f408:	f003 0302 	and.w	r3, r3, #2
3400f40c:	2b00      	cmp	r3, #0
3400f40e:	d001      	beq.n	3400f414 <LL_RCC_LSE_IsReady+0x14>
3400f410:	2301      	movs	r3, #1
3400f412:	e000      	b.n	3400f416 <LL_RCC_LSE_IsReady+0x16>
3400f414:	2300      	movs	r3, #0
}
3400f416:	4618      	mov	r0, r3
3400f418:	46bd      	mov	sp, r7
3400f41a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f41e:	4770      	bx	lr
3400f420:	56028000 	.word	0x56028000

3400f424 <LL_RCC_LSI_IsReady>:
{
3400f424:	b480      	push	{r7}
3400f426:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSIRDY) != 0UL) ? 1UL : 0UL);
3400f428:	4b04      	ldr	r3, [pc, #16]	@ (3400f43c <LL_RCC_LSI_IsReady+0x18>)
3400f42a:	685b      	ldr	r3, [r3, #4]
3400f42c:	f003 0301 	and.w	r3, r3, #1
}
3400f430:	4618      	mov	r0, r3
3400f432:	46bd      	mov	sp, r7
3400f434:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f438:	4770      	bx	lr
3400f43a:	bf00      	nop
3400f43c:	56028000 	.word	0x56028000

3400f440 <LL_RCC_GetAHBPrescaler>:
{
3400f440:	b480      	push	{r7}
3400f442:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_HPRE));
3400f444:	4b04      	ldr	r3, [pc, #16]	@ (3400f458 <LL_RCC_GetAHBPrescaler+0x18>)
3400f446:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400f448:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
}
3400f44c:	4618      	mov	r0, r3
3400f44e:	46bd      	mov	sp, r7
3400f450:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f454:	4770      	bx	lr
3400f456:	bf00      	nop
3400f458:	56028000 	.word	0x56028000

3400f45c <LL_RCC_GetAPB1Prescaler>:
{
3400f45c:	b480      	push	{r7}
3400f45e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE1));
3400f460:	4b04      	ldr	r3, [pc, #16]	@ (3400f474 <LL_RCC_GetAPB1Prescaler+0x18>)
3400f462:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400f464:	f003 0307 	and.w	r3, r3, #7
}
3400f468:	4618      	mov	r0, r3
3400f46a:	46bd      	mov	sp, r7
3400f46c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f470:	4770      	bx	lr
3400f472:	bf00      	nop
3400f474:	56028000 	.word	0x56028000

3400f478 <LL_RCC_GetAPB2Prescaler>:
{
3400f478:	b480      	push	{r7}
3400f47a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE2));
3400f47c:	4b04      	ldr	r3, [pc, #16]	@ (3400f490 <LL_RCC_GetAPB2Prescaler+0x18>)
3400f47e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400f480:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3400f484:	4618      	mov	r0, r3
3400f486:	46bd      	mov	sp, r7
3400f488:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f48c:	4770      	bx	lr
3400f48e:	bf00      	nop
3400f490:	56028000 	.word	0x56028000

3400f494 <LL_RCC_GetAPB4Prescaler>:
{
3400f494:	b480      	push	{r7}
3400f496:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE4));
3400f498:	4b04      	ldr	r3, [pc, #16]	@ (3400f4ac <LL_RCC_GetAPB4Prescaler+0x18>)
3400f49a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400f49c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
}
3400f4a0:	4618      	mov	r0, r3
3400f4a2:	46bd      	mov	sp, r7
3400f4a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f4a8:	4770      	bx	lr
3400f4aa:	bf00      	nop
3400f4ac:	56028000 	.word	0x56028000

3400f4b0 <LL_RCC_GetAPB5Prescaler>:
{
3400f4b0:	b480      	push	{r7}
3400f4b2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_PPRE5));
3400f4b4:	4b04      	ldr	r3, [pc, #16]	@ (3400f4c8 <LL_RCC_GetAPB5Prescaler+0x18>)
3400f4b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400f4b8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3400f4bc:	4618      	mov	r0, r3
3400f4be:	46bd      	mov	sp, r7
3400f4c0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f4c4:	4770      	bx	lr
3400f4c6:	bf00      	nop
3400f4c8:	56028000 	.word	0x56028000

3400f4cc <LL_RCC_SetClockSource>:
{
3400f4cc:	b480      	push	{r7}
3400f4ce:	b085      	sub	sp, #20
3400f4d0:	af00      	add	r7, sp, #0
3400f4d2:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
3400f4d4:	687b      	ldr	r3, [r7, #4]
3400f4d6:	b2da      	uxtb	r2, r3
3400f4d8:	4b10      	ldr	r3, [pc, #64]	@ (3400f51c <LL_RCC_SetClockSource+0x50>)
3400f4da:	4413      	add	r3, r2
3400f4dc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
3400f4de:	68fb      	ldr	r3, [r7, #12]
3400f4e0:	681a      	ldr	r2, [r3, #0]
3400f4e2:	687b      	ldr	r3, [r7, #4]
3400f4e4:	0e19      	lsrs	r1, r3, #24
3400f4e6:	687b      	ldr	r3, [r7, #4]
3400f4e8:	0a1b      	lsrs	r3, r3, #8
3400f4ea:	f003 031f 	and.w	r3, r3, #31
3400f4ee:	fa01 f303 	lsl.w	r3, r1, r3
3400f4f2:	43db      	mvns	r3, r3
3400f4f4:	401a      	ands	r2, r3
3400f4f6:	687b      	ldr	r3, [r7, #4]
3400f4f8:	0c1b      	lsrs	r3, r3, #16
3400f4fa:	b2d9      	uxtb	r1, r3
3400f4fc:	687b      	ldr	r3, [r7, #4]
3400f4fe:	0a1b      	lsrs	r3, r3, #8
3400f500:	f003 031f 	and.w	r3, r3, #31
3400f504:	fa01 f303 	lsl.w	r3, r1, r3
3400f508:	431a      	orrs	r2, r3
3400f50a:	68fb      	ldr	r3, [r7, #12]
3400f50c:	601a      	str	r2, [r3, #0]
}
3400f50e:	bf00      	nop
3400f510:	3714      	adds	r7, #20
3400f512:	46bd      	mov	sp, r7
3400f514:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f518:	4770      	bx	lr
3400f51a:	bf00      	nop
3400f51c:	56028144 	.word	0x56028144

3400f520 <LL_RCC_GetADCPrescaler>:
{
3400f520:	b480      	push	{r7}
3400f522:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADCPRE) >> RCC_CCIPR1_ADCPRE_Pos);
3400f524:	4b04      	ldr	r3, [pc, #16]	@ (3400f538 <LL_RCC_GetADCPrescaler+0x18>)
3400f526:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f52a:	0a1b      	lsrs	r3, r3, #8
3400f52c:	b2db      	uxtb	r3, r3
}
3400f52e:	4618      	mov	r0, r3
3400f530:	46bd      	mov	sp, r7
3400f532:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f536:	4770      	bx	lr
3400f538:	56028000 	.word	0x56028000

3400f53c <LL_RCC_SetADFClockSource>:
{
3400f53c:	b480      	push	{r7}
3400f53e:	b083      	sub	sp, #12
3400f540:	af00      	add	r7, sp, #0
3400f542:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
3400f544:	4b07      	ldr	r3, [pc, #28]	@ (3400f564 <LL_RCC_SetADFClockSource+0x28>)
3400f546:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f54a:	f023 0207 	bic.w	r2, r3, #7
3400f54e:	4905      	ldr	r1, [pc, #20]	@ (3400f564 <LL_RCC_SetADFClockSource+0x28>)
3400f550:	687b      	ldr	r3, [r7, #4]
3400f552:	4313      	orrs	r3, r2
3400f554:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3400f558:	bf00      	nop
3400f55a:	370c      	adds	r7, #12
3400f55c:	46bd      	mov	sp, r7
3400f55e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f562:	4770      	bx	lr
3400f564:	56028000 	.word	0x56028000

3400f568 <LL_RCC_SetCLKPClockSource>:
{
3400f568:	b480      	push	{r7}
3400f56a:	b083      	sub	sp, #12
3400f56c:	af00      	add	r7, sp, #0
3400f56e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400f570:	4b07      	ldr	r3, [pc, #28]	@ (3400f590 <LL_RCC_SetCLKPClockSource+0x28>)
3400f572:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400f576:	f023 0207 	bic.w	r2, r3, #7
3400f57a:	4905      	ldr	r1, [pc, #20]	@ (3400f590 <LL_RCC_SetCLKPClockSource+0x28>)
3400f57c:	687b      	ldr	r3, [r7, #4]
3400f57e:	4313      	orrs	r3, r2
3400f580:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400f584:	bf00      	nop
3400f586:	370c      	adds	r7, #12
3400f588:	46bd      	mov	sp, r7
3400f58a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f58e:	4770      	bx	lr
3400f590:	56028000 	.word	0x56028000

3400f594 <LL_RCC_SetDCMIPPClockSource>:
{
3400f594:	b480      	push	{r7}
3400f596:	b083      	sub	sp, #12
3400f598:	af00      	add	r7, sp, #0
3400f59a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
3400f59c:	4b07      	ldr	r3, [pc, #28]	@ (3400f5bc <LL_RCC_SetDCMIPPClockSource+0x28>)
3400f59e:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f5a2:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
3400f5a6:	4905      	ldr	r1, [pc, #20]	@ (3400f5bc <LL_RCC_SetDCMIPPClockSource+0x28>)
3400f5a8:	687b      	ldr	r3, [r7, #4]
3400f5aa:	4313      	orrs	r3, r2
3400f5ac:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
3400f5b0:	bf00      	nop
3400f5b2:	370c      	adds	r7, #12
3400f5b4:	46bd      	mov	sp, r7
3400f5b6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f5ba:	4770      	bx	lr
3400f5bc:	56028000 	.word	0x56028000

3400f5c0 <LL_RCC_SetETHClockSource>:
{
3400f5c0:	b480      	push	{r7}
3400f5c2:	b083      	sub	sp, #12
3400f5c4:	af00      	add	r7, sp, #0
3400f5c6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
3400f5c8:	4b07      	ldr	r3, [pc, #28]	@ (3400f5e8 <LL_RCC_SetETHClockSource+0x28>)
3400f5ca:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f5ce:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
3400f5d2:	4905      	ldr	r1, [pc, #20]	@ (3400f5e8 <LL_RCC_SetETHClockSource+0x28>)
3400f5d4:	687b      	ldr	r3, [r7, #4]
3400f5d6:	4313      	orrs	r3, r2
3400f5d8:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400f5dc:	bf00      	nop
3400f5de:	370c      	adds	r7, #12
3400f5e0:	46bd      	mov	sp, r7
3400f5e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f5e6:	4770      	bx	lr
3400f5e8:	56028000 	.word	0x56028000

3400f5ec <LL_RCC_SetETHPHYInterface>:
{
3400f5ec:	b480      	push	{r7}
3400f5ee:	b083      	sub	sp, #12
3400f5f0:	af00      	add	r7, sp, #0
3400f5f2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
3400f5f4:	4b07      	ldr	r3, [pc, #28]	@ (3400f614 <LL_RCC_SetETHPHYInterface+0x28>)
3400f5f6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f5fa:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400f5fe:	4905      	ldr	r1, [pc, #20]	@ (3400f614 <LL_RCC_SetETHPHYInterface+0x28>)
3400f600:	687b      	ldr	r3, [r7, #4]
3400f602:	4313      	orrs	r3, r2
3400f604:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400f608:	bf00      	nop
3400f60a:	370c      	adds	r7, #12
3400f60c:	46bd      	mov	sp, r7
3400f60e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f612:	4770      	bx	lr
3400f614:	56028000 	.word	0x56028000

3400f618 <LL_RCC_GetETH1PTPDivider>:
{
3400f618:	b480      	push	{r7}
3400f61a:	af00      	add	r7, sp, #0
  return (READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPDIV));
3400f61c:	4b04      	ldr	r3, [pc, #16]	@ (3400f630 <LL_RCC_GetETH1PTPDivider+0x18>)
3400f61e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f622:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
}
3400f626:	4618      	mov	r0, r3
3400f628:	46bd      	mov	sp, r7
3400f62a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f62e:	4770      	bx	lr
3400f630:	56028000 	.word	0x56028000

3400f634 <LL_RCC_SetETHREFRXClockSource>:
{
3400f634:	b480      	push	{r7}
3400f636:	b083      	sub	sp, #12
3400f638:	af00      	add	r7, sp, #0
3400f63a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400f63c:	4b07      	ldr	r3, [pc, #28]	@ (3400f65c <LL_RCC_SetETHREFRXClockSource+0x28>)
3400f63e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f642:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
3400f646:	4905      	ldr	r1, [pc, #20]	@ (3400f65c <LL_RCC_SetETHREFRXClockSource+0x28>)
3400f648:	687b      	ldr	r3, [r7, #4]
3400f64a:	4313      	orrs	r3, r2
3400f64c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400f650:	bf00      	nop
3400f652:	370c      	adds	r7, #12
3400f654:	46bd      	mov	sp, r7
3400f656:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f65a:	4770      	bx	lr
3400f65c:	56028000 	.word	0x56028000

3400f660 <LL_RCC_SetETHREFTXClockSource>:
{
3400f660:	b480      	push	{r7}
3400f662:	b083      	sub	sp, #12
3400f664:	af00      	add	r7, sp, #0
3400f666:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
3400f668:	4b07      	ldr	r3, [pc, #28]	@ (3400f688 <LL_RCC_SetETHREFTXClockSource+0x28>)
3400f66a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f66e:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
3400f672:	4905      	ldr	r1, [pc, #20]	@ (3400f688 <LL_RCC_SetETHREFTXClockSource+0x28>)
3400f674:	687b      	ldr	r3, [r7, #4]
3400f676:	4313      	orrs	r3, r2
3400f678:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400f67c:	bf00      	nop
3400f67e:	370c      	adds	r7, #12
3400f680:	46bd      	mov	sp, r7
3400f682:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f686:	4770      	bx	lr
3400f688:	56028000 	.word	0x56028000

3400f68c <LL_RCC_SetFDCANClockSource>:
{
3400f68c:	b480      	push	{r7}
3400f68e:	b083      	sub	sp, #12
3400f690:	af00      	add	r7, sp, #0
3400f692:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
3400f694:	4b07      	ldr	r3, [pc, #28]	@ (3400f6b4 <LL_RCC_SetFDCANClockSource+0x28>)
3400f696:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400f69a:	f023 0203 	bic.w	r2, r3, #3
3400f69e:	4905      	ldr	r1, [pc, #20]	@ (3400f6b4 <LL_RCC_SetFDCANClockSource+0x28>)
3400f6a0:	687b      	ldr	r3, [r7, #4]
3400f6a2:	4313      	orrs	r3, r2
3400f6a4:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3400f6a8:	bf00      	nop
3400f6aa:	370c      	adds	r7, #12
3400f6ac:	46bd      	mov	sp, r7
3400f6ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f6b2:	4770      	bx	lr
3400f6b4:	56028000 	.word	0x56028000

3400f6b8 <LL_RCC_SetFMCClockSource>:
{
3400f6b8:	b480      	push	{r7}
3400f6ba:	b083      	sub	sp, #12
3400f6bc:	af00      	add	r7, sp, #0
3400f6be:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
3400f6c0:	4b07      	ldr	r3, [pc, #28]	@ (3400f6e0 <LL_RCC_SetFMCClockSource+0x28>)
3400f6c2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400f6c6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400f6ca:	4905      	ldr	r1, [pc, #20]	@ (3400f6e0 <LL_RCC_SetFMCClockSource+0x28>)
3400f6cc:	687b      	ldr	r3, [r7, #4]
3400f6ce:	4313      	orrs	r3, r2
3400f6d0:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
3400f6d4:	bf00      	nop
3400f6d6:	370c      	adds	r7, #12
3400f6d8:	46bd      	mov	sp, r7
3400f6da:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f6de:	4770      	bx	lr
3400f6e0:	56028000 	.word	0x56028000

3400f6e4 <LL_RCC_SetI2CClockSource>:
{
3400f6e4:	b580      	push	{r7, lr}
3400f6e6:	b082      	sub	sp, #8
3400f6e8:	af00      	add	r7, sp, #0
3400f6ea:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f6ec:	6878      	ldr	r0, [r7, #4]
3400f6ee:	f7ff feed 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f6f2:	bf00      	nop
3400f6f4:	3708      	adds	r7, #8
3400f6f6:	46bd      	mov	sp, r7
3400f6f8:	bd80      	pop	{r7, pc}

3400f6fa <LL_RCC_SetI3CClockSource>:
{
3400f6fa:	b580      	push	{r7, lr}
3400f6fc:	b082      	sub	sp, #8
3400f6fe:	af00      	add	r7, sp, #0
3400f700:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f702:	6878      	ldr	r0, [r7, #4]
3400f704:	f7ff fee2 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f708:	bf00      	nop
3400f70a:	3708      	adds	r7, #8
3400f70c:	46bd      	mov	sp, r7
3400f70e:	bd80      	pop	{r7, pc}

3400f710 <LL_RCC_SetLPTIMClockSource>:
{
3400f710:	b580      	push	{r7, lr}
3400f712:	b082      	sub	sp, #8
3400f714:	af00      	add	r7, sp, #0
3400f716:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f718:	6878      	ldr	r0, [r7, #4]
3400f71a:	f7ff fed7 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f71e:	bf00      	nop
3400f720:	3708      	adds	r7, #8
3400f722:	46bd      	mov	sp, r7
3400f724:	bd80      	pop	{r7, pc}
	...

3400f728 <LL_RCC_SetLPUARTClockSource>:
{
3400f728:	b480      	push	{r7}
3400f72a:	b083      	sub	sp, #12
3400f72c:	af00      	add	r7, sp, #0
3400f72e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
3400f730:	4b07      	ldr	r3, [pc, #28]	@ (3400f750 <LL_RCC_SetLPUARTClockSource+0x28>)
3400f732:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400f736:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3400f73a:	4905      	ldr	r1, [pc, #20]	@ (3400f750 <LL_RCC_SetLPUARTClockSource+0x28>)
3400f73c:	687b      	ldr	r3, [r7, #4]
3400f73e:	4313      	orrs	r3, r2
3400f740:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
3400f744:	bf00      	nop
3400f746:	370c      	adds	r7, #12
3400f748:	46bd      	mov	sp, r7
3400f74a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f74e:	4770      	bx	lr
3400f750:	56028000 	.word	0x56028000

3400f754 <LL_RCC_SetLTDCClockSource>:
{
3400f754:	b480      	push	{r7}
3400f756:	b083      	sub	sp, #12
3400f758:	af00      	add	r7, sp, #0
3400f75a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400f75c:	4b07      	ldr	r3, [pc, #28]	@ (3400f77c <LL_RCC_SetLTDCClockSource+0x28>)
3400f75e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400f762:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400f766:	4905      	ldr	r1, [pc, #20]	@ (3400f77c <LL_RCC_SetLTDCClockSource+0x28>)
3400f768:	687b      	ldr	r3, [r7, #4]
3400f76a:	4313      	orrs	r3, r2
3400f76c:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
3400f770:	bf00      	nop
3400f772:	370c      	adds	r7, #12
3400f774:	46bd      	mov	sp, r7
3400f776:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f77a:	4770      	bx	lr
3400f77c:	56028000 	.word	0x56028000

3400f780 <LL_RCC_SetMDFClockSource>:
{
3400f780:	b480      	push	{r7}
3400f782:	b083      	sub	sp, #12
3400f784:	af00      	add	r7, sp, #0
3400f786:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
3400f788:	4b07      	ldr	r3, [pc, #28]	@ (3400f7a8 <LL_RCC_SetMDFClockSource+0x28>)
3400f78a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400f78e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400f792:	4905      	ldr	r1, [pc, #20]	@ (3400f7a8 <LL_RCC_SetMDFClockSource+0x28>)
3400f794:	687b      	ldr	r3, [r7, #4]
3400f796:	4313      	orrs	r3, r2
3400f798:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
3400f79c:	bf00      	nop
3400f79e:	370c      	adds	r7, #12
3400f7a0:	46bd      	mov	sp, r7
3400f7a2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f7a6:	4770      	bx	lr
3400f7a8:	56028000 	.word	0x56028000

3400f7ac <LL_RCC_SetOTGPHYClockSource>:
{
3400f7ac:	b580      	push	{r7, lr}
3400f7ae:	b082      	sub	sp, #8
3400f7b0:	af00      	add	r7, sp, #0
3400f7b2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f7b4:	6878      	ldr	r0, [r7, #4]
3400f7b6:	f7ff fe89 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f7ba:	bf00      	nop
3400f7bc:	3708      	adds	r7, #8
3400f7be:	46bd      	mov	sp, r7
3400f7c0:	bd80      	pop	{r7, pc}

3400f7c2 <LL_RCC_SetOTGPHYCKREFClockSource>:
{
3400f7c2:	b580      	push	{r7, lr}
3400f7c4:	b082      	sub	sp, #8
3400f7c6:	af00      	add	r7, sp, #0
3400f7c8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f7ca:	6878      	ldr	r0, [r7, #4]
3400f7cc:	f7ff fe7e 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f7d0:	bf00      	nop
3400f7d2:	3708      	adds	r7, #8
3400f7d4:	46bd      	mov	sp, r7
3400f7d6:	bd80      	pop	{r7, pc}

3400f7d8 <LL_RCC_SetPSSIClockSource>:
{
3400f7d8:	b480      	push	{r7}
3400f7da:	b083      	sub	sp, #12
3400f7dc:	af00      	add	r7, sp, #0
3400f7de:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
3400f7e0:	4b07      	ldr	r3, [pc, #28]	@ (3400f800 <LL_RCC_SetPSSIClockSource+0x28>)
3400f7e2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400f7e6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
3400f7ea:	4905      	ldr	r1, [pc, #20]	@ (3400f800 <LL_RCC_SetPSSIClockSource+0x28>)
3400f7ec:	687b      	ldr	r3, [r7, #4]
3400f7ee:	4313      	orrs	r3, r2
3400f7f0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400f7f4:	bf00      	nop
3400f7f6:	370c      	adds	r7, #12
3400f7f8:	46bd      	mov	sp, r7
3400f7fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f7fe:	4770      	bx	lr
3400f800:	56028000 	.word	0x56028000

3400f804 <LL_RCC_SetSAIClockSource>:
{
3400f804:	b580      	push	{r7, lr}
3400f806:	b082      	sub	sp, #8
3400f808:	af00      	add	r7, sp, #0
3400f80a:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f80c:	6878      	ldr	r0, [r7, #4]
3400f80e:	f7ff fe5d 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f812:	bf00      	nop
3400f814:	3708      	adds	r7, #8
3400f816:	46bd      	mov	sp, r7
3400f818:	bd80      	pop	{r7, pc}

3400f81a <LL_RCC_SetSDMMCClockSource>:
{
3400f81a:	b580      	push	{r7, lr}
3400f81c:	b082      	sub	sp, #8
3400f81e:	af00      	add	r7, sp, #0
3400f820:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f822:	6878      	ldr	r0, [r7, #4]
3400f824:	f7ff fe52 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f828:	bf00      	nop
3400f82a:	3708      	adds	r7, #8
3400f82c:	46bd      	mov	sp, r7
3400f82e:	bd80      	pop	{r7, pc}

3400f830 <LL_RCC_SetSPDIFRXClockSource>:
{
3400f830:	b480      	push	{r7}
3400f832:	b083      	sub	sp, #12
3400f834:	af00      	add	r7, sp, #0
3400f836:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
3400f838:	4b07      	ldr	r3, [pc, #28]	@ (3400f858 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3400f83a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400f83e:	f023 0207 	bic.w	r2, r3, #7
3400f842:	4905      	ldr	r1, [pc, #20]	@ (3400f858 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3400f844:	687b      	ldr	r3, [r7, #4]
3400f846:	4313      	orrs	r3, r2
3400f848:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
3400f84c:	bf00      	nop
3400f84e:	370c      	adds	r7, #12
3400f850:	46bd      	mov	sp, r7
3400f852:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f856:	4770      	bx	lr
3400f858:	56028000 	.word	0x56028000

3400f85c <LL_RCC_SetSPIClockSource>:
{
3400f85c:	b580      	push	{r7, lr}
3400f85e:	b082      	sub	sp, #8
3400f860:	af00      	add	r7, sp, #0
3400f862:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f864:	6878      	ldr	r0, [r7, #4]
3400f866:	f7ff fe31 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f86a:	bf00      	nop
3400f86c:	3708      	adds	r7, #8
3400f86e:	46bd      	mov	sp, r7
3400f870:	bd80      	pop	{r7, pc}

3400f872 <LL_RCC_SetUSARTClockSource>:
{
3400f872:	b580      	push	{r7, lr}
3400f874:	b082      	sub	sp, #8
3400f876:	af00      	add	r7, sp, #0
3400f878:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f87a:	6878      	ldr	r0, [r7, #4]
3400f87c:	f7ff fe26 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f880:	bf00      	nop
3400f882:	3708      	adds	r7, #8
3400f884:	46bd      	mov	sp, r7
3400f886:	bd80      	pop	{r7, pc}

3400f888 <LL_RCC_SetXSPIClockSource>:
{
3400f888:	b580      	push	{r7, lr}
3400f88a:	b082      	sub	sp, #8
3400f88c:	af00      	add	r7, sp, #0
3400f88e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400f890:	6878      	ldr	r0, [r7, #4]
3400f892:	f7ff fe1b 	bl	3400f4cc <LL_RCC_SetClockSource>
}
3400f896:	bf00      	nop
3400f898:	3708      	adds	r7, #8
3400f89a:	46bd      	mov	sp, r7
3400f89c:	bd80      	pop	{r7, pc}
	...

3400f8a0 <LL_RCC_GetClockSource>:
{
3400f8a0:	b480      	push	{r7}
3400f8a2:	b085      	sub	sp, #20
3400f8a4:	af00      	add	r7, sp, #0
3400f8a6:	6078      	str	r0, [r7, #4]
  const volatile uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&RCC->CCIPR1) + LL_CLKSOURCE_REG(Periph)));
3400f8a8:	687b      	ldr	r3, [r7, #4]
3400f8aa:	b2da      	uxtb	r2, r3
3400f8ac:	4b0e      	ldr	r3, [pc, #56]	@ (3400f8e8 <LL_RCC_GetClockSource+0x48>)
3400f8ae:	4413      	add	r3, r2
3400f8b0:	60fb      	str	r3, [r7, #12]
  return (uint32_t)(Periph | (((READ_BIT(*pReg, LL_CLKSOURCE_MASK(Periph))) >> LL_CLKSOURCE_SHIFT(Periph)) << LL_RCC_CONFIG_SHIFT));
3400f8b2:	68fb      	ldr	r3, [r7, #12]
3400f8b4:	681a      	ldr	r2, [r3, #0]
3400f8b6:	687b      	ldr	r3, [r7, #4]
3400f8b8:	0e19      	lsrs	r1, r3, #24
3400f8ba:	687b      	ldr	r3, [r7, #4]
3400f8bc:	0a1b      	lsrs	r3, r3, #8
3400f8be:	f003 031f 	and.w	r3, r3, #31
3400f8c2:	fa01 f303 	lsl.w	r3, r1, r3
3400f8c6:	401a      	ands	r2, r3
3400f8c8:	687b      	ldr	r3, [r7, #4]
3400f8ca:	0a1b      	lsrs	r3, r3, #8
3400f8cc:	f003 031f 	and.w	r3, r3, #31
3400f8d0:	fa22 f303 	lsr.w	r3, r2, r3
3400f8d4:	041a      	lsls	r2, r3, #16
3400f8d6:	687b      	ldr	r3, [r7, #4]
3400f8d8:	4313      	orrs	r3, r2
}
3400f8da:	4618      	mov	r0, r3
3400f8dc:	3714      	adds	r7, #20
3400f8de:	46bd      	mov	sp, r7
3400f8e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f8e4:	4770      	bx	lr
3400f8e6:	bf00      	nop
3400f8e8:	56028144 	.word	0x56028144

3400f8ec <LL_RCC_GetADCClockSource>:
{
3400f8ec:	b480      	push	{r7}
3400f8ee:	b083      	sub	sp, #12
3400f8f0:	af00      	add	r7, sp, #0
3400f8f2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADC12SEL));
3400f8f4:	4b05      	ldr	r3, [pc, #20]	@ (3400f90c <LL_RCC_GetADCClockSource+0x20>)
3400f8f6:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f8fa:	f003 0370 	and.w	r3, r3, #112	@ 0x70
}
3400f8fe:	4618      	mov	r0, r3
3400f900:	370c      	adds	r7, #12
3400f902:	46bd      	mov	sp, r7
3400f904:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f908:	4770      	bx	lr
3400f90a:	bf00      	nop
3400f90c:	56028000 	.word	0x56028000

3400f910 <LL_RCC_GetADFClockSource>:
{
3400f910:	b480      	push	{r7}
3400f912:	b083      	sub	sp, #12
3400f914:	af00      	add	r7, sp, #0
3400f916:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL));
3400f918:	4b05      	ldr	r3, [pc, #20]	@ (3400f930 <LL_RCC_GetADFClockSource+0x20>)
3400f91a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f91e:	f003 0307 	and.w	r3, r3, #7
}
3400f922:	4618      	mov	r0, r3
3400f924:	370c      	adds	r7, #12
3400f926:	46bd      	mov	sp, r7
3400f928:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f92c:	4770      	bx	lr
3400f92e:	bf00      	nop
3400f930:	56028000 	.word	0x56028000

3400f934 <LL_RCC_GetCLKPClockSource>:
{
3400f934:	b480      	push	{r7}
3400f936:	b083      	sub	sp, #12
3400f938:	af00      	add	r7, sp, #0
3400f93a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PERSEL));
3400f93c:	4b05      	ldr	r3, [pc, #20]	@ (3400f954 <LL_RCC_GetCLKPClockSource+0x20>)
3400f93e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400f942:	f003 0307 	and.w	r3, r3, #7
}
3400f946:	4618      	mov	r0, r3
3400f948:	370c      	adds	r7, #12
3400f94a:	46bd      	mov	sp, r7
3400f94c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f950:	4770      	bx	lr
3400f952:	bf00      	nop
3400f954:	56028000 	.word	0x56028000

3400f958 <LL_RCC_GetDCMIPPClockSource>:
{
3400f958:	b480      	push	{r7}
3400f95a:	b083      	sub	sp, #12
3400f95c:	af00      	add	r7, sp, #0
3400f95e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL));
3400f960:	4b05      	ldr	r3, [pc, #20]	@ (3400f978 <LL_RCC_GetDCMIPPClockSource+0x20>)
3400f962:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400f966:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
}
3400f96a:	4618      	mov	r0, r3
3400f96c:	370c      	adds	r7, #12
3400f96e:	46bd      	mov	sp, r7
3400f970:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f974:	4770      	bx	lr
3400f976:	bf00      	nop
3400f978:	56028000 	.word	0x56028000

3400f97c <LL_RCC_GetETHClockSource>:
{
3400f97c:	b480      	push	{r7}
3400f97e:	b083      	sub	sp, #12
3400f980:	af00      	add	r7, sp, #0
3400f982:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL));
3400f984:	4b05      	ldr	r3, [pc, #20]	@ (3400f99c <LL_RCC_GetETHClockSource+0x20>)
3400f986:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f98a:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
}
3400f98e:	4618      	mov	r0, r3
3400f990:	370c      	adds	r7, #12
3400f992:	46bd      	mov	sp, r7
3400f994:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f998:	4770      	bx	lr
3400f99a:	bf00      	nop
3400f99c:	56028000 	.word	0x56028000

3400f9a0 <LL_RCC_GetETHPTPClockSource>:
{
3400f9a0:	b480      	push	{r7}
3400f9a2:	b083      	sub	sp, #12
3400f9a4:	af00      	add	r7, sp, #0
3400f9a6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR2, RCC_CCIPR2_ETH1PTPSEL));
3400f9a8:	4b05      	ldr	r3, [pc, #20]	@ (3400f9c0 <LL_RCC_GetETHPTPClockSource+0x20>)
3400f9aa:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400f9ae:	f003 0303 	and.w	r3, r3, #3
}
3400f9b2:	4618      	mov	r0, r3
3400f9b4:	370c      	adds	r7, #12
3400f9b6:	46bd      	mov	sp, r7
3400f9b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f9bc:	4770      	bx	lr
3400f9be:	bf00      	nop
3400f9c0:	56028000 	.word	0x56028000

3400f9c4 <LL_RCC_GetFDCANClockSource>:
{
3400f9c4:	b480      	push	{r7}
3400f9c6:	b083      	sub	sp, #12
3400f9c8:	af00      	add	r7, sp, #0
3400f9ca:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL));
3400f9cc:	4b05      	ldr	r3, [pc, #20]	@ (3400f9e4 <LL_RCC_GetFDCANClockSource+0x20>)
3400f9ce:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400f9d2:	f003 0303 	and.w	r3, r3, #3
}
3400f9d6:	4618      	mov	r0, r3
3400f9d8:	370c      	adds	r7, #12
3400f9da:	46bd      	mov	sp, r7
3400f9dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f9e0:	4770      	bx	lr
3400f9e2:	bf00      	nop
3400f9e4:	56028000 	.word	0x56028000

3400f9e8 <LL_RCC_GetFMCClockSource>:
{
3400f9e8:	b480      	push	{r7}
3400f9ea:	b083      	sub	sp, #12
3400f9ec:	af00      	add	r7, sp, #0
3400f9ee:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR3, RCC_CCIPR3_FMCSEL));
3400f9f0:	4b05      	ldr	r3, [pc, #20]	@ (3400fa08 <LL_RCC_GetFMCClockSource+0x20>)
3400f9f2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400f9f6:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3400f9fa:	4618      	mov	r0, r3
3400f9fc:	370c      	adds	r7, #12
3400f9fe:	46bd      	mov	sp, r7
3400fa00:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fa04:	4770      	bx	lr
3400fa06:	bf00      	nop
3400fa08:	56028000 	.word	0x56028000

3400fa0c <LL_RCC_GetI2CClockSource>:
{
3400fa0c:	b580      	push	{r7, lr}
3400fa0e:	b082      	sub	sp, #8
3400fa10:	af00      	add	r7, sp, #0
3400fa12:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fa14:	6878      	ldr	r0, [r7, #4]
3400fa16:	f7ff ff43 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fa1a:	4603      	mov	r3, r0
}
3400fa1c:	4618      	mov	r0, r3
3400fa1e:	3708      	adds	r7, #8
3400fa20:	46bd      	mov	sp, r7
3400fa22:	bd80      	pop	{r7, pc}

3400fa24 <LL_RCC_GetI3CClockSource>:
{
3400fa24:	b580      	push	{r7, lr}
3400fa26:	b082      	sub	sp, #8
3400fa28:	af00      	add	r7, sp, #0
3400fa2a:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fa2c:	6878      	ldr	r0, [r7, #4]
3400fa2e:	f7ff ff37 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fa32:	4603      	mov	r3, r0
}
3400fa34:	4618      	mov	r0, r3
3400fa36:	3708      	adds	r7, #8
3400fa38:	46bd      	mov	sp, r7
3400fa3a:	bd80      	pop	{r7, pc}

3400fa3c <LL_RCC_GetLPTIMClockSource>:
{
3400fa3c:	b580      	push	{r7, lr}
3400fa3e:	b082      	sub	sp, #8
3400fa40:	af00      	add	r7, sp, #0
3400fa42:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fa44:	6878      	ldr	r0, [r7, #4]
3400fa46:	f7ff ff2b 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fa4a:	4603      	mov	r3, r0
}
3400fa4c:	4618      	mov	r0, r3
3400fa4e:	3708      	adds	r7, #8
3400fa50:	46bd      	mov	sp, r7
3400fa52:	bd80      	pop	{r7, pc}

3400fa54 <LL_RCC_GetLPUARTClockSource>:
{
3400fa54:	b480      	push	{r7}
3400fa56:	b083      	sub	sp, #12
3400fa58:	af00      	add	r7, sp, #0
3400fa5a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL));
3400fa5c:	4b05      	ldr	r3, [pc, #20]	@ (3400fa74 <LL_RCC_GetLPUARTClockSource+0x20>)
3400fa5e:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400fa62:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
}
3400fa66:	4618      	mov	r0, r3
3400fa68:	370c      	adds	r7, #12
3400fa6a:	46bd      	mov	sp, r7
3400fa6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fa70:	4770      	bx	lr
3400fa72:	bf00      	nop
3400fa74:	56028000 	.word	0x56028000

3400fa78 <LL_RCC_GetLTDCClockSource>:
{
3400fa78:	b480      	push	{r7}
3400fa7a:	b083      	sub	sp, #12
3400fa7c:	af00      	add	r7, sp, #0
3400fa7e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL));
3400fa80:	4b05      	ldr	r3, [pc, #20]	@ (3400fa98 <LL_RCC_GetLTDCClockSource+0x20>)
3400fa82:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400fa86:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
}
3400fa8a:	4618      	mov	r0, r3
3400fa8c:	370c      	adds	r7, #12
3400fa8e:	46bd      	mov	sp, r7
3400fa90:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fa94:	4770      	bx	lr
3400fa96:	bf00      	nop
3400fa98:	56028000 	.word	0x56028000

3400fa9c <LL_RCC_GetMDFClockSource>:
{
3400fa9c:	b480      	push	{r7}
3400fa9e:	b083      	sub	sp, #12
3400faa0:	af00      	add	r7, sp, #0
3400faa2:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL));
3400faa4:	4b05      	ldr	r3, [pc, #20]	@ (3400fabc <LL_RCC_GetMDFClockSource+0x20>)
3400faa6:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400faaa:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
}
3400faae:	4618      	mov	r0, r3
3400fab0:	370c      	adds	r7, #12
3400fab2:	46bd      	mov	sp, r7
3400fab4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fab8:	4770      	bx	lr
3400faba:	bf00      	nop
3400fabc:	56028000 	.word	0x56028000

3400fac0 <LL_RCC_GetPSSIClockSource>:
{
3400fac0:	b480      	push	{r7}
3400fac2:	b083      	sub	sp, #12
3400fac4:	af00      	add	r7, sp, #0
3400fac6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_PSSISEL));
3400fac8:	4b05      	ldr	r3, [pc, #20]	@ (3400fae0 <LL_RCC_GetPSSIClockSource+0x20>)
3400faca:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400face:	f003 0330 	and.w	r3, r3, #48	@ 0x30
}
3400fad2:	4618      	mov	r0, r3
3400fad4:	370c      	adds	r7, #12
3400fad6:	46bd      	mov	sp, r7
3400fad8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fadc:	4770      	bx	lr
3400fade:	bf00      	nop
3400fae0:	56028000 	.word	0x56028000

3400fae4 <LL_RCC_GetSAIClockSource>:
{
3400fae4:	b580      	push	{r7, lr}
3400fae6:	b082      	sub	sp, #8
3400fae8:	af00      	add	r7, sp, #0
3400faea:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400faec:	6878      	ldr	r0, [r7, #4]
3400faee:	f7ff fed7 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400faf2:	4603      	mov	r3, r0
}
3400faf4:	4618      	mov	r0, r3
3400faf6:	3708      	adds	r7, #8
3400faf8:	46bd      	mov	sp, r7
3400fafa:	bd80      	pop	{r7, pc}

3400fafc <LL_RCC_GetSDMMCClockSource>:
{
3400fafc:	b580      	push	{r7, lr}
3400fafe:	b082      	sub	sp, #8
3400fb00:	af00      	add	r7, sp, #0
3400fb02:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fb04:	6878      	ldr	r0, [r7, #4]
3400fb06:	f7ff fecb 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fb0a:	4603      	mov	r3, r0
}
3400fb0c:	4618      	mov	r0, r3
3400fb0e:	3708      	adds	r7, #8
3400fb10:	46bd      	mov	sp, r7
3400fb12:	bd80      	pop	{r7, pc}

3400fb14 <LL_RCC_GetSPDIFRXClockSource>:
{
3400fb14:	b480      	push	{r7}
3400fb16:	b083      	sub	sp, #12
3400fb18:	af00      	add	r7, sp, #0
3400fb1a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL));
3400fb1c:	4b05      	ldr	r3, [pc, #20]	@ (3400fb34 <LL_RCC_GetSPDIFRXClockSource+0x20>)
3400fb1e:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400fb22:	f003 0307 	and.w	r3, r3, #7
}
3400fb26:	4618      	mov	r0, r3
3400fb28:	370c      	adds	r7, #12
3400fb2a:	46bd      	mov	sp, r7
3400fb2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fb30:	4770      	bx	lr
3400fb32:	bf00      	nop
3400fb34:	56028000 	.word	0x56028000

3400fb38 <LL_RCC_GetSPIClockSource>:
{
3400fb38:	b580      	push	{r7, lr}
3400fb3a:	b082      	sub	sp, #8
3400fb3c:	af00      	add	r7, sp, #0
3400fb3e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fb40:	6878      	ldr	r0, [r7, #4]
3400fb42:	f7ff fead 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fb46:	4603      	mov	r3, r0
}
3400fb48:	4618      	mov	r0, r3
3400fb4a:	3708      	adds	r7, #8
3400fb4c:	46bd      	mov	sp, r7
3400fb4e:	bd80      	pop	{r7, pc}

3400fb50 <LL_RCC_GetUSARTClockSource>:
{
3400fb50:	b580      	push	{r7, lr}
3400fb52:	b082      	sub	sp, #8
3400fb54:	af00      	add	r7, sp, #0
3400fb56:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fb58:	6878      	ldr	r0, [r7, #4]
3400fb5a:	f7ff fea1 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fb5e:	4603      	mov	r3, r0
}
3400fb60:	4618      	mov	r0, r3
3400fb62:	3708      	adds	r7, #8
3400fb64:	46bd      	mov	sp, r7
3400fb66:	bd80      	pop	{r7, pc}

3400fb68 <LL_RCC_GetUARTClockSource>:
{
3400fb68:	b580      	push	{r7, lr}
3400fb6a:	b082      	sub	sp, #8
3400fb6c:	af00      	add	r7, sp, #0
3400fb6e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fb70:	6878      	ldr	r0, [r7, #4]
3400fb72:	f7ff fe95 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fb76:	4603      	mov	r3, r0
}
3400fb78:	4618      	mov	r0, r3
3400fb7a:	3708      	adds	r7, #8
3400fb7c:	46bd      	mov	sp, r7
3400fb7e:	bd80      	pop	{r7, pc}

3400fb80 <LL_RCC_GetUSBClockSource>:
{
3400fb80:	b580      	push	{r7, lr}
3400fb82:	b082      	sub	sp, #8
3400fb84:	af00      	add	r7, sp, #0
3400fb86:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fb88:	6878      	ldr	r0, [r7, #4]
3400fb8a:	f7ff fe89 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fb8e:	4603      	mov	r3, r0
}
3400fb90:	4618      	mov	r0, r3
3400fb92:	3708      	adds	r7, #8
3400fb94:	46bd      	mov	sp, r7
3400fb96:	bd80      	pop	{r7, pc}

3400fb98 <LL_RCC_GetXSPIClockSource>:
{
3400fb98:	b580      	push	{r7, lr}
3400fb9a:	b082      	sub	sp, #8
3400fb9c:	af00      	add	r7, sp, #0
3400fb9e:	6078      	str	r0, [r7, #4]
  return LL_RCC_GetClockSource(Periph);
3400fba0:	6878      	ldr	r0, [r7, #4]
3400fba2:	f7ff fe7d 	bl	3400f8a0 <LL_RCC_GetClockSource>
3400fba6:	4603      	mov	r3, r0
}
3400fba8:	4618      	mov	r0, r3
3400fbaa:	3708      	adds	r7, #8
3400fbac:	46bd      	mov	sp, r7
3400fbae:	bd80      	pop	{r7, pc}

3400fbb0 <LL_RCC_SetRTCClockSource>:
{
3400fbb0:	b480      	push	{r7}
3400fbb2:	b083      	sub	sp, #12
3400fbb4:	af00      	add	r7, sp, #0
3400fbb6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
3400fbb8:	4b07      	ldr	r3, [pc, #28]	@ (3400fbd8 <LL_RCC_SetRTCClockSource+0x28>)
3400fbba:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400fbbe:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
3400fbc2:	4905      	ldr	r1, [pc, #20]	@ (3400fbd8 <LL_RCC_SetRTCClockSource+0x28>)
3400fbc4:	687b      	ldr	r3, [r7, #4]
3400fbc6:	4313      	orrs	r3, r2
3400fbc8:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400fbcc:	bf00      	nop
3400fbce:	370c      	adds	r7, #12
3400fbd0:	46bd      	mov	sp, r7
3400fbd2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fbd6:	4770      	bx	lr
3400fbd8:	56028000 	.word	0x56028000

3400fbdc <LL_RCC_GetRTCClockSource>:
{
3400fbdc:	b480      	push	{r7}
3400fbde:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
3400fbe0:	4b04      	ldr	r3, [pc, #16]	@ (3400fbf4 <LL_RCC_GetRTCClockSource+0x18>)
3400fbe2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400fbe6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
3400fbea:	4618      	mov	r0, r3
3400fbec:	46bd      	mov	sp, r7
3400fbee:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fbf2:	4770      	bx	lr
3400fbf4:	56028000 	.word	0x56028000

3400fbf8 <LL_RCC_SetRTC_HSEPrescaler>:
{
3400fbf8:	b480      	push	{r7}
3400fbfa:	b083      	sub	sp, #12
3400fbfc:	af00      	add	r7, sp, #0
3400fbfe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
3400fc00:	4b07      	ldr	r3, [pc, #28]	@ (3400fc20 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3400fc02:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400fc06:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
3400fc0a:	4905      	ldr	r1, [pc, #20]	@ (3400fc20 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
3400fc0c:	687b      	ldr	r3, [r7, #4]
3400fc0e:	4313      	orrs	r3, r2
3400fc10:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
3400fc14:	bf00      	nop
3400fc16:	370c      	adds	r7, #12
3400fc18:	46bd      	mov	sp, r7
3400fc1a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc1e:	4770      	bx	lr
3400fc20:	56028000 	.word	0x56028000

3400fc24 <LL_RCC_SetTIMPrescaler>:
{
3400fc24:	b480      	push	{r7}
3400fc26:	b083      	sub	sp, #12
3400fc28:	af00      	add	r7, sp, #0
3400fc2a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400fc2c:	4b07      	ldr	r3, [pc, #28]	@ (3400fc4c <LL_RCC_SetTIMPrescaler+0x28>)
3400fc2e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fc30:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
3400fc34:	687b      	ldr	r3, [r7, #4]
3400fc36:	061b      	lsls	r3, r3, #24
3400fc38:	4904      	ldr	r1, [pc, #16]	@ (3400fc4c <LL_RCC_SetTIMPrescaler+0x28>)
3400fc3a:	4313      	orrs	r3, r2
3400fc3c:	624b      	str	r3, [r1, #36]	@ 0x24
}
3400fc3e:	bf00      	nop
3400fc40:	370c      	adds	r7, #12
3400fc42:	46bd      	mov	sp, r7
3400fc44:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc48:	4770      	bx	lr
3400fc4a:	bf00      	nop
3400fc4c:	56028000 	.word	0x56028000

3400fc50 <LL_RCC_GetTIMPrescaler>:
{
3400fc50:	b480      	push	{r7}
3400fc52:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR2, RCC_CFGR2_TIMPRE) >> RCC_CFGR2_TIMPRE_Pos);
3400fc54:	4b04      	ldr	r3, [pc, #16]	@ (3400fc68 <LL_RCC_GetTIMPrescaler+0x18>)
3400fc56:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400fc58:	0e1b      	lsrs	r3, r3, #24
3400fc5a:	f003 0303 	and.w	r3, r3, #3
}
3400fc5e:	4618      	mov	r0, r3
3400fc60:	46bd      	mov	sp, r7
3400fc62:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc66:	4770      	bx	lr
3400fc68:	56028000 	.word	0x56028000

3400fc6c <LL_RCC_PLL1_GetSource>:
{
3400fc6c:	b480      	push	{r7}
3400fc6e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1SEL));
3400fc70:	4b04      	ldr	r3, [pc, #16]	@ (3400fc84 <LL_RCC_PLL1_GetSource+0x18>)
3400fc72:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400fc76:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400fc7a:	4618      	mov	r0, r3
3400fc7c:	46bd      	mov	sp, r7
3400fc7e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc82:	4770      	bx	lr
3400fc84:	56028000 	.word	0x56028000

3400fc88 <LL_RCC_PLL1_IsReady>:
{
3400fc88:	b480      	push	{r7}
3400fc8a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL1RDY) == (RCC_SR_PLL1RDY)) ? 1UL : 0UL);
3400fc8c:	4b07      	ldr	r3, [pc, #28]	@ (3400fcac <LL_RCC_PLL1_IsReady+0x24>)
3400fc8e:	685b      	ldr	r3, [r3, #4]
3400fc90:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400fc94:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400fc98:	d101      	bne.n	3400fc9e <LL_RCC_PLL1_IsReady+0x16>
3400fc9a:	2301      	movs	r3, #1
3400fc9c:	e000      	b.n	3400fca0 <LL_RCC_PLL1_IsReady+0x18>
3400fc9e:	2300      	movs	r3, #0
}
3400fca0:	4618      	mov	r0, r3
3400fca2:	46bd      	mov	sp, r7
3400fca4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fca8:	4770      	bx	lr
3400fcaa:	bf00      	nop
3400fcac:	56028000 	.word	0x56028000

3400fcb0 <LL_RCC_PLL1_IsEnabledBypass>:
{
3400fcb0:	b480      	push	{r7}
3400fcb2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1BYP) == RCC_PLL1CFGR1_PLL1BYP) ? 1UL : 0UL);
3400fcb4:	4b07      	ldr	r3, [pc, #28]	@ (3400fcd4 <LL_RCC_PLL1_IsEnabledBypass+0x24>)
3400fcb6:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400fcba:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400fcbe:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400fcc2:	d101      	bne.n	3400fcc8 <LL_RCC_PLL1_IsEnabledBypass+0x18>
3400fcc4:	2301      	movs	r3, #1
3400fcc6:	e000      	b.n	3400fcca <LL_RCC_PLL1_IsEnabledBypass+0x1a>
3400fcc8:	2300      	movs	r3, #0
}
3400fcca:	4618      	mov	r0, r3
3400fccc:	46bd      	mov	sp, r7
3400fcce:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fcd2:	4770      	bx	lr
3400fcd4:	56028000 	.word	0x56028000

3400fcd8 <LL_RCC_PLL1_GetN>:
{
3400fcd8:	b480      	push	{r7}
3400fcda:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVN) >> RCC_PLL1CFGR1_PLL1DIVN_Pos));
3400fcdc:	4b05      	ldr	r3, [pc, #20]	@ (3400fcf4 <LL_RCC_PLL1_GetN+0x1c>)
3400fcde:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400fce2:	0a1b      	lsrs	r3, r3, #8
3400fce4:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400fce8:	4618      	mov	r0, r3
3400fcea:	46bd      	mov	sp, r7
3400fcec:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fcf0:	4770      	bx	lr
3400fcf2:	bf00      	nop
3400fcf4:	56028000 	.word	0x56028000

3400fcf8 <LL_RCC_PLL1_GetM>:
{
3400fcf8:	b480      	push	{r7}
3400fcfa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR1, RCC_PLL1CFGR1_PLL1DIVM) >> RCC_PLL1CFGR1_PLL1DIVM_Pos);
3400fcfc:	4b05      	ldr	r3, [pc, #20]	@ (3400fd14 <LL_RCC_PLL1_GetM+0x1c>)
3400fcfe:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
3400fd02:	0d1b      	lsrs	r3, r3, #20
3400fd04:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400fd08:	4618      	mov	r0, r3
3400fd0a:	46bd      	mov	sp, r7
3400fd0c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fd10:	4770      	bx	lr
3400fd12:	bf00      	nop
3400fd14:	56028000 	.word	0x56028000

3400fd18 <LL_RCC_PLL1_GetP1>:
{
3400fd18:	b480      	push	{r7}
3400fd1a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV1) >> RCC_PLL1CFGR3_PLL1PDIV1_Pos);
3400fd1c:	4b05      	ldr	r3, [pc, #20]	@ (3400fd34 <LL_RCC_PLL1_GetP1+0x1c>)
3400fd1e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400fd22:	0edb      	lsrs	r3, r3, #27
3400fd24:	f003 0307 	and.w	r3, r3, #7
}
3400fd28:	4618      	mov	r0, r3
3400fd2a:	46bd      	mov	sp, r7
3400fd2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fd30:	4770      	bx	lr
3400fd32:	bf00      	nop
3400fd34:	56028000 	.word	0x56028000

3400fd38 <LL_RCC_PLL1_GetP2>:
{
3400fd38:	b480      	push	{r7}
3400fd3a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIV2) >> RCC_PLL1CFGR3_PLL1PDIV2_Pos);
3400fd3c:	4b05      	ldr	r3, [pc, #20]	@ (3400fd54 <LL_RCC_PLL1_GetP2+0x1c>)
3400fd3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400fd42:	0e1b      	lsrs	r3, r3, #24
3400fd44:	f003 0307 	and.w	r3, r3, #7
}
3400fd48:	4618      	mov	r0, r3
3400fd4a:	46bd      	mov	sp, r7
3400fd4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fd50:	4770      	bx	lr
3400fd52:	bf00      	nop
3400fd54:	56028000 	.word	0x56028000

3400fd58 <LL_RCC_PLL1P_IsEnabled>:
{
3400fd58:	b480      	push	{r7}
3400fd5a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL1CFGR3, RCC_PLL1CFGR3_PLL1PDIVEN) == RCC_PLL1CFGR3_PLL1PDIVEN) ? 1UL : 0UL);
3400fd5c:	4b07      	ldr	r3, [pc, #28]	@ (3400fd7c <LL_RCC_PLL1P_IsEnabled+0x24>)
3400fd5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3400fd62:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400fd66:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400fd6a:	d101      	bne.n	3400fd70 <LL_RCC_PLL1P_IsEnabled+0x18>
3400fd6c:	2301      	movs	r3, #1
3400fd6e:	e000      	b.n	3400fd72 <LL_RCC_PLL1P_IsEnabled+0x1a>
3400fd70:	2300      	movs	r3, #0
}
3400fd72:	4618      	mov	r0, r3
3400fd74:	46bd      	mov	sp, r7
3400fd76:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fd7a:	4770      	bx	lr
3400fd7c:	56028000 	.word	0x56028000

3400fd80 <LL_RCC_PLL1_GetFRACN>:
{
3400fd80:	b480      	push	{r7}
3400fd82:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >> RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos);
3400fd84:	4b04      	ldr	r3, [pc, #16]	@ (3400fd98 <LL_RCC_PLL1_GetFRACN+0x18>)
3400fd86:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3400fd8a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400fd8e:	4618      	mov	r0, r3
3400fd90:	46bd      	mov	sp, r7
3400fd92:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fd96:	4770      	bx	lr
3400fd98:	56028000 	.word	0x56028000

3400fd9c <LL_RCC_PLL2_GetSource>:
{
3400fd9c:	b480      	push	{r7}
3400fd9e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2SEL));
3400fda0:	4b04      	ldr	r3, [pc, #16]	@ (3400fdb4 <LL_RCC_PLL2_GetSource+0x18>)
3400fda2:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400fda6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400fdaa:	4618      	mov	r0, r3
3400fdac:	46bd      	mov	sp, r7
3400fdae:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fdb2:	4770      	bx	lr
3400fdb4:	56028000 	.word	0x56028000

3400fdb8 <LL_RCC_PLL2_IsReady>:
{
3400fdb8:	b480      	push	{r7}
3400fdba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL2RDY) == (RCC_SR_PLL2RDY)) ? 1UL : 0UL);
3400fdbc:	4b07      	ldr	r3, [pc, #28]	@ (3400fddc <LL_RCC_PLL2_IsReady+0x24>)
3400fdbe:	685b      	ldr	r3, [r3, #4]
3400fdc0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400fdc4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3400fdc8:	d101      	bne.n	3400fdce <LL_RCC_PLL2_IsReady+0x16>
3400fdca:	2301      	movs	r3, #1
3400fdcc:	e000      	b.n	3400fdd0 <LL_RCC_PLL2_IsReady+0x18>
3400fdce:	2300      	movs	r3, #0
}
3400fdd0:	4618      	mov	r0, r3
3400fdd2:	46bd      	mov	sp, r7
3400fdd4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fdd8:	4770      	bx	lr
3400fdda:	bf00      	nop
3400fddc:	56028000 	.word	0x56028000

3400fde0 <LL_RCC_PLL2_IsEnabledBypass>:
{
3400fde0:	b480      	push	{r7}
3400fde2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2BYP) == RCC_PLL2CFGR1_PLL2BYP) ? 1UL : 0UL);
3400fde4:	4b07      	ldr	r3, [pc, #28]	@ (3400fe04 <LL_RCC_PLL2_IsEnabledBypass+0x24>)
3400fde6:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400fdea:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400fdee:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400fdf2:	d101      	bne.n	3400fdf8 <LL_RCC_PLL2_IsEnabledBypass+0x18>
3400fdf4:	2301      	movs	r3, #1
3400fdf6:	e000      	b.n	3400fdfa <LL_RCC_PLL2_IsEnabledBypass+0x1a>
3400fdf8:	2300      	movs	r3, #0
}
3400fdfa:	4618      	mov	r0, r3
3400fdfc:	46bd      	mov	sp, r7
3400fdfe:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fe02:	4770      	bx	lr
3400fe04:	56028000 	.word	0x56028000

3400fe08 <LL_RCC_PLL2_GetN>:
{
3400fe08:	b480      	push	{r7}
3400fe0a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVN) >> RCC_PLL2CFGR1_PLL2DIVN_Pos));
3400fe0c:	4b05      	ldr	r3, [pc, #20]	@ (3400fe24 <LL_RCC_PLL2_GetN+0x1c>)
3400fe0e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400fe12:	0a1b      	lsrs	r3, r3, #8
3400fe14:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400fe18:	4618      	mov	r0, r3
3400fe1a:	46bd      	mov	sp, r7
3400fe1c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fe20:	4770      	bx	lr
3400fe22:	bf00      	nop
3400fe24:	56028000 	.word	0x56028000

3400fe28 <LL_RCC_PLL2_GetM>:
{
3400fe28:	b480      	push	{r7}
3400fe2a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR1, RCC_PLL2CFGR1_PLL2DIVM) >> RCC_PLL2CFGR1_PLL2DIVM_Pos);
3400fe2c:	4b05      	ldr	r3, [pc, #20]	@ (3400fe44 <LL_RCC_PLL2_GetM+0x1c>)
3400fe2e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
3400fe32:	0d1b      	lsrs	r3, r3, #20
3400fe34:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400fe38:	4618      	mov	r0, r3
3400fe3a:	46bd      	mov	sp, r7
3400fe3c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fe40:	4770      	bx	lr
3400fe42:	bf00      	nop
3400fe44:	56028000 	.word	0x56028000

3400fe48 <LL_RCC_PLL2_GetP1>:
{
3400fe48:	b480      	push	{r7}
3400fe4a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV1) >> RCC_PLL2CFGR3_PLL2PDIV1_Pos);
3400fe4c:	4b05      	ldr	r3, [pc, #20]	@ (3400fe64 <LL_RCC_PLL2_GetP1+0x1c>)
3400fe4e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400fe52:	0edb      	lsrs	r3, r3, #27
3400fe54:	f003 0307 	and.w	r3, r3, #7
}
3400fe58:	4618      	mov	r0, r3
3400fe5a:	46bd      	mov	sp, r7
3400fe5c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fe60:	4770      	bx	lr
3400fe62:	bf00      	nop
3400fe64:	56028000 	.word	0x56028000

3400fe68 <LL_RCC_PLL2_GetP2>:
{
3400fe68:	b480      	push	{r7}
3400fe6a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIV2) >> RCC_PLL2CFGR3_PLL2PDIV2_Pos);
3400fe6c:	4b05      	ldr	r3, [pc, #20]	@ (3400fe84 <LL_RCC_PLL2_GetP2+0x1c>)
3400fe6e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400fe72:	0e1b      	lsrs	r3, r3, #24
3400fe74:	f003 0307 	and.w	r3, r3, #7
}
3400fe78:	4618      	mov	r0, r3
3400fe7a:	46bd      	mov	sp, r7
3400fe7c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fe80:	4770      	bx	lr
3400fe82:	bf00      	nop
3400fe84:	56028000 	.word	0x56028000

3400fe88 <LL_RCC_PLL2P_IsEnabled>:
{
3400fe88:	b480      	push	{r7}
3400fe8a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL2CFGR3, RCC_PLL2CFGR3_PLL2PDIVEN) == RCC_PLL2CFGR3_PLL2PDIVEN) ? 1UL : 0UL);
3400fe8c:	4b07      	ldr	r3, [pc, #28]	@ (3400feac <LL_RCC_PLL2P_IsEnabled+0x24>)
3400fe8e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400fe92:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400fe96:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400fe9a:	d101      	bne.n	3400fea0 <LL_RCC_PLL2P_IsEnabled+0x18>
3400fe9c:	2301      	movs	r3, #1
3400fe9e:	e000      	b.n	3400fea2 <LL_RCC_PLL2P_IsEnabled+0x1a>
3400fea0:	2300      	movs	r3, #0
}
3400fea2:	4618      	mov	r0, r3
3400fea4:	46bd      	mov	sp, r7
3400fea6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400feaa:	4770      	bx	lr
3400feac:	56028000 	.word	0x56028000

3400feb0 <LL_RCC_PLL2_GetFRACN>:
{
3400feb0:	b480      	push	{r7}
3400feb2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >> RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos);
3400feb4:	4b04      	ldr	r3, [pc, #16]	@ (3400fec8 <LL_RCC_PLL2_GetFRACN+0x18>)
3400feb6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3400feba:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400febe:	4618      	mov	r0, r3
3400fec0:	46bd      	mov	sp, r7
3400fec2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fec6:	4770      	bx	lr
3400fec8:	56028000 	.word	0x56028000

3400fecc <LL_RCC_PLL3_GetSource>:
{
3400fecc:	b480      	push	{r7}
3400fece:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3SEL));
3400fed0:	4b04      	ldr	r3, [pc, #16]	@ (3400fee4 <LL_RCC_PLL3_GetSource+0x18>)
3400fed2:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400fed6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3400feda:	4618      	mov	r0, r3
3400fedc:	46bd      	mov	sp, r7
3400fede:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fee2:	4770      	bx	lr
3400fee4:	56028000 	.word	0x56028000

3400fee8 <LL_RCC_PLL3_IsReady>:
{
3400fee8:	b480      	push	{r7}
3400feea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL3RDY) == (RCC_SR_PLL3RDY)) ? 1UL : 0UL);
3400feec:	4b07      	ldr	r3, [pc, #28]	@ (3400ff0c <LL_RCC_PLL3_IsReady+0x24>)
3400feee:	685b      	ldr	r3, [r3, #4]
3400fef0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400fef4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3400fef8:	d101      	bne.n	3400fefe <LL_RCC_PLL3_IsReady+0x16>
3400fefa:	2301      	movs	r3, #1
3400fefc:	e000      	b.n	3400ff00 <LL_RCC_PLL3_IsReady+0x18>
3400fefe:	2300      	movs	r3, #0
}
3400ff00:	4618      	mov	r0, r3
3400ff02:	46bd      	mov	sp, r7
3400ff04:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ff08:	4770      	bx	lr
3400ff0a:	bf00      	nop
3400ff0c:	56028000 	.word	0x56028000

3400ff10 <LL_RCC_PLL3_IsEnabledBypass>:
{
3400ff10:	b480      	push	{r7}
3400ff12:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3BYP) == RCC_PLL3CFGR1_PLL3BYP) ? 1UL : 0UL);
3400ff14:	4b07      	ldr	r3, [pc, #28]	@ (3400ff34 <LL_RCC_PLL3_IsEnabledBypass+0x24>)
3400ff16:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ff1a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400ff1e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
3400ff22:	d101      	bne.n	3400ff28 <LL_RCC_PLL3_IsEnabledBypass+0x18>
3400ff24:	2301      	movs	r3, #1
3400ff26:	e000      	b.n	3400ff2a <LL_RCC_PLL3_IsEnabledBypass+0x1a>
3400ff28:	2300      	movs	r3, #0
}
3400ff2a:	4618      	mov	r0, r3
3400ff2c:	46bd      	mov	sp, r7
3400ff2e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ff32:	4770      	bx	lr
3400ff34:	56028000 	.word	0x56028000

3400ff38 <LL_RCC_PLL3_GetN>:
{
3400ff38:	b480      	push	{r7}
3400ff3a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVN) >> RCC_PLL3CFGR1_PLL3DIVN_Pos));
3400ff3c:	4b05      	ldr	r3, [pc, #20]	@ (3400ff54 <LL_RCC_PLL3_GetN+0x1c>)
3400ff3e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ff42:	0a1b      	lsrs	r3, r3, #8
3400ff44:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
3400ff48:	4618      	mov	r0, r3
3400ff4a:	46bd      	mov	sp, r7
3400ff4c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ff50:	4770      	bx	lr
3400ff52:	bf00      	nop
3400ff54:	56028000 	.word	0x56028000

3400ff58 <LL_RCC_PLL3_GetM>:
{
3400ff58:	b480      	push	{r7}
3400ff5a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR1, RCC_PLL3CFGR1_PLL3DIVM) >> RCC_PLL3CFGR1_PLL3DIVM_Pos);
3400ff5c:	4b05      	ldr	r3, [pc, #20]	@ (3400ff74 <LL_RCC_PLL3_GetM+0x1c>)
3400ff5e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400ff62:	0d1b      	lsrs	r3, r3, #20
3400ff64:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
3400ff68:	4618      	mov	r0, r3
3400ff6a:	46bd      	mov	sp, r7
3400ff6c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ff70:	4770      	bx	lr
3400ff72:	bf00      	nop
3400ff74:	56028000 	.word	0x56028000

3400ff78 <LL_RCC_PLL3_GetP1>:
{
3400ff78:	b480      	push	{r7}
3400ff7a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV1) >> RCC_PLL3CFGR3_PLL3PDIV1_Pos);
3400ff7c:	4b05      	ldr	r3, [pc, #20]	@ (3400ff94 <LL_RCC_PLL3_GetP1+0x1c>)
3400ff7e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400ff82:	0edb      	lsrs	r3, r3, #27
3400ff84:	f003 0307 	and.w	r3, r3, #7
}
3400ff88:	4618      	mov	r0, r3
3400ff8a:	46bd      	mov	sp, r7
3400ff8c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ff90:	4770      	bx	lr
3400ff92:	bf00      	nop
3400ff94:	56028000 	.word	0x56028000

3400ff98 <LL_RCC_PLL3_GetP2>:
{
3400ff98:	b480      	push	{r7}
3400ff9a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIV2) >> RCC_PLL3CFGR3_PLL3PDIV2_Pos);
3400ff9c:	4b05      	ldr	r3, [pc, #20]	@ (3400ffb4 <LL_RCC_PLL3_GetP2+0x1c>)
3400ff9e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400ffa2:	0e1b      	lsrs	r3, r3, #24
3400ffa4:	f003 0307 	and.w	r3, r3, #7
}
3400ffa8:	4618      	mov	r0, r3
3400ffaa:	46bd      	mov	sp, r7
3400ffac:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ffb0:	4770      	bx	lr
3400ffb2:	bf00      	nop
3400ffb4:	56028000 	.word	0x56028000

3400ffb8 <LL_RCC_PLL3P_IsEnabled>:
{
3400ffb8:	b480      	push	{r7}
3400ffba:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL3CFGR3, RCC_PLL3CFGR3_PLL3PDIVEN) == RCC_PLL3CFGR3_PLL3PDIVEN) ? 1UL : 0UL);
3400ffbc:	4b07      	ldr	r3, [pc, #28]	@ (3400ffdc <LL_RCC_PLL3P_IsEnabled+0x24>)
3400ffbe:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
3400ffc2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400ffc6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
3400ffca:	d101      	bne.n	3400ffd0 <LL_RCC_PLL3P_IsEnabled+0x18>
3400ffcc:	2301      	movs	r3, #1
3400ffce:	e000      	b.n	3400ffd2 <LL_RCC_PLL3P_IsEnabled+0x1a>
3400ffd0:	2300      	movs	r3, #0
}
3400ffd2:	4618      	mov	r0, r3
3400ffd4:	46bd      	mov	sp, r7
3400ffd6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ffda:	4770      	bx	lr
3400ffdc:	56028000 	.word	0x56028000

3400ffe0 <LL_RCC_PLL3_GetFRACN>:
{
3400ffe0:	b480      	push	{r7}
3400ffe2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >> RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos);
3400ffe4:	4b04      	ldr	r3, [pc, #16]	@ (3400fff8 <LL_RCC_PLL3_GetFRACN+0x18>)
3400ffe6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3400ffea:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3400ffee:	4618      	mov	r0, r3
3400fff0:	46bd      	mov	sp, r7
3400fff2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fff6:	4770      	bx	lr
3400fff8:	56028000 	.word	0x56028000

3400fffc <LL_RCC_PLL4_GetSource>:
{
3400fffc:	b480      	push	{r7}
3400fffe:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4SEL));
34010000:	4b04      	ldr	r3, [pc, #16]	@ (34010014 <LL_RCC_PLL4_GetSource+0x18>)
34010002:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34010006:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
}
3401000a:	4618      	mov	r0, r3
3401000c:	46bd      	mov	sp, r7
3401000e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010012:	4770      	bx	lr
34010014:	56028000 	.word	0x56028000

34010018 <LL_RCC_PLL4_IsReady>:
{
34010018:	b480      	push	{r7}
3401001a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_PLL4RDY) == (RCC_SR_PLL4RDY)) ? 1UL : 0UL);
3401001c:	4b07      	ldr	r3, [pc, #28]	@ (3401003c <LL_RCC_PLL4_IsReady+0x24>)
3401001e:	685b      	ldr	r3, [r3, #4]
34010020:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34010024:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34010028:	d101      	bne.n	3401002e <LL_RCC_PLL4_IsReady+0x16>
3401002a:	2301      	movs	r3, #1
3401002c:	e000      	b.n	34010030 <LL_RCC_PLL4_IsReady+0x18>
3401002e:	2300      	movs	r3, #0
}
34010030:	4618      	mov	r0, r3
34010032:	46bd      	mov	sp, r7
34010034:	f85d 7b04 	ldr.w	r7, [sp], #4
34010038:	4770      	bx	lr
3401003a:	bf00      	nop
3401003c:	56028000 	.word	0x56028000

34010040 <LL_RCC_PLL4_IsEnabledBypass>:
{
34010040:	b480      	push	{r7}
34010042:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4BYP) == RCC_PLL4CFGR1_PLL4BYP) ? 1UL : 0UL);
34010044:	4b07      	ldr	r3, [pc, #28]	@ (34010064 <LL_RCC_PLL4_IsEnabledBypass+0x24>)
34010046:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
3401004a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3401004e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34010052:	d101      	bne.n	34010058 <LL_RCC_PLL4_IsEnabledBypass+0x18>
34010054:	2301      	movs	r3, #1
34010056:	e000      	b.n	3401005a <LL_RCC_PLL4_IsEnabledBypass+0x1a>
34010058:	2300      	movs	r3, #0
}
3401005a:	4618      	mov	r0, r3
3401005c:	46bd      	mov	sp, r7
3401005e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010062:	4770      	bx	lr
34010064:	56028000 	.word	0x56028000

34010068 <LL_RCC_PLL4_GetN>:
{
34010068:	b480      	push	{r7}
3401006a:	af00      	add	r7, sp, #0
  return (uint32_t)((READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVN) >> RCC_PLL4CFGR1_PLL4DIVN_Pos));
3401006c:	4b05      	ldr	r3, [pc, #20]	@ (34010084 <LL_RCC_PLL4_GetN+0x1c>)
3401006e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34010072:	0a1b      	lsrs	r3, r3, #8
34010074:	f3c3 030b 	ubfx	r3, r3, #0, #12
}
34010078:	4618      	mov	r0, r3
3401007a:	46bd      	mov	sp, r7
3401007c:	f85d 7b04 	ldr.w	r7, [sp], #4
34010080:	4770      	bx	lr
34010082:	bf00      	nop
34010084:	56028000 	.word	0x56028000

34010088 <LL_RCC_PLL4_GetM>:
{
34010088:	b480      	push	{r7}
3401008a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR1, RCC_PLL4CFGR1_PLL4DIVM) >> RCC_PLL4CFGR1_PLL4DIVM_Pos);
3401008c:	4b05      	ldr	r3, [pc, #20]	@ (340100a4 <LL_RCC_PLL4_GetM+0x1c>)
3401008e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34010092:	0d1b      	lsrs	r3, r3, #20
34010094:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
}
34010098:	4618      	mov	r0, r3
3401009a:	46bd      	mov	sp, r7
3401009c:	f85d 7b04 	ldr.w	r7, [sp], #4
340100a0:	4770      	bx	lr
340100a2:	bf00      	nop
340100a4:	56028000 	.word	0x56028000

340100a8 <LL_RCC_PLL4_GetP1>:
{
340100a8:	b480      	push	{r7}
340100aa:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV1) >> RCC_PLL4CFGR3_PLL4PDIV1_Pos);
340100ac:	4b05      	ldr	r3, [pc, #20]	@ (340100c4 <LL_RCC_PLL4_GetP1+0x1c>)
340100ae:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340100b2:	0edb      	lsrs	r3, r3, #27
340100b4:	f003 0307 	and.w	r3, r3, #7
}
340100b8:	4618      	mov	r0, r3
340100ba:	46bd      	mov	sp, r7
340100bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340100c0:	4770      	bx	lr
340100c2:	bf00      	nop
340100c4:	56028000 	.word	0x56028000

340100c8 <LL_RCC_PLL4_GetP2>:
{
340100c8:	b480      	push	{r7}
340100ca:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIV2) >> RCC_PLL4CFGR3_PLL4PDIV2_Pos);
340100cc:	4b05      	ldr	r3, [pc, #20]	@ (340100e4 <LL_RCC_PLL4_GetP2+0x1c>)
340100ce:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340100d2:	0e1b      	lsrs	r3, r3, #24
340100d4:	f003 0307 	and.w	r3, r3, #7
}
340100d8:	4618      	mov	r0, r3
340100da:	46bd      	mov	sp, r7
340100dc:	f85d 7b04 	ldr.w	r7, [sp], #4
340100e0:	4770      	bx	lr
340100e2:	bf00      	nop
340100e4:	56028000 	.word	0x56028000

340100e8 <LL_RCC_PLL4P_IsEnabled>:
{
340100e8:	b480      	push	{r7}
340100ea:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->PLL4CFGR3, RCC_PLL4CFGR3_PLL4PDIVEN) == RCC_PLL4CFGR3_PLL4PDIVEN) ? 1UL : 0UL);
340100ec:	4b07      	ldr	r3, [pc, #28]	@ (3401010c <LL_RCC_PLL4P_IsEnabled+0x24>)
340100ee:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340100f2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
340100f6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
340100fa:	d101      	bne.n	34010100 <LL_RCC_PLL4P_IsEnabled+0x18>
340100fc:	2301      	movs	r3, #1
340100fe:	e000      	b.n	34010102 <LL_RCC_PLL4P_IsEnabled+0x1a>
34010100:	2300      	movs	r3, #0
}
34010102:	4618      	mov	r0, r3
34010104:	46bd      	mov	sp, r7
34010106:	f85d 7b04 	ldr.w	r7, [sp], #4
3401010a:	4770      	bx	lr
3401010c:	56028000 	.word	0x56028000

34010110 <LL_RCC_PLL4_GetFRACN>:
{
34010110:	b480      	push	{r7}
34010112:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >> RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos);
34010114:	4b04      	ldr	r3, [pc, #16]	@ (34010128 <LL_RCC_PLL4_GetFRACN+0x18>)
34010116:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3401011a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
}
3401011e:	4618      	mov	r0, r3
34010120:	46bd      	mov	sp, r7
34010122:	f85d 7b04 	ldr.w	r7, [sp], #4
34010126:	4770      	bx	lr
34010128:	56028000 	.word	0x56028000

3401012c <LL_RCC_IC3_Enable>:
{
3401012c:	b480      	push	{r7}
3401012e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34010130:	4b04      	ldr	r3, [pc, #16]	@ (34010144 <LL_RCC_IC3_Enable+0x18>)
34010132:	2204      	movs	r2, #4
34010134:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34010138:	bf00      	nop
3401013a:	46bd      	mov	sp, r7
3401013c:	f85d 7b04 	ldr.w	r7, [sp], #4
34010140:	4770      	bx	lr
34010142:	bf00      	nop
34010144:	56028000 	.word	0x56028000

34010148 <LL_RCC_IC3_IsEnabled>:
{
34010148:	b480      	push	{r7}
3401014a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC3EN) == RCC_DIVENR_IC3EN) ? 1UL : 0UL);
3401014c:	4b07      	ldr	r3, [pc, #28]	@ (3401016c <LL_RCC_IC3_IsEnabled+0x24>)
3401014e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010152:	f003 0304 	and.w	r3, r3, #4
34010156:	2b04      	cmp	r3, #4
34010158:	d101      	bne.n	3401015e <LL_RCC_IC3_IsEnabled+0x16>
3401015a:	2301      	movs	r3, #1
3401015c:	e000      	b.n	34010160 <LL_RCC_IC3_IsEnabled+0x18>
3401015e:	2300      	movs	r3, #0
}
34010160:	4618      	mov	r0, r3
34010162:	46bd      	mov	sp, r7
34010164:	f85d 7b04 	ldr.w	r7, [sp], #4
34010168:	4770      	bx	lr
3401016a:	bf00      	nop
3401016c:	56028000 	.word	0x56028000

34010170 <LL_RCC_IC3_GetSource>:
{
34010170:	b480      	push	{r7}
34010172:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL));
34010174:	4b04      	ldr	r3, [pc, #16]	@ (34010188 <LL_RCC_IC3_GetSource+0x18>)
34010176:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3401017a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401017e:	4618      	mov	r0, r3
34010180:	46bd      	mov	sp, r7
34010182:	f85d 7b04 	ldr.w	r7, [sp], #4
34010186:	4770      	bx	lr
34010188:	56028000 	.word	0x56028000

3401018c <LL_RCC_IC3_GetDivider>:
{
3401018c:	b480      	push	{r7}
3401018e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC3CFGR, RCC_IC3CFGR_IC3INT) >> RCC_IC3CFGR_IC3INT_Pos) + 1UL);
34010190:	4b05      	ldr	r3, [pc, #20]	@ (340101a8 <LL_RCC_IC3_GetDivider+0x1c>)
34010192:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010196:	0c1b      	lsrs	r3, r3, #16
34010198:	b2db      	uxtb	r3, r3
3401019a:	3301      	adds	r3, #1
}
3401019c:	4618      	mov	r0, r3
3401019e:	46bd      	mov	sp, r7
340101a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340101a4:	4770      	bx	lr
340101a6:	bf00      	nop
340101a8:	56028000 	.word	0x56028000

340101ac <LL_RCC_IC4_Enable>:
{
340101ac:	b480      	push	{r7}
340101ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
340101b0:	4b04      	ldr	r3, [pc, #16]	@ (340101c4 <LL_RCC_IC4_Enable+0x18>)
340101b2:	2208      	movs	r2, #8
340101b4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340101b8:	bf00      	nop
340101ba:	46bd      	mov	sp, r7
340101bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340101c0:	4770      	bx	lr
340101c2:	bf00      	nop
340101c4:	56028000 	.word	0x56028000

340101c8 <LL_RCC_IC4_IsEnabled>:
{
340101c8:	b480      	push	{r7}
340101ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC4EN) == RCC_DIVENR_IC4EN) ? 1UL : 0UL);
340101cc:	4b07      	ldr	r3, [pc, #28]	@ (340101ec <LL_RCC_IC4_IsEnabled+0x24>)
340101ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340101d2:	f003 0308 	and.w	r3, r3, #8
340101d6:	2b08      	cmp	r3, #8
340101d8:	d101      	bne.n	340101de <LL_RCC_IC4_IsEnabled+0x16>
340101da:	2301      	movs	r3, #1
340101dc:	e000      	b.n	340101e0 <LL_RCC_IC4_IsEnabled+0x18>
340101de:	2300      	movs	r3, #0
}
340101e0:	4618      	mov	r0, r3
340101e2:	46bd      	mov	sp, r7
340101e4:	f85d 7b04 	ldr.w	r7, [sp], #4
340101e8:	4770      	bx	lr
340101ea:	bf00      	nop
340101ec:	56028000 	.word	0x56028000

340101f0 <LL_RCC_IC4_GetSource>:
{
340101f0:	b480      	push	{r7}
340101f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL));
340101f4:	4b04      	ldr	r3, [pc, #16]	@ (34010208 <LL_RCC_IC4_GetSource+0x18>)
340101f6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340101fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340101fe:	4618      	mov	r0, r3
34010200:	46bd      	mov	sp, r7
34010202:	f85d 7b04 	ldr.w	r7, [sp], #4
34010206:	4770      	bx	lr
34010208:	56028000 	.word	0x56028000

3401020c <LL_RCC_IC4_GetDivider>:
{
3401020c:	b480      	push	{r7}
3401020e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC4CFGR, RCC_IC4CFGR_IC4INT) >> RCC_IC4CFGR_IC4INT_Pos) + 1UL);
34010210:	4b05      	ldr	r3, [pc, #20]	@ (34010228 <LL_RCC_IC4_GetDivider+0x1c>)
34010212:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010216:	0c1b      	lsrs	r3, r3, #16
34010218:	b2db      	uxtb	r3, r3
3401021a:	3301      	adds	r3, #1
}
3401021c:	4618      	mov	r0, r3
3401021e:	46bd      	mov	sp, r7
34010220:	f85d 7b04 	ldr.w	r7, [sp], #4
34010224:	4770      	bx	lr
34010226:	bf00      	nop
34010228:	56028000 	.word	0x56028000

3401022c <LL_RCC_IC5_Enable>:
{
3401022c:	b480      	push	{r7}
3401022e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
34010230:	4b04      	ldr	r3, [pc, #16]	@ (34010244 <LL_RCC_IC5_Enable+0x18>)
34010232:	2210      	movs	r2, #16
34010234:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34010238:	bf00      	nop
3401023a:	46bd      	mov	sp, r7
3401023c:	f85d 7b04 	ldr.w	r7, [sp], #4
34010240:	4770      	bx	lr
34010242:	bf00      	nop
34010244:	56028000 	.word	0x56028000

34010248 <LL_RCC_IC5_IsEnabled>:
{
34010248:	b480      	push	{r7}
3401024a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC5EN) == RCC_DIVENR_IC5EN) ? 1UL : 0UL);
3401024c:	4b07      	ldr	r3, [pc, #28]	@ (3401026c <LL_RCC_IC5_IsEnabled+0x24>)
3401024e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010252:	f003 0310 	and.w	r3, r3, #16
34010256:	2b10      	cmp	r3, #16
34010258:	d101      	bne.n	3401025e <LL_RCC_IC5_IsEnabled+0x16>
3401025a:	2301      	movs	r3, #1
3401025c:	e000      	b.n	34010260 <LL_RCC_IC5_IsEnabled+0x18>
3401025e:	2300      	movs	r3, #0
}
34010260:	4618      	mov	r0, r3
34010262:	46bd      	mov	sp, r7
34010264:	f85d 7b04 	ldr.w	r7, [sp], #4
34010268:	4770      	bx	lr
3401026a:	bf00      	nop
3401026c:	56028000 	.word	0x56028000

34010270 <LL_RCC_IC5_GetSource>:
{
34010270:	b480      	push	{r7}
34010272:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL));
34010274:	4b04      	ldr	r3, [pc, #16]	@ (34010288 <LL_RCC_IC5_GetSource+0x18>)
34010276:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3401027a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401027e:	4618      	mov	r0, r3
34010280:	46bd      	mov	sp, r7
34010282:	f85d 7b04 	ldr.w	r7, [sp], #4
34010286:	4770      	bx	lr
34010288:	56028000 	.word	0x56028000

3401028c <LL_RCC_IC5_GetDivider>:
{
3401028c:	b480      	push	{r7}
3401028e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC5CFGR, RCC_IC5CFGR_IC5INT) >> RCC_IC5CFGR_IC5INT_Pos) + 1UL);
34010290:	4b05      	ldr	r3, [pc, #20]	@ (340102a8 <LL_RCC_IC5_GetDivider+0x1c>)
34010292:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010296:	0c1b      	lsrs	r3, r3, #16
34010298:	b2db      	uxtb	r3, r3
3401029a:	3301      	adds	r3, #1
}
3401029c:	4618      	mov	r0, r3
3401029e:	46bd      	mov	sp, r7
340102a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340102a4:	4770      	bx	lr
340102a6:	bf00      	nop
340102a8:	56028000 	.word	0x56028000

340102ac <LL_RCC_IC7_Enable>:
{
340102ac:	b480      	push	{r7}
340102ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
340102b0:	4b04      	ldr	r3, [pc, #16]	@ (340102c4 <LL_RCC_IC7_Enable+0x18>)
340102b2:	2240      	movs	r2, #64	@ 0x40
340102b4:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340102b8:	bf00      	nop
340102ba:	46bd      	mov	sp, r7
340102bc:	f85d 7b04 	ldr.w	r7, [sp], #4
340102c0:	4770      	bx	lr
340102c2:	bf00      	nop
340102c4:	56028000 	.word	0x56028000

340102c8 <LL_RCC_IC7_IsEnabled>:
{
340102c8:	b480      	push	{r7}
340102ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC7EN) == RCC_DIVENR_IC7EN) ? 1UL : 0UL);
340102cc:	4b07      	ldr	r3, [pc, #28]	@ (340102ec <LL_RCC_IC7_IsEnabled+0x24>)
340102ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340102d2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340102d6:	2b40      	cmp	r3, #64	@ 0x40
340102d8:	d101      	bne.n	340102de <LL_RCC_IC7_IsEnabled+0x16>
340102da:	2301      	movs	r3, #1
340102dc:	e000      	b.n	340102e0 <LL_RCC_IC7_IsEnabled+0x18>
340102de:	2300      	movs	r3, #0
}
340102e0:	4618      	mov	r0, r3
340102e2:	46bd      	mov	sp, r7
340102e4:	f85d 7b04 	ldr.w	r7, [sp], #4
340102e8:	4770      	bx	lr
340102ea:	bf00      	nop
340102ec:	56028000 	.word	0x56028000

340102f0 <LL_RCC_IC7_GetSource>:
{
340102f0:	b480      	push	{r7}
340102f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL));
340102f4:	4b04      	ldr	r3, [pc, #16]	@ (34010308 <LL_RCC_IC7_GetSource+0x18>)
340102f6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340102fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340102fe:	4618      	mov	r0, r3
34010300:	46bd      	mov	sp, r7
34010302:	f85d 7b04 	ldr.w	r7, [sp], #4
34010306:	4770      	bx	lr
34010308:	56028000 	.word	0x56028000

3401030c <LL_RCC_IC7_GetDivider>:
{
3401030c:	b480      	push	{r7}
3401030e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC7CFGR, RCC_IC7CFGR_IC7INT) >> RCC_IC7CFGR_IC7INT_Pos) + 1UL);
34010310:	4b05      	ldr	r3, [pc, #20]	@ (34010328 <LL_RCC_IC7_GetDivider+0x1c>)
34010312:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34010316:	0c1b      	lsrs	r3, r3, #16
34010318:	b2db      	uxtb	r3, r3
3401031a:	3301      	adds	r3, #1
}
3401031c:	4618      	mov	r0, r3
3401031e:	46bd      	mov	sp, r7
34010320:	f85d 7b04 	ldr.w	r7, [sp], #4
34010324:	4770      	bx	lr
34010326:	bf00      	nop
34010328:	56028000 	.word	0x56028000

3401032c <LL_RCC_IC8_Enable>:
{
3401032c:	b480      	push	{r7}
3401032e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
34010330:	4b04      	ldr	r3, [pc, #16]	@ (34010344 <LL_RCC_IC8_Enable+0x18>)
34010332:	2280      	movs	r2, #128	@ 0x80
34010334:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34010338:	bf00      	nop
3401033a:	46bd      	mov	sp, r7
3401033c:	f85d 7b04 	ldr.w	r7, [sp], #4
34010340:	4770      	bx	lr
34010342:	bf00      	nop
34010344:	56028000 	.word	0x56028000

34010348 <LL_RCC_IC8_IsEnabled>:
{
34010348:	b480      	push	{r7}
3401034a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC8EN) == RCC_DIVENR_IC8EN) ? 1UL : 0UL);
3401034c:	4b07      	ldr	r3, [pc, #28]	@ (3401036c <LL_RCC_IC8_IsEnabled+0x24>)
3401034e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010352:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34010356:	2b80      	cmp	r3, #128	@ 0x80
34010358:	d101      	bne.n	3401035e <LL_RCC_IC8_IsEnabled+0x16>
3401035a:	2301      	movs	r3, #1
3401035c:	e000      	b.n	34010360 <LL_RCC_IC8_IsEnabled+0x18>
3401035e:	2300      	movs	r3, #0
}
34010360:	4618      	mov	r0, r3
34010362:	46bd      	mov	sp, r7
34010364:	f85d 7b04 	ldr.w	r7, [sp], #4
34010368:	4770      	bx	lr
3401036a:	bf00      	nop
3401036c:	56028000 	.word	0x56028000

34010370 <LL_RCC_IC8_GetSource>:
{
34010370:	b480      	push	{r7}
34010372:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL));
34010374:	4b04      	ldr	r3, [pc, #16]	@ (34010388 <LL_RCC_IC8_GetSource+0x18>)
34010376:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3401037a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401037e:	4618      	mov	r0, r3
34010380:	46bd      	mov	sp, r7
34010382:	f85d 7b04 	ldr.w	r7, [sp], #4
34010386:	4770      	bx	lr
34010388:	56028000 	.word	0x56028000

3401038c <LL_RCC_IC8_GetDivider>:
{
3401038c:	b480      	push	{r7}
3401038e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC8CFGR, RCC_IC8CFGR_IC8INT) >> RCC_IC8CFGR_IC8INT_Pos) + 1UL);
34010390:	4b05      	ldr	r3, [pc, #20]	@ (340103a8 <LL_RCC_IC8_GetDivider+0x1c>)
34010392:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34010396:	0c1b      	lsrs	r3, r3, #16
34010398:	b2db      	uxtb	r3, r3
3401039a:	3301      	adds	r3, #1
}
3401039c:	4618      	mov	r0, r3
3401039e:	46bd      	mov	sp, r7
340103a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340103a4:	4770      	bx	lr
340103a6:	bf00      	nop
340103a8:	56028000 	.word	0x56028000

340103ac <LL_RCC_IC9_Enable>:
{
340103ac:	b480      	push	{r7}
340103ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340103b0:	4b04      	ldr	r3, [pc, #16]	@ (340103c4 <LL_RCC_IC9_Enable+0x18>)
340103b2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340103b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340103ba:	bf00      	nop
340103bc:	46bd      	mov	sp, r7
340103be:	f85d 7b04 	ldr.w	r7, [sp], #4
340103c2:	4770      	bx	lr
340103c4:	56028000 	.word	0x56028000

340103c8 <LL_RCC_IC9_IsEnabled>:
{
340103c8:	b480      	push	{r7}
340103ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC9EN) == RCC_DIVENR_IC9EN) ? 1UL : 0UL);
340103cc:	4b07      	ldr	r3, [pc, #28]	@ (340103ec <LL_RCC_IC9_IsEnabled+0x24>)
340103ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340103d2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340103d6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340103da:	d101      	bne.n	340103e0 <LL_RCC_IC9_IsEnabled+0x18>
340103dc:	2301      	movs	r3, #1
340103de:	e000      	b.n	340103e2 <LL_RCC_IC9_IsEnabled+0x1a>
340103e0:	2300      	movs	r3, #0
}
340103e2:	4618      	mov	r0, r3
340103e4:	46bd      	mov	sp, r7
340103e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340103ea:	4770      	bx	lr
340103ec:	56028000 	.word	0x56028000

340103f0 <LL_RCC_IC9_GetSource>:
{
340103f0:	b480      	push	{r7}
340103f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL));
340103f4:	4b04      	ldr	r3, [pc, #16]	@ (34010408 <LL_RCC_IC9_GetSource+0x18>)
340103f6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340103fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340103fe:	4618      	mov	r0, r3
34010400:	46bd      	mov	sp, r7
34010402:	f85d 7b04 	ldr.w	r7, [sp], #4
34010406:	4770      	bx	lr
34010408:	56028000 	.word	0x56028000

3401040c <LL_RCC_IC9_GetDivider>:
{
3401040c:	b480      	push	{r7}
3401040e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC9CFGR, RCC_IC9CFGR_IC9INT) >> RCC_IC9CFGR_IC9INT_Pos) + 1UL);
34010410:	4b05      	ldr	r3, [pc, #20]	@ (34010428 <LL_RCC_IC9_GetDivider+0x1c>)
34010412:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34010416:	0c1b      	lsrs	r3, r3, #16
34010418:	b2db      	uxtb	r3, r3
3401041a:	3301      	adds	r3, #1
}
3401041c:	4618      	mov	r0, r3
3401041e:	46bd      	mov	sp, r7
34010420:	f85d 7b04 	ldr.w	r7, [sp], #4
34010424:	4770      	bx	lr
34010426:	bf00      	nop
34010428:	56028000 	.word	0x56028000

3401042c <LL_RCC_IC10_Enable>:
{
3401042c:	b480      	push	{r7}
3401042e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
34010430:	4b04      	ldr	r3, [pc, #16]	@ (34010444 <LL_RCC_IC10_Enable+0x18>)
34010432:	f44f 7200 	mov.w	r2, #512	@ 0x200
34010436:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3401043a:	bf00      	nop
3401043c:	46bd      	mov	sp, r7
3401043e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010442:	4770      	bx	lr
34010444:	56028000 	.word	0x56028000

34010448 <LL_RCC_IC10_IsEnabled>:
{
34010448:	b480      	push	{r7}
3401044a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC10EN) == RCC_DIVENR_IC10EN) ? 1UL : 0UL);
3401044c:	4b07      	ldr	r3, [pc, #28]	@ (3401046c <LL_RCC_IC10_IsEnabled+0x24>)
3401044e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010452:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34010456:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401045a:	d101      	bne.n	34010460 <LL_RCC_IC10_IsEnabled+0x18>
3401045c:	2301      	movs	r3, #1
3401045e:	e000      	b.n	34010462 <LL_RCC_IC10_IsEnabled+0x1a>
34010460:	2300      	movs	r3, #0
}
34010462:	4618      	mov	r0, r3
34010464:	46bd      	mov	sp, r7
34010466:	f85d 7b04 	ldr.w	r7, [sp], #4
3401046a:	4770      	bx	lr
3401046c:	56028000 	.word	0x56028000

34010470 <LL_RCC_IC10_GetSource>:
{
34010470:	b480      	push	{r7}
34010472:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL));
34010474:	4b04      	ldr	r3, [pc, #16]	@ (34010488 <LL_RCC_IC10_GetSource+0x18>)
34010476:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401047a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401047e:	4618      	mov	r0, r3
34010480:	46bd      	mov	sp, r7
34010482:	f85d 7b04 	ldr.w	r7, [sp], #4
34010486:	4770      	bx	lr
34010488:	56028000 	.word	0x56028000

3401048c <LL_RCC_IC10_GetDivider>:
{
3401048c:	b480      	push	{r7}
3401048e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC10CFGR, RCC_IC10CFGR_IC10INT) >> RCC_IC10CFGR_IC10INT_Pos) + 1UL);
34010490:	4b05      	ldr	r3, [pc, #20]	@ (340104a8 <LL_RCC_IC10_GetDivider+0x1c>)
34010492:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34010496:	0c1b      	lsrs	r3, r3, #16
34010498:	b2db      	uxtb	r3, r3
3401049a:	3301      	adds	r3, #1
}
3401049c:	4618      	mov	r0, r3
3401049e:	46bd      	mov	sp, r7
340104a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340104a4:	4770      	bx	lr
340104a6:	bf00      	nop
340104a8:	56028000 	.word	0x56028000

340104ac <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
340104ac:	b480      	push	{r7}
340104ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
340104b0:	4b04      	ldr	r3, [pc, #16]	@ (340104c4 <LL_RCC_IC12_Enable+0x18>)
340104b2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340104b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340104ba:	bf00      	nop
340104bc:	46bd      	mov	sp, r7
340104be:	f85d 7b04 	ldr.w	r7, [sp], #4
340104c2:	4770      	bx	lr
340104c4:	56028000 	.word	0x56028000

340104c8 <LL_RCC_IC12_IsEnabled>:
  * @brief  Check if IC12 is enabled
  * @rmtoll DIVENR       IC12EN         LL_RCC_IC12_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_IsEnabled(void)
{
340104c8:	b480      	push	{r7}
340104ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC12EN) == RCC_DIVENR_IC12EN) ? 1UL : 0UL);
340104cc:	4b07      	ldr	r3, [pc, #28]	@ (340104ec <LL_RCC_IC12_IsEnabled+0x24>)
340104ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340104d2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340104d6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
340104da:	d101      	bne.n	340104e0 <LL_RCC_IC12_IsEnabled+0x18>
340104dc:	2301      	movs	r3, #1
340104de:	e000      	b.n	340104e2 <LL_RCC_IC12_IsEnabled+0x1a>
340104e0:	2300      	movs	r3, #0
}
340104e2:	4618      	mov	r0, r3
340104e4:	46bd      	mov	sp, r7
340104e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340104ea:	4770      	bx	lr
340104ec:	56028000 	.word	0x56028000

340104f0 <LL_RCC_IC12_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetSource(void)
{
340104f0:	b480      	push	{r7}
340104f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL));
340104f4:	4b04      	ldr	r3, [pc, #16]	@ (34010508 <LL_RCC_IC12_GetSource+0x18>)
340104f6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
340104fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340104fe:	4618      	mov	r0, r3
34010500:	46bd      	mov	sp, r7
34010502:	f85d 7b04 	ldr.w	r7, [sp], #4
34010506:	4770      	bx	lr
34010508:	56028000 	.word	0x56028000

3401050c <LL_RCC_IC12_GetDivider>:
  * @brief  Get IC12 divider
  * @rmtoll IC12CFGR      IC12INT        LL_RCC_IC12_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC12_GetDivider(void)
{
3401050c:	b480      	push	{r7}
3401050e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC12CFGR, RCC_IC12CFGR_IC12INT) >> RCC_IC12CFGR_IC12INT_Pos) + 1UL);
34010510:	4b05      	ldr	r3, [pc, #20]	@ (34010528 <LL_RCC_IC12_GetDivider+0x1c>)
34010512:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34010516:	0c1b      	lsrs	r3, r3, #16
34010518:	b2db      	uxtb	r3, r3
3401051a:	3301      	adds	r3, #1
}
3401051c:	4618      	mov	r0, r3
3401051e:	46bd      	mov	sp, r7
34010520:	f85d 7b04 	ldr.w	r7, [sp], #4
34010524:	4770      	bx	lr
34010526:	bf00      	nop
34010528:	56028000 	.word	0x56028000

3401052c <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
3401052c:	b480      	push	{r7}
3401052e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34010530:	4b04      	ldr	r3, [pc, #16]	@ (34010544 <LL_RCC_IC13_Enable+0x18>)
34010532:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
34010536:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3401053a:	bf00      	nop
3401053c:	46bd      	mov	sp, r7
3401053e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010542:	4770      	bx	lr
34010544:	56028000 	.word	0x56028000

34010548 <LL_RCC_IC13_IsEnabled>:
  * @brief  Check if IC13 is enabled
  * @rmtoll DIVENR       IC13EN         LL_RCC_IC13_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_IsEnabled(void)
{
34010548:	b480      	push	{r7}
3401054a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC13EN) == RCC_DIVENR_IC13EN) ? 1UL : 0UL);
3401054c:	4b07      	ldr	r3, [pc, #28]	@ (3401056c <LL_RCC_IC13_IsEnabled+0x24>)
3401054e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010552:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34010556:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401055a:	d101      	bne.n	34010560 <LL_RCC_IC13_IsEnabled+0x18>
3401055c:	2301      	movs	r3, #1
3401055e:	e000      	b.n	34010562 <LL_RCC_IC13_IsEnabled+0x1a>
34010560:	2300      	movs	r3, #0
}
34010562:	4618      	mov	r0, r3
34010564:	46bd      	mov	sp, r7
34010566:	f85d 7b04 	ldr.w	r7, [sp], #4
3401056a:	4770      	bx	lr
3401056c:	56028000 	.word	0x56028000

34010570 <LL_RCC_IC13_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetSource(void)
{
34010570:	b480      	push	{r7}
34010572:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL));
34010574:	4b04      	ldr	r3, [pc, #16]	@ (34010588 <LL_RCC_IC13_GetSource+0x18>)
34010576:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
3401057a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401057e:	4618      	mov	r0, r3
34010580:	46bd      	mov	sp, r7
34010582:	f85d 7b04 	ldr.w	r7, [sp], #4
34010586:	4770      	bx	lr
34010588:	56028000 	.word	0x56028000

3401058c <LL_RCC_IC13_GetDivider>:
  * @brief  Get IC13 divider
  * @rmtoll IC13CFGR      IC13INT        LL_RCC_IC13_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC13_GetDivider(void)
{
3401058c:	b480      	push	{r7}
3401058e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC13CFGR, RCC_IC13CFGR_IC13INT) >> RCC_IC13CFGR_IC13INT_Pos) + 1UL);
34010590:	4b05      	ldr	r3, [pc, #20]	@ (340105a8 <LL_RCC_IC13_GetDivider+0x1c>)
34010592:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34010596:	0c1b      	lsrs	r3, r3, #16
34010598:	b2db      	uxtb	r3, r3
3401059a:	3301      	adds	r3, #1
}
3401059c:	4618      	mov	r0, r3
3401059e:	46bd      	mov	sp, r7
340105a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340105a4:	4770      	bx	lr
340105a6:	bf00      	nop
340105a8:	56028000 	.word	0x56028000

340105ac <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
340105ac:	b480      	push	{r7}
340105ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
340105b0:	4b04      	ldr	r3, [pc, #16]	@ (340105c4 <LL_RCC_IC14_Enable+0x18>)
340105b2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
340105b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340105ba:	bf00      	nop
340105bc:	46bd      	mov	sp, r7
340105be:	f85d 7b04 	ldr.w	r7, [sp], #4
340105c2:	4770      	bx	lr
340105c4:	56028000 	.word	0x56028000

340105c8 <LL_RCC_IC14_IsEnabled>:
  * @brief  Check if IC14 is enabled
  * @rmtoll DIVENR       IC14EN         LL_RCC_IC14_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_IsEnabled(void)
{
340105c8:	b480      	push	{r7}
340105ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC14EN) == RCC_DIVENR_IC14EN) ? 1UL : 0UL);
340105cc:	4b07      	ldr	r3, [pc, #28]	@ (340105ec <LL_RCC_IC14_IsEnabled+0x24>)
340105ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340105d2:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
340105d6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340105da:	d101      	bne.n	340105e0 <LL_RCC_IC14_IsEnabled+0x18>
340105dc:	2301      	movs	r3, #1
340105de:	e000      	b.n	340105e2 <LL_RCC_IC14_IsEnabled+0x1a>
340105e0:	2300      	movs	r3, #0
}
340105e2:	4618      	mov	r0, r3
340105e4:	46bd      	mov	sp, r7
340105e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340105ea:	4770      	bx	lr
340105ec:	56028000 	.word	0x56028000

340105f0 <LL_RCC_IC14_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetSource(void)
{
340105f0:	b480      	push	{r7}
340105f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL));
340105f4:	4b04      	ldr	r3, [pc, #16]	@ (34010608 <LL_RCC_IC14_GetSource+0x18>)
340105f6:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340105fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340105fe:	4618      	mov	r0, r3
34010600:	46bd      	mov	sp, r7
34010602:	f85d 7b04 	ldr.w	r7, [sp], #4
34010606:	4770      	bx	lr
34010608:	56028000 	.word	0x56028000

3401060c <LL_RCC_IC14_GetDivider>:
  * @brief  Get IC14 divider
  * @rmtoll IC14CFGR      IC14INT        LL_RCC_IC14_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC14_GetDivider(void)
{
3401060c:	b480      	push	{r7}
3401060e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC14CFGR, RCC_IC14CFGR_IC14INT) >> RCC_IC14CFGR_IC14INT_Pos) + 1UL);
34010610:	4b05      	ldr	r3, [pc, #20]	@ (34010628 <LL_RCC_IC14_GetDivider+0x1c>)
34010612:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34010616:	0c1b      	lsrs	r3, r3, #16
34010618:	b2db      	uxtb	r3, r3
3401061a:	3301      	adds	r3, #1
}
3401061c:	4618      	mov	r0, r3
3401061e:	46bd      	mov	sp, r7
34010620:	f85d 7b04 	ldr.w	r7, [sp], #4
34010624:	4770      	bx	lr
34010626:	bf00      	nop
34010628:	56028000 	.word	0x56028000

3401062c <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
3401062c:	b480      	push	{r7}
3401062e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
34010630:	4b04      	ldr	r3, [pc, #16]	@ (34010644 <LL_RCC_IC15_Enable+0x18>)
34010632:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34010636:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3401063a:	bf00      	nop
3401063c:	46bd      	mov	sp, r7
3401063e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010642:	4770      	bx	lr
34010644:	56028000 	.word	0x56028000

34010648 <LL_RCC_IC15_IsEnabled>:
  * @brief  Check if IC15 is enabled
  * @rmtoll DIVENR       IC15EN         LL_RCC_IC15_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_IsEnabled(void)
{
34010648:	b480      	push	{r7}
3401064a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC15EN) == RCC_DIVENR_IC15EN) ? 1UL : 0UL);
3401064c:	4b07      	ldr	r3, [pc, #28]	@ (3401066c <LL_RCC_IC15_IsEnabled+0x24>)
3401064e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010652:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34010656:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
3401065a:	d101      	bne.n	34010660 <LL_RCC_IC15_IsEnabled+0x18>
3401065c:	2301      	movs	r3, #1
3401065e:	e000      	b.n	34010662 <LL_RCC_IC15_IsEnabled+0x1a>
34010660:	2300      	movs	r3, #0
}
34010662:	4618      	mov	r0, r3
34010664:	46bd      	mov	sp, r7
34010666:	f85d 7b04 	ldr.w	r7, [sp], #4
3401066a:	4770      	bx	lr
3401066c:	56028000 	.word	0x56028000

34010670 <LL_RCC_IC15_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetSource(void)
{
34010670:	b480      	push	{r7}
34010672:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL));
34010674:	4b04      	ldr	r3, [pc, #16]	@ (34010688 <LL_RCC_IC15_GetSource+0x18>)
34010676:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401067a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401067e:	4618      	mov	r0, r3
34010680:	46bd      	mov	sp, r7
34010682:	f85d 7b04 	ldr.w	r7, [sp], #4
34010686:	4770      	bx	lr
34010688:	56028000 	.word	0x56028000

3401068c <LL_RCC_IC15_GetDivider>:
  * @brief  Get IC15 divider
  * @rmtoll IC15CFGR      IC15INT        LL_RCC_IC15_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC15_GetDivider(void)
{
3401068c:	b480      	push	{r7}
3401068e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC15CFGR, RCC_IC15CFGR_IC15INT) >> RCC_IC15CFGR_IC15INT_Pos) + 1UL);
34010690:	4b05      	ldr	r3, [pc, #20]	@ (340106a8 <LL_RCC_IC15_GetDivider+0x1c>)
34010692:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34010696:	0c1b      	lsrs	r3, r3, #16
34010698:	b2db      	uxtb	r3, r3
3401069a:	3301      	adds	r3, #1
}
3401069c:	4618      	mov	r0, r3
3401069e:	46bd      	mov	sp, r7
340106a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340106a4:	4770      	bx	lr
340106a6:	bf00      	nop
340106a8:	56028000 	.word	0x56028000

340106ac <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
340106ac:	b480      	push	{r7}
340106ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
340106b0:	4b04      	ldr	r3, [pc, #16]	@ (340106c4 <LL_RCC_IC16_Enable+0x18>)
340106b2:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
340106b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340106ba:	bf00      	nop
340106bc:	46bd      	mov	sp, r7
340106be:	f85d 7b04 	ldr.w	r7, [sp], #4
340106c2:	4770      	bx	lr
340106c4:	56028000 	.word	0x56028000

340106c8 <LL_RCC_IC16_IsEnabled>:
  * @brief  Check if IC16 is enabled
  * @rmtoll DIVENR       IC16EN         LL_RCC_IC16_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_IsEnabled(void)
{
340106c8:	b480      	push	{r7}
340106ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC16EN) == RCC_DIVENR_IC16EN) ? 1UL : 0UL);
340106cc:	4b07      	ldr	r3, [pc, #28]	@ (340106ec <LL_RCC_IC16_IsEnabled+0x24>)
340106ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340106d2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340106d6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340106da:	d101      	bne.n	340106e0 <LL_RCC_IC16_IsEnabled+0x18>
340106dc:	2301      	movs	r3, #1
340106de:	e000      	b.n	340106e2 <LL_RCC_IC16_IsEnabled+0x1a>
340106e0:	2300      	movs	r3, #0
}
340106e2:	4618      	mov	r0, r3
340106e4:	46bd      	mov	sp, r7
340106e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340106ea:	4770      	bx	lr
340106ec:	56028000 	.word	0x56028000

340106f0 <LL_RCC_IC16_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetSource(void)
{
340106f0:	b480      	push	{r7}
340106f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL));
340106f4:	4b04      	ldr	r3, [pc, #16]	@ (34010708 <LL_RCC_IC16_GetSource+0x18>)
340106f6:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
340106fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340106fe:	4618      	mov	r0, r3
34010700:	46bd      	mov	sp, r7
34010702:	f85d 7b04 	ldr.w	r7, [sp], #4
34010706:	4770      	bx	lr
34010708:	56028000 	.word	0x56028000

3401070c <LL_RCC_IC16_GetDivider>:
  * @brief  Get IC16 divider
  * @rmtoll IC16CFGR      IC16INT        LL_RCC_IC16_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC16_GetDivider(void)
{
3401070c:	b480      	push	{r7}
3401070e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC16CFGR, RCC_IC16CFGR_IC16INT) >> RCC_IC16CFGR_IC16INT_Pos) + 1UL);
34010710:	4b05      	ldr	r3, [pc, #20]	@ (34010728 <LL_RCC_IC16_GetDivider+0x1c>)
34010712:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34010716:	0c1b      	lsrs	r3, r3, #16
34010718:	b2db      	uxtb	r3, r3
3401071a:	3301      	adds	r3, #1
}
3401071c:	4618      	mov	r0, r3
3401071e:	46bd      	mov	sp, r7
34010720:	f85d 7b04 	ldr.w	r7, [sp], #4
34010724:	4770      	bx	lr
34010726:	bf00      	nop
34010728:	56028000 	.word	0x56028000

3401072c <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
3401072c:	b480      	push	{r7}
3401072e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
34010730:	4b04      	ldr	r3, [pc, #16]	@ (34010744 <LL_RCC_IC17_Enable+0x18>)
34010732:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
34010736:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3401073a:	bf00      	nop
3401073c:	46bd      	mov	sp, r7
3401073e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010742:	4770      	bx	lr
34010744:	56028000 	.word	0x56028000

34010748 <LL_RCC_IC17_IsEnabled>:
  * @brief  Check if IC17 is enabled
  * @rmtoll DIVENR       IC17EN         LL_RCC_IC17_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_IsEnabled(void)
{
34010748:	b480      	push	{r7}
3401074a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC17EN) == RCC_DIVENR_IC17EN) ? 1UL : 0UL);
3401074c:	4b07      	ldr	r3, [pc, #28]	@ (3401076c <LL_RCC_IC17_IsEnabled+0x24>)
3401074e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010752:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34010756:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
3401075a:	d101      	bne.n	34010760 <LL_RCC_IC17_IsEnabled+0x18>
3401075c:	2301      	movs	r3, #1
3401075e:	e000      	b.n	34010762 <LL_RCC_IC17_IsEnabled+0x1a>
34010760:	2300      	movs	r3, #0
}
34010762:	4618      	mov	r0, r3
34010764:	46bd      	mov	sp, r7
34010766:	f85d 7b04 	ldr.w	r7, [sp], #4
3401076a:	4770      	bx	lr
3401076c:	56028000 	.word	0x56028000

34010770 <LL_RCC_IC17_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetSource(void)
{
34010770:	b480      	push	{r7}
34010772:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL));
34010774:	4b04      	ldr	r3, [pc, #16]	@ (34010788 <LL_RCC_IC17_GetSource+0x18>)
34010776:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
3401077a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401077e:	4618      	mov	r0, r3
34010780:	46bd      	mov	sp, r7
34010782:	f85d 7b04 	ldr.w	r7, [sp], #4
34010786:	4770      	bx	lr
34010788:	56028000 	.word	0x56028000

3401078c <LL_RCC_IC17_GetDivider>:
  * @brief  Get IC17 divider
  * @rmtoll IC17CFGR      IC17INT        LL_RCC_IC17_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC17_GetDivider(void)
{
3401078c:	b480      	push	{r7}
3401078e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC17CFGR, RCC_IC17CFGR_IC17INT) >> RCC_IC17CFGR_IC17INT_Pos) + 1UL);
34010790:	4b05      	ldr	r3, [pc, #20]	@ (340107a8 <LL_RCC_IC17_GetDivider+0x1c>)
34010792:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34010796:	0c1b      	lsrs	r3, r3, #16
34010798:	b2db      	uxtb	r3, r3
3401079a:	3301      	adds	r3, #1
}
3401079c:	4618      	mov	r0, r3
3401079e:	46bd      	mov	sp, r7
340107a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340107a4:	4770      	bx	lr
340107a6:	bf00      	nop
340107a8:	56028000 	.word	0x56028000

340107ac <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
340107ac:	b480      	push	{r7}
340107ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
340107b0:	4b04      	ldr	r3, [pc, #16]	@ (340107c4 <LL_RCC_IC18_Enable+0x18>)
340107b2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
340107b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340107ba:	bf00      	nop
340107bc:	46bd      	mov	sp, r7
340107be:	f85d 7b04 	ldr.w	r7, [sp], #4
340107c2:	4770      	bx	lr
340107c4:	56028000 	.word	0x56028000

340107c8 <LL_RCC_IC18_IsEnabled>:
  * @brief  Check if IC18 is enabled
  * @rmtoll DIVENR       IC18EN         LL_RCC_IC18_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_IsEnabled(void)
{
340107c8:	b480      	push	{r7}
340107ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC18EN) == RCC_DIVENR_IC18EN) ? 1UL : 0UL);
340107cc:	4b07      	ldr	r3, [pc, #28]	@ (340107ec <LL_RCC_IC18_IsEnabled+0x24>)
340107ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340107d2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
340107d6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
340107da:	d101      	bne.n	340107e0 <LL_RCC_IC18_IsEnabled+0x18>
340107dc:	2301      	movs	r3, #1
340107de:	e000      	b.n	340107e2 <LL_RCC_IC18_IsEnabled+0x1a>
340107e0:	2300      	movs	r3, #0
}
340107e2:	4618      	mov	r0, r3
340107e4:	46bd      	mov	sp, r7
340107e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340107ea:	4770      	bx	lr
340107ec:	56028000 	.word	0x56028000

340107f0 <LL_RCC_IC18_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetSource(void)
{
340107f0:	b480      	push	{r7}
340107f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL));
340107f4:	4b04      	ldr	r3, [pc, #16]	@ (34010808 <LL_RCC_IC18_GetSource+0x18>)
340107f6:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
340107fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340107fe:	4618      	mov	r0, r3
34010800:	46bd      	mov	sp, r7
34010802:	f85d 7b04 	ldr.w	r7, [sp], #4
34010806:	4770      	bx	lr
34010808:	56028000 	.word	0x56028000

3401080c <LL_RCC_IC18_GetDivider>:
  * @brief  Get IC18 divider
  * @rmtoll IC18CFGR      IC18INT        LL_RCC_IC18_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC18_GetDivider(void)
{
3401080c:	b480      	push	{r7}
3401080e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC18CFGR, RCC_IC18CFGR_IC18INT) >> RCC_IC18CFGR_IC18INT_Pos) + 1UL);
34010810:	4b05      	ldr	r3, [pc, #20]	@ (34010828 <LL_RCC_IC18_GetDivider+0x1c>)
34010812:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34010816:	0c1b      	lsrs	r3, r3, #16
34010818:	b2db      	uxtb	r3, r3
3401081a:	3301      	adds	r3, #1
}
3401081c:	4618      	mov	r0, r3
3401081e:	46bd      	mov	sp, r7
34010820:	f85d 7b04 	ldr.w	r7, [sp], #4
34010824:	4770      	bx	lr
34010826:	bf00      	nop
34010828:	56028000 	.word	0x56028000

3401082c <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
3401082c:	b480      	push	{r7}
3401082e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
34010830:	4b04      	ldr	r3, [pc, #16]	@ (34010844 <LL_RCC_IC19_Enable+0x18>)
34010832:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
34010836:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3401083a:	bf00      	nop
3401083c:	46bd      	mov	sp, r7
3401083e:	f85d 7b04 	ldr.w	r7, [sp], #4
34010842:	4770      	bx	lr
34010844:	56028000 	.word	0x56028000

34010848 <LL_RCC_IC19_IsEnabled>:
  * @brief  Check if IC19 is enabled
  * @rmtoll DIVENR       IC19EN         LL_RCC_IC19_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_IsEnabled(void)
{
34010848:	b480      	push	{r7}
3401084a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC19EN) == RCC_DIVENR_IC19EN) ? 1UL : 0UL);
3401084c:	4b07      	ldr	r3, [pc, #28]	@ (3401086c <LL_RCC_IC19_IsEnabled+0x24>)
3401084e:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
34010852:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34010856:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401085a:	d101      	bne.n	34010860 <LL_RCC_IC19_IsEnabled+0x18>
3401085c:	2301      	movs	r3, #1
3401085e:	e000      	b.n	34010862 <LL_RCC_IC19_IsEnabled+0x1a>
34010860:	2300      	movs	r3, #0
}
34010862:	4618      	mov	r0, r3
34010864:	46bd      	mov	sp, r7
34010866:	f85d 7b04 	ldr.w	r7, [sp], #4
3401086a:	4770      	bx	lr
3401086c:	56028000 	.word	0x56028000

34010870 <LL_RCC_IC19_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetSource(void)
{
34010870:	b480      	push	{r7}
34010872:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL));
34010874:	4b04      	ldr	r3, [pc, #16]	@ (34010888 <LL_RCC_IC19_GetSource+0x18>)
34010876:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3401087a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
3401087e:	4618      	mov	r0, r3
34010880:	46bd      	mov	sp, r7
34010882:	f85d 7b04 	ldr.w	r7, [sp], #4
34010886:	4770      	bx	lr
34010888:	56028000 	.word	0x56028000

3401088c <LL_RCC_IC19_GetDivider>:
  * @brief  Get IC19 divider
  * @rmtoll IC19CFGR      IC19INT        LL_RCC_IC19_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC19_GetDivider(void)
{
3401088c:	b480      	push	{r7}
3401088e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC19CFGR, RCC_IC19CFGR_IC19INT) >> RCC_IC19CFGR_IC19INT_Pos) + 1UL);
34010890:	4b05      	ldr	r3, [pc, #20]	@ (340108a8 <LL_RCC_IC19_GetDivider+0x1c>)
34010892:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34010896:	0c1b      	lsrs	r3, r3, #16
34010898:	b2db      	uxtb	r3, r3
3401089a:	3301      	adds	r3, #1
}
3401089c:	4618      	mov	r0, r3
3401089e:	46bd      	mov	sp, r7
340108a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340108a4:	4770      	bx	lr
340108a6:	bf00      	nop
340108a8:	56028000 	.word	0x56028000

340108ac <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
340108ac:	b480      	push	{r7}
340108ae:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
340108b0:	4b04      	ldr	r3, [pc, #16]	@ (340108c4 <LL_RCC_IC20_Enable+0x18>)
340108b2:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
340108b6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340108ba:	bf00      	nop
340108bc:	46bd      	mov	sp, r7
340108be:	f85d 7b04 	ldr.w	r7, [sp], #4
340108c2:	4770      	bx	lr
340108c4:	56028000 	.word	0x56028000

340108c8 <LL_RCC_IC20_IsEnabled>:
  * @brief  Check if IC20 is enabled
  * @rmtoll DIVENR       IC20EN         LL_RCC_IC20_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_IsEnabled(void)
{
340108c8:	b480      	push	{r7}
340108ca:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->DIVENR, RCC_DIVENR_IC20EN) == RCC_DIVENR_IC20EN) ? 1UL : 0UL);
340108cc:	4b07      	ldr	r3, [pc, #28]	@ (340108ec <LL_RCC_IC20_IsEnabled+0x24>)
340108ce:	f8d3 3240 	ldr.w	r3, [r3, #576]	@ 0x240
340108d2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
340108d6:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
340108da:	d101      	bne.n	340108e0 <LL_RCC_IC20_IsEnabled+0x18>
340108dc:	2301      	movs	r3, #1
340108de:	e000      	b.n	340108e2 <LL_RCC_IC20_IsEnabled+0x1a>
340108e0:	2300      	movs	r3, #0
}
340108e2:	4618      	mov	r0, r3
340108e4:	46bd      	mov	sp, r7
340108e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340108ea:	4770      	bx	lr
340108ec:	56028000 	.word	0x56028000

340108f0 <LL_RCC_IC20_GetSource>:
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL2
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL3
  *         @arg @ref LL_RCC_ICCLKSOURCE_PLL4
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetSource(void)
{
340108f0:	b480      	push	{r7}
340108f2:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL));
340108f4:	4b04      	ldr	r3, [pc, #16]	@ (34010908 <LL_RCC_IC20_GetSource+0x18>)
340108f6:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
340108fa:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
}
340108fe:	4618      	mov	r0, r3
34010900:	46bd      	mov	sp, r7
34010902:	f85d 7b04 	ldr.w	r7, [sp], #4
34010906:	4770      	bx	lr
34010908:	56028000 	.word	0x56028000

3401090c <LL_RCC_IC20_GetDivider>:
  * @brief  Get IC20 divider
  * @rmtoll IC20CFGR      IC20INT        LL_RCC_IC20_GetDivider
  * @retval can be a value between 1 and 256.
  */
__STATIC_INLINE uint32_t LL_RCC_IC20_GetDivider(void)
{
3401090c:	b480      	push	{r7}
3401090e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->IC20CFGR, RCC_IC20CFGR_IC20INT) >> RCC_IC20CFGR_IC20INT_Pos) + 1UL);
34010910:	4b05      	ldr	r3, [pc, #20]	@ (34010928 <LL_RCC_IC20_GetDivider+0x1c>)
34010912:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34010916:	0c1b      	lsrs	r3, r3, #16
34010918:	b2db      	uxtb	r3, r3
3401091a:	3301      	adds	r3, #1
}
3401091c:	4618      	mov	r0, r3
3401091e:	46bd      	mov	sp, r7
34010920:	f85d 7b04 	ldr.w	r7, [sp], #4
34010924:	4770      	bx	lr
34010926:	bf00      	nop
34010928:	56028000 	.word	0x56028000

3401092c <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
3401092c:	b480      	push	{r7}
3401092e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
34010930:	4b04      	ldr	r3, [pc, #16]	@ (34010944 <LL_RCC_CLKP_Enable+0x18>)
34010932:	2240      	movs	r2, #64	@ 0x40
34010934:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
34010938:	bf00      	nop
3401093a:	46bd      	mov	sp, r7
3401093c:	f85d 7b04 	ldr.w	r7, [sp], #4
34010940:	4770      	bx	lr
34010942:	bf00      	nop
34010944:	56028000 	.word	0x56028000

34010948 <LL_RCC_CLKP_IsEnabled>:
  * @brief  Check if CLKP is enabled
  * @rmtoll MISCENR       PEREN         LL_RCC_CLKP_IsEnabled
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_CLKP_IsEnabled(void)
{
34010948:	b480      	push	{r7}
3401094a:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->MISCENR, RCC_MISCENR_PEREN) == RCC_MISCENR_PEREN) ? 1UL : 0UL);
3401094c:	4b07      	ldr	r3, [pc, #28]	@ (3401096c <LL_RCC_CLKP_IsEnabled+0x24>)
3401094e:	f8d3 3248 	ldr.w	r3, [r3, #584]	@ 0x248
34010952:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34010956:	2b40      	cmp	r3, #64	@ 0x40
34010958:	d101      	bne.n	3401095e <LL_RCC_CLKP_IsEnabled+0x16>
3401095a:	2301      	movs	r3, #1
3401095c:	e000      	b.n	34010960 <LL_RCC_CLKP_IsEnabled+0x18>
3401095e:	2300      	movs	r3, #0
}
34010960:	4618      	mov	r0, r3
34010962:	46bd      	mov	sp, r7
34010964:	f85d 7b04 	ldr.w	r7, [sp], #4
34010968:	4770      	bx	lr
3401096a:	bf00      	nop
3401096c:	56028000 	.word	0x56028000

34010970 <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
34010970:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34010974:	b0f2      	sub	sp, #456	@ 0x1c8
34010976:	af00      	add	r7, sp, #0
34010978:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
3401097c:	2300      	movs	r3, #0
3401097e:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
34010982:	2300      	movs	r3, #0
34010984:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
34010988:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401098c:	e9d3 2300 	ldrd	r2, r3, [r3]
34010990:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
34010994:	2500      	movs	r5, #0
34010996:	ea54 0305 	orrs.w	r3, r4, r5
3401099a:	d06c      	beq.n	34010a76 <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
3401099c:	f7ff f91e 	bl	3400fbdc <LL_RCC_GetRTCClockSource>
340109a0:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
340109a4:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
340109a8:	2b00      	cmp	r3, #0
340109aa:	d018      	beq.n	340109de <HAL_RCCEx_PeriphCLKConfig+0x6e>
340109ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340109b0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340109b4:	f403 7240 	and.w	r2, r3, #768	@ 0x300
340109b8:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
340109bc:	4293      	cmp	r3, r2
340109be:	d00e      	beq.n	340109de <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
340109c0:	4bc3      	ldr	r3, [pc, #780]	@ (34010cd0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340109c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340109c4:	4ac2      	ldr	r2, [pc, #776]	@ (34010cd0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340109c6:	f043 0301 	orr.w	r3, r3, #1
340109ca:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
340109cc:	4bc0      	ldr	r3, [pc, #768]	@ (34010cd0 <HAL_RCCEx_PeriphCLKConfig+0x360>)
340109ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340109d0:	f003 0301 	and.w	r3, r3, #1
340109d4:	2b00      	cmp	r3, #0
340109d6:	d102      	bne.n	340109de <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
340109d8:	2301      	movs	r3, #1
340109da:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
340109de:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
340109e2:	2b00      	cmp	r3, #0
340109e4:	d143      	bne.n	34010a6e <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
340109e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340109ea:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340109ee:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
340109f2:	d117      	bne.n	34010a24 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
340109f4:	f7f4 f91b 	bl	34004c2e <HAL_GetTick>
340109f8:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
340109fc:	e00d      	b.n	34010a1a <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
340109fe:	f7f4 f916 	bl	34004c2e <HAL_GetTick>
34010a02:	4602      	mov	r2, r0
34010a04:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
34010a08:	1ad2      	subs	r2, r2, r3
34010a0a:	f241 3388 	movw	r3, #5000	@ 0x1388
34010a0e:	429a      	cmp	r2, r3
34010a10:	d903      	bls.n	34010a1a <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
34010a12:	2303      	movs	r3, #3
34010a14:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
34010a18:	e004      	b.n	34010a24 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
34010a1a:	f7fe fcf1 	bl	3400f400 <LL_RCC_LSE_IsReady>
34010a1e:	4603      	mov	r3, r0
34010a20:	2b00      	cmp	r3, #0
34010a22:	d0ec      	beq.n	340109fe <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
34010a24:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34010a28:	2b00      	cmp	r3, #0
34010a2a:	d11b      	bne.n	34010a64 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
34010a2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010a30:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34010a34:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34010a38:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34010a3c:	d108      	bne.n	34010a50 <HAL_RCCEx_PeriphCLKConfig+0xe0>
34010a3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010a42:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34010a46:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
34010a4a:	4618      	mov	r0, r3
34010a4c:	f7ff f8d4 	bl	3400fbf8 <LL_RCC_SetRTC_HSEPrescaler>
34010a50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010a54:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34010a58:	f403 7340 	and.w	r3, r3, #768	@ 0x300
34010a5c:	4618      	mov	r0, r3
34010a5e:	f7ff f8a7 	bl	3400fbb0 <LL_RCC_SetRTCClockSource>
34010a62:	e008      	b.n	34010a76 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
34010a64:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34010a68:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
34010a6c:	e003      	b.n	34010a76 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
34010a6e:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34010a72:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
34010a76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010a7a:	e9d3 2300 	ldrd	r2, r3, [r3]
34010a7e:	f002 0804 	and.w	r8, r2, #4
34010a82:	f04f 0900 	mov.w	r9, #0
34010a86:	ea58 0309 	orrs.w	r3, r8, r9
34010a8a:	f000 809b 	beq.w	34010bc4 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
34010a8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010a92:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010a96:	2b04      	cmp	r3, #4
34010a98:	d116      	bne.n	34010ac8 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34010a9a:	4b8e      	ldr	r3, [pc, #568]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010a9c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010aa0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010aa4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010aa8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010aac:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34010aae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ab2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34010ab4:	3b01      	subs	r3, #1
34010ab6:	041b      	lsls	r3, r3, #16
34010ab8:	4313      	orrs	r3, r2
34010aba:	4a86      	ldr	r2, [pc, #536]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010abc:	430b      	orrs	r3, r1
34010abe:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34010ac2:	f7ff fbb3 	bl	3401022c <LL_RCC_IC5_Enable>
34010ac6:	e076      	b.n	34010bb6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
34010ac8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010acc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010ad0:	2b05      	cmp	r3, #5
34010ad2:	d116      	bne.n	34010b02 <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34010ad4:	4b7f      	ldr	r3, [pc, #508]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010ad6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34010ada:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010ade:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010ae2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ae6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34010ae8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010aec:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34010aee:	3b01      	subs	r3, #1
34010af0:	041b      	lsls	r3, r3, #16
34010af2:	4313      	orrs	r3, r2
34010af4:	4a77      	ldr	r2, [pc, #476]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010af6:	430b      	orrs	r3, r1
34010af8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34010afc:	f7ff fc96 	bl	3401042c <LL_RCC_IC10_Enable>
34010b00:	e059      	b.n	34010bb6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
34010b02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b06:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010b0a:	2b06      	cmp	r3, #6
34010b0c:	d116      	bne.n	34010b3c <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34010b0e:	4b71      	ldr	r3, [pc, #452]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010b10:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34010b14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010b18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010b1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b20:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34010b22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b26:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34010b28:	3b01      	subs	r3, #1
34010b2a:	041b      	lsls	r3, r3, #16
34010b2c:	4313      	orrs	r3, r2
34010b2e:	4a69      	ldr	r2, [pc, #420]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010b30:	430b      	orrs	r3, r1
34010b32:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34010b36:	f7ff fd79 	bl	3401062c <LL_RCC_IC15_Enable>
34010b3a:	e03c      	b.n	34010bb6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
34010b3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b40:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010b44:	2b03      	cmp	r3, #3
34010b46:	d118      	bne.n	34010b7a <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34010b48:	4b62      	ldr	r3, [pc, #392]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010b4a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34010b4e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010b52:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010b56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b5a:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34010b5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b62:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34010b66:	3b01      	subs	r3, #1
34010b68:	041b      	lsls	r3, r3, #16
34010b6a:	4313      	orrs	r3, r2
34010b6c:	4a59      	ldr	r2, [pc, #356]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010b6e:	430b      	orrs	r3, r1
34010b70:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34010b74:	f7ff fe5a 	bl	3401082c <LL_RCC_IC19_Enable>
34010b78:	e01d      	b.n	34010bb6 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
34010b7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b7e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010b82:	2b07      	cmp	r3, #7
34010b84:	d117      	bne.n	34010bb6 <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34010b86:	4b53      	ldr	r3, [pc, #332]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010b88:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34010b8c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010b90:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010b94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010b98:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34010b9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ba0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34010ba4:	3b01      	subs	r3, #1
34010ba6:	041b      	lsls	r3, r3, #16
34010ba8:	4313      	orrs	r3, r2
34010baa:	4a4a      	ldr	r2, [pc, #296]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010bac:	430b      	orrs	r3, r1
34010bae:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34010bb2:	f7ff fe7b 	bl	340108ac <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
34010bb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010bba:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34010bbe:	4618      	mov	r0, r3
34010bc0:	f7fe fcd2 	bl	3400f568 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
34010bc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010bc8:	e9d3 2300 	ldrd	r2, r3, [r3]
34010bcc:	f04f 0a00 	mov.w	sl, #0
34010bd0:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
34010bd4:	ea5a 030b 	orrs.w	r3, sl, fp
34010bd8:	d04b      	beq.n	34010c72 <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
34010bda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010bde:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34010be2:	4b3d      	ldr	r3, [pc, #244]	@ (34010cd8 <HAL_RCCEx_PeriphCLKConfig+0x368>)
34010be4:	429a      	cmp	r2, r3
34010be6:	d116      	bne.n	34010c16 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34010be8:	4b3a      	ldr	r3, [pc, #232]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010bea:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010bee:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010bf2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010bf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010bfa:	699a      	ldr	r2, [r3, #24]
34010bfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c00:	69db      	ldr	r3, [r3, #28]
34010c02:	3b01      	subs	r3, #1
34010c04:	041b      	lsls	r3, r3, #16
34010c06:	4313      	orrs	r3, r2
34010c08:	4a32      	ldr	r2, [pc, #200]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010c0a:	430b      	orrs	r3, r1
34010c0c:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34010c10:	f7ff fa8c 	bl	3401012c <LL_RCC_IC3_Enable>
34010c14:	e026      	b.n	34010c64 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
34010c16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c1a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34010c1e:	4b2f      	ldr	r3, [pc, #188]	@ (34010cdc <HAL_RCCEx_PeriphCLKConfig+0x36c>)
34010c20:	429a      	cmp	r2, r3
34010c22:	d116      	bne.n	34010c52 <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010c24:	4b2b      	ldr	r3, [pc, #172]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010c26:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010c2a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010c2e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010c32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c36:	6a1a      	ldr	r2, [r3, #32]
34010c38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c3c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010c3e:	3b01      	subs	r3, #1
34010c40:	041b      	lsls	r3, r3, #16
34010c42:	4313      	orrs	r3, r2
34010c44:	4a23      	ldr	r2, [pc, #140]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010c46:	430b      	orrs	r3, r1
34010c48:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010c4c:	f7ff faae 	bl	340101ac <LL_RCC_IC4_Enable>
34010c50:	e008      	b.n	34010c64 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
34010c52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c56:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
34010c5a:	4b21      	ldr	r3, [pc, #132]	@ (34010ce0 <HAL_RCCEx_PeriphCLKConfig+0x370>)
34010c5c:	429a      	cmp	r2, r3
34010c5e:	d101      	bne.n	34010c64 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
34010c60:	f7ff fe64 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
34010c64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c68:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34010c6c:	4618      	mov	r0, r3
34010c6e:	f7fe fe0b 	bl	3400f888 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
34010c72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c76:	e9d3 2300 	ldrd	r2, r3, [r3]
34010c7a:	2100      	movs	r1, #0
34010c7c:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
34010c80:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34010c84:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
34010c88:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
34010c8c:	4603      	mov	r3, r0
34010c8e:	460a      	mov	r2, r1
34010c90:	4313      	orrs	r3, r2
34010c92:	d057      	beq.n	34010d44 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
34010c94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010c98:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34010c9c:	4b11      	ldr	r3, [pc, #68]	@ (34010ce4 <HAL_RCCEx_PeriphCLKConfig+0x374>)
34010c9e:	429a      	cmp	r2, r3
34010ca0:	d122      	bne.n	34010ce8 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34010ca2:	4b0c      	ldr	r3, [pc, #48]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010ca4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010ca8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010cac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010cb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010cb4:	699a      	ldr	r2, [r3, #24]
34010cb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010cba:	69db      	ldr	r3, [r3, #28]
34010cbc:	3b01      	subs	r3, #1
34010cbe:	041b      	lsls	r3, r3, #16
34010cc0:	4313      	orrs	r3, r2
34010cc2:	4a04      	ldr	r2, [pc, #16]	@ (34010cd4 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34010cc4:	430b      	orrs	r3, r1
34010cc6:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34010cca:	f7ff fa2f 	bl	3401012c <LL_RCC_IC3_Enable>
34010cce:	e032      	b.n	34010d36 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
34010cd0:	56024800 	.word	0x56024800
34010cd4:	56028000 	.word	0x56028000
34010cd8:	03020014 	.word	0x03020014
34010cdc:	03030014 	.word	0x03030014
34010ce0:	03010014 	.word	0x03010014
34010ce4:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
34010ce8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010cec:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34010cf0:	4bc5      	ldr	r3, [pc, #788]	@ (34011008 <HAL_RCCEx_PeriphCLKConfig+0x698>)
34010cf2:	429a      	cmp	r2, r3
34010cf4:	d116      	bne.n	34010d24 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010cf6:	4bc5      	ldr	r3, [pc, #788]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010cf8:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010cfc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010d00:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010d04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d08:	6a1a      	ldr	r2, [r3, #32]
34010d0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d0e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010d10:	3b01      	subs	r3, #1
34010d12:	041b      	lsls	r3, r3, #16
34010d14:	4313      	orrs	r3, r2
34010d16:	4abd      	ldr	r2, [pc, #756]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010d18:	430b      	orrs	r3, r1
34010d1a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010d1e:	f7ff fa45 	bl	340101ac <LL_RCC_IC4_Enable>
34010d22:	e008      	b.n	34010d36 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
34010d24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d28:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34010d2c:	4bb8      	ldr	r3, [pc, #736]	@ (34011010 <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
34010d2e:	429a      	cmp	r2, r3
34010d30:	d101      	bne.n	34010d36 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
34010d32:	f7ff fdfb 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
34010d36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d3a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34010d3e:	4618      	mov	r0, r3
34010d40:	f7fe fda2 	bl	3400f888 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
34010d44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d48:	e9d3 2300 	ldrd	r2, r3, [r3]
34010d4c:	2100      	movs	r1, #0
34010d4e:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
34010d52:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34010d56:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
34010d5a:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
34010d5e:	4603      	mov	r3, r0
34010d60:	460a      	mov	r2, r1
34010d62:	4313      	orrs	r3, r2
34010d64:	d04b      	beq.n	34010dfe <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
34010d66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d6a:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34010d6e:	4ba9      	ldr	r3, [pc, #676]	@ (34011014 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34010d70:	429a      	cmp	r2, r3
34010d72:	d116      	bne.n	34010da2 <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34010d74:	4ba5      	ldr	r3, [pc, #660]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010d76:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010d7a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010d7e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010d82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d86:	699a      	ldr	r2, [r3, #24]
34010d88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010d8c:	69db      	ldr	r3, [r3, #28]
34010d8e:	3b01      	subs	r3, #1
34010d90:	041b      	lsls	r3, r3, #16
34010d92:	4313      	orrs	r3, r2
34010d94:	4a9d      	ldr	r2, [pc, #628]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010d96:	430b      	orrs	r3, r1
34010d98:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34010d9c:	f7ff f9c6 	bl	3401012c <LL_RCC_IC3_Enable>
34010da0:	e026      	b.n	34010df0 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
34010da2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010da6:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34010daa:	4b9b      	ldr	r3, [pc, #620]	@ (34011018 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
34010dac:	429a      	cmp	r2, r3
34010dae:	d116      	bne.n	34010dde <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010db0:	4b96      	ldr	r3, [pc, #600]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010db2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010db6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010dba:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010dbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010dc2:	6a1a      	ldr	r2, [r3, #32]
34010dc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010dc8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010dca:	3b01      	subs	r3, #1
34010dcc:	041b      	lsls	r3, r3, #16
34010dce:	4313      	orrs	r3, r2
34010dd0:	4a8e      	ldr	r2, [pc, #568]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010dd2:	430b      	orrs	r3, r1
34010dd4:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010dd8:	f7ff f9e8 	bl	340101ac <LL_RCC_IC4_Enable>
34010ddc:	e008      	b.n	34010df0 <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
34010dde:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010de2:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34010de6:	4b8d      	ldr	r3, [pc, #564]	@ (3401101c <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
34010de8:	429a      	cmp	r2, r3
34010dea:	d101      	bne.n	34010df0 <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
34010dec:	f7ff fd9e 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
34010df0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010df4:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34010df8:	4618      	mov	r0, r3
34010dfa:	f7fe fd45 	bl	3400f888 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
34010dfe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e02:	e9d3 2300 	ldrd	r2, r3, [r3]
34010e06:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
34010e0a:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
34010e0e:	2300      	movs	r3, #0
34010e10:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
34010e14:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
34010e18:	4603      	mov	r3, r0
34010e1a:	460a      	mov	r2, r1
34010e1c:	4313      	orrs	r3, r2
34010e1e:	d048      	beq.n	34010eb2 <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
34010e20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e24:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010e28:	2b20      	cmp	r3, #32
34010e2a:	d116      	bne.n	34010e5a <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34010e2c:	4b77      	ldr	r3, [pc, #476]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010e2e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34010e32:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010e36:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010e3a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e3e:	699a      	ldr	r2, [r3, #24]
34010e40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e44:	69db      	ldr	r3, [r3, #28]
34010e46:	3b01      	subs	r3, #1
34010e48:	041b      	lsls	r3, r3, #16
34010e4a:	4313      	orrs	r3, r2
34010e4c:	4a6f      	ldr	r2, [pc, #444]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010e4e:	430b      	orrs	r3, r1
34010e50:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34010e54:	f7ff f96a 	bl	3401012c <LL_RCC_IC3_Enable>
34010e58:	e024      	b.n	34010ea4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
34010e5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e5e:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010e62:	2b30      	cmp	r3, #48	@ 0x30
34010e64:	d116      	bne.n	34010e94 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010e66:	4b69      	ldr	r3, [pc, #420]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010e68:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010e6c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010e70:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010e74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e78:	6a1a      	ldr	r2, [r3, #32]
34010e7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e7e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010e80:	3b01      	subs	r3, #1
34010e82:	041b      	lsls	r3, r3, #16
34010e84:	4313      	orrs	r3, r2
34010e86:	4a61      	ldr	r2, [pc, #388]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010e88:	430b      	orrs	r3, r1
34010e8a:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010e8e:	f7ff f98d 	bl	340101ac <LL_RCC_IC4_Enable>
34010e92:	e007      	b.n	34010ea4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
34010e94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010e98:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010e9c:	2b10      	cmp	r3, #16
34010e9e:	d101      	bne.n	34010ea4 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
34010ea0:	f7ff fd44 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
34010ea4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ea8:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34010eac:	4618      	mov	r0, r3
34010eae:	f7fe fc03 	bl	3400f6b8 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34010eb2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010eb6:	e9d3 2300 	ldrd	r2, r3, [r3]
34010eba:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
34010ebe:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
34010ec2:	2300      	movs	r3, #0
34010ec4:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
34010ec8:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
34010ecc:	4603      	mov	r3, r0
34010ece:	460a      	mov	r2, r1
34010ed0:	4313      	orrs	r3, r2
34010ed2:	d04b      	beq.n	34010f6c <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
34010ed4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ed8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34010edc:	4b50      	ldr	r3, [pc, #320]	@ (34011020 <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
34010ede:	429a      	cmp	r2, r3
34010ee0:	d116      	bne.n	34010f10 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010ee2:	4b4a      	ldr	r3, [pc, #296]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010ee4:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010ee8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010eec:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010ef0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ef4:	6a1a      	ldr	r2, [r3, #32]
34010ef6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010efa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010efc:	3b01      	subs	r3, #1
34010efe:	041b      	lsls	r3, r3, #16
34010f00:	4313      	orrs	r3, r2
34010f02:	4a42      	ldr	r2, [pc, #264]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010f04:	430b      	orrs	r3, r1
34010f06:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010f0a:	f7ff f94f 	bl	340101ac <LL_RCC_IC4_Enable>
34010f0e:	e026      	b.n	34010f5e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
34010f10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f14:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34010f18:	4b42      	ldr	r3, [pc, #264]	@ (34011024 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
34010f1a:	429a      	cmp	r2, r3
34010f1c:	d116      	bne.n	34010f4c <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34010f1e:	4b3b      	ldr	r3, [pc, #236]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010f20:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010f24:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010f28:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010f2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f30:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34010f32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34010f38:	3b01      	subs	r3, #1
34010f3a:	041b      	lsls	r3, r3, #16
34010f3c:	4313      	orrs	r3, r2
34010f3e:	4a33      	ldr	r2, [pc, #204]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010f40:	430b      	orrs	r3, r1
34010f42:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34010f46:	f7ff f971 	bl	3401022c <LL_RCC_IC5_Enable>
34010f4a:	e008      	b.n	34010f5e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
34010f4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f50:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34010f54:	4b34      	ldr	r3, [pc, #208]	@ (34011028 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
34010f56:	429a      	cmp	r2, r3
34010f58:	d101      	bne.n	34010f5e <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
34010f5a:	f7ff fce7 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
34010f5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f62:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
34010f66:	4618      	mov	r0, r3
34010f68:	f7fe fc57 	bl	3400f81a <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34010f6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f70:	e9d3 2300 	ldrd	r2, r3, [r3]
34010f74:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
34010f78:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34010f7c:	2300      	movs	r3, #0
34010f7e:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34010f82:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
34010f86:	4603      	mov	r3, r0
34010f88:	460a      	mov	r2, r1
34010f8a:	4313      	orrs	r3, r2
34010f8c:	d062      	beq.n	34011054 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34010f8e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010f92:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34010f96:	4b25      	ldr	r3, [pc, #148]	@ (3401102c <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
34010f98:	429a      	cmp	r2, r3
34010f9a:	d116      	bne.n	34010fca <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34010f9c:	4b1b      	ldr	r3, [pc, #108]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010f9e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34010fa2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010fa6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010faa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010fae:	6a1a      	ldr	r2, [r3, #32]
34010fb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010fb4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34010fb6:	3b01      	subs	r3, #1
34010fb8:	041b      	lsls	r3, r3, #16
34010fba:	4313      	orrs	r3, r2
34010fbc:	4a13      	ldr	r2, [pc, #76]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010fbe:	430b      	orrs	r3, r1
34010fc0:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34010fc4:	f7ff f8f2 	bl	340101ac <LL_RCC_IC4_Enable>
34010fc8:	e03d      	b.n	34011046 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
34010fca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010fce:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34010fd2:	4b17      	ldr	r3, [pc, #92]	@ (34011030 <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34010fd4:	429a      	cmp	r2, r3
34010fd6:	d12d      	bne.n	34011034 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34010fd8:	4b0c      	ldr	r3, [pc, #48]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010fda:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34010fde:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34010fe2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34010fe6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010fea:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34010fec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34010ff0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34010ff2:	3b01      	subs	r3, #1
34010ff4:	041b      	lsls	r3, r3, #16
34010ff6:	4313      	orrs	r3, r2
34010ff8:	4a04      	ldr	r2, [pc, #16]	@ (3401100c <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34010ffa:	430b      	orrs	r3, r1
34010ffc:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34011000:	f7ff f914 	bl	3401022c <LL_RCC_IC5_Enable>
34011004:	e01f      	b.n	34011046 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
34011006:	bf00      	nop
34011008:	03030414 	.word	0x03030414
3401100c:	56028000 	.word	0x56028000
34011010:	03010414 	.word	0x03010414
34011014:	03020814 	.word	0x03020814
34011018:	03030814 	.word	0x03030814
3401101c:	03010814 	.word	0x03010814
34011020:	0302001c 	.word	0x0302001c
34011024:	0303001c 	.word	0x0303001c
34011028:	0301001c 	.word	0x0301001c
3401102c:	0302041c 	.word	0x0302041c
34011030:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34011034:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011038:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
3401103c:	4bb3      	ldr	r3, [pc, #716]	@ (3401130c <HAL_RCCEx_PeriphCLKConfig+0x99c>)
3401103e:	429a      	cmp	r2, r3
34011040:	d101      	bne.n	34011046 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
34011042:	f7ff fc73 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
34011046:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401104a:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
3401104e:	4618      	mov	r0, r3
34011050:	f7fe fbe3 	bl	3400f81a <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
34011054:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011058:	e9d3 2300 	ldrd	r2, r3, [r3]
3401105c:	f002 0301 	and.w	r3, r2, #1
34011060:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
34011064:	2300      	movs	r3, #0
34011066:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
3401106a:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
3401106e:	4603      	mov	r3, r0
34011070:	460a      	mov	r2, r1
34011072:	4313      	orrs	r3, r2
34011074:	d057      	beq.n	34011126 <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
34011076:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401107a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3401107e:	2b20      	cmp	r3, #32
34011080:	d116      	bne.n	340110b0 <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34011082:	4ba3      	ldr	r3, [pc, #652]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011084:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34011088:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401108c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011090:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011094:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34011096:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401109a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401109c:	3b01      	subs	r3, #1
3401109e:	041b      	lsls	r3, r3, #16
340110a0:	4313      	orrs	r3, r2
340110a2:	4a9b      	ldr	r2, [pc, #620]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340110a4:	430b      	orrs	r3, r1
340110a6:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
340110aa:	f7ff f8ff 	bl	340102ac <LL_RCC_IC7_Enable>
340110ae:	e024      	b.n	340110fa <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
340110b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340110b4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340110b8:	2b30      	cmp	r3, #48	@ 0x30
340110ba:	d116      	bne.n	340110ea <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340110bc:	4b94      	ldr	r3, [pc, #592]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340110be:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340110c2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340110c6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340110ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340110ce:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340110d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340110d4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340110d6:	3b01      	subs	r3, #1
340110d8:	041b      	lsls	r3, r3, #16
340110da:	4313      	orrs	r3, r2
340110dc:	4a8c      	ldr	r2, [pc, #560]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340110de:	430b      	orrs	r3, r1
340110e0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340110e4:	f7ff f922 	bl	3401032c <LL_RCC_IC8_Enable>
340110e8:	e007      	b.n	340110fa <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
340110ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340110ee:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340110f2:	2b10      	cmp	r3, #16
340110f4:	d101      	bne.n	340110fa <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
340110f6:	f7ff fc19 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
340110fa:	4b85      	ldr	r3, [pc, #532]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340110fc:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34011100:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34011104:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
34011108:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401110c:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
34011110:	3b01      	subs	r3, #1
34011112:	021a      	lsls	r2, r3, #8
34011114:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011118:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
3401111c:	4313      	orrs	r3, r2
3401111e:	4a7c      	ldr	r2, [pc, #496]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011120:	430b      	orrs	r3, r1
34011122:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34011126:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401112a:	e9d3 2300 	ldrd	r2, r3, [r3]
3401112e:	f002 0302 	and.w	r3, r2, #2
34011132:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
34011136:	2300      	movs	r3, #0
34011138:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
3401113c:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34011140:	4603      	mov	r3, r0
34011142:	460a      	mov	r2, r1
34011144:	4313      	orrs	r3, r2
34011146:	d048      	beq.n	340111da <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34011148:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401114c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34011150:	2b02      	cmp	r3, #2
34011152:	d116      	bne.n	34011182 <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34011154:	4b6e      	ldr	r3, [pc, #440]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011156:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3401115a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401115e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011162:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011166:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34011168:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401116c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401116e:	3b01      	subs	r3, #1
34011170:	041b      	lsls	r3, r3, #16
34011172:	4313      	orrs	r3, r2
34011174:	4a66      	ldr	r2, [pc, #408]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011176:	430b      	orrs	r3, r1
34011178:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
3401117c:	f7ff f896 	bl	340102ac <LL_RCC_IC7_Enable>
34011180:	e024      	b.n	340111cc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34011182:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011186:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
3401118a:	2b03      	cmp	r3, #3
3401118c:	d116      	bne.n	340111bc <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3401118e:	4b60      	ldr	r3, [pc, #384]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011190:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34011194:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011198:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401119c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340111a0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340111a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340111a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340111a8:	3b01      	subs	r3, #1
340111aa:	041b      	lsls	r3, r3, #16
340111ac:	4313      	orrs	r3, r2
340111ae:	4a58      	ldr	r2, [pc, #352]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340111b0:	430b      	orrs	r3, r1
340111b2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340111b6:	f7ff f8b9 	bl	3401032c <LL_RCC_IC8_Enable>
340111ba:	e007      	b.n	340111cc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
340111bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340111c0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340111c4:	2b01      	cmp	r3, #1
340111c6:	d101      	bne.n	340111cc <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
340111c8:	f7ff fbb0 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
340111cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340111d0:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340111d4:	4618      	mov	r0, r3
340111d6:	f7fe f9b1 	bl	3400f53c <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
340111da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340111de:	e9d3 2300 	ldrd	r2, r3, [r3]
340111e2:	f002 0308 	and.w	r3, r2, #8
340111e6:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
340111ea:	2300      	movs	r3, #0
340111ec:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
340111f0:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
340111f4:	4603      	mov	r3, r0
340111f6:	460a      	mov	r2, r1
340111f8:	4313      	orrs	r3, r2
340111fa:	d017      	beq.n	3401122c <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
340111fc:	4b44      	ldr	r3, [pc, #272]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340111fe:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34011202:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011206:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401120a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401120e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34011212:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011216:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
3401121a:	3b01      	subs	r3, #1
3401121c:	041b      	lsls	r3, r3, #16
3401121e:	4313      	orrs	r3, r2
34011220:	4a3b      	ldr	r2, [pc, #236]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011222:	430b      	orrs	r3, r1
34011224:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34011228:	f7ff fac0 	bl	340107ac <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
3401122c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011230:	e9d3 2300 	ldrd	r2, r3, [r3]
34011234:	f002 0310 	and.w	r3, r2, #16
34011238:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
3401123c:	2300      	movs	r3, #0
3401123e:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
34011242:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
34011246:	4603      	mov	r3, r0
34011248:	460a      	mov	r2, r1
3401124a:	4313      	orrs	r3, r2
3401124c:	d02f      	beq.n	340112ae <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
3401124e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011252:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34011256:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
3401125a:	d118      	bne.n	3401128e <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
3401125c:	4b2c      	ldr	r3, [pc, #176]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3401125e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34011262:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011266:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401126a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401126e:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
34011272:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011276:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3401127a:	3b01      	subs	r3, #1
3401127c:	041b      	lsls	r3, r3, #16
3401127e:	4313      	orrs	r3, r2
34011280:	4a23      	ldr	r2, [pc, #140]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011282:	430b      	orrs	r3, r1
34011284:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34011288:	f7ff fa50 	bl	3401072c <LL_RCC_IC17_Enable>
3401128c:	e008      	b.n	340112a0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3401128e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011292:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34011296:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401129a:	d101      	bne.n	340112a0 <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
3401129c:	f7ff fb46 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
340112a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340112a4:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
340112a8:	4618      	mov	r0, r3
340112aa:	f7fe f973 	bl	3400f594 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
340112ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340112b2:	e9d3 2300 	ldrd	r2, r3, [r3]
340112b6:	f002 0320 	and.w	r3, r2, #32
340112ba:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
340112be:	2300      	movs	r3, #0
340112c0:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
340112c4:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
340112c8:	4603      	mov	r3, r0
340112ca:	460a      	mov	r2, r1
340112cc:	4313      	orrs	r3, r2
340112ce:	d031      	beq.n	34011334 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
340112d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340112d4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340112d8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340112dc:	d11a      	bne.n	34011314 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
340112de:	4b0c      	ldr	r3, [pc, #48]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
340112e0:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
340112e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340112e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340112ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340112f0:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
340112f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340112f6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
340112f8:	3b01      	subs	r3, #1
340112fa:	041b      	lsls	r3, r3, #16
340112fc:	4313      	orrs	r3, r2
340112fe:	4a04      	ldr	r2, [pc, #16]	@ (34011310 <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34011300:	430b      	orrs	r3, r1
34011302:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
34011306:	f7ff f8d1 	bl	340104ac <LL_RCC_IC12_Enable>
3401130a:	e00c      	b.n	34011326 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
3401130c:	0301041c 	.word	0x0301041c
34011310:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
34011314:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011318:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3401131c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34011320:	d101      	bne.n	34011326 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
34011322:	f7ff fb03 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
34011326:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401132a:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3401132e:	4618      	mov	r0, r3
34011330:	f7fe f946 	bl	3400f5c0 <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
34011334:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011338:	e9d3 2300 	ldrd	r2, r3, [r3]
3401133c:	f002 0340 	and.w	r3, r2, #64	@ 0x40
34011340:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
34011344:	2300      	movs	r3, #0
34011346:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
3401134a:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
3401134e:	4603      	mov	r3, r0
34011350:	460a      	mov	r2, r1
34011352:	4313      	orrs	r3, r2
34011354:	d006      	beq.n	34011364 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
34011356:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401135a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3401135e:	4618      	mov	r0, r3
34011360:	f7fe f944 	bl	3400f5ec <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34011364:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011368:	e9d3 2300 	ldrd	r2, r3, [r3]
3401136c:	f002 0380 	and.w	r3, r2, #128	@ 0x80
34011370:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34011374:	2300      	movs	r3, #0
34011376:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
3401137a:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
3401137e:	4603      	mov	r3, r0
34011380:	460a      	mov	r2, r1
34011382:	4313      	orrs	r3, r2
34011384:	d006      	beq.n	34011394 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34011386:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401138a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3401138e:	4618      	mov	r0, r3
34011390:	f7fe f950 	bl	3400f634 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34011394:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011398:	e9d3 2300 	ldrd	r2, r3, [r3]
3401139c:	f402 7380 	and.w	r3, r2, #256	@ 0x100
340113a0:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
340113a4:	2300      	movs	r3, #0
340113a6:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
340113aa:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
340113ae:	4603      	mov	r3, r0
340113b0:	460a      	mov	r2, r1
340113b2:	4313      	orrs	r3, r2
340113b4:	d006      	beq.n	340113c4 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
340113b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340113ba:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
340113be:	4618      	mov	r0, r3
340113c0:	f7fe f94e 	bl	3400f660 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
340113c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340113c8:	e9d3 2300 	ldrd	r2, r3, [r3]
340113cc:	f402 7300 	and.w	r3, r2, #512	@ 0x200
340113d0:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
340113d4:	2300      	movs	r3, #0
340113d6:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
340113da:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
340113de:	4603      	mov	r3, r0
340113e0:	460a      	mov	r2, r1
340113e2:	4313      	orrs	r3, r2
340113e4:	d038      	beq.n	34011458 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
340113e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340113ea:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340113ee:	2b02      	cmp	r3, #2
340113f0:	d116      	bne.n	34011420 <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
340113f2:	4bbc      	ldr	r3, [pc, #752]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340113f4:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
340113f8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340113fc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011400:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011404:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
34011406:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401140a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3401140c:	3b01      	subs	r3, #1
3401140e:	041b      	lsls	r3, r3, #16
34011410:	4313      	orrs	r3, r2
34011412:	4ab4      	ldr	r2, [pc, #720]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011414:	430b      	orrs	r3, r1
34011416:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
3401141a:	f7ff f887 	bl	3401052c <LL_RCC_IC13_Enable>
3401141e:	e007      	b.n	34011430 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
34011420:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011424:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34011428:	2b01      	cmp	r3, #1
3401142a:	d101      	bne.n	34011430 <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
3401142c:	f7ff fa7e 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
34011430:	4bac      	ldr	r3, [pc, #688]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011432:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34011436:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
3401143a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401143e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34011442:	3b01      	subs	r3, #1
34011444:	011a      	lsls	r2, r3, #4
34011446:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401144a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3401144e:	4313      	orrs	r3, r2
34011450:	4aa4      	ldr	r2, [pc, #656]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011452:	430b      	orrs	r3, r1
34011454:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
34011458:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401145c:	e9d3 2300 	ldrd	r2, r3, [r3]
34011460:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34011464:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34011468:	2300      	movs	r3, #0
3401146a:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3401146e:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
34011472:	4603      	mov	r3, r0
34011474:	460a      	mov	r2, r1
34011476:	4313      	orrs	r3, r2
34011478:	d02d      	beq.n	340114d6 <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
3401147a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401147e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34011482:	2b02      	cmp	r3, #2
34011484:	d118      	bne.n	340114b8 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34011486:	4b97      	ldr	r3, [pc, #604]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011488:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3401148c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011490:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011494:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011498:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
3401149c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340114a0:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
340114a4:	3b01      	subs	r3, #1
340114a6:	041b      	lsls	r3, r3, #16
340114a8:	4313      	orrs	r3, r2
340114aa:	4a8e      	ldr	r2, [pc, #568]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340114ac:	430b      	orrs	r3, r1
340114ae:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
340114b2:	f7ff f9bb 	bl	3401082c <LL_RCC_IC19_Enable>
340114b6:	e007      	b.n	340114c8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
340114b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340114bc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340114c0:	2b01      	cmp	r3, #1
340114c2:	d101      	bne.n	340114c8 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
340114c4:	f7ff fa32 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
340114c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340114cc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340114d0:	4618      	mov	r0, r3
340114d2:	f7fe f8db 	bl	3400f68c <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
340114d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340114da:	e9d3 2300 	ldrd	r2, r3, [r3]
340114de:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
340114e2:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
340114e6:	2300      	movs	r3, #0
340114e8:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
340114ec:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
340114f0:	4603      	mov	r3, r0
340114f2:	460a      	mov	r2, r1
340114f4:	4313      	orrs	r3, r2
340114f6:	d04b      	beq.n	34011590 <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
340114f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340114fc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34011500:	4b79      	ldr	r3, [pc, #484]	@ (340116e8 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
34011502:	429a      	cmp	r2, r3
34011504:	d116      	bne.n	34011534 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011506:	4b77      	ldr	r3, [pc, #476]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011508:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401150c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011510:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011514:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011518:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401151a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401151e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011520:	3b01      	subs	r3, #1
34011522:	041b      	lsls	r3, r3, #16
34011524:	4313      	orrs	r3, r2
34011526:	4a6f      	ldr	r2, [pc, #444]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011528:	430b      	orrs	r3, r1
3401152a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3401152e:	f7fe ff7d 	bl	3401042c <LL_RCC_IC10_Enable>
34011532:	e026      	b.n	34011582 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
34011534:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011538:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3401153c:	4b6b      	ldr	r3, [pc, #428]	@ (340116ec <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
3401153e:	429a      	cmp	r2, r3
34011540:	d116      	bne.n	34011570 <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011542:	4b68      	ldr	r3, [pc, #416]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011544:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011548:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401154c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011550:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011554:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011556:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401155a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3401155c:	3b01      	subs	r3, #1
3401155e:	041b      	lsls	r3, r3, #16
34011560:	4313      	orrs	r3, r2
34011562:	4a60      	ldr	r2, [pc, #384]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34011564:	430b      	orrs	r3, r1
34011566:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3401156a:	f7ff f85f 	bl	3401062c <LL_RCC_IC15_Enable>
3401156e:	e008      	b.n	34011582 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
34011570:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011574:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34011578:	4b5d      	ldr	r3, [pc, #372]	@ (340116f0 <HAL_RCCEx_PeriphCLKConfig+0xd80>)
3401157a:	429a      	cmp	r2, r3
3401157c:	d101      	bne.n	34011582 <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
3401157e:	f7ff f9d5 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
34011582:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011586:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401158a:	4618      	mov	r0, r3
3401158c:	f7fe f8aa 	bl	3400f6e4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
34011590:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011594:	e9d3 2300 	ldrd	r2, r3, [r3]
34011598:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
3401159c:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
340115a0:	2300      	movs	r3, #0
340115a2:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
340115a6:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
340115aa:	4603      	mov	r3, r0
340115ac:	460a      	mov	r2, r1
340115ae:	4313      	orrs	r3, r2
340115b0:	d04b      	beq.n	3401164a <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
340115b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340115b6:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
340115ba:	4b4e      	ldr	r3, [pc, #312]	@ (340116f4 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
340115bc:	429a      	cmp	r2, r3
340115be:	d116      	bne.n	340115ee <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340115c0:	4b48      	ldr	r3, [pc, #288]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340115c2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340115c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340115ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340115ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340115d2:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340115d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340115d8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340115da:	3b01      	subs	r3, #1
340115dc:	041b      	lsls	r3, r3, #16
340115de:	4313      	orrs	r3, r2
340115e0:	4a40      	ldr	r2, [pc, #256]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340115e2:	430b      	orrs	r3, r1
340115e4:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340115e8:	f7fe ff20 	bl	3401042c <LL_RCC_IC10_Enable>
340115ec:	e026      	b.n	3401163c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
340115ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340115f2:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
340115f6:	4b40      	ldr	r3, [pc, #256]	@ (340116f8 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
340115f8:	429a      	cmp	r2, r3
340115fa:	d116      	bne.n	3401162a <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340115fc:	4b39      	ldr	r3, [pc, #228]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340115fe:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011602:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011606:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401160a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401160e:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011610:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011614:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011616:	3b01      	subs	r3, #1
34011618:	041b      	lsls	r3, r3, #16
3401161a:	4313      	orrs	r3, r2
3401161c:	4a31      	ldr	r2, [pc, #196]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3401161e:	430b      	orrs	r3, r1
34011620:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011624:	f7ff f802 	bl	3401062c <LL_RCC_IC15_Enable>
34011628:	e008      	b.n	3401163c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
3401162a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401162e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34011632:	4b32      	ldr	r3, [pc, #200]	@ (340116fc <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
34011634:	429a      	cmp	r2, r3
34011636:	d101      	bne.n	3401163c <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
34011638:	f7ff f978 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
3401163c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011640:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
34011644:	4618      	mov	r0, r3
34011646:	f7fe f84d 	bl	3400f6e4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
3401164a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401164e:	e9d3 2300 	ldrd	r2, r3, [r3]
34011652:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
34011656:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
3401165a:	2300      	movs	r3, #0
3401165c:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
34011660:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34011664:	4603      	mov	r3, r0
34011666:	460a      	mov	r2, r1
34011668:	4313      	orrs	r3, r2
3401166a:	d05d      	beq.n	34011728 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
3401166c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011670:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011674:	4b22      	ldr	r3, [pc, #136]	@ (34011700 <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34011676:	429a      	cmp	r2, r3
34011678:	d116      	bne.n	340116a8 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3401167a:	4b1a      	ldr	r3, [pc, #104]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3401167c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34011680:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011684:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011688:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401168c:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401168e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011692:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011694:	3b01      	subs	r3, #1
34011696:	041b      	lsls	r3, r3, #16
34011698:	4313      	orrs	r3, r2
3401169a:	4a12      	ldr	r2, [pc, #72]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3401169c:	430b      	orrs	r3, r1
3401169e:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340116a2:	f7fe fec3 	bl	3401042c <LL_RCC_IC10_Enable>
340116a6:	e038      	b.n	3401171a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
340116a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340116ac:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
340116b0:	4b14      	ldr	r3, [pc, #80]	@ (34011704 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
340116b2:	429a      	cmp	r2, r3
340116b4:	d128      	bne.n	34011708 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340116b6:	4b0b      	ldr	r3, [pc, #44]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340116b8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340116bc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340116c0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340116c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340116c8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340116ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340116ce:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340116d0:	3b01      	subs	r3, #1
340116d2:	041b      	lsls	r3, r3, #16
340116d4:	4313      	orrs	r3, r2
340116d6:	4a03      	ldr	r2, [pc, #12]	@ (340116e4 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340116d8:	430b      	orrs	r3, r1
340116da:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340116de:	f7fe ffa5 	bl	3401062c <LL_RCC_IC15_Enable>
340116e2:	e01a      	b.n	3401171a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
340116e4:	56028000 	.word	0x56028000
340116e8:	0702000c 	.word	0x0702000c
340116ec:	0703000c 	.word	0x0703000c
340116f0:	0701000c 	.word	0x0701000c
340116f4:	0702040c 	.word	0x0702040c
340116f8:	0703040c 	.word	0x0703040c
340116fc:	0701040c 	.word	0x0701040c
34011700:	0702080c 	.word	0x0702080c
34011704:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
34011708:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401170c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34011710:	4bc8      	ldr	r3, [pc, #800]	@ (34011a34 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
34011712:	429a      	cmp	r2, r3
34011714:	d101      	bne.n	3401171a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
34011716:	f7ff f909 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
3401171a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401171e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34011722:	4618      	mov	r0, r3
34011724:	f7fd ffde 	bl	3400f6e4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
34011728:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401172c:	e9d3 2300 	ldrd	r2, r3, [r3]
34011730:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
34011734:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
34011738:	2300      	movs	r3, #0
3401173a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
3401173e:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
34011742:	4603      	mov	r3, r0
34011744:	460a      	mov	r2, r1
34011746:	4313      	orrs	r3, r2
34011748:	d04b      	beq.n	340117e2 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
3401174a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401174e:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34011752:	4bb9      	ldr	r3, [pc, #740]	@ (34011a38 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
34011754:	429a      	cmp	r2, r3
34011756:	d116      	bne.n	34011786 <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011758:	4bb8      	ldr	r3, [pc, #736]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3401175a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3401175e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011762:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011766:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401176a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3401176c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011770:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34011772:	3b01      	subs	r3, #1
34011774:	041b      	lsls	r3, r3, #16
34011776:	4313      	orrs	r3, r2
34011778:	4ab0      	ldr	r2, [pc, #704]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3401177a:	430b      	orrs	r3, r1
3401177c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34011780:	f7fe fe54 	bl	3401042c <LL_RCC_IC10_Enable>
34011784:	e026      	b.n	340117d4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34011786:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401178a:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3401178e:	4bac      	ldr	r3, [pc, #688]	@ (34011a40 <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
34011790:	429a      	cmp	r2, r3
34011792:	d116      	bne.n	340117c2 <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011794:	4ba9      	ldr	r3, [pc, #676]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011796:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401179a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401179e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340117a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340117a6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340117a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340117ac:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340117ae:	3b01      	subs	r3, #1
340117b0:	041b      	lsls	r3, r3, #16
340117b2:	4313      	orrs	r3, r2
340117b4:	4aa1      	ldr	r2, [pc, #644]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340117b6:	430b      	orrs	r3, r1
340117b8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340117bc:	f7fe ff36 	bl	3401062c <LL_RCC_IC15_Enable>
340117c0:	e008      	b.n	340117d4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
340117c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340117c6:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340117ca:	4b9e      	ldr	r3, [pc, #632]	@ (34011a44 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
340117cc:	429a      	cmp	r2, r3
340117ce:	d101      	bne.n	340117d4 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
340117d0:	f7ff f8ac 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
340117d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340117d8:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
340117dc:	4618      	mov	r0, r3
340117de:	f7fd ff81 	bl	3400f6e4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
340117e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340117e6:	e9d3 2300 	ldrd	r2, r3, [r3]
340117ea:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
340117ee:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
340117f2:	2300      	movs	r3, #0
340117f4:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
340117f8:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
340117fc:	4603      	mov	r3, r0
340117fe:	460a      	mov	r2, r1
34011800:	4313      	orrs	r3, r2
34011802:	d04b      	beq.n	3401189c <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
34011804:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011808:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
3401180c:	4b8e      	ldr	r3, [pc, #568]	@ (34011a48 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
3401180e:	429a      	cmp	r2, r3
34011810:	d116      	bne.n	34011840 <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34011812:	4b8a      	ldr	r3, [pc, #552]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011814:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34011818:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401181c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011820:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011824:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34011826:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401182a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401182c:	3b01      	subs	r3, #1
3401182e:	041b      	lsls	r3, r3, #16
34011830:	4313      	orrs	r3, r2
34011832:	4a82      	ldr	r2, [pc, #520]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011834:	430b      	orrs	r3, r1
34011836:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3401183a:	f7fe fdf7 	bl	3401042c <LL_RCC_IC10_Enable>
3401183e:	e026      	b.n	3401188e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
34011840:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011844:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011848:	4b80      	ldr	r3, [pc, #512]	@ (34011a4c <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
3401184a:	429a      	cmp	r2, r3
3401184c:	d116      	bne.n	3401187c <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3401184e:	4b7b      	ldr	r3, [pc, #492]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011850:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011854:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011858:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401185c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011860:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011862:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011866:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011868:	3b01      	subs	r3, #1
3401186a:	041b      	lsls	r3, r3, #16
3401186c:	4313      	orrs	r3, r2
3401186e:	4a73      	ldr	r2, [pc, #460]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011870:	430b      	orrs	r3, r1
34011872:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011876:	f7fe fed9 	bl	3401062c <LL_RCC_IC15_Enable>
3401187a:	e008      	b.n	3401188e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
3401187c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011880:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34011884:	4b72      	ldr	r3, [pc, #456]	@ (34011a50 <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
34011886:	429a      	cmp	r2, r3
34011888:	d101      	bne.n	3401188e <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
3401188a:	f7ff f84f 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
3401188e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011892:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34011896:	4618      	mov	r0, r3
34011898:	f7fd ff2f 	bl	3400f6fa <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
3401189c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340118a0:	e9d3 2300 	ldrd	r2, r3, [r3]
340118a4:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
340118a8:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
340118ac:	2300      	movs	r3, #0
340118ae:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
340118b2:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
340118b6:	4603      	mov	r3, r0
340118b8:	460a      	mov	r2, r1
340118ba:	4313      	orrs	r3, r2
340118bc:	d04b      	beq.n	34011956 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
340118be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340118c2:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
340118c6:	4b63      	ldr	r3, [pc, #396]	@ (34011a54 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
340118c8:	429a      	cmp	r2, r3
340118ca:	d116      	bne.n	340118fa <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340118cc:	4b5b      	ldr	r3, [pc, #364]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340118ce:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340118d2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340118d6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340118da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340118de:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340118e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340118e4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340118e6:	3b01      	subs	r3, #1
340118e8:	041b      	lsls	r3, r3, #16
340118ea:	4313      	orrs	r3, r2
340118ec:	4a53      	ldr	r2, [pc, #332]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340118ee:	430b      	orrs	r3, r1
340118f0:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340118f4:	f7fe fd9a 	bl	3401042c <LL_RCC_IC10_Enable>
340118f8:	e026      	b.n	34011948 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
340118fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340118fe:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34011902:	4b55      	ldr	r3, [pc, #340]	@ (34011a58 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
34011904:	429a      	cmp	r2, r3
34011906:	d116      	bne.n	34011936 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011908:	4b4c      	ldr	r3, [pc, #304]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3401190a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401190e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011912:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011916:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401191a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3401191c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011920:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011922:	3b01      	subs	r3, #1
34011924:	041b      	lsls	r3, r3, #16
34011926:	4313      	orrs	r3, r2
34011928:	4a44      	ldr	r2, [pc, #272]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3401192a:	430b      	orrs	r3, r1
3401192c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011930:	f7fe fe7c 	bl	3401062c <LL_RCC_IC15_Enable>
34011934:	e008      	b.n	34011948 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
34011936:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401193a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3401193e:	4b47      	ldr	r3, [pc, #284]	@ (34011a5c <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
34011940:	429a      	cmp	r2, r3
34011942:	d101      	bne.n	34011948 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
34011944:	f7fe fff2 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
34011948:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401194c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011950:	4618      	mov	r0, r3
34011952:	f7fd fed2 	bl	3400f6fa <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
34011956:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401195a:	e9d3 2300 	ldrd	r2, r3, [r3]
3401195e:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
34011962:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34011966:	2300      	movs	r3, #0
34011968:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3401196c:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
34011970:	4603      	mov	r3, r0
34011972:	460a      	mov	r2, r1
34011974:	4313      	orrs	r3, r2
34011976:	d02d      	beq.n	340119d4 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34011978:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401197c:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34011980:	4b37      	ldr	r3, [pc, #220]	@ (34011a60 <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
34011982:	429a      	cmp	r2, r3
34011984:	d116      	bne.n	340119b4 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011986:	4b2d      	ldr	r3, [pc, #180]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011988:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401198c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011990:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011994:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011998:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3401199a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401199e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340119a0:	3b01      	subs	r3, #1
340119a2:	041b      	lsls	r3, r3, #16
340119a4:	4313      	orrs	r3, r2
340119a6:	4a25      	ldr	r2, [pc, #148]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340119a8:	430b      	orrs	r3, r1
340119aa:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340119ae:	f7fe fe3d 	bl	3401062c <LL_RCC_IC15_Enable>
340119b2:	e008      	b.n	340119c6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
340119b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340119b8:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
340119bc:	4b29      	ldr	r3, [pc, #164]	@ (34011a64 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
340119be:	429a      	cmp	r2, r3
340119c0:	d101      	bne.n	340119c6 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
340119c2:	f7fe ffb3 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
340119c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340119ca:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
340119ce:	4618      	mov	r0, r3
340119d0:	f7fd fe9e 	bl	3400f710 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
340119d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340119d8:	e9d3 2300 	ldrd	r2, r3, [r3]
340119dc:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
340119e0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
340119e4:	2300      	movs	r3, #0
340119e6:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
340119ea:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
340119ee:	4603      	mov	r3, r0
340119f0:	460a      	mov	r2, r1
340119f2:	4313      	orrs	r3, r2
340119f4:	d04a      	beq.n	34011a8c <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
340119f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340119fa:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
340119fe:	4b1a      	ldr	r3, [pc, #104]	@ (34011a68 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
34011a00:	429a      	cmp	r2, r3
34011a02:	d133      	bne.n	34011a6c <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011a04:	4b0d      	ldr	r3, [pc, #52]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011a06:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011a0a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011a0e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011a12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011a16:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011a18:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011a1c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011a1e:	3b01      	subs	r3, #1
34011a20:	041b      	lsls	r3, r3, #16
34011a22:	4313      	orrs	r3, r2
34011a24:	4a05      	ldr	r2, [pc, #20]	@ (34011a3c <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34011a26:	430b      	orrs	r3, r1
34011a28:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011a2c:	f7fe fdfe 	bl	3401062c <LL_RCC_IC15_Enable>
34011a30:	e025      	b.n	34011a7e <HAL_RCCEx_PeriphCLKConfig+0x110e>
34011a32:	bf00      	nop
34011a34:	0701080c 	.word	0x0701080c
34011a38:	07020c0c 	.word	0x07020c0c
34011a3c:	56028000 	.word	0x56028000
34011a40:	07030c0c 	.word	0x07030c0c
34011a44:	07010c0c 	.word	0x07010c0c
34011a48:	0702100c 	.word	0x0702100c
34011a4c:	0703100c 	.word	0x0703100c
34011a50:	0701100c 	.word	0x0701100c
34011a54:	0702140c 	.word	0x0702140c
34011a58:	0703140c 	.word	0x0703140c
34011a5c:	0701140c 	.word	0x0701140c
34011a60:	0702082c 	.word	0x0702082c
34011a64:	0701082c 	.word	0x0701082c
34011a68:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34011a6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011a70:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34011a74:	4bca      	ldr	r3, [pc, #808]	@ (34011da0 <HAL_RCCEx_PeriphCLKConfig+0x1430>)
34011a76:	429a      	cmp	r2, r3
34011a78:	d101      	bne.n	34011a7e <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
34011a7a:	f7fe ff57 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
34011a7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011a82:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34011a86:	4618      	mov	r0, r3
34011a88:	f7fd fe42 	bl	3400f710 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34011a8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011a90:	e9d3 2300 	ldrd	r2, r3, [r3]
34011a94:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34011a98:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34011a9c:	2300      	movs	r3, #0
34011a9e:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
34011aa2:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
34011aa6:	4603      	mov	r3, r0
34011aa8:	460a      	mov	r2, r1
34011aaa:	4313      	orrs	r3, r2
34011aac:	d02d      	beq.n	34011b0a <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
34011aae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ab2:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011ab6:	4bbb      	ldr	r3, [pc, #748]	@ (34011da4 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
34011ab8:	429a      	cmp	r2, r3
34011aba:	d116      	bne.n	34011aea <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011abc:	4bba      	ldr	r3, [pc, #744]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011abe:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011ac2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011ac6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011aca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ace:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011ad0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ad4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011ad6:	3b01      	subs	r3, #1
34011ad8:	041b      	lsls	r3, r3, #16
34011ada:	4313      	orrs	r3, r2
34011adc:	4ab2      	ldr	r2, [pc, #712]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011ade:	430b      	orrs	r3, r1
34011ae0:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011ae4:	f7fe fda2 	bl	3401062c <LL_RCC_IC15_Enable>
34011ae8:	e008      	b.n	34011afc <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
34011aea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011aee:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34011af2:	4bae      	ldr	r3, [pc, #696]	@ (34011dac <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34011af4:	429a      	cmp	r2, r3
34011af6:	d101      	bne.n	34011afc <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
34011af8:	f7fe ff18 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34011afc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b00:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34011b04:	4618      	mov	r0, r3
34011b06:	f7fd fe03 	bl	3400f710 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
34011b0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b0e:	e9d3 2300 	ldrd	r2, r3, [r3]
34011b12:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
34011b16:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
34011b1a:	2300      	movs	r3, #0
34011b1c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
34011b20:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
34011b24:	4603      	mov	r3, r0
34011b26:	460a      	mov	r2, r1
34011b28:	4313      	orrs	r3, r2
34011b2a:	d02d      	beq.n	34011b88 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
34011b2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b30:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011b34:	4b9e      	ldr	r3, [pc, #632]	@ (34011db0 <HAL_RCCEx_PeriphCLKConfig+0x1440>)
34011b36:	429a      	cmp	r2, r3
34011b38:	d116      	bne.n	34011b68 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011b3a:	4b9b      	ldr	r3, [pc, #620]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011b3c:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011b40:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011b44:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011b48:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b4c:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011b4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b52:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011b54:	3b01      	subs	r3, #1
34011b56:	041b      	lsls	r3, r3, #16
34011b58:	4313      	orrs	r3, r2
34011b5a:	4a93      	ldr	r2, [pc, #588]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011b5c:	430b      	orrs	r3, r1
34011b5e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011b62:	f7fe fd63 	bl	3401062c <LL_RCC_IC15_Enable>
34011b66:	e008      	b.n	34011b7a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34011b68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b6c:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
34011b70:	4b90      	ldr	r3, [pc, #576]	@ (34011db4 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
34011b72:	429a      	cmp	r2, r3
34011b74:	d101      	bne.n	34011b7a <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
34011b76:	f7fe fed9 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
34011b7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b7e:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34011b82:	4618      	mov	r0, r3
34011b84:	f7fd fdc4 	bl	3400f710 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34011b88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011b8c:	e9d3 2300 	ldrd	r2, r3, [r3]
34011b90:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
34011b94:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
34011b98:	2300      	movs	r3, #0
34011b9a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
34011b9e:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
34011ba2:	4603      	mov	r3, r0
34011ba4:	460a      	mov	r2, r1
34011ba6:	4313      	orrs	r3, r2
34011ba8:	d02d      	beq.n	34011c06 <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
34011baa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011bae:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34011bb2:	4b81      	ldr	r3, [pc, #516]	@ (34011db8 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
34011bb4:	429a      	cmp	r2, r3
34011bb6:	d116      	bne.n	34011be6 <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34011bb8:	4b7b      	ldr	r3, [pc, #492]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011bba:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34011bbe:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011bc2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011bc6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011bca:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34011bcc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011bd0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34011bd2:	3b01      	subs	r3, #1
34011bd4:	041b      	lsls	r3, r3, #16
34011bd6:	4313      	orrs	r3, r2
34011bd8:	4a73      	ldr	r2, [pc, #460]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011bda:	430b      	orrs	r3, r1
34011bdc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34011be0:	f7fe fd24 	bl	3401062c <LL_RCC_IC15_Enable>
34011be4:	e008      	b.n	34011bf8 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34011be6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011bea:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
34011bee:	4b73      	ldr	r3, [pc, #460]	@ (34011dbc <HAL_RCCEx_PeriphCLKConfig+0x144c>)
34011bf0:	429a      	cmp	r2, r3
34011bf2:	d101      	bne.n	34011bf8 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34011bf4:	f7fe fe9a 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
34011bf8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011bfc:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34011c00:	4618      	mov	r0, r3
34011c02:	f7fd fd85 	bl	3400f710 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
34011c06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c0a:	e9d3 2300 	ldrd	r2, r3, [r3]
34011c0e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
34011c12:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
34011c16:	2300      	movs	r3, #0
34011c18:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
34011c1c:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
34011c20:	4603      	mov	r3, r0
34011c22:	460a      	mov	r2, r1
34011c24:	4313      	orrs	r3, r2
34011c26:	d04b      	beq.n	34011cc0 <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
34011c28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c2c:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34011c30:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34011c34:	d116      	bne.n	34011c64 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34011c36:	4b5c      	ldr	r3, [pc, #368]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011c38:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34011c3c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011c40:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011c44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c48:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34011c4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c4e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34011c50:	3b01      	subs	r3, #1
34011c52:	041b      	lsls	r3, r3, #16
34011c54:	4313      	orrs	r3, r2
34011c56:	4a54      	ldr	r2, [pc, #336]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011c58:	430b      	orrs	r3, r1
34011c5a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34011c5e:	f7fe fba5 	bl	340103ac <LL_RCC_IC9_Enable>
34011c62:	e026      	b.n	34011cb2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
34011c64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c68:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34011c6c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34011c70:	d116      	bne.n	34011ca0 <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34011c72:	4b4d      	ldr	r3, [pc, #308]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011c74:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34011c78:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011c7c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011c80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c84:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34011c86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011c8a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34011c8c:	3b01      	subs	r3, #1
34011c8e:	041b      	lsls	r3, r3, #16
34011c90:	4313      	orrs	r3, r2
34011c92:	4a45      	ldr	r2, [pc, #276]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011c94:	430b      	orrs	r3, r1
34011c96:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34011c9a:	f7fe fc87 	bl	340105ac <LL_RCC_IC14_Enable>
34011c9e:	e008      	b.n	34011cb2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34011ca0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ca4:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34011ca8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34011cac:	d101      	bne.n	34011cb2 <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34011cae:	f7fe fe3d 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34011cb2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011cb6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34011cba:	4618      	mov	r0, r3
34011cbc:	f7fd fd34 	bl	3400f728 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34011cc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011cc4:	e9d3 2300 	ldrd	r2, r3, [r3]
34011cc8:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
34011ccc:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34011cd0:	2300      	movs	r3, #0
34011cd2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
34011cd6:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
34011cda:	4603      	mov	r3, r0
34011cdc:	460a      	mov	r2, r1
34011cde:	4313      	orrs	r3, r2
34011ce0:	d02f      	beq.n	34011d42 <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34011ce2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ce6:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34011cea:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34011cee:	d118      	bne.n	34011d22 <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34011cf0:	4b2d      	ldr	r3, [pc, #180]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011cf2:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34011cf6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011cfa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011cfe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d02:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34011d06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d0a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34011d0e:	3b01      	subs	r3, #1
34011d10:	041b      	lsls	r3, r3, #16
34011d12:	4313      	orrs	r3, r2
34011d14:	4a24      	ldr	r2, [pc, #144]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011d16:	430b      	orrs	r3, r1
34011d18:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
34011d1c:	f7fe fcc6 	bl	340106ac <LL_RCC_IC16_Enable>
34011d20:	e008      	b.n	34011d34 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34011d22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d26:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34011d2a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34011d2e:	d101      	bne.n	34011d34 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
34011d30:	f7fe fdfc 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
34011d34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d38:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34011d3c:	4618      	mov	r0, r3
34011d3e:	f7fd fd09 	bl	3400f754 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34011d42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d46:	e9d3 2300 	ldrd	r2, r3, [r3]
34011d4a:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
34011d4e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34011d52:	2300      	movs	r3, #0
34011d54:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34011d58:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
34011d5c:	4603      	mov	r3, r0
34011d5e:	460a      	mov	r2, r1
34011d60:	4313      	orrs	r3, r2
34011d62:	d05b      	beq.n	34011e1c <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34011d64:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d68:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34011d6c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34011d70:	d126      	bne.n	34011dc0 <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34011d72:	4b0d      	ldr	r3, [pc, #52]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011d74:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34011d78:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011d7c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011d80:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d84:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34011d86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011d8a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34011d8c:	3b01      	subs	r3, #1
34011d8e:	041b      	lsls	r3, r3, #16
34011d90:	4313      	orrs	r3, r2
34011d92:	4a05      	ldr	r2, [pc, #20]	@ (34011da8 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34011d94:	430b      	orrs	r3, r1
34011d96:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34011d9a:	f7fe fa87 	bl	340102ac <LL_RCC_IC7_Enable>
34011d9e:	e036      	b.n	34011e0e <HAL_RCCEx_PeriphCLKConfig+0x149e>
34011da0:	07010c2c 	.word	0x07010c2c
34011da4:	0702102c 	.word	0x0702102c
34011da8:	56028000 	.word	0x56028000
34011dac:	0701102c 	.word	0x0701102c
34011db0:	0702142c 	.word	0x0702142c
34011db4:	0701142c 	.word	0x0701142c
34011db8:	0702182c 	.word	0x0702182c
34011dbc:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34011dc0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011dc4:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34011dc8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34011dcc:	d116      	bne.n	34011dfc <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34011dce:	4bb5      	ldr	r3, [pc, #724]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011dd0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34011dd4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011dd8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011ddc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011de0:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34011de2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011de6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34011de8:	3b01      	subs	r3, #1
34011dea:	041b      	lsls	r3, r3, #16
34011dec:	4313      	orrs	r3, r2
34011dee:	4aad      	ldr	r2, [pc, #692]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011df0:	430b      	orrs	r3, r1
34011df2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34011df6:	f7fe fa99 	bl	3401032c <LL_RCC_IC8_Enable>
34011dfa:	e008      	b.n	34011e0e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34011dfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e00:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34011e04:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34011e08:	d101      	bne.n	34011e0e <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
34011e0a:	f7fe fd8f 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
34011e0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e12:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34011e16:	4618      	mov	r0, r3
34011e18:	f7fd fcb2 	bl	3400f780 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34011e1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e20:	e9d3 2300 	ldrd	r2, r3, [r3]
34011e24:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34011e28:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34011e2c:	2300      	movs	r3, #0
34011e2e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34011e32:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
34011e36:	4603      	mov	r3, r0
34011e38:	460a      	mov	r2, r1
34011e3a:	4313      	orrs	r3, r2
34011e3c:	d02d      	beq.n	34011e9a <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
34011e3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e42:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34011e46:	2b20      	cmp	r3, #32
34011e48:	d118      	bne.n	34011e7c <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34011e4a:	4b96      	ldr	r3, [pc, #600]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011e4c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34011e50:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011e54:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011e58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e5c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34011e60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e64:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34011e68:	3b01      	subs	r3, #1
34011e6a:	041b      	lsls	r3, r3, #16
34011e6c:	4313      	orrs	r3, r2
34011e6e:	4a8d      	ldr	r2, [pc, #564]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011e70:	430b      	orrs	r3, r1
34011e72:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34011e76:	f7fe fd19 	bl	340108ac <LL_RCC_IC20_Enable>
34011e7a:	e007      	b.n	34011e8c <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34011e7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e80:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34011e84:	2b10      	cmp	r3, #16
34011e86:	d101      	bne.n	34011e8c <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
34011e88:	f7fe fd50 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34011e8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e90:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34011e94:	4618      	mov	r0, r3
34011e96:	f7fd fc9f 	bl	3400f7d8 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
34011e9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011e9e:	e9d3 2300 	ldrd	r2, r3, [r3]
34011ea2:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
34011ea6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
34011eaa:	2300      	movs	r3, #0
34011eac:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34011eb0:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34011eb4:	4603      	mov	r3, r0
34011eb6:	460a      	mov	r2, r1
34011eb8:	4313      	orrs	r3, r2
34011eba:	d04b      	beq.n	34011f54 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34011ebc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ec0:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34011ec4:	4b78      	ldr	r3, [pc, #480]	@ (340120a8 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
34011ec6:	429a      	cmp	r2, r3
34011ec8:	d116      	bne.n	34011ef8 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34011eca:	4b76      	ldr	r3, [pc, #472]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011ecc:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34011ed0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011ed4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011ed8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011edc:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34011ede:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ee2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34011ee4:	3b01      	subs	r3, #1
34011ee6:	041b      	lsls	r3, r3, #16
34011ee8:	4313      	orrs	r3, r2
34011eea:	4a6e      	ldr	r2, [pc, #440]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011eec:	430b      	orrs	r3, r1
34011eee:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34011ef2:	f7fe f9db 	bl	340102ac <LL_RCC_IC7_Enable>
34011ef6:	e026      	b.n	34011f46 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
34011ef8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011efc:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34011f00:	4b6a      	ldr	r3, [pc, #424]	@ (340120ac <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34011f02:	429a      	cmp	r2, r3
34011f04:	d116      	bne.n	34011f34 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34011f06:	4b67      	ldr	r3, [pc, #412]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011f08:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34011f0c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011f10:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011f14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f18:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34011f1a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f1e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34011f20:	3b01      	subs	r3, #1
34011f22:	041b      	lsls	r3, r3, #16
34011f24:	4313      	orrs	r3, r2
34011f26:	4a5f      	ldr	r2, [pc, #380]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011f28:	430b      	orrs	r3, r1
34011f2a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34011f2e:	f7fe f9fd 	bl	3401032c <LL_RCC_IC8_Enable>
34011f32:	e008      	b.n	34011f46 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34011f34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f38:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34011f3c:	4b5c      	ldr	r3, [pc, #368]	@ (340120b0 <HAL_RCCEx_PeriphCLKConfig+0x1740>)
34011f3e:	429a      	cmp	r2, r3
34011f40:	d101      	bne.n	34011f46 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
34011f42:	f7fe fcf3 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
34011f46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f4a:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34011f4e:	4618      	mov	r0, r3
34011f50:	f7fd fc58 	bl	3400f804 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34011f54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f58:	e9d3 2300 	ldrd	r2, r3, [r3]
34011f5c:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
34011f60:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
34011f64:	2300      	movs	r3, #0
34011f66:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
34011f6a:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34011f6e:	4603      	mov	r3, r0
34011f70:	460a      	mov	r2, r1
34011f72:	4313      	orrs	r3, r2
34011f74:	d04b      	beq.n	3401200e <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34011f76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f7a:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34011f7e:	4b4d      	ldr	r3, [pc, #308]	@ (340120b4 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34011f80:	429a      	cmp	r2, r3
34011f82:	d116      	bne.n	34011fb2 <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34011f84:	4b47      	ldr	r3, [pc, #284]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011f86:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34011f8a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011f8e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011f92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f96:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34011f98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011f9c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34011f9e:	3b01      	subs	r3, #1
34011fa0:	041b      	lsls	r3, r3, #16
34011fa2:	4313      	orrs	r3, r2
34011fa4:	4a3f      	ldr	r2, [pc, #252]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011fa6:	430b      	orrs	r3, r1
34011fa8:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34011fac:	f7fe f97e 	bl	340102ac <LL_RCC_IC7_Enable>
34011fb0:	e026      	b.n	34012000 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34011fb2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011fb6:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34011fba:	4b3f      	ldr	r3, [pc, #252]	@ (340120b8 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34011fbc:	429a      	cmp	r2, r3
34011fbe:	d116      	bne.n	34011fee <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34011fc0:	4b38      	ldr	r3, [pc, #224]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011fc2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34011fc6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34011fca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34011fce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011fd2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34011fd4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011fd8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34011fda:	3b01      	subs	r3, #1
34011fdc:	041b      	lsls	r3, r3, #16
34011fde:	4313      	orrs	r3, r2
34011fe0:	4a30      	ldr	r2, [pc, #192]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34011fe2:	430b      	orrs	r3, r1
34011fe4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34011fe8:	f7fe f9a0 	bl	3401032c <LL_RCC_IC8_Enable>
34011fec:	e008      	b.n	34012000 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34011fee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34011ff2:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34011ff6:	4b31      	ldr	r3, [pc, #196]	@ (340120bc <HAL_RCCEx_PeriphCLKConfig+0x174c>)
34011ff8:	429a      	cmp	r2, r3
34011ffa:	d101      	bne.n	34012000 <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34011ffc:	f7fe fc96 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34012000:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012004:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34012008:	4618      	mov	r0, r3
3401200a:	f7fd fbfb 	bl	3400f804 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
3401200e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012012:	e9d3 2300 	ldrd	r2, r3, [r3]
34012016:	2100      	movs	r1, #0
34012018:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
3401201c:	f003 0301 	and.w	r3, r3, #1
34012020:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34012024:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34012028:	4603      	mov	r3, r0
3401202a:	460a      	mov	r2, r1
3401202c:	4313      	orrs	r3, r2
3401202e:	d056      	beq.n	340120de <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34012030:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012034:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012038:	2b02      	cmp	r3, #2
3401203a:	d116      	bne.n	3401206a <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
3401203c:	4b19      	ldr	r3, [pc, #100]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3401203e:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34012042:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012046:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401204a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401204e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34012050:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012054:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34012056:	3b01      	subs	r3, #1
34012058:	041b      	lsls	r3, r3, #16
3401205a:	4313      	orrs	r3, r2
3401205c:	4a11      	ldr	r2, [pc, #68]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
3401205e:	430b      	orrs	r3, r1
34012060:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34012064:	f7fe f922 	bl	340102ac <LL_RCC_IC7_Enable>
34012068:	e032      	b.n	340120d0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
3401206a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401206e:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34012072:	2b03      	cmp	r3, #3
34012074:	d124      	bne.n	340120c0 <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012076:	4b0b      	ldr	r3, [pc, #44]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34012078:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3401207c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012080:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012084:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012088:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3401208a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401208e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012090:	3b01      	subs	r3, #1
34012092:	041b      	lsls	r3, r3, #16
34012094:	4313      	orrs	r3, r2
34012096:	4a03      	ldr	r2, [pc, #12]	@ (340120a4 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34012098:	430b      	orrs	r3, r1
3401209a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3401209e:	f7fe f945 	bl	3401032c <LL_RCC_IC8_Enable>
340120a2:	e015      	b.n	340120d0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
340120a4:	56028000 	.word	0x56028000
340120a8:	07021418 	.word	0x07021418
340120ac:	07031418 	.word	0x07031418
340120b0:	07011418 	.word	0x07011418
340120b4:	07021818 	.word	0x07021818
340120b8:	07031818 	.word	0x07031818
340120bc:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
340120c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340120c4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
340120c8:	2b01      	cmp	r3, #1
340120ca:	d101      	bne.n	340120d0 <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
340120cc:	f7fe fc2e 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
340120d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340120d4:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
340120d8:	4618      	mov	r0, r3
340120da:	f7fd fba9 	bl	3400f830 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
340120de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340120e2:	e9d3 2300 	ldrd	r2, r3, [r3]
340120e6:	2100      	movs	r1, #0
340120e8:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
340120ec:	f003 0302 	and.w	r3, r3, #2
340120f0:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
340120f4:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
340120f8:	4603      	mov	r3, r0
340120fa:	460a      	mov	r2, r1
340120fc:	4313      	orrs	r3, r2
340120fe:	d04b      	beq.n	34012198 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34012100:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012104:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012108:	4bc6      	ldr	r3, [pc, #792]	@ (34012424 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
3401210a:	429a      	cmp	r2, r3
3401210c:	d116      	bne.n	3401213c <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3401210e:	4bc6      	ldr	r3, [pc, #792]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012110:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012114:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012118:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401211c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012120:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012122:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012126:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34012128:	3b01      	subs	r3, #1
3401212a:	041b      	lsls	r3, r3, #16
3401212c:	4313      	orrs	r3, r2
3401212e:	4abe      	ldr	r2, [pc, #760]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012130:	430b      	orrs	r3, r1
34012132:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34012136:	f7fe f8f9 	bl	3401032c <LL_RCC_IC8_Enable>
3401213a:	e026      	b.n	3401218a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
3401213c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012140:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012144:	4bb9      	ldr	r3, [pc, #740]	@ (3401242c <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
34012146:	429a      	cmp	r2, r3
34012148:	d116      	bne.n	34012178 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401214a:	4bb7      	ldr	r3, [pc, #732]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401214c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012150:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012154:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012158:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401215c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401215e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012162:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012164:	3b01      	subs	r3, #1
34012166:	041b      	lsls	r3, r3, #16
34012168:	4313      	orrs	r3, r2
3401216a:	4aaf      	ldr	r2, [pc, #700]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401216c:	430b      	orrs	r3, r1
3401216e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012172:	f7fe f91b 	bl	340103ac <LL_RCC_IC9_Enable>
34012176:	e008      	b.n	3401218a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34012178:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401217c:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34012180:	4bab      	ldr	r3, [pc, #684]	@ (34012430 <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34012182:	429a      	cmp	r2, r3
34012184:	d101      	bne.n	3401218a <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
34012186:	f7fe fbd1 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
3401218a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401218e:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34012192:	4618      	mov	r0, r3
34012194:	f7fd fb62 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34012198:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401219c:	e9d3 2300 	ldrd	r2, r3, [r3]
340121a0:	2100      	movs	r1, #0
340121a2:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
340121a6:	f003 0304 	and.w	r3, r3, #4
340121aa:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
340121ae:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
340121b2:	4603      	mov	r3, r0
340121b4:	460a      	mov	r2, r1
340121b6:	4313      	orrs	r3, r2
340121b8:	d04b      	beq.n	34012252 <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
340121ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340121be:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
340121c2:	4b9c      	ldr	r3, [pc, #624]	@ (34012434 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
340121c4:	429a      	cmp	r2, r3
340121c6:	d116      	bne.n	340121f6 <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340121c8:	4b97      	ldr	r3, [pc, #604]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340121ca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340121ce:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340121d2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340121d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340121da:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340121dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340121e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340121e2:	3b01      	subs	r3, #1
340121e4:	041b      	lsls	r3, r3, #16
340121e6:	4313      	orrs	r3, r2
340121e8:	4a8f      	ldr	r2, [pc, #572]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340121ea:	430b      	orrs	r3, r1
340121ec:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340121f0:	f7fe f89c 	bl	3401032c <LL_RCC_IC8_Enable>
340121f4:	e026      	b.n	34012244 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
340121f6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340121fa:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
340121fe:	4b8e      	ldr	r3, [pc, #568]	@ (34012438 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34012200:	429a      	cmp	r2, r3
34012202:	d116      	bne.n	34012232 <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012204:	4b88      	ldr	r3, [pc, #544]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012206:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401220a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401220e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012212:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012216:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012218:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401221c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401221e:	3b01      	subs	r3, #1
34012220:	041b      	lsls	r3, r3, #16
34012222:	4313      	orrs	r3, r2
34012224:	4a80      	ldr	r2, [pc, #512]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012226:	430b      	orrs	r3, r1
34012228:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401222c:	f7fe f8be 	bl	340103ac <LL_RCC_IC9_Enable>
34012230:	e008      	b.n	34012244 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
34012232:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012236:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
3401223a:	4b80      	ldr	r3, [pc, #512]	@ (3401243c <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
3401223c:	429a      	cmp	r2, r3
3401223e:	d101      	bne.n	34012244 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
34012240:	f7fe fb74 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
34012244:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012248:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
3401224c:	4618      	mov	r0, r3
3401224e:	f7fd fb05 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34012252:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012256:	e9d3 2300 	ldrd	r2, r3, [r3]
3401225a:	2100      	movs	r1, #0
3401225c:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
34012260:	f003 0308 	and.w	r3, r3, #8
34012264:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34012268:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
3401226c:	4603      	mov	r3, r0
3401226e:	460a      	mov	r2, r1
34012270:	4313      	orrs	r3, r2
34012272:	d04b      	beq.n	3401230c <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
34012274:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012278:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3401227c:	4b70      	ldr	r3, [pc, #448]	@ (34012440 <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
3401227e:	429a      	cmp	r2, r3
34012280:	d116      	bne.n	340122b0 <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34012282:	4b69      	ldr	r3, [pc, #420]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012284:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34012288:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401228c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012290:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012294:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34012296:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401229a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401229c:	3b01      	subs	r3, #1
3401229e:	041b      	lsls	r3, r3, #16
340122a0:	4313      	orrs	r3, r2
340122a2:	4a61      	ldr	r2, [pc, #388]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340122a4:	430b      	orrs	r3, r1
340122a6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
340122aa:	f7fe f83f 	bl	3401032c <LL_RCC_IC8_Enable>
340122ae:	e026      	b.n	340122fe <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
340122b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340122b4:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340122b8:	4b62      	ldr	r3, [pc, #392]	@ (34012444 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
340122ba:	429a      	cmp	r2, r3
340122bc:	d116      	bne.n	340122ec <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340122be:	4b5a      	ldr	r3, [pc, #360]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340122c0:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340122c4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340122c8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340122cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340122d0:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340122d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340122d6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340122d8:	3b01      	subs	r3, #1
340122da:	041b      	lsls	r3, r3, #16
340122dc:	4313      	orrs	r3, r2
340122de:	4a52      	ldr	r2, [pc, #328]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340122e0:	430b      	orrs	r3, r1
340122e2:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340122e6:	f7fe f861 	bl	340103ac <LL_RCC_IC9_Enable>
340122ea:	e008      	b.n	340122fe <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
340122ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340122f0:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
340122f4:	4b54      	ldr	r3, [pc, #336]	@ (34012448 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
340122f6:	429a      	cmp	r2, r3
340122f8:	d101      	bne.n	340122fe <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
340122fa:	f7fe fb17 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
340122fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012302:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
34012306:	4618      	mov	r0, r3
34012308:	f7fd faa8 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3401230c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012310:	e9d3 2300 	ldrd	r2, r3, [r3]
34012314:	2100      	movs	r1, #0
34012316:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3401231a:	f003 0310 	and.w	r3, r3, #16
3401231e:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
34012322:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
34012326:	4603      	mov	r3, r0
34012328:	460a      	mov	r2, r1
3401232a:	4313      	orrs	r3, r2
3401232c:	d04b      	beq.n	340123c6 <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3401232e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012332:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34012336:	4b45      	ldr	r3, [pc, #276]	@ (3401244c <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
34012338:	429a      	cmp	r2, r3
3401233a:	d116      	bne.n	3401236a <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401233c:	4b3a      	ldr	r3, [pc, #232]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401233e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012342:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012346:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401234a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401234e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012350:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012354:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012356:	3b01      	subs	r3, #1
34012358:	041b      	lsls	r3, r3, #16
3401235a:	4313      	orrs	r3, r2
3401235c:	4a32      	ldr	r2, [pc, #200]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401235e:	430b      	orrs	r3, r1
34012360:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012364:	f7fe f822 	bl	340103ac <LL_RCC_IC9_Enable>
34012368:	e026      	b.n	340123b8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3401236a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401236e:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
34012372:	4b37      	ldr	r3, [pc, #220]	@ (34012450 <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
34012374:	429a      	cmp	r2, r3
34012376:	d116      	bne.n	340123a6 <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012378:	4b2b      	ldr	r3, [pc, #172]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401237a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401237e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012382:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012386:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401238a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401238c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012390:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012392:	3b01      	subs	r3, #1
34012394:	041b      	lsls	r3, r3, #16
34012396:	4313      	orrs	r3, r2
34012398:	4a23      	ldr	r2, [pc, #140]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3401239a:	430b      	orrs	r3, r1
3401239c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340123a0:	f7fe f904 	bl	340105ac <LL_RCC_IC14_Enable>
340123a4:	e008      	b.n	340123b8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
340123a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340123aa:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
340123ae:	4b29      	ldr	r3, [pc, #164]	@ (34012454 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
340123b0:	429a      	cmp	r2, r3
340123b2:	d101      	bne.n	340123b8 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
340123b4:	f7fe faba 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
340123b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340123bc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
340123c0:	4618      	mov	r0, r3
340123c2:	f7fd fa4b 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
340123c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340123ca:	e9d3 2300 	ldrd	r2, r3, [r3]
340123ce:	2100      	movs	r1, #0
340123d0:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
340123d4:	f003 0320 	and.w	r3, r3, #32
340123d8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
340123dc:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
340123e0:	4603      	mov	r3, r0
340123e2:	460a      	mov	r2, r1
340123e4:	4313      	orrs	r3, r2
340123e6:	d067      	beq.n	340124b8 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
340123e8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340123ec:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340123f0:	4b19      	ldr	r3, [pc, #100]	@ (34012458 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
340123f2:	429a      	cmp	r2, r3
340123f4:	d132      	bne.n	3401245c <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340123f6:	4b0c      	ldr	r3, [pc, #48]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
340123f8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340123fc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012400:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012404:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012408:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401240a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401240e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012410:	3b01      	subs	r3, #1
34012412:	041b      	lsls	r3, r3, #16
34012414:	4313      	orrs	r3, r2
34012416:	4a04      	ldr	r2, [pc, #16]	@ (34012428 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34012418:	430b      	orrs	r3, r1
3401241a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401241e:	f7fd ffc5 	bl	340103ac <LL_RCC_IC9_Enable>
34012422:	e042      	b.n	340124aa <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
34012424:	07020420 	.word	0x07020420
34012428:	56028000 	.word	0x56028000
3401242c:	07030420 	.word	0x07030420
34012430:	07010420 	.word	0x07010420
34012434:	07020820 	.word	0x07020820
34012438:	07030820 	.word	0x07030820
3401243c:	07010820 	.word	0x07010820
34012440:	07020c20 	.word	0x07020c20
34012444:	07030c20 	.word	0x07030c20
34012448:	07010c20 	.word	0x07010c20
3401244c:	07021020 	.word	0x07021020
34012450:	07031020 	.word	0x07031020
34012454:	07011020 	.word	0x07011020
34012458:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3401245c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012460:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
34012464:	4bc2      	ldr	r3, [pc, #776]	@ (34012770 <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
34012466:	429a      	cmp	r2, r3
34012468:	d116      	bne.n	34012498 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3401246a:	4bc2      	ldr	r3, [pc, #776]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3401246c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012470:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012474:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012478:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401247c:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3401247e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012482:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012484:	3b01      	subs	r3, #1
34012486:	041b      	lsls	r3, r3, #16
34012488:	4313      	orrs	r3, r2
3401248a:	4aba      	ldr	r2, [pc, #744]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3401248c:	430b      	orrs	r3, r1
3401248e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012492:	f7fe f88b 	bl	340105ac <LL_RCC_IC14_Enable>
34012496:	e008      	b.n	340124aa <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
34012498:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401249c:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
340124a0:	4bb5      	ldr	r3, [pc, #724]	@ (34012778 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
340124a2:	429a      	cmp	r2, r3
340124a4:	d101      	bne.n	340124aa <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
340124a6:	f7fe fa41 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
340124aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340124ae:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
340124b2:	4618      	mov	r0, r3
340124b4:	f7fd f9d2 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
340124b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340124bc:	e9d3 2300 	ldrd	r2, r3, [r3]
340124c0:	2100      	movs	r1, #0
340124c2:	67b9      	str	r1, [r7, #120]	@ 0x78
340124c4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340124c8:	67fb      	str	r3, [r7, #124]	@ 0x7c
340124ca:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
340124ce:	4603      	mov	r3, r0
340124d0:	460a      	mov	r2, r1
340124d2:	4313      	orrs	r3, r2
340124d4:	d04b      	beq.n	3401256e <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
340124d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340124da:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
340124de:	4ba7      	ldr	r3, [pc, #668]	@ (3401277c <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
340124e0:	429a      	cmp	r2, r3
340124e2:	d116      	bne.n	34012512 <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
340124e4:	4ba3      	ldr	r3, [pc, #652]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340124e6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340124ea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340124ee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340124f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340124f6:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
340124f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340124fc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340124fe:	3b01      	subs	r3, #1
34012500:	041b      	lsls	r3, r3, #16
34012502:	4313      	orrs	r3, r2
34012504:	4a9b      	ldr	r2, [pc, #620]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012506:	430b      	orrs	r3, r1
34012508:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3401250c:	f7fd ff0e 	bl	3401032c <LL_RCC_IC8_Enable>
34012510:	e026      	b.n	34012560 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
34012512:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012516:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3401251a:	4b99      	ldr	r3, [pc, #612]	@ (34012780 <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
3401251c:	429a      	cmp	r2, r3
3401251e:	d116      	bne.n	3401254e <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012520:	4b94      	ldr	r3, [pc, #592]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012522:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012526:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401252a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401252e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012532:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012534:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012538:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401253a:	3b01      	subs	r3, #1
3401253c:	041b      	lsls	r3, r3, #16
3401253e:	4313      	orrs	r3, r2
34012540:	4a8c      	ldr	r2, [pc, #560]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012542:	430b      	orrs	r3, r1
34012544:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012548:	f7fd ff30 	bl	340103ac <LL_RCC_IC9_Enable>
3401254c:	e008      	b.n	34012560 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3401254e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012552:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
34012556:	4b8b      	ldr	r3, [pc, #556]	@ (34012784 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
34012558:	429a      	cmp	r2, r3
3401255a:	d101      	bne.n	34012560 <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
3401255c:	f7fe f9e6 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
34012560:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012564:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34012568:	4618      	mov	r0, r3
3401256a:	f7fd f977 	bl	3400f85c <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3401256e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012572:	e9d3 2300 	ldrd	r2, r3, [r3]
34012576:	2100      	movs	r1, #0
34012578:	6739      	str	r1, [r7, #112]	@ 0x70
3401257a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3401257e:	677b      	str	r3, [r7, #116]	@ 0x74
34012580:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
34012584:	4603      	mov	r3, r0
34012586:	460a      	mov	r2, r1
34012588:	4313      	orrs	r3, r2
3401258a:	d04b      	beq.n	34012624 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3401258c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012590:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
34012594:	4b7c      	ldr	r3, [pc, #496]	@ (34012788 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
34012596:	429a      	cmp	r2, r3
34012598:	d116      	bne.n	340125c8 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3401259a:	4b76      	ldr	r3, [pc, #472]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3401259c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340125a0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340125a4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340125a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340125ac:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340125ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340125b2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340125b4:	3b01      	subs	r3, #1
340125b6:	041b      	lsls	r3, r3, #16
340125b8:	4313      	orrs	r3, r2
340125ba:	4a6e      	ldr	r2, [pc, #440]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340125bc:	430b      	orrs	r3, r1
340125be:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340125c2:	f7fd fef3 	bl	340103ac <LL_RCC_IC9_Enable>
340125c6:	e026      	b.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
340125c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340125cc:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
340125d0:	4b6e      	ldr	r3, [pc, #440]	@ (3401278c <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
340125d2:	429a      	cmp	r2, r3
340125d4:	d116      	bne.n	34012604 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340125d6:	4b67      	ldr	r3, [pc, #412]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340125d8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340125dc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340125e0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340125e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340125e8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340125ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340125ee:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340125f0:	3b01      	subs	r3, #1
340125f2:	041b      	lsls	r3, r3, #16
340125f4:	4313      	orrs	r3, r2
340125f6:	4a5f      	ldr	r2, [pc, #380]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340125f8:	430b      	orrs	r3, r1
340125fa:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340125fe:	f7fd ffd5 	bl	340105ac <LL_RCC_IC14_Enable>
34012602:	e008      	b.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
34012604:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012608:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3401260c:	4b60      	ldr	r3, [pc, #384]	@ (34012790 <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
3401260e:	429a      	cmp	r2, r3
34012610:	d101      	bne.n	34012616 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
34012612:	f7fe f98b 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
34012616:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401261a:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3401261e:	4618      	mov	r0, r3
34012620:	f7fd f927 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
34012624:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012628:	e9d3 2300 	ldrd	r2, r3, [r3]
3401262c:	2100      	movs	r1, #0
3401262e:	66b9      	str	r1, [r7, #104]	@ 0x68
34012630:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34012634:	66fb      	str	r3, [r7, #108]	@ 0x6c
34012636:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
3401263a:	4603      	mov	r3, r0
3401263c:	460a      	mov	r2, r1
3401263e:	4313      	orrs	r3, r2
34012640:	d04b      	beq.n	340126da <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
34012642:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012646:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3401264a:	4b52      	ldr	r3, [pc, #328]	@ (34012794 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
3401264c:	429a      	cmp	r2, r3
3401264e:	d116      	bne.n	3401267e <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012650:	4b48      	ldr	r3, [pc, #288]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012652:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012656:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401265a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401265e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012662:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012664:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012668:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401266a:	3b01      	subs	r3, #1
3401266c:	041b      	lsls	r3, r3, #16
3401266e:	4313      	orrs	r3, r2
34012670:	4a40      	ldr	r2, [pc, #256]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012672:	430b      	orrs	r3, r1
34012674:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012678:	f7fd fe98 	bl	340103ac <LL_RCC_IC9_Enable>
3401267c:	e026      	b.n	340126cc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3401267e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012682:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
34012686:	4b44      	ldr	r3, [pc, #272]	@ (34012798 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
34012688:	429a      	cmp	r2, r3
3401268a:	d116      	bne.n	340126ba <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3401268c:	4b39      	ldr	r3, [pc, #228]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3401268e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012692:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012696:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401269a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401269e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340126a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340126a4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340126a6:	3b01      	subs	r3, #1
340126a8:	041b      	lsls	r3, r3, #16
340126aa:	4313      	orrs	r3, r2
340126ac:	4a31      	ldr	r2, [pc, #196]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
340126ae:	430b      	orrs	r3, r1
340126b0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340126b4:	f7fd ff7a 	bl	340105ac <LL_RCC_IC14_Enable>
340126b8:	e008      	b.n	340126cc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
340126ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340126be:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
340126c2:	4b36      	ldr	r3, [pc, #216]	@ (3401279c <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
340126c4:	429a      	cmp	r2, r3
340126c6:	d101      	bne.n	340126cc <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
340126c8:	f7fe f930 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
340126cc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340126d0:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
340126d4:	4618      	mov	r0, r3
340126d6:	f7fd f8cc 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
340126da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340126de:	e9d3 2300 	ldrd	r2, r3, [r3]
340126e2:	2100      	movs	r1, #0
340126e4:	6639      	str	r1, [r7, #96]	@ 0x60
340126e6:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
340126ea:	667b      	str	r3, [r7, #100]	@ 0x64
340126ec:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
340126f0:	4603      	mov	r3, r0
340126f2:	460a      	mov	r2, r1
340126f4:	4313      	orrs	r3, r2
340126f6:	d067      	beq.n	340127c8 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
340126f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340126fc:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
34012700:	4b27      	ldr	r3, [pc, #156]	@ (340127a0 <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
34012702:	429a      	cmp	r2, r3
34012704:	d116      	bne.n	34012734 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012706:	4b1b      	ldr	r3, [pc, #108]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012708:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3401270c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012710:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012714:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012718:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3401271a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401271e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012720:	3b01      	subs	r3, #1
34012722:	041b      	lsls	r3, r3, #16
34012724:	4313      	orrs	r3, r2
34012726:	4a13      	ldr	r2, [pc, #76]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012728:	430b      	orrs	r3, r1
3401272a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401272e:	f7fd fe3d 	bl	340103ac <LL_RCC_IC9_Enable>
34012732:	e042      	b.n	340127ba <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
34012734:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012738:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3401273c:	4b19      	ldr	r3, [pc, #100]	@ (340127a4 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
3401273e:	429a      	cmp	r2, r3
34012740:	d132      	bne.n	340127a8 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012742:	4b0c      	ldr	r3, [pc, #48]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012744:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012748:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401274c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012750:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012754:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012756:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401275a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401275c:	3b01      	subs	r3, #1
3401275e:	041b      	lsls	r3, r3, #16
34012760:	4313      	orrs	r3, r2
34012762:	4a04      	ldr	r2, [pc, #16]	@ (34012774 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
34012764:	430b      	orrs	r3, r1
34012766:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401276a:	f7fd ff1f 	bl	340105ac <LL_RCC_IC14_Enable>
3401276e:	e024      	b.n	340127ba <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
34012770:	07031420 	.word	0x07031420
34012774:	56028000 	.word	0x56028000
34012778:	07011420 	.word	0x07011420
3401277c:	07021820 	.word	0x07021820
34012780:	07031820 	.word	0x07031820
34012784:	07011820 	.word	0x07011820
34012788:	07020030 	.word	0x07020030
3401278c:	07030030 	.word	0x07030030
34012790:	07010030 	.word	0x07010030
34012794:	07020430 	.word	0x07020430
34012798:	07030430 	.word	0x07030430
3401279c:	07010430 	.word	0x07010430
340127a0:	07020830 	.word	0x07020830
340127a4:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
340127a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340127ac:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
340127b0:	4bb3      	ldr	r3, [pc, #716]	@ (34012a80 <HAL_RCCEx_PeriphCLKConfig+0x2110>)
340127b2:	429a      	cmp	r2, r3
340127b4:	d101      	bne.n	340127ba <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
340127b6:	f7fe f8b9 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
340127ba:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340127be:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
340127c2:	4618      	mov	r0, r3
340127c4:	f7fd f855 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
340127c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340127cc:	e9d3 2300 	ldrd	r2, r3, [r3]
340127d0:	2100      	movs	r1, #0
340127d2:	65b9      	str	r1, [r7, #88]	@ 0x58
340127d4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
340127d8:	65fb      	str	r3, [r7, #92]	@ 0x5c
340127da:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
340127de:	4603      	mov	r3, r0
340127e0:	460a      	mov	r2, r1
340127e2:	4313      	orrs	r3, r2
340127e4:	d04b      	beq.n	3401287e <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
340127e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340127ea:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
340127ee:	4ba5      	ldr	r3, [pc, #660]	@ (34012a84 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
340127f0:	429a      	cmp	r2, r3
340127f2:	d116      	bne.n	34012822 <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340127f4:	4ba4      	ldr	r3, [pc, #656]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340127f6:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340127fa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340127fe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012802:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012806:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012808:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401280c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401280e:	3b01      	subs	r3, #1
34012810:	041b      	lsls	r3, r3, #16
34012812:	4313      	orrs	r3, r2
34012814:	4a9c      	ldr	r2, [pc, #624]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012816:	430b      	orrs	r3, r1
34012818:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3401281c:	f7fd fdc6 	bl	340103ac <LL_RCC_IC9_Enable>
34012820:	e026      	b.n	34012870 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
34012822:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012826:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3401282a:	4b98      	ldr	r3, [pc, #608]	@ (34012a8c <HAL_RCCEx_PeriphCLKConfig+0x211c>)
3401282c:	429a      	cmp	r2, r3
3401282e:	d116      	bne.n	3401285e <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012830:	4b95      	ldr	r3, [pc, #596]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012832:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012836:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401283a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401283e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012842:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012844:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012848:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3401284a:	3b01      	subs	r3, #1
3401284c:	041b      	lsls	r3, r3, #16
3401284e:	4313      	orrs	r3, r2
34012850:	4a8d      	ldr	r2, [pc, #564]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012852:	430b      	orrs	r3, r1
34012854:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012858:	f7fd fea8 	bl	340105ac <LL_RCC_IC14_Enable>
3401285c:	e008      	b.n	34012870 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3401285e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012862:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
34012866:	4b8a      	ldr	r3, [pc, #552]	@ (34012a90 <HAL_RCCEx_PeriphCLKConfig+0x2120>)
34012868:	429a      	cmp	r2, r3
3401286a:	d101      	bne.n	34012870 <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
3401286c:	f7fe f85e 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
34012870:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012874:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34012878:	4618      	mov	r0, r3
3401287a:	f7fc fffa 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3401287e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012882:	e9d3 2300 	ldrd	r2, r3, [r3]
34012886:	2100      	movs	r1, #0
34012888:	6539      	str	r1, [r7, #80]	@ 0x50
3401288a:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3401288e:	657b      	str	r3, [r7, #84]	@ 0x54
34012890:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
34012894:	4603      	mov	r3, r0
34012896:	460a      	mov	r2, r1
34012898:	4313      	orrs	r3, r2
3401289a:	d04b      	beq.n	34012934 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3401289c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128a0:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340128a4:	4b7b      	ldr	r3, [pc, #492]	@ (34012a94 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
340128a6:	429a      	cmp	r2, r3
340128a8:	d116      	bne.n	340128d8 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340128aa:	4b77      	ldr	r3, [pc, #476]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340128ac:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340128b0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340128b4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340128b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128bc:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340128be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128c2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340128c4:	3b01      	subs	r3, #1
340128c6:	041b      	lsls	r3, r3, #16
340128c8:	4313      	orrs	r3, r2
340128ca:	4a6f      	ldr	r2, [pc, #444]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340128cc:	430b      	orrs	r3, r1
340128ce:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340128d2:	f7fd fd6b 	bl	340103ac <LL_RCC_IC9_Enable>
340128d6:	e026      	b.n	34012926 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
340128d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128dc:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
340128e0:	4b6d      	ldr	r3, [pc, #436]	@ (34012a98 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
340128e2:	429a      	cmp	r2, r3
340128e4:	d116      	bne.n	34012914 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
340128e6:	4b68      	ldr	r3, [pc, #416]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340128e8:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340128ec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340128f0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340128f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128f8:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340128fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340128fe:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012900:	3b01      	subs	r3, #1
34012902:	041b      	lsls	r3, r3, #16
34012904:	4313      	orrs	r3, r2
34012906:	4a60      	ldr	r2, [pc, #384]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012908:	430b      	orrs	r3, r1
3401290a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3401290e:	f7fd fe4d 	bl	340105ac <LL_RCC_IC14_Enable>
34012912:	e008      	b.n	34012926 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
34012914:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012918:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3401291c:	4b5f      	ldr	r3, [pc, #380]	@ (34012a9c <HAL_RCCEx_PeriphCLKConfig+0x212c>)
3401291e:	429a      	cmp	r2, r3
34012920:	d101      	bne.n	34012926 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
34012922:	f7fe f803 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
34012926:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3401292a:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3401292e:	4618      	mov	r0, r3
34012930:	f7fc ff9f 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
34012934:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012938:	e9d3 2300 	ldrd	r2, r3, [r3]
3401293c:	2100      	movs	r1, #0
3401293e:	64b9      	str	r1, [r7, #72]	@ 0x48
34012940:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
34012944:	64fb      	str	r3, [r7, #76]	@ 0x4c
34012946:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3401294a:	4603      	mov	r3, r0
3401294c:	460a      	mov	r2, r1
3401294e:	4313      	orrs	r3, r2
34012950:	d04b      	beq.n	340129ea <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
34012952:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012956:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3401295a:	4b51      	ldr	r3, [pc, #324]	@ (34012aa0 <HAL_RCCEx_PeriphCLKConfig+0x2130>)
3401295c:	429a      	cmp	r2, r3
3401295e:	d116      	bne.n	3401298e <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012960:	4b49      	ldr	r3, [pc, #292]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012962:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012966:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3401296a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3401296e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012972:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012974:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012978:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401297a:	3b01      	subs	r3, #1
3401297c:	041b      	lsls	r3, r3, #16
3401297e:	4313      	orrs	r3, r2
34012980:	4a41      	ldr	r2, [pc, #260]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012982:	430b      	orrs	r3, r1
34012984:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012988:	f7fd fd10 	bl	340103ac <LL_RCC_IC9_Enable>
3401298c:	e026      	b.n	340129dc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3401298e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012992:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
34012996:	4b43      	ldr	r3, [pc, #268]	@ (34012aa4 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
34012998:	429a      	cmp	r2, r3
3401299a:	d116      	bne.n	340129ca <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3401299c:	4b3a      	ldr	r3, [pc, #232]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3401299e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
340129a2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340129a6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340129aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340129ae:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
340129b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340129b4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340129b6:	3b01      	subs	r3, #1
340129b8:	041b      	lsls	r3, r3, #16
340129ba:	4313      	orrs	r3, r2
340129bc:	4a32      	ldr	r2, [pc, #200]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
340129be:	430b      	orrs	r3, r1
340129c0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
340129c4:	f7fd fdf2 	bl	340105ac <LL_RCC_IC14_Enable>
340129c8:	e008      	b.n	340129dc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
340129ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340129ce:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
340129d2:	4b35      	ldr	r3, [pc, #212]	@ (34012aa8 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
340129d4:	429a      	cmp	r2, r3
340129d6:	d101      	bne.n	340129dc <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
340129d8:	f7fd ffa8 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
340129dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340129e0:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
340129e4:	4618      	mov	r0, r3
340129e6:	f7fc ff44 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
340129ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340129ee:	e9d3 2300 	ldrd	r2, r3, [r3]
340129f2:	2100      	movs	r1, #0
340129f4:	6439      	str	r1, [r7, #64]	@ 0x40
340129f6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
340129fa:	647b      	str	r3, [r7, #68]	@ 0x44
340129fc:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34012a00:	4603      	mov	r3, r0
34012a02:	460a      	mov	r2, r1
34012a04:	4313      	orrs	r3, r2
34012a06:	d065      	beq.n	34012ad4 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
34012a08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a0c:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34012a10:	4b26      	ldr	r3, [pc, #152]	@ (34012aac <HAL_RCCEx_PeriphCLKConfig+0x213c>)
34012a12:	429a      	cmp	r2, r3
34012a14:	d116      	bne.n	34012a44 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012a16:	4b1c      	ldr	r3, [pc, #112]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012a18:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012a1c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012a20:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012a24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a28:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012a2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a2e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012a30:	3b01      	subs	r3, #1
34012a32:	041b      	lsls	r3, r3, #16
34012a34:	4313      	orrs	r3, r2
34012a36:	4a14      	ldr	r2, [pc, #80]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012a38:	430b      	orrs	r3, r1
34012a3a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012a3e:	f7fd fcb5 	bl	340103ac <LL_RCC_IC9_Enable>
34012a42:	e040      	b.n	34012ac6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
34012a44:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a48:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34012a4c:	4b18      	ldr	r3, [pc, #96]	@ (34012ab0 <HAL_RCCEx_PeriphCLKConfig+0x2140>)
34012a4e:	429a      	cmp	r2, r3
34012a50:	d130      	bne.n	34012ab4 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012a52:	4b0d      	ldr	r3, [pc, #52]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012a54:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012a58:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012a5c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012a60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a64:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012a66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012a6a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012a6c:	3b01      	subs	r3, #1
34012a6e:	041b      	lsls	r3, r3, #16
34012a70:	4313      	orrs	r3, r2
34012a72:	4a05      	ldr	r2, [pc, #20]	@ (34012a88 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
34012a74:	430b      	orrs	r3, r1
34012a76:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012a7a:	f7fd fd97 	bl	340105ac <LL_RCC_IC14_Enable>
34012a7e:	e022      	b.n	34012ac6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
34012a80:	07010830 	.word	0x07010830
34012a84:	07020c30 	.word	0x07020c30
34012a88:	56028000 	.word	0x56028000
34012a8c:	07030c30 	.word	0x07030c30
34012a90:	07010c30 	.word	0x07010c30
34012a94:	07021030 	.word	0x07021030
34012a98:	07031030 	.word	0x07031030
34012a9c:	07011030 	.word	0x07011030
34012aa0:	07021430 	.word	0x07021430
34012aa4:	07031430 	.word	0x07031430
34012aa8:	07011430 	.word	0x07011430
34012aac:	07021830 	.word	0x07021830
34012ab0:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
34012ab4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012ab8:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
34012abc:	4bc8      	ldr	r3, [pc, #800]	@ (34012de0 <HAL_RCCEx_PeriphCLKConfig+0x2470>)
34012abe:	429a      	cmp	r2, r3
34012ac0:	d101      	bne.n	34012ac6 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
34012ac2:	f7fd ff33 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
34012ac6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012aca:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
34012ace:	4618      	mov	r0, r3
34012ad0:	f7fc fecf 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
34012ad4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012ad8:	e9d3 2300 	ldrd	r2, r3, [r3]
34012adc:	2100      	movs	r1, #0
34012ade:	63b9      	str	r1, [r7, #56]	@ 0x38
34012ae0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
34012ae4:	63fb      	str	r3, [r7, #60]	@ 0x3c
34012ae6:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
34012aea:	4603      	mov	r3, r0
34012aec:	460a      	mov	r2, r1
34012aee:	4313      	orrs	r3, r2
34012af0:	d04b      	beq.n	34012b8a <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
34012af2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012af6:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34012afa:	4bba      	ldr	r3, [pc, #744]	@ (34012de4 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
34012afc:	429a      	cmp	r2, r3
34012afe:	d116      	bne.n	34012b2e <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012b00:	4bb9      	ldr	r3, [pc, #740]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012b02:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012b06:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012b0a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012b0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b12:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012b14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b18:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012b1a:	3b01      	subs	r3, #1
34012b1c:	041b      	lsls	r3, r3, #16
34012b1e:	4313      	orrs	r3, r2
34012b20:	4ab1      	ldr	r2, [pc, #708]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012b22:	430b      	orrs	r3, r1
34012b24:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012b28:	f7fd fc40 	bl	340103ac <LL_RCC_IC9_Enable>
34012b2c:	e026      	b.n	34012b7c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
34012b2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b32:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34012b36:	4bad      	ldr	r3, [pc, #692]	@ (34012dec <HAL_RCCEx_PeriphCLKConfig+0x247c>)
34012b38:	429a      	cmp	r2, r3
34012b3a:	d116      	bne.n	34012b6a <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012b3c:	4baa      	ldr	r3, [pc, #680]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012b3e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012b42:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012b46:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012b4a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b4e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012b50:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b54:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012b56:	3b01      	subs	r3, #1
34012b58:	041b      	lsls	r3, r3, #16
34012b5a:	4313      	orrs	r3, r2
34012b5c:	4aa2      	ldr	r2, [pc, #648]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012b5e:	430b      	orrs	r3, r1
34012b60:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012b64:	f7fd fd22 	bl	340105ac <LL_RCC_IC14_Enable>
34012b68:	e008      	b.n	34012b7c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
34012b6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b6e:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
34012b72:	4b9f      	ldr	r3, [pc, #636]	@ (34012df0 <HAL_RCCEx_PeriphCLKConfig+0x2480>)
34012b74:	429a      	cmp	r2, r3
34012b76:	d101      	bne.n	34012b7c <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
34012b78:	f7fd fed8 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
34012b7c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b80:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
34012b84:	4618      	mov	r0, r3
34012b86:	f7fc fe74 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
34012b8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012b8e:	e9d3 2300 	ldrd	r2, r3, [r3]
34012b92:	2100      	movs	r1, #0
34012b94:	6339      	str	r1, [r7, #48]	@ 0x30
34012b96:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34012b9a:	637b      	str	r3, [r7, #52]	@ 0x34
34012b9c:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34012ba0:	4603      	mov	r3, r0
34012ba2:	460a      	mov	r2, r1
34012ba4:	4313      	orrs	r3, r2
34012ba6:	d04b      	beq.n	34012c40 <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
34012ba8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012bac:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34012bb0:	4a90      	ldr	r2, [pc, #576]	@ (34012df4 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
34012bb2:	4293      	cmp	r3, r2
34012bb4:	d116      	bne.n	34012be4 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012bb6:	4b8c      	ldr	r3, [pc, #560]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012bb8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012bbc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012bc0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012bc4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012bc8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34012bca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012bce:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34012bd0:	3b01      	subs	r3, #1
34012bd2:	041b      	lsls	r3, r3, #16
34012bd4:	4313      	orrs	r3, r2
34012bd6:	4a84      	ldr	r2, [pc, #528]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012bd8:	430b      	orrs	r3, r1
34012bda:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012bde:	f7fd fbe5 	bl	340103ac <LL_RCC_IC9_Enable>
34012be2:	e026      	b.n	34012c32 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
34012be4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012be8:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34012bec:	4a82      	ldr	r2, [pc, #520]	@ (34012df8 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
34012bee:	4293      	cmp	r3, r2
34012bf0:	d116      	bne.n	34012c20 <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012bf2:	4b7d      	ldr	r3, [pc, #500]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012bf4:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012bf8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34012bfc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34012c00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c04:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34012c06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c0a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34012c0c:	3b01      	subs	r3, #1
34012c0e:	041b      	lsls	r3, r3, #16
34012c10:	4313      	orrs	r3, r2
34012c12:	4a75      	ldr	r2, [pc, #468]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012c14:	430b      	orrs	r3, r1
34012c16:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012c1a:	f7fd fcc7 	bl	340105ac <LL_RCC_IC14_Enable>
34012c1e:	e008      	b.n	34012c32 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
34012c20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c24:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34012c28:	4a74      	ldr	r2, [pc, #464]	@ (34012dfc <HAL_RCCEx_PeriphCLKConfig+0x248c>)
34012c2a:	4293      	cmp	r3, r2
34012c2c:	d101      	bne.n	34012c32 <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
34012c2e:	f7fd fe7d 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
34012c32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c36:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
34012c3a:	4618      	mov	r0, r3
34012c3c:	f7fc fe19 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
34012c40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c44:	e9d3 2300 	ldrd	r2, r3, [r3]
34012c48:	2100      	movs	r1, #0
34012c4a:	62b9      	str	r1, [r7, #40]	@ 0x28
34012c4c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34012c50:	62fb      	str	r3, [r7, #44]	@ 0x2c
34012c52:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
34012c56:	4603      	mov	r3, r0
34012c58:	460a      	mov	r2, r1
34012c5a:	4313      	orrs	r3, r2
34012c5c:	d04b      	beq.n	34012cf6 <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
34012c5e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c62:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34012c66:	4a66      	ldr	r2, [pc, #408]	@ (34012e00 <HAL_RCCEx_PeriphCLKConfig+0x2490>)
34012c68:	4293      	cmp	r3, r2
34012c6a:	d116      	bne.n	34012c9a <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34012c6c:	4b5e      	ldr	r3, [pc, #376]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012c6e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34012c72:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34012c76:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34012c7a:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012c7e:	6c91      	ldr	r1, [r2, #72]	@ 0x48
34012c80:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012c84:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
34012c86:	3a01      	subs	r2, #1
34012c88:	0412      	lsls	r2, r2, #16
34012c8a:	430a      	orrs	r2, r1
34012c8c:	4956      	ldr	r1, [pc, #344]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012c8e:	4313      	orrs	r3, r2
34012c90:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34012c94:	f7fd fb8a 	bl	340103ac <LL_RCC_IC9_Enable>
34012c98:	e026      	b.n	34012ce8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
34012c9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012c9e:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34012ca2:	4a58      	ldr	r2, [pc, #352]	@ (34012e04 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
34012ca4:	4293      	cmp	r3, r2
34012ca6:	d116      	bne.n	34012cd6 <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34012ca8:	4b4f      	ldr	r3, [pc, #316]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012caa:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34012cae:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34012cb2:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34012cb6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012cba:	6f11      	ldr	r1, [r2, #112]	@ 0x70
34012cbc:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012cc0:	6f52      	ldr	r2, [r2, #116]	@ 0x74
34012cc2:	3a01      	subs	r2, #1
34012cc4:	0412      	lsls	r2, r2, #16
34012cc6:	430a      	orrs	r2, r1
34012cc8:	4947      	ldr	r1, [pc, #284]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012cca:	4313      	orrs	r3, r2
34012ccc:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34012cd0:	f7fd fc6c 	bl	340105ac <LL_RCC_IC14_Enable>
34012cd4:	e008      	b.n	34012ce8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
34012cd6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012cda:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34012cde:	4a4a      	ldr	r2, [pc, #296]	@ (34012e08 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
34012ce0:	4293      	cmp	r3, r2
34012ce2:	d101      	bne.n	34012ce8 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
34012ce4:	f7fd fe22 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
34012ce8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012cec:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
34012cf0:	4618      	mov	r0, r3
34012cf2:	f7fc fdbe 	bl	3400f872 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
34012cf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012cfa:	e9d3 2300 	ldrd	r2, r3, [r3]
34012cfe:	2100      	movs	r1, #0
34012d00:	6239      	str	r1, [r7, #32]
34012d02:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34012d06:	627b      	str	r3, [r7, #36]	@ 0x24
34012d08:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34012d0c:	4603      	mov	r3, r0
34012d0e:	460a      	mov	r2, r1
34012d10:	4313      	orrs	r3, r2
34012d12:	d014      	beq.n	34012d3e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
34012d14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d18:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34012d1c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34012d20:	4618      	mov	r0, r3
34012d22:	f7fc fd4e 	bl	3400f7c2 <LL_RCC_SetOTGPHYCKREFClockSource>
34012d26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d2a:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34012d2e:	0fdb      	lsrs	r3, r3, #31
34012d30:	2b01      	cmp	r3, #1
34012d32:	d102      	bne.n	34012d3a <HAL_RCCEx_PeriphCLKConfig+0x23ca>
34012d34:	f7fc faf0 	bl	3400f318 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34012d38:	e001      	b.n	34012d3e <HAL_RCCEx_PeriphCLKConfig+0x23ce>
34012d3a:	f7fc fadd 	bl	3400f2f8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
34012d3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d42:	e9d3 2300 	ldrd	r2, r3, [r3]
34012d46:	2100      	movs	r1, #0
34012d48:	61b9      	str	r1, [r7, #24]
34012d4a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34012d4e:	61fb      	str	r3, [r7, #28]
34012d50:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34012d54:	4603      	mov	r3, r0
34012d56:	460a      	mov	r2, r1
34012d58:	4313      	orrs	r3, r2
34012d5a:	d014      	beq.n	34012d86 <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
34012d5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d60:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34012d64:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34012d68:	4618      	mov	r0, r3
34012d6a:	f7fc fd2a 	bl	3400f7c2 <LL_RCC_SetOTGPHYCKREFClockSource>
34012d6e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d72:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
34012d76:	0fdb      	lsrs	r3, r3, #31
34012d78:	2b01      	cmp	r3, #1
34012d7a:	d102      	bne.n	34012d82 <HAL_RCCEx_PeriphCLKConfig+0x2412>
34012d7c:	f7fc facc 	bl	3400f318 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34012d80:	e001      	b.n	34012d86 <HAL_RCCEx_PeriphCLKConfig+0x2416>
34012d82:	f7fc fab9 	bl	3400f2f8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
34012d86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012d8a:	e9d3 2300 	ldrd	r2, r3, [r3]
34012d8e:	2100      	movs	r1, #0
34012d90:	6139      	str	r1, [r7, #16]
34012d92:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
34012d96:	617b      	str	r3, [r7, #20]
34012d98:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
34012d9c:	4603      	mov	r3, r0
34012d9e:	460a      	mov	r2, r1
34012da0:	4313      	orrs	r3, r2
34012da2:	d053      	beq.n	34012e4c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
34012da4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012da8:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34012dac:	4a17      	ldr	r2, [pc, #92]	@ (34012e0c <HAL_RCCEx_PeriphCLKConfig+0x249c>)
34012dae:	4293      	cmp	r3, r2
34012db0:	d12e      	bne.n	34012e10 <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34012db2:	4b0d      	ldr	r3, [pc, #52]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012db4:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34012db8:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34012dbc:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34012dc0:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012dc4:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34012dc6:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012dca:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34012dcc:	3a01      	subs	r2, #1
34012dce:	0412      	lsls	r2, r2, #16
34012dd0:	430a      	orrs	r2, r1
34012dd2:	4905      	ldr	r1, [pc, #20]	@ (34012de8 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
34012dd4:	4313      	orrs	r3, r2
34012dd6:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34012dda:	f7fd fc27 	bl	3401062c <LL_RCC_IC15_Enable>
34012dde:	e020      	b.n	34012e22 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
34012de0:	07011830 	.word	0x07011830
34012de4:	07021c30 	.word	0x07021c30
34012de8:	56028000 	.word	0x56028000
34012dec:	07031c30 	.word	0x07031c30
34012df0:	07011c30 	.word	0x07011c30
34012df4:	07020034 	.word	0x07020034
34012df8:	07030034 	.word	0x07030034
34012dfc:	07010034 	.word	0x07010034
34012e00:	07020434 	.word	0x07020434
34012e04:	07030434 	.word	0x07030434
34012e08:	07010434 	.word	0x07010434
34012e0c:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
34012e10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012e14:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34012e18:	4a43      	ldr	r2, [pc, #268]	@ (34012f28 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
34012e1a:	4293      	cmp	r3, r2
34012e1c:	d101      	bne.n	34012e22 <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
34012e1e:	f7fd fd85 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
34012e22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012e26:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34012e2a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34012e2e:	4618      	mov	r0, r3
34012e30:	f7fc fcbc 	bl	3400f7ac <LL_RCC_SetOTGPHYClockSource>
34012e34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012e38:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
34012e3c:	0fdb      	lsrs	r3, r3, #31
34012e3e:	2b01      	cmp	r3, #1
34012e40:	d102      	bne.n	34012e48 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
34012e42:	f7fc fa69 	bl	3400f318 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34012e46:	e001      	b.n	34012e4c <HAL_RCCEx_PeriphCLKConfig+0x24dc>
34012e48:	f7fc fa56 	bl	3400f2f8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
34012e4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012e50:	e9d3 2300 	ldrd	r2, r3, [r3]
34012e54:	2100      	movs	r1, #0
34012e56:	60b9      	str	r1, [r7, #8]
34012e58:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34012e5c:	60fb      	str	r3, [r7, #12]
34012e5e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34012e62:	4603      	mov	r3, r0
34012e64:	460a      	mov	r2, r1
34012e66:	4313      	orrs	r3, r2
34012e68:	d03b      	beq.n	34012ee2 <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
34012e6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012e6e:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34012e72:	4a2e      	ldr	r2, [pc, #184]	@ (34012f2c <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
34012e74:	4293      	cmp	r3, r2
34012e76:	d116      	bne.n	34012ea6 <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34012e78:	4b2d      	ldr	r3, [pc, #180]	@ (34012f30 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34012e7a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34012e7e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
34012e82:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
34012e86:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012e8a:	6f91      	ldr	r1, [r2, #120]	@ 0x78
34012e8c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
34012e90:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
34012e92:	3a01      	subs	r2, #1
34012e94:	0412      	lsls	r2, r2, #16
34012e96:	430a      	orrs	r2, r1
34012e98:	4925      	ldr	r1, [pc, #148]	@ (34012f30 <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
34012e9a:	4313      	orrs	r3, r2
34012e9c:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34012ea0:	f7fd fbc4 	bl	3401062c <LL_RCC_IC15_Enable>
34012ea4:	e008      	b.n	34012eb8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
34012ea6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012eaa:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34012eae:	4a21      	ldr	r2, [pc, #132]	@ (34012f34 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
34012eb0:	4293      	cmp	r3, r2
34012eb2:	d101      	bne.n	34012eb8 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
34012eb4:	f7fd fd3a 	bl	3401092c <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
34012eb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012ebc:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34012ec0:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34012ec4:	4618      	mov	r0, r3
34012ec6:	f7fc fc71 	bl	3400f7ac <LL_RCC_SetOTGPHYClockSource>
34012eca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012ece:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
34012ed2:	0fdb      	lsrs	r3, r3, #31
34012ed4:	2b01      	cmp	r3, #1
34012ed6:	d102      	bne.n	34012ede <HAL_RCCEx_PeriphCLKConfig+0x256e>
34012ed8:	f7fc fa1e 	bl	3400f318 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
34012edc:	e001      	b.n	34012ee2 <HAL_RCCEx_PeriphCLKConfig+0x2572>
34012ede:	f7fc fa0b 	bl	3400f2f8 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
34012ee2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012ee6:	e9d3 2300 	ldrd	r2, r3, [r3]
34012eea:	2100      	movs	r1, #0
34012eec:	6039      	str	r1, [r7, #0]
34012eee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34012ef2:	607b      	str	r3, [r7, #4]
34012ef4:	e9d7 0100 	ldrd	r0, r1, [r7]
34012ef8:	4603      	mov	r3, r0
34012efa:	460a      	mov	r2, r1
34012efc:	4313      	orrs	r3, r2
34012efe:	d006      	beq.n	34012f0e <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
34012f00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34012f04:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
34012f08:	4618      	mov	r0, r3
34012f0a:	f7fc fe8b 	bl	3400fc24 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
34012f0e:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
34012f12:	2b00      	cmp	r3, #0
34012f14:	d101      	bne.n	34012f1a <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
34012f16:	2300      	movs	r3, #0
34012f18:	e000      	b.n	34012f1c <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
34012f1a:	2301      	movs	r3, #1
}
34012f1c:	4618      	mov	r0, r3
34012f1e:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
34012f22:	46bd      	mov	sp, r7
34012f24:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34012f28:	03010c14 	.word	0x03010c14
34012f2c:	03021414 	.word	0x03021414
34012f30:	56028000 	.word	0x56028000
34012f34:	03011414 	.word	0x03011414

34012f38 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_XSPI2    : XSPI2 peripheral clock
  *            @arg RCC_PERIPHCLK_XSPI3    : XSPI3 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
34012f38:	b590      	push	{r4, r7, lr}
34012f3a:	b085      	sub	sp, #20
34012f3c:	af00      	add	r7, sp, #0
34012f3e:	e9c7 0100 	strd	r0, r1, [r7]
  uint32_t frequency = 0;   /* Set to 0 for returned value if no source clock */
34012f42:	2100      	movs	r1, #0
34012f44:	60f9      	str	r1, [r7, #12]

  switch (PeriphClk)
34012f46:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f4a:	f101 447f 	add.w	r4, r1, #4278190080	@ 0xff000000
34012f4e:	ea50 0104 	orrs.w	r1, r0, r4
34012f52:	f000 8436 	beq.w	340137c2 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
34012f56:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f5a:	2801      	cmp	r0, #1
34012f5c:	f171 7180 	sbcs.w	r1, r1, #16777216	@ 0x1000000
34012f60:	f080 8434 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012f64:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f68:	f5a1 0400 	sub.w	r4, r1, #8388608	@ 0x800000
34012f6c:	ea50 0104 	orrs.w	r1, r0, r4
34012f70:	f000 8422 	beq.w	340137b8 <HAL_RCCEx_GetPeriphCLKFreq+0x880>
34012f74:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f78:	2801      	cmp	r0, #1
34012f7a:	f571 0100 	sbcs.w	r1, r1, #8388608	@ 0x800000
34012f7e:	f080 8425 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012f82:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f86:	f5a1 0480 	sub.w	r4, r1, #4194304	@ 0x400000
34012f8a:	ea50 0104 	orrs.w	r1, r0, r4
34012f8e:	f000 840e 	beq.w	340137ae <HAL_RCCEx_GetPeriphCLKFreq+0x876>
34012f92:	e9d7 0100 	ldrd	r0, r1, [r7]
34012f96:	2801      	cmp	r0, #1
34012f98:	f571 0180 	sbcs.w	r1, r1, #4194304	@ 0x400000
34012f9c:	f080 8416 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012fa0:	e9d7 0100 	ldrd	r0, r1, [r7]
34012fa4:	f5a1 1400 	sub.w	r4, r1, #2097152	@ 0x200000
34012fa8:	ea50 0104 	orrs.w	r1, r0, r4
34012fac:	f000 83fa 	beq.w	340137a4 <HAL_RCCEx_GetPeriphCLKFreq+0x86c>
34012fb0:	e9d7 0100 	ldrd	r0, r1, [r7]
34012fb4:	2801      	cmp	r0, #1
34012fb6:	f571 1100 	sbcs.w	r1, r1, #2097152	@ 0x200000
34012fba:	f080 8407 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012fbe:	e9d7 0100 	ldrd	r0, r1, [r7]
34012fc2:	f5a1 1480 	sub.w	r4, r1, #1048576	@ 0x100000
34012fc6:	ea50 0104 	orrs.w	r1, r0, r4
34012fca:	f000 83e6 	beq.w	3401379a <HAL_RCCEx_GetPeriphCLKFreq+0x862>
34012fce:	e9d7 0100 	ldrd	r0, r1, [r7]
34012fd2:	2801      	cmp	r0, #1
34012fd4:	f571 1180 	sbcs.w	r1, r1, #1048576	@ 0x100000
34012fd8:	f080 83f8 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012fdc:	e9d7 0100 	ldrd	r0, r1, [r7]
34012fe0:	f5a1 2400 	sub.w	r4, r1, #524288	@ 0x80000
34012fe4:	ea50 0104 	orrs.w	r1, r0, r4
34012fe8:	f000 83d2 	beq.w	34013790 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
34012fec:	e9d7 0100 	ldrd	r0, r1, [r7]
34012ff0:	2801      	cmp	r0, #1
34012ff2:	f571 2100 	sbcs.w	r1, r1, #524288	@ 0x80000
34012ff6:	f080 83e9 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34012ffa:	e9d7 0100 	ldrd	r0, r1, [r7]
34012ffe:	f5a1 2480 	sub.w	r4, r1, #262144	@ 0x40000
34013002:	ea50 0104 	orrs.w	r1, r0, r4
34013006:	f000 83be 	beq.w	34013786 <HAL_RCCEx_GetPeriphCLKFreq+0x84e>
3401300a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401300e:	2801      	cmp	r0, #1
34013010:	f571 2180 	sbcs.w	r1, r1, #262144	@ 0x40000
34013014:	f080 83da 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013018:	e9d7 0100 	ldrd	r0, r1, [r7]
3401301c:	f5a1 3400 	sub.w	r4, r1, #131072	@ 0x20000
34013020:	ea50 0104 	orrs.w	r1, r0, r4
34013024:	f000 83aa 	beq.w	3401377c <HAL_RCCEx_GetPeriphCLKFreq+0x844>
34013028:	e9d7 0100 	ldrd	r0, r1, [r7]
3401302c:	2801      	cmp	r0, #1
3401302e:	f571 3100 	sbcs.w	r1, r1, #131072	@ 0x20000
34013032:	f080 83cb 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013036:	e9d7 0100 	ldrd	r0, r1, [r7]
3401303a:	f5a1 3480 	sub.w	r4, r1, #65536	@ 0x10000
3401303e:	ea50 0104 	orrs.w	r1, r0, r4
34013042:	f000 8396 	beq.w	34013772 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
34013046:	e9d7 0100 	ldrd	r0, r1, [r7]
3401304a:	2801      	cmp	r0, #1
3401304c:	f571 3180 	sbcs.w	r1, r1, #65536	@ 0x10000
34013050:	f080 83bc 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013054:	e9d7 0100 	ldrd	r0, r1, [r7]
34013058:	f5a1 4400 	sub.w	r4, r1, #32768	@ 0x8000
3401305c:	ea50 0104 	orrs.w	r1, r0, r4
34013060:	f000 8382 	beq.w	34013768 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
34013064:	e9d7 0100 	ldrd	r0, r1, [r7]
34013068:	2801      	cmp	r0, #1
3401306a:	f571 4100 	sbcs.w	r1, r1, #32768	@ 0x8000
3401306e:	f080 83ad 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013072:	e9d7 0100 	ldrd	r0, r1, [r7]
34013076:	f5a1 4480 	sub.w	r4, r1, #16384	@ 0x4000
3401307a:	ea50 0104 	orrs.w	r1, r0, r4
3401307e:	f000 836e 	beq.w	3401375e <HAL_RCCEx_GetPeriphCLKFreq+0x826>
34013082:	e9d7 0100 	ldrd	r0, r1, [r7]
34013086:	2801      	cmp	r0, #1
34013088:	f571 4180 	sbcs.w	r1, r1, #16384	@ 0x4000
3401308c:	f080 839e 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013090:	e9d7 0100 	ldrd	r0, r1, [r7]
34013094:	f5a1 5400 	sub.w	r4, r1, #8192	@ 0x2000
34013098:	ea50 0104 	orrs.w	r1, r0, r4
3401309c:	f000 835a 	beq.w	34013754 <HAL_RCCEx_GetPeriphCLKFreq+0x81c>
340130a0:	e9d7 0100 	ldrd	r0, r1, [r7]
340130a4:	2801      	cmp	r0, #1
340130a6:	f571 5100 	sbcs.w	r1, r1, #8192	@ 0x2000
340130aa:	f080 838f 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340130ae:	e9d7 0100 	ldrd	r0, r1, [r7]
340130b2:	f5a1 5480 	sub.w	r4, r1, #4096	@ 0x1000
340130b6:	ea50 0104 	orrs.w	r1, r0, r4
340130ba:	f000 8346 	beq.w	3401374a <HAL_RCCEx_GetPeriphCLKFreq+0x812>
340130be:	e9d7 0100 	ldrd	r0, r1, [r7]
340130c2:	2801      	cmp	r0, #1
340130c4:	f571 5180 	sbcs.w	r1, r1, #4096	@ 0x1000
340130c8:	f080 8380 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340130cc:	e9d7 0100 	ldrd	r0, r1, [r7]
340130d0:	f5a1 6400 	sub.w	r4, r1, #2048	@ 0x800
340130d4:	ea50 0104 	orrs.w	r1, r0, r4
340130d8:	f000 8332 	beq.w	34013740 <HAL_RCCEx_GetPeriphCLKFreq+0x808>
340130dc:	e9d7 0100 	ldrd	r0, r1, [r7]
340130e0:	2801      	cmp	r0, #1
340130e2:	f571 6100 	sbcs.w	r1, r1, #2048	@ 0x800
340130e6:	f080 8371 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340130ea:	e9d7 0100 	ldrd	r0, r1, [r7]
340130ee:	f5a1 6480 	sub.w	r4, r1, #1024	@ 0x400
340130f2:	ea50 0104 	orrs.w	r1, r0, r4
340130f6:	f000 831e 	beq.w	34013736 <HAL_RCCEx_GetPeriphCLKFreq+0x7fe>
340130fa:	e9d7 0100 	ldrd	r0, r1, [r7]
340130fe:	2801      	cmp	r0, #1
34013100:	f571 6180 	sbcs.w	r1, r1, #1024	@ 0x400
34013104:	f080 8362 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013108:	e9d7 0100 	ldrd	r0, r1, [r7]
3401310c:	f5a1 7400 	sub.w	r4, r1, #512	@ 0x200
34013110:	ea50 0104 	orrs.w	r1, r0, r4
34013114:	f000 830a 	beq.w	3401372c <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
34013118:	e9d7 0100 	ldrd	r0, r1, [r7]
3401311c:	2801      	cmp	r0, #1
3401311e:	f571 7100 	sbcs.w	r1, r1, #512	@ 0x200
34013122:	f080 8353 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013126:	e9d7 0100 	ldrd	r0, r1, [r7]
3401312a:	f5a1 7480 	sub.w	r4, r1, #256	@ 0x100
3401312e:	ea50 0104 	orrs.w	r1, r0, r4
34013132:	f000 82f6 	beq.w	34013722 <HAL_RCCEx_GetPeriphCLKFreq+0x7ea>
34013136:	e9d7 0100 	ldrd	r0, r1, [r7]
3401313a:	2801      	cmp	r0, #1
3401313c:	f571 7180 	sbcs.w	r1, r1, #256	@ 0x100
34013140:	f080 8344 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013144:	e9d7 0100 	ldrd	r0, r1, [r7]
34013148:	f1a1 0440 	sub.w	r4, r1, #64	@ 0x40
3401314c:	ea50 0104 	orrs.w	r1, r0, r4
34013150:	f000 82e2 	beq.w	34013718 <HAL_RCCEx_GetPeriphCLKFreq+0x7e0>
34013154:	e9d7 0100 	ldrd	r0, r1, [r7]
34013158:	2801      	cmp	r0, #1
3401315a:	f171 0140 	sbcs.w	r1, r1, #64	@ 0x40
3401315e:	f080 8335 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013162:	e9d7 0100 	ldrd	r0, r1, [r7]
34013166:	f1a1 0420 	sub.w	r4, r1, #32
3401316a:	ea50 0104 	orrs.w	r1, r0, r4
3401316e:	f000 82ce 	beq.w	3401370e <HAL_RCCEx_GetPeriphCLKFreq+0x7d6>
34013172:	e9d7 0100 	ldrd	r0, r1, [r7]
34013176:	2801      	cmp	r0, #1
34013178:	f171 0120 	sbcs.w	r1, r1, #32
3401317c:	f080 8326 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013180:	e9d7 0100 	ldrd	r0, r1, [r7]
34013184:	f1a1 0410 	sub.w	r4, r1, #16
34013188:	ea50 0104 	orrs.w	r1, r0, r4
3401318c:	f000 82ba 	beq.w	34013704 <HAL_RCCEx_GetPeriphCLKFreq+0x7cc>
34013190:	e9d7 0100 	ldrd	r0, r1, [r7]
34013194:	2801      	cmp	r0, #1
34013196:	f171 0110 	sbcs.w	r1, r1, #16
3401319a:	f080 8317 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401319e:	e9d7 0100 	ldrd	r0, r1, [r7]
340131a2:	f1a1 0408 	sub.w	r4, r1, #8
340131a6:	ea50 0104 	orrs.w	r1, r0, r4
340131aa:	f000 82a6 	beq.w	340136fa <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
340131ae:	e9d7 0100 	ldrd	r0, r1, [r7]
340131b2:	2801      	cmp	r0, #1
340131b4:	f171 0108 	sbcs.w	r1, r1, #8
340131b8:	f080 8308 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340131bc:	e9d7 0100 	ldrd	r0, r1, [r7]
340131c0:	1f0c      	subs	r4, r1, #4
340131c2:	ea50 0104 	orrs.w	r1, r0, r4
340131c6:	f000 8293 	beq.w	340136f0 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
340131ca:	e9d7 0100 	ldrd	r0, r1, [r7]
340131ce:	2801      	cmp	r0, #1
340131d0:	f171 0104 	sbcs.w	r1, r1, #4
340131d4:	f080 82fa 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340131d8:	e9d7 0100 	ldrd	r0, r1, [r7]
340131dc:	1e8c      	subs	r4, r1, #2
340131de:	ea50 0104 	orrs.w	r1, r0, r4
340131e2:	f000 8280 	beq.w	340136e6 <HAL_RCCEx_GetPeriphCLKFreq+0x7ae>
340131e6:	e9d7 0100 	ldrd	r0, r1, [r7]
340131ea:	2801      	cmp	r0, #1
340131ec:	f171 0102 	sbcs.w	r1, r1, #2
340131f0:	f080 82ec 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340131f4:	e9d7 0100 	ldrd	r0, r1, [r7]
340131f8:	1e4c      	subs	r4, r1, #1
340131fa:	ea50 0104 	orrs.w	r1, r0, r4
340131fe:	f000 826d 	beq.w	340136dc <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>
34013202:	e9d7 0100 	ldrd	r0, r1, [r7]
34013206:	2801      	cmp	r0, #1
34013208:	f171 0101 	sbcs.w	r1, r1, #1
3401320c:	f080 82de 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013210:	e9d7 0100 	ldrd	r0, r1, [r7]
34013214:	f100 4400 	add.w	r4, r0, #2147483648	@ 0x80000000
34013218:	4321      	orrs	r1, r4
3401321a:	f000 825a 	beq.w	340136d2 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
3401321e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013222:	4cda      	ldr	r4, [pc, #872]	@ (3401358c <HAL_RCCEx_GetPeriphCLKFreq+0x654>)
34013224:	42a0      	cmp	r0, r4
34013226:	f171 0100 	sbcs.w	r1, r1, #0
3401322a:	f080 82cf 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401322e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013232:	f100 4440 	add.w	r4, r0, #3221225472	@ 0xc0000000
34013236:	4321      	orrs	r1, r4
34013238:	f000 8246 	beq.w	340136c8 <HAL_RCCEx_GetPeriphCLKFreq+0x790>
3401323c:	e9d7 0100 	ldrd	r0, r1, [r7]
34013240:	4cd3      	ldr	r4, [pc, #844]	@ (34013590 <HAL_RCCEx_GetPeriphCLKFreq+0x658>)
34013242:	42a0      	cmp	r0, r4
34013244:	f171 0100 	sbcs.w	r1, r1, #0
34013248:	f080 82c0 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401324c:	e9d7 0100 	ldrd	r0, r1, [r7]
34013250:	f100 4460 	add.w	r4, r0, #3758096384	@ 0xe0000000
34013254:	4321      	orrs	r1, r4
34013256:	f000 8232 	beq.w	340136be <HAL_RCCEx_GetPeriphCLKFreq+0x786>
3401325a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401325e:	4ccd      	ldr	r4, [pc, #820]	@ (34013594 <HAL_RCCEx_GetPeriphCLKFreq+0x65c>)
34013260:	42a0      	cmp	r0, r4
34013262:	f171 0100 	sbcs.w	r1, r1, #0
34013266:	f080 82b1 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401326a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401326e:	f100 4470 	add.w	r4, r0, #4026531840	@ 0xf0000000
34013272:	4321      	orrs	r1, r4
34013274:	f000 821e 	beq.w	340136b4 <HAL_RCCEx_GetPeriphCLKFreq+0x77c>
34013278:	e9d7 0100 	ldrd	r0, r1, [r7]
3401327c:	4cc6      	ldr	r4, [pc, #792]	@ (34013598 <HAL_RCCEx_GetPeriphCLKFreq+0x660>)
3401327e:	42a0      	cmp	r0, r4
34013280:	f171 0100 	sbcs.w	r1, r1, #0
34013284:	f080 82a2 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013288:	e9d7 0100 	ldrd	r0, r1, [r7]
3401328c:	f100 4478 	add.w	r4, r0, #4160749568	@ 0xf8000000
34013290:	4321      	orrs	r1, r4
34013292:	f000 820b 	beq.w	340136ac <HAL_RCCEx_GetPeriphCLKFreq+0x774>
34013296:	e9d7 0100 	ldrd	r0, r1, [r7]
3401329a:	4cc0      	ldr	r4, [pc, #768]	@ (3401359c <HAL_RCCEx_GetPeriphCLKFreq+0x664>)
3401329c:	42a0      	cmp	r0, r4
3401329e:	f171 0100 	sbcs.w	r1, r1, #0
340132a2:	f080 8293 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340132a6:	e9d7 0100 	ldrd	r0, r1, [r7]
340132aa:	f100 447c 	add.w	r4, r0, #4227858432	@ 0xfc000000
340132ae:	4321      	orrs	r1, r4
340132b0:	f000 81f7 	beq.w	340136a2 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
340132b4:	e9d7 0100 	ldrd	r0, r1, [r7]
340132b8:	4cb9      	ldr	r4, [pc, #740]	@ (340135a0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>)
340132ba:	42a0      	cmp	r0, r4
340132bc:	f171 0100 	sbcs.w	r1, r1, #0
340132c0:	f080 8284 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340132c4:	e9d7 0100 	ldrd	r0, r1, [r7]
340132c8:	f100 447e 	add.w	r4, r0, #4261412864	@ 0xfe000000
340132cc:	4321      	orrs	r1, r4
340132ce:	f000 81e2 	beq.w	34013696 <HAL_RCCEx_GetPeriphCLKFreq+0x75e>
340132d2:	e9d7 0100 	ldrd	r0, r1, [r7]
340132d6:	4cb3      	ldr	r4, [pc, #716]	@ (340135a4 <HAL_RCCEx_GetPeriphCLKFreq+0x66c>)
340132d8:	42a0      	cmp	r0, r4
340132da:	f171 0100 	sbcs.w	r1, r1, #0
340132de:	f080 8275 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340132e2:	e9d7 0100 	ldrd	r0, r1, [r7]
340132e6:	f100 447f 	add.w	r4, r0, #4278190080	@ 0xff000000
340132ea:	4321      	orrs	r1, r4
340132ec:	f000 81cd 	beq.w	3401368a <HAL_RCCEx_GetPeriphCLKFreq+0x752>
340132f0:	e9d7 0100 	ldrd	r0, r1, [r7]
340132f4:	4cac      	ldr	r4, [pc, #688]	@ (340135a8 <HAL_RCCEx_GetPeriphCLKFreq+0x670>)
340132f6:	42a0      	cmp	r0, r4
340132f8:	f171 0100 	sbcs.w	r1, r1, #0
340132fc:	f080 8266 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013300:	e9d7 0100 	ldrd	r0, r1, [r7]
34013304:	f5a0 0400 	sub.w	r4, r0, #8388608	@ 0x800000
34013308:	4321      	orrs	r1, r4
3401330a:	f000 81b8 	beq.w	3401367e <HAL_RCCEx_GetPeriphCLKFreq+0x746>
3401330e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013312:	4ca6      	ldr	r4, [pc, #664]	@ (340135ac <HAL_RCCEx_GetPeriphCLKFreq+0x674>)
34013314:	42a0      	cmp	r0, r4
34013316:	f171 0100 	sbcs.w	r1, r1, #0
3401331a:	f080 8257 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401331e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013322:	f5a0 0480 	sub.w	r4, r0, #4194304	@ 0x400000
34013326:	4321      	orrs	r1, r4
34013328:	f000 81a4 	beq.w	34013674 <HAL_RCCEx_GetPeriphCLKFreq+0x73c>
3401332c:	e9d7 0100 	ldrd	r0, r1, [r7]
34013330:	4c9f      	ldr	r4, [pc, #636]	@ (340135b0 <HAL_RCCEx_GetPeriphCLKFreq+0x678>)
34013332:	42a0      	cmp	r0, r4
34013334:	f171 0100 	sbcs.w	r1, r1, #0
34013338:	f080 8248 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401333c:	e9d7 0100 	ldrd	r0, r1, [r7]
34013340:	f5a0 1400 	sub.w	r4, r0, #2097152	@ 0x200000
34013344:	4321      	orrs	r1, r4
34013346:	f000 8190 	beq.w	3401366a <HAL_RCCEx_GetPeriphCLKFreq+0x732>
3401334a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401334e:	4c99      	ldr	r4, [pc, #612]	@ (340135b4 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>)
34013350:	42a0      	cmp	r0, r4
34013352:	f171 0100 	sbcs.w	r1, r1, #0
34013356:	f080 8239 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
3401335a:	e9d7 0100 	ldrd	r0, r1, [r7]
3401335e:	f5a0 1480 	sub.w	r4, r0, #1048576	@ 0x100000
34013362:	4321      	orrs	r1, r4
34013364:	f000 817c 	beq.w	34013660 <HAL_RCCEx_GetPeriphCLKFreq+0x728>
34013368:	e9d7 0100 	ldrd	r0, r1, [r7]
3401336c:	4c92      	ldr	r4, [pc, #584]	@ (340135b8 <HAL_RCCEx_GetPeriphCLKFreq+0x680>)
3401336e:	42a0      	cmp	r0, r4
34013370:	f171 0100 	sbcs.w	r1, r1, #0
34013374:	f080 822a 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013378:	e9d7 0100 	ldrd	r0, r1, [r7]
3401337c:	f5a0 2400 	sub.w	r4, r0, #524288	@ 0x80000
34013380:	4321      	orrs	r1, r4
34013382:	f000 8168 	beq.w	34013656 <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
34013386:	e9d7 0100 	ldrd	r0, r1, [r7]
3401338a:	4c8c      	ldr	r4, [pc, #560]	@ (340135bc <HAL_RCCEx_GetPeriphCLKFreq+0x684>)
3401338c:	42a0      	cmp	r0, r4
3401338e:	f171 0100 	sbcs.w	r1, r1, #0
34013392:	f080 821b 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013396:	e9d7 0100 	ldrd	r0, r1, [r7]
3401339a:	f5a0 2480 	sub.w	r4, r0, #262144	@ 0x40000
3401339e:	4321      	orrs	r1, r4
340133a0:	f000 8154 	beq.w	3401364c <HAL_RCCEx_GetPeriphCLKFreq+0x714>
340133a4:	e9d7 0100 	ldrd	r0, r1, [r7]
340133a8:	4c85      	ldr	r4, [pc, #532]	@ (340135c0 <HAL_RCCEx_GetPeriphCLKFreq+0x688>)
340133aa:	42a0      	cmp	r0, r4
340133ac:	f171 0100 	sbcs.w	r1, r1, #0
340133b0:	f080 820c 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340133b4:	e9d7 0100 	ldrd	r0, r1, [r7]
340133b8:	f5a0 3400 	sub.w	r4, r0, #131072	@ 0x20000
340133bc:	4321      	orrs	r1, r4
340133be:	f000 8140 	beq.w	34013642 <HAL_RCCEx_GetPeriphCLKFreq+0x70a>
340133c2:	e9d7 0100 	ldrd	r0, r1, [r7]
340133c6:	4c7f      	ldr	r4, [pc, #508]	@ (340135c4 <HAL_RCCEx_GetPeriphCLKFreq+0x68c>)
340133c8:	42a0      	cmp	r0, r4
340133ca:	f171 0100 	sbcs.w	r1, r1, #0
340133ce:	f080 81fd 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340133d2:	e9d7 0100 	ldrd	r0, r1, [r7]
340133d6:	f5a0 3480 	sub.w	r4, r0, #65536	@ 0x10000
340133da:	4321      	orrs	r1, r4
340133dc:	f000 812c 	beq.w	34013638 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
340133e0:	e9d7 0100 	ldrd	r0, r1, [r7]
340133e4:	f1b0 1f01 	cmp.w	r0, #65537	@ 0x10001
340133e8:	f171 0100 	sbcs.w	r1, r1, #0
340133ec:	f080 81ee 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340133f0:	e9d7 0100 	ldrd	r0, r1, [r7]
340133f4:	f5a0 4400 	sub.w	r4, r0, #32768	@ 0x8000
340133f8:	4321      	orrs	r1, r4
340133fa:	f000 8118 	beq.w	3401362e <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
340133fe:	e9d7 0100 	ldrd	r0, r1, [r7]
34013402:	f248 0401 	movw	r4, #32769	@ 0x8001
34013406:	42a0      	cmp	r0, r4
34013408:	f171 0100 	sbcs.w	r1, r1, #0
3401340c:	f080 81de 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013410:	e9d7 0100 	ldrd	r0, r1, [r7]
34013414:	f5a0 4480 	sub.w	r4, r0, #16384	@ 0x4000
34013418:	4321      	orrs	r1, r4
3401341a:	f000 8103 	beq.w	34013624 <HAL_RCCEx_GetPeriphCLKFreq+0x6ec>
3401341e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013422:	f244 0401 	movw	r4, #16385	@ 0x4001
34013426:	42a0      	cmp	r0, r4
34013428:	f171 0100 	sbcs.w	r1, r1, #0
3401342c:	f080 81ce 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013430:	e9d7 0100 	ldrd	r0, r1, [r7]
34013434:	f5a0 5400 	sub.w	r4, r0, #8192	@ 0x2000
34013438:	4321      	orrs	r1, r4
3401343a:	f000 80ee 	beq.w	3401361a <HAL_RCCEx_GetPeriphCLKFreq+0x6e2>
3401343e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013442:	f242 0401 	movw	r4, #8193	@ 0x2001
34013446:	42a0      	cmp	r0, r4
34013448:	f171 0100 	sbcs.w	r1, r1, #0
3401344c:	f080 81be 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013450:	e9d7 0100 	ldrd	r0, r1, [r7]
34013454:	f5a0 5480 	sub.w	r4, r0, #4096	@ 0x1000
34013458:	4321      	orrs	r1, r4
3401345a:	f000 80d9 	beq.w	34013610 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
3401345e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013462:	f241 0401 	movw	r4, #4097	@ 0x1001
34013466:	42a0      	cmp	r0, r4
34013468:	f171 0100 	sbcs.w	r1, r1, #0
3401346c:	f080 81ae 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013470:	e9d7 0100 	ldrd	r0, r1, [r7]
34013474:	f5a0 6400 	sub.w	r4, r0, #2048	@ 0x800
34013478:	4321      	orrs	r1, r4
3401347a:	f000 80c4 	beq.w	34013606 <HAL_RCCEx_GetPeriphCLKFreq+0x6ce>
3401347e:	e9d7 0100 	ldrd	r0, r1, [r7]
34013482:	f640 0401 	movw	r4, #2049	@ 0x801
34013486:	42a0      	cmp	r0, r4
34013488:	f171 0100 	sbcs.w	r1, r1, #0
3401348c:	f080 819e 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
34013490:	e9d7 0100 	ldrd	r0, r1, [r7]
34013494:	f5a0 6480 	sub.w	r4, r0, #1024	@ 0x400
34013498:	4321      	orrs	r1, r4
3401349a:	f000 80af 	beq.w	340135fc <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
3401349e:	e9d7 0100 	ldrd	r0, r1, [r7]
340134a2:	f240 4401 	movw	r4, #1025	@ 0x401
340134a6:	42a0      	cmp	r0, r4
340134a8:	f171 0100 	sbcs.w	r1, r1, #0
340134ac:	f080 818e 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340134b0:	e9d7 0100 	ldrd	r0, r1, [r7]
340134b4:	2821      	cmp	r0, #33	@ 0x21
340134b6:	f171 0100 	sbcs.w	r1, r1, #0
340134ba:	d255      	bcs.n	34013568 <HAL_RCCEx_GetPeriphCLKFreq+0x630>
340134bc:	e9d7 0100 	ldrd	r0, r1, [r7]
340134c0:	4301      	orrs	r1, r0
340134c2:	f000 8183 	beq.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340134c6:	e9d7 0100 	ldrd	r0, r1, [r7]
340134ca:	1e42      	subs	r2, r0, #1
340134cc:	f141 33ff 	adc.w	r3, r1, #4294967295
340134d0:	2a20      	cmp	r2, #32
340134d2:	f173 0100 	sbcs.w	r1, r3, #0
340134d6:	f080 8179 	bcs.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340134da:	2a1f      	cmp	r2, #31
340134dc:	f200 8176 	bhi.w	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
340134e0:	a101      	add	r1, pc, #4	@ (adr r1, 340134e8 <HAL_RCCEx_GetPeriphCLKFreq+0x5b0>)
340134e2:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
340134e6:	bf00      	nop
340134e8:	34013577 	.word	0x34013577
340134ec:	34013581 	.word	0x34013581
340134f0:	340137cd 	.word	0x340137cd
340134f4:	340135d1 	.word	0x340135d1
340134f8:	340137cd 	.word	0x340137cd
340134fc:	340137cd 	.word	0x340137cd
34013500:	340137cd 	.word	0x340137cd
34013504:	340135c9 	.word	0x340135c9
34013508:	340137cd 	.word	0x340137cd
3401350c:	340137cd 	.word	0x340137cd
34013510:	340137cd 	.word	0x340137cd
34013514:	340137cd 	.word	0x340137cd
34013518:	340137cd 	.word	0x340137cd
3401351c:	340137cd 	.word	0x340137cd
34013520:	340137cd 	.word	0x340137cd
34013524:	340135db 	.word	0x340135db
34013528:	340137cd 	.word	0x340137cd
3401352c:	340137cd 	.word	0x340137cd
34013530:	340137cd 	.word	0x340137cd
34013534:	340137cd 	.word	0x340137cd
34013538:	340137cd 	.word	0x340137cd
3401353c:	340137cd 	.word	0x340137cd
34013540:	340137cd 	.word	0x340137cd
34013544:	340137cd 	.word	0x340137cd
34013548:	340137cd 	.word	0x340137cd
3401354c:	340137cd 	.word	0x340137cd
34013550:	340137cd 	.word	0x340137cd
34013554:	340137cd 	.word	0x340137cd
34013558:	340137cd 	.word	0x340137cd
3401355c:	340137cd 	.word	0x340137cd
34013560:	340137cd 	.word	0x340137cd
34013564:	340135e7 	.word	0x340135e7
34013568:	e9d7 2300 	ldrd	r2, r3, [r7]
3401356c:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
34013570:	430b      	orrs	r3, r1
34013572:	d03e      	beq.n	340135f2 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
      break;

    default:
      /* Unexpected case, frequency is by default set to 0 */
      break;
34013574:	e12a      	b.n	340137cc <HAL_RCCEx_GetPeriphCLKFreq+0x894>
      frequency = RCCEx_GetADCCLKFreq(LL_RCC_ADC_CLKSOURCE);
34013576:	2070      	movs	r0, #112	@ 0x70
34013578:	f000 fb90 	bl	34013c9c <RCCEx_GetADCCLKFreq>
3401357c:	60f8      	str	r0, [r7, #12]
      break;
3401357e:	e126      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetADFCLKFreq(LL_RCC_ADF1_CLKSOURCE);
34013580:	2007      	movs	r0, #7
34013582:	f000 fc8d 	bl	34013ea0 <RCCEx_GetADFCLKFreq>
34013586:	60f8      	str	r0, [r7, #12]
      break;
34013588:	e121      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
3401358a:	bf00      	nop
3401358c:	80000001 	.word	0x80000001
34013590:	40000001 	.word	0x40000001
34013594:	20000001 	.word	0x20000001
34013598:	10000001 	.word	0x10000001
3401359c:	08000001 	.word	0x08000001
340135a0:	04000001 	.word	0x04000001
340135a4:	02000001 	.word	0x02000001
340135a8:	01000001 	.word	0x01000001
340135ac:	00800001 	.word	0x00800001
340135b0:	00400001 	.word	0x00400001
340135b4:	00200001 	.word	0x00200001
340135b8:	00100001 	.word	0x00100001
340135bc:	00080001 	.word	0x00080001
340135c0:	00040001 	.word	0x00040001
340135c4:	00020001 	.word	0x00020001
      frequency = RCCEx_GetCSICLKFreq();
340135c8:	f000 ff0c 	bl	340143e4 <RCCEx_GetCSICLKFreq>
340135cc:	60f8      	str	r0, [r7, #12]
      break;
340135ce:	e0fe      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340135d0:	2007      	movs	r0, #7
340135d2:	f000 fd51 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340135d6:	60f8      	str	r0, [r7, #12]
      break;
340135d8:	e0f9      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetDCMIPPCLKFreq(LL_RCC_DCMIPP_CLKSOURCE);
340135da:	f44f 1040 	mov.w	r0, #3145728	@ 0x300000
340135de:	f000 ff4d 	bl	3401447c <RCCEx_GetDCMIPPCLKFreq>
340135e2:	60f8      	str	r0, [r7, #12]
      break;
340135e4:	e0f3      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1CLKFreq(LL_RCC_ETH1_CLKSOURCE);
340135e6:	f44f 5040 	mov.w	r0, #12288	@ 0x3000
340135ea:	f000 ffd1 	bl	34014590 <RCCEx_GetETH1CLKFreq>
340135ee:	60f8      	str	r0, [r7, #12]
      break;
340135f0:	e0ed      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetETH1PTPCLKFreq(LL_RCC_ETH1PTP_CLKSOURCE);
340135f2:	2003      	movs	r0, #3
340135f4:	f001 f84c 	bl	34014690 <RCCEx_GetETH1PTPCLKFreq>
340135f8:	60f8      	str	r0, [r7, #12]
      break;
340135fa:	e0e8      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFDCANCLKFreq(LL_RCC_FDCAN_CLKSOURCE);
340135fc:	2003      	movs	r0, #3
340135fe:	f001 f8cb 	bl	34014798 <RCCEx_GetFDCANCLKFreq>
34013602:	60f8      	str	r0, [r7, #12]
      break;
34013604:	e0e3      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetFMCCLKFreq(LL_RCC_FMC_CLKSOURCE);
34013606:	2030      	movs	r0, #48	@ 0x30
34013608:	f001 f946 	bl	34014898 <RCCEx_GetFMCCLKFreq>
3401360c:	60f8      	str	r0, [r7, #12]
      break;
3401360e:	e0de      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C1_CLKSOURCE);
34013610:	4871      	ldr	r0, [pc, #452]	@ (340137d8 <HAL_RCCEx_GetPeriphCLKFreq+0x8a0>)
34013612:	f001 f9f9 	bl	34014a08 <RCCEx_GetI2CCLKFreq>
34013616:	60f8      	str	r0, [r7, #12]
      break;
34013618:	e0d9      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C2_CLKSOURCE);
3401361a:	4870      	ldr	r0, [pc, #448]	@ (340137dc <HAL_RCCEx_GetPeriphCLKFreq+0x8a4>)
3401361c:	f001 f9f4 	bl	34014a08 <RCCEx_GetI2CCLKFreq>
34013620:	60f8      	str	r0, [r7, #12]
      break;
34013622:	e0d4      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C3_CLKSOURCE);
34013624:	486e      	ldr	r0, [pc, #440]	@ (340137e0 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>)
34013626:	f001 f9ef 	bl	34014a08 <RCCEx_GetI2CCLKFreq>
3401362a:	60f8      	str	r0, [r7, #12]
      break;
3401362c:	e0cf      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI2CCLKFreq(LL_RCC_I2C4_CLKSOURCE);
3401362e:	486d      	ldr	r0, [pc, #436]	@ (340137e4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>)
34013630:	f001 f9ea 	bl	34014a08 <RCCEx_GetI2CCLKFreq>
34013634:	60f8      	str	r0, [r7, #12]
      break;
34013636:	e0ca      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C1_CLKSOURCE);
34013638:	486b      	ldr	r0, [pc, #428]	@ (340137e8 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>)
3401363a:	f001 fb8d 	bl	34014d58 <RCCEx_GetI3CCLKFreq>
3401363e:	60f8      	str	r0, [r7, #12]
      break;
34013640:	e0c5      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetI3CCLKFreq(LL_RCC_I3C2_CLKSOURCE);
34013642:	486a      	ldr	r0, [pc, #424]	@ (340137ec <HAL_RCCEx_GetPeriphCLKFreq+0x8b4>)
34013644:	f001 fb88 	bl	34014d58 <RCCEx_GetI3CCLKFreq>
34013648:	60f8      	str	r0, [r7, #12]
      break;
3401364a:	e0c0      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM1_CLKSOURCE);
3401364c:	4868      	ldr	r0, [pc, #416]	@ (340137f0 <HAL_RCCEx_GetPeriphCLKFreq+0x8b8>)
3401364e:	f001 fcb7 	bl	34014fc0 <RCCEx_GetLPTIMCLKFreq>
34013652:	60f8      	str	r0, [r7, #12]
      break;
34013654:	e0bb      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM2_CLKSOURCE);
34013656:	4867      	ldr	r0, [pc, #412]	@ (340137f4 <HAL_RCCEx_GetPeriphCLKFreq+0x8bc>)
34013658:	f001 fcb2 	bl	34014fc0 <RCCEx_GetLPTIMCLKFreq>
3401365c:	60f8      	str	r0, [r7, #12]
      break;
3401365e:	e0b6      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM3_CLKSOURCE);
34013660:	4865      	ldr	r0, [pc, #404]	@ (340137f8 <HAL_RCCEx_GetPeriphCLKFreq+0x8c0>)
34013662:	f001 fcad 	bl	34014fc0 <RCCEx_GetLPTIMCLKFreq>
34013666:	60f8      	str	r0, [r7, #12]
      break;
34013668:	e0b1      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM4_CLKSOURCE);
3401366a:	4864      	ldr	r0, [pc, #400]	@ (340137fc <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>)
3401366c:	f001 fca8 	bl	34014fc0 <RCCEx_GetLPTIMCLKFreq>
34013670:	60f8      	str	r0, [r7, #12]
      break;
34013672:	e0ac      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPTIMCLKFreq(LL_RCC_LPTIM5_CLKSOURCE);
34013674:	4862      	ldr	r0, [pc, #392]	@ (34013800 <HAL_RCCEx_GetPeriphCLKFreq+0x8c8>)
34013676:	f001 fca3 	bl	34014fc0 <RCCEx_GetLPTIMCLKFreq>
3401367a:	60f8      	str	r0, [r7, #12]
      break;
3401367c:	e0a7      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLPUARTCLKFreq(LL_RCC_LPUART1_CLKSOURCE);
3401367e:	f44f 60e0 	mov.w	r0, #1792	@ 0x700
34013682:	f001 fe47 	bl	34015314 <RCCEx_GetLPUARTCLKFreq>
34013686:	60f8      	str	r0, [r7, #12]
      break;
34013688:	e0a1      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetLTDCCLKFreq(LL_RCC_LTDC_CLKSOURCE);
3401368a:	f04f 7040 	mov.w	r0, #50331648	@ 0x3000000
3401368e:	f001 ff43 	bl	34015518 <RCCEx_GetLTDCCLKFreq>
34013692:	60f8      	str	r0, [r7, #12]
      break;
34013694:	e09b      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetMDFCLKFreq(LL_RCC_MDF1_CLKSOURCE);
34013696:	f44f 20e0 	mov.w	r0, #458752	@ 0x70000
3401369a:	f001 ffc7 	bl	3401562c <RCCEx_GetMDFCLKFreq>
3401369e:	60f8      	str	r0, [r7, #12]
      break;
340136a0:	e095      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetPSSICLKFreq(LL_RCC_PSSI_CLKSOURCE);
340136a2:	2030      	movs	r0, #48	@ 0x30
340136a4:	f002 f8cc 	bl	34015840 <RCCEx_GetPSSICLKFreq>
340136a8:	60f8      	str	r0, [r7, #12]
      break;
340136aa:	e090      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetRTCCLKFreq();
340136ac:	f002 f94a 	bl	34015944 <RCCEx_GetRTCCLKFreq>
340136b0:	60f8      	str	r0, [r7, #12]
      break;
340136b2:	e08c      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI1_CLKSOURCE);
340136b4:	4853      	ldr	r0, [pc, #332]	@ (34013804 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>)
340136b6:	f002 f997 	bl	340159e8 <RCCEx_GetSAICLKFreq>
340136ba:	60f8      	str	r0, [r7, #12]
      break;
340136bc:	e087      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSAICLKFreq(LL_RCC_SAI2_CLKSOURCE);
340136be:	4852      	ldr	r0, [pc, #328]	@ (34013808 <HAL_RCCEx_GetPeriphCLKFreq+0x8d0>)
340136c0:	f002 f992 	bl	340159e8 <RCCEx_GetSAICLKFreq>
340136c4:	60f8      	str	r0, [r7, #12]
      break;
340136c6:	e082      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC1_CLKSOURCE);
340136c8:	4850      	ldr	r0, [pc, #320]	@ (3401380c <HAL_RCCEx_GetPeriphCLKFreq+0x8d4>)
340136ca:	f002 faf3 	bl	34015cb4 <RCCEx_GetSDMMCCLKFreq>
340136ce:	60f8      	str	r0, [r7, #12]
      break;
340136d0:	e07d      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSDMMCCLKFreq(LL_RCC_SDMMC2_CLKSOURCE);
340136d2:	484f      	ldr	r0, [pc, #316]	@ (34013810 <HAL_RCCEx_GetPeriphCLKFreq+0x8d8>)
340136d4:	f002 faee 	bl	34015cb4 <RCCEx_GetSDMMCCLKFreq>
340136d8:	60f8      	str	r0, [r7, #12]
      break;
340136da:	e078      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
340136dc:	2007      	movs	r0, #7
340136de:	f002 fbd3 	bl	34015e88 <RCCEx_GetSPDIFRXCLKFreq>
340136e2:	60f8      	str	r0, [r7, #12]
      break;
340136e4:	e073      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI1_CLKSOURCE);
340136e6:	484b      	ldr	r0, [pc, #300]	@ (34013814 <HAL_RCCEx_GetPeriphCLKFreq+0x8dc>)
340136e8:	f002 fcb2 	bl	34016050 <RCCEx_GetSPICLKFreq>
340136ec:	60f8      	str	r0, [r7, #12]
      break;
340136ee:	e06e      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI2_CLKSOURCE);
340136f0:	4849      	ldr	r0, [pc, #292]	@ (34013818 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>)
340136f2:	f002 fcad 	bl	34016050 <RCCEx_GetSPICLKFreq>
340136f6:	60f8      	str	r0, [r7, #12]
      break;
340136f8:	e069      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI3_CLKSOURCE);
340136fa:	4848      	ldr	r0, [pc, #288]	@ (3401381c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>)
340136fc:	f002 fca8 	bl	34016050 <RCCEx_GetSPICLKFreq>
34013700:	60f8      	str	r0, [r7, #12]
      break;
34013702:	e064      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI4_CLKSOURCE);
34013704:	4846      	ldr	r0, [pc, #280]	@ (34013820 <HAL_RCCEx_GetPeriphCLKFreq+0x8e8>)
34013706:	f002 fca3 	bl	34016050 <RCCEx_GetSPICLKFreq>
3401370a:	60f8      	str	r0, [r7, #12]
      break;
3401370c:	e05f      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI5_CLKSOURCE);
3401370e:	4845      	ldr	r0, [pc, #276]	@ (34013824 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>)
34013710:	f002 fc9e 	bl	34016050 <RCCEx_GetSPICLKFreq>
34013714:	60f8      	str	r0, [r7, #12]
      break;
34013716:	e05a      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetSPICLKFreq(LL_RCC_SPI6_CLKSOURCE);
34013718:	4843      	ldr	r0, [pc, #268]	@ (34013828 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>)
3401371a:	f002 fc99 	bl	34016050 <RCCEx_GetSPICLKFreq>
3401371e:	60f8      	str	r0, [r7, #12]
      break;
34013720:	e055      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART1_CLKSOURCE);
34013722:	4842      	ldr	r0, [pc, #264]	@ (3401382c <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>)
34013724:	f003 f990 	bl	34016a48 <RCCEx_GetUSARTCLKFreq>
34013728:	60f8      	str	r0, [r7, #12]
      break;
3401372a:	e050      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART2_CLKSOURCE);
3401372c:	4840      	ldr	r0, [pc, #256]	@ (34013830 <HAL_RCCEx_GetPeriphCLKFreq+0x8f8>)
3401372e:	f003 f98b 	bl	34016a48 <RCCEx_GetUSARTCLKFreq>
34013732:	60f8      	str	r0, [r7, #12]
      break;
34013734:	e04b      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART3_CLKSOURCE);
34013736:	483f      	ldr	r0, [pc, #252]	@ (34013834 <HAL_RCCEx_GetPeriphCLKFreq+0x8fc>)
34013738:	f003 f986 	bl	34016a48 <RCCEx_GetUSARTCLKFreq>
3401373c:	60f8      	str	r0, [r7, #12]
      break;
3401373e:	e046      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART4_CLKSOURCE);
34013740:	483d      	ldr	r0, [pc, #244]	@ (34013838 <HAL_RCCEx_GetPeriphCLKFreq+0x900>)
34013742:	f002 ff57 	bl	340165f4 <RCCEx_GetUARTCLKFreq>
34013746:	60f8      	str	r0, [r7, #12]
      break;
34013748:	e041      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART5_CLKSOURCE);
3401374a:	483c      	ldr	r0, [pc, #240]	@ (3401383c <HAL_RCCEx_GetPeriphCLKFreq+0x904>)
3401374c:	f002 ff52 	bl	340165f4 <RCCEx_GetUARTCLKFreq>
34013750:	60f8      	str	r0, [r7, #12]
      break;
34013752:	e03c      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART6_CLKSOURCE);
34013754:	483a      	ldr	r0, [pc, #232]	@ (34013840 <HAL_RCCEx_GetPeriphCLKFreq+0x908>)
34013756:	f003 f977 	bl	34016a48 <RCCEx_GetUSARTCLKFreq>
3401375a:	60f8      	str	r0, [r7, #12]
      break;
3401375c:	e037      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART7_CLKSOURCE);
3401375e:	4839      	ldr	r0, [pc, #228]	@ (34013844 <HAL_RCCEx_GetPeriphCLKFreq+0x90c>)
34013760:	f002 ff48 	bl	340165f4 <RCCEx_GetUARTCLKFreq>
34013764:	60f8      	str	r0, [r7, #12]
      break;
34013766:	e032      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART8_CLKSOURCE);
34013768:	4837      	ldr	r0, [pc, #220]	@ (34013848 <HAL_RCCEx_GetPeriphCLKFreq+0x910>)
3401376a:	f002 ff43 	bl	340165f4 <RCCEx_GetUARTCLKFreq>
3401376e:	60f8      	str	r0, [r7, #12]
      break;
34013770:	e02d      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUARTCLKFreq(LL_RCC_UART9_CLKSOURCE);
34013772:	4836      	ldr	r0, [pc, #216]	@ (3401384c <HAL_RCCEx_GetPeriphCLKFreq+0x914>)
34013774:	f002 ff3e 	bl	340165f4 <RCCEx_GetUARTCLKFreq>
34013778:	60f8      	str	r0, [r7, #12]
      break;
3401377a:	e028      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetUSARTCLKFreq(LL_RCC_USART10_CLKSOURCE);
3401377c:	4834      	ldr	r0, [pc, #208]	@ (34013850 <HAL_RCCEx_GetPeriphCLKFreq+0x918>)
3401377e:	f003 f963 	bl	34016a48 <RCCEx_GetUSARTCLKFreq>
34013782:	60f8      	str	r0, [r7, #12]
      break;
34013784:	e023      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY1CKREF_CLKSOURCE);
34013786:	4833      	ldr	r0, [pc, #204]	@ (34013854 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>)
34013788:	f003 fc3e 	bl	34017008 <RCCEx_GetOTGPHYCKREFCLKFreq>
3401378c:	60f8      	str	r0, [r7, #12]
      break;
3401378e:	e01e      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34013790:	4831      	ldr	r0, [pc, #196]	@ (34013858 <HAL_RCCEx_GetPeriphCLKFreq+0x920>)
34013792:	f003 fb83 	bl	34016e9c <RCCEx_GetOTGPHYCLKFreq>
34013796:	60f8      	str	r0, [r7, #12]
      break;
34013798:	e019      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCKREFCLKFreq(LL_RCC_OTGPHY2CKREF_CLKSOURCE);
3401379a:	4830      	ldr	r0, [pc, #192]	@ (3401385c <HAL_RCCEx_GetPeriphCLKFreq+0x924>)
3401379c:	f003 fc34 	bl	34017008 <RCCEx_GetOTGPHYCKREFCLKFreq>
340137a0:	60f8      	str	r0, [r7, #12]
      break;
340137a2:	e014      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
340137a4:	482e      	ldr	r0, [pc, #184]	@ (34013860 <HAL_RCCEx_GetPeriphCLKFreq+0x928>)
340137a6:	f003 fb79 	bl	34016e9c <RCCEx_GetOTGPHYCLKFreq>
340137aa:	60f8      	str	r0, [r7, #12]
      break;
340137ac:	e00f      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI1_CLKSOURCE);
340137ae:	482d      	ldr	r0, [pc, #180]	@ (34013864 <HAL_RCCEx_GetPeriphCLKFreq+0x92c>)
340137b0:	f003 fc7a 	bl	340170a8 <RCCEx_GetXSPICLKFreq>
340137b4:	60f8      	str	r0, [r7, #12]
      break;
340137b6:	e00a      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI2_CLKSOURCE);
340137b8:	482b      	ldr	r0, [pc, #172]	@ (34013868 <HAL_RCCEx_GetPeriphCLKFreq+0x930>)
340137ba:	f003 fc75 	bl	340170a8 <RCCEx_GetXSPICLKFreq>
340137be:	60f8      	str	r0, [r7, #12]
      break;
340137c0:	e005      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      frequency = RCCEx_GetXSPICLKFreq(LL_RCC_XSPI3_CLKSOURCE);
340137c2:	482a      	ldr	r0, [pc, #168]	@ (3401386c <HAL_RCCEx_GetPeriphCLKFreq+0x934>)
340137c4:	f003 fc70 	bl	340170a8 <RCCEx_GetXSPICLKFreq>
340137c8:	60f8      	str	r0, [r7, #12]
      break;
340137ca:	e000      	b.n	340137ce <HAL_RCCEx_GetPeriphCLKFreq+0x896>
      break;
340137cc:	bf00      	nop
  }

  return frequency;
340137ce:	68fb      	ldr	r3, [r7, #12]
}
340137d0:	4618      	mov	r0, r3
340137d2:	3714      	adds	r7, #20
340137d4:	46bd      	mov	sp, r7
340137d6:	bd90      	pop	{r4, r7, pc}
340137d8:	0700000c 	.word	0x0700000c
340137dc:	0700040c 	.word	0x0700040c
340137e0:	0700080c 	.word	0x0700080c
340137e4:	07000c0c 	.word	0x07000c0c
340137e8:	0700100c 	.word	0x0700100c
340137ec:	0700140c 	.word	0x0700140c
340137f0:	0700082c 	.word	0x0700082c
340137f4:	07000c2c 	.word	0x07000c2c
340137f8:	0700102c 	.word	0x0700102c
340137fc:	0700142c 	.word	0x0700142c
34013800:	0700182c 	.word	0x0700182c
34013804:	07001418 	.word	0x07001418
34013808:	07001818 	.word	0x07001818
3401380c:	0300001c 	.word	0x0300001c
34013810:	0300041c 	.word	0x0300041c
34013814:	07000420 	.word	0x07000420
34013818:	07000820 	.word	0x07000820
3401381c:	07000c20 	.word	0x07000c20
34013820:	07001020 	.word	0x07001020
34013824:	07001420 	.word	0x07001420
34013828:	07001820 	.word	0x07001820
3401382c:	07000030 	.word	0x07000030
34013830:	07000430 	.word	0x07000430
34013834:	07000830 	.word	0x07000830
34013838:	07000c30 	.word	0x07000c30
3401383c:	07001030 	.word	0x07001030
34013840:	07001430 	.word	0x07001430
34013844:	07001830 	.word	0x07001830
34013848:	07001c30 	.word	0x07001c30
3401384c:	07000034 	.word	0x07000034
34013850:	07000434 	.word	0x07000434
34013854:	01001014 	.word	0x01001014
34013858:	03000c14 	.word	0x03000c14
3401385c:	01001814 	.word	0x01001814
34013860:	03001414 	.word	0x03001414
34013864:	03000014 	.word	0x03000014
34013868:	03000414 	.word	0x03000414
3401386c:	03000814 	.word	0x03000814

34013870 <HAL_RCCEx_GetPLL1CLKFreq>:
  * @brief  Return PLL1 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL1 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL1CLKFreq(void)
{
34013870:	b5f0      	push	{r4, r5, r6, r7, lr}
34013872:	b087      	sub	sp, #28
34013874:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34013876:	2300      	movs	r3, #0
34013878:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL1_IsReady() != 0U)
3401387a:	f7fc fa05 	bl	3400fc88 <LL_RCC_PLL1_IsReady>
3401387e:	4603      	mov	r3, r0
34013880:	2b00      	cmp	r3, #0
34013882:	d02a      	beq.n	340138da <HAL_RCCEx_GetPLL1CLKFreq+0x6a>
  {
    if (LL_RCC_PLL1P_IsEnabled() != 0U)
34013884:	f7fc fa68 	bl	3400fd58 <LL_RCC_PLL1P_IsEnabled>
34013888:	4603      	mov	r3, r0
3401388a:	2b00      	cmp	r3, #0
3401388c:	d031      	beq.n	340138f2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
3401388e:	f7fc f9ed 	bl	3400fc6c <LL_RCC_PLL1_GetSource>
34013892:	4603      	mov	r3, r0
34013894:	4618      	mov	r0, r3
34013896:	f000 f957 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
3401389a:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
3401389c:	68bb      	ldr	r3, [r7, #8]
3401389e:	2b00      	cmp	r3, #0
340138a0:	d027      	beq.n	340138f2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL1_GetM();
340138a2:	f7fc fa29 	bl	3400fcf8 <LL_RCC_PLL1_GetM>
340138a6:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
340138a8:	687b      	ldr	r3, [r7, #4]
340138aa:	2b00      	cmp	r3, #0
340138ac:	d021      	beq.n	340138f2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL1_GetN(), LL_RCC_PLL1_GetFRACN(), \
340138ae:	f7fc fa13 	bl	3400fcd8 <LL_RCC_PLL1_GetN>
340138b2:	4605      	mov	r5, r0
340138b4:	f7fc fa64 	bl	3400fd80 <LL_RCC_PLL1_GetFRACN>
340138b8:	4606      	mov	r6, r0
340138ba:	f7fc fa2d 	bl	3400fd18 <LL_RCC_PLL1_GetP1>
340138be:	4604      	mov	r4, r0
340138c0:	f7fc fa3a 	bl	3400fd38 <LL_RCC_PLL1_GetP2>
340138c4:	4603      	mov	r3, r0
340138c6:	9301      	str	r3, [sp, #4]
340138c8:	9400      	str	r4, [sp, #0]
340138ca:	4633      	mov	r3, r6
340138cc:	462a      	mov	r2, r5
340138ce:	6879      	ldr	r1, [r7, #4]
340138d0:	68b8      	ldr	r0, [r7, #8]
340138d2:	f000 f997 	bl	34013c04 <RCCEx_CalcPLLFreq>
340138d6:	60f8      	str	r0, [r7, #12]
340138d8:	e00b      	b.n	340138f2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
                                            LL_RCC_PLL1_GetP1(), LL_RCC_PLL1_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL1_IsEnabledBypass() != 0U)
340138da:	f7fc f9e9 	bl	3400fcb0 <LL_RCC_PLL1_IsEnabledBypass>
340138de:	4603      	mov	r3, r0
340138e0:	2b00      	cmp	r3, #0
340138e2:	d006      	beq.n	340138f2 <HAL_RCCEx_GetPLL1CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL1_GetSource());
340138e4:	f7fc f9c2 	bl	3400fc6c <LL_RCC_PLL1_GetSource>
340138e8:	4603      	mov	r3, r0
340138ea:	4618      	mov	r0, r3
340138ec:	f000 f92c 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
340138f0:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
340138f2:	68fb      	ldr	r3, [r7, #12]
}
340138f4:	4618      	mov	r0, r3
340138f6:	3714      	adds	r7, #20
340138f8:	46bd      	mov	sp, r7
340138fa:	bdf0      	pop	{r4, r5, r6, r7, pc}

340138fc <HAL_RCCEx_GetPLL2CLKFreq>:
  * @brief  Return PLL2 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL2 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL2CLKFreq(void)
{
340138fc:	b5f0      	push	{r4, r5, r6, r7, lr}
340138fe:	b087      	sub	sp, #28
34013900:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34013902:	2300      	movs	r3, #0
34013904:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL2_IsReady() != 0U)
34013906:	f7fc fa57 	bl	3400fdb8 <LL_RCC_PLL2_IsReady>
3401390a:	4603      	mov	r3, r0
3401390c:	2b00      	cmp	r3, #0
3401390e:	d02a      	beq.n	34013966 <HAL_RCCEx_GetPLL2CLKFreq+0x6a>
  {
    if (LL_RCC_PLL2P_IsEnabled() != 0U)
34013910:	f7fc faba 	bl	3400fe88 <LL_RCC_PLL2P_IsEnabled>
34013914:	4603      	mov	r3, r0
34013916:	2b00      	cmp	r3, #0
34013918:	d031      	beq.n	3401397e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
3401391a:	f7fc fa3f 	bl	3400fd9c <LL_RCC_PLL2_GetSource>
3401391e:	4603      	mov	r3, r0
34013920:	4618      	mov	r0, r3
34013922:	f000 f911 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
34013926:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34013928:	68bb      	ldr	r3, [r7, #8]
3401392a:	2b00      	cmp	r3, #0
3401392c:	d027      	beq.n	3401397e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL2_GetM();
3401392e:	f7fc fa7b 	bl	3400fe28 <LL_RCC_PLL2_GetM>
34013932:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34013934:	687b      	ldr	r3, [r7, #4]
34013936:	2b00      	cmp	r3, #0
34013938:	d021      	beq.n	3401397e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL2_GetN(), LL_RCC_PLL2_GetFRACN(), \
3401393a:	f7fc fa65 	bl	3400fe08 <LL_RCC_PLL2_GetN>
3401393e:	4605      	mov	r5, r0
34013940:	f7fc fab6 	bl	3400feb0 <LL_RCC_PLL2_GetFRACN>
34013944:	4606      	mov	r6, r0
34013946:	f7fc fa7f 	bl	3400fe48 <LL_RCC_PLL2_GetP1>
3401394a:	4604      	mov	r4, r0
3401394c:	f7fc fa8c 	bl	3400fe68 <LL_RCC_PLL2_GetP2>
34013950:	4603      	mov	r3, r0
34013952:	9301      	str	r3, [sp, #4]
34013954:	9400      	str	r4, [sp, #0]
34013956:	4633      	mov	r3, r6
34013958:	462a      	mov	r2, r5
3401395a:	6879      	ldr	r1, [r7, #4]
3401395c:	68b8      	ldr	r0, [r7, #8]
3401395e:	f000 f951 	bl	34013c04 <RCCEx_CalcPLLFreq>
34013962:	60f8      	str	r0, [r7, #12]
34013964:	e00b      	b.n	3401397e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
                                            LL_RCC_PLL2_GetP1(), LL_RCC_PLL2_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL2_IsEnabledBypass() != 0U)
34013966:	f7fc fa3b 	bl	3400fde0 <LL_RCC_PLL2_IsEnabledBypass>
3401396a:	4603      	mov	r3, r0
3401396c:	2b00      	cmp	r3, #0
3401396e:	d006      	beq.n	3401397e <HAL_RCCEx_GetPLL2CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL2_GetSource());
34013970:	f7fc fa14 	bl	3400fd9c <LL_RCC_PLL2_GetSource>
34013974:	4603      	mov	r3, r0
34013976:	4618      	mov	r0, r3
34013978:	f000 f8e6 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
3401397c:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
3401397e:	68fb      	ldr	r3, [r7, #12]
}
34013980:	4618      	mov	r0, r3
34013982:	3714      	adds	r7, #20
34013984:	46bd      	mov	sp, r7
34013986:	bdf0      	pop	{r4, r5, r6, r7, pc}

34013988 <HAL_RCCEx_GetPLL3CLKFreq>:
  * @brief  Return PLL3 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL3 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL3CLKFreq(void)
{
34013988:	b5f0      	push	{r4, r5, r6, r7, lr}
3401398a:	b087      	sub	sp, #28
3401398c:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
3401398e:	2300      	movs	r3, #0
34013990:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL3_IsReady() != 0U)
34013992:	f7fc faa9 	bl	3400fee8 <LL_RCC_PLL3_IsReady>
34013996:	4603      	mov	r3, r0
34013998:	2b00      	cmp	r3, #0
3401399a:	d02a      	beq.n	340139f2 <HAL_RCCEx_GetPLL3CLKFreq+0x6a>
  {
    if (LL_RCC_PLL3P_IsEnabled() != 0U)
3401399c:	f7fc fb0c 	bl	3400ffb8 <LL_RCC_PLL3P_IsEnabled>
340139a0:	4603      	mov	r3, r0
340139a2:	2b00      	cmp	r3, #0
340139a4:	d031      	beq.n	34013a0a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
340139a6:	f7fc fa91 	bl	3400fecc <LL_RCC_PLL3_GetSource>
340139aa:	4603      	mov	r3, r0
340139ac:	4618      	mov	r0, r3
340139ae:	f000 f8cb 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
340139b2:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
340139b4:	68bb      	ldr	r3, [r7, #8]
340139b6:	2b00      	cmp	r3, #0
340139b8:	d027      	beq.n	34013a0a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL3_GetM();
340139ba:	f7fc facd 	bl	3400ff58 <LL_RCC_PLL3_GetM>
340139be:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
340139c0:	687b      	ldr	r3, [r7, #4]
340139c2:	2b00      	cmp	r3, #0
340139c4:	d021      	beq.n	34013a0a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL3_GetN(), LL_RCC_PLL3_GetFRACN(), \
340139c6:	f7fc fab7 	bl	3400ff38 <LL_RCC_PLL3_GetN>
340139ca:	4605      	mov	r5, r0
340139cc:	f7fc fb08 	bl	3400ffe0 <LL_RCC_PLL3_GetFRACN>
340139d0:	4606      	mov	r6, r0
340139d2:	f7fc fad1 	bl	3400ff78 <LL_RCC_PLL3_GetP1>
340139d6:	4604      	mov	r4, r0
340139d8:	f7fc fade 	bl	3400ff98 <LL_RCC_PLL3_GetP2>
340139dc:	4603      	mov	r3, r0
340139de:	9301      	str	r3, [sp, #4]
340139e0:	9400      	str	r4, [sp, #0]
340139e2:	4633      	mov	r3, r6
340139e4:	462a      	mov	r2, r5
340139e6:	6879      	ldr	r1, [r7, #4]
340139e8:	68b8      	ldr	r0, [r7, #8]
340139ea:	f000 f90b 	bl	34013c04 <RCCEx_CalcPLLFreq>
340139ee:	60f8      	str	r0, [r7, #12]
340139f0:	e00b      	b.n	34013a0a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
                                            LL_RCC_PLL3_GetP1(), LL_RCC_PLL3_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL3_IsEnabledBypass() != 0U)
340139f2:	f7fc fa8d 	bl	3400ff10 <LL_RCC_PLL3_IsEnabledBypass>
340139f6:	4603      	mov	r3, r0
340139f8:	2b00      	cmp	r3, #0
340139fa:	d006      	beq.n	34013a0a <HAL_RCCEx_GetPLL3CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL3_GetSource());
340139fc:	f7fc fa66 	bl	3400fecc <LL_RCC_PLL3_GetSource>
34013a00:	4603      	mov	r3, r0
34013a02:	4618      	mov	r0, r3
34013a04:	f000 f8a0 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
34013a08:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34013a0a:	68fb      	ldr	r3, [r7, #12]
}
34013a0c:	4618      	mov	r0, r3
34013a0e:	3714      	adds	r7, #20
34013a10:	46bd      	mov	sp, r7
34013a12:	bdf0      	pop	{r4, r5, r6, r7, pc}

34013a14 <HAL_RCCEx_GetPLL4CLKFreq>:
  * @brief  Return PLL4 clock frequency
  * @note   RCC_PERIPH_FREQUENCY_NO returned for non activated output or oscillator not ready
  * @retval PLL4 output clock frequency
  */
uint32_t HAL_RCCEx_GetPLL4CLKFreq(void)
{
34013a14:	b5f0      	push	{r4, r5, r6, r7, lr}
34013a16:	b087      	sub	sp, #28
34013a18:	af02      	add	r7, sp, #8
  uint32_t plloutputfreq = RCC_PERIPH_FREQUENCY_NO;
34013a1a:	2300      	movs	r3, #0
34013a1c:	60fb      	str	r3, [r7, #12]
  uint32_t divm;

  /* PLL_VCO = (HSE_VALUE, MSI_VALUE or HSI_VALUE/HSIDIV) / PLLM * (PLLN + FRACN)
     SYSCLK = PLL_VCO / PLLP1 / PLLP2
  */
  if (LL_RCC_PLL4_IsReady() != 0U)
34013a1e:	f7fc fafb 	bl	34010018 <LL_RCC_PLL4_IsReady>
34013a22:	4603      	mov	r3, r0
34013a24:	2b00      	cmp	r3, #0
34013a26:	d02a      	beq.n	34013a7e <HAL_RCCEx_GetPLL4CLKFreq+0x6a>
  {
    if (LL_RCC_PLL4P_IsEnabled() != 0U)
34013a28:	f7fc fb5e 	bl	340100e8 <LL_RCC_PLL4P_IsEnabled>
34013a2c:	4603      	mov	r3, r0
34013a2e:	2b00      	cmp	r3, #0
34013a30:	d031      	beq.n	34013a96 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
    {
      uint32_t pllinputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34013a32:	f7fc fae3 	bl	3400fffc <LL_RCC_PLL4_GetSource>
34013a36:	4603      	mov	r3, r0
34013a38:	4618      	mov	r0, r3
34013a3a:	f000 f885 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
34013a3e:	60b8      	str	r0, [r7, #8]

      if (pllinputfreq != RCC_PERIPH_FREQUENCY_NO)
34013a40:	68bb      	ldr	r3, [r7, #8]
34013a42:	2b00      	cmp	r3, #0
34013a44:	d027      	beq.n	34013a96 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
#if defined(USE_FPGA)
        /**** FPGA PLL input forced to 32MHz *****/
        pllinputfreq = RCC_PLL_SOURCE_FREQ;
        /*****************************************/
#endif /* USE_FPGA */
        divm = LL_RCC_PLL4_GetM();
34013a46:	f7fc fb1f 	bl	34010088 <LL_RCC_PLL4_GetM>
34013a4a:	6078      	str	r0, [r7, #4]

        if (divm != 0U)
34013a4c:	687b      	ldr	r3, [r7, #4]
34013a4e:	2b00      	cmp	r3, #0
34013a50:	d021      	beq.n	34013a96 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
        {
          plloutputfreq = RCCEx_CalcPLLFreq(pllinputfreq, divm, LL_RCC_PLL4_GetN(), LL_RCC_PLL4_GetFRACN(), \
34013a52:	f7fc fb09 	bl	34010068 <LL_RCC_PLL4_GetN>
34013a56:	4605      	mov	r5, r0
34013a58:	f7fc fb5a 	bl	34010110 <LL_RCC_PLL4_GetFRACN>
34013a5c:	4606      	mov	r6, r0
34013a5e:	f7fc fb23 	bl	340100a8 <LL_RCC_PLL4_GetP1>
34013a62:	4604      	mov	r4, r0
34013a64:	f7fc fb30 	bl	340100c8 <LL_RCC_PLL4_GetP2>
34013a68:	4603      	mov	r3, r0
34013a6a:	9301      	str	r3, [sp, #4]
34013a6c:	9400      	str	r4, [sp, #0]
34013a6e:	4633      	mov	r3, r6
34013a70:	462a      	mov	r2, r5
34013a72:	6879      	ldr	r1, [r7, #4]
34013a74:	68b8      	ldr	r0, [r7, #8]
34013a76:	f000 f8c5 	bl	34013c04 <RCCEx_CalcPLLFreq>
34013a7a:	60f8      	str	r0, [r7, #12]
34013a7c:	e00b      	b.n	34013a96 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
                                            LL_RCC_PLL4_GetP1(), LL_RCC_PLL4_GetP2());
        }
      }
    }
  }
  else if (LL_RCC_PLL4_IsEnabledBypass() != 0U)
34013a7e:	f7fc fadf 	bl	34010040 <LL_RCC_PLL4_IsEnabledBypass>
34013a82:	4603      	mov	r3, r0
34013a84:	2b00      	cmp	r3, #0
34013a86:	d006      	beq.n	34013a96 <HAL_RCCEx_GetPLL4CLKFreq+0x82>
  {
    plloutputfreq = RCCEx_GetPLLSourceFreq(LL_RCC_PLL4_GetSource());
34013a88:	f7fc fab8 	bl	3400fffc <LL_RCC_PLL4_GetSource>
34013a8c:	4603      	mov	r3, r0
34013a8e:	4618      	mov	r0, r3
34013a90:	f000 f85a 	bl	34013b48 <RCCEx_GetPLLSourceFreq>
34013a94:	60f8      	str	r0, [r7, #12]
  else
  {
    /* Nothing to do */
  }

  return plloutputfreq;
34013a96:	68fb      	ldr	r3, [r7, #12]
}
34013a98:	4618      	mov	r0, r3
34013a9a:	3714      	adds	r7, #20
34013a9c:	46bd      	mov	sp, r7
34013a9e:	bdf0      	pop	{r4, r5, r6, r7, pc}

34013aa0 <RCCEx_GetHCLKFreq>:
  * @brief  Return HCLK clock frequency
  * @param  SYSCLK_Frequency SYSCLK clock frequency
  * @retval HCLK clock frequency (in Hz)
  */
static uint32_t RCCEx_GetHCLKFreq(uint32_t SYSCLK_Frequency)
{
34013aa0:	b580      	push	{r7, lr}
34013aa2:	b082      	sub	sp, #8
34013aa4:	af00      	add	r7, sp, #0
34013aa6:	6078      	str	r0, [r7, #4]
  /* HCLK clock frequency */
  return LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
34013aa8:	f7fb fcca 	bl	3400f440 <LL_RCC_GetAHBPrescaler>
34013aac:	4603      	mov	r3, r0
34013aae:	0d1b      	lsrs	r3, r3, #20
34013ab0:	f003 0307 	and.w	r3, r3, #7
34013ab4:	687a      	ldr	r2, [r7, #4]
34013ab6:	fa22 f303 	lsr.w	r3, r2, r3
}
34013aba:	4618      	mov	r0, r3
34013abc:	3708      	adds	r7, #8
34013abe:	46bd      	mov	sp, r7
34013ac0:	bd80      	pop	{r7, pc}

34013ac2 <RCCEx_GetPCLK1Freq>:
  * @brief  Return PCLK1 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK1 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK1Freq(uint32_t HCLK_Frequency)
{
34013ac2:	b580      	push	{r7, lr}
34013ac4:	b082      	sub	sp, #8
34013ac6:	af00      	add	r7, sp, #0
34013ac8:	6078      	str	r0, [r7, #4]
  /* PCLK1 clock frequency */
  return LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
34013aca:	f7fb fcc7 	bl	3400f45c <LL_RCC_GetAPB1Prescaler>
34013ace:	4603      	mov	r3, r0
34013ad0:	f003 0307 	and.w	r3, r3, #7
34013ad4:	687a      	ldr	r2, [r7, #4]
34013ad6:	fa22 f303 	lsr.w	r3, r2, r3
}
34013ada:	4618      	mov	r0, r3
34013adc:	3708      	adds	r7, #8
34013ade:	46bd      	mov	sp, r7
34013ae0:	bd80      	pop	{r7, pc}

34013ae2 <RCCEx_GetPCLK2Freq>:
  * @brief  Return PCLK2 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK2 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK2Freq(uint32_t HCLK_Frequency)
{
34013ae2:	b580      	push	{r7, lr}
34013ae4:	b082      	sub	sp, #8
34013ae6:	af00      	add	r7, sp, #0
34013ae8:	6078      	str	r0, [r7, #4]
  /* PCLK2 clock frequency */
  return LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
34013aea:	f7fb fcc5 	bl	3400f478 <LL_RCC_GetAPB2Prescaler>
34013aee:	4603      	mov	r3, r0
34013af0:	091b      	lsrs	r3, r3, #4
34013af2:	f003 0307 	and.w	r3, r3, #7
34013af6:	687a      	ldr	r2, [r7, #4]
34013af8:	fa22 f303 	lsr.w	r3, r2, r3
}
34013afc:	4618      	mov	r0, r3
34013afe:	3708      	adds	r7, #8
34013b00:	46bd      	mov	sp, r7
34013b02:	bd80      	pop	{r7, pc}

34013b04 <RCCEx_GetPCLK4Freq>:
  * @brief  Return PCLK4 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK4 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK4Freq(uint32_t HCLK_Frequency)
{
34013b04:	b580      	push	{r7, lr}
34013b06:	b082      	sub	sp, #8
34013b08:	af00      	add	r7, sp, #0
34013b0a:	6078      	str	r0, [r7, #4]
  /* PCLK4 clock frequency */
  return LL_RCC_CALC_PCLK4_FREQ(HCLK_Frequency, LL_RCC_GetAPB4Prescaler());
34013b0c:	f7fb fcc2 	bl	3400f494 <LL_RCC_GetAPB4Prescaler>
34013b10:	4603      	mov	r3, r0
34013b12:	0b1b      	lsrs	r3, r3, #12
34013b14:	f003 0307 	and.w	r3, r3, #7
34013b18:	687a      	ldr	r2, [r7, #4]
34013b1a:	fa22 f303 	lsr.w	r3, r2, r3
}
34013b1e:	4618      	mov	r0, r3
34013b20:	3708      	adds	r7, #8
34013b22:	46bd      	mov	sp, r7
34013b24:	bd80      	pop	{r7, pc}

34013b26 <RCCEx_GetPCLK5Freq>:
  * @brief  Return PCLK5 clock frequency
  * @param  HCLK_Frequency HCLK clock frequency
  * @retval PCLK5 clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPCLK5Freq(uint32_t HCLK_Frequency)
{
34013b26:	b580      	push	{r7, lr}
34013b28:	b082      	sub	sp, #8
34013b2a:	af00      	add	r7, sp, #0
34013b2c:	6078      	str	r0, [r7, #4]
  /* PCLK5 clock frequency */
  return LL_RCC_CALC_PCLK5_FREQ(HCLK_Frequency, LL_RCC_GetAPB5Prescaler());
34013b2e:	f7fb fcbf 	bl	3400f4b0 <LL_RCC_GetAPB5Prescaler>
34013b32:	4603      	mov	r3, r0
34013b34:	0c1b      	lsrs	r3, r3, #16
34013b36:	f003 0307 	and.w	r3, r3, #7
34013b3a:	687a      	ldr	r2, [r7, #4]
34013b3c:	fa22 f303 	lsr.w	r3, r2, r3
}
34013b40:	4618      	mov	r0, r3
34013b42:	3708      	adds	r7, #8
34013b44:	46bd      	mov	sp, r7
34013b46:	bd80      	pop	{r7, pc}

34013b48 <RCCEx_GetPLLSourceFreq>:
  * @brief  Return PLL source clock frequency
  * @param  PLLsource PLL source clock
  * @retval PLL source clock frequency (in Hz)
  */
static uint32_t RCCEx_GetPLLSourceFreq(uint32_t PLLsource)
{
34013b48:	b580      	push	{r7, lr}
34013b4a:	b084      	sub	sp, #16
34013b4c:	af00      	add	r7, sp, #0
34013b4e:	6078      	str	r0, [r7, #4]
  uint32_t pllinputfreq = RCC_PERIPH_FREQUENCY_NO;
34013b50:	2300      	movs	r3, #0
34013b52:	60fb      	str	r3, [r7, #12]

  switch (PLLsource)
34013b54:	687b      	ldr	r3, [r7, #4]
34013b56:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013b5a:	d039      	beq.n	34013bd0 <RCCEx_GetPLLSourceFreq+0x88>
34013b5c:	687b      	ldr	r3, [r7, #4]
34013b5e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013b62:	d838      	bhi.n	34013bd6 <RCCEx_GetPLLSourceFreq+0x8e>
34013b64:	687b      	ldr	r3, [r7, #4]
34013b66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013b6a:	d029      	beq.n	34013bc0 <RCCEx_GetPLLSourceFreq+0x78>
34013b6c:	687b      	ldr	r3, [r7, #4]
34013b6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013b72:	d830      	bhi.n	34013bd6 <RCCEx_GetPLLSourceFreq+0x8e>
34013b74:	687b      	ldr	r3, [r7, #4]
34013b76:	2b00      	cmp	r3, #0
34013b78:	d004      	beq.n	34013b84 <RCCEx_GetPLLSourceFreq+0x3c>
34013b7a:	687b      	ldr	r3, [r7, #4]
34013b7c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013b80:	d00e      	beq.n	34013ba0 <RCCEx_GetPLLSourceFreq+0x58>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
      break;

    default:
      /* unexpected case */
      break;
34013b82:	e028      	b.n	34013bd6 <RCCEx_GetPLLSourceFreq+0x8e>
      if (LL_RCC_HSI_IsReady() != 0U)
34013b84:	f7fb fbfc 	bl	3400f380 <LL_RCC_HSI_IsReady>
34013b88:	4603      	mov	r3, r0
34013b8a:	2b00      	cmp	r3, #0
34013b8c:	d025      	beq.n	34013bda <RCCEx_GetPLLSourceFreq+0x92>
        pllinputfreq = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34013b8e:	f7fb fc09 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34013b92:	4603      	mov	r3, r0
34013b94:	09db      	lsrs	r3, r3, #7
34013b96:	4a16      	ldr	r2, [pc, #88]	@ (34013bf0 <RCCEx_GetPLLSourceFreq+0xa8>)
34013b98:	fa22 f303 	lsr.w	r3, r2, r3
34013b9c:	60fb      	str	r3, [r7, #12]
      break;
34013b9e:	e01c      	b.n	34013bda <RCCEx_GetPLLSourceFreq+0x92>
      if (LL_RCC_MSI_IsReady() != 0U)
34013ba0:	f7fb fc0e 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34013ba4:	4603      	mov	r3, r0
34013ba6:	2b00      	cmp	r3, #0
34013ba8:	d019      	beq.n	34013bde <RCCEx_GetPLLSourceFreq+0x96>
        if (LL_RCC_MSI_GetFrequency() == LL_RCC_MSI_FREQ_4MHZ)
34013baa:	f7fb fc1b 	bl	3400f3e4 <LL_RCC_MSI_GetFrequency>
34013bae:	4603      	mov	r3, r0
34013bb0:	2b00      	cmp	r3, #0
34013bb2:	d102      	bne.n	34013bba <RCCEx_GetPLLSourceFreq+0x72>
          pllinputfreq = MSI_VALUE;
34013bb4:	4b0f      	ldr	r3, [pc, #60]	@ (34013bf4 <RCCEx_GetPLLSourceFreq+0xac>)
34013bb6:	60fb      	str	r3, [r7, #12]
      break;
34013bb8:	e011      	b.n	34013bde <RCCEx_GetPLLSourceFreq+0x96>
          pllinputfreq = 16000000UL;
34013bba:	4b0f      	ldr	r3, [pc, #60]	@ (34013bf8 <RCCEx_GetPLLSourceFreq+0xb0>)
34013bbc:	60fb      	str	r3, [r7, #12]
      break;
34013bbe:	e00e      	b.n	34013bde <RCCEx_GetPLLSourceFreq+0x96>
      if (LL_RCC_HSE_IsReady() != 0U)
34013bc0:	f7fb fbcc 	bl	3400f35c <LL_RCC_HSE_IsReady>
34013bc4:	4603      	mov	r3, r0
34013bc6:	2b00      	cmp	r3, #0
34013bc8:	d00b      	beq.n	34013be2 <RCCEx_GetPLLSourceFreq+0x9a>
        pllinputfreq = HSE_VALUE;
34013bca:	4b0c      	ldr	r3, [pc, #48]	@ (34013bfc <RCCEx_GetPLLSourceFreq+0xb4>)
34013bcc:	60fb      	str	r3, [r7, #12]
      break;
34013bce:	e008      	b.n	34013be2 <RCCEx_GetPLLSourceFreq+0x9a>
      pllinputfreq = EXTERNAL_CLOCK_VALUE;
34013bd0:	4b0b      	ldr	r3, [pc, #44]	@ (34013c00 <RCCEx_GetPLLSourceFreq+0xb8>)
34013bd2:	60fb      	str	r3, [r7, #12]
      break;
34013bd4:	e006      	b.n	34013be4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34013bd6:	bf00      	nop
34013bd8:	e004      	b.n	34013be4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34013bda:	bf00      	nop
34013bdc:	e002      	b.n	34013be4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34013bde:	bf00      	nop
34013be0:	e000      	b.n	34013be4 <RCCEx_GetPLLSourceFreq+0x9c>
      break;
34013be2:	bf00      	nop
  }

  return pllinputfreq;
34013be4:	68fb      	ldr	r3, [r7, #12]
}
34013be6:	4618      	mov	r0, r3
34013be8:	3710      	adds	r7, #16
34013bea:	46bd      	mov	sp, r7
34013bec:	bd80      	pop	{r7, pc}
34013bee:	bf00      	nop
34013bf0:	03d09000 	.word	0x03d09000
34013bf4:	003d0900 	.word	0x003d0900
34013bf8:	00f42400 	.word	0x00f42400
34013bfc:	02dc6c00 	.word	0x02dc6c00
34013c00:	00bb8000 	.word	0x00bb8000

34013c04 <RCCEx_CalcPLLFreq>:
  * @param  P2     VCO output divider P2 between 1 and 7
  * @retval PLL clock frequency (in Hz)
  */
static uint32_t RCCEx_CalcPLLFreq(uint32_t PLLInputFreq, uint32_t M, uint32_t N, uint32_t FRACN, uint32_t P1,
                                  uint32_t P2)
{
34013c04:	b480      	push	{r7}
34013c06:	b087      	sub	sp, #28
34013c08:	af00      	add	r7, sp, #0
34013c0a:	60f8      	str	r0, [r7, #12]
34013c0c:	60b9      	str	r1, [r7, #8]
34013c0e:	607a      	str	r2, [r7, #4]
34013c10:	603b      	str	r3, [r7, #0]
  float_t freq;

  freq = ((float_t)PLLInputFreq * ((float_t)N + ((float_t)FRACN / (float_t)0x1000000))) / (float_t)M;
34013c12:	68fb      	ldr	r3, [r7, #12]
34013c14:	ee07 3a90 	vmov	s15, r3
34013c18:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34013c1c:	687b      	ldr	r3, [r7, #4]
34013c1e:	ee07 3a90 	vmov	s15, r3
34013c22:	eef8 6a67 	vcvt.f32.u32	s13, s15
34013c26:	683b      	ldr	r3, [r7, #0]
34013c28:	ee07 3a90 	vmov	s15, r3
34013c2c:	eeb8 6a67 	vcvt.f32.u32	s12, s15
34013c30:	eddf 5a19 	vldr	s11, [pc, #100]	@ 34013c98 <RCCEx_CalcPLLFreq+0x94>
34013c34:	eec6 7a25 	vdiv.f32	s15, s12, s11
34013c38:	ee76 7aa7 	vadd.f32	s15, s13, s15
34013c3c:	ee67 6a27 	vmul.f32	s13, s14, s15
34013c40:	68bb      	ldr	r3, [r7, #8]
34013c42:	ee07 3a90 	vmov	s15, r3
34013c46:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34013c4a:	eec6 7a87 	vdiv.f32	s15, s13, s14
34013c4e:	edc7 7a05 	vstr	s15, [r7, #20]

  freq = freq / (float_t)P1;
34013c52:	6a3b      	ldr	r3, [r7, #32]
34013c54:	ee07 3a90 	vmov	s15, r3
34013c58:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34013c5c:	edd7 6a05 	vldr	s13, [r7, #20]
34013c60:	eec6 7a87 	vdiv.f32	s15, s13, s14
34013c64:	edc7 7a05 	vstr	s15, [r7, #20]
  freq = freq / (float_t)P2;
34013c68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34013c6a:	ee07 3a90 	vmov	s15, r3
34013c6e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34013c72:	edd7 6a05 	vldr	s13, [r7, #20]
34013c76:	eec6 7a87 	vdiv.f32	s15, s13, s14
34013c7a:	edc7 7a05 	vstr	s15, [r7, #20]

  return (uint32_t)freq;
34013c7e:	edd7 7a05 	vldr	s15, [r7, #20]
34013c82:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34013c86:	ee17 3a90 	vmov	r3, s15
}
34013c8a:	4618      	mov	r0, r3
34013c8c:	371c      	adds	r7, #28
34013c8e:	46bd      	mov	sp, r7
34013c90:	f85d 7b04 	ldr.w	r7, [sp], #4
34013c94:	4770      	bx	lr
34013c96:	bf00      	nop
34013c98:	4b800000 	.word	0x4b800000

34013c9c <RCCEx_GetADCCLKFreq>:
  *         @arg @ref RCCEx_ADC_Clock_Source
  * @retval ADC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADCCLKFreq(uint32_t ADCxSource)
{
34013c9c:	b590      	push	{r4, r7, lr}
34013c9e:	b085      	sub	sp, #20
34013ca0:	af00      	add	r7, sp, #0
34013ca2:	6078      	str	r0, [r7, #4]
  uint32_t adc_frequency = RCC_PERIPH_FREQUENCY_NO;
34013ca4:	2300      	movs	r3, #0
34013ca6:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADCClockSource(ADCxSource))
34013ca8:	6878      	ldr	r0, [r7, #4]
34013caa:	f7fb fe1f 	bl	3400f8ec <LL_RCC_GetADCClockSource>
34013cae:	4603      	mov	r3, r0
34013cb0:	2b70      	cmp	r3, #112	@ 0x70
34013cb2:	f000 80d1 	beq.w	34013e58 <RCCEx_GetADCCLKFreq+0x1bc>
34013cb6:	2b70      	cmp	r3, #112	@ 0x70
34013cb8:	f200 80d8 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013cbc:	2b60      	cmp	r3, #96	@ 0x60
34013cbe:	f000 80c8 	beq.w	34013e52 <RCCEx_GetADCCLKFreq+0x1b6>
34013cc2:	2b60      	cmp	r3, #96	@ 0x60
34013cc4:	f200 80d2 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013cc8:	2b50      	cmp	r3, #80	@ 0x50
34013cca:	f000 80ac 	beq.w	34013e26 <RCCEx_GetADCCLKFreq+0x18a>
34013cce:	2b50      	cmp	r3, #80	@ 0x50
34013cd0:	f200 80cc 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013cd4:	2b40      	cmp	r3, #64	@ 0x40
34013cd6:	f000 80b4 	beq.w	34013e42 <RCCEx_GetADCCLKFreq+0x1a6>
34013cda:	2b40      	cmp	r3, #64	@ 0x40
34013cdc:	f200 80c6 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013ce0:	2b30      	cmp	r3, #48	@ 0x30
34013ce2:	d05d      	beq.n	34013da0 <RCCEx_GetADCCLKFreq+0x104>
34013ce4:	2b30      	cmp	r3, #48	@ 0x30
34013ce6:	f200 80c1 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013cea:	2b20      	cmp	r3, #32
34013cec:	d014      	beq.n	34013d18 <RCCEx_GetADCCLKFreq+0x7c>
34013cee:	2b20      	cmp	r3, #32
34013cf0:	f200 80bc 	bhi.w	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
34013cf4:	2b00      	cmp	r3, #0
34013cf6:	d002      	beq.n	34013cfe <RCCEx_GetADCCLKFreq+0x62>
34013cf8:	2b10      	cmp	r3, #16
34013cfa:	d008      	beq.n	34013d0e <RCCEx_GetADCCLKFreq+0x72>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34013cfc:	e0b6      	b.n	34013e6c <RCCEx_GetADCCLKFreq+0x1d0>
      adc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34013cfe:	f7fa ff3f 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34013d02:	4603      	mov	r3, r0
34013d04:	4618      	mov	r0, r3
34013d06:	f7ff fecb 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34013d0a:	60f8      	str	r0, [r7, #12]
      break;
34013d0c:	e0b7      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34013d0e:	2007      	movs	r0, #7
34013d10:	f000 f9b2 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34013d14:	60f8      	str	r0, [r7, #12]
      break;
34013d16:	e0b2      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      if (LL_RCC_IC7_IsEnabled() != 0U)
34013d18:	f7fc fad6 	bl	340102c8 <LL_RCC_IC7_IsEnabled>
34013d1c:	4603      	mov	r3, r0
34013d1e:	2b00      	cmp	r3, #0
34013d20:	f000 80a6 	beq.w	34013e70 <RCCEx_GetADCCLKFreq+0x1d4>
        ic_divider = LL_RCC_IC7_GetDivider();
34013d24:	f7fc faf2 	bl	3401030c <LL_RCC_IC7_GetDivider>
34013d28:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34013d2a:	f7fc fae1 	bl	340102f0 <LL_RCC_IC7_GetSource>
34013d2e:	4603      	mov	r3, r0
34013d30:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013d34:	d029      	beq.n	34013d8a <RCCEx_GetADCCLKFreq+0xee>
34013d36:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013d3a:	d82f      	bhi.n	34013d9c <RCCEx_GetADCCLKFreq+0x100>
34013d3c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013d40:	d01a      	beq.n	34013d78 <RCCEx_GetADCCLKFreq+0xdc>
34013d42:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013d46:	d829      	bhi.n	34013d9c <RCCEx_GetADCCLKFreq+0x100>
34013d48:	2b00      	cmp	r3, #0
34013d4a:	d003      	beq.n	34013d54 <RCCEx_GetADCCLKFreq+0xb8>
34013d4c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013d50:	d009      	beq.n	34013d66 <RCCEx_GetADCCLKFreq+0xca>
            break;
34013d52:	e023      	b.n	34013d9c <RCCEx_GetADCCLKFreq+0x100>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013d54:	f7ff fd8c 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34013d58:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013d5a:	68fa      	ldr	r2, [r7, #12]
34013d5c:	68bb      	ldr	r3, [r7, #8]
34013d5e:	fbb2 f3f3 	udiv	r3, r2, r3
34013d62:	60fb      	str	r3, [r7, #12]
            break;
34013d64:	e01b      	b.n	34013d9e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013d66:	f7ff fdc9 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34013d6a:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013d6c:	68fa      	ldr	r2, [r7, #12]
34013d6e:	68bb      	ldr	r3, [r7, #8]
34013d70:	fbb2 f3f3 	udiv	r3, r2, r3
34013d74:	60fb      	str	r3, [r7, #12]
            break;
34013d76:	e012      	b.n	34013d9e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013d78:	f7ff fe06 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34013d7c:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013d7e:	68fa      	ldr	r2, [r7, #12]
34013d80:	68bb      	ldr	r3, [r7, #8]
34013d82:	fbb2 f3f3 	udiv	r3, r2, r3
34013d86:	60fb      	str	r3, [r7, #12]
            break;
34013d88:	e009      	b.n	34013d9e <RCCEx_GetADCCLKFreq+0x102>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013d8a:	f7ff fe43 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34013d8e:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013d90:	68fa      	ldr	r2, [r7, #12]
34013d92:	68bb      	ldr	r3, [r7, #8]
34013d94:	fbb2 f3f3 	udiv	r3, r2, r3
34013d98:	60fb      	str	r3, [r7, #12]
            break;
34013d9a:	e000      	b.n	34013d9e <RCCEx_GetADCCLKFreq+0x102>
            break;
34013d9c:	bf00      	nop
      break;
34013d9e:	e067      	b.n	34013e70 <RCCEx_GetADCCLKFreq+0x1d4>
      if (LL_RCC_IC8_IsEnabled() != 0U)
34013da0:	f7fc fad2 	bl	34010348 <LL_RCC_IC8_IsEnabled>
34013da4:	4603      	mov	r3, r0
34013da6:	2b00      	cmp	r3, #0
34013da8:	d064      	beq.n	34013e74 <RCCEx_GetADCCLKFreq+0x1d8>
        ic_divider = LL_RCC_IC8_GetDivider();
34013daa:	f7fc faef 	bl	3401038c <LL_RCC_IC8_GetDivider>
34013dae:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34013db0:	f7fc fade 	bl	34010370 <LL_RCC_IC8_GetSource>
34013db4:	4603      	mov	r3, r0
34013db6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013dba:	d029      	beq.n	34013e10 <RCCEx_GetADCCLKFreq+0x174>
34013dbc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013dc0:	d82f      	bhi.n	34013e22 <RCCEx_GetADCCLKFreq+0x186>
34013dc2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013dc6:	d01a      	beq.n	34013dfe <RCCEx_GetADCCLKFreq+0x162>
34013dc8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013dcc:	d829      	bhi.n	34013e22 <RCCEx_GetADCCLKFreq+0x186>
34013dce:	2b00      	cmp	r3, #0
34013dd0:	d003      	beq.n	34013dda <RCCEx_GetADCCLKFreq+0x13e>
34013dd2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013dd6:	d009      	beq.n	34013dec <RCCEx_GetADCCLKFreq+0x150>
            break;
34013dd8:	e023      	b.n	34013e22 <RCCEx_GetADCCLKFreq+0x186>
            adc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013dda:	f7ff fd49 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34013dde:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013de0:	68fa      	ldr	r2, [r7, #12]
34013de2:	68bb      	ldr	r3, [r7, #8]
34013de4:	fbb2 f3f3 	udiv	r3, r2, r3
34013de8:	60fb      	str	r3, [r7, #12]
            break;
34013dea:	e01b      	b.n	34013e24 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013dec:	f7ff fd86 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34013df0:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013df2:	68fa      	ldr	r2, [r7, #12]
34013df4:	68bb      	ldr	r3, [r7, #8]
34013df6:	fbb2 f3f3 	udiv	r3, r2, r3
34013dfa:	60fb      	str	r3, [r7, #12]
            break;
34013dfc:	e012      	b.n	34013e24 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013dfe:	f7ff fdc3 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34013e02:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013e04:	68fa      	ldr	r2, [r7, #12]
34013e06:	68bb      	ldr	r3, [r7, #8]
34013e08:	fbb2 f3f3 	udiv	r3, r2, r3
34013e0c:	60fb      	str	r3, [r7, #12]
            break;
34013e0e:	e009      	b.n	34013e24 <RCCEx_GetADCCLKFreq+0x188>
            adc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013e10:	f7ff fe00 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34013e14:	60f8      	str	r0, [r7, #12]
            adc_frequency = adc_frequency / ic_divider;
34013e16:	68fa      	ldr	r2, [r7, #12]
34013e18:	68bb      	ldr	r3, [r7, #8]
34013e1a:	fbb2 f3f3 	udiv	r3, r2, r3
34013e1e:	60fb      	str	r3, [r7, #12]
            break;
34013e20:	e000      	b.n	34013e24 <RCCEx_GetADCCLKFreq+0x188>
            break;
34013e22:	bf00      	nop
      break;
34013e24:	e026      	b.n	34013e74 <RCCEx_GetADCCLKFreq+0x1d8>
      if (LL_RCC_HSI_IsReady() != 0U)
34013e26:	f7fb faab 	bl	3400f380 <LL_RCC_HSI_IsReady>
34013e2a:	4603      	mov	r3, r0
34013e2c:	2b00      	cmp	r3, #0
34013e2e:	d023      	beq.n	34013e78 <RCCEx_GetADCCLKFreq+0x1dc>
        adc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34013e30:	f7fb fab8 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34013e34:	4603      	mov	r3, r0
34013e36:	09db      	lsrs	r3, r3, #7
34013e38:	4a16      	ldr	r2, [pc, #88]	@ (34013e94 <RCCEx_GetADCCLKFreq+0x1f8>)
34013e3a:	fa22 f303 	lsr.w	r3, r2, r3
34013e3e:	60fb      	str	r3, [r7, #12]
      break;
34013e40:	e01a      	b.n	34013e78 <RCCEx_GetADCCLKFreq+0x1dc>
      if (LL_RCC_MSI_IsReady() != 0U)
34013e42:	f7fb fabd 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34013e46:	4603      	mov	r3, r0
34013e48:	2b00      	cmp	r3, #0
34013e4a:	d017      	beq.n	34013e7c <RCCEx_GetADCCLKFreq+0x1e0>
        adc_frequency = MSI_VALUE;
34013e4c:	4b12      	ldr	r3, [pc, #72]	@ (34013e98 <RCCEx_GetADCCLKFreq+0x1fc>)
34013e4e:	60fb      	str	r3, [r7, #12]
      break;
34013e50:	e014      	b.n	34013e7c <RCCEx_GetADCCLKFreq+0x1e0>
      adc_frequency = EXTERNAL_CLOCK_VALUE;
34013e52:	4b12      	ldr	r3, [pc, #72]	@ (34013e9c <RCCEx_GetADCCLKFreq+0x200>)
34013e54:	60fb      	str	r3, [r7, #12]
      break;
34013e56:	e012      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      adc_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
34013e58:	f7fa fe92 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34013e5c:	4604      	mov	r4, r0
34013e5e:	f7fb fef7 	bl	3400fc50 <LL_RCC_GetTIMPrescaler>
34013e62:	4603      	mov	r3, r0
34013e64:	fa24 f303 	lsr.w	r3, r4, r3
34013e68:	60fb      	str	r3, [r7, #12]
      break;
34013e6a:	e008      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34013e6c:	bf00      	nop
34013e6e:	e006      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34013e70:	bf00      	nop
34013e72:	e004      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34013e74:	bf00      	nop
34013e76:	e002      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34013e78:	bf00      	nop
34013e7a:	e000      	b.n	34013e7e <RCCEx_GetADCCLKFreq+0x1e2>
      break;
34013e7c:	bf00      	nop
  }

  return (adc_frequency / __HAL_RCC_GET_ADC_DIVIDER());
34013e7e:	f7fb fb4f 	bl	3400f520 <LL_RCC_GetADCPrescaler>
34013e82:	4603      	mov	r3, r0
34013e84:	3301      	adds	r3, #1
34013e86:	68fa      	ldr	r2, [r7, #12]
34013e88:	fbb2 f3f3 	udiv	r3, r2, r3
}
34013e8c:	4618      	mov	r0, r3
34013e8e:	3714      	adds	r7, #20
34013e90:	46bd      	mov	sp, r7
34013e92:	bd90      	pop	{r4, r7, pc}
34013e94:	03d09000 	.word	0x03d09000
34013e98:	003d0900 	.word	0x003d0900
34013e9c:	00bb8000 	.word	0x00bb8000

34013ea0 <RCCEx_GetADFCLKFreq>:
  *         @arg @ref RCCEx_ADF1_Clock_Source
  * @retval ADF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetADFCLKFreq(uint32_t ADFxSource)
{
34013ea0:	b590      	push	{r4, r7, lr}
34013ea2:	b085      	sub	sp, #20
34013ea4:	af00      	add	r7, sp, #0
34013ea6:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34013ea8:	2300      	movs	r3, #0
34013eaa:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetADFClockSource(ADFxSource))
34013eac:	6878      	ldr	r0, [r7, #4]
34013eae:	f7fb fd2f 	bl	3400f910 <LL_RCC_GetADFClockSource>
34013eb2:	4603      	mov	r3, r0
34013eb4:	2b07      	cmp	r3, #7
34013eb6:	f200 80ca 	bhi.w	3401404e <RCCEx_GetADFCLKFreq+0x1ae>
34013eba:	a201      	add	r2, pc, #4	@ (adr r2, 34013ec0 <RCCEx_GetADFCLKFreq+0x20>)
34013ebc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34013ec0:	34013ee1 	.word	0x34013ee1
34013ec4:	34013ef1 	.word	0x34013ef1
34013ec8:	34013efb 	.word	0x34013efb
34013ecc:	34013f83 	.word	0x34013f83
34013ed0:	34014025 	.word	0x34014025
34013ed4:	34014009 	.word	0x34014009
34013ed8:	34014035 	.word	0x34014035
34013edc:	3401403b 	.word	0x3401403b
  {
    case LL_RCC_ADF1_CLKSOURCE_HCLK:
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34013ee0:	f7fa fe4e 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34013ee4:	4603      	mov	r3, r0
34013ee6:	4618      	mov	r0, r3
34013ee8:	f7ff fdda 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34013eec:	60f8      	str	r0, [r7, #12]
      break;
34013eee:	e0b7      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_CLKP:
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34013ef0:	2007      	movs	r0, #7
34013ef2:	f000 f8c1 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34013ef6:	60f8      	str	r0, [r7, #12]
      break;
34013ef8:	e0b2      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34013efa:	f7fc f9e5 	bl	340102c8 <LL_RCC_IC7_IsEnabled>
34013efe:	4603      	mov	r3, r0
34013f00:	2b00      	cmp	r3, #0
34013f02:	f000 80a6 	beq.w	34014052 <RCCEx_GetADFCLKFreq+0x1b2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34013f06:	f7fc fa01 	bl	3401030c <LL_RCC_IC7_GetDivider>
34013f0a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34013f0c:	f7fc f9f0 	bl	340102f0 <LL_RCC_IC7_GetSource>
34013f10:	4603      	mov	r3, r0
34013f12:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013f16:	d029      	beq.n	34013f6c <RCCEx_GetADFCLKFreq+0xcc>
34013f18:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013f1c:	d82f      	bhi.n	34013f7e <RCCEx_GetADFCLKFreq+0xde>
34013f1e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013f22:	d01a      	beq.n	34013f5a <RCCEx_GetADFCLKFreq+0xba>
34013f24:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013f28:	d829      	bhi.n	34013f7e <RCCEx_GetADFCLKFreq+0xde>
34013f2a:	2b00      	cmp	r3, #0
34013f2c:	d003      	beq.n	34013f36 <RCCEx_GetADFCLKFreq+0x96>
34013f2e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013f32:	d009      	beq.n	34013f48 <RCCEx_GetADFCLKFreq+0xa8>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013f34:	e023      	b.n	34013f7e <RCCEx_GetADFCLKFreq+0xde>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013f36:	f7ff fc9b 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34013f3a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013f3c:	68fa      	ldr	r2, [r7, #12]
34013f3e:	68bb      	ldr	r3, [r7, #8]
34013f40:	fbb2 f3f3 	udiv	r3, r2, r3
34013f44:	60fb      	str	r3, [r7, #12]
            break;
34013f46:	e01b      	b.n	34013f80 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013f48:	f7ff fcd8 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34013f4c:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013f4e:	68fa      	ldr	r2, [r7, #12]
34013f50:	68bb      	ldr	r3, [r7, #8]
34013f52:	fbb2 f3f3 	udiv	r3, r2, r3
34013f56:	60fb      	str	r3, [r7, #12]
            break;
34013f58:	e012      	b.n	34013f80 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013f5a:	f7ff fd15 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34013f5e:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013f60:	68fa      	ldr	r2, [r7, #12]
34013f62:	68bb      	ldr	r3, [r7, #8]
34013f64:	fbb2 f3f3 	udiv	r3, r2, r3
34013f68:	60fb      	str	r3, [r7, #12]
            break;
34013f6a:	e009      	b.n	34013f80 <RCCEx_GetADFCLKFreq+0xe0>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013f6c:	f7ff fd52 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34013f70:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013f72:	68fa      	ldr	r2, [r7, #12]
34013f74:	68bb      	ldr	r3, [r7, #8]
34013f76:	fbb2 f3f3 	udiv	r3, r2, r3
34013f7a:	60fb      	str	r3, [r7, #12]
            break;
34013f7c:	e000      	b.n	34013f80 <RCCEx_GetADFCLKFreq+0xe0>
            break;
34013f7e:	bf00      	nop
        }
      }
      break;
34013f80:	e067      	b.n	34014052 <RCCEx_GetADFCLKFreq+0x1b2>

    case LL_RCC_ADF1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34013f82:	f7fc f9e1 	bl	34010348 <LL_RCC_IC8_IsEnabled>
34013f86:	4603      	mov	r3, r0
34013f88:	2b00      	cmp	r3, #0
34013f8a:	d064      	beq.n	34014056 <RCCEx_GetADFCLKFreq+0x1b6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34013f8c:	f7fc f9fe 	bl	3401038c <LL_RCC_IC8_GetDivider>
34013f90:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34013f92:	f7fc f9ed 	bl	34010370 <LL_RCC_IC8_GetSource>
34013f96:	4603      	mov	r3, r0
34013f98:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013f9c:	d029      	beq.n	34013ff2 <RCCEx_GetADFCLKFreq+0x152>
34013f9e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34013fa2:	d82f      	bhi.n	34014004 <RCCEx_GetADFCLKFreq+0x164>
34013fa4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013fa8:	d01a      	beq.n	34013fe0 <RCCEx_GetADFCLKFreq+0x140>
34013faa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34013fae:	d829      	bhi.n	34014004 <RCCEx_GetADFCLKFreq+0x164>
34013fb0:	2b00      	cmp	r3, #0
34013fb2:	d003      	beq.n	34013fbc <RCCEx_GetADFCLKFreq+0x11c>
34013fb4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34013fb8:	d009      	beq.n	34013fce <RCCEx_GetADFCLKFreq+0x12e>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            adf_frequency = adf_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34013fba:	e023      	b.n	34014004 <RCCEx_GetADFCLKFreq+0x164>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34013fbc:	f7ff fc58 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34013fc0:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013fc2:	68fa      	ldr	r2, [r7, #12]
34013fc4:	68bb      	ldr	r3, [r7, #8]
34013fc6:	fbb2 f3f3 	udiv	r3, r2, r3
34013fca:	60fb      	str	r3, [r7, #12]
            break;
34013fcc:	e01b      	b.n	34014006 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34013fce:	f7ff fc95 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34013fd2:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013fd4:	68fa      	ldr	r2, [r7, #12]
34013fd6:	68bb      	ldr	r3, [r7, #8]
34013fd8:	fbb2 f3f3 	udiv	r3, r2, r3
34013fdc:	60fb      	str	r3, [r7, #12]
            break;
34013fde:	e012      	b.n	34014006 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34013fe0:	f7ff fcd2 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34013fe4:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013fe6:	68fa      	ldr	r2, [r7, #12]
34013fe8:	68bb      	ldr	r3, [r7, #8]
34013fea:	fbb2 f3f3 	udiv	r3, r2, r3
34013fee:	60fb      	str	r3, [r7, #12]
            break;
34013ff0:	e009      	b.n	34014006 <RCCEx_GetADFCLKFreq+0x166>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34013ff2:	f7ff fd0f 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34013ff6:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34013ff8:	68fa      	ldr	r2, [r7, #12]
34013ffa:	68bb      	ldr	r3, [r7, #8]
34013ffc:	fbb2 f3f3 	udiv	r3, r2, r3
34014000:	60fb      	str	r3, [r7, #12]
            break;
34014002:	e000      	b.n	34014006 <RCCEx_GetADFCLKFreq+0x166>
            break;
34014004:	bf00      	nop
        }
      }
      break;
34014006:	e026      	b.n	34014056 <RCCEx_GetADFCLKFreq+0x1b6>

    case LL_RCC_ADF1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34014008:	f7fb f9ba 	bl	3400f380 <LL_RCC_HSI_IsReady>
3401400c:	4603      	mov	r3, r0
3401400e:	2b00      	cmp	r3, #0
34014010:	d023      	beq.n	3401405a <RCCEx_GetADFCLKFreq+0x1ba>
      {
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34014012:	f7fb f9c7 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34014016:	4603      	mov	r3, r0
34014018:	09db      	lsrs	r3, r3, #7
3401401a:	4a14      	ldr	r2, [pc, #80]	@ (3401406c <RCCEx_GetADFCLKFreq+0x1cc>)
3401401c:	fa22 f303 	lsr.w	r3, r2, r3
34014020:	60fb      	str	r3, [r7, #12]
      }
      break;
34014022:	e01a      	b.n	3401405a <RCCEx_GetADFCLKFreq+0x1ba>

    case LL_RCC_ADF1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34014024:	f7fb f9cc 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34014028:	4603      	mov	r3, r0
3401402a:	2b00      	cmp	r3, #0
3401402c:	d017      	beq.n	3401405e <RCCEx_GetADFCLKFreq+0x1be>
      {
        adf_frequency = MSI_VALUE;
3401402e:	4b10      	ldr	r3, [pc, #64]	@ (34014070 <RCCEx_GetADFCLKFreq+0x1d0>)
34014030:	60fb      	str	r3, [r7, #12]
      }
      break;
34014032:	e014      	b.n	3401405e <RCCEx_GetADFCLKFreq+0x1be>

    case LL_RCC_ADF1_CLKSOURCE_I2S_CKIN:
      adf_frequency = EXTERNAL_CLOCK_VALUE;
34014034:	4b0f      	ldr	r3, [pc, #60]	@ (34014074 <RCCEx_GetADFCLKFreq+0x1d4>)
34014036:	60fb      	str	r3, [r7, #12]
      break;
34014038:	e012      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>

    case LL_RCC_ADF1_CLKSOURCE_TIMG:
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
3401403a:	f7fa fda1 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
3401403e:	4604      	mov	r4, r0
34014040:	f7fb fe06 	bl	3400fc50 <LL_RCC_GetTIMPrescaler>
34014044:	4603      	mov	r3, r0
34014046:	fa24 f303 	lsr.w	r3, r4, r3
3401404a:	60fb      	str	r3, [r7, #12]
      break;
3401404c:	e008      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>

    default:
      /* Unexpected case */
      break;
3401404e:	bf00      	nop
34014050:	e006      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34014052:	bf00      	nop
34014054:	e004      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
34014056:	bf00      	nop
34014058:	e002      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3401405a:	bf00      	nop
3401405c:	e000      	b.n	34014060 <RCCEx_GetADFCLKFreq+0x1c0>
      break;
3401405e:	bf00      	nop
  }

  return adf_frequency;
34014060:	68fb      	ldr	r3, [r7, #12]
}
34014062:	4618      	mov	r0, r3
34014064:	3714      	adds	r7, #20
34014066:	46bd      	mov	sp, r7
34014068:	bd90      	pop	{r4, r7, pc}
3401406a:	bf00      	nop
3401406c:	03d09000 	.word	0x03d09000
34014070:	003d0900 	.word	0x003d0900
34014074:	00bb8000 	.word	0x00bb8000

34014078 <RCCEx_GetCLKPCLKFreq>:
  *         @arg @ref RCCEx_CLKP_Clock_Source
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCLKPCLKFreq(uint32_t CLKPxSource)
{
34014078:	b580      	push	{r7, lr}
3401407a:	b084      	sub	sp, #16
3401407c:	af00      	add	r7, sp, #0
3401407e:	6078      	str	r0, [r7, #4]
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
34014080:	2300      	movs	r3, #0
34014082:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  if (LL_RCC_CLKP_IsEnabled() == 1U)
34014084:	f7fc fc60 	bl	34010948 <LL_RCC_CLKP_IsEnabled>
34014088:	4603      	mov	r3, r0
3401408a:	2b01      	cmp	r3, #1
3401408c:	f040 81a5 	bne.w	340143da <RCCEx_GetCLKPCLKFreq+0x362>
  {
    switch (LL_RCC_GetCLKPClockSource(CLKPxSource))
34014090:	6878      	ldr	r0, [r7, #4]
34014092:	f7fb fc4f 	bl	3400f934 <LL_RCC_GetCLKPClockSource>
34014096:	4603      	mov	r3, r0
34014098:	2b07      	cmp	r3, #7
3401409a:	f200 818d 	bhi.w	340143b8 <RCCEx_GetCLKPCLKFreq+0x340>
3401409e:	a201      	add	r2, pc, #4	@ (adr r2, 340140a4 <RCCEx_GetCLKPCLKFreq+0x2c>)
340140a0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340140a4:	340140c5 	.word	0x340140c5
340140a8:	340140e3 	.word	0x340140e3
340140ac:	340140f5 	.word	0x340140f5
340140b0:	3401429f 	.word	0x3401429f
340140b4:	34014107 	.word	0x34014107
340140b8:	3401418f 	.word	0x3401418f
340140bc:	34014217 	.word	0x34014217
340140c0:	34014327 	.word	0x34014327
    {
      case LL_RCC_CLKP_CLKSOURCE_HSI:
        if (LL_RCC_HSI_IsReady() != 0U)
340140c4:	f7fb f95c 	bl	3400f380 <LL_RCC_HSI_IsReady>
340140c8:	4603      	mov	r3, r0
340140ca:	2b00      	cmp	r3, #0
340140cc:	f000 8176 	beq.w	340143bc <RCCEx_GetCLKPCLKFreq+0x344>
        {
          clkp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340140d0:	f7fb f968 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
340140d4:	4603      	mov	r3, r0
340140d6:	09db      	lsrs	r3, r3, #7
340140d8:	4aa1      	ldr	r2, [pc, #644]	@ (34014360 <RCCEx_GetCLKPCLKFreq+0x2e8>)
340140da:	fa22 f303 	lsr.w	r3, r2, r3
340140de:	60fb      	str	r3, [r7, #12]
        }
        break;
340140e0:	e16c      	b.n	340143bc <RCCEx_GetCLKPCLKFreq+0x344>

      case LL_RCC_CLKP_CLKSOURCE_MSI:
        if (LL_RCC_MSI_IsReady() != 0U)
340140e2:	f7fb f96d 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
340140e6:	4603      	mov	r3, r0
340140e8:	2b00      	cmp	r3, #0
340140ea:	f000 8169 	beq.w	340143c0 <RCCEx_GetCLKPCLKFreq+0x348>
        {
          clkp_frequency = MSI_VALUE;
340140ee:	4b9d      	ldr	r3, [pc, #628]	@ (34014364 <RCCEx_GetCLKPCLKFreq+0x2ec>)
340140f0:	60fb      	str	r3, [r7, #12]
        }
        break;
340140f2:	e165      	b.n	340143c0 <RCCEx_GetCLKPCLKFreq+0x348>

      case LL_RCC_CLKP_CLKSOURCE_HSE:
        if (LL_RCC_HSE_IsReady() != 0U)
340140f4:	f7fb f932 	bl	3400f35c <LL_RCC_HSE_IsReady>
340140f8:	4603      	mov	r3, r0
340140fa:	2b00      	cmp	r3, #0
340140fc:	f000 8162 	beq.w	340143c4 <RCCEx_GetCLKPCLKFreq+0x34c>
        {
          clkp_frequency = HSE_VALUE;
34014100:	4b99      	ldr	r3, [pc, #612]	@ (34014368 <RCCEx_GetCLKPCLKFreq+0x2f0>)
34014102:	60fb      	str	r3, [r7, #12]
        }
        break;
34014104:	e15e      	b.n	340143c4 <RCCEx_GetCLKPCLKFreq+0x34c>

      case LL_RCC_CLKP_CLKSOURCE_IC5:
        if (LL_RCC_IC5_IsEnabled() != 0U)
34014106:	f7fc f89f 	bl	34010248 <LL_RCC_IC5_IsEnabled>
3401410a:	4603      	mov	r3, r0
3401410c:	2b00      	cmp	r3, #0
3401410e:	f000 815b 	beq.w	340143c8 <RCCEx_GetCLKPCLKFreq+0x350>
        {
          ic_divider = LL_RCC_IC5_GetDivider();
34014112:	f7fc f8bb 	bl	3401028c <LL_RCC_IC5_GetDivider>
34014116:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC5_GetSource())
34014118:	f7fc f8aa 	bl	34010270 <LL_RCC_IC5_GetSource>
3401411c:	4603      	mov	r3, r0
3401411e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014122:	d029      	beq.n	34014178 <RCCEx_GetCLKPCLKFreq+0x100>
34014124:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014128:	d82f      	bhi.n	3401418a <RCCEx_GetCLKPCLKFreq+0x112>
3401412a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401412e:	d01a      	beq.n	34014166 <RCCEx_GetCLKPCLKFreq+0xee>
34014130:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014134:	d829      	bhi.n	3401418a <RCCEx_GetCLKPCLKFreq+0x112>
34014136:	2b00      	cmp	r3, #0
34014138:	d003      	beq.n	34014142 <RCCEx_GetCLKPCLKFreq+0xca>
3401413a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401413e:	d009      	beq.n	34014154 <RCCEx_GetCLKPCLKFreq+0xdc>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34014140:	e023      	b.n	3401418a <RCCEx_GetCLKPCLKFreq+0x112>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014142:	f7ff fb95 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014146:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014148:	68fa      	ldr	r2, [r7, #12]
3401414a:	68bb      	ldr	r3, [r7, #8]
3401414c:	fbb2 f3f3 	udiv	r3, r2, r3
34014150:	60fb      	str	r3, [r7, #12]
              break;
34014152:	e01b      	b.n	3401418c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014154:	f7ff fbd2 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014158:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401415a:	68fa      	ldr	r2, [r7, #12]
3401415c:	68bb      	ldr	r3, [r7, #8]
3401415e:	fbb2 f3f3 	udiv	r3, r2, r3
34014162:	60fb      	str	r3, [r7, #12]
              break;
34014164:	e012      	b.n	3401418c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014166:	f7ff fc0f 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401416a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401416c:	68fa      	ldr	r2, [r7, #12]
3401416e:	68bb      	ldr	r3, [r7, #8]
34014170:	fbb2 f3f3 	udiv	r3, r2, r3
34014174:	60fb      	str	r3, [r7, #12]
              break;
34014176:	e009      	b.n	3401418c <RCCEx_GetCLKPCLKFreq+0x114>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014178:	f7ff fc4c 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401417c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401417e:	68fa      	ldr	r2, [r7, #12]
34014180:	68bb      	ldr	r3, [r7, #8]
34014182:	fbb2 f3f3 	udiv	r3, r2, r3
34014186:	60fb      	str	r3, [r7, #12]
              break;
34014188:	e000      	b.n	3401418c <RCCEx_GetCLKPCLKFreq+0x114>
              break;
3401418a:	bf00      	nop
          }
        }
        break;
3401418c:	e11c      	b.n	340143c8 <RCCEx_GetCLKPCLKFreq+0x350>

      case LL_RCC_CLKP_CLKSOURCE_IC10:
        if (LL_RCC_IC10_IsEnabled() != 0U)
3401418e:	f7fc f95b 	bl	34010448 <LL_RCC_IC10_IsEnabled>
34014192:	4603      	mov	r3, r0
34014194:	2b00      	cmp	r3, #0
34014196:	f000 8119 	beq.w	340143cc <RCCEx_GetCLKPCLKFreq+0x354>
        {
          ic_divider = LL_RCC_IC10_GetDivider();
3401419a:	f7fc f977 	bl	3401048c <LL_RCC_IC10_GetDivider>
3401419e:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC10_GetSource())
340141a0:	f7fc f966 	bl	34010470 <LL_RCC_IC10_GetSource>
340141a4:	4603      	mov	r3, r0
340141a6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340141aa:	d029      	beq.n	34014200 <RCCEx_GetCLKPCLKFreq+0x188>
340141ac:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340141b0:	d82f      	bhi.n	34014212 <RCCEx_GetCLKPCLKFreq+0x19a>
340141b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340141b6:	d01a      	beq.n	340141ee <RCCEx_GetCLKPCLKFreq+0x176>
340141b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340141bc:	d829      	bhi.n	34014212 <RCCEx_GetCLKPCLKFreq+0x19a>
340141be:	2b00      	cmp	r3, #0
340141c0:	d003      	beq.n	340141ca <RCCEx_GetCLKPCLKFreq+0x152>
340141c2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340141c6:	d009      	beq.n	340141dc <RCCEx_GetCLKPCLKFreq+0x164>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340141c8:	e023      	b.n	34014212 <RCCEx_GetCLKPCLKFreq+0x19a>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340141ca:	f7ff fb51 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340141ce:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340141d0:	68fa      	ldr	r2, [r7, #12]
340141d2:	68bb      	ldr	r3, [r7, #8]
340141d4:	fbb2 f3f3 	udiv	r3, r2, r3
340141d8:	60fb      	str	r3, [r7, #12]
              break;
340141da:	e01b      	b.n	34014214 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340141dc:	f7ff fb8e 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340141e0:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340141e2:	68fa      	ldr	r2, [r7, #12]
340141e4:	68bb      	ldr	r3, [r7, #8]
340141e6:	fbb2 f3f3 	udiv	r3, r2, r3
340141ea:	60fb      	str	r3, [r7, #12]
              break;
340141ec:	e012      	b.n	34014214 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340141ee:	f7ff fbcb 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340141f2:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340141f4:	68fa      	ldr	r2, [r7, #12]
340141f6:	68bb      	ldr	r3, [r7, #8]
340141f8:	fbb2 f3f3 	udiv	r3, r2, r3
340141fc:	60fb      	str	r3, [r7, #12]
              break;
340141fe:	e009      	b.n	34014214 <RCCEx_GetCLKPCLKFreq+0x19c>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014200:	f7ff fc08 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014204:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014206:	68fa      	ldr	r2, [r7, #12]
34014208:	68bb      	ldr	r3, [r7, #8]
3401420a:	fbb2 f3f3 	udiv	r3, r2, r3
3401420e:	60fb      	str	r3, [r7, #12]
              break;
34014210:	e000      	b.n	34014214 <RCCEx_GetCLKPCLKFreq+0x19c>
              break;
34014212:	bf00      	nop
          }
        }
        break;
34014214:	e0da      	b.n	340143cc <RCCEx_GetCLKPCLKFreq+0x354>

      case LL_RCC_CLKP_CLKSOURCE_IC15:
        if (LL_RCC_IC15_IsEnabled() != 0U)
34014216:	f7fc fa17 	bl	34010648 <LL_RCC_IC15_IsEnabled>
3401421a:	4603      	mov	r3, r0
3401421c:	2b00      	cmp	r3, #0
3401421e:	f000 80d7 	beq.w	340143d0 <RCCEx_GetCLKPCLKFreq+0x358>
        {
          ic_divider = LL_RCC_IC15_GetDivider();
34014222:	f7fc fa33 	bl	3401068c <LL_RCC_IC15_GetDivider>
34014226:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC15_GetSource())
34014228:	f7fc fa22 	bl	34010670 <LL_RCC_IC15_GetSource>
3401422c:	4603      	mov	r3, r0
3401422e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014232:	d029      	beq.n	34014288 <RCCEx_GetCLKPCLKFreq+0x210>
34014234:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014238:	d82f      	bhi.n	3401429a <RCCEx_GetCLKPCLKFreq+0x222>
3401423a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401423e:	d01a      	beq.n	34014276 <RCCEx_GetCLKPCLKFreq+0x1fe>
34014240:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014244:	d829      	bhi.n	3401429a <RCCEx_GetCLKPCLKFreq+0x222>
34014246:	2b00      	cmp	r3, #0
34014248:	d003      	beq.n	34014252 <RCCEx_GetCLKPCLKFreq+0x1da>
3401424a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401424e:	d009      	beq.n	34014264 <RCCEx_GetCLKPCLKFreq+0x1ec>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
34014250:	e023      	b.n	3401429a <RCCEx_GetCLKPCLKFreq+0x222>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014252:	f7ff fb0d 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014256:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014258:	68fa      	ldr	r2, [r7, #12]
3401425a:	68bb      	ldr	r3, [r7, #8]
3401425c:	fbb2 f3f3 	udiv	r3, r2, r3
34014260:	60fb      	str	r3, [r7, #12]
              break;
34014262:	e01b      	b.n	3401429c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014264:	f7ff fb4a 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014268:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401426a:	68fa      	ldr	r2, [r7, #12]
3401426c:	68bb      	ldr	r3, [r7, #8]
3401426e:	fbb2 f3f3 	udiv	r3, r2, r3
34014272:	60fb      	str	r3, [r7, #12]
              break;
34014274:	e012      	b.n	3401429c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014276:	f7ff fb87 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401427a:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401427c:	68fa      	ldr	r2, [r7, #12]
3401427e:	68bb      	ldr	r3, [r7, #8]
34014280:	fbb2 f3f3 	udiv	r3, r2, r3
34014284:	60fb      	str	r3, [r7, #12]
              break;
34014286:	e009      	b.n	3401429c <RCCEx_GetCLKPCLKFreq+0x224>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014288:	f7ff fbc4 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401428c:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
3401428e:	68fa      	ldr	r2, [r7, #12]
34014290:	68bb      	ldr	r3, [r7, #8]
34014292:	fbb2 f3f3 	udiv	r3, r2, r3
34014296:	60fb      	str	r3, [r7, #12]
              break;
34014298:	e000      	b.n	3401429c <RCCEx_GetCLKPCLKFreq+0x224>
              break;
3401429a:	bf00      	nop
          }
        }
        break;
3401429c:	e098      	b.n	340143d0 <RCCEx_GetCLKPCLKFreq+0x358>

      case LL_RCC_CLKP_CLKSOURCE_IC19:
        if (LL_RCC_IC19_IsEnabled() != 0U)
3401429e:	f7fc fad3 	bl	34010848 <LL_RCC_IC19_IsEnabled>
340142a2:	4603      	mov	r3, r0
340142a4:	2b00      	cmp	r3, #0
340142a6:	f000 8095 	beq.w	340143d4 <RCCEx_GetCLKPCLKFreq+0x35c>
        {
          ic_divider = LL_RCC_IC19_GetDivider();
340142aa:	f7fc faef 	bl	3401088c <LL_RCC_IC19_GetDivider>
340142ae:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC19_GetSource())
340142b0:	f7fc fade 	bl	34010870 <LL_RCC_IC19_GetSource>
340142b4:	4603      	mov	r3, r0
340142b6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340142ba:	d029      	beq.n	34014310 <RCCEx_GetCLKPCLKFreq+0x298>
340142bc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340142c0:	d82f      	bhi.n	34014322 <RCCEx_GetCLKPCLKFreq+0x2aa>
340142c2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340142c6:	d01a      	beq.n	340142fe <RCCEx_GetCLKPCLKFreq+0x286>
340142c8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340142cc:	d829      	bhi.n	34014322 <RCCEx_GetCLKPCLKFreq+0x2aa>
340142ce:	2b00      	cmp	r3, #0
340142d0:	d003      	beq.n	340142da <RCCEx_GetCLKPCLKFreq+0x262>
340142d2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340142d6:	d009      	beq.n	340142ec <RCCEx_GetCLKPCLKFreq+0x274>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
340142d8:	e023      	b.n	34014322 <RCCEx_GetCLKPCLKFreq+0x2aa>
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340142da:	f7ff fac9 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340142de:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340142e0:	68fa      	ldr	r2, [r7, #12]
340142e2:	68bb      	ldr	r3, [r7, #8]
340142e4:	fbb2 f3f3 	udiv	r3, r2, r3
340142e8:	60fb      	str	r3, [r7, #12]
              break;
340142ea:	e01b      	b.n	34014324 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340142ec:	f7ff fb06 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340142f0:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340142f2:	68fa      	ldr	r2, [r7, #12]
340142f4:	68bb      	ldr	r3, [r7, #8]
340142f6:	fbb2 f3f3 	udiv	r3, r2, r3
340142fa:	60fb      	str	r3, [r7, #12]
              break;
340142fc:	e012      	b.n	34014324 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340142fe:	f7ff fb43 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014302:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014304:	68fa      	ldr	r2, [r7, #12]
34014306:	68bb      	ldr	r3, [r7, #8]
34014308:	fbb2 f3f3 	udiv	r3, r2, r3
3401430c:	60fb      	str	r3, [r7, #12]
              break;
3401430e:	e009      	b.n	34014324 <RCCEx_GetCLKPCLKFreq+0x2ac>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014310:	f7ff fb80 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014314:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014316:	68fa      	ldr	r2, [r7, #12]
34014318:	68bb      	ldr	r3, [r7, #8]
3401431a:	fbb2 f3f3 	udiv	r3, r2, r3
3401431e:	60fb      	str	r3, [r7, #12]
              break;
34014320:	e000      	b.n	34014324 <RCCEx_GetCLKPCLKFreq+0x2ac>
              break;
34014322:	bf00      	nop
          }
        }
        break;
34014324:	e056      	b.n	340143d4 <RCCEx_GetCLKPCLKFreq+0x35c>

      case LL_RCC_CLKP_CLKSOURCE_IC20:
        if (LL_RCC_IC20_IsEnabled() != 0U)
34014326:	f7fc facf 	bl	340108c8 <LL_RCC_IC20_IsEnabled>
3401432a:	4603      	mov	r3, r0
3401432c:	2b00      	cmp	r3, #0
3401432e:	d053      	beq.n	340143d8 <RCCEx_GetCLKPCLKFreq+0x360>
        {
          ic_divider = LL_RCC_IC20_GetDivider();
34014330:	f7fc faec 	bl	3401090c <LL_RCC_IC20_GetDivider>
34014334:	60b8      	str	r0, [r7, #8]
          switch (LL_RCC_IC20_GetSource())
34014336:	f7fc fadb 	bl	340108f0 <LL_RCC_IC20_GetSource>
3401433a:	4603      	mov	r3, r0
3401433c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014340:	d02f      	beq.n	340143a2 <RCCEx_GetCLKPCLKFreq+0x32a>
34014342:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014346:	d835      	bhi.n	340143b4 <RCCEx_GetCLKPCLKFreq+0x33c>
34014348:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401434c:	d020      	beq.n	34014390 <RCCEx_GetCLKPCLKFreq+0x318>
3401434e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014352:	d82f      	bhi.n	340143b4 <RCCEx_GetCLKPCLKFreq+0x33c>
34014354:	2b00      	cmp	r3, #0
34014356:	d009      	beq.n	3401436c <RCCEx_GetCLKPCLKFreq+0x2f4>
34014358:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401435c:	d00f      	beq.n	3401437e <RCCEx_GetCLKPCLKFreq+0x306>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
              clkp_frequency = clkp_frequency / ic_divider;
              break;
            default:
              /* Unexpected case */
              break;
3401435e:	e029      	b.n	340143b4 <RCCEx_GetCLKPCLKFreq+0x33c>
34014360:	03d09000 	.word	0x03d09000
34014364:	003d0900 	.word	0x003d0900
34014368:	02dc6c00 	.word	0x02dc6c00
              clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401436c:	f7ff fa80 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014370:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014372:	68fa      	ldr	r2, [r7, #12]
34014374:	68bb      	ldr	r3, [r7, #8]
34014376:	fbb2 f3f3 	udiv	r3, r2, r3
3401437a:	60fb      	str	r3, [r7, #12]
              break;
3401437c:	e01b      	b.n	340143b6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401437e:	f7ff fabd 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014382:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014384:	68fa      	ldr	r2, [r7, #12]
34014386:	68bb      	ldr	r3, [r7, #8]
34014388:	fbb2 f3f3 	udiv	r3, r2, r3
3401438c:	60fb      	str	r3, [r7, #12]
              break;
3401438e:	e012      	b.n	340143b6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014390:	f7ff fafa 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014394:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
34014396:	68fa      	ldr	r2, [r7, #12]
34014398:	68bb      	ldr	r3, [r7, #8]
3401439a:	fbb2 f3f3 	udiv	r3, r2, r3
3401439e:	60fb      	str	r3, [r7, #12]
              break;
340143a0:	e009      	b.n	340143b6 <RCCEx_GetCLKPCLKFreq+0x33e>
              clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340143a2:	f7ff fb37 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340143a6:	60f8      	str	r0, [r7, #12]
              clkp_frequency = clkp_frequency / ic_divider;
340143a8:	68fa      	ldr	r2, [r7, #12]
340143aa:	68bb      	ldr	r3, [r7, #8]
340143ac:	fbb2 f3f3 	udiv	r3, r2, r3
340143b0:	60fb      	str	r3, [r7, #12]
              break;
340143b2:	e000      	b.n	340143b6 <RCCEx_GetCLKPCLKFreq+0x33e>
              break;
340143b4:	bf00      	nop
          }
        }
        break;
340143b6:	e00f      	b.n	340143d8 <RCCEx_GetCLKPCLKFreq+0x360>

      default:
        /* Unexpected case */
        break;
340143b8:	bf00      	nop
340143ba:	e00e      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143bc:	bf00      	nop
340143be:	e00c      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143c0:	bf00      	nop
340143c2:	e00a      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143c4:	bf00      	nop
340143c6:	e008      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143c8:	bf00      	nop
340143ca:	e006      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143cc:	bf00      	nop
340143ce:	e004      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143d0:	bf00      	nop
340143d2:	e002      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143d4:	bf00      	nop
340143d6:	e000      	b.n	340143da <RCCEx_GetCLKPCLKFreq+0x362>
        break;
340143d8:	bf00      	nop
    }
  }

  return clkp_frequency;
340143da:	68fb      	ldr	r3, [r7, #12]
}
340143dc:	4618      	mov	r0, r3
340143de:	3710      	adds	r7, #16
340143e0:	46bd      	mov	sp, r7
340143e2:	bd80      	pop	{r7, pc}

340143e4 <RCCEx_GetCSICLKFreq>:
  * @brief  Return CSI clock frequency
  * @retval CLKP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetCSICLKFreq(void)
{
340143e4:	b580      	push	{r7, lr}
340143e6:	b082      	sub	sp, #8
340143e8:	af00      	add	r7, sp, #0
  uint32_t clkp_frequency = RCC_PERIPH_FREQUENCY_NO;
340143ea:	2300      	movs	r3, #0
340143ec:	607b      	str	r3, [r7, #4]

  if (LL_RCC_IC18_IsEnabled() != 0U)
340143ee:	f7fc f9eb 	bl	340107c8 <LL_RCC_IC18_IsEnabled>
340143f2:	4603      	mov	r3, r0
340143f4:	2b00      	cmp	r3, #0
340143f6:	d03c      	beq.n	34014472 <RCCEx_GetCSICLKFreq+0x8e>
  {
    uint32_t ic_divider = LL_RCC_IC18_GetDivider();
340143f8:	f7fc fa08 	bl	3401080c <LL_RCC_IC18_GetDivider>
340143fc:	6038      	str	r0, [r7, #0]
    switch (LL_RCC_IC18_GetSource())
340143fe:	f7fc f9f7 	bl	340107f0 <LL_RCC_IC18_GetSource>
34014402:	4603      	mov	r3, r0
34014404:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014408:	d029      	beq.n	3401445e <RCCEx_GetCSICLKFreq+0x7a>
3401440a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401440e:	d82f      	bhi.n	34014470 <RCCEx_GetCSICLKFreq+0x8c>
34014410:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014414:	d01a      	beq.n	3401444c <RCCEx_GetCSICLKFreq+0x68>
34014416:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401441a:	d829      	bhi.n	34014470 <RCCEx_GetCSICLKFreq+0x8c>
3401441c:	2b00      	cmp	r3, #0
3401441e:	d003      	beq.n	34014428 <RCCEx_GetCSICLKFreq+0x44>
34014420:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014424:	d009      	beq.n	3401443a <RCCEx_GetCSICLKFreq+0x56>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
        clkp_frequency = clkp_frequency / ic_divider;
        break;
      default:
        /* Unexpected case */
        break;
34014426:	e023      	b.n	34014470 <RCCEx_GetCSICLKFreq+0x8c>
        clkp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014428:	f7ff fa22 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
3401442c:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
3401442e:	687a      	ldr	r2, [r7, #4]
34014430:	683b      	ldr	r3, [r7, #0]
34014432:	fbb2 f3f3 	udiv	r3, r2, r3
34014436:	607b      	str	r3, [r7, #4]
        break;
34014438:	e01b      	b.n	34014472 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401443a:	f7ff fa5f 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401443e:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34014440:	687a      	ldr	r2, [r7, #4]
34014442:	683b      	ldr	r3, [r7, #0]
34014444:	fbb2 f3f3 	udiv	r3, r2, r3
34014448:	607b      	str	r3, [r7, #4]
        break;
3401444a:	e012      	b.n	34014472 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401444c:	f7ff fa9c 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014450:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34014452:	687a      	ldr	r2, [r7, #4]
34014454:	683b      	ldr	r3, [r7, #0]
34014456:	fbb2 f3f3 	udiv	r3, r2, r3
3401445a:	607b      	str	r3, [r7, #4]
        break;
3401445c:	e009      	b.n	34014472 <RCCEx_GetCSICLKFreq+0x8e>
        clkp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401445e:	f7ff fad9 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014462:	6078      	str	r0, [r7, #4]
        clkp_frequency = clkp_frequency / ic_divider;
34014464:	687a      	ldr	r2, [r7, #4]
34014466:	683b      	ldr	r3, [r7, #0]
34014468:	fbb2 f3f3 	udiv	r3, r2, r3
3401446c:	607b      	str	r3, [r7, #4]
        break;
3401446e:	e000      	b.n	34014472 <RCCEx_GetCSICLKFreq+0x8e>
        break;
34014470:	bf00      	nop
    }
  }

  return clkp_frequency;
34014472:	687b      	ldr	r3, [r7, #4]
}
34014474:	4618      	mov	r0, r3
34014476:	3708      	adds	r7, #8
34014478:	46bd      	mov	sp, r7
3401447a:	bd80      	pop	{r7, pc}

3401447c <RCCEx_GetDCMIPPCLKFreq>:
  *         @arg @ref RCCEx_DCMIPP_Clock_Source
  * @retval DCMIPP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetDCMIPPCLKFreq(uint32_t DCMIPPxSource)
{
3401447c:	b580      	push	{r7, lr}
3401447e:	b084      	sub	sp, #16
34014480:	af00      	add	r7, sp, #0
34014482:	6078      	str	r0, [r7, #4]
  uint32_t dcmipp_frequency = RCC_PERIPH_FREQUENCY_NO;
34014484:	2300      	movs	r3, #0
34014486:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetDCMIPPClockSource(DCMIPPxSource))
34014488:	6878      	ldr	r0, [r7, #4]
3401448a:	f7fb fa65 	bl	3400f958 <LL_RCC_GetDCMIPPClockSource>
3401448e:	4603      	mov	r3, r0
34014490:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34014494:	d062      	beq.n	3401455c <RCCEx_GetDCMIPPCLKFreq+0xe0>
34014496:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
3401449a:	d86d      	bhi.n	34014578 <RCCEx_GetDCMIPPCLKFreq+0xfc>
3401449c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340144a0:	d019      	beq.n	340144d6 <RCCEx_GetDCMIPPCLKFreq+0x5a>
340144a2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340144a6:	d867      	bhi.n	34014578 <RCCEx_GetDCMIPPCLKFreq+0xfc>
340144a8:	2b00      	cmp	r3, #0
340144aa:	d003      	beq.n	340144b4 <RCCEx_GetDCMIPPCLKFreq+0x38>
340144ac:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
340144b0:	d00c      	beq.n	340144cc <RCCEx_GetDCMIPPCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
340144b2:	e061      	b.n	34014578 <RCCEx_GetDCMIPPCLKFreq+0xfc>
      dcmipp_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340144b4:	f7fa fb64 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340144b8:	4603      	mov	r3, r0
340144ba:	4618      	mov	r0, r3
340144bc:	f7ff faf0 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340144c0:	4603      	mov	r3, r0
340144c2:	4618      	mov	r0, r3
340144c4:	f7ff fb2f 	bl	34013b26 <RCCEx_GetPCLK5Freq>
340144c8:	60f8      	str	r0, [r7, #12]
      break;
340144ca:	e05a      	b.n	34014582 <RCCEx_GetDCMIPPCLKFreq+0x106>
      dcmipp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340144cc:	2007      	movs	r0, #7
340144ce:	f7ff fdd3 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340144d2:	60f8      	str	r0, [r7, #12]
      break;
340144d4:	e055      	b.n	34014582 <RCCEx_GetDCMIPPCLKFreq+0x106>
      if (LL_RCC_IC17_IsEnabled() != 0U)
340144d6:	f7fc f937 	bl	34010748 <LL_RCC_IC17_IsEnabled>
340144da:	4603      	mov	r3, r0
340144dc:	2b00      	cmp	r3, #0
340144de:	d04d      	beq.n	3401457c <RCCEx_GetDCMIPPCLKFreq+0x100>
        ic_divider = LL_RCC_IC17_GetDivider();
340144e0:	f7fc f954 	bl	3401078c <LL_RCC_IC17_GetDivider>
340144e4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC17_GetSource())
340144e6:	f7fc f943 	bl	34010770 <LL_RCC_IC17_GetSource>
340144ea:	4603      	mov	r3, r0
340144ec:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340144f0:	d029      	beq.n	34014546 <RCCEx_GetDCMIPPCLKFreq+0xca>
340144f2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340144f6:	d82f      	bhi.n	34014558 <RCCEx_GetDCMIPPCLKFreq+0xdc>
340144f8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340144fc:	d01a      	beq.n	34014534 <RCCEx_GetDCMIPPCLKFreq+0xb8>
340144fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014502:	d829      	bhi.n	34014558 <RCCEx_GetDCMIPPCLKFreq+0xdc>
34014504:	2b00      	cmp	r3, #0
34014506:	d003      	beq.n	34014510 <RCCEx_GetDCMIPPCLKFreq+0x94>
34014508:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401450c:	d009      	beq.n	34014522 <RCCEx_GetDCMIPPCLKFreq+0xa6>
            break;
3401450e:	e023      	b.n	34014558 <RCCEx_GetDCMIPPCLKFreq+0xdc>
            dcmipp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014510:	f7ff f9ae 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014514:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34014516:	68fa      	ldr	r2, [r7, #12]
34014518:	68bb      	ldr	r3, [r7, #8]
3401451a:	fbb2 f3f3 	udiv	r3, r2, r3
3401451e:	60fb      	str	r3, [r7, #12]
            break;
34014520:	e01b      	b.n	3401455a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014522:	f7ff f9eb 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014526:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
34014528:	68fa      	ldr	r2, [r7, #12]
3401452a:	68bb      	ldr	r3, [r7, #8]
3401452c:	fbb2 f3f3 	udiv	r3, r2, r3
34014530:	60fb      	str	r3, [r7, #12]
            break;
34014532:	e012      	b.n	3401455a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014534:	f7ff fa28 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014538:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
3401453a:	68fa      	ldr	r2, [r7, #12]
3401453c:	68bb      	ldr	r3, [r7, #8]
3401453e:	fbb2 f3f3 	udiv	r3, r2, r3
34014542:	60fb      	str	r3, [r7, #12]
            break;
34014544:	e009      	b.n	3401455a <RCCEx_GetDCMIPPCLKFreq+0xde>
            dcmipp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014546:	f7ff fa65 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401454a:	60f8      	str	r0, [r7, #12]
            dcmipp_frequency = dcmipp_frequency / ic_divider;
3401454c:	68fa      	ldr	r2, [r7, #12]
3401454e:	68bb      	ldr	r3, [r7, #8]
34014550:	fbb2 f3f3 	udiv	r3, r2, r3
34014554:	60fb      	str	r3, [r7, #12]
            break;
34014556:	e000      	b.n	3401455a <RCCEx_GetDCMIPPCLKFreq+0xde>
            break;
34014558:	bf00      	nop
      break;
3401455a:	e00f      	b.n	3401457c <RCCEx_GetDCMIPPCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
3401455c:	f7fa ff10 	bl	3400f380 <LL_RCC_HSI_IsReady>
34014560:	4603      	mov	r3, r0
34014562:	2b00      	cmp	r3, #0
34014564:	d00c      	beq.n	34014580 <RCCEx_GetDCMIPPCLKFreq+0x104>
        dcmipp_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34014566:	f7fa ff1d 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
3401456a:	4603      	mov	r3, r0
3401456c:	09db      	lsrs	r3, r3, #7
3401456e:	4a07      	ldr	r2, [pc, #28]	@ (3401458c <RCCEx_GetDCMIPPCLKFreq+0x110>)
34014570:	fa22 f303 	lsr.w	r3, r2, r3
34014574:	60fb      	str	r3, [r7, #12]
      break;
34014576:	e003      	b.n	34014580 <RCCEx_GetDCMIPPCLKFreq+0x104>
      break;
34014578:	bf00      	nop
3401457a:	e002      	b.n	34014582 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
3401457c:	bf00      	nop
3401457e:	e000      	b.n	34014582 <RCCEx_GetDCMIPPCLKFreq+0x106>
      break;
34014580:	bf00      	nop
  }

  return dcmipp_frequency;
34014582:	68fb      	ldr	r3, [r7, #12]
}
34014584:	4618      	mov	r0, r3
34014586:	3710      	adds	r7, #16
34014588:	46bd      	mov	sp, r7
3401458a:	bd80      	pop	{r7, pc}
3401458c:	03d09000 	.word	0x03d09000

34014590 <RCCEx_GetETH1CLKFreq>:
  *         @arg @ref RCCEx_ETH1_Clock_Source
  * @retval ETH1 clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1CLKFreq(uint32_t ETH1xSource)
{
34014590:	b580      	push	{r7, lr}
34014592:	b084      	sub	sp, #16
34014594:	af00      	add	r7, sp, #0
34014596:	6078      	str	r0, [r7, #4]
  uint32_t eth1_frequency = RCC_PERIPH_FREQUENCY_NO;
34014598:	2300      	movs	r3, #0
3401459a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHClockSource(ETH1xSource))
3401459c:	6878      	ldr	r0, [r7, #4]
3401459e:	f7fb f9ed 	bl	3400f97c <LL_RCC_GetETHClockSource>
340145a2:	4603      	mov	r3, r0
340145a4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
340145a8:	d05e      	beq.n	34014668 <RCCEx_GetETH1CLKFreq+0xd8>
340145aa:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
340145ae:	d863      	bhi.n	34014678 <RCCEx_GetETH1CLKFreq+0xe8>
340145b0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340145b4:	d015      	beq.n	340145e2 <RCCEx_GetETH1CLKFreq+0x52>
340145b6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
340145ba:	d85d      	bhi.n	34014678 <RCCEx_GetETH1CLKFreq+0xe8>
340145bc:	2b00      	cmp	r3, #0
340145be:	d003      	beq.n	340145c8 <RCCEx_GetETH1CLKFreq+0x38>
340145c0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340145c4:	d008      	beq.n	340145d8 <RCCEx_GetETH1CLKFreq+0x48>
      }
      break;

    default:
      /* Unexpected case */
      break;
340145c6:	e057      	b.n	34014678 <RCCEx_GetETH1CLKFreq+0xe8>
      eth1_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340145c8:	f7fa fada 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340145cc:	4603      	mov	r3, r0
340145ce:	4618      	mov	r0, r3
340145d0:	f7ff fa66 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340145d4:	60f8      	str	r0, [r7, #12]
      break;
340145d6:	e054      	b.n	34014682 <RCCEx_GetETH1CLKFreq+0xf2>
      eth1_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340145d8:	2007      	movs	r0, #7
340145da:	f7ff fd4d 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340145de:	60f8      	str	r0, [r7, #12]
      break;
340145e0:	e04f      	b.n	34014682 <RCCEx_GetETH1CLKFreq+0xf2>
      if (LL_RCC_IC12_IsEnabled() != 0U)
340145e2:	f7fb ff71 	bl	340104c8 <LL_RCC_IC12_IsEnabled>
340145e6:	4603      	mov	r3, r0
340145e8:	2b00      	cmp	r3, #0
340145ea:	d047      	beq.n	3401467c <RCCEx_GetETH1CLKFreq+0xec>
        ic_divider = LL_RCC_IC12_GetDivider();
340145ec:	f7fb ff8e 	bl	3401050c <LL_RCC_IC12_GetDivider>
340145f0:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC12_GetSource())
340145f2:	f7fb ff7d 	bl	340104f0 <LL_RCC_IC12_GetSource>
340145f6:	4603      	mov	r3, r0
340145f8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340145fc:	d029      	beq.n	34014652 <RCCEx_GetETH1CLKFreq+0xc2>
340145fe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014602:	d82f      	bhi.n	34014664 <RCCEx_GetETH1CLKFreq+0xd4>
34014604:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014608:	d01a      	beq.n	34014640 <RCCEx_GetETH1CLKFreq+0xb0>
3401460a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401460e:	d829      	bhi.n	34014664 <RCCEx_GetETH1CLKFreq+0xd4>
34014610:	2b00      	cmp	r3, #0
34014612:	d003      	beq.n	3401461c <RCCEx_GetETH1CLKFreq+0x8c>
34014614:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014618:	d009      	beq.n	3401462e <RCCEx_GetETH1CLKFreq+0x9e>
            break;
3401461a:	e023      	b.n	34014664 <RCCEx_GetETH1CLKFreq+0xd4>
            eth1_frequency = HAL_RCCEx_GetPLL1CLKFreq();
3401461c:	f7ff f928 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014620:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34014622:	68fa      	ldr	r2, [r7, #12]
34014624:	68bb      	ldr	r3, [r7, #8]
34014626:	fbb2 f3f3 	udiv	r3, r2, r3
3401462a:	60fb      	str	r3, [r7, #12]
            break;
3401462c:	e01b      	b.n	34014666 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401462e:	f7ff f965 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014632:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34014634:	68fa      	ldr	r2, [r7, #12]
34014636:	68bb      	ldr	r3, [r7, #8]
34014638:	fbb2 f3f3 	udiv	r3, r2, r3
3401463c:	60fb      	str	r3, [r7, #12]
            break;
3401463e:	e012      	b.n	34014666 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014640:	f7ff f9a2 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014644:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34014646:	68fa      	ldr	r2, [r7, #12]
34014648:	68bb      	ldr	r3, [r7, #8]
3401464a:	fbb2 f3f3 	udiv	r3, r2, r3
3401464e:	60fb      	str	r3, [r7, #12]
            break;
34014650:	e009      	b.n	34014666 <RCCEx_GetETH1CLKFreq+0xd6>
            eth1_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014652:	f7ff f9df 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014656:	60f8      	str	r0, [r7, #12]
            eth1_frequency = eth1_frequency / ic_divider;
34014658:	68fa      	ldr	r2, [r7, #12]
3401465a:	68bb      	ldr	r3, [r7, #8]
3401465c:	fbb2 f3f3 	udiv	r3, r2, r3
34014660:	60fb      	str	r3, [r7, #12]
            break;
34014662:	e000      	b.n	34014666 <RCCEx_GetETH1CLKFreq+0xd6>
            break;
34014664:	bf00      	nop
      break;
34014666:	e009      	b.n	3401467c <RCCEx_GetETH1CLKFreq+0xec>
      if (LL_RCC_HSE_IsReady() != 0U)
34014668:	f7fa fe78 	bl	3400f35c <LL_RCC_HSE_IsReady>
3401466c:	4603      	mov	r3, r0
3401466e:	2b00      	cmp	r3, #0
34014670:	d006      	beq.n	34014680 <RCCEx_GetETH1CLKFreq+0xf0>
        eth1_frequency = HSE_VALUE;
34014672:	4b06      	ldr	r3, [pc, #24]	@ (3401468c <RCCEx_GetETH1CLKFreq+0xfc>)
34014674:	60fb      	str	r3, [r7, #12]
      break;
34014676:	e003      	b.n	34014680 <RCCEx_GetETH1CLKFreq+0xf0>
      break;
34014678:	bf00      	nop
3401467a:	e002      	b.n	34014682 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
3401467c:	bf00      	nop
3401467e:	e000      	b.n	34014682 <RCCEx_GetETH1CLKFreq+0xf2>
      break;
34014680:	bf00      	nop
  }

  return eth1_frequency;
34014682:	68fb      	ldr	r3, [r7, #12]
}
34014684:	4618      	mov	r0, r3
34014686:	3710      	adds	r7, #16
34014688:	46bd      	mov	sp, r7
3401468a:	bd80      	pop	{r7, pc}
3401468c:	02dc6c00 	.word	0x02dc6c00

34014690 <RCCEx_GetETH1PTPCLKFreq>:
  *         @arg @ref RCCEx_ETH1_PTP_Clock_Source
  * @retval ETH1PTP clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetETH1PTPCLKFreq(uint32_t ETH1PTPxSource)
{
34014690:	b580      	push	{r7, lr}
34014692:	b084      	sub	sp, #16
34014694:	af00      	add	r7, sp, #0
34014696:	6078      	str	r0, [r7, #4]
  uint32_t eth1ptp_frequency = RCC_PERIPH_FREQUENCY_NO;
34014698:	2300      	movs	r3, #0
3401469a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetETHPTPClockSource(ETH1PTPxSource))
3401469c:	6878      	ldr	r0, [r7, #4]
3401469e:	f7fb f97f 	bl	3400f9a0 <LL_RCC_GetETHPTPClockSource>
340146a2:	4603      	mov	r3, r0
340146a4:	2b03      	cmp	r3, #3
340146a6:	d863      	bhi.n	34014770 <RCCEx_GetETH1PTPCLKFreq+0xe0>
340146a8:	a201      	add	r2, pc, #4	@ (adr r2, 340146b0 <RCCEx_GetETH1PTPCLKFreq+0x20>)
340146aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340146ae:	bf00      	nop
340146b0:	340146c1 	.word	0x340146c1
340146b4:	340146d1 	.word	0x340146d1
340146b8:	340146db 	.word	0x340146db
340146bc:	34014761 	.word	0x34014761
  {
    case LL_RCC_ETH1PTP_CLKSOURCE_HCLK:
      eth1ptp_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340146c0:	f7fa fa5e 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340146c4:	4603      	mov	r3, r0
340146c6:	4618      	mov	r0, r3
340146c8:	f7ff f9ea 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340146cc:	60f8      	str	r0, [r7, #12]
      break;
340146ce:	e054      	b.n	3401477a <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_CLKP:
      eth1ptp_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340146d0:	2007      	movs	r0, #7
340146d2:	f7ff fcd1 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340146d6:	60f8      	str	r0, [r7, #12]
      break;
340146d8:	e04f      	b.n	3401477a <RCCEx_GetETH1PTPCLKFreq+0xea>

    case LL_RCC_ETH1PTP_CLKSOURCE_IC13:
      if (LL_RCC_IC13_IsEnabled() != 0U)
340146da:	f7fb ff35 	bl	34010548 <LL_RCC_IC13_IsEnabled>
340146de:	4603      	mov	r3, r0
340146e0:	2b00      	cmp	r3, #0
340146e2:	d047      	beq.n	34014774 <RCCEx_GetETH1PTPCLKFreq+0xe4>
      {
        ic_divider = LL_RCC_IC13_GetDivider();
340146e4:	f7fb ff52 	bl	3401058c <LL_RCC_IC13_GetDivider>
340146e8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC13_GetSource())
340146ea:	f7fb ff41 	bl	34010570 <LL_RCC_IC13_GetSource>
340146ee:	4603      	mov	r3, r0
340146f0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340146f4:	d029      	beq.n	3401474a <RCCEx_GetETH1PTPCLKFreq+0xba>
340146f6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340146fa:	d82f      	bhi.n	3401475c <RCCEx_GetETH1PTPCLKFreq+0xcc>
340146fc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014700:	d01a      	beq.n	34014738 <RCCEx_GetETH1PTPCLKFreq+0xa8>
34014702:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014706:	d829      	bhi.n	3401475c <RCCEx_GetETH1PTPCLKFreq+0xcc>
34014708:	2b00      	cmp	r3, #0
3401470a:	d003      	beq.n	34014714 <RCCEx_GetETH1PTPCLKFreq+0x84>
3401470c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014710:	d009      	beq.n	34014726 <RCCEx_GetETH1PTPCLKFreq+0x96>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014712:	e023      	b.n	3401475c <RCCEx_GetETH1PTPCLKFreq+0xcc>
            eth1ptp_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014714:	f7ff f8ac 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014718:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3401471a:	68fa      	ldr	r2, [r7, #12]
3401471c:	68bb      	ldr	r3, [r7, #8]
3401471e:	fbb2 f3f3 	udiv	r3, r2, r3
34014722:	60fb      	str	r3, [r7, #12]
            break;
34014724:	e01b      	b.n	3401475e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014726:	f7ff f8e9 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401472a:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3401472c:	68fa      	ldr	r2, [r7, #12]
3401472e:	68bb      	ldr	r3, [r7, #8]
34014730:	fbb2 f3f3 	udiv	r3, r2, r3
34014734:	60fb      	str	r3, [r7, #12]
            break;
34014736:	e012      	b.n	3401475e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014738:	f7ff f926 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401473c:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
3401473e:	68fa      	ldr	r2, [r7, #12]
34014740:	68bb      	ldr	r3, [r7, #8]
34014742:	fbb2 f3f3 	udiv	r3, r2, r3
34014746:	60fb      	str	r3, [r7, #12]
            break;
34014748:	e009      	b.n	3401475e <RCCEx_GetETH1PTPCLKFreq+0xce>
            eth1ptp_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401474a:	f7ff f963 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401474e:	60f8      	str	r0, [r7, #12]
            eth1ptp_frequency = eth1ptp_frequency / ic_divider;
34014750:	68fa      	ldr	r2, [r7, #12]
34014752:	68bb      	ldr	r3, [r7, #8]
34014754:	fbb2 f3f3 	udiv	r3, r2, r3
34014758:	60fb      	str	r3, [r7, #12]
            break;
3401475a:	e000      	b.n	3401475e <RCCEx_GetETH1PTPCLKFreq+0xce>
            break;
3401475c:	bf00      	nop
        }
      }
      break;
3401475e:	e009      	b.n	34014774 <RCCEx_GetETH1PTPCLKFreq+0xe4>

    case LL_RCC_ETH1PTP_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34014760:	f7fa fdfc 	bl	3400f35c <LL_RCC_HSE_IsReady>
34014764:	4603      	mov	r3, r0
34014766:	2b00      	cmp	r3, #0
34014768:	d006      	beq.n	34014778 <RCCEx_GetETH1PTPCLKFreq+0xe8>
      {
        eth1ptp_frequency = HSE_VALUE;
3401476a:	4b0a      	ldr	r3, [pc, #40]	@ (34014794 <RCCEx_GetETH1PTPCLKFreq+0x104>)
3401476c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401476e:	e003      	b.n	34014778 <RCCEx_GetETH1PTPCLKFreq+0xe8>

    default:
      /* Unexpected case */
      break;
34014770:	bf00      	nop
34014772:	e002      	b.n	3401477a <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34014774:	bf00      	nop
34014776:	e000      	b.n	3401477a <RCCEx_GetETH1PTPCLKFreq+0xea>
      break;
34014778:	bf00      	nop
  }

  return (eth1ptp_frequency / __HAL_RCC_GET_ETH1PTP_DIVIDER());
3401477a:	f7fa ff4d 	bl	3400f618 <LL_RCC_GetETH1PTPDivider>
3401477e:	4603      	mov	r3, r0
34014780:	091b      	lsrs	r3, r3, #4
34014782:	3301      	adds	r3, #1
34014784:	68fa      	ldr	r2, [r7, #12]
34014786:	fbb2 f3f3 	udiv	r3, r2, r3
}
3401478a:	4618      	mov	r0, r3
3401478c:	3710      	adds	r7, #16
3401478e:	46bd      	mov	sp, r7
34014790:	bd80      	pop	{r7, pc}
34014792:	bf00      	nop
34014794:	02dc6c00 	.word	0x02dc6c00

34014798 <RCCEx_GetFDCANCLKFreq>:
  *         @arg @ref RCCEx_FDCAN_Clock_Source
  * @retval FDCAN clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFDCANCLKFreq(uint32_t FDCANxSource)
{
34014798:	b580      	push	{r7, lr}
3401479a:	b084      	sub	sp, #16
3401479c:	af00      	add	r7, sp, #0
3401479e:	6078      	str	r0, [r7, #4]
  uint32_t fdcan_frequency = RCC_PERIPH_FREQUENCY_NO;
340147a0:	2300      	movs	r3, #0
340147a2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFDCANClockSource(FDCANxSource))
340147a4:	6878      	ldr	r0, [r7, #4]
340147a6:	f7fb f90d 	bl	3400f9c4 <LL_RCC_GetFDCANClockSource>
340147aa:	4603      	mov	r3, r0
340147ac:	2b03      	cmp	r3, #3
340147ae:	d867      	bhi.n	34014880 <RCCEx_GetFDCANCLKFreq+0xe8>
340147b0:	a201      	add	r2, pc, #4	@ (adr r2, 340147b8 <RCCEx_GetFDCANCLKFreq+0x20>)
340147b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
340147b6:	bf00      	nop
340147b8:	340147c9 	.word	0x340147c9
340147bc:	340147e1 	.word	0x340147e1
340147c0:	340147eb 	.word	0x340147eb
340147c4:	34014871 	.word	0x34014871
  {
    case LL_RCC_FDCAN_CLKSOURCE_PCLK1:
      fdcan_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340147c8:	f7fa f9da 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340147cc:	4603      	mov	r3, r0
340147ce:	4618      	mov	r0, r3
340147d0:	f7ff f966 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340147d4:	4603      	mov	r3, r0
340147d6:	4618      	mov	r0, r3
340147d8:	f7ff f973 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
340147dc:	60f8      	str	r0, [r7, #12]
      break;
340147de:	e054      	b.n	3401488a <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_CLKP:
      fdcan_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340147e0:	2007      	movs	r0, #7
340147e2:	f7ff fc49 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340147e6:	60f8      	str	r0, [r7, #12]
      break;
340147e8:	e04f      	b.n	3401488a <RCCEx_GetFDCANCLKFreq+0xf2>

    case LL_RCC_FDCAN_CLKSOURCE_IC19:
      if (LL_RCC_IC19_IsEnabled() != 0U)
340147ea:	f7fc f82d 	bl	34010848 <LL_RCC_IC19_IsEnabled>
340147ee:	4603      	mov	r3, r0
340147f0:	2b00      	cmp	r3, #0
340147f2:	d047      	beq.n	34014884 <RCCEx_GetFDCANCLKFreq+0xec>
      {
        ic_divider = LL_RCC_IC19_GetDivider();
340147f4:	f7fc f84a 	bl	3401088c <LL_RCC_IC19_GetDivider>
340147f8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC19_GetSource())
340147fa:	f7fc f839 	bl	34010870 <LL_RCC_IC19_GetSource>
340147fe:	4603      	mov	r3, r0
34014800:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014804:	d029      	beq.n	3401485a <RCCEx_GetFDCANCLKFreq+0xc2>
34014806:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401480a:	d82f      	bhi.n	3401486c <RCCEx_GetFDCANCLKFreq+0xd4>
3401480c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014810:	d01a      	beq.n	34014848 <RCCEx_GetFDCANCLKFreq+0xb0>
34014812:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014816:	d829      	bhi.n	3401486c <RCCEx_GetFDCANCLKFreq+0xd4>
34014818:	2b00      	cmp	r3, #0
3401481a:	d003      	beq.n	34014824 <RCCEx_GetFDCANCLKFreq+0x8c>
3401481c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014820:	d009      	beq.n	34014836 <RCCEx_GetFDCANCLKFreq+0x9e>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            fdcan_frequency = fdcan_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014822:	e023      	b.n	3401486c <RCCEx_GetFDCANCLKFreq+0xd4>
            fdcan_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014824:	f7ff f824 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014828:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3401482a:	68fa      	ldr	r2, [r7, #12]
3401482c:	68bb      	ldr	r3, [r7, #8]
3401482e:	fbb2 f3f3 	udiv	r3, r2, r3
34014832:	60fb      	str	r3, [r7, #12]
            break;
34014834:	e01b      	b.n	3401486e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014836:	f7ff f861 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401483a:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3401483c:	68fa      	ldr	r2, [r7, #12]
3401483e:	68bb      	ldr	r3, [r7, #8]
34014840:	fbb2 f3f3 	udiv	r3, r2, r3
34014844:	60fb      	str	r3, [r7, #12]
            break;
34014846:	e012      	b.n	3401486e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014848:	f7ff f89e 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401484c:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
3401484e:	68fa      	ldr	r2, [r7, #12]
34014850:	68bb      	ldr	r3, [r7, #8]
34014852:	fbb2 f3f3 	udiv	r3, r2, r3
34014856:	60fb      	str	r3, [r7, #12]
            break;
34014858:	e009      	b.n	3401486e <RCCEx_GetFDCANCLKFreq+0xd6>
            fdcan_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401485a:	f7ff f8db 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401485e:	60f8      	str	r0, [r7, #12]
            fdcan_frequency = fdcan_frequency / ic_divider;
34014860:	68fa      	ldr	r2, [r7, #12]
34014862:	68bb      	ldr	r3, [r7, #8]
34014864:	fbb2 f3f3 	udiv	r3, r2, r3
34014868:	60fb      	str	r3, [r7, #12]
            break;
3401486a:	e000      	b.n	3401486e <RCCEx_GetFDCANCLKFreq+0xd6>
            break;
3401486c:	bf00      	nop
        }
      }
      break;
3401486e:	e009      	b.n	34014884 <RCCEx_GetFDCANCLKFreq+0xec>

    case LL_RCC_FDCAN_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
34014870:	f7fa fd74 	bl	3400f35c <LL_RCC_HSE_IsReady>
34014874:	4603      	mov	r3, r0
34014876:	2b00      	cmp	r3, #0
34014878:	d006      	beq.n	34014888 <RCCEx_GetFDCANCLKFreq+0xf0>
      {
        fdcan_frequency = HSE_VALUE;
3401487a:	4b06      	ldr	r3, [pc, #24]	@ (34014894 <RCCEx_GetFDCANCLKFreq+0xfc>)
3401487c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401487e:	e003      	b.n	34014888 <RCCEx_GetFDCANCLKFreq+0xf0>

    default:
      /* Unexpected case */
      break;
34014880:	bf00      	nop
34014882:	e002      	b.n	3401488a <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34014884:	bf00      	nop
34014886:	e000      	b.n	3401488a <RCCEx_GetFDCANCLKFreq+0xf2>
      break;
34014888:	bf00      	nop
  }

  return fdcan_frequency;
3401488a:	68fb      	ldr	r3, [r7, #12]
}
3401488c:	4618      	mov	r0, r3
3401488e:	3710      	adds	r7, #16
34014890:	46bd      	mov	sp, r7
34014892:	bd80      	pop	{r7, pc}
34014894:	02dc6c00 	.word	0x02dc6c00

34014898 <RCCEx_GetFMCCLKFreq>:
  *         @arg @ref RCCEx_FMC_Clock_Source
  * @retval FMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetFMCCLKFreq(uint32_t FMCxSource)
{
34014898:	b580      	push	{r7, lr}
3401489a:	b084      	sub	sp, #16
3401489c:	af00      	add	r7, sp, #0
3401489e:	6078      	str	r0, [r7, #4]
  uint32_t fmc_frequency = RCC_PERIPH_FREQUENCY_NO;
340148a0:	2300      	movs	r3, #0
340148a2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetFMCClockSource(FMCxSource))
340148a4:	6878      	ldr	r0, [r7, #4]
340148a6:	f7fb f89f 	bl	3400f9e8 <LL_RCC_GetFMCClockSource>
340148aa:	4603      	mov	r3, r0
340148ac:	2b30      	cmp	r3, #48	@ 0x30
340148ae:	d05d      	beq.n	3401496c <RCCEx_GetFMCCLKFreq+0xd4>
340148b0:	2b30      	cmp	r3, #48	@ 0x30
340148b2:	f200 809e 	bhi.w	340149f2 <RCCEx_GetFMCCLKFreq+0x15a>
340148b6:	2b20      	cmp	r3, #32
340148b8:	d014      	beq.n	340148e4 <RCCEx_GetFMCCLKFreq+0x4c>
340148ba:	2b20      	cmp	r3, #32
340148bc:	f200 8099 	bhi.w	340149f2 <RCCEx_GetFMCCLKFreq+0x15a>
340148c0:	2b00      	cmp	r3, #0
340148c2:	d002      	beq.n	340148ca <RCCEx_GetFMCCLKFreq+0x32>
340148c4:	2b10      	cmp	r3, #16
340148c6:	d008      	beq.n	340148da <RCCEx_GetFMCCLKFreq+0x42>
      }
      break;

    default:
      /* Unexpected case */
      break;
340148c8:	e093      	b.n	340149f2 <RCCEx_GetFMCCLKFreq+0x15a>
      fmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340148ca:	f7fa f959 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340148ce:	4603      	mov	r3, r0
340148d0:	4618      	mov	r0, r3
340148d2:	f7ff f8e5 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340148d6:	60f8      	str	r0, [r7, #12]
      break;
340148d8:	e090      	b.n	340149fc <RCCEx_GetFMCCLKFreq+0x164>
      fmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340148da:	2007      	movs	r0, #7
340148dc:	f7ff fbcc 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340148e0:	60f8      	str	r0, [r7, #12]
      break;
340148e2:	e08b      	b.n	340149fc <RCCEx_GetFMCCLKFreq+0x164>
      if (LL_RCC_IC3_IsEnabled() != 0U)
340148e4:	f7fb fc30 	bl	34010148 <LL_RCC_IC3_IsEnabled>
340148e8:	4603      	mov	r3, r0
340148ea:	2b00      	cmp	r3, #0
340148ec:	f000 8083 	beq.w	340149f6 <RCCEx_GetFMCCLKFreq+0x15e>
        ic_divider = LL_RCC_IC3_GetDivider();
340148f0:	f7fb fc4c 	bl	3401018c <LL_RCC_IC3_GetDivider>
340148f4:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
340148f6:	f7fb fc3b 	bl	34010170 <LL_RCC_IC3_GetSource>
340148fa:	4603      	mov	r3, r0
340148fc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014900:	d029      	beq.n	34014956 <RCCEx_GetFMCCLKFreq+0xbe>
34014902:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014906:	d82f      	bhi.n	34014968 <RCCEx_GetFMCCLKFreq+0xd0>
34014908:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401490c:	d01a      	beq.n	34014944 <RCCEx_GetFMCCLKFreq+0xac>
3401490e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014912:	d829      	bhi.n	34014968 <RCCEx_GetFMCCLKFreq+0xd0>
34014914:	2b00      	cmp	r3, #0
34014916:	d003      	beq.n	34014920 <RCCEx_GetFMCCLKFreq+0x88>
34014918:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401491c:	d009      	beq.n	34014932 <RCCEx_GetFMCCLKFreq+0x9a>
            break;
3401491e:	e023      	b.n	34014968 <RCCEx_GetFMCCLKFreq+0xd0>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014920:	f7fe ffa6 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014924:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34014926:	68fa      	ldr	r2, [r7, #12]
34014928:	68bb      	ldr	r3, [r7, #8]
3401492a:	fbb2 f3f3 	udiv	r3, r2, r3
3401492e:	60fb      	str	r3, [r7, #12]
            break;
34014930:	e01b      	b.n	3401496a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014932:	f7fe ffe3 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014936:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
34014938:	68fa      	ldr	r2, [r7, #12]
3401493a:	68bb      	ldr	r3, [r7, #8]
3401493c:	fbb2 f3f3 	udiv	r3, r2, r3
34014940:	60fb      	str	r3, [r7, #12]
            break;
34014942:	e012      	b.n	3401496a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014944:	f7ff f820 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014948:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3401494a:	68fa      	ldr	r2, [r7, #12]
3401494c:	68bb      	ldr	r3, [r7, #8]
3401494e:	fbb2 f3f3 	udiv	r3, r2, r3
34014952:	60fb      	str	r3, [r7, #12]
            break;
34014954:	e009      	b.n	3401496a <RCCEx_GetFMCCLKFreq+0xd2>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014956:	f7ff f85d 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401495a:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
3401495c:	68fa      	ldr	r2, [r7, #12]
3401495e:	68bb      	ldr	r3, [r7, #8]
34014960:	fbb2 f3f3 	udiv	r3, r2, r3
34014964:	60fb      	str	r3, [r7, #12]
            break;
34014966:	e000      	b.n	3401496a <RCCEx_GetFMCCLKFreq+0xd2>
            break;
34014968:	bf00      	nop
      break;
3401496a:	e044      	b.n	340149f6 <RCCEx_GetFMCCLKFreq+0x15e>
      if (LL_RCC_IC4_IsEnabled() != 0U)
3401496c:	f7fb fc2c 	bl	340101c8 <LL_RCC_IC4_IsEnabled>
34014970:	4603      	mov	r3, r0
34014972:	2b00      	cmp	r3, #0
34014974:	d041      	beq.n	340149fa <RCCEx_GetFMCCLKFreq+0x162>
        ic_divider = LL_RCC_IC4_GetDivider();
34014976:	f7fb fc49 	bl	3401020c <LL_RCC_IC4_GetDivider>
3401497a:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3401497c:	f7fb fc38 	bl	340101f0 <LL_RCC_IC4_GetSource>
34014980:	4603      	mov	r3, r0
34014982:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014986:	d029      	beq.n	340149dc <RCCEx_GetFMCCLKFreq+0x144>
34014988:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401498c:	d82f      	bhi.n	340149ee <RCCEx_GetFMCCLKFreq+0x156>
3401498e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014992:	d01a      	beq.n	340149ca <RCCEx_GetFMCCLKFreq+0x132>
34014994:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014998:	d829      	bhi.n	340149ee <RCCEx_GetFMCCLKFreq+0x156>
3401499a:	2b00      	cmp	r3, #0
3401499c:	d003      	beq.n	340149a6 <RCCEx_GetFMCCLKFreq+0x10e>
3401499e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340149a2:	d009      	beq.n	340149b8 <RCCEx_GetFMCCLKFreq+0x120>
            break;
340149a4:	e023      	b.n	340149ee <RCCEx_GetFMCCLKFreq+0x156>
            fmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340149a6:	f7fe ff63 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340149aa:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
340149ac:	68fa      	ldr	r2, [r7, #12]
340149ae:	68bb      	ldr	r3, [r7, #8]
340149b0:	fbb2 f3f3 	udiv	r3, r2, r3
340149b4:	60fb      	str	r3, [r7, #12]
            break;
340149b6:	e01b      	b.n	340149f0 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340149b8:	f7fe ffa0 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340149bc:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
340149be:	68fa      	ldr	r2, [r7, #12]
340149c0:	68bb      	ldr	r3, [r7, #8]
340149c2:	fbb2 f3f3 	udiv	r3, r2, r3
340149c6:	60fb      	str	r3, [r7, #12]
            break;
340149c8:	e012      	b.n	340149f0 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340149ca:	f7fe ffdd 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340149ce:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
340149d0:	68fa      	ldr	r2, [r7, #12]
340149d2:	68bb      	ldr	r3, [r7, #8]
340149d4:	fbb2 f3f3 	udiv	r3, r2, r3
340149d8:	60fb      	str	r3, [r7, #12]
            break;
340149da:	e009      	b.n	340149f0 <RCCEx_GetFMCCLKFreq+0x158>
            fmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340149dc:	f7ff f81a 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340149e0:	60f8      	str	r0, [r7, #12]
            fmc_frequency = fmc_frequency / ic_divider;
340149e2:	68fa      	ldr	r2, [r7, #12]
340149e4:	68bb      	ldr	r3, [r7, #8]
340149e6:	fbb2 f3f3 	udiv	r3, r2, r3
340149ea:	60fb      	str	r3, [r7, #12]
            break;
340149ec:	e000      	b.n	340149f0 <RCCEx_GetFMCCLKFreq+0x158>
            break;
340149ee:	bf00      	nop
      break;
340149f0:	e003      	b.n	340149fa <RCCEx_GetFMCCLKFreq+0x162>
      break;
340149f2:	bf00      	nop
340149f4:	e002      	b.n	340149fc <RCCEx_GetFMCCLKFreq+0x164>
      break;
340149f6:	bf00      	nop
340149f8:	e000      	b.n	340149fc <RCCEx_GetFMCCLKFreq+0x164>
      break;
340149fa:	bf00      	nop
  }

  return fmc_frequency;
340149fc:	68fb      	ldr	r3, [r7, #12]
}
340149fe:	4618      	mov	r0, r3
34014a00:	3710      	adds	r7, #16
34014a02:	46bd      	mov	sp, r7
34014a04:	bd80      	pop	{r7, pc}
	...

34014a08 <RCCEx_GetI2CCLKFreq>:
  *         @arg @ref RCCEx_I2C4_Clock_Source
  * @retval I2C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI2CCLKFreq(uint32_t I2CxSource)
{
34014a08:	b580      	push	{r7, lr}
34014a0a:	b084      	sub	sp, #16
34014a0c:	af00      	add	r7, sp, #0
34014a0e:	6078      	str	r0, [r7, #4]
  uint32_t i2c_frequency = RCC_PERIPH_FREQUENCY_NO;
34014a10:	2300      	movs	r3, #0
34014a12:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI2CClockSource(I2CxSource))
34014a14:	6878      	ldr	r0, [r7, #4]
34014a16:	f7fa fff9 	bl	3400fa0c <LL_RCC_GetI2CClockSource>
34014a1a:	4603      	mov	r3, r0
34014a1c:	4aa2      	ldr	r2, [pc, #648]	@ (34014ca8 <RCCEx_GetI2CCLKFreq+0x2a0>)
34014a1e:	4293      	cmp	r3, r2
34014a20:	f000 8172 	beq.w	34014d08 <RCCEx_GetI2CCLKFreq+0x300>
34014a24:	4aa0      	ldr	r2, [pc, #640]	@ (34014ca8 <RCCEx_GetI2CCLKFreq+0x2a0>)
34014a26:	4293      	cmp	r3, r2
34014a28:	f200 8184 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a2c:	4a9f      	ldr	r2, [pc, #636]	@ (34014cac <RCCEx_GetI2CCLKFreq+0x2a4>)
34014a2e:	4293      	cmp	r3, r2
34014a30:	f000 816a 	beq.w	34014d08 <RCCEx_GetI2CCLKFreq+0x300>
34014a34:	4a9d      	ldr	r2, [pc, #628]	@ (34014cac <RCCEx_GetI2CCLKFreq+0x2a4>)
34014a36:	4293      	cmp	r3, r2
34014a38:	f200 817c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a3c:	4a9c      	ldr	r2, [pc, #624]	@ (34014cb0 <RCCEx_GetI2CCLKFreq+0x2a8>)
34014a3e:	4293      	cmp	r3, r2
34014a40:	f000 8162 	beq.w	34014d08 <RCCEx_GetI2CCLKFreq+0x300>
34014a44:	4a9a      	ldr	r2, [pc, #616]	@ (34014cb0 <RCCEx_GetI2CCLKFreq+0x2a8>)
34014a46:	4293      	cmp	r3, r2
34014a48:	f200 8174 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a4c:	4a99      	ldr	r2, [pc, #612]	@ (34014cb4 <RCCEx_GetI2CCLKFreq+0x2ac>)
34014a4e:	4293      	cmp	r3, r2
34014a50:	f000 815a 	beq.w	34014d08 <RCCEx_GetI2CCLKFreq+0x300>
34014a54:	4a97      	ldr	r2, [pc, #604]	@ (34014cb4 <RCCEx_GetI2CCLKFreq+0x2ac>)
34014a56:	4293      	cmp	r3, r2
34014a58:	f200 816c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a5c:	4a96      	ldr	r2, [pc, #600]	@ (34014cb8 <RCCEx_GetI2CCLKFreq+0x2b0>)
34014a5e:	4293      	cmp	r3, r2
34014a60:	f000 8160 	beq.w	34014d24 <RCCEx_GetI2CCLKFreq+0x31c>
34014a64:	4a94      	ldr	r2, [pc, #592]	@ (34014cb8 <RCCEx_GetI2CCLKFreq+0x2b0>)
34014a66:	4293      	cmp	r3, r2
34014a68:	f200 8164 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a6c:	4a93      	ldr	r2, [pc, #588]	@ (34014cbc <RCCEx_GetI2CCLKFreq+0x2b4>)
34014a6e:	4293      	cmp	r3, r2
34014a70:	f000 8158 	beq.w	34014d24 <RCCEx_GetI2CCLKFreq+0x31c>
34014a74:	4a91      	ldr	r2, [pc, #580]	@ (34014cbc <RCCEx_GetI2CCLKFreq+0x2b4>)
34014a76:	4293      	cmp	r3, r2
34014a78:	f200 815c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a7c:	4a90      	ldr	r2, [pc, #576]	@ (34014cc0 <RCCEx_GetI2CCLKFreq+0x2b8>)
34014a7e:	4293      	cmp	r3, r2
34014a80:	f000 8150 	beq.w	34014d24 <RCCEx_GetI2CCLKFreq+0x31c>
34014a84:	4a8e      	ldr	r2, [pc, #568]	@ (34014cc0 <RCCEx_GetI2CCLKFreq+0x2b8>)
34014a86:	4293      	cmp	r3, r2
34014a88:	f200 8154 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a8c:	4a8d      	ldr	r2, [pc, #564]	@ (34014cc4 <RCCEx_GetI2CCLKFreq+0x2bc>)
34014a8e:	4293      	cmp	r3, r2
34014a90:	f000 8148 	beq.w	34014d24 <RCCEx_GetI2CCLKFreq+0x31c>
34014a94:	4a8b      	ldr	r2, [pc, #556]	@ (34014cc4 <RCCEx_GetI2CCLKFreq+0x2bc>)
34014a96:	4293      	cmp	r3, r2
34014a98:	f200 814c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014a9c:	4a8a      	ldr	r2, [pc, #552]	@ (34014cc8 <RCCEx_GetI2CCLKFreq+0x2c0>)
34014a9e:	4293      	cmp	r3, r2
34014aa0:	f000 80be 	beq.w	34014c20 <RCCEx_GetI2CCLKFreq+0x218>
34014aa4:	4a88      	ldr	r2, [pc, #544]	@ (34014cc8 <RCCEx_GetI2CCLKFreq+0x2c0>)
34014aa6:	4293      	cmp	r3, r2
34014aa8:	f200 8144 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014aac:	4a87      	ldr	r2, [pc, #540]	@ (34014ccc <RCCEx_GetI2CCLKFreq+0x2c4>)
34014aae:	4293      	cmp	r3, r2
34014ab0:	f000 80b6 	beq.w	34014c20 <RCCEx_GetI2CCLKFreq+0x218>
34014ab4:	4a85      	ldr	r2, [pc, #532]	@ (34014ccc <RCCEx_GetI2CCLKFreq+0x2c4>)
34014ab6:	4293      	cmp	r3, r2
34014ab8:	f200 813c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014abc:	4a84      	ldr	r2, [pc, #528]	@ (34014cd0 <RCCEx_GetI2CCLKFreq+0x2c8>)
34014abe:	4293      	cmp	r3, r2
34014ac0:	f000 80ae 	beq.w	34014c20 <RCCEx_GetI2CCLKFreq+0x218>
34014ac4:	4a82      	ldr	r2, [pc, #520]	@ (34014cd0 <RCCEx_GetI2CCLKFreq+0x2c8>)
34014ac6:	4293      	cmp	r3, r2
34014ac8:	f200 8134 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014acc:	4a81      	ldr	r2, [pc, #516]	@ (34014cd4 <RCCEx_GetI2CCLKFreq+0x2cc>)
34014ace:	4293      	cmp	r3, r2
34014ad0:	f000 80a6 	beq.w	34014c20 <RCCEx_GetI2CCLKFreq+0x218>
34014ad4:	4a7f      	ldr	r2, [pc, #508]	@ (34014cd4 <RCCEx_GetI2CCLKFreq+0x2cc>)
34014ad6:	4293      	cmp	r3, r2
34014ad8:	f200 812c 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014adc:	4a7e      	ldr	r2, [pc, #504]	@ (34014cd8 <RCCEx_GetI2CCLKFreq+0x2d0>)
34014ade:	4293      	cmp	r3, r2
34014ae0:	d05a      	beq.n	34014b98 <RCCEx_GetI2CCLKFreq+0x190>
34014ae2:	4a7d      	ldr	r2, [pc, #500]	@ (34014cd8 <RCCEx_GetI2CCLKFreq+0x2d0>)
34014ae4:	4293      	cmp	r3, r2
34014ae6:	f200 8125 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014aea:	4a7c      	ldr	r2, [pc, #496]	@ (34014cdc <RCCEx_GetI2CCLKFreq+0x2d4>)
34014aec:	4293      	cmp	r3, r2
34014aee:	d053      	beq.n	34014b98 <RCCEx_GetI2CCLKFreq+0x190>
34014af0:	4a7a      	ldr	r2, [pc, #488]	@ (34014cdc <RCCEx_GetI2CCLKFreq+0x2d4>)
34014af2:	4293      	cmp	r3, r2
34014af4:	f200 811e 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014af8:	4a79      	ldr	r2, [pc, #484]	@ (34014ce0 <RCCEx_GetI2CCLKFreq+0x2d8>)
34014afa:	4293      	cmp	r3, r2
34014afc:	d04c      	beq.n	34014b98 <RCCEx_GetI2CCLKFreq+0x190>
34014afe:	4a78      	ldr	r2, [pc, #480]	@ (34014ce0 <RCCEx_GetI2CCLKFreq+0x2d8>)
34014b00:	4293      	cmp	r3, r2
34014b02:	f200 8117 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b06:	4a77      	ldr	r2, [pc, #476]	@ (34014ce4 <RCCEx_GetI2CCLKFreq+0x2dc>)
34014b08:	4293      	cmp	r3, r2
34014b0a:	d045      	beq.n	34014b98 <RCCEx_GetI2CCLKFreq+0x190>
34014b0c:	4a75      	ldr	r2, [pc, #468]	@ (34014ce4 <RCCEx_GetI2CCLKFreq+0x2dc>)
34014b0e:	4293      	cmp	r3, r2
34014b10:	f200 8110 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b14:	4a74      	ldr	r2, [pc, #464]	@ (34014ce8 <RCCEx_GetI2CCLKFreq+0x2e0>)
34014b16:	4293      	cmp	r3, r2
34014b18:	d039      	beq.n	34014b8e <RCCEx_GetI2CCLKFreq+0x186>
34014b1a:	4a73      	ldr	r2, [pc, #460]	@ (34014ce8 <RCCEx_GetI2CCLKFreq+0x2e0>)
34014b1c:	4293      	cmp	r3, r2
34014b1e:	f200 8109 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b22:	4a72      	ldr	r2, [pc, #456]	@ (34014cec <RCCEx_GetI2CCLKFreq+0x2e4>)
34014b24:	4293      	cmp	r3, r2
34014b26:	d032      	beq.n	34014b8e <RCCEx_GetI2CCLKFreq+0x186>
34014b28:	4a70      	ldr	r2, [pc, #448]	@ (34014cec <RCCEx_GetI2CCLKFreq+0x2e4>)
34014b2a:	4293      	cmp	r3, r2
34014b2c:	f200 8102 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b30:	4a6f      	ldr	r2, [pc, #444]	@ (34014cf0 <RCCEx_GetI2CCLKFreq+0x2e8>)
34014b32:	4293      	cmp	r3, r2
34014b34:	d02b      	beq.n	34014b8e <RCCEx_GetI2CCLKFreq+0x186>
34014b36:	4a6e      	ldr	r2, [pc, #440]	@ (34014cf0 <RCCEx_GetI2CCLKFreq+0x2e8>)
34014b38:	4293      	cmp	r3, r2
34014b3a:	f200 80fb 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b3e:	4a6d      	ldr	r2, [pc, #436]	@ (34014cf4 <RCCEx_GetI2CCLKFreq+0x2ec>)
34014b40:	4293      	cmp	r3, r2
34014b42:	d024      	beq.n	34014b8e <RCCEx_GetI2CCLKFreq+0x186>
34014b44:	4a6b      	ldr	r2, [pc, #428]	@ (34014cf4 <RCCEx_GetI2CCLKFreq+0x2ec>)
34014b46:	4293      	cmp	r3, r2
34014b48:	f200 80f4 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b4c:	4a6a      	ldr	r2, [pc, #424]	@ (34014cf8 <RCCEx_GetI2CCLKFreq+0x2f0>)
34014b4e:	4293      	cmp	r3, r2
34014b50:	d011      	beq.n	34014b76 <RCCEx_GetI2CCLKFreq+0x16e>
34014b52:	4a69      	ldr	r2, [pc, #420]	@ (34014cf8 <RCCEx_GetI2CCLKFreq+0x2f0>)
34014b54:	4293      	cmp	r3, r2
34014b56:	f200 80ed 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b5a:	4a68      	ldr	r2, [pc, #416]	@ (34014cfc <RCCEx_GetI2CCLKFreq+0x2f4>)
34014b5c:	4293      	cmp	r3, r2
34014b5e:	d00a      	beq.n	34014b76 <RCCEx_GetI2CCLKFreq+0x16e>
34014b60:	4a66      	ldr	r2, [pc, #408]	@ (34014cfc <RCCEx_GetI2CCLKFreq+0x2f4>)
34014b62:	4293      	cmp	r3, r2
34014b64:	f200 80e6 	bhi.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
34014b68:	4a65      	ldr	r2, [pc, #404]	@ (34014d00 <RCCEx_GetI2CCLKFreq+0x2f8>)
34014b6a:	4293      	cmp	r3, r2
34014b6c:	d003      	beq.n	34014b76 <RCCEx_GetI2CCLKFreq+0x16e>
34014b6e:	4a65      	ldr	r2, [pc, #404]	@ (34014d04 <RCCEx_GetI2CCLKFreq+0x2fc>)
34014b70:	4293      	cmp	r3, r2
34014b72:	f040 80df 	bne.w	34014d34 <RCCEx_GetI2CCLKFreq+0x32c>
  {
    case LL_RCC_I2C1_CLKSOURCE_PCLK1:
    case LL_RCC_I2C2_CLKSOURCE_PCLK1:
    case LL_RCC_I2C3_CLKSOURCE_PCLK1:
    case LL_RCC_I2C4_CLKSOURCE_PCLK1:
      i2c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34014b76:	f7fa f803 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34014b7a:	4603      	mov	r3, r0
34014b7c:	4618      	mov	r0, r3
34014b7e:	f7fe ff8f 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34014b82:	4603      	mov	r3, r0
34014b84:	4618      	mov	r0, r3
34014b86:	f7fe ff9c 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34014b8a:	60f8      	str	r0, [r7, #12]
      break;
34014b8c:	e0db      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_CLKP:
    case LL_RCC_I2C2_CLKSOURCE_CLKP:
    case LL_RCC_I2C3_CLKSOURCE_CLKP:
    case LL_RCC_I2C4_CLKSOURCE_CLKP:
      i2c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34014b8e:	2007      	movs	r0, #7
34014b90:	f7ff fa72 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34014b94:	60f8      	str	r0, [r7, #12]
      break;
34014b96:	e0d6      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>

    case LL_RCC_I2C1_CLKSOURCE_IC10:
    case LL_RCC_I2C2_CLKSOURCE_IC10:
    case LL_RCC_I2C3_CLKSOURCE_IC10:
    case LL_RCC_I2C4_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34014b98:	f7fb fc56 	bl	34010448 <LL_RCC_IC10_IsEnabled>
34014b9c:	4603      	mov	r3, r0
34014b9e:	2b00      	cmp	r3, #0
34014ba0:	f000 80ca 	beq.w	34014d38 <RCCEx_GetI2CCLKFreq+0x330>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34014ba4:	f7fb fc72 	bl	3401048c <LL_RCC_IC10_GetDivider>
34014ba8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34014baa:	f7fb fc61 	bl	34010470 <LL_RCC_IC10_GetSource>
34014bae:	4603      	mov	r3, r0
34014bb0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014bb4:	d029      	beq.n	34014c0a <RCCEx_GetI2CCLKFreq+0x202>
34014bb6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014bba:	d82f      	bhi.n	34014c1c <RCCEx_GetI2CCLKFreq+0x214>
34014bbc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014bc0:	d01a      	beq.n	34014bf8 <RCCEx_GetI2CCLKFreq+0x1f0>
34014bc2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014bc6:	d829      	bhi.n	34014c1c <RCCEx_GetI2CCLKFreq+0x214>
34014bc8:	2b00      	cmp	r3, #0
34014bca:	d003      	beq.n	34014bd4 <RCCEx_GetI2CCLKFreq+0x1cc>
34014bcc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014bd0:	d009      	beq.n	34014be6 <RCCEx_GetI2CCLKFreq+0x1de>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014bd2:	e023      	b.n	34014c1c <RCCEx_GetI2CCLKFreq+0x214>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014bd4:	f7fe fe4c 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014bd8:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014bda:	68fa      	ldr	r2, [r7, #12]
34014bdc:	68bb      	ldr	r3, [r7, #8]
34014bde:	fbb2 f3f3 	udiv	r3, r2, r3
34014be2:	60fb      	str	r3, [r7, #12]
            break;
34014be4:	e01b      	b.n	34014c1e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014be6:	f7fe fe89 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014bea:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014bec:	68fa      	ldr	r2, [r7, #12]
34014bee:	68bb      	ldr	r3, [r7, #8]
34014bf0:	fbb2 f3f3 	udiv	r3, r2, r3
34014bf4:	60fb      	str	r3, [r7, #12]
            break;
34014bf6:	e012      	b.n	34014c1e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014bf8:	f7fe fec6 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014bfc:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014bfe:	68fa      	ldr	r2, [r7, #12]
34014c00:	68bb      	ldr	r3, [r7, #8]
34014c02:	fbb2 f3f3 	udiv	r3, r2, r3
34014c06:	60fb      	str	r3, [r7, #12]
            break;
34014c08:	e009      	b.n	34014c1e <RCCEx_GetI2CCLKFreq+0x216>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014c0a:	f7fe ff03 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014c0e:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014c10:	68fa      	ldr	r2, [r7, #12]
34014c12:	68bb      	ldr	r3, [r7, #8]
34014c14:	fbb2 f3f3 	udiv	r3, r2, r3
34014c18:	60fb      	str	r3, [r7, #12]
            break;
34014c1a:	e000      	b.n	34014c1e <RCCEx_GetI2CCLKFreq+0x216>
            break;
34014c1c:	bf00      	nop
        }
      }
      break;
34014c1e:	e08b      	b.n	34014d38 <RCCEx_GetI2CCLKFreq+0x330>

    case LL_RCC_I2C1_CLKSOURCE_IC15:
    case LL_RCC_I2C2_CLKSOURCE_IC15:
    case LL_RCC_I2C3_CLKSOURCE_IC15:
    case LL_RCC_I2C4_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34014c20:	f7fb fd12 	bl	34010648 <LL_RCC_IC15_IsEnabled>
34014c24:	4603      	mov	r3, r0
34014c26:	2b00      	cmp	r3, #0
34014c28:	f000 8088 	beq.w	34014d3c <RCCEx_GetI2CCLKFreq+0x334>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34014c2c:	f7fb fd2e 	bl	3401068c <LL_RCC_IC15_GetDivider>
34014c30:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34014c32:	f7fb fd1d 	bl	34010670 <LL_RCC_IC15_GetSource>
34014c36:	4603      	mov	r3, r0
34014c38:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014c3c:	d029      	beq.n	34014c92 <RCCEx_GetI2CCLKFreq+0x28a>
34014c3e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014c42:	d82f      	bhi.n	34014ca4 <RCCEx_GetI2CCLKFreq+0x29c>
34014c44:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014c48:	d01a      	beq.n	34014c80 <RCCEx_GetI2CCLKFreq+0x278>
34014c4a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014c4e:	d829      	bhi.n	34014ca4 <RCCEx_GetI2CCLKFreq+0x29c>
34014c50:	2b00      	cmp	r3, #0
34014c52:	d003      	beq.n	34014c5c <RCCEx_GetI2CCLKFreq+0x254>
34014c54:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014c58:	d009      	beq.n	34014c6e <RCCEx_GetI2CCLKFreq+0x266>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i2c_frequency = i2c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014c5a:	e023      	b.n	34014ca4 <RCCEx_GetI2CCLKFreq+0x29c>
            i2c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014c5c:	f7fe fe08 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014c60:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014c62:	68fa      	ldr	r2, [r7, #12]
34014c64:	68bb      	ldr	r3, [r7, #8]
34014c66:	fbb2 f3f3 	udiv	r3, r2, r3
34014c6a:	60fb      	str	r3, [r7, #12]
            break;
34014c6c:	e01b      	b.n	34014ca6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014c6e:	f7fe fe45 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014c72:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014c74:	68fa      	ldr	r2, [r7, #12]
34014c76:	68bb      	ldr	r3, [r7, #8]
34014c78:	fbb2 f3f3 	udiv	r3, r2, r3
34014c7c:	60fb      	str	r3, [r7, #12]
            break;
34014c7e:	e012      	b.n	34014ca6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014c80:	f7fe fe82 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014c84:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014c86:	68fa      	ldr	r2, [r7, #12]
34014c88:	68bb      	ldr	r3, [r7, #8]
34014c8a:	fbb2 f3f3 	udiv	r3, r2, r3
34014c8e:	60fb      	str	r3, [r7, #12]
            break;
34014c90:	e009      	b.n	34014ca6 <RCCEx_GetI2CCLKFreq+0x29e>
            i2c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014c92:	f7fe febf 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014c96:	60f8      	str	r0, [r7, #12]
            i2c_frequency = i2c_frequency / ic_divider;
34014c98:	68fa      	ldr	r2, [r7, #12]
34014c9a:	68bb      	ldr	r3, [r7, #8]
34014c9c:	fbb2 f3f3 	udiv	r3, r2, r3
34014ca0:	60fb      	str	r3, [r7, #12]
            break;
34014ca2:	e000      	b.n	34014ca6 <RCCEx_GetI2CCLKFreq+0x29e>
            break;
34014ca4:	bf00      	nop
        }
      }
      break;
34014ca6:	e049      	b.n	34014d3c <RCCEx_GetI2CCLKFreq+0x334>
34014ca8:	07050c0c 	.word	0x07050c0c
34014cac:	0705080c 	.word	0x0705080c
34014cb0:	0705040c 	.word	0x0705040c
34014cb4:	0705000c 	.word	0x0705000c
34014cb8:	07040c0c 	.word	0x07040c0c
34014cbc:	0704080c 	.word	0x0704080c
34014cc0:	0704040c 	.word	0x0704040c
34014cc4:	0704000c 	.word	0x0704000c
34014cc8:	07030c0c 	.word	0x07030c0c
34014ccc:	0703080c 	.word	0x0703080c
34014cd0:	0703040c 	.word	0x0703040c
34014cd4:	0703000c 	.word	0x0703000c
34014cd8:	07020c0c 	.word	0x07020c0c
34014cdc:	0702080c 	.word	0x0702080c
34014ce0:	0702040c 	.word	0x0702040c
34014ce4:	0702000c 	.word	0x0702000c
34014ce8:	07010c0c 	.word	0x07010c0c
34014cec:	0701080c 	.word	0x0701080c
34014cf0:	0701040c 	.word	0x0701040c
34014cf4:	0701000c 	.word	0x0701000c
34014cf8:	07000c0c 	.word	0x07000c0c
34014cfc:	0700080c 	.word	0x0700080c
34014d00:	0700000c 	.word	0x0700000c
34014d04:	0700040c 	.word	0x0700040c

    case LL_RCC_I2C1_CLKSOURCE_HSI:
    case LL_RCC_I2C2_CLKSOURCE_HSI:
    case LL_RCC_I2C3_CLKSOURCE_HSI:
    case LL_RCC_I2C4_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34014d08:	f7fa fb3a 	bl	3400f380 <LL_RCC_HSI_IsReady>
34014d0c:	4603      	mov	r3, r0
34014d0e:	2b00      	cmp	r3, #0
34014d10:	d016      	beq.n	34014d40 <RCCEx_GetI2CCLKFreq+0x338>
      {
        i2c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34014d12:	f7fa fb47 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34014d16:	4603      	mov	r3, r0
34014d18:	09db      	lsrs	r3, r3, #7
34014d1a:	4a0d      	ldr	r2, [pc, #52]	@ (34014d50 <RCCEx_GetI2CCLKFreq+0x348>)
34014d1c:	fa22 f303 	lsr.w	r3, r2, r3
34014d20:	60fb      	str	r3, [r7, #12]
      }
      break;
34014d22:	e00d      	b.n	34014d40 <RCCEx_GetI2CCLKFreq+0x338>

    case LL_RCC_I2C1_CLKSOURCE_MSI:
    case LL_RCC_I2C2_CLKSOURCE_MSI:
    case LL_RCC_I2C3_CLKSOURCE_MSI:
    case LL_RCC_I2C4_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34014d24:	f7fa fb4c 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34014d28:	4603      	mov	r3, r0
34014d2a:	2b00      	cmp	r3, #0
34014d2c:	d00a      	beq.n	34014d44 <RCCEx_GetI2CCLKFreq+0x33c>
      {
        i2c_frequency = MSI_VALUE;
34014d2e:	4b09      	ldr	r3, [pc, #36]	@ (34014d54 <RCCEx_GetI2CCLKFreq+0x34c>)
34014d30:	60fb      	str	r3, [r7, #12]
      }
      break;
34014d32:	e007      	b.n	34014d44 <RCCEx_GetI2CCLKFreq+0x33c>

    default:
      /* Unexpected case */
      break;
34014d34:	bf00      	nop
34014d36:	e006      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34014d38:	bf00      	nop
34014d3a:	e004      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34014d3c:	bf00      	nop
34014d3e:	e002      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34014d40:	bf00      	nop
34014d42:	e000      	b.n	34014d46 <RCCEx_GetI2CCLKFreq+0x33e>
      break;
34014d44:	bf00      	nop
  }

  return i2c_frequency;
34014d46:	68fb      	ldr	r3, [r7, #12]
}
34014d48:	4618      	mov	r0, r3
34014d4a:	3710      	adds	r7, #16
34014d4c:	46bd      	mov	sp, r7
34014d4e:	bd80      	pop	{r7, pc}
34014d50:	03d09000 	.word	0x03d09000
34014d54:	003d0900 	.word	0x003d0900

34014d58 <RCCEx_GetI3CCLKFreq>:
  *         @arg @ref RCCEx_I3C2_Clock_Source
  * @retval I3C clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetI3CCLKFreq(uint32_t I3CxSource)
{
34014d58:	b580      	push	{r7, lr}
34014d5a:	b084      	sub	sp, #16
34014d5c:	af00      	add	r7, sp, #0
34014d5e:	6078      	str	r0, [r7, #4]
  uint32_t i3c_frequency = RCC_PERIPH_FREQUENCY_NO;
34014d60:	2300      	movs	r3, #0
34014d62:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetI3CClockSource(I3CxSource))
34014d64:	6878      	ldr	r0, [r7, #4]
34014d66:	f7fa fe5d 	bl	3400fa24 <LL_RCC_GetI3CClockSource>
34014d6a:	4603      	mov	r3, r0
34014d6c:	4a86      	ldr	r2, [pc, #536]	@ (34014f88 <RCCEx_GetI3CCLKFreq+0x230>)
34014d6e:	4293      	cmp	r3, r2
34014d70:	f000 80e6 	beq.w	34014f40 <RCCEx_GetI3CCLKFreq+0x1e8>
34014d74:	4a84      	ldr	r2, [pc, #528]	@ (34014f88 <RCCEx_GetI3CCLKFreq+0x230>)
34014d76:	4293      	cmp	r3, r2
34014d78:	f200 80f8 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014d7c:	4a83      	ldr	r2, [pc, #524]	@ (34014f8c <RCCEx_GetI3CCLKFreq+0x234>)
34014d7e:	4293      	cmp	r3, r2
34014d80:	f000 80de 	beq.w	34014f40 <RCCEx_GetI3CCLKFreq+0x1e8>
34014d84:	4a81      	ldr	r2, [pc, #516]	@ (34014f8c <RCCEx_GetI3CCLKFreq+0x234>)
34014d86:	4293      	cmp	r3, r2
34014d88:	f200 80f0 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014d8c:	4a80      	ldr	r2, [pc, #512]	@ (34014f90 <RCCEx_GetI3CCLKFreq+0x238>)
34014d8e:	4293      	cmp	r3, r2
34014d90:	f000 80e4 	beq.w	34014f5c <RCCEx_GetI3CCLKFreq+0x204>
34014d94:	4a7e      	ldr	r2, [pc, #504]	@ (34014f90 <RCCEx_GetI3CCLKFreq+0x238>)
34014d96:	4293      	cmp	r3, r2
34014d98:	f200 80e8 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014d9c:	4a7d      	ldr	r2, [pc, #500]	@ (34014f94 <RCCEx_GetI3CCLKFreq+0x23c>)
34014d9e:	4293      	cmp	r3, r2
34014da0:	f000 80dc 	beq.w	34014f5c <RCCEx_GetI3CCLKFreq+0x204>
34014da4:	4a7b      	ldr	r2, [pc, #492]	@ (34014f94 <RCCEx_GetI3CCLKFreq+0x23c>)
34014da6:	4293      	cmp	r3, r2
34014da8:	f200 80e0 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014dac:	4a7a      	ldr	r2, [pc, #488]	@ (34014f98 <RCCEx_GetI3CCLKFreq+0x240>)
34014dae:	4293      	cmp	r3, r2
34014db0:	f000 8083 	beq.w	34014eba <RCCEx_GetI3CCLKFreq+0x162>
34014db4:	4a78      	ldr	r2, [pc, #480]	@ (34014f98 <RCCEx_GetI3CCLKFreq+0x240>)
34014db6:	4293      	cmp	r3, r2
34014db8:	f200 80d8 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014dbc:	4a77      	ldr	r2, [pc, #476]	@ (34014f9c <RCCEx_GetI3CCLKFreq+0x244>)
34014dbe:	4293      	cmp	r3, r2
34014dc0:	d07b      	beq.n	34014eba <RCCEx_GetI3CCLKFreq+0x162>
34014dc2:	4a76      	ldr	r2, [pc, #472]	@ (34014f9c <RCCEx_GetI3CCLKFreq+0x244>)
34014dc4:	4293      	cmp	r3, r2
34014dc6:	f200 80d1 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014dca:	4a75      	ldr	r2, [pc, #468]	@ (34014fa0 <RCCEx_GetI3CCLKFreq+0x248>)
34014dcc:	4293      	cmp	r3, r2
34014dce:	d030      	beq.n	34014e32 <RCCEx_GetI3CCLKFreq+0xda>
34014dd0:	4a73      	ldr	r2, [pc, #460]	@ (34014fa0 <RCCEx_GetI3CCLKFreq+0x248>)
34014dd2:	4293      	cmp	r3, r2
34014dd4:	f200 80ca 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014dd8:	4a72      	ldr	r2, [pc, #456]	@ (34014fa4 <RCCEx_GetI3CCLKFreq+0x24c>)
34014dda:	4293      	cmp	r3, r2
34014ddc:	d029      	beq.n	34014e32 <RCCEx_GetI3CCLKFreq+0xda>
34014dde:	4a71      	ldr	r2, [pc, #452]	@ (34014fa4 <RCCEx_GetI3CCLKFreq+0x24c>)
34014de0:	4293      	cmp	r3, r2
34014de2:	f200 80c3 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014de6:	4a70      	ldr	r2, [pc, #448]	@ (34014fa8 <RCCEx_GetI3CCLKFreq+0x250>)
34014de8:	4293      	cmp	r3, r2
34014dea:	d01d      	beq.n	34014e28 <RCCEx_GetI3CCLKFreq+0xd0>
34014dec:	4a6e      	ldr	r2, [pc, #440]	@ (34014fa8 <RCCEx_GetI3CCLKFreq+0x250>)
34014dee:	4293      	cmp	r3, r2
34014df0:	f200 80bc 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014df4:	4a6d      	ldr	r2, [pc, #436]	@ (34014fac <RCCEx_GetI3CCLKFreq+0x254>)
34014df6:	4293      	cmp	r3, r2
34014df8:	d016      	beq.n	34014e28 <RCCEx_GetI3CCLKFreq+0xd0>
34014dfa:	4a6c      	ldr	r2, [pc, #432]	@ (34014fac <RCCEx_GetI3CCLKFreq+0x254>)
34014dfc:	4293      	cmp	r3, r2
34014dfe:	f200 80b5 	bhi.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
34014e02:	4a6b      	ldr	r2, [pc, #428]	@ (34014fb0 <RCCEx_GetI3CCLKFreq+0x258>)
34014e04:	4293      	cmp	r3, r2
34014e06:	d003      	beq.n	34014e10 <RCCEx_GetI3CCLKFreq+0xb8>
34014e08:	4a6a      	ldr	r2, [pc, #424]	@ (34014fb4 <RCCEx_GetI3CCLKFreq+0x25c>)
34014e0a:	4293      	cmp	r3, r2
34014e0c:	f040 80ae 	bne.w	34014f6c <RCCEx_GetI3CCLKFreq+0x214>
  {
    case LL_RCC_I3C1_CLKSOURCE_PCLK1:
    case LL_RCC_I3C2_CLKSOURCE_PCLK1:
      i3c_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34014e10:	f7f9 feb6 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34014e14:	4603      	mov	r3, r0
34014e16:	4618      	mov	r0, r3
34014e18:	f7fe fe42 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34014e1c:	4603      	mov	r3, r0
34014e1e:	4618      	mov	r0, r3
34014e20:	f7fe fe4f 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34014e24:	60f8      	str	r0, [r7, #12]
      break;
34014e26:	e0aa      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_CLKP:
    case LL_RCC_I3C2_CLKSOURCE_CLKP:
      i3c_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34014e28:	2007      	movs	r0, #7
34014e2a:	f7ff f925 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34014e2e:	60f8      	str	r0, [r7, #12]
      break;
34014e30:	e0a5      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>

    case LL_RCC_I3C1_CLKSOURCE_IC10:
    case LL_RCC_I3C2_CLKSOURCE_IC10:
      if (LL_RCC_IC10_IsEnabled() != 0U)
34014e32:	f7fb fb09 	bl	34010448 <LL_RCC_IC10_IsEnabled>
34014e36:	4603      	mov	r3, r0
34014e38:	2b00      	cmp	r3, #0
34014e3a:	f000 8099 	beq.w	34014f70 <RCCEx_GetI3CCLKFreq+0x218>
      {
        ic_divider = LL_RCC_IC10_GetDivider();
34014e3e:	f7fb fb25 	bl	3401048c <LL_RCC_IC10_GetDivider>
34014e42:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC10_GetSource())
34014e44:	f7fb fb14 	bl	34010470 <LL_RCC_IC10_GetSource>
34014e48:	4603      	mov	r3, r0
34014e4a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014e4e:	d029      	beq.n	34014ea4 <RCCEx_GetI3CCLKFreq+0x14c>
34014e50:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014e54:	d82f      	bhi.n	34014eb6 <RCCEx_GetI3CCLKFreq+0x15e>
34014e56:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014e5a:	d01a      	beq.n	34014e92 <RCCEx_GetI3CCLKFreq+0x13a>
34014e5c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014e60:	d829      	bhi.n	34014eb6 <RCCEx_GetI3CCLKFreq+0x15e>
34014e62:	2b00      	cmp	r3, #0
34014e64:	d003      	beq.n	34014e6e <RCCEx_GetI3CCLKFreq+0x116>
34014e66:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014e6a:	d009      	beq.n	34014e80 <RCCEx_GetI3CCLKFreq+0x128>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014e6c:	e023      	b.n	34014eb6 <RCCEx_GetI3CCLKFreq+0x15e>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014e6e:	f7fe fcff 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014e72:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014e74:	68fa      	ldr	r2, [r7, #12]
34014e76:	68bb      	ldr	r3, [r7, #8]
34014e78:	fbb2 f3f3 	udiv	r3, r2, r3
34014e7c:	60fb      	str	r3, [r7, #12]
            break;
34014e7e:	e01b      	b.n	34014eb8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014e80:	f7fe fd3c 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014e84:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014e86:	68fa      	ldr	r2, [r7, #12]
34014e88:	68bb      	ldr	r3, [r7, #8]
34014e8a:	fbb2 f3f3 	udiv	r3, r2, r3
34014e8e:	60fb      	str	r3, [r7, #12]
            break;
34014e90:	e012      	b.n	34014eb8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014e92:	f7fe fd79 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014e96:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014e98:	68fa      	ldr	r2, [r7, #12]
34014e9a:	68bb      	ldr	r3, [r7, #8]
34014e9c:	fbb2 f3f3 	udiv	r3, r2, r3
34014ea0:	60fb      	str	r3, [r7, #12]
            break;
34014ea2:	e009      	b.n	34014eb8 <RCCEx_GetI3CCLKFreq+0x160>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014ea4:	f7fe fdb6 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014ea8:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014eaa:	68fa      	ldr	r2, [r7, #12]
34014eac:	68bb      	ldr	r3, [r7, #8]
34014eae:	fbb2 f3f3 	udiv	r3, r2, r3
34014eb2:	60fb      	str	r3, [r7, #12]
            break;
34014eb4:	e000      	b.n	34014eb8 <RCCEx_GetI3CCLKFreq+0x160>
            break;
34014eb6:	bf00      	nop
        }
      }
      break;
34014eb8:	e05a      	b.n	34014f70 <RCCEx_GetI3CCLKFreq+0x218>

    case LL_RCC_I3C1_CLKSOURCE_IC15:
    case LL_RCC_I3C2_CLKSOURCE_IC15:
      if (LL_RCC_IC15_IsEnabled() != 0U)
34014eba:	f7fb fbc5 	bl	34010648 <LL_RCC_IC15_IsEnabled>
34014ebe:	4603      	mov	r3, r0
34014ec0:	2b00      	cmp	r3, #0
34014ec2:	d057      	beq.n	34014f74 <RCCEx_GetI3CCLKFreq+0x21c>
      {
        ic_divider = LL_RCC_IC15_GetDivider();
34014ec4:	f7fb fbe2 	bl	3401068c <LL_RCC_IC15_GetDivider>
34014ec8:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34014eca:	f7fb fbd1 	bl	34010670 <LL_RCC_IC15_GetSource>
34014ece:	4603      	mov	r3, r0
34014ed0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014ed4:	d029      	beq.n	34014f2a <RCCEx_GetI3CCLKFreq+0x1d2>
34014ed6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34014eda:	d82f      	bhi.n	34014f3c <RCCEx_GetI3CCLKFreq+0x1e4>
34014edc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014ee0:	d01a      	beq.n	34014f18 <RCCEx_GetI3CCLKFreq+0x1c0>
34014ee2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34014ee6:	d829      	bhi.n	34014f3c <RCCEx_GetI3CCLKFreq+0x1e4>
34014ee8:	2b00      	cmp	r3, #0
34014eea:	d003      	beq.n	34014ef4 <RCCEx_GetI3CCLKFreq+0x19c>
34014eec:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34014ef0:	d009      	beq.n	34014f06 <RCCEx_GetI3CCLKFreq+0x1ae>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            i3c_frequency = i3c_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34014ef2:	e023      	b.n	34014f3c <RCCEx_GetI3CCLKFreq+0x1e4>
            i3c_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34014ef4:	f7fe fcbc 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34014ef8:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014efa:	68fa      	ldr	r2, [r7, #12]
34014efc:	68bb      	ldr	r3, [r7, #8]
34014efe:	fbb2 f3f3 	udiv	r3, r2, r3
34014f02:	60fb      	str	r3, [r7, #12]
            break;
34014f04:	e01b      	b.n	34014f3e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34014f06:	f7fe fcf9 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34014f0a:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014f0c:	68fa      	ldr	r2, [r7, #12]
34014f0e:	68bb      	ldr	r3, [r7, #8]
34014f10:	fbb2 f3f3 	udiv	r3, r2, r3
34014f14:	60fb      	str	r3, [r7, #12]
            break;
34014f16:	e012      	b.n	34014f3e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34014f18:	f7fe fd36 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34014f1c:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014f1e:	68fa      	ldr	r2, [r7, #12]
34014f20:	68bb      	ldr	r3, [r7, #8]
34014f22:	fbb2 f3f3 	udiv	r3, r2, r3
34014f26:	60fb      	str	r3, [r7, #12]
            break;
34014f28:	e009      	b.n	34014f3e <RCCEx_GetI3CCLKFreq+0x1e6>
            i3c_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34014f2a:	f7fe fd73 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34014f2e:	60f8      	str	r0, [r7, #12]
            i3c_frequency = i3c_frequency / ic_divider;
34014f30:	68fa      	ldr	r2, [r7, #12]
34014f32:	68bb      	ldr	r3, [r7, #8]
34014f34:	fbb2 f3f3 	udiv	r3, r2, r3
34014f38:	60fb      	str	r3, [r7, #12]
            break;
34014f3a:	e000      	b.n	34014f3e <RCCEx_GetI3CCLKFreq+0x1e6>
            break;
34014f3c:	bf00      	nop
        }
      }
      break;
34014f3e:	e019      	b.n	34014f74 <RCCEx_GetI3CCLKFreq+0x21c>

    case LL_RCC_I3C1_CLKSOURCE_HSI:
    case LL_RCC_I3C2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34014f40:	f7fa fa1e 	bl	3400f380 <LL_RCC_HSI_IsReady>
34014f44:	4603      	mov	r3, r0
34014f46:	2b00      	cmp	r3, #0
34014f48:	d016      	beq.n	34014f78 <RCCEx_GetI3CCLKFreq+0x220>
      {
        i3c_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34014f4a:	f7fa fa2b 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34014f4e:	4603      	mov	r3, r0
34014f50:	09db      	lsrs	r3, r3, #7
34014f52:	4a19      	ldr	r2, [pc, #100]	@ (34014fb8 <RCCEx_GetI3CCLKFreq+0x260>)
34014f54:	fa22 f303 	lsr.w	r3, r2, r3
34014f58:	60fb      	str	r3, [r7, #12]
      }
      break;
34014f5a:	e00d      	b.n	34014f78 <RCCEx_GetI3CCLKFreq+0x220>

    case LL_RCC_I3C1_CLKSOURCE_MSI:
    case LL_RCC_I3C2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34014f5c:	f7fa fa30 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34014f60:	4603      	mov	r3, r0
34014f62:	2b00      	cmp	r3, #0
34014f64:	d00a      	beq.n	34014f7c <RCCEx_GetI3CCLKFreq+0x224>
      {
        i3c_frequency = MSI_VALUE;
34014f66:	4b15      	ldr	r3, [pc, #84]	@ (34014fbc <RCCEx_GetI3CCLKFreq+0x264>)
34014f68:	60fb      	str	r3, [r7, #12]
      }
      break;
34014f6a:	e007      	b.n	34014f7c <RCCEx_GetI3CCLKFreq+0x224>

    default:
      /* Unexpected case */
      break;
34014f6c:	bf00      	nop
34014f6e:	e006      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34014f70:	bf00      	nop
34014f72:	e004      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34014f74:	bf00      	nop
34014f76:	e002      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34014f78:	bf00      	nop
34014f7a:	e000      	b.n	34014f7e <RCCEx_GetI3CCLKFreq+0x226>
      break;
34014f7c:	bf00      	nop
  }

  return i3c_frequency;
34014f7e:	68fb      	ldr	r3, [r7, #12]
}
34014f80:	4618      	mov	r0, r3
34014f82:	3710      	adds	r7, #16
34014f84:	46bd      	mov	sp, r7
34014f86:	bd80      	pop	{r7, pc}
34014f88:	0705140c 	.word	0x0705140c
34014f8c:	0705100c 	.word	0x0705100c
34014f90:	0704140c 	.word	0x0704140c
34014f94:	0704100c 	.word	0x0704100c
34014f98:	0703140c 	.word	0x0703140c
34014f9c:	0703100c 	.word	0x0703100c
34014fa0:	0702140c 	.word	0x0702140c
34014fa4:	0702100c 	.word	0x0702100c
34014fa8:	0701140c 	.word	0x0701140c
34014fac:	0701100c 	.word	0x0701100c
34014fb0:	0700100c 	.word	0x0700100c
34014fb4:	0700140c 	.word	0x0700140c
34014fb8:	03d09000 	.word	0x03d09000
34014fbc:	003d0900 	.word	0x003d0900

34014fc0 <RCCEx_GetLPTIMCLKFreq>:
  *         @arg @ref RCCEx_LPTIM5_Clock_Source
  * @retval LPTIM clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPTIMCLKFreq(uint32_t LPTIMxSource)
{
34014fc0:	b590      	push	{r4, r7, lr}
34014fc2:	b085      	sub	sp, #20
34014fc4:	af00      	add	r7, sp, #0
34014fc6:	6078      	str	r0, [r7, #4]
  uint32_t lptim_frequency = RCC_PERIPH_FREQUENCY_NO;
34014fc8:	2300      	movs	r3, #0
34014fca:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPTIMClockSource(LPTIMxSource))
34014fcc:	6878      	ldr	r0, [r7, #4]
34014fce:	f7fa fd35 	bl	3400fa3c <LL_RCC_GetLPTIMClockSource>
34014fd2:	4603      	mov	r3, r0
34014fd4:	4aa1      	ldr	r2, [pc, #644]	@ (3401525c <RCCEx_GetLPTIMCLKFreq+0x29c>)
34014fd6:	4293      	cmp	r3, r2
34014fd8:	f000 8185 	beq.w	340152e6 <RCCEx_GetLPTIMCLKFreq+0x326>
34014fdc:	4a9f      	ldr	r2, [pc, #636]	@ (3401525c <RCCEx_GetLPTIMCLKFreq+0x29c>)
34014fde:	4293      	cmp	r3, r2
34014fe0:	f200 818b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34014fe4:	4a9e      	ldr	r2, [pc, #632]	@ (34015260 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34014fe6:	4293      	cmp	r3, r2
34014fe8:	f000 817d 	beq.w	340152e6 <RCCEx_GetLPTIMCLKFreq+0x326>
34014fec:	4a9c      	ldr	r2, [pc, #624]	@ (34015260 <RCCEx_GetLPTIMCLKFreq+0x2a0>)
34014fee:	4293      	cmp	r3, r2
34014ff0:	f200 8183 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34014ff4:	4a9b      	ldr	r2, [pc, #620]	@ (34015264 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34014ff6:	4293      	cmp	r3, r2
34014ff8:	f000 8175 	beq.w	340152e6 <RCCEx_GetLPTIMCLKFreq+0x326>
34014ffc:	4a99      	ldr	r2, [pc, #612]	@ (34015264 <RCCEx_GetLPTIMCLKFreq+0x2a4>)
34014ffe:	4293      	cmp	r3, r2
34015000:	f200 817b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015004:	4a98      	ldr	r2, [pc, #608]	@ (34015268 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
34015006:	4293      	cmp	r3, r2
34015008:	f000 816d 	beq.w	340152e6 <RCCEx_GetLPTIMCLKFreq+0x326>
3401500c:	4a96      	ldr	r2, [pc, #600]	@ (34015268 <RCCEx_GetLPTIMCLKFreq+0x2a8>)
3401500e:	4293      	cmp	r3, r2
34015010:	f200 8173 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015014:	4a95      	ldr	r2, [pc, #596]	@ (3401526c <RCCEx_GetLPTIMCLKFreq+0x2ac>)
34015016:	4293      	cmp	r3, r2
34015018:	f000 8165 	beq.w	340152e6 <RCCEx_GetLPTIMCLKFreq+0x326>
3401501c:	4a93      	ldr	r2, [pc, #588]	@ (3401526c <RCCEx_GetLPTIMCLKFreq+0x2ac>)
3401501e:	4293      	cmp	r3, r2
34015020:	f200 816b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015024:	4a92      	ldr	r2, [pc, #584]	@ (34015270 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
34015026:	4293      	cmp	r3, r2
34015028:	f000 8154 	beq.w	340152d4 <RCCEx_GetLPTIMCLKFreq+0x314>
3401502c:	4a90      	ldr	r2, [pc, #576]	@ (34015270 <RCCEx_GetLPTIMCLKFreq+0x2b0>)
3401502e:	4293      	cmp	r3, r2
34015030:	f200 8163 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015034:	4a8f      	ldr	r2, [pc, #572]	@ (34015274 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
34015036:	4293      	cmp	r3, r2
34015038:	f000 814c 	beq.w	340152d4 <RCCEx_GetLPTIMCLKFreq+0x314>
3401503c:	4a8d      	ldr	r2, [pc, #564]	@ (34015274 <RCCEx_GetLPTIMCLKFreq+0x2b4>)
3401503e:	4293      	cmp	r3, r2
34015040:	f200 815b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015044:	4a8c      	ldr	r2, [pc, #560]	@ (34015278 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
34015046:	4293      	cmp	r3, r2
34015048:	f000 8144 	beq.w	340152d4 <RCCEx_GetLPTIMCLKFreq+0x314>
3401504c:	4a8a      	ldr	r2, [pc, #552]	@ (34015278 <RCCEx_GetLPTIMCLKFreq+0x2b8>)
3401504e:	4293      	cmp	r3, r2
34015050:	f200 8153 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015054:	4a89      	ldr	r2, [pc, #548]	@ (3401527c <RCCEx_GetLPTIMCLKFreq+0x2bc>)
34015056:	4293      	cmp	r3, r2
34015058:	f000 813c 	beq.w	340152d4 <RCCEx_GetLPTIMCLKFreq+0x314>
3401505c:	4a87      	ldr	r2, [pc, #540]	@ (3401527c <RCCEx_GetLPTIMCLKFreq+0x2bc>)
3401505e:	4293      	cmp	r3, r2
34015060:	f200 814b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015064:	4a86      	ldr	r2, [pc, #536]	@ (34015280 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
34015066:	4293      	cmp	r3, r2
34015068:	f000 8134 	beq.w	340152d4 <RCCEx_GetLPTIMCLKFreq+0x314>
3401506c:	4a84      	ldr	r2, [pc, #528]	@ (34015280 <RCCEx_GetLPTIMCLKFreq+0x2c0>)
3401506e:	4293      	cmp	r3, r2
34015070:	f200 8143 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015074:	4a83      	ldr	r2, [pc, #524]	@ (34015284 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
34015076:	4293      	cmp	r3, r2
34015078:	f000 80e7 	beq.w	3401524a <RCCEx_GetLPTIMCLKFreq+0x28a>
3401507c:	4a81      	ldr	r2, [pc, #516]	@ (34015284 <RCCEx_GetLPTIMCLKFreq+0x2c4>)
3401507e:	4293      	cmp	r3, r2
34015080:	f200 813b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015084:	4a80      	ldr	r2, [pc, #512]	@ (34015288 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
34015086:	4293      	cmp	r3, r2
34015088:	f000 80df 	beq.w	3401524a <RCCEx_GetLPTIMCLKFreq+0x28a>
3401508c:	4a7e      	ldr	r2, [pc, #504]	@ (34015288 <RCCEx_GetLPTIMCLKFreq+0x2c8>)
3401508e:	4293      	cmp	r3, r2
34015090:	f200 8133 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015094:	4a7d      	ldr	r2, [pc, #500]	@ (3401528c <RCCEx_GetLPTIMCLKFreq+0x2cc>)
34015096:	4293      	cmp	r3, r2
34015098:	f000 80d7 	beq.w	3401524a <RCCEx_GetLPTIMCLKFreq+0x28a>
3401509c:	4a7b      	ldr	r2, [pc, #492]	@ (3401528c <RCCEx_GetLPTIMCLKFreq+0x2cc>)
3401509e:	4293      	cmp	r3, r2
340150a0:	f200 812b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150a4:	4a7a      	ldr	r2, [pc, #488]	@ (34015290 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
340150a6:	4293      	cmp	r3, r2
340150a8:	f000 80cf 	beq.w	3401524a <RCCEx_GetLPTIMCLKFreq+0x28a>
340150ac:	4a78      	ldr	r2, [pc, #480]	@ (34015290 <RCCEx_GetLPTIMCLKFreq+0x2d0>)
340150ae:	4293      	cmp	r3, r2
340150b0:	f200 8123 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150b4:	4a77      	ldr	r2, [pc, #476]	@ (34015294 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
340150b6:	4293      	cmp	r3, r2
340150b8:	f000 80c7 	beq.w	3401524a <RCCEx_GetLPTIMCLKFreq+0x28a>
340150bc:	4a75      	ldr	r2, [pc, #468]	@ (34015294 <RCCEx_GetLPTIMCLKFreq+0x2d4>)
340150be:	4293      	cmp	r3, r2
340150c0:	f200 811b 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150c4:	4a74      	ldr	r2, [pc, #464]	@ (34015298 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
340150c6:	4293      	cmp	r3, r2
340150c8:	d07b      	beq.n	340151c2 <RCCEx_GetLPTIMCLKFreq+0x202>
340150ca:	4a73      	ldr	r2, [pc, #460]	@ (34015298 <RCCEx_GetLPTIMCLKFreq+0x2d8>)
340150cc:	4293      	cmp	r3, r2
340150ce:	f200 8114 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150d2:	4a72      	ldr	r2, [pc, #456]	@ (3401529c <RCCEx_GetLPTIMCLKFreq+0x2dc>)
340150d4:	4293      	cmp	r3, r2
340150d6:	d074      	beq.n	340151c2 <RCCEx_GetLPTIMCLKFreq+0x202>
340150d8:	4a70      	ldr	r2, [pc, #448]	@ (3401529c <RCCEx_GetLPTIMCLKFreq+0x2dc>)
340150da:	4293      	cmp	r3, r2
340150dc:	f200 810d 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150e0:	4a6f      	ldr	r2, [pc, #444]	@ (340152a0 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
340150e2:	4293      	cmp	r3, r2
340150e4:	d06d      	beq.n	340151c2 <RCCEx_GetLPTIMCLKFreq+0x202>
340150e6:	4a6e      	ldr	r2, [pc, #440]	@ (340152a0 <RCCEx_GetLPTIMCLKFreq+0x2e0>)
340150e8:	4293      	cmp	r3, r2
340150ea:	f200 8106 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150ee:	4a6d      	ldr	r2, [pc, #436]	@ (340152a4 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
340150f0:	4293      	cmp	r3, r2
340150f2:	d066      	beq.n	340151c2 <RCCEx_GetLPTIMCLKFreq+0x202>
340150f4:	4a6b      	ldr	r2, [pc, #428]	@ (340152a4 <RCCEx_GetLPTIMCLKFreq+0x2e4>)
340150f6:	4293      	cmp	r3, r2
340150f8:	f200 80ff 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
340150fc:	4a6a      	ldr	r2, [pc, #424]	@ (340152a8 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
340150fe:	4293      	cmp	r3, r2
34015100:	d05f      	beq.n	340151c2 <RCCEx_GetLPTIMCLKFreq+0x202>
34015102:	4a69      	ldr	r2, [pc, #420]	@ (340152a8 <RCCEx_GetLPTIMCLKFreq+0x2e8>)
34015104:	4293      	cmp	r3, r2
34015106:	f200 80f8 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
3401510a:	4a68      	ldr	r2, [pc, #416]	@ (340152ac <RCCEx_GetLPTIMCLKFreq+0x2ec>)
3401510c:	4293      	cmp	r3, r2
3401510e:	d053      	beq.n	340151b8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34015110:	4a66      	ldr	r2, [pc, #408]	@ (340152ac <RCCEx_GetLPTIMCLKFreq+0x2ec>)
34015112:	4293      	cmp	r3, r2
34015114:	f200 80f1 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015118:	4a65      	ldr	r2, [pc, #404]	@ (340152b0 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
3401511a:	4293      	cmp	r3, r2
3401511c:	d04c      	beq.n	340151b8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401511e:	4a64      	ldr	r2, [pc, #400]	@ (340152b0 <RCCEx_GetLPTIMCLKFreq+0x2f0>)
34015120:	4293      	cmp	r3, r2
34015122:	f200 80ea 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015126:	4a63      	ldr	r2, [pc, #396]	@ (340152b4 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
34015128:	4293      	cmp	r3, r2
3401512a:	d045      	beq.n	340151b8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401512c:	4a61      	ldr	r2, [pc, #388]	@ (340152b4 <RCCEx_GetLPTIMCLKFreq+0x2f4>)
3401512e:	4293      	cmp	r3, r2
34015130:	f200 80e3 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015134:	4a60      	ldr	r2, [pc, #384]	@ (340152b8 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
34015136:	4293      	cmp	r3, r2
34015138:	d03e      	beq.n	340151b8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
3401513a:	4a5f      	ldr	r2, [pc, #380]	@ (340152b8 <RCCEx_GetLPTIMCLKFreq+0x2f8>)
3401513c:	4293      	cmp	r3, r2
3401513e:	f200 80dc 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015142:	4a5e      	ldr	r2, [pc, #376]	@ (340152bc <RCCEx_GetLPTIMCLKFreq+0x2fc>)
34015144:	4293      	cmp	r3, r2
34015146:	d037      	beq.n	340151b8 <RCCEx_GetLPTIMCLKFreq+0x1f8>
34015148:	4a5c      	ldr	r2, [pc, #368]	@ (340152bc <RCCEx_GetLPTIMCLKFreq+0x2fc>)
3401514a:	4293      	cmp	r3, r2
3401514c:	f200 80d5 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
34015150:	4a5b      	ldr	r2, [pc, #364]	@ (340152c0 <RCCEx_GetLPTIMCLKFreq+0x300>)
34015152:	4293      	cmp	r3, r2
34015154:	d024      	beq.n	340151a0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34015156:	4a5a      	ldr	r2, [pc, #360]	@ (340152c0 <RCCEx_GetLPTIMCLKFreq+0x300>)
34015158:	4293      	cmp	r3, r2
3401515a:	f200 80ce 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
3401515e:	4a59      	ldr	r2, [pc, #356]	@ (340152c4 <RCCEx_GetLPTIMCLKFreq+0x304>)
34015160:	4293      	cmp	r3, r2
34015162:	d01d      	beq.n	340151a0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34015164:	4a57      	ldr	r2, [pc, #348]	@ (340152c4 <RCCEx_GetLPTIMCLKFreq+0x304>)
34015166:	4293      	cmp	r3, r2
34015168:	f200 80c7 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
3401516c:	4a56      	ldr	r2, [pc, #344]	@ (340152c8 <RCCEx_GetLPTIMCLKFreq+0x308>)
3401516e:	4293      	cmp	r3, r2
34015170:	d016      	beq.n	340151a0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
34015172:	4a55      	ldr	r2, [pc, #340]	@ (340152c8 <RCCEx_GetLPTIMCLKFreq+0x308>)
34015174:	4293      	cmp	r3, r2
34015176:	f200 80c0 	bhi.w	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
3401517a:	4a54      	ldr	r2, [pc, #336]	@ (340152cc <RCCEx_GetLPTIMCLKFreq+0x30c>)
3401517c:	4293      	cmp	r3, r2
3401517e:	d003      	beq.n	34015188 <RCCEx_GetLPTIMCLKFreq+0x1c8>
34015180:	4a53      	ldr	r2, [pc, #332]	@ (340152d0 <RCCEx_GetLPTIMCLKFreq+0x310>)
34015182:	4293      	cmp	r3, r2
34015184:	d00c      	beq.n	340151a0 <RCCEx_GetLPTIMCLKFreq+0x1e0>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
34015186:	e0b8      	b.n	340152fa <RCCEx_GetLPTIMCLKFreq+0x33a>
      lptim_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34015188:	f7f9 fcfa 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
3401518c:	4603      	mov	r3, r0
3401518e:	4618      	mov	r0, r3
34015190:	f7fe fc86 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34015194:	4603      	mov	r3, r0
34015196:	4618      	mov	r0, r3
34015198:	f7fe fc93 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
3401519c:	60f8      	str	r0, [r7, #12]
      break;
3401519e:	e0b3      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340151a0:	f7f9 fcee 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340151a4:	4603      	mov	r3, r0
340151a6:	4618      	mov	r0, r3
340151a8:	f7fe fc7a 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340151ac:	4603      	mov	r3, r0
340151ae:	4618      	mov	r0, r3
340151b0:	f7fe fca8 	bl	34013b04 <RCCEx_GetPCLK4Freq>
340151b4:	60f8      	str	r0, [r7, #12]
      break;
340151b6:	e0a7      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      lptim_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340151b8:	2007      	movs	r0, #7
340151ba:	f7fe ff5d 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340151be:	60f8      	str	r0, [r7, #12]
      break;
340151c0:	e0a2      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      if (LL_RCC_IC15_IsEnabled() != 0U)
340151c2:	f7fb fa41 	bl	34010648 <LL_RCC_IC15_IsEnabled>
340151c6:	4603      	mov	r3, r0
340151c8:	2b00      	cmp	r3, #0
340151ca:	f000 8098 	beq.w	340152fe <RCCEx_GetLPTIMCLKFreq+0x33e>
        ic_divider = LL_RCC_IC15_GetDivider();
340151ce:	f7fb fa5d 	bl	3401068c <LL_RCC_IC15_GetDivider>
340151d2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
340151d4:	f7fb fa4c 	bl	34010670 <LL_RCC_IC15_GetSource>
340151d8:	4603      	mov	r3, r0
340151da:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340151de:	d029      	beq.n	34015234 <RCCEx_GetLPTIMCLKFreq+0x274>
340151e0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340151e4:	d82f      	bhi.n	34015246 <RCCEx_GetLPTIMCLKFreq+0x286>
340151e6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340151ea:	d01a      	beq.n	34015222 <RCCEx_GetLPTIMCLKFreq+0x262>
340151ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340151f0:	d829      	bhi.n	34015246 <RCCEx_GetLPTIMCLKFreq+0x286>
340151f2:	2b00      	cmp	r3, #0
340151f4:	d003      	beq.n	340151fe <RCCEx_GetLPTIMCLKFreq+0x23e>
340151f6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340151fa:	d009      	beq.n	34015210 <RCCEx_GetLPTIMCLKFreq+0x250>
            break;
340151fc:	e023      	b.n	34015246 <RCCEx_GetLPTIMCLKFreq+0x286>
            lptim_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340151fe:	f7fe fb37 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015202:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34015204:	68fa      	ldr	r2, [r7, #12]
34015206:	68bb      	ldr	r3, [r7, #8]
34015208:	fbb2 f3f3 	udiv	r3, r2, r3
3401520c:	60fb      	str	r3, [r7, #12]
            break;
3401520e:	e01b      	b.n	34015248 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015210:	f7fe fb74 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015214:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34015216:	68fa      	ldr	r2, [r7, #12]
34015218:	68bb      	ldr	r3, [r7, #8]
3401521a:	fbb2 f3f3 	udiv	r3, r2, r3
3401521e:	60fb      	str	r3, [r7, #12]
            break;
34015220:	e012      	b.n	34015248 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015222:	f7fe fbb1 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015226:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
34015228:	68fa      	ldr	r2, [r7, #12]
3401522a:	68bb      	ldr	r3, [r7, #8]
3401522c:	fbb2 f3f3 	udiv	r3, r2, r3
34015230:	60fb      	str	r3, [r7, #12]
            break;
34015232:	e009      	b.n	34015248 <RCCEx_GetLPTIMCLKFreq+0x288>
            lptim_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015234:	f7fe fbee 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015238:	60f8      	str	r0, [r7, #12]
            lptim_frequency = lptim_frequency / ic_divider;
3401523a:	68fa      	ldr	r2, [r7, #12]
3401523c:	68bb      	ldr	r3, [r7, #8]
3401523e:	fbb2 f3f3 	udiv	r3, r2, r3
34015242:	60fb      	str	r3, [r7, #12]
            break;
34015244:	e000      	b.n	34015248 <RCCEx_GetLPTIMCLKFreq+0x288>
            break;
34015246:	bf00      	nop
      break;
34015248:	e059      	b.n	340152fe <RCCEx_GetLPTIMCLKFreq+0x33e>
      if (LL_RCC_LSE_IsReady() != 0U)
3401524a:	f7fa f8d9 	bl	3400f400 <LL_RCC_LSE_IsReady>
3401524e:	4603      	mov	r3, r0
34015250:	2b00      	cmp	r3, #0
34015252:	d056      	beq.n	34015302 <RCCEx_GetLPTIMCLKFreq+0x342>
        lptim_frequency = LSE_VALUE;
34015254:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34015258:	60fb      	str	r3, [r7, #12]
      break;
3401525a:	e052      	b.n	34015302 <RCCEx_GetLPTIMCLKFreq+0x342>
3401525c:	0705182c 	.word	0x0705182c
34015260:	0705142c 	.word	0x0705142c
34015264:	0705102c 	.word	0x0705102c
34015268:	07050c2c 	.word	0x07050c2c
3401526c:	0705082c 	.word	0x0705082c
34015270:	0704182c 	.word	0x0704182c
34015274:	0704142c 	.word	0x0704142c
34015278:	0704102c 	.word	0x0704102c
3401527c:	07040c2c 	.word	0x07040c2c
34015280:	0704082c 	.word	0x0704082c
34015284:	0703182c 	.word	0x0703182c
34015288:	0703142c 	.word	0x0703142c
3401528c:	0703102c 	.word	0x0703102c
34015290:	07030c2c 	.word	0x07030c2c
34015294:	0703082c 	.word	0x0703082c
34015298:	0702182c 	.word	0x0702182c
3401529c:	0702142c 	.word	0x0702142c
340152a0:	0702102c 	.word	0x0702102c
340152a4:	07020c2c 	.word	0x07020c2c
340152a8:	0702082c 	.word	0x0702082c
340152ac:	0701182c 	.word	0x0701182c
340152b0:	0701142c 	.word	0x0701142c
340152b4:	0701102c 	.word	0x0701102c
340152b8:	07010c2c 	.word	0x07010c2c
340152bc:	0701082c 	.word	0x0701082c
340152c0:	0700182c 	.word	0x0700182c
340152c4:	0700142c 	.word	0x0700142c
340152c8:	0700102c 	.word	0x0700102c
340152cc:	0700082c 	.word	0x0700082c
340152d0:	07000c2c 	.word	0x07000c2c
      if (LL_RCC_LSI_IsReady() != 0U)
340152d4:	f7fa f8a6 	bl	3400f424 <LL_RCC_LSI_IsReady>
340152d8:	4603      	mov	r3, r0
340152da:	2b00      	cmp	r3, #0
340152dc:	d013      	beq.n	34015306 <RCCEx_GetLPTIMCLKFreq+0x346>
        lptim_frequency = LSI_VALUE;
340152de:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
340152e2:	60fb      	str	r3, [r7, #12]
      break;
340152e4:	e00f      	b.n	34015306 <RCCEx_GetLPTIMCLKFreq+0x346>
      lptim_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
340152e6:	f7f9 fc4b 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340152ea:	4604      	mov	r4, r0
340152ec:	f7fa fcb0 	bl	3400fc50 <LL_RCC_GetTIMPrescaler>
340152f0:	4603      	mov	r3, r0
340152f2:	fa24 f303 	lsr.w	r3, r4, r3
340152f6:	60fb      	str	r3, [r7, #12]
      break;
340152f8:	e006      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340152fa:	bf00      	nop
340152fc:	e004      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
340152fe:	bf00      	nop
34015300:	e002      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34015302:	bf00      	nop
34015304:	e000      	b.n	34015308 <RCCEx_GetLPTIMCLKFreq+0x348>
      break;
34015306:	bf00      	nop
  }

  return lptim_frequency;
34015308:	68fb      	ldr	r3, [r7, #12]
}
3401530a:	4618      	mov	r0, r3
3401530c:	3714      	adds	r7, #20
3401530e:	46bd      	mov	sp, r7
34015310:	bd90      	pop	{r4, r7, pc}
34015312:	bf00      	nop

34015314 <RCCEx_GetLPUARTCLKFreq>:
  *         @arg @ref RCCEx_LPUART1_Clock_Source
  * @retval LPUART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLPUARTCLKFreq(uint32_t LPUARTxSource)
{
34015314:	b580      	push	{r7, lr}
34015316:	b084      	sub	sp, #16
34015318:	af00      	add	r7, sp, #0
3401531a:	6078      	str	r0, [r7, #4]
  uint32_t lpuart_frequency = RCC_PERIPH_FREQUENCY_NO;
3401531c:	2300      	movs	r3, #0
3401531e:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLPUARTClockSource(LPUARTxSource))
34015320:	6878      	ldr	r0, [r7, #4]
34015322:	f7fa fb97 	bl	3400fa54 <LL_RCC_GetLPUARTClockSource>
34015326:	4603      	mov	r3, r0
34015328:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
3401532c:	f000 80c0 	beq.w	340154b0 <RCCEx_GetLPUARTCLKFreq+0x19c>
34015330:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34015334:	f200 80db 	bhi.w	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
34015338:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
3401533c:	f000 80c6 	beq.w	340154cc <RCCEx_GetLPUARTCLKFreq+0x1b8>
34015340:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
34015344:	f200 80d3 	bhi.w	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
34015348:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
3401534c:	f000 80c6 	beq.w	340154dc <RCCEx_GetLPUARTCLKFreq+0x1c8>
34015350:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
34015354:	f200 80cb 	bhi.w	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
34015358:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401535c:	d065      	beq.n	3401542a <RCCEx_GetLPUARTCLKFreq+0x116>
3401535e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34015362:	f200 80c4 	bhi.w	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
34015366:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401536a:	d01a      	beq.n	340153a2 <RCCEx_GetLPUARTCLKFreq+0x8e>
3401536c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34015370:	f200 80bd 	bhi.w	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
34015374:	2b00      	cmp	r3, #0
34015376:	d003      	beq.n	34015380 <RCCEx_GetLPUARTCLKFreq+0x6c>
34015378:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401537c:	d00c      	beq.n	34015398 <RCCEx_GetLPUARTCLKFreq+0x84>
      }
      break;

    default:
      /* Unexpected case */
      break;
3401537e:	e0b6      	b.n	340154ee <RCCEx_GetLPUARTCLKFreq+0x1da>
      lpuart_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34015380:	f7f9 fbfe 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015384:	4603      	mov	r3, r0
34015386:	4618      	mov	r0, r3
34015388:	f7fe fb8a 	bl	34013aa0 <RCCEx_GetHCLKFreq>
3401538c:	4603      	mov	r3, r0
3401538e:	4618      	mov	r0, r3
34015390:	f7fe fbb8 	bl	34013b04 <RCCEx_GetPCLK4Freq>
34015394:	60f8      	str	r0, [r7, #12]
      break;
34015396:	e0b5      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      lpuart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015398:	2007      	movs	r0, #7
3401539a:	f7fe fe6d 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
3401539e:	60f8      	str	r0, [r7, #12]
      break;
340153a0:	e0b0      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      if (LL_RCC_IC9_IsEnabled() != 0U)
340153a2:	f7fb f811 	bl	340103c8 <LL_RCC_IC9_IsEnabled>
340153a6:	4603      	mov	r3, r0
340153a8:	2b00      	cmp	r3, #0
340153aa:	f000 80a2 	beq.w	340154f2 <RCCEx_GetLPUARTCLKFreq+0x1de>
        ic_divider = LL_RCC_IC9_GetDivider();
340153ae:	f7fb f82d 	bl	3401040c <LL_RCC_IC9_GetDivider>
340153b2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
340153b4:	f7fb f81c 	bl	340103f0 <LL_RCC_IC9_GetSource>
340153b8:	4603      	mov	r3, r0
340153ba:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340153be:	d029      	beq.n	34015414 <RCCEx_GetLPUARTCLKFreq+0x100>
340153c0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340153c4:	d82f      	bhi.n	34015426 <RCCEx_GetLPUARTCLKFreq+0x112>
340153c6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340153ca:	d01a      	beq.n	34015402 <RCCEx_GetLPUARTCLKFreq+0xee>
340153cc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340153d0:	d829      	bhi.n	34015426 <RCCEx_GetLPUARTCLKFreq+0x112>
340153d2:	2b00      	cmp	r3, #0
340153d4:	d003      	beq.n	340153de <RCCEx_GetLPUARTCLKFreq+0xca>
340153d6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340153da:	d009      	beq.n	340153f0 <RCCEx_GetLPUARTCLKFreq+0xdc>
            break;
340153dc:	e023      	b.n	34015426 <RCCEx_GetLPUARTCLKFreq+0x112>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340153de:	f7fe fa47 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340153e2:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340153e4:	68fa      	ldr	r2, [r7, #12]
340153e6:	68bb      	ldr	r3, [r7, #8]
340153e8:	fbb2 f3f3 	udiv	r3, r2, r3
340153ec:	60fb      	str	r3, [r7, #12]
            break;
340153ee:	e01b      	b.n	34015428 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340153f0:	f7fe fa84 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340153f4:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340153f6:	68fa      	ldr	r2, [r7, #12]
340153f8:	68bb      	ldr	r3, [r7, #8]
340153fa:	fbb2 f3f3 	udiv	r3, r2, r3
340153fe:	60fb      	str	r3, [r7, #12]
            break;
34015400:	e012      	b.n	34015428 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015402:	f7fe fac1 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015406:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
34015408:	68fa      	ldr	r2, [r7, #12]
3401540a:	68bb      	ldr	r3, [r7, #8]
3401540c:	fbb2 f3f3 	udiv	r3, r2, r3
34015410:	60fb      	str	r3, [r7, #12]
            break;
34015412:	e009      	b.n	34015428 <RCCEx_GetLPUARTCLKFreq+0x114>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015414:	f7fe fafe 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015418:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3401541a:	68fa      	ldr	r2, [r7, #12]
3401541c:	68bb      	ldr	r3, [r7, #8]
3401541e:	fbb2 f3f3 	udiv	r3, r2, r3
34015422:	60fb      	str	r3, [r7, #12]
            break;
34015424:	e000      	b.n	34015428 <RCCEx_GetLPUARTCLKFreq+0x114>
            break;
34015426:	bf00      	nop
      break;
34015428:	e063      	b.n	340154f2 <RCCEx_GetLPUARTCLKFreq+0x1de>
      if (LL_RCC_IC14_IsEnabled() != 0U)
3401542a:	f7fb f8cd 	bl	340105c8 <LL_RCC_IC14_IsEnabled>
3401542e:	4603      	mov	r3, r0
34015430:	2b00      	cmp	r3, #0
34015432:	d060      	beq.n	340154f6 <RCCEx_GetLPUARTCLKFreq+0x1e2>
        ic_divider = LL_RCC_IC14_GetDivider();
34015434:	f7fb f8ea 	bl	3401060c <LL_RCC_IC14_GetDivider>
34015438:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3401543a:	f7fb f8d9 	bl	340105f0 <LL_RCC_IC14_GetSource>
3401543e:	4603      	mov	r3, r0
34015440:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015444:	d029      	beq.n	3401549a <RCCEx_GetLPUARTCLKFreq+0x186>
34015446:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401544a:	d82f      	bhi.n	340154ac <RCCEx_GetLPUARTCLKFreq+0x198>
3401544c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015450:	d01a      	beq.n	34015488 <RCCEx_GetLPUARTCLKFreq+0x174>
34015452:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015456:	d829      	bhi.n	340154ac <RCCEx_GetLPUARTCLKFreq+0x198>
34015458:	2b00      	cmp	r3, #0
3401545a:	d003      	beq.n	34015464 <RCCEx_GetLPUARTCLKFreq+0x150>
3401545c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015460:	d009      	beq.n	34015476 <RCCEx_GetLPUARTCLKFreq+0x162>
            break;
34015462:	e023      	b.n	340154ac <RCCEx_GetLPUARTCLKFreq+0x198>
            lpuart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015464:	f7fe fa04 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015468:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3401546a:	68fa      	ldr	r2, [r7, #12]
3401546c:	68bb      	ldr	r3, [r7, #8]
3401546e:	fbb2 f3f3 	udiv	r3, r2, r3
34015472:	60fb      	str	r3, [r7, #12]
            break;
34015474:	e01b      	b.n	340154ae <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015476:	f7fe fa41 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401547a:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3401547c:	68fa      	ldr	r2, [r7, #12]
3401547e:	68bb      	ldr	r3, [r7, #8]
34015480:	fbb2 f3f3 	udiv	r3, r2, r3
34015484:	60fb      	str	r3, [r7, #12]
            break;
34015486:	e012      	b.n	340154ae <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015488:	f7fe fa7e 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401548c:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
3401548e:	68fa      	ldr	r2, [r7, #12]
34015490:	68bb      	ldr	r3, [r7, #8]
34015492:	fbb2 f3f3 	udiv	r3, r2, r3
34015496:	60fb      	str	r3, [r7, #12]
            break;
34015498:	e009      	b.n	340154ae <RCCEx_GetLPUARTCLKFreq+0x19a>
            lpuart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401549a:	f7fe fabb 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401549e:	60f8      	str	r0, [r7, #12]
            lpuart_frequency = lpuart_frequency / ic_divider;
340154a0:	68fa      	ldr	r2, [r7, #12]
340154a2:	68bb      	ldr	r3, [r7, #8]
340154a4:	fbb2 f3f3 	udiv	r3, r2, r3
340154a8:	60fb      	str	r3, [r7, #12]
            break;
340154aa:	e000      	b.n	340154ae <RCCEx_GetLPUARTCLKFreq+0x19a>
            break;
340154ac:	bf00      	nop
      break;
340154ae:	e022      	b.n	340154f6 <RCCEx_GetLPUARTCLKFreq+0x1e2>
      if (LL_RCC_HSI_IsReady() != 0U)
340154b0:	f7f9 ff66 	bl	3400f380 <LL_RCC_HSI_IsReady>
340154b4:	4603      	mov	r3, r0
340154b6:	2b00      	cmp	r3, #0
340154b8:	d01f      	beq.n	340154fa <RCCEx_GetLPUARTCLKFreq+0x1e6>
        lpuart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340154ba:	f7f9 ff73 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
340154be:	4603      	mov	r3, r0
340154c0:	09db      	lsrs	r3, r3, #7
340154c2:	4a13      	ldr	r2, [pc, #76]	@ (34015510 <RCCEx_GetLPUARTCLKFreq+0x1fc>)
340154c4:	fa22 f303 	lsr.w	r3, r2, r3
340154c8:	60fb      	str	r3, [r7, #12]
      break;
340154ca:	e016      	b.n	340154fa <RCCEx_GetLPUARTCLKFreq+0x1e6>
      if (LL_RCC_MSI_IsReady() != 0U)
340154cc:	f7f9 ff78 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
340154d0:	4603      	mov	r3, r0
340154d2:	2b00      	cmp	r3, #0
340154d4:	d013      	beq.n	340154fe <RCCEx_GetLPUARTCLKFreq+0x1ea>
        lpuart_frequency = MSI_VALUE;
340154d6:	4b0f      	ldr	r3, [pc, #60]	@ (34015514 <RCCEx_GetLPUARTCLKFreq+0x200>)
340154d8:	60fb      	str	r3, [r7, #12]
      break;
340154da:	e010      	b.n	340154fe <RCCEx_GetLPUARTCLKFreq+0x1ea>
      if (LL_RCC_LSE_IsReady() != 0U)
340154dc:	f7f9 ff90 	bl	3400f400 <LL_RCC_LSE_IsReady>
340154e0:	4603      	mov	r3, r0
340154e2:	2b00      	cmp	r3, #0
340154e4:	d00d      	beq.n	34015502 <RCCEx_GetLPUARTCLKFreq+0x1ee>
        lpuart_frequency = LSE_VALUE;
340154e6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
340154ea:	60fb      	str	r3, [r7, #12]
      break;
340154ec:	e009      	b.n	34015502 <RCCEx_GetLPUARTCLKFreq+0x1ee>
      break;
340154ee:	bf00      	nop
340154f0:	e008      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
340154f2:	bf00      	nop
340154f4:	e006      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
340154f6:	bf00      	nop
340154f8:	e004      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
340154fa:	bf00      	nop
340154fc:	e002      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
340154fe:	bf00      	nop
34015500:	e000      	b.n	34015504 <RCCEx_GetLPUARTCLKFreq+0x1f0>
      break;
34015502:	bf00      	nop
  }

  return lpuart_frequency;
34015504:	68fb      	ldr	r3, [r7, #12]
}
34015506:	4618      	mov	r0, r3
34015508:	3710      	adds	r7, #16
3401550a:	46bd      	mov	sp, r7
3401550c:	bd80      	pop	{r7, pc}
3401550e:	bf00      	nop
34015510:	03d09000 	.word	0x03d09000
34015514:	003d0900 	.word	0x003d0900

34015518 <RCCEx_GetLTDCCLKFreq>:
  *         @arg @ref RCCEx_LTDC_Clock_Source
  * @retval LTDC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetLTDCCLKFreq(uint32_t LTDCxSource)
{
34015518:	b580      	push	{r7, lr}
3401551a:	b084      	sub	sp, #16
3401551c:	af00      	add	r7, sp, #0
3401551e:	6078      	str	r0, [r7, #4]
  uint32_t ltdc_frequency = RCC_PERIPH_FREQUENCY_NO;
34015520:	2300      	movs	r3, #0
34015522:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetLTDCClockSource(LTDCxSource))
34015524:	6878      	ldr	r0, [r7, #4]
34015526:	f7fa faa7 	bl	3400fa78 <LL_RCC_GetLTDCClockSource>
3401552a:	4603      	mov	r3, r0
3401552c:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34015530:	d062      	beq.n	340155f8 <RCCEx_GetLTDCCLKFreq+0xe0>
34015532:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
34015536:	d86d      	bhi.n	34015614 <RCCEx_GetLTDCCLKFreq+0xfc>
34015538:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
3401553c:	d019      	beq.n	34015572 <RCCEx_GetLTDCCLKFreq+0x5a>
3401553e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34015542:	d867      	bhi.n	34015614 <RCCEx_GetLTDCCLKFreq+0xfc>
34015544:	2b00      	cmp	r3, #0
34015546:	d003      	beq.n	34015550 <RCCEx_GetLTDCCLKFreq+0x38>
34015548:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
3401554c:	d00c      	beq.n	34015568 <RCCEx_GetLTDCCLKFreq+0x50>
      }
      break;

    default:
      /* Unexpected case */
      break;
3401554e:	e061      	b.n	34015614 <RCCEx_GetLTDCCLKFreq+0xfc>
      ltdc_frequency = RCCEx_GetPCLK5Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34015550:	f7f9 fb16 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015554:	4603      	mov	r3, r0
34015556:	4618      	mov	r0, r3
34015558:	f7fe faa2 	bl	34013aa0 <RCCEx_GetHCLKFreq>
3401555c:	4603      	mov	r3, r0
3401555e:	4618      	mov	r0, r3
34015560:	f7fe fae1 	bl	34013b26 <RCCEx_GetPCLK5Freq>
34015564:	60f8      	str	r0, [r7, #12]
      break;
34015566:	e05a      	b.n	3401561e <RCCEx_GetLTDCCLKFreq+0x106>
      ltdc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015568:	2007      	movs	r0, #7
3401556a:	f7fe fd85 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
3401556e:	60f8      	str	r0, [r7, #12]
      break;
34015570:	e055      	b.n	3401561e <RCCEx_GetLTDCCLKFreq+0x106>
      if (LL_RCC_IC16_IsEnabled() != 0U)
34015572:	f7fb f8a9 	bl	340106c8 <LL_RCC_IC16_IsEnabled>
34015576:	4603      	mov	r3, r0
34015578:	2b00      	cmp	r3, #0
3401557a:	d04d      	beq.n	34015618 <RCCEx_GetLTDCCLKFreq+0x100>
        ic_divider = LL_RCC_IC16_GetDivider();
3401557c:	f7fb f8c6 	bl	3401070c <LL_RCC_IC16_GetDivider>
34015580:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC16_GetSource())
34015582:	f7fb f8b5 	bl	340106f0 <LL_RCC_IC16_GetSource>
34015586:	4603      	mov	r3, r0
34015588:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401558c:	d029      	beq.n	340155e2 <RCCEx_GetLTDCCLKFreq+0xca>
3401558e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015592:	d82f      	bhi.n	340155f4 <RCCEx_GetLTDCCLKFreq+0xdc>
34015594:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015598:	d01a      	beq.n	340155d0 <RCCEx_GetLTDCCLKFreq+0xb8>
3401559a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401559e:	d829      	bhi.n	340155f4 <RCCEx_GetLTDCCLKFreq+0xdc>
340155a0:	2b00      	cmp	r3, #0
340155a2:	d003      	beq.n	340155ac <RCCEx_GetLTDCCLKFreq+0x94>
340155a4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340155a8:	d009      	beq.n	340155be <RCCEx_GetLTDCCLKFreq+0xa6>
            break;
340155aa:	e023      	b.n	340155f4 <RCCEx_GetLTDCCLKFreq+0xdc>
            ltdc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340155ac:	f7fe f960 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340155b0:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
340155b2:	68fa      	ldr	r2, [r7, #12]
340155b4:	68bb      	ldr	r3, [r7, #8]
340155b6:	fbb2 f3f3 	udiv	r3, r2, r3
340155ba:	60fb      	str	r3, [r7, #12]
            break;
340155bc:	e01b      	b.n	340155f6 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340155be:	f7fe f99d 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340155c2:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
340155c4:	68fa      	ldr	r2, [r7, #12]
340155c6:	68bb      	ldr	r3, [r7, #8]
340155c8:	fbb2 f3f3 	udiv	r3, r2, r3
340155cc:	60fb      	str	r3, [r7, #12]
            break;
340155ce:	e012      	b.n	340155f6 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340155d0:	f7fe f9da 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340155d4:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
340155d6:	68fa      	ldr	r2, [r7, #12]
340155d8:	68bb      	ldr	r3, [r7, #8]
340155da:	fbb2 f3f3 	udiv	r3, r2, r3
340155de:	60fb      	str	r3, [r7, #12]
            break;
340155e0:	e009      	b.n	340155f6 <RCCEx_GetLTDCCLKFreq+0xde>
            ltdc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340155e2:	f7fe fa17 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340155e6:	60f8      	str	r0, [r7, #12]
            ltdc_frequency = ltdc_frequency / ic_divider;
340155e8:	68fa      	ldr	r2, [r7, #12]
340155ea:	68bb      	ldr	r3, [r7, #8]
340155ec:	fbb2 f3f3 	udiv	r3, r2, r3
340155f0:	60fb      	str	r3, [r7, #12]
            break;
340155f2:	e000      	b.n	340155f6 <RCCEx_GetLTDCCLKFreq+0xde>
            break;
340155f4:	bf00      	nop
      break;
340155f6:	e00f      	b.n	34015618 <RCCEx_GetLTDCCLKFreq+0x100>
      if (LL_RCC_HSI_IsReady() != 0U)
340155f8:	f7f9 fec2 	bl	3400f380 <LL_RCC_HSI_IsReady>
340155fc:	4603      	mov	r3, r0
340155fe:	2b00      	cmp	r3, #0
34015600:	d00c      	beq.n	3401561c <RCCEx_GetLTDCCLKFreq+0x104>
        ltdc_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34015602:	f7f9 fecf 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34015606:	4603      	mov	r3, r0
34015608:	09db      	lsrs	r3, r3, #7
3401560a:	4a07      	ldr	r2, [pc, #28]	@ (34015628 <RCCEx_GetLTDCCLKFreq+0x110>)
3401560c:	fa22 f303 	lsr.w	r3, r2, r3
34015610:	60fb      	str	r3, [r7, #12]
      break;
34015612:	e003      	b.n	3401561c <RCCEx_GetLTDCCLKFreq+0x104>
      break;
34015614:	bf00      	nop
34015616:	e002      	b.n	3401561e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
34015618:	bf00      	nop
3401561a:	e000      	b.n	3401561e <RCCEx_GetLTDCCLKFreq+0x106>
      break;
3401561c:	bf00      	nop
  }

  return ltdc_frequency;
3401561e:	68fb      	ldr	r3, [r7, #12]
}
34015620:	4618      	mov	r0, r3
34015622:	3710      	adds	r7, #16
34015624:	46bd      	mov	sp, r7
34015626:	bd80      	pop	{r7, pc}
34015628:	03d09000 	.word	0x03d09000

3401562c <RCCEx_GetMDFCLKFreq>:
  *         @arg @ref RCCEx_MDF1_Clock_Source
  * @retval MDF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetMDFCLKFreq(uint32_t MDFxSource)
{
3401562c:	b590      	push	{r4, r7, lr}
3401562e:	b085      	sub	sp, #20
34015630:	af00      	add	r7, sp, #0
34015632:	6078      	str	r0, [r7, #4]
  uint32_t adf_frequency = RCC_PERIPH_FREQUENCY_NO;
34015634:	2300      	movs	r3, #0
34015636:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetMDFClockSource(MDFxSource))
34015638:	6878      	ldr	r0, [r7, #4]
3401563a:	f7fa fa2f 	bl	3400fa9c <LL_RCC_GetMDFClockSource>
3401563e:	4603      	mov	r3, r0
34015640:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
34015644:	f000 80dd 	beq.w	34015802 <RCCEx_GetMDFCLKFreq+0x1d6>
34015648:	f5b3 2fe0 	cmp.w	r3, #458752	@ 0x70000
3401564c:	f200 80e3 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
34015650:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
34015654:	f000 80d2 	beq.w	340157fc <RCCEx_GetMDFCLKFreq+0x1d0>
34015658:	f5b3 2fc0 	cmp.w	r3, #393216	@ 0x60000
3401565c:	f200 80db 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
34015660:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
34015664:	f000 80b4 	beq.w	340157d0 <RCCEx_GetMDFCLKFreq+0x1a4>
34015668:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
3401566c:	f200 80d3 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
34015670:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34015674:	f000 80ba 	beq.w	340157ec <RCCEx_GetMDFCLKFreq+0x1c0>
34015678:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
3401567c:	f200 80cb 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
34015680:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34015684:	d061      	beq.n	3401574a <RCCEx_GetMDFCLKFreq+0x11e>
34015686:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
3401568a:	f200 80c4 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
3401568e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34015692:	d016      	beq.n	340156c2 <RCCEx_GetMDFCLKFreq+0x96>
34015694:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34015698:	f200 80bd 	bhi.w	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
3401569c:	2b00      	cmp	r3, #0
3401569e:	d003      	beq.n	340156a8 <RCCEx_GetMDFCLKFreq+0x7c>
340156a0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340156a4:	d008      	beq.n	340156b8 <RCCEx_GetMDFCLKFreq+0x8c>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
      break;

    default:
      /* Unexpected case */
      break;
340156a6:	e0b6      	b.n	34015816 <RCCEx_GetMDFCLKFreq+0x1ea>
      adf_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
340156a8:	f7f9 fa6a 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340156ac:	4603      	mov	r3, r0
340156ae:	4618      	mov	r0, r3
340156b0:	f7fe f9f6 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340156b4:	60f8      	str	r0, [r7, #12]
      break;
340156b6:	e0b7      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340156b8:	2007      	movs	r0, #7
340156ba:	f7fe fcdd 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340156be:	60f8      	str	r0, [r7, #12]
      break;
340156c0:	e0b2      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      if (LL_RCC_IC7_IsEnabled() != 0U)
340156c2:	f7fa fe01 	bl	340102c8 <LL_RCC_IC7_IsEnabled>
340156c6:	4603      	mov	r3, r0
340156c8:	2b00      	cmp	r3, #0
340156ca:	f000 80a6 	beq.w	3401581a <RCCEx_GetMDFCLKFreq+0x1ee>
        ic_divider = LL_RCC_IC7_GetDivider();
340156ce:	f7fa fe1d 	bl	3401030c <LL_RCC_IC7_GetDivider>
340156d2:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
340156d4:	f7fa fe0c 	bl	340102f0 <LL_RCC_IC7_GetSource>
340156d8:	4603      	mov	r3, r0
340156da:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340156de:	d029      	beq.n	34015734 <RCCEx_GetMDFCLKFreq+0x108>
340156e0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340156e4:	d82f      	bhi.n	34015746 <RCCEx_GetMDFCLKFreq+0x11a>
340156e6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340156ea:	d01a      	beq.n	34015722 <RCCEx_GetMDFCLKFreq+0xf6>
340156ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340156f0:	d829      	bhi.n	34015746 <RCCEx_GetMDFCLKFreq+0x11a>
340156f2:	2b00      	cmp	r3, #0
340156f4:	d003      	beq.n	340156fe <RCCEx_GetMDFCLKFreq+0xd2>
340156f6:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340156fa:	d009      	beq.n	34015710 <RCCEx_GetMDFCLKFreq+0xe4>
            break;
340156fc:	e023      	b.n	34015746 <RCCEx_GetMDFCLKFreq+0x11a>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340156fe:	f7fe f8b7 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015702:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34015704:	68fa      	ldr	r2, [r7, #12]
34015706:	68bb      	ldr	r3, [r7, #8]
34015708:	fbb2 f3f3 	udiv	r3, r2, r3
3401570c:	60fb      	str	r3, [r7, #12]
            break;
3401570e:	e01b      	b.n	34015748 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015710:	f7fe f8f4 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015714:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34015716:	68fa      	ldr	r2, [r7, #12]
34015718:	68bb      	ldr	r3, [r7, #8]
3401571a:	fbb2 f3f3 	udiv	r3, r2, r3
3401571e:	60fb      	str	r3, [r7, #12]
            break;
34015720:	e012      	b.n	34015748 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015722:	f7fe f931 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015726:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
34015728:	68fa      	ldr	r2, [r7, #12]
3401572a:	68bb      	ldr	r3, [r7, #8]
3401572c:	fbb2 f3f3 	udiv	r3, r2, r3
34015730:	60fb      	str	r3, [r7, #12]
            break;
34015732:	e009      	b.n	34015748 <RCCEx_GetMDFCLKFreq+0x11c>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015734:	f7fe f96e 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015738:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3401573a:	68fa      	ldr	r2, [r7, #12]
3401573c:	68bb      	ldr	r3, [r7, #8]
3401573e:	fbb2 f3f3 	udiv	r3, r2, r3
34015742:	60fb      	str	r3, [r7, #12]
            break;
34015744:	e000      	b.n	34015748 <RCCEx_GetMDFCLKFreq+0x11c>
            break;
34015746:	bf00      	nop
      break;
34015748:	e067      	b.n	3401581a <RCCEx_GetMDFCLKFreq+0x1ee>
      if (LL_RCC_IC8_IsEnabled() != 0U)
3401574a:	f7fa fdfd 	bl	34010348 <LL_RCC_IC8_IsEnabled>
3401574e:	4603      	mov	r3, r0
34015750:	2b00      	cmp	r3, #0
34015752:	d064      	beq.n	3401581e <RCCEx_GetMDFCLKFreq+0x1f2>
        ic_divider = LL_RCC_IC8_GetDivider();
34015754:	f7fa fe1a 	bl	3401038c <LL_RCC_IC8_GetDivider>
34015758:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
3401575a:	f7fa fe09 	bl	34010370 <LL_RCC_IC8_GetSource>
3401575e:	4603      	mov	r3, r0
34015760:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015764:	d029      	beq.n	340157ba <RCCEx_GetMDFCLKFreq+0x18e>
34015766:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401576a:	d82f      	bhi.n	340157cc <RCCEx_GetMDFCLKFreq+0x1a0>
3401576c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015770:	d01a      	beq.n	340157a8 <RCCEx_GetMDFCLKFreq+0x17c>
34015772:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015776:	d829      	bhi.n	340157cc <RCCEx_GetMDFCLKFreq+0x1a0>
34015778:	2b00      	cmp	r3, #0
3401577a:	d003      	beq.n	34015784 <RCCEx_GetMDFCLKFreq+0x158>
3401577c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015780:	d009      	beq.n	34015796 <RCCEx_GetMDFCLKFreq+0x16a>
            break;
34015782:	e023      	b.n	340157cc <RCCEx_GetMDFCLKFreq+0x1a0>
            adf_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015784:	f7fe f874 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015788:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3401578a:	68fa      	ldr	r2, [r7, #12]
3401578c:	68bb      	ldr	r3, [r7, #8]
3401578e:	fbb2 f3f3 	udiv	r3, r2, r3
34015792:	60fb      	str	r3, [r7, #12]
            break;
34015794:	e01b      	b.n	340157ce <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015796:	f7fe f8b1 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401579a:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
3401579c:	68fa      	ldr	r2, [r7, #12]
3401579e:	68bb      	ldr	r3, [r7, #8]
340157a0:	fbb2 f3f3 	udiv	r3, r2, r3
340157a4:	60fb      	str	r3, [r7, #12]
            break;
340157a6:	e012      	b.n	340157ce <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340157a8:	f7fe f8ee 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340157ac:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340157ae:	68fa      	ldr	r2, [r7, #12]
340157b0:	68bb      	ldr	r3, [r7, #8]
340157b2:	fbb2 f3f3 	udiv	r3, r2, r3
340157b6:	60fb      	str	r3, [r7, #12]
            break;
340157b8:	e009      	b.n	340157ce <RCCEx_GetMDFCLKFreq+0x1a2>
            adf_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340157ba:	f7fe f92b 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340157be:	60f8      	str	r0, [r7, #12]
            adf_frequency = adf_frequency / ic_divider;
340157c0:	68fa      	ldr	r2, [r7, #12]
340157c2:	68bb      	ldr	r3, [r7, #8]
340157c4:	fbb2 f3f3 	udiv	r3, r2, r3
340157c8:	60fb      	str	r3, [r7, #12]
            break;
340157ca:	e000      	b.n	340157ce <RCCEx_GetMDFCLKFreq+0x1a2>
            break;
340157cc:	bf00      	nop
      break;
340157ce:	e026      	b.n	3401581e <RCCEx_GetMDFCLKFreq+0x1f2>
      if (LL_RCC_HSI_IsReady() != 0U)
340157d0:	f7f9 fdd6 	bl	3400f380 <LL_RCC_HSI_IsReady>
340157d4:	4603      	mov	r3, r0
340157d6:	2b00      	cmp	r3, #0
340157d8:	d023      	beq.n	34015822 <RCCEx_GetMDFCLKFreq+0x1f6>
        adf_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340157da:	f7f9 fde3 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
340157de:	4603      	mov	r3, r0
340157e0:	09db      	lsrs	r3, r3, #7
340157e2:	4a14      	ldr	r2, [pc, #80]	@ (34015834 <RCCEx_GetMDFCLKFreq+0x208>)
340157e4:	fa22 f303 	lsr.w	r3, r2, r3
340157e8:	60fb      	str	r3, [r7, #12]
      break;
340157ea:	e01a      	b.n	34015822 <RCCEx_GetMDFCLKFreq+0x1f6>
      if (LL_RCC_MSI_IsReady() != 0U)
340157ec:	f7f9 fde8 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
340157f0:	4603      	mov	r3, r0
340157f2:	2b00      	cmp	r3, #0
340157f4:	d017      	beq.n	34015826 <RCCEx_GetMDFCLKFreq+0x1fa>
        adf_frequency = MSI_VALUE;
340157f6:	4b10      	ldr	r3, [pc, #64]	@ (34015838 <RCCEx_GetMDFCLKFreq+0x20c>)
340157f8:	60fb      	str	r3, [r7, #12]
      break;
340157fa:	e014      	b.n	34015826 <RCCEx_GetMDFCLKFreq+0x1fa>
      adf_frequency = EXTERNAL_CLOCK_VALUE;
340157fc:	4b0f      	ldr	r3, [pc, #60]	@ (3401583c <RCCEx_GetMDFCLKFreq+0x210>)
340157fe:	60fb      	str	r3, [r7, #12]
      break;
34015800:	e012      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      adf_frequency = HAL_RCC_GetSysClockFreq() / (1UL << LL_RCC_GetTIMPrescaler());
34015802:	f7f9 f9bd 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015806:	4604      	mov	r4, r0
34015808:	f7fa fa22 	bl	3400fc50 <LL_RCC_GetTIMPrescaler>
3401580c:	4603      	mov	r3, r0
3401580e:	fa24 f303 	lsr.w	r3, r4, r3
34015812:	60fb      	str	r3, [r7, #12]
      break;
34015814:	e008      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34015816:	bf00      	nop
34015818:	e006      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3401581a:	bf00      	nop
3401581c:	e004      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
3401581e:	bf00      	nop
34015820:	e002      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34015822:	bf00      	nop
34015824:	e000      	b.n	34015828 <RCCEx_GetMDFCLKFreq+0x1fc>
      break;
34015826:	bf00      	nop
  }

  return adf_frequency;
34015828:	68fb      	ldr	r3, [r7, #12]
}
3401582a:	4618      	mov	r0, r3
3401582c:	3714      	adds	r7, #20
3401582e:	46bd      	mov	sp, r7
34015830:	bd90      	pop	{r4, r7, pc}
34015832:	bf00      	nop
34015834:	03d09000 	.word	0x03d09000
34015838:	003d0900 	.word	0x003d0900
3401583c:	00bb8000 	.word	0x00bb8000

34015840 <RCCEx_GetPSSICLKFreq>:
  *         @arg @ref RCCEx_PSSI_Clock_Source
  * @retval PSSI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetPSSICLKFreq(uint32_t PSSIxSource)
{
34015840:	b580      	push	{r7, lr}
34015842:	b084      	sub	sp, #16
34015844:	af00      	add	r7, sp, #0
34015846:	6078      	str	r0, [r7, #4]
  uint32_t pssi_frequency = RCC_PERIPH_FREQUENCY_NO;
34015848:	2300      	movs	r3, #0
3401584a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetPSSIClockSource(PSSIxSource))
3401584c:	6878      	ldr	r0, [r7, #4]
3401584e:	f7fa f937 	bl	3400fac0 <LL_RCC_GetPSSIClockSource>
34015852:	4603      	mov	r3, r0
34015854:	2b30      	cmp	r3, #48	@ 0x30
34015856:	d05a      	beq.n	3401590e <RCCEx_GetPSSICLKFreq+0xce>
34015858:	2b30      	cmp	r3, #48	@ 0x30
3401585a:	d866      	bhi.n	3401592a <RCCEx_GetPSSICLKFreq+0xea>
3401585c:	2b20      	cmp	r3, #32
3401585e:	d013      	beq.n	34015888 <RCCEx_GetPSSICLKFreq+0x48>
34015860:	2b20      	cmp	r3, #32
34015862:	d862      	bhi.n	3401592a <RCCEx_GetPSSICLKFreq+0xea>
34015864:	2b00      	cmp	r3, #0
34015866:	d002      	beq.n	3401586e <RCCEx_GetPSSICLKFreq+0x2e>
34015868:	2b10      	cmp	r3, #16
3401586a:	d008      	beq.n	3401587e <RCCEx_GetPSSICLKFreq+0x3e>
      }
      break;

    default:
      /* Unexpected case */
      break;
3401586c:	e05d      	b.n	3401592a <RCCEx_GetPSSICLKFreq+0xea>
      pssi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3401586e:	f7f9 f987 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015872:	4603      	mov	r3, r0
34015874:	4618      	mov	r0, r3
34015876:	f7fe f913 	bl	34013aa0 <RCCEx_GetHCLKFreq>
3401587a:	60f8      	str	r0, [r7, #12]
      break;
3401587c:	e05a      	b.n	34015934 <RCCEx_GetPSSICLKFreq+0xf4>
      pssi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401587e:	2007      	movs	r0, #7
34015880:	f7fe fbfa 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34015884:	60f8      	str	r0, [r7, #12]
      break;
34015886:	e055      	b.n	34015934 <RCCEx_GetPSSICLKFreq+0xf4>
      if (LL_RCC_IC20_IsEnabled() != 0U)
34015888:	f7fb f81e 	bl	340108c8 <LL_RCC_IC20_IsEnabled>
3401588c:	4603      	mov	r3, r0
3401588e:	2b00      	cmp	r3, #0
34015890:	d04d      	beq.n	3401592e <RCCEx_GetPSSICLKFreq+0xee>
        ic_divider = LL_RCC_IC20_GetDivider();
34015892:	f7fb f83b 	bl	3401090c <LL_RCC_IC20_GetDivider>
34015896:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC20_GetSource())
34015898:	f7fb f82a 	bl	340108f0 <LL_RCC_IC20_GetSource>
3401589c:	4603      	mov	r3, r0
3401589e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340158a2:	d029      	beq.n	340158f8 <RCCEx_GetPSSICLKFreq+0xb8>
340158a4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
340158a8:	d82f      	bhi.n	3401590a <RCCEx_GetPSSICLKFreq+0xca>
340158aa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340158ae:	d01a      	beq.n	340158e6 <RCCEx_GetPSSICLKFreq+0xa6>
340158b0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340158b4:	d829      	bhi.n	3401590a <RCCEx_GetPSSICLKFreq+0xca>
340158b6:	2b00      	cmp	r3, #0
340158b8:	d003      	beq.n	340158c2 <RCCEx_GetPSSICLKFreq+0x82>
340158ba:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340158be:	d009      	beq.n	340158d4 <RCCEx_GetPSSICLKFreq+0x94>
            break;
340158c0:	e023      	b.n	3401590a <RCCEx_GetPSSICLKFreq+0xca>
            pssi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340158c2:	f7fd ffd5 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340158c6:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
340158c8:	68fa      	ldr	r2, [r7, #12]
340158ca:	68bb      	ldr	r3, [r7, #8]
340158cc:	fbb2 f3f3 	udiv	r3, r2, r3
340158d0:	60fb      	str	r3, [r7, #12]
            break;
340158d2:	e01b      	b.n	3401590c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340158d4:	f7fe f812 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340158d8:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
340158da:	68fa      	ldr	r2, [r7, #12]
340158dc:	68bb      	ldr	r3, [r7, #8]
340158de:	fbb2 f3f3 	udiv	r3, r2, r3
340158e2:	60fb      	str	r3, [r7, #12]
            break;
340158e4:	e012      	b.n	3401590c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340158e6:	f7fe f84f 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340158ea:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
340158ec:	68fa      	ldr	r2, [r7, #12]
340158ee:	68bb      	ldr	r3, [r7, #8]
340158f0:	fbb2 f3f3 	udiv	r3, r2, r3
340158f4:	60fb      	str	r3, [r7, #12]
            break;
340158f6:	e009      	b.n	3401590c <RCCEx_GetPSSICLKFreq+0xcc>
            pssi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340158f8:	f7fe f88c 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340158fc:	60f8      	str	r0, [r7, #12]
            pssi_frequency = pssi_frequency / ic_divider;
340158fe:	68fa      	ldr	r2, [r7, #12]
34015900:	68bb      	ldr	r3, [r7, #8]
34015902:	fbb2 f3f3 	udiv	r3, r2, r3
34015906:	60fb      	str	r3, [r7, #12]
            break;
34015908:	e000      	b.n	3401590c <RCCEx_GetPSSICLKFreq+0xcc>
            break;
3401590a:	bf00      	nop
      break;
3401590c:	e00f      	b.n	3401592e <RCCEx_GetPSSICLKFreq+0xee>
      if (LL_RCC_HSI_IsReady() != 0U)
3401590e:	f7f9 fd37 	bl	3400f380 <LL_RCC_HSI_IsReady>
34015912:	4603      	mov	r3, r0
34015914:	2b00      	cmp	r3, #0
34015916:	d00c      	beq.n	34015932 <RCCEx_GetPSSICLKFreq+0xf2>
        pssi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34015918:	f7f9 fd44 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
3401591c:	4603      	mov	r3, r0
3401591e:	09db      	lsrs	r3, r3, #7
34015920:	4a07      	ldr	r2, [pc, #28]	@ (34015940 <RCCEx_GetPSSICLKFreq+0x100>)
34015922:	fa22 f303 	lsr.w	r3, r2, r3
34015926:	60fb      	str	r3, [r7, #12]
      break;
34015928:	e003      	b.n	34015932 <RCCEx_GetPSSICLKFreq+0xf2>
      break;
3401592a:	bf00      	nop
3401592c:	e002      	b.n	34015934 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
3401592e:	bf00      	nop
34015930:	e000      	b.n	34015934 <RCCEx_GetPSSICLKFreq+0xf4>
      break;
34015932:	bf00      	nop
  }

  return pssi_frequency;
34015934:	68fb      	ldr	r3, [r7, #12]
}
34015936:	4618      	mov	r0, r3
34015938:	3710      	adds	r7, #16
3401593a:	46bd      	mov	sp, r7
3401593c:	bd80      	pop	{r7, pc}
3401593e:	bf00      	nop
34015940:	03d09000 	.word	0x03d09000

34015944 <RCCEx_GetRTCCLKFreq>:
  * @brief  Return RTC clock frequency
  * @retval RTC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetRTCCLKFreq()
{
34015944:	b580      	push	{r7, lr}
34015946:	b082      	sub	sp, #8
34015948:	af00      	add	r7, sp, #0
  uint32_t rtc_frequency = RCC_PERIPH_FREQUENCY_NO;
3401594a:	2300      	movs	r3, #0
3401594c:	607b      	str	r3, [r7, #4]

  switch (LL_RCC_GetRTCClockSource())
3401594e:	f7fa f945 	bl	3400fbdc <LL_RCC_GetRTCClockSource>
34015952:	4603      	mov	r3, r0
34015954:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34015958:	d020      	beq.n	3401599c <RCCEx_GetRTCCLKFreq+0x58>
3401595a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
3401595e:	d830      	bhi.n	340159c2 <RCCEx_GetRTCCLKFreq+0x7e>
34015960:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34015964:	d011      	beq.n	3401598a <RCCEx_GetRTCCLKFreq+0x46>
34015966:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
3401596a:	d82a      	bhi.n	340159c2 <RCCEx_GetRTCCLKFreq+0x7e>
3401596c:	2b00      	cmp	r3, #0
3401596e:	d02a      	beq.n	340159c6 <RCCEx_GetRTCCLKFreq+0x82>
34015970:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34015974:	d000      	beq.n	34015978 <RCCEx_GetRTCCLKFreq+0x34>
      }
      break;

    default:
      /* Unexpected case */
      break;
34015976:	e024      	b.n	340159c2 <RCCEx_GetRTCCLKFreq+0x7e>
      if (LL_RCC_LSE_IsReady() != 0U)
34015978:	f7f9 fd42 	bl	3400f400 <LL_RCC_LSE_IsReady>
3401597c:	4603      	mov	r3, r0
3401597e:	2b00      	cmp	r3, #0
34015980:	d023      	beq.n	340159ca <RCCEx_GetRTCCLKFreq+0x86>
        rtc_frequency = LSE_VALUE;
34015982:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34015986:	607b      	str	r3, [r7, #4]
      break;
34015988:	e01f      	b.n	340159ca <RCCEx_GetRTCCLKFreq+0x86>
      if (LL_RCC_LSI_IsReady() != 0U)
3401598a:	f7f9 fd4b 	bl	3400f424 <LL_RCC_LSI_IsReady>
3401598e:	4603      	mov	r3, r0
34015990:	2b00      	cmp	r3, #0
34015992:	d01c      	beq.n	340159ce <RCCEx_GetRTCCLKFreq+0x8a>
        rtc_frequency = LSI_VALUE;
34015994:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
34015998:	607b      	str	r3, [r7, #4]
      break;
3401599a:	e018      	b.n	340159ce <RCCEx_GetRTCCLKFreq+0x8a>
      if (LL_RCC_HSE_IsReady() != 0U)
3401599c:	f7f9 fcde 	bl	3400f35c <LL_RCC_HSE_IsReady>
340159a0:	4603      	mov	r3, r0
340159a2:	2b00      	cmp	r3, #0
340159a4:	d015      	beq.n	340159d2 <RCCEx_GetRTCCLKFreq+0x8e>
        uint32_t prescaler = (READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCPRE) >> RCC_CCIPR7_RTCPRE_Pos) + 1U;
340159a6:	4b0e      	ldr	r3, [pc, #56]	@ (340159e0 <RCCEx_GetRTCCLKFreq+0x9c>)
340159a8:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
340159ac:	0b1b      	lsrs	r3, r3, #12
340159ae:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340159b2:	3301      	adds	r3, #1
340159b4:	603b      	str	r3, [r7, #0]
        rtc_frequency = HSE_VALUE / prescaler;
340159b6:	4a0b      	ldr	r2, [pc, #44]	@ (340159e4 <RCCEx_GetRTCCLKFreq+0xa0>)
340159b8:	683b      	ldr	r3, [r7, #0]
340159ba:	fbb2 f3f3 	udiv	r3, r2, r3
340159be:	607b      	str	r3, [r7, #4]
      break;
340159c0:	e007      	b.n	340159d2 <RCCEx_GetRTCCLKFreq+0x8e>
      break;
340159c2:	bf00      	nop
340159c4:	e006      	b.n	340159d4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
340159c6:	bf00      	nop
340159c8:	e004      	b.n	340159d4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
340159ca:	bf00      	nop
340159cc:	e002      	b.n	340159d4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
340159ce:	bf00      	nop
340159d0:	e000      	b.n	340159d4 <RCCEx_GetRTCCLKFreq+0x90>
      break;
340159d2:	bf00      	nop
  }

  return rtc_frequency;
340159d4:	687b      	ldr	r3, [r7, #4]
}
340159d6:	4618      	mov	r0, r3
340159d8:	3708      	adds	r7, #8
340159da:	46bd      	mov	sp, r7
340159dc:	bd80      	pop	{r7, pc}
340159de:	bf00      	nop
340159e0:	56028000 	.word	0x56028000
340159e4:	02dc6c00 	.word	0x02dc6c00

340159e8 <RCCEx_GetSAICLKFreq>:
  *         @arg @ref RCCEx_SAI2_Clock_Source
  * @retval SAI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSAICLKFreq(uint32_t SAIxSource)
{
340159e8:	b580      	push	{r7, lr}
340159ea:	b084      	sub	sp, #16
340159ec:	af00      	add	r7, sp, #0
340159ee:	6078      	str	r0, [r7, #4]
  uint32_t sai_frequency = RCC_PERIPH_FREQUENCY_NO;
340159f0:	2300      	movs	r3, #0
340159f2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSAIClockSource(SAIxSource))
340159f4:	6878      	ldr	r0, [r7, #4]
340159f6:	f7fa f875 	bl	3400fae4 <LL_RCC_GetSAIClockSource>
340159fa:	4603      	mov	r3, r0
340159fc:	4a9a      	ldr	r2, [pc, #616]	@ (34015c68 <RCCEx_GetSAICLKFreq+0x280>)
340159fe:	4293      	cmp	r3, r2
34015a00:	f000 811f 	beq.w	34015c42 <RCCEx_GetSAICLKFreq+0x25a>
34015a04:	4a98      	ldr	r2, [pc, #608]	@ (34015c68 <RCCEx_GetSAICLKFreq+0x280>)
34015a06:	4293      	cmp	r3, r2
34015a08:	f200 8120 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a0c:	4a97      	ldr	r2, [pc, #604]	@ (34015c6c <RCCEx_GetSAICLKFreq+0x284>)
34015a0e:	4293      	cmp	r3, r2
34015a10:	f000 8117 	beq.w	34015c42 <RCCEx_GetSAICLKFreq+0x25a>
34015a14:	4a95      	ldr	r2, [pc, #596]	@ (34015c6c <RCCEx_GetSAICLKFreq+0x284>)
34015a16:	4293      	cmp	r3, r2
34015a18:	f200 8118 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a1c:	4a94      	ldr	r2, [pc, #592]	@ (34015c70 <RCCEx_GetSAICLKFreq+0x288>)
34015a1e:	4293      	cmp	r3, r2
34015a20:	f000 810c 	beq.w	34015c3c <RCCEx_GetSAICLKFreq+0x254>
34015a24:	4a92      	ldr	r2, [pc, #584]	@ (34015c70 <RCCEx_GetSAICLKFreq+0x288>)
34015a26:	4293      	cmp	r3, r2
34015a28:	f200 8110 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a2c:	4a91      	ldr	r2, [pc, #580]	@ (34015c74 <RCCEx_GetSAICLKFreq+0x28c>)
34015a2e:	4293      	cmp	r3, r2
34015a30:	f000 8104 	beq.w	34015c3c <RCCEx_GetSAICLKFreq+0x254>
34015a34:	4a8f      	ldr	r2, [pc, #572]	@ (34015c74 <RCCEx_GetSAICLKFreq+0x28c>)
34015a36:	4293      	cmp	r3, r2
34015a38:	f200 8108 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a3c:	4a8e      	ldr	r2, [pc, #568]	@ (34015c78 <RCCEx_GetSAICLKFreq+0x290>)
34015a3e:	4293      	cmp	r3, r2
34015a40:	f000 80e6 	beq.w	34015c10 <RCCEx_GetSAICLKFreq+0x228>
34015a44:	4a8c      	ldr	r2, [pc, #560]	@ (34015c78 <RCCEx_GetSAICLKFreq+0x290>)
34015a46:	4293      	cmp	r3, r2
34015a48:	f200 8100 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a4c:	4a8b      	ldr	r2, [pc, #556]	@ (34015c7c <RCCEx_GetSAICLKFreq+0x294>)
34015a4e:	4293      	cmp	r3, r2
34015a50:	f000 80de 	beq.w	34015c10 <RCCEx_GetSAICLKFreq+0x228>
34015a54:	4a89      	ldr	r2, [pc, #548]	@ (34015c7c <RCCEx_GetSAICLKFreq+0x294>)
34015a56:	4293      	cmp	r3, r2
34015a58:	f200 80f8 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a5c:	4a88      	ldr	r2, [pc, #544]	@ (34015c80 <RCCEx_GetSAICLKFreq+0x298>)
34015a5e:	4293      	cmp	r3, r2
34015a60:	f000 80e4 	beq.w	34015c2c <RCCEx_GetSAICLKFreq+0x244>
34015a64:	4a86      	ldr	r2, [pc, #536]	@ (34015c80 <RCCEx_GetSAICLKFreq+0x298>)
34015a66:	4293      	cmp	r3, r2
34015a68:	f200 80f0 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a6c:	4a85      	ldr	r2, [pc, #532]	@ (34015c84 <RCCEx_GetSAICLKFreq+0x29c>)
34015a6e:	4293      	cmp	r3, r2
34015a70:	f000 80dc 	beq.w	34015c2c <RCCEx_GetSAICLKFreq+0x244>
34015a74:	4a83      	ldr	r2, [pc, #524]	@ (34015c84 <RCCEx_GetSAICLKFreq+0x29c>)
34015a76:	4293      	cmp	r3, r2
34015a78:	f200 80e8 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a7c:	4a82      	ldr	r2, [pc, #520]	@ (34015c88 <RCCEx_GetSAICLKFreq+0x2a0>)
34015a7e:	4293      	cmp	r3, r2
34015a80:	f000 8083 	beq.w	34015b8a <RCCEx_GetSAICLKFreq+0x1a2>
34015a84:	4a80      	ldr	r2, [pc, #512]	@ (34015c88 <RCCEx_GetSAICLKFreq+0x2a0>)
34015a86:	4293      	cmp	r3, r2
34015a88:	f200 80e0 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a8c:	4a7f      	ldr	r2, [pc, #508]	@ (34015c8c <RCCEx_GetSAICLKFreq+0x2a4>)
34015a8e:	4293      	cmp	r3, r2
34015a90:	d07b      	beq.n	34015b8a <RCCEx_GetSAICLKFreq+0x1a2>
34015a92:	4a7e      	ldr	r2, [pc, #504]	@ (34015c8c <RCCEx_GetSAICLKFreq+0x2a4>)
34015a94:	4293      	cmp	r3, r2
34015a96:	f200 80d9 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015a9a:	4a7d      	ldr	r2, [pc, #500]	@ (34015c90 <RCCEx_GetSAICLKFreq+0x2a8>)
34015a9c:	4293      	cmp	r3, r2
34015a9e:	d030      	beq.n	34015b02 <RCCEx_GetSAICLKFreq+0x11a>
34015aa0:	4a7b      	ldr	r2, [pc, #492]	@ (34015c90 <RCCEx_GetSAICLKFreq+0x2a8>)
34015aa2:	4293      	cmp	r3, r2
34015aa4:	f200 80d2 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015aa8:	4a7a      	ldr	r2, [pc, #488]	@ (34015c94 <RCCEx_GetSAICLKFreq+0x2ac>)
34015aaa:	4293      	cmp	r3, r2
34015aac:	d029      	beq.n	34015b02 <RCCEx_GetSAICLKFreq+0x11a>
34015aae:	4a79      	ldr	r2, [pc, #484]	@ (34015c94 <RCCEx_GetSAICLKFreq+0x2ac>)
34015ab0:	4293      	cmp	r3, r2
34015ab2:	f200 80cb 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015ab6:	4a78      	ldr	r2, [pc, #480]	@ (34015c98 <RCCEx_GetSAICLKFreq+0x2b0>)
34015ab8:	4293      	cmp	r3, r2
34015aba:	d01d      	beq.n	34015af8 <RCCEx_GetSAICLKFreq+0x110>
34015abc:	4a76      	ldr	r2, [pc, #472]	@ (34015c98 <RCCEx_GetSAICLKFreq+0x2b0>)
34015abe:	4293      	cmp	r3, r2
34015ac0:	f200 80c4 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015ac4:	4a75      	ldr	r2, [pc, #468]	@ (34015c9c <RCCEx_GetSAICLKFreq+0x2b4>)
34015ac6:	4293      	cmp	r3, r2
34015ac8:	d016      	beq.n	34015af8 <RCCEx_GetSAICLKFreq+0x110>
34015aca:	4a74      	ldr	r2, [pc, #464]	@ (34015c9c <RCCEx_GetSAICLKFreq+0x2b4>)
34015acc:	4293      	cmp	r3, r2
34015ace:	f200 80bd 	bhi.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
34015ad2:	4a73      	ldr	r2, [pc, #460]	@ (34015ca0 <RCCEx_GetSAICLKFreq+0x2b8>)
34015ad4:	4293      	cmp	r3, r2
34015ad6:	d003      	beq.n	34015ae0 <RCCEx_GetSAICLKFreq+0xf8>
34015ad8:	4a72      	ldr	r2, [pc, #456]	@ (34015ca4 <RCCEx_GetSAICLKFreq+0x2bc>)
34015ada:	4293      	cmp	r3, r2
34015adc:	f040 80b6 	bne.w	34015c4c <RCCEx_GetSAICLKFreq+0x264>
  {
    case LL_RCC_SAI1_CLKSOURCE_PCLK2:
    case LL_RCC_SAI2_CLKSOURCE_PCLK2:
      sai_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34015ae0:	f7f9 f84e 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015ae4:	4603      	mov	r3, r0
34015ae6:	4618      	mov	r0, r3
34015ae8:	f7fd ffda 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34015aec:	4603      	mov	r3, r0
34015aee:	4618      	mov	r0, r3
34015af0:	f7fd fff7 	bl	34013ae2 <RCCEx_GetPCLK2Freq>
34015af4:	60f8      	str	r0, [r7, #12]
      break;
34015af6:	e0b2      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_CLKP:
    case LL_RCC_SAI2_CLKSOURCE_CLKP:
      sai_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015af8:	2007      	movs	r0, #7
34015afa:	f7fe fabd 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34015afe:	60f8      	str	r0, [r7, #12]
      break;
34015b00:	e0ad      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_IC7:
    case LL_RCC_SAI2_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34015b02:	f7fa fbe1 	bl	340102c8 <LL_RCC_IC7_IsEnabled>
34015b06:	4603      	mov	r3, r0
34015b08:	2b00      	cmp	r3, #0
34015b0a:	f000 80a1 	beq.w	34015c50 <RCCEx_GetSAICLKFreq+0x268>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34015b0e:	f7fa fbfd 	bl	3401030c <LL_RCC_IC7_GetDivider>
34015b12:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34015b14:	f7fa fbec 	bl	340102f0 <LL_RCC_IC7_GetSource>
34015b18:	4603      	mov	r3, r0
34015b1a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015b1e:	d029      	beq.n	34015b74 <RCCEx_GetSAICLKFreq+0x18c>
34015b20:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015b24:	d82f      	bhi.n	34015b86 <RCCEx_GetSAICLKFreq+0x19e>
34015b26:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015b2a:	d01a      	beq.n	34015b62 <RCCEx_GetSAICLKFreq+0x17a>
34015b2c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015b30:	d829      	bhi.n	34015b86 <RCCEx_GetSAICLKFreq+0x19e>
34015b32:	2b00      	cmp	r3, #0
34015b34:	d003      	beq.n	34015b3e <RCCEx_GetSAICLKFreq+0x156>
34015b36:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015b3a:	d009      	beq.n	34015b50 <RCCEx_GetSAICLKFreq+0x168>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015b3c:	e023      	b.n	34015b86 <RCCEx_GetSAICLKFreq+0x19e>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015b3e:	f7fd fe97 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015b42:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015b44:	68fa      	ldr	r2, [r7, #12]
34015b46:	68bb      	ldr	r3, [r7, #8]
34015b48:	fbb2 f3f3 	udiv	r3, r2, r3
34015b4c:	60fb      	str	r3, [r7, #12]
            break;
34015b4e:	e01b      	b.n	34015b88 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015b50:	f7fd fed4 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015b54:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015b56:	68fa      	ldr	r2, [r7, #12]
34015b58:	68bb      	ldr	r3, [r7, #8]
34015b5a:	fbb2 f3f3 	udiv	r3, r2, r3
34015b5e:	60fb      	str	r3, [r7, #12]
            break;
34015b60:	e012      	b.n	34015b88 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015b62:	f7fd ff11 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015b66:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015b68:	68fa      	ldr	r2, [r7, #12]
34015b6a:	68bb      	ldr	r3, [r7, #8]
34015b6c:	fbb2 f3f3 	udiv	r3, r2, r3
34015b70:	60fb      	str	r3, [r7, #12]
            break;
34015b72:	e009      	b.n	34015b88 <RCCEx_GetSAICLKFreq+0x1a0>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015b74:	f7fd ff4e 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015b78:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015b7a:	68fa      	ldr	r2, [r7, #12]
34015b7c:	68bb      	ldr	r3, [r7, #8]
34015b7e:	fbb2 f3f3 	udiv	r3, r2, r3
34015b82:	60fb      	str	r3, [r7, #12]
            break;
34015b84:	e000      	b.n	34015b88 <RCCEx_GetSAICLKFreq+0x1a0>
            break;
34015b86:	bf00      	nop
        }
      }
      break;
34015b88:	e062      	b.n	34015c50 <RCCEx_GetSAICLKFreq+0x268>

    case LL_RCC_SAI1_CLKSOURCE_IC8:
    case LL_RCC_SAI2_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34015b8a:	f7fa fbdd 	bl	34010348 <LL_RCC_IC8_IsEnabled>
34015b8e:	4603      	mov	r3, r0
34015b90:	2b00      	cmp	r3, #0
34015b92:	d05f      	beq.n	34015c54 <RCCEx_GetSAICLKFreq+0x26c>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34015b94:	f7fa fbfa 	bl	3401038c <LL_RCC_IC8_GetDivider>
34015b98:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34015b9a:	f7fa fbe9 	bl	34010370 <LL_RCC_IC8_GetSource>
34015b9e:	4603      	mov	r3, r0
34015ba0:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015ba4:	d029      	beq.n	34015bfa <RCCEx_GetSAICLKFreq+0x212>
34015ba6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015baa:	d82f      	bhi.n	34015c0c <RCCEx_GetSAICLKFreq+0x224>
34015bac:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015bb0:	d01a      	beq.n	34015be8 <RCCEx_GetSAICLKFreq+0x200>
34015bb2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015bb6:	d829      	bhi.n	34015c0c <RCCEx_GetSAICLKFreq+0x224>
34015bb8:	2b00      	cmp	r3, #0
34015bba:	d003      	beq.n	34015bc4 <RCCEx_GetSAICLKFreq+0x1dc>
34015bbc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015bc0:	d009      	beq.n	34015bd6 <RCCEx_GetSAICLKFreq+0x1ee>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sai_frequency = sai_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015bc2:	e023      	b.n	34015c0c <RCCEx_GetSAICLKFreq+0x224>
            sai_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015bc4:	f7fd fe54 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015bc8:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015bca:	68fa      	ldr	r2, [r7, #12]
34015bcc:	68bb      	ldr	r3, [r7, #8]
34015bce:	fbb2 f3f3 	udiv	r3, r2, r3
34015bd2:	60fb      	str	r3, [r7, #12]
            break;
34015bd4:	e01b      	b.n	34015c0e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015bd6:	f7fd fe91 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015bda:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015bdc:	68fa      	ldr	r2, [r7, #12]
34015bde:	68bb      	ldr	r3, [r7, #8]
34015be0:	fbb2 f3f3 	udiv	r3, r2, r3
34015be4:	60fb      	str	r3, [r7, #12]
            break;
34015be6:	e012      	b.n	34015c0e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015be8:	f7fd fece 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015bec:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015bee:	68fa      	ldr	r2, [r7, #12]
34015bf0:	68bb      	ldr	r3, [r7, #8]
34015bf2:	fbb2 f3f3 	udiv	r3, r2, r3
34015bf6:	60fb      	str	r3, [r7, #12]
            break;
34015bf8:	e009      	b.n	34015c0e <RCCEx_GetSAICLKFreq+0x226>
            sai_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015bfa:	f7fd ff0b 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015bfe:	60f8      	str	r0, [r7, #12]
            sai_frequency = sai_frequency / ic_divider;
34015c00:	68fa      	ldr	r2, [r7, #12]
34015c02:	68bb      	ldr	r3, [r7, #8]
34015c04:	fbb2 f3f3 	udiv	r3, r2, r3
34015c08:	60fb      	str	r3, [r7, #12]
            break;
34015c0a:	e000      	b.n	34015c0e <RCCEx_GetSAICLKFreq+0x226>
            break;
34015c0c:	bf00      	nop
        }
      }
      break;
34015c0e:	e021      	b.n	34015c54 <RCCEx_GetSAICLKFreq+0x26c>

    case LL_RCC_SAI1_CLKSOURCE_HSI:
    case LL_RCC_SAI2_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34015c10:	f7f9 fbb6 	bl	3400f380 <LL_RCC_HSI_IsReady>
34015c14:	4603      	mov	r3, r0
34015c16:	2b00      	cmp	r3, #0
34015c18:	d01e      	beq.n	34015c58 <RCCEx_GetSAICLKFreq+0x270>
      {
        sai_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34015c1a:	f7f9 fbc3 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34015c1e:	4603      	mov	r3, r0
34015c20:	09db      	lsrs	r3, r3, #7
34015c22:	4a21      	ldr	r2, [pc, #132]	@ (34015ca8 <RCCEx_GetSAICLKFreq+0x2c0>)
34015c24:	fa22 f303 	lsr.w	r3, r2, r3
34015c28:	60fb      	str	r3, [r7, #12]
      }
      break;
34015c2a:	e015      	b.n	34015c58 <RCCEx_GetSAICLKFreq+0x270>

    case LL_RCC_SAI1_CLKSOURCE_MSI:
    case LL_RCC_SAI2_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34015c2c:	f7f9 fbc8 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34015c30:	4603      	mov	r3, r0
34015c32:	2b00      	cmp	r3, #0
34015c34:	d012      	beq.n	34015c5c <RCCEx_GetSAICLKFreq+0x274>
      {
        sai_frequency = MSI_VALUE;
34015c36:	4b1d      	ldr	r3, [pc, #116]	@ (34015cac <RCCEx_GetSAICLKFreq+0x2c4>)
34015c38:	60fb      	str	r3, [r7, #12]
      }
      break;
34015c3a:	e00f      	b.n	34015c5c <RCCEx_GetSAICLKFreq+0x274>

    case LL_RCC_SAI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SAI2_CLKSOURCE_I2S_CKIN:
      sai_frequency = EXTERNAL_CLOCK_VALUE;
34015c3c:	4b1c      	ldr	r3, [pc, #112]	@ (34015cb0 <RCCEx_GetSAICLKFreq+0x2c8>)
34015c3e:	60fb      	str	r3, [r7, #12]
      break;
34015c40:	e00d      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>

    case LL_RCC_SAI1_CLKSOURCE_SPDIFRX1:
    case LL_RCC_SAI2_CLKSOURCE_SPDIFRX1:
      sai_frequency = RCCEx_GetSPDIFRXCLKFreq(LL_RCC_SPDIFRX1_CLKSOURCE);
34015c42:	2007      	movs	r0, #7
34015c44:	f000 f920 	bl	34015e88 <RCCEx_GetSPDIFRXCLKFreq>
34015c48:	60f8      	str	r0, [r7, #12]
      break;
34015c4a:	e008      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>

    default:
      /* Unexpected case */
      break;
34015c4c:	bf00      	nop
34015c4e:	e006      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>
      break;
34015c50:	bf00      	nop
34015c52:	e004      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>
      break;
34015c54:	bf00      	nop
34015c56:	e002      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>
      break;
34015c58:	bf00      	nop
34015c5a:	e000      	b.n	34015c5e <RCCEx_GetSAICLKFreq+0x276>
      break;
34015c5c:	bf00      	nop
  }

  return sai_frequency;
34015c5e:	68fb      	ldr	r3, [r7, #12]
}
34015c60:	4618      	mov	r0, r3
34015c62:	3710      	adds	r7, #16
34015c64:	46bd      	mov	sp, r7
34015c66:	bd80      	pop	{r7, pc}
34015c68:	07071818 	.word	0x07071818
34015c6c:	07071418 	.word	0x07071418
34015c70:	07061818 	.word	0x07061818
34015c74:	07061418 	.word	0x07061418
34015c78:	07051818 	.word	0x07051818
34015c7c:	07051418 	.word	0x07051418
34015c80:	07041818 	.word	0x07041818
34015c84:	07041418 	.word	0x07041418
34015c88:	07031818 	.word	0x07031818
34015c8c:	07031418 	.word	0x07031418
34015c90:	07021818 	.word	0x07021818
34015c94:	07021418 	.word	0x07021418
34015c98:	07011818 	.word	0x07011818
34015c9c:	07011418 	.word	0x07011418
34015ca0:	07001418 	.word	0x07001418
34015ca4:	07001818 	.word	0x07001818
34015ca8:	03d09000 	.word	0x03d09000
34015cac:	003d0900 	.word	0x003d0900
34015cb0:	00bb8000 	.word	0x00bb8000

34015cb4 <RCCEx_GetSDMMCCLKFreq>:
  *         @arg @ref RCCEx_SDMMC2_Clock_Source
  * @retval SDMMC clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSDMMCCLKFreq(uint32_t SDMMCxSource)
{
34015cb4:	b580      	push	{r7, lr}
34015cb6:	b084      	sub	sp, #16
34015cb8:	af00      	add	r7, sp, #0
34015cba:	6078      	str	r0, [r7, #4]
  uint32_t sdmmc_frequency = RCC_PERIPH_FREQUENCY_NO;
34015cbc:	2300      	movs	r3, #0
34015cbe:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSDMMCClockSource(SDMMCxSource))
34015cc0:	6878      	ldr	r0, [r7, #4]
34015cc2:	f7f9 ff1b 	bl	3400fafc <LL_RCC_GetSDMMCClockSource>
34015cc6:	4603      	mov	r3, r0
34015cc8:	4a67      	ldr	r2, [pc, #412]	@ (34015e68 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34015cca:	4293      	cmp	r3, r2
34015ccc:	d07e      	beq.n	34015dcc <RCCEx_GetSDMMCCLKFreq+0x118>
34015cce:	4a66      	ldr	r2, [pc, #408]	@ (34015e68 <RCCEx_GetSDMMCCLKFreq+0x1b4>)
34015cd0:	4293      	cmp	r3, r2
34015cd2:	f200 80be 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015cd6:	4a65      	ldr	r2, [pc, #404]	@ (34015e6c <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34015cd8:	4293      	cmp	r3, r2
34015cda:	d077      	beq.n	34015dcc <RCCEx_GetSDMMCCLKFreq+0x118>
34015cdc:	4a63      	ldr	r2, [pc, #396]	@ (34015e6c <RCCEx_GetSDMMCCLKFreq+0x1b8>)
34015cde:	4293      	cmp	r3, r2
34015ce0:	f200 80b7 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015ce4:	4a62      	ldr	r2, [pc, #392]	@ (34015e70 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34015ce6:	4293      	cmp	r3, r2
34015ce8:	d02c      	beq.n	34015d44 <RCCEx_GetSDMMCCLKFreq+0x90>
34015cea:	4a61      	ldr	r2, [pc, #388]	@ (34015e70 <RCCEx_GetSDMMCCLKFreq+0x1bc>)
34015cec:	4293      	cmp	r3, r2
34015cee:	f200 80b0 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015cf2:	4a60      	ldr	r2, [pc, #384]	@ (34015e74 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34015cf4:	4293      	cmp	r3, r2
34015cf6:	d025      	beq.n	34015d44 <RCCEx_GetSDMMCCLKFreq+0x90>
34015cf8:	4a5e      	ldr	r2, [pc, #376]	@ (34015e74 <RCCEx_GetSDMMCCLKFreq+0x1c0>)
34015cfa:	4293      	cmp	r3, r2
34015cfc:	f200 80a9 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015d00:	4a5d      	ldr	r2, [pc, #372]	@ (34015e78 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34015d02:	4293      	cmp	r3, r2
34015d04:	d019      	beq.n	34015d3a <RCCEx_GetSDMMCCLKFreq+0x86>
34015d06:	4a5c      	ldr	r2, [pc, #368]	@ (34015e78 <RCCEx_GetSDMMCCLKFreq+0x1c4>)
34015d08:	4293      	cmp	r3, r2
34015d0a:	f200 80a2 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015d0e:	4a5b      	ldr	r2, [pc, #364]	@ (34015e7c <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34015d10:	4293      	cmp	r3, r2
34015d12:	d012      	beq.n	34015d3a <RCCEx_GetSDMMCCLKFreq+0x86>
34015d14:	4a59      	ldr	r2, [pc, #356]	@ (34015e7c <RCCEx_GetSDMMCCLKFreq+0x1c8>)
34015d16:	4293      	cmp	r3, r2
34015d18:	f200 809b 	bhi.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
34015d1c:	4a58      	ldr	r2, [pc, #352]	@ (34015e80 <RCCEx_GetSDMMCCLKFreq+0x1cc>)
34015d1e:	4293      	cmp	r3, r2
34015d20:	d003      	beq.n	34015d2a <RCCEx_GetSDMMCCLKFreq+0x76>
34015d22:	4a58      	ldr	r2, [pc, #352]	@ (34015e84 <RCCEx_GetSDMMCCLKFreq+0x1d0>)
34015d24:	4293      	cmp	r3, r2
34015d26:	f040 8094 	bne.w	34015e52 <RCCEx_GetSDMMCCLKFreq+0x19e>
  {
    case LL_RCC_SDMMC1_CLKSOURCE_HCLK:
    case LL_RCC_SDMMC2_CLKSOURCE_HCLK:
      sdmmc_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
34015d2a:	f7f8 ff29 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015d2e:	4603      	mov	r3, r0
34015d30:	4618      	mov	r0, r3
34015d32:	f7fd feb5 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34015d36:	60f8      	str	r0, [r7, #12]
      break;
34015d38:	e090      	b.n	34015e5c <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_CLKP:
    case LL_RCC_SDMMC2_CLKSOURCE_CLKP:
      sdmmc_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015d3a:	2007      	movs	r0, #7
34015d3c:	f7fe f99c 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34015d40:	60f8      	str	r0, [r7, #12]
      break;
34015d42:	e08b      	b.n	34015e5c <RCCEx_GetSDMMCCLKFreq+0x1a8>

    case LL_RCC_SDMMC1_CLKSOURCE_IC4:
    case LL_RCC_SDMMC2_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
34015d44:	f7fa fa40 	bl	340101c8 <LL_RCC_IC4_IsEnabled>
34015d48:	4603      	mov	r3, r0
34015d4a:	2b00      	cmp	r3, #0
34015d4c:	f000 8083 	beq.w	34015e56 <RCCEx_GetSDMMCCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34015d50:	f7fa fa5c 	bl	3401020c <LL_RCC_IC4_GetDivider>
34015d54:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
34015d56:	f7fa fa4b 	bl	340101f0 <LL_RCC_IC4_GetSource>
34015d5a:	4603      	mov	r3, r0
34015d5c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015d60:	d029      	beq.n	34015db6 <RCCEx_GetSDMMCCLKFreq+0x102>
34015d62:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015d66:	d82f      	bhi.n	34015dc8 <RCCEx_GetSDMMCCLKFreq+0x114>
34015d68:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015d6c:	d01a      	beq.n	34015da4 <RCCEx_GetSDMMCCLKFreq+0xf0>
34015d6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015d72:	d829      	bhi.n	34015dc8 <RCCEx_GetSDMMCCLKFreq+0x114>
34015d74:	2b00      	cmp	r3, #0
34015d76:	d003      	beq.n	34015d80 <RCCEx_GetSDMMCCLKFreq+0xcc>
34015d78:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015d7c:	d009      	beq.n	34015d92 <RCCEx_GetSDMMCCLKFreq+0xde>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015d7e:	e023      	b.n	34015dc8 <RCCEx_GetSDMMCCLKFreq+0x114>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015d80:	f7fd fd76 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015d84:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015d86:	68fa      	ldr	r2, [r7, #12]
34015d88:	68bb      	ldr	r3, [r7, #8]
34015d8a:	fbb2 f3f3 	udiv	r3, r2, r3
34015d8e:	60fb      	str	r3, [r7, #12]
            break;
34015d90:	e01b      	b.n	34015dca <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015d92:	f7fd fdb3 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015d96:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015d98:	68fa      	ldr	r2, [r7, #12]
34015d9a:	68bb      	ldr	r3, [r7, #8]
34015d9c:	fbb2 f3f3 	udiv	r3, r2, r3
34015da0:	60fb      	str	r3, [r7, #12]
            break;
34015da2:	e012      	b.n	34015dca <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015da4:	f7fd fdf0 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015da8:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015daa:	68fa      	ldr	r2, [r7, #12]
34015dac:	68bb      	ldr	r3, [r7, #8]
34015dae:	fbb2 f3f3 	udiv	r3, r2, r3
34015db2:	60fb      	str	r3, [r7, #12]
            break;
34015db4:	e009      	b.n	34015dca <RCCEx_GetSDMMCCLKFreq+0x116>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015db6:	f7fd fe2d 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015dba:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015dbc:	68fa      	ldr	r2, [r7, #12]
34015dbe:	68bb      	ldr	r3, [r7, #8]
34015dc0:	fbb2 f3f3 	udiv	r3, r2, r3
34015dc4:	60fb      	str	r3, [r7, #12]
            break;
34015dc6:	e000      	b.n	34015dca <RCCEx_GetSDMMCCLKFreq+0x116>
            break;
34015dc8:	bf00      	nop
        }
      }
      break;
34015dca:	e044      	b.n	34015e56 <RCCEx_GetSDMMCCLKFreq+0x1a2>

    case LL_RCC_SDMMC1_CLKSOURCE_IC5:
    case LL_RCC_SDMMC2_CLKSOURCE_IC5:
      if (LL_RCC_IC5_IsEnabled() != 0U)
34015dcc:	f7fa fa3c 	bl	34010248 <LL_RCC_IC5_IsEnabled>
34015dd0:	4603      	mov	r3, r0
34015dd2:	2b00      	cmp	r3, #0
34015dd4:	d041      	beq.n	34015e5a <RCCEx_GetSDMMCCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC5_GetDivider();
34015dd6:	f7fa fa59 	bl	3401028c <LL_RCC_IC5_GetDivider>
34015dda:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC5_GetSource())
34015ddc:	f7fa fa48 	bl	34010270 <LL_RCC_IC5_GetSource>
34015de0:	4603      	mov	r3, r0
34015de2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015de6:	d029      	beq.n	34015e3c <RCCEx_GetSDMMCCLKFreq+0x188>
34015de8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015dec:	d82f      	bhi.n	34015e4e <RCCEx_GetSDMMCCLKFreq+0x19a>
34015dee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015df2:	d01a      	beq.n	34015e2a <RCCEx_GetSDMMCCLKFreq+0x176>
34015df4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015df8:	d829      	bhi.n	34015e4e <RCCEx_GetSDMMCCLKFreq+0x19a>
34015dfa:	2b00      	cmp	r3, #0
34015dfc:	d003      	beq.n	34015e06 <RCCEx_GetSDMMCCLKFreq+0x152>
34015dfe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015e02:	d009      	beq.n	34015e18 <RCCEx_GetSDMMCCLKFreq+0x164>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            sdmmc_frequency = sdmmc_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015e04:	e023      	b.n	34015e4e <RCCEx_GetSDMMCCLKFreq+0x19a>
            sdmmc_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015e06:	f7fd fd33 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015e0a:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015e0c:	68fa      	ldr	r2, [r7, #12]
34015e0e:	68bb      	ldr	r3, [r7, #8]
34015e10:	fbb2 f3f3 	udiv	r3, r2, r3
34015e14:	60fb      	str	r3, [r7, #12]
            break;
34015e16:	e01b      	b.n	34015e50 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015e18:	f7fd fd70 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015e1c:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015e1e:	68fa      	ldr	r2, [r7, #12]
34015e20:	68bb      	ldr	r3, [r7, #8]
34015e22:	fbb2 f3f3 	udiv	r3, r2, r3
34015e26:	60fb      	str	r3, [r7, #12]
            break;
34015e28:	e012      	b.n	34015e50 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015e2a:	f7fd fdad 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015e2e:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015e30:	68fa      	ldr	r2, [r7, #12]
34015e32:	68bb      	ldr	r3, [r7, #8]
34015e34:	fbb2 f3f3 	udiv	r3, r2, r3
34015e38:	60fb      	str	r3, [r7, #12]
            break;
34015e3a:	e009      	b.n	34015e50 <RCCEx_GetSDMMCCLKFreq+0x19c>
            sdmmc_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015e3c:	f7fd fdea 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015e40:	60f8      	str	r0, [r7, #12]
            sdmmc_frequency = sdmmc_frequency / ic_divider;
34015e42:	68fa      	ldr	r2, [r7, #12]
34015e44:	68bb      	ldr	r3, [r7, #8]
34015e46:	fbb2 f3f3 	udiv	r3, r2, r3
34015e4a:	60fb      	str	r3, [r7, #12]
            break;
34015e4c:	e000      	b.n	34015e50 <RCCEx_GetSDMMCCLKFreq+0x19c>
            break;
34015e4e:	bf00      	nop
        }
      }
      break;
34015e50:	e003      	b.n	34015e5a <RCCEx_GetSDMMCCLKFreq+0x1a6>

    default:
      /* Unexpected case */
      break;
34015e52:	bf00      	nop
34015e54:	e002      	b.n	34015e5c <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34015e56:	bf00      	nop
34015e58:	e000      	b.n	34015e5c <RCCEx_GetSDMMCCLKFreq+0x1a8>
      break;
34015e5a:	bf00      	nop
  }

  return sdmmc_frequency;
34015e5c:	68fb      	ldr	r3, [r7, #12]
}
34015e5e:	4618      	mov	r0, r3
34015e60:	3710      	adds	r7, #16
34015e62:	46bd      	mov	sp, r7
34015e64:	bd80      	pop	{r7, pc}
34015e66:	bf00      	nop
34015e68:	0303041c 	.word	0x0303041c
34015e6c:	0303001c 	.word	0x0303001c
34015e70:	0302041c 	.word	0x0302041c
34015e74:	0302001c 	.word	0x0302001c
34015e78:	0301041c 	.word	0x0301041c
34015e7c:	0301001c 	.word	0x0301001c
34015e80:	0300001c 	.word	0x0300001c
34015e84:	0300041c 	.word	0x0300041c

34015e88 <RCCEx_GetSPDIFRXCLKFreq>:
  *         @arg @ref RCCEx_SPDIFRX1_Clock_Source
  * @retval SPDIF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPDIFRXCLKFreq(uint32_t SPDIFRXxSource)
{
34015e88:	b580      	push	{r7, lr}
34015e8a:	b084      	sub	sp, #16
34015e8c:	af00      	add	r7, sp, #0
34015e8e:	6078      	str	r0, [r7, #4]
  uint32_t spdifrx_frequency = RCC_PERIPH_FREQUENCY_NO;
34015e90:	2300      	movs	r3, #0
34015e92:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPDIFRXClockSource(SPDIFRXxSource))
34015e94:	6878      	ldr	r0, [r7, #4]
34015e96:	f7f9 fe3d 	bl	3400fb14 <LL_RCC_GetSPDIFRXClockSource>
34015e9a:	4603      	mov	r3, r0
34015e9c:	2b06      	cmp	r3, #6
34015e9e:	f200 80c2 	bhi.w	34016026 <RCCEx_GetSPDIFRXCLKFreq+0x19e>
34015ea2:	a201      	add	r2, pc, #4	@ (adr r2, 34015ea8 <RCCEx_GetSPDIFRXCLKFreq+0x20>)
34015ea4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34015ea8:	34015ec5 	.word	0x34015ec5
34015eac:	34015edd 	.word	0x34015edd
34015eb0:	34015ee7 	.word	0x34015ee7
34015eb4:	34015f6f 	.word	0x34015f6f
34015eb8:	34016011 	.word	0x34016011
34015ebc:	34015ff5 	.word	0x34015ff5
34015ec0:	34016021 	.word	0x34016021
  {
    case LL_RCC_SPDIFRX1_CLKSOURCE_PCLK1:
      spdifrx_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34015ec4:	f7f8 fe5c 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34015ec8:	4603      	mov	r3, r0
34015eca:	4618      	mov	r0, r3
34015ecc:	f7fd fde8 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34015ed0:	4603      	mov	r3, r0
34015ed2:	4618      	mov	r0, r3
34015ed4:	f7fd fdf5 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34015ed8:	60f8      	str	r0, [r7, #12]
      break;
34015eda:	e0ad      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_CLKP:
      spdifrx_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34015edc:	2007      	movs	r0, #7
34015ede:	f7fe f8cb 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34015ee2:	60f8      	str	r0, [r7, #12]
      break;
34015ee4:	e0a8      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC7:
      if (LL_RCC_IC7_IsEnabled() != 0U)
34015ee6:	f7fa f9ef 	bl	340102c8 <LL_RCC_IC7_IsEnabled>
34015eea:	4603      	mov	r3, r0
34015eec:	2b00      	cmp	r3, #0
34015eee:	f000 809c 	beq.w	3401602a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>
      {
        ic_divider = LL_RCC_IC7_GetDivider();
34015ef2:	f7fa fa0b 	bl	3401030c <LL_RCC_IC7_GetDivider>
34015ef6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC7_GetSource())
34015ef8:	f7fa f9fa 	bl	340102f0 <LL_RCC_IC7_GetSource>
34015efc:	4603      	mov	r3, r0
34015efe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015f02:	d029      	beq.n	34015f58 <RCCEx_GetSPDIFRXCLKFreq+0xd0>
34015f04:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015f08:	d82f      	bhi.n	34015f6a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34015f0a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015f0e:	d01a      	beq.n	34015f46 <RCCEx_GetSPDIFRXCLKFreq+0xbe>
34015f10:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015f14:	d829      	bhi.n	34015f6a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
34015f16:	2b00      	cmp	r3, #0
34015f18:	d003      	beq.n	34015f22 <RCCEx_GetSPDIFRXCLKFreq+0x9a>
34015f1a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015f1e:	d009      	beq.n	34015f34 <RCCEx_GetSPDIFRXCLKFreq+0xac>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015f20:	e023      	b.n	34015f6a <RCCEx_GetSPDIFRXCLKFreq+0xe2>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015f22:	f7fd fca5 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015f26:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015f28:	68fa      	ldr	r2, [r7, #12]
34015f2a:	68bb      	ldr	r3, [r7, #8]
34015f2c:	fbb2 f3f3 	udiv	r3, r2, r3
34015f30:	60fb      	str	r3, [r7, #12]
            break;
34015f32:	e01b      	b.n	34015f6c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015f34:	f7fd fce2 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015f38:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015f3a:	68fa      	ldr	r2, [r7, #12]
34015f3c:	68bb      	ldr	r3, [r7, #8]
34015f3e:	fbb2 f3f3 	udiv	r3, r2, r3
34015f42:	60fb      	str	r3, [r7, #12]
            break;
34015f44:	e012      	b.n	34015f6c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015f46:	f7fd fd1f 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015f4a:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015f4c:	68fa      	ldr	r2, [r7, #12]
34015f4e:	68bb      	ldr	r3, [r7, #8]
34015f50:	fbb2 f3f3 	udiv	r3, r2, r3
34015f54:	60fb      	str	r3, [r7, #12]
            break;
34015f56:	e009      	b.n	34015f6c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015f58:	f7fd fd5c 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015f5c:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015f5e:	68fa      	ldr	r2, [r7, #12]
34015f60:	68bb      	ldr	r3, [r7, #8]
34015f62:	fbb2 f3f3 	udiv	r3, r2, r3
34015f66:	60fb      	str	r3, [r7, #12]
            break;
34015f68:	e000      	b.n	34015f6c <RCCEx_GetSPDIFRXCLKFreq+0xe4>
            break;
34015f6a:	bf00      	nop
        }
      }
      break;
34015f6c:	e05d      	b.n	3401602a <RCCEx_GetSPDIFRXCLKFreq+0x1a2>

    case LL_RCC_SPDIFRX1_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
34015f6e:	f7fa f9eb 	bl	34010348 <LL_RCC_IC8_IsEnabled>
34015f72:	4603      	mov	r3, r0
34015f74:	2b00      	cmp	r3, #0
34015f76:	d05a      	beq.n	3401602e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
34015f78:	f7fa fa08 	bl	3401038c <LL_RCC_IC8_GetDivider>
34015f7c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
34015f7e:	f7fa f9f7 	bl	34010370 <LL_RCC_IC8_GetSource>
34015f82:	4603      	mov	r3, r0
34015f84:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015f88:	d029      	beq.n	34015fde <RCCEx_GetSPDIFRXCLKFreq+0x156>
34015f8a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34015f8e:	d82f      	bhi.n	34015ff0 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34015f90:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015f94:	d01a      	beq.n	34015fcc <RCCEx_GetSPDIFRXCLKFreq+0x144>
34015f96:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34015f9a:	d829      	bhi.n	34015ff0 <RCCEx_GetSPDIFRXCLKFreq+0x168>
34015f9c:	2b00      	cmp	r3, #0
34015f9e:	d003      	beq.n	34015fa8 <RCCEx_GetSPDIFRXCLKFreq+0x120>
34015fa0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34015fa4:	d009      	beq.n	34015fba <RCCEx_GetSPDIFRXCLKFreq+0x132>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spdifrx_frequency = spdifrx_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34015fa6:	e023      	b.n	34015ff0 <RCCEx_GetSPDIFRXCLKFreq+0x168>
            spdifrx_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34015fa8:	f7fd fc62 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34015fac:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015fae:	68fa      	ldr	r2, [r7, #12]
34015fb0:	68bb      	ldr	r3, [r7, #8]
34015fb2:	fbb2 f3f3 	udiv	r3, r2, r3
34015fb6:	60fb      	str	r3, [r7, #12]
            break;
34015fb8:	e01b      	b.n	34015ff2 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34015fba:	f7fd fc9f 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34015fbe:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015fc0:	68fa      	ldr	r2, [r7, #12]
34015fc2:	68bb      	ldr	r3, [r7, #8]
34015fc4:	fbb2 f3f3 	udiv	r3, r2, r3
34015fc8:	60fb      	str	r3, [r7, #12]
            break;
34015fca:	e012      	b.n	34015ff2 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34015fcc:	f7fd fcdc 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34015fd0:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015fd2:	68fa      	ldr	r2, [r7, #12]
34015fd4:	68bb      	ldr	r3, [r7, #8]
34015fd6:	fbb2 f3f3 	udiv	r3, r2, r3
34015fda:	60fb      	str	r3, [r7, #12]
            break;
34015fdc:	e009      	b.n	34015ff2 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            spdifrx_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34015fde:	f7fd fd19 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34015fe2:	60f8      	str	r0, [r7, #12]
            spdifrx_frequency = spdifrx_frequency / ic_divider;
34015fe4:	68fa      	ldr	r2, [r7, #12]
34015fe6:	68bb      	ldr	r3, [r7, #8]
34015fe8:	fbb2 f3f3 	udiv	r3, r2, r3
34015fec:	60fb      	str	r3, [r7, #12]
            break;
34015fee:	e000      	b.n	34015ff2 <RCCEx_GetSPDIFRXCLKFreq+0x16a>
            break;
34015ff0:	bf00      	nop
        }
      }
      break;
34015ff2:	e01c      	b.n	3401602e <RCCEx_GetSPDIFRXCLKFreq+0x1a6>

    case LL_RCC_SPDIFRX1_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
34015ff4:	f7f9 f9c4 	bl	3400f380 <LL_RCC_HSI_IsReady>
34015ff8:	4603      	mov	r3, r0
34015ffa:	2b00      	cmp	r3, #0
34015ffc:	d019      	beq.n	34016032 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>
      {
        spdifrx_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34015ffe:	f7f9 f9d1 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34016002:	4603      	mov	r3, r0
34016004:	09db      	lsrs	r3, r3, #7
34016006:	4a0f      	ldr	r2, [pc, #60]	@ (34016044 <RCCEx_GetSPDIFRXCLKFreq+0x1bc>)
34016008:	fa22 f303 	lsr.w	r3, r2, r3
3401600c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401600e:	e010      	b.n	34016032 <RCCEx_GetSPDIFRXCLKFreq+0x1aa>

    case LL_RCC_SPDIFRX1_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34016010:	f7f9 f9d6 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34016014:	4603      	mov	r3, r0
34016016:	2b00      	cmp	r3, #0
34016018:	d00d      	beq.n	34016036 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>
      {
        spdifrx_frequency = MSI_VALUE;
3401601a:	4b0b      	ldr	r3, [pc, #44]	@ (34016048 <RCCEx_GetSPDIFRXCLKFreq+0x1c0>)
3401601c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401601e:	e00a      	b.n	34016036 <RCCEx_GetSPDIFRXCLKFreq+0x1ae>

    case LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN:
      spdifrx_frequency = EXTERNAL_CLOCK_VALUE;
34016020:	4b0a      	ldr	r3, [pc, #40]	@ (3401604c <RCCEx_GetSPDIFRXCLKFreq+0x1c4>)
34016022:	60fb      	str	r3, [r7, #12]
      break;
34016024:	e008      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>

    default:
      /* Unexpected case */
      break;
34016026:	bf00      	nop
34016028:	e006      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3401602a:	bf00      	nop
3401602c:	e004      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
3401602e:	bf00      	nop
34016030:	e002      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34016032:	bf00      	nop
34016034:	e000      	b.n	34016038 <RCCEx_GetSPDIFRXCLKFreq+0x1b0>
      break;
34016036:	bf00      	nop
  }

  return spdifrx_frequency;
34016038:	68fb      	ldr	r3, [r7, #12]
}
3401603a:	4618      	mov	r0, r3
3401603c:	3710      	adds	r7, #16
3401603e:	46bd      	mov	sp, r7
34016040:	bd80      	pop	{r7, pc}
34016042:	bf00      	nop
34016044:	03d09000 	.word	0x03d09000
34016048:	003d0900 	.word	0x003d0900
3401604c:	00bb8000 	.word	0x00bb8000

34016050 <RCCEx_GetSPICLKFreq>:
  *         @arg @ref RCCEx_SPI6_Clock_Source
  * @retval SPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetSPICLKFreq(uint32_t SPIxSource)
{
34016050:	b580      	push	{r7, lr}
34016052:	b084      	sub	sp, #16
34016054:	af00      	add	r7, sp, #0
34016056:	6078      	str	r0, [r7, #4]
  uint32_t spi_frequency = RCC_PERIPH_FREQUENCY_NO;
34016058:	2300      	movs	r3, #0
3401605a:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetSPIClockSource(SPIxSource))
3401605c:	6878      	ldr	r0, [r7, #4]
3401605e:	f7f9 fd6b 	bl	3400fb38 <LL_RCC_GetSPIClockSource>
34016062:	4603      	mov	r3, r0
34016064:	4aa7      	ldr	r2, [pc, #668]	@ (34016304 <RCCEx_GetSPICLKFreq+0x2b4>)
34016066:	4293      	cmp	r3, r2
34016068:	f000 829e 	beq.w	340165a8 <RCCEx_GetSPICLKFreq+0x558>
3401606c:	4aa5      	ldr	r2, [pc, #660]	@ (34016304 <RCCEx_GetSPICLKFreq+0x2b4>)
3401606e:	4293      	cmp	r3, r2
34016070:	f200 82a5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016074:	4aa4      	ldr	r2, [pc, #656]	@ (34016308 <RCCEx_GetSPICLKFreq+0x2b8>)
34016076:	4293      	cmp	r3, r2
34016078:	f000 8299 	beq.w	340165ae <RCCEx_GetSPICLKFreq+0x55e>
3401607c:	4aa2      	ldr	r2, [pc, #648]	@ (34016308 <RCCEx_GetSPICLKFreq+0x2b8>)
3401607e:	4293      	cmp	r3, r2
34016080:	f200 829d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016084:	4aa1      	ldr	r2, [pc, #644]	@ (3401630c <RCCEx_GetSPICLKFreq+0x2bc>)
34016086:	4293      	cmp	r3, r2
34016088:	f000 8291 	beq.w	340165ae <RCCEx_GetSPICLKFreq+0x55e>
3401608c:	4a9f      	ldr	r2, [pc, #636]	@ (3401630c <RCCEx_GetSPICLKFreq+0x2bc>)
3401608e:	4293      	cmp	r3, r2
34016090:	f200 8295 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016094:	4a9e      	ldr	r2, [pc, #632]	@ (34016310 <RCCEx_GetSPICLKFreq+0x2c0>)
34016096:	4293      	cmp	r3, r2
34016098:	f000 8286 	beq.w	340165a8 <RCCEx_GetSPICLKFreq+0x558>
3401609c:	4a9c      	ldr	r2, [pc, #624]	@ (34016310 <RCCEx_GetSPICLKFreq+0x2c0>)
3401609e:	4293      	cmp	r3, r2
340160a0:	f200 828d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160a4:	4a9b      	ldr	r2, [pc, #620]	@ (34016314 <RCCEx_GetSPICLKFreq+0x2c4>)
340160a6:	4293      	cmp	r3, r2
340160a8:	f000 827e 	beq.w	340165a8 <RCCEx_GetSPICLKFreq+0x558>
340160ac:	4a99      	ldr	r2, [pc, #612]	@ (34016314 <RCCEx_GetSPICLKFreq+0x2c4>)
340160ae:	4293      	cmp	r3, r2
340160b0:	f200 8285 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160b4:	4a98      	ldr	r2, [pc, #608]	@ (34016318 <RCCEx_GetSPICLKFreq+0x2c8>)
340160b6:	4293      	cmp	r3, r2
340160b8:	f000 8276 	beq.w	340165a8 <RCCEx_GetSPICLKFreq+0x558>
340160bc:	4a96      	ldr	r2, [pc, #600]	@ (34016318 <RCCEx_GetSPICLKFreq+0x2c8>)
340160be:	4293      	cmp	r3, r2
340160c0:	f200 827d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160c4:	4a95      	ldr	r2, [pc, #596]	@ (3401631c <RCCEx_GetSPICLKFreq+0x2cc>)
340160c6:	4293      	cmp	r3, r2
340160c8:	f000 8258 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
340160cc:	4a93      	ldr	r2, [pc, #588]	@ (3401631c <RCCEx_GetSPICLKFreq+0x2cc>)
340160ce:	4293      	cmp	r3, r2
340160d0:	f200 8275 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160d4:	4a92      	ldr	r2, [pc, #584]	@ (34016320 <RCCEx_GetSPICLKFreq+0x2d0>)
340160d6:	4293      	cmp	r3, r2
340160d8:	f000 8250 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
340160dc:	4a90      	ldr	r2, [pc, #576]	@ (34016320 <RCCEx_GetSPICLKFreq+0x2d0>)
340160de:	4293      	cmp	r3, r2
340160e0:	f200 826d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160e4:	4a8f      	ldr	r2, [pc, #572]	@ (34016324 <RCCEx_GetSPICLKFreq+0x2d4>)
340160e6:	4293      	cmp	r3, r2
340160e8:	f000 8248 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
340160ec:	4a8d      	ldr	r2, [pc, #564]	@ (34016324 <RCCEx_GetSPICLKFreq+0x2d4>)
340160ee:	4293      	cmp	r3, r2
340160f0:	f200 8265 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340160f4:	4a8c      	ldr	r2, [pc, #560]	@ (34016328 <RCCEx_GetSPICLKFreq+0x2d8>)
340160f6:	4293      	cmp	r3, r2
340160f8:	f000 8240 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
340160fc:	4a8a      	ldr	r2, [pc, #552]	@ (34016328 <RCCEx_GetSPICLKFreq+0x2d8>)
340160fe:	4293      	cmp	r3, r2
34016100:	f200 825d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016104:	4a89      	ldr	r2, [pc, #548]	@ (3401632c <RCCEx_GetSPICLKFreq+0x2dc>)
34016106:	4293      	cmp	r3, r2
34016108:	f000 8238 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
3401610c:	4a87      	ldr	r2, [pc, #540]	@ (3401632c <RCCEx_GetSPICLKFreq+0x2dc>)
3401610e:	4293      	cmp	r3, r2
34016110:	f200 8255 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016114:	4a86      	ldr	r2, [pc, #536]	@ (34016330 <RCCEx_GetSPICLKFreq+0x2e0>)
34016116:	4293      	cmp	r3, r2
34016118:	f000 8230 	beq.w	3401657c <RCCEx_GetSPICLKFreq+0x52c>
3401611c:	4a84      	ldr	r2, [pc, #528]	@ (34016330 <RCCEx_GetSPICLKFreq+0x2e0>)
3401611e:	4293      	cmp	r3, r2
34016120:	f200 824d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016124:	4a83      	ldr	r2, [pc, #524]	@ (34016334 <RCCEx_GetSPICLKFreq+0x2e4>)
34016126:	4293      	cmp	r3, r2
34016128:	f000 8236 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401612c:	4a81      	ldr	r2, [pc, #516]	@ (34016334 <RCCEx_GetSPICLKFreq+0x2e4>)
3401612e:	4293      	cmp	r3, r2
34016130:	f200 8245 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016134:	4a80      	ldr	r2, [pc, #512]	@ (34016338 <RCCEx_GetSPICLKFreq+0x2e8>)
34016136:	4293      	cmp	r3, r2
34016138:	f000 822e 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401613c:	4a7e      	ldr	r2, [pc, #504]	@ (34016338 <RCCEx_GetSPICLKFreq+0x2e8>)
3401613e:	4293      	cmp	r3, r2
34016140:	f200 823d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016144:	4a7d      	ldr	r2, [pc, #500]	@ (3401633c <RCCEx_GetSPICLKFreq+0x2ec>)
34016146:	4293      	cmp	r3, r2
34016148:	f000 8226 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401614c:	4a7b      	ldr	r2, [pc, #492]	@ (3401633c <RCCEx_GetSPICLKFreq+0x2ec>)
3401614e:	4293      	cmp	r3, r2
34016150:	f200 8235 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016154:	4a7a      	ldr	r2, [pc, #488]	@ (34016340 <RCCEx_GetSPICLKFreq+0x2f0>)
34016156:	4293      	cmp	r3, r2
34016158:	f000 821e 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401615c:	4a78      	ldr	r2, [pc, #480]	@ (34016340 <RCCEx_GetSPICLKFreq+0x2f0>)
3401615e:	4293      	cmp	r3, r2
34016160:	f200 822d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016164:	4a77      	ldr	r2, [pc, #476]	@ (34016344 <RCCEx_GetSPICLKFreq+0x2f4>)
34016166:	4293      	cmp	r3, r2
34016168:	f000 8216 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401616c:	4a75      	ldr	r2, [pc, #468]	@ (34016344 <RCCEx_GetSPICLKFreq+0x2f4>)
3401616e:	4293      	cmp	r3, r2
34016170:	f200 8225 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016174:	4a74      	ldr	r2, [pc, #464]	@ (34016348 <RCCEx_GetSPICLKFreq+0x2f8>)
34016176:	4293      	cmp	r3, r2
34016178:	f000 820e 	beq.w	34016598 <RCCEx_GetSPICLKFreq+0x548>
3401617c:	4a72      	ldr	r2, [pc, #456]	@ (34016348 <RCCEx_GetSPICLKFreq+0x2f8>)
3401617e:	4293      	cmp	r3, r2
34016180:	f200 821d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016184:	4a71      	ldr	r2, [pc, #452]	@ (3401634c <RCCEx_GetSPICLKFreq+0x2fc>)
34016186:	4293      	cmp	r3, r2
34016188:	f000 8171 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
3401618c:	4a6f      	ldr	r2, [pc, #444]	@ (3401634c <RCCEx_GetSPICLKFreq+0x2fc>)
3401618e:	4293      	cmp	r3, r2
34016190:	f200 8215 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016194:	4a6e      	ldr	r2, [pc, #440]	@ (34016350 <RCCEx_GetSPICLKFreq+0x300>)
34016196:	4293      	cmp	r3, r2
34016198:	f000 81ad 	beq.w	340164f6 <RCCEx_GetSPICLKFreq+0x4a6>
3401619c:	4a6c      	ldr	r2, [pc, #432]	@ (34016350 <RCCEx_GetSPICLKFreq+0x300>)
3401619e:	4293      	cmp	r3, r2
340161a0:	f200 820d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161a4:	4a6b      	ldr	r2, [pc, #428]	@ (34016354 <RCCEx_GetSPICLKFreq+0x304>)
340161a6:	4293      	cmp	r3, r2
340161a8:	f000 81a5 	beq.w	340164f6 <RCCEx_GetSPICLKFreq+0x4a6>
340161ac:	4a69      	ldr	r2, [pc, #420]	@ (34016354 <RCCEx_GetSPICLKFreq+0x304>)
340161ae:	4293      	cmp	r3, r2
340161b0:	f200 8205 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161b4:	4a68      	ldr	r2, [pc, #416]	@ (34016358 <RCCEx_GetSPICLKFreq+0x308>)
340161b6:	4293      	cmp	r3, r2
340161b8:	f000 8159 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
340161bc:	4a66      	ldr	r2, [pc, #408]	@ (34016358 <RCCEx_GetSPICLKFreq+0x308>)
340161be:	4293      	cmp	r3, r2
340161c0:	f200 81fd 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161c4:	4a65      	ldr	r2, [pc, #404]	@ (3401635c <RCCEx_GetSPICLKFreq+0x30c>)
340161c6:	4293      	cmp	r3, r2
340161c8:	f000 8151 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
340161cc:	4a63      	ldr	r2, [pc, #396]	@ (3401635c <RCCEx_GetSPICLKFreq+0x30c>)
340161ce:	4293      	cmp	r3, r2
340161d0:	f200 81f5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161d4:	4a62      	ldr	r2, [pc, #392]	@ (34016360 <RCCEx_GetSPICLKFreq+0x310>)
340161d6:	4293      	cmp	r3, r2
340161d8:	f000 8149 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
340161dc:	4a60      	ldr	r2, [pc, #384]	@ (34016360 <RCCEx_GetSPICLKFreq+0x310>)
340161de:	4293      	cmp	r3, r2
340161e0:	f200 81ed 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161e4:	4a5f      	ldr	r2, [pc, #380]	@ (34016364 <RCCEx_GetSPICLKFreq+0x314>)
340161e6:	4293      	cmp	r3, r2
340161e8:	f000 80fd 	beq.w	340163e6 <RCCEx_GetSPICLKFreq+0x396>
340161ec:	4a5d      	ldr	r2, [pc, #372]	@ (34016364 <RCCEx_GetSPICLKFreq+0x314>)
340161ee:	4293      	cmp	r3, r2
340161f0:	f200 81e5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340161f4:	4a5c      	ldr	r2, [pc, #368]	@ (34016368 <RCCEx_GetSPICLKFreq+0x318>)
340161f6:	4293      	cmp	r3, r2
340161f8:	f000 8139 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
340161fc:	4a5a      	ldr	r2, [pc, #360]	@ (34016368 <RCCEx_GetSPICLKFreq+0x318>)
340161fe:	4293      	cmp	r3, r2
34016200:	f200 81dd 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016204:	4a59      	ldr	r2, [pc, #356]	@ (3401636c <RCCEx_GetSPICLKFreq+0x31c>)
34016206:	4293      	cmp	r3, r2
34016208:	f000 8131 	beq.w	3401646e <RCCEx_GetSPICLKFreq+0x41e>
3401620c:	4a57      	ldr	r2, [pc, #348]	@ (3401636c <RCCEx_GetSPICLKFreq+0x31c>)
3401620e:	4293      	cmp	r3, r2
34016210:	f200 81d5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016214:	4a56      	ldr	r2, [pc, #344]	@ (34016370 <RCCEx_GetSPICLKFreq+0x320>)
34016216:	4293      	cmp	r3, r2
34016218:	f000 80e5 	beq.w	340163e6 <RCCEx_GetSPICLKFreq+0x396>
3401621c:	4a54      	ldr	r2, [pc, #336]	@ (34016370 <RCCEx_GetSPICLKFreq+0x320>)
3401621e:	4293      	cmp	r3, r2
34016220:	f200 81cd 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016224:	4a53      	ldr	r2, [pc, #332]	@ (34016374 <RCCEx_GetSPICLKFreq+0x324>)
34016226:	4293      	cmp	r3, r2
34016228:	f000 80dd 	beq.w	340163e6 <RCCEx_GetSPICLKFreq+0x396>
3401622c:	4a51      	ldr	r2, [pc, #324]	@ (34016374 <RCCEx_GetSPICLKFreq+0x324>)
3401622e:	4293      	cmp	r3, r2
34016230:	f200 81c5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016234:	4a50      	ldr	r2, [pc, #320]	@ (34016378 <RCCEx_GetSPICLKFreq+0x328>)
34016236:	4293      	cmp	r3, r2
34016238:	f000 80d5 	beq.w	340163e6 <RCCEx_GetSPICLKFreq+0x396>
3401623c:	4a4e      	ldr	r2, [pc, #312]	@ (34016378 <RCCEx_GetSPICLKFreq+0x328>)
3401623e:	4293      	cmp	r3, r2
34016240:	f200 81bd 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016244:	4a4d      	ldr	r2, [pc, #308]	@ (3401637c <RCCEx_GetSPICLKFreq+0x32c>)
34016246:	4293      	cmp	r3, r2
34016248:	f000 80c8 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401624c:	4a4b      	ldr	r2, [pc, #300]	@ (3401637c <RCCEx_GetSPICLKFreq+0x32c>)
3401624e:	4293      	cmp	r3, r2
34016250:	f200 81b5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016254:	4a4a      	ldr	r2, [pc, #296]	@ (34016380 <RCCEx_GetSPICLKFreq+0x330>)
34016256:	4293      	cmp	r3, r2
34016258:	f000 80c0 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401625c:	4a48      	ldr	r2, [pc, #288]	@ (34016380 <RCCEx_GetSPICLKFreq+0x330>)
3401625e:	4293      	cmp	r3, r2
34016260:	f200 81ad 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016264:	4a47      	ldr	r2, [pc, #284]	@ (34016384 <RCCEx_GetSPICLKFreq+0x334>)
34016266:	4293      	cmp	r3, r2
34016268:	f000 80b8 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401626c:	4a45      	ldr	r2, [pc, #276]	@ (34016384 <RCCEx_GetSPICLKFreq+0x334>)
3401626e:	4293      	cmp	r3, r2
34016270:	f200 81a5 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016274:	4a44      	ldr	r2, [pc, #272]	@ (34016388 <RCCEx_GetSPICLKFreq+0x338>)
34016276:	4293      	cmp	r3, r2
34016278:	f000 80b0 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401627c:	4a42      	ldr	r2, [pc, #264]	@ (34016388 <RCCEx_GetSPICLKFreq+0x338>)
3401627e:	4293      	cmp	r3, r2
34016280:	f200 819d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016284:	4a41      	ldr	r2, [pc, #260]	@ (3401638c <RCCEx_GetSPICLKFreq+0x33c>)
34016286:	4293      	cmp	r3, r2
34016288:	f000 80a8 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401628c:	4a3f      	ldr	r2, [pc, #252]	@ (3401638c <RCCEx_GetSPICLKFreq+0x33c>)
3401628e:	4293      	cmp	r3, r2
34016290:	f200 8195 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
34016294:	4a3e      	ldr	r2, [pc, #248]	@ (34016390 <RCCEx_GetSPICLKFreq+0x340>)
34016296:	4293      	cmp	r3, r2
34016298:	f000 80a0 	beq.w	340163dc <RCCEx_GetSPICLKFreq+0x38c>
3401629c:	4a3c      	ldr	r2, [pc, #240]	@ (34016390 <RCCEx_GetSPICLKFreq+0x340>)
3401629e:	4293      	cmp	r3, r2
340162a0:	f200 818d 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340162a4:	4a3b      	ldr	r2, [pc, #236]	@ (34016394 <RCCEx_GetSPICLKFreq+0x344>)
340162a6:	4293      	cmp	r3, r2
340162a8:	f000 808c 	beq.w	340163c4 <RCCEx_GetSPICLKFreq+0x374>
340162ac:	4a39      	ldr	r2, [pc, #228]	@ (34016394 <RCCEx_GetSPICLKFreq+0x344>)
340162ae:	4293      	cmp	r3, r2
340162b0:	f200 8185 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340162b4:	4a38      	ldr	r2, [pc, #224]	@ (34016398 <RCCEx_GetSPICLKFreq+0x348>)
340162b6:	4293      	cmp	r3, r2
340162b8:	d078      	beq.n	340163ac <RCCEx_GetSPICLKFreq+0x35c>
340162ba:	4a37      	ldr	r2, [pc, #220]	@ (34016398 <RCCEx_GetSPICLKFreq+0x348>)
340162bc:	4293      	cmp	r3, r2
340162be:	f200 817e 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340162c2:	4a36      	ldr	r2, [pc, #216]	@ (3401639c <RCCEx_GetSPICLKFreq+0x34c>)
340162c4:	4293      	cmp	r3, r2
340162c6:	d071      	beq.n	340163ac <RCCEx_GetSPICLKFreq+0x35c>
340162c8:	4a34      	ldr	r2, [pc, #208]	@ (3401639c <RCCEx_GetSPICLKFreq+0x34c>)
340162ca:	4293      	cmp	r3, r2
340162cc:	f200 8177 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340162d0:	4a33      	ldr	r2, [pc, #204]	@ (340163a0 <RCCEx_GetSPICLKFreq+0x350>)
340162d2:	4293      	cmp	r3, r2
340162d4:	d00a      	beq.n	340162ec <RCCEx_GetSPICLKFreq+0x29c>
340162d6:	4a32      	ldr	r2, [pc, #200]	@ (340163a0 <RCCEx_GetSPICLKFreq+0x350>)
340162d8:	4293      	cmp	r3, r2
340162da:	f200 8170 	bhi.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
340162de:	4a31      	ldr	r2, [pc, #196]	@ (340163a4 <RCCEx_GetSPICLKFreq+0x354>)
340162e0:	4293      	cmp	r3, r2
340162e2:	d063      	beq.n	340163ac <RCCEx_GetSPICLKFreq+0x35c>
340162e4:	4a30      	ldr	r2, [pc, #192]	@ (340163a8 <RCCEx_GetSPICLKFreq+0x358>)
340162e6:	4293      	cmp	r3, r2
340162e8:	f040 8169 	bne.w	340165be <RCCEx_GetSPICLKFreq+0x56e>
  {
    case LL_RCC_SPI2_CLKSOURCE_PCLK1:
    case LL_RCC_SPI3_CLKSOURCE_PCLK1:
      spi_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340162ec:	f7f8 fc48 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340162f0:	4603      	mov	r3, r0
340162f2:	4618      	mov	r0, r3
340162f4:	f7fd fbd4 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340162f8:	4603      	mov	r3, r0
340162fa:	4618      	mov	r0, r3
340162fc:	f7fd fbe1 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34016300:	60f8      	str	r0, [r7, #12]
      break;
34016302:	e169      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
34016304:	07061820 	.word	0x07061820
34016308:	07061420 	.word	0x07061420
3401630c:	07061020 	.word	0x07061020
34016310:	07060c20 	.word	0x07060c20
34016314:	07060820 	.word	0x07060820
34016318:	07060420 	.word	0x07060420
3401631c:	07051820 	.word	0x07051820
34016320:	07051420 	.word	0x07051420
34016324:	07051020 	.word	0x07051020
34016328:	07050c20 	.word	0x07050c20
3401632c:	07050820 	.word	0x07050820
34016330:	07050420 	.word	0x07050420
34016334:	07041820 	.word	0x07041820
34016338:	07041420 	.word	0x07041420
3401633c:	07041020 	.word	0x07041020
34016340:	07040c20 	.word	0x07040c20
34016344:	07040820 	.word	0x07040820
34016348:	07040420 	.word	0x07040420
3401634c:	07031820 	.word	0x07031820
34016350:	07031420 	.word	0x07031420
34016354:	07031020 	.word	0x07031020
34016358:	07030c20 	.word	0x07030c20
3401635c:	07030820 	.word	0x07030820
34016360:	07030420 	.word	0x07030420
34016364:	07021820 	.word	0x07021820
34016368:	07021420 	.word	0x07021420
3401636c:	07021020 	.word	0x07021020
34016370:	07020c20 	.word	0x07020c20
34016374:	07020820 	.word	0x07020820
34016378:	07020420 	.word	0x07020420
3401637c:	07011820 	.word	0x07011820
34016380:	07011420 	.word	0x07011420
34016384:	07011020 	.word	0x07011020
34016388:	07010c20 	.word	0x07010c20
3401638c:	07010820 	.word	0x07010820
34016390:	07010420 	.word	0x07010420
34016394:	07001820 	.word	0x07001820
34016398:	07001420 	.word	0x07001420
3401639c:	07001020 	.word	0x07001020
340163a0:	07000c20 	.word	0x07000c20
340163a4:	07000420 	.word	0x07000420
340163a8:	07000820 	.word	0x07000820

    case LL_RCC_SPI1_CLKSOURCE_PCLK2:
    case LL_RCC_SPI4_CLKSOURCE_PCLK2:
    case LL_RCC_SPI5_CLKSOURCE_PCLK2:
      spi_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340163ac:	f7f8 fbe8 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340163b0:	4603      	mov	r3, r0
340163b2:	4618      	mov	r0, r3
340163b4:	f7fd fb74 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340163b8:	4603      	mov	r3, r0
340163ba:	4618      	mov	r0, r3
340163bc:	f7fd fb91 	bl	34013ae2 <RCCEx_GetPCLK2Freq>
340163c0:	60f8      	str	r0, [r7, #12]
      break;
340163c2:	e109      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI6_CLKSOURCE_PCLK4:
      spi_frequency = RCCEx_GetPCLK4Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
340163c4:	f7f8 fbdc 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
340163c8:	4603      	mov	r3, r0
340163ca:	4618      	mov	r0, r3
340163cc:	f7fd fb68 	bl	34013aa0 <RCCEx_GetHCLKFreq>
340163d0:	4603      	mov	r3, r0
340163d2:	4618      	mov	r0, r3
340163d4:	f7fd fb96 	bl	34013b04 <RCCEx_GetPCLK4Freq>
340163d8:	60f8      	str	r0, [r7, #12]
      break;
340163da:	e0fd      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
    case LL_RCC_SPI2_CLKSOURCE_CLKP:
    case LL_RCC_SPI3_CLKSOURCE_CLKP:
    case LL_RCC_SPI4_CLKSOURCE_CLKP:
    case LL_RCC_SPI5_CLKSOURCE_CLKP:
    case LL_RCC_SPI6_CLKSOURCE_CLKP:
      spi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
340163dc:	2007      	movs	r0, #7
340163de:	f7fd fe4b 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
340163e2:	60f8      	str	r0, [r7, #12]
      break;
340163e4:	e0f8      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI1_CLKSOURCE_IC8:
    case LL_RCC_SPI2_CLKSOURCE_IC8:
    case LL_RCC_SPI3_CLKSOURCE_IC8:
    case LL_RCC_SPI6_CLKSOURCE_IC8:
      if (LL_RCC_IC8_IsEnabled() != 0U)
340163e6:	f7f9 ffaf 	bl	34010348 <LL_RCC_IC8_IsEnabled>
340163ea:	4603      	mov	r3, r0
340163ec:	2b00      	cmp	r3, #0
340163ee:	f000 80e8 	beq.w	340165c2 <RCCEx_GetSPICLKFreq+0x572>
      {
        ic_divider = LL_RCC_IC8_GetDivider();
340163f2:	f7f9 ffcb 	bl	3401038c <LL_RCC_IC8_GetDivider>
340163f6:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC8_GetSource())
340163f8:	f7f9 ffba 	bl	34010370 <LL_RCC_IC8_GetSource>
340163fc:	4603      	mov	r3, r0
340163fe:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016402:	d029      	beq.n	34016458 <RCCEx_GetSPICLKFreq+0x408>
34016404:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016408:	d82f      	bhi.n	3401646a <RCCEx_GetSPICLKFreq+0x41a>
3401640a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401640e:	d01a      	beq.n	34016446 <RCCEx_GetSPICLKFreq+0x3f6>
34016410:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016414:	d829      	bhi.n	3401646a <RCCEx_GetSPICLKFreq+0x41a>
34016416:	2b00      	cmp	r3, #0
34016418:	d003      	beq.n	34016422 <RCCEx_GetSPICLKFreq+0x3d2>
3401641a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401641e:	d009      	beq.n	34016434 <RCCEx_GetSPICLKFreq+0x3e4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016420:	e023      	b.n	3401646a <RCCEx_GetSPICLKFreq+0x41a>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016422:	f7fd fa25 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016426:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34016428:	68fa      	ldr	r2, [r7, #12]
3401642a:	68bb      	ldr	r3, [r7, #8]
3401642c:	fbb2 f3f3 	udiv	r3, r2, r3
34016430:	60fb      	str	r3, [r7, #12]
            break;
34016432:	e01b      	b.n	3401646c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016434:	f7fd fa62 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016438:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401643a:	68fa      	ldr	r2, [r7, #12]
3401643c:	68bb      	ldr	r3, [r7, #8]
3401643e:	fbb2 f3f3 	udiv	r3, r2, r3
34016442:	60fb      	str	r3, [r7, #12]
            break;
34016444:	e012      	b.n	3401646c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016446:	f7fd fa9f 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
3401644a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401644c:	68fa      	ldr	r2, [r7, #12]
3401644e:	68bb      	ldr	r3, [r7, #8]
34016450:	fbb2 f3f3 	udiv	r3, r2, r3
34016454:	60fb      	str	r3, [r7, #12]
            break;
34016456:	e009      	b.n	3401646c <RCCEx_GetSPICLKFreq+0x41c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016458:	f7fd fadc 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401645c:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401645e:	68fa      	ldr	r2, [r7, #12]
34016460:	68bb      	ldr	r3, [r7, #8]
34016462:	fbb2 f3f3 	udiv	r3, r2, r3
34016466:	60fb      	str	r3, [r7, #12]
            break;
34016468:	e000      	b.n	3401646c <RCCEx_GetSPICLKFreq+0x41c>
            break;
3401646a:	bf00      	nop
        }
      }
      break;
3401646c:	e0a9      	b.n	340165c2 <RCCEx_GetSPICLKFreq+0x572>
    case LL_RCC_SPI2_CLKSOURCE_IC9:
    case LL_RCC_SPI3_CLKSOURCE_IC9:
    case LL_RCC_SPI4_CLKSOURCE_IC9:
    case LL_RCC_SPI5_CLKSOURCE_IC9:
    case LL_RCC_SPI6_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
3401646e:	f7f9 ffab 	bl	340103c8 <LL_RCC_IC9_IsEnabled>
34016472:	4603      	mov	r3, r0
34016474:	2b00      	cmp	r3, #0
34016476:	f000 80a6 	beq.w	340165c6 <RCCEx_GetSPICLKFreq+0x576>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
3401647a:	f7f9 ffc7 	bl	3401040c <LL_RCC_IC9_GetDivider>
3401647e:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34016480:	f7f9 ffb6 	bl	340103f0 <LL_RCC_IC9_GetSource>
34016484:	4603      	mov	r3, r0
34016486:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401648a:	d029      	beq.n	340164e0 <RCCEx_GetSPICLKFreq+0x490>
3401648c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016490:	d82f      	bhi.n	340164f2 <RCCEx_GetSPICLKFreq+0x4a2>
34016492:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016496:	d01a      	beq.n	340164ce <RCCEx_GetSPICLKFreq+0x47e>
34016498:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401649c:	d829      	bhi.n	340164f2 <RCCEx_GetSPICLKFreq+0x4a2>
3401649e:	2b00      	cmp	r3, #0
340164a0:	d003      	beq.n	340164aa <RCCEx_GetSPICLKFreq+0x45a>
340164a2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340164a6:	d009      	beq.n	340164bc <RCCEx_GetSPICLKFreq+0x46c>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340164a8:	e023      	b.n	340164f2 <RCCEx_GetSPICLKFreq+0x4a2>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340164aa:	f7fd f9e1 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340164ae:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340164b0:	68fa      	ldr	r2, [r7, #12]
340164b2:	68bb      	ldr	r3, [r7, #8]
340164b4:	fbb2 f3f3 	udiv	r3, r2, r3
340164b8:	60fb      	str	r3, [r7, #12]
            break;
340164ba:	e01b      	b.n	340164f4 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340164bc:	f7fd fa1e 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340164c0:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340164c2:	68fa      	ldr	r2, [r7, #12]
340164c4:	68bb      	ldr	r3, [r7, #8]
340164c6:	fbb2 f3f3 	udiv	r3, r2, r3
340164ca:	60fb      	str	r3, [r7, #12]
            break;
340164cc:	e012      	b.n	340164f4 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340164ce:	f7fd fa5b 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340164d2:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340164d4:	68fa      	ldr	r2, [r7, #12]
340164d6:	68bb      	ldr	r3, [r7, #8]
340164d8:	fbb2 f3f3 	udiv	r3, r2, r3
340164dc:	60fb      	str	r3, [r7, #12]
            break;
340164de:	e009      	b.n	340164f4 <RCCEx_GetSPICLKFreq+0x4a4>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340164e0:	f7fd fa98 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340164e4:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
340164e6:	68fa      	ldr	r2, [r7, #12]
340164e8:	68bb      	ldr	r3, [r7, #8]
340164ea:	fbb2 f3f3 	udiv	r3, r2, r3
340164ee:	60fb      	str	r3, [r7, #12]
            break;
340164f0:	e000      	b.n	340164f4 <RCCEx_GetSPICLKFreq+0x4a4>
            break;
340164f2:	bf00      	nop
        }
      }
      break;
340164f4:	e067      	b.n	340165c6 <RCCEx_GetSPICLKFreq+0x576>

    case LL_RCC_SPI4_CLKSOURCE_IC14:
    case LL_RCC_SPI5_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
340164f6:	f7fa f867 	bl	340105c8 <LL_RCC_IC14_IsEnabled>
340164fa:	4603      	mov	r3, r0
340164fc:	2b00      	cmp	r3, #0
340164fe:	d064      	beq.n	340165ca <RCCEx_GetSPICLKFreq+0x57a>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34016500:	f7fa f884 	bl	3401060c <LL_RCC_IC14_GetDivider>
34016504:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34016506:	f7fa f873 	bl	340105f0 <LL_RCC_IC14_GetSource>
3401650a:	4603      	mov	r3, r0
3401650c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016510:	d029      	beq.n	34016566 <RCCEx_GetSPICLKFreq+0x516>
34016512:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016516:	d82f      	bhi.n	34016578 <RCCEx_GetSPICLKFreq+0x528>
34016518:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401651c:	d01a      	beq.n	34016554 <RCCEx_GetSPICLKFreq+0x504>
3401651e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016522:	d829      	bhi.n	34016578 <RCCEx_GetSPICLKFreq+0x528>
34016524:	2b00      	cmp	r3, #0
34016526:	d003      	beq.n	34016530 <RCCEx_GetSPICLKFreq+0x4e0>
34016528:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401652c:	d009      	beq.n	34016542 <RCCEx_GetSPICLKFreq+0x4f2>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            spi_frequency = spi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
3401652e:	e023      	b.n	34016578 <RCCEx_GetSPICLKFreq+0x528>
            spi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016530:	f7fd f99e 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016534:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34016536:	68fa      	ldr	r2, [r7, #12]
34016538:	68bb      	ldr	r3, [r7, #8]
3401653a:	fbb2 f3f3 	udiv	r3, r2, r3
3401653e:	60fb      	str	r3, [r7, #12]
            break;
34016540:	e01b      	b.n	3401657a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016542:	f7fd f9db 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016546:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
34016548:	68fa      	ldr	r2, [r7, #12]
3401654a:	68bb      	ldr	r3, [r7, #8]
3401654c:	fbb2 f3f3 	udiv	r3, r2, r3
34016550:	60fb      	str	r3, [r7, #12]
            break;
34016552:	e012      	b.n	3401657a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016554:	f7fd fa18 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34016558:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401655a:	68fa      	ldr	r2, [r7, #12]
3401655c:	68bb      	ldr	r3, [r7, #8]
3401655e:	fbb2 f3f3 	udiv	r3, r2, r3
34016562:	60fb      	str	r3, [r7, #12]
            break;
34016564:	e009      	b.n	3401657a <RCCEx_GetSPICLKFreq+0x52a>
            spi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016566:	f7fd fa55 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
3401656a:	60f8      	str	r0, [r7, #12]
            spi_frequency = spi_frequency / ic_divider;
3401656c:	68fa      	ldr	r2, [r7, #12]
3401656e:	68bb      	ldr	r3, [r7, #8]
34016570:	fbb2 f3f3 	udiv	r3, r2, r3
34016574:	60fb      	str	r3, [r7, #12]
            break;
34016576:	e000      	b.n	3401657a <RCCEx_GetSPICLKFreq+0x52a>
            break;
34016578:	bf00      	nop
        }
      }
      break;
3401657a:	e026      	b.n	340165ca <RCCEx_GetSPICLKFreq+0x57a>
    case LL_RCC_SPI2_CLKSOURCE_HSI:
    case LL_RCC_SPI3_CLKSOURCE_HSI:
    case LL_RCC_SPI4_CLKSOURCE_HSI:
    case LL_RCC_SPI5_CLKSOURCE_HSI:
    case LL_RCC_SPI6_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
3401657c:	f7f8 ff00 	bl	3400f380 <LL_RCC_HSI_IsReady>
34016580:	4603      	mov	r3, r0
34016582:	2b00      	cmp	r3, #0
34016584:	d023      	beq.n	340165ce <RCCEx_GetSPICLKFreq+0x57e>
      {
        spi_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34016586:	f7f8 ff0d 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
3401658a:	4603      	mov	r3, r0
3401658c:	09db      	lsrs	r3, r3, #7
3401658e:	4a15      	ldr	r2, [pc, #84]	@ (340165e4 <RCCEx_GetSPICLKFreq+0x594>)
34016590:	fa22 f303 	lsr.w	r3, r2, r3
34016594:	60fb      	str	r3, [r7, #12]
      }
      break;
34016596:	e01a      	b.n	340165ce <RCCEx_GetSPICLKFreq+0x57e>
    case LL_RCC_SPI2_CLKSOURCE_MSI:
    case LL_RCC_SPI3_CLKSOURCE_MSI:
    case LL_RCC_SPI4_CLKSOURCE_MSI:
    case LL_RCC_SPI5_CLKSOURCE_MSI:
    case LL_RCC_SPI6_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
34016598:	f7f8 ff12 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
3401659c:	4603      	mov	r3, r0
3401659e:	2b00      	cmp	r3, #0
340165a0:	d017      	beq.n	340165d2 <RCCEx_GetSPICLKFreq+0x582>
      {
        spi_frequency = MSI_VALUE;
340165a2:	4b11      	ldr	r3, [pc, #68]	@ (340165e8 <RCCEx_GetSPICLKFreq+0x598>)
340165a4:	60fb      	str	r3, [r7, #12]
      }
      break;
340165a6:	e014      	b.n	340165d2 <RCCEx_GetSPICLKFreq+0x582>

    case LL_RCC_SPI1_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI2_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI3_CLKSOURCE_I2S_CKIN:
    case LL_RCC_SPI6_CLKSOURCE_I2S_CKIN:
      spi_frequency = EXTERNAL_CLOCK_VALUE;
340165a8:	4b10      	ldr	r3, [pc, #64]	@ (340165ec <RCCEx_GetSPICLKFreq+0x59c>)
340165aa:	60fb      	str	r3, [r7, #12]
      break;
340165ac:	e014      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>

    case LL_RCC_SPI4_CLKSOURCE_HSE:
    case LL_RCC_SPI5_CLKSOURCE_HSE:
      if (LL_RCC_HSE_IsReady() != 0U)
340165ae:	f7f8 fed5 	bl	3400f35c <LL_RCC_HSE_IsReady>
340165b2:	4603      	mov	r3, r0
340165b4:	2b00      	cmp	r3, #0
340165b6:	d00e      	beq.n	340165d6 <RCCEx_GetSPICLKFreq+0x586>
      {
        spi_frequency = HSE_VALUE;
340165b8:	4b0d      	ldr	r3, [pc, #52]	@ (340165f0 <RCCEx_GetSPICLKFreq+0x5a0>)
340165ba:	60fb      	str	r3, [r7, #12]
      }
      break;
340165bc:	e00b      	b.n	340165d6 <RCCEx_GetSPICLKFreq+0x586>

    default:
      /* Unexpected case */
      break;
340165be:	bf00      	nop
340165c0:	e00a      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165c2:	bf00      	nop
340165c4:	e008      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165c6:	bf00      	nop
340165c8:	e006      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165ca:	bf00      	nop
340165cc:	e004      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165ce:	bf00      	nop
340165d0:	e002      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165d2:	bf00      	nop
340165d4:	e000      	b.n	340165d8 <RCCEx_GetSPICLKFreq+0x588>
      break;
340165d6:	bf00      	nop
  }

  return spi_frequency;
340165d8:	68fb      	ldr	r3, [r7, #12]
}
340165da:	4618      	mov	r0, r3
340165dc:	3710      	adds	r7, #16
340165de:	46bd      	mov	sp, r7
340165e0:	bd80      	pop	{r7, pc}
340165e2:	bf00      	nop
340165e4:	03d09000 	.word	0x03d09000
340165e8:	003d0900 	.word	0x003d0900
340165ec:	00bb8000 	.word	0x00bb8000
340165f0:	02dc6c00 	.word	0x02dc6c00

340165f4 <RCCEx_GetUARTCLKFreq>:
  *         @arg @ref RCCEx_UART9_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUARTCLKFreq(uint32_t UARTxSource)
{
340165f4:	b580      	push	{r7, lr}
340165f6:	b084      	sub	sp, #16
340165f8:	af00      	add	r7, sp, #0
340165fa:	6078      	str	r0, [r7, #4]
  uint32_t uart_frequency = RCC_PERIPH_FREQUENCY_NO;
340165fc:	2300      	movs	r3, #0
340165fe:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUARTClockSource(UARTxSource))
34016600:	6878      	ldr	r0, [r7, #4]
34016602:	f7f9 fab1 	bl	3400fb68 <LL_RCC_GetUARTClockSource>
34016606:	4603      	mov	r3, r0
34016608:	4aa2      	ldr	r2, [pc, #648]	@ (34016894 <RCCEx_GetUARTCLKFreq+0x2a0>)
3401660a:	4293      	cmp	r3, r2
3401660c:	f000 81e8 	beq.w	340169e0 <RCCEx_GetUARTCLKFreq+0x3ec>
34016610:	4aa0      	ldr	r2, [pc, #640]	@ (34016894 <RCCEx_GetUARTCLKFreq+0x2a0>)
34016612:	4293      	cmp	r3, r2
34016614:	f200 8203 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016618:	4a9f      	ldr	r2, [pc, #636]	@ (34016898 <RCCEx_GetUARTCLKFreq+0x2a4>)
3401661a:	4293      	cmp	r3, r2
3401661c:	f000 81e0 	beq.w	340169e0 <RCCEx_GetUARTCLKFreq+0x3ec>
34016620:	4a9d      	ldr	r2, [pc, #628]	@ (34016898 <RCCEx_GetUARTCLKFreq+0x2a4>)
34016622:	4293      	cmp	r3, r2
34016624:	f200 81fb 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016628:	4a9c      	ldr	r2, [pc, #624]	@ (3401689c <RCCEx_GetUARTCLKFreq+0x2a8>)
3401662a:	4293      	cmp	r3, r2
3401662c:	f000 81d8 	beq.w	340169e0 <RCCEx_GetUARTCLKFreq+0x3ec>
34016630:	4a9a      	ldr	r2, [pc, #616]	@ (3401689c <RCCEx_GetUARTCLKFreq+0x2a8>)
34016632:	4293      	cmp	r3, r2
34016634:	f200 81f3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016638:	4a99      	ldr	r2, [pc, #612]	@ (340168a0 <RCCEx_GetUARTCLKFreq+0x2ac>)
3401663a:	4293      	cmp	r3, r2
3401663c:	f000 81d0 	beq.w	340169e0 <RCCEx_GetUARTCLKFreq+0x3ec>
34016640:	4a97      	ldr	r2, [pc, #604]	@ (340168a0 <RCCEx_GetUARTCLKFreq+0x2ac>)
34016642:	4293      	cmp	r3, r2
34016644:	f200 81eb 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016648:	4a96      	ldr	r2, [pc, #600]	@ (340168a4 <RCCEx_GetUARTCLKFreq+0x2b0>)
3401664a:	4293      	cmp	r3, r2
3401664c:	f000 81c8 	beq.w	340169e0 <RCCEx_GetUARTCLKFreq+0x3ec>
34016650:	4a94      	ldr	r2, [pc, #592]	@ (340168a4 <RCCEx_GetUARTCLKFreq+0x2b0>)
34016652:	4293      	cmp	r3, r2
34016654:	f200 81e3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016658:	4a93      	ldr	r2, [pc, #588]	@ (340168a8 <RCCEx_GetUARTCLKFreq+0x2b4>)
3401665a:	4293      	cmp	r3, r2
3401665c:	f000 81ce 	beq.w	340169fc <RCCEx_GetUARTCLKFreq+0x408>
34016660:	4a91      	ldr	r2, [pc, #580]	@ (340168a8 <RCCEx_GetUARTCLKFreq+0x2b4>)
34016662:	4293      	cmp	r3, r2
34016664:	f200 81db 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016668:	4a90      	ldr	r2, [pc, #576]	@ (340168ac <RCCEx_GetUARTCLKFreq+0x2b8>)
3401666a:	4293      	cmp	r3, r2
3401666c:	f000 81c6 	beq.w	340169fc <RCCEx_GetUARTCLKFreq+0x408>
34016670:	4a8e      	ldr	r2, [pc, #568]	@ (340168ac <RCCEx_GetUARTCLKFreq+0x2b8>)
34016672:	4293      	cmp	r3, r2
34016674:	f200 81d3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016678:	4a8d      	ldr	r2, [pc, #564]	@ (340168b0 <RCCEx_GetUARTCLKFreq+0x2bc>)
3401667a:	4293      	cmp	r3, r2
3401667c:	f000 81be 	beq.w	340169fc <RCCEx_GetUARTCLKFreq+0x408>
34016680:	4a8b      	ldr	r2, [pc, #556]	@ (340168b0 <RCCEx_GetUARTCLKFreq+0x2bc>)
34016682:	4293      	cmp	r3, r2
34016684:	f200 81cb 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016688:	4a8a      	ldr	r2, [pc, #552]	@ (340168b4 <RCCEx_GetUARTCLKFreq+0x2c0>)
3401668a:	4293      	cmp	r3, r2
3401668c:	f000 81b6 	beq.w	340169fc <RCCEx_GetUARTCLKFreq+0x408>
34016690:	4a88      	ldr	r2, [pc, #544]	@ (340168b4 <RCCEx_GetUARTCLKFreq+0x2c0>)
34016692:	4293      	cmp	r3, r2
34016694:	f200 81c3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016698:	4a87      	ldr	r2, [pc, #540]	@ (340168b8 <RCCEx_GetUARTCLKFreq+0x2c4>)
3401669a:	4293      	cmp	r3, r2
3401669c:	f000 81ae 	beq.w	340169fc <RCCEx_GetUARTCLKFreq+0x408>
340166a0:	4a85      	ldr	r2, [pc, #532]	@ (340168b8 <RCCEx_GetUARTCLKFreq+0x2c4>)
340166a2:	4293      	cmp	r3, r2
340166a4:	f200 81bb 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166a8:	4a84      	ldr	r2, [pc, #528]	@ (340168bc <RCCEx_GetUARTCLKFreq+0x2c8>)
340166aa:	4293      	cmp	r3, r2
340166ac:	f000 81ae 	beq.w	34016a0c <RCCEx_GetUARTCLKFreq+0x418>
340166b0:	4a82      	ldr	r2, [pc, #520]	@ (340168bc <RCCEx_GetUARTCLKFreq+0x2c8>)
340166b2:	4293      	cmp	r3, r2
340166b4:	f200 81b3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166b8:	4a81      	ldr	r2, [pc, #516]	@ (340168c0 <RCCEx_GetUARTCLKFreq+0x2cc>)
340166ba:	4293      	cmp	r3, r2
340166bc:	f000 81a6 	beq.w	34016a0c <RCCEx_GetUARTCLKFreq+0x418>
340166c0:	4a7f      	ldr	r2, [pc, #508]	@ (340168c0 <RCCEx_GetUARTCLKFreq+0x2cc>)
340166c2:	4293      	cmp	r3, r2
340166c4:	f200 81ab 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166c8:	4a7e      	ldr	r2, [pc, #504]	@ (340168c4 <RCCEx_GetUARTCLKFreq+0x2d0>)
340166ca:	4293      	cmp	r3, r2
340166cc:	f000 819e 	beq.w	34016a0c <RCCEx_GetUARTCLKFreq+0x418>
340166d0:	4a7c      	ldr	r2, [pc, #496]	@ (340168c4 <RCCEx_GetUARTCLKFreq+0x2d0>)
340166d2:	4293      	cmp	r3, r2
340166d4:	f200 81a3 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166d8:	4a7b      	ldr	r2, [pc, #492]	@ (340168c8 <RCCEx_GetUARTCLKFreq+0x2d4>)
340166da:	4293      	cmp	r3, r2
340166dc:	f000 8196 	beq.w	34016a0c <RCCEx_GetUARTCLKFreq+0x418>
340166e0:	4a79      	ldr	r2, [pc, #484]	@ (340168c8 <RCCEx_GetUARTCLKFreq+0x2d4>)
340166e2:	4293      	cmp	r3, r2
340166e4:	f200 819b 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166e8:	4a78      	ldr	r2, [pc, #480]	@ (340168cc <RCCEx_GetUARTCLKFreq+0x2d8>)
340166ea:	4293      	cmp	r3, r2
340166ec:	f000 818e 	beq.w	34016a0c <RCCEx_GetUARTCLKFreq+0x418>
340166f0:	4a76      	ldr	r2, [pc, #472]	@ (340168cc <RCCEx_GetUARTCLKFreq+0x2d8>)
340166f2:	4293      	cmp	r3, r2
340166f4:	f200 8193 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340166f8:	4a75      	ldr	r2, [pc, #468]	@ (340168d0 <RCCEx_GetUARTCLKFreq+0x2dc>)
340166fa:	4293      	cmp	r3, r2
340166fc:	f000 812d 	beq.w	3401695a <RCCEx_GetUARTCLKFreq+0x366>
34016700:	4a73      	ldr	r2, [pc, #460]	@ (340168d0 <RCCEx_GetUARTCLKFreq+0x2dc>)
34016702:	4293      	cmp	r3, r2
34016704:	f200 818b 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016708:	4a72      	ldr	r2, [pc, #456]	@ (340168d4 <RCCEx_GetUARTCLKFreq+0x2e0>)
3401670a:	4293      	cmp	r3, r2
3401670c:	f000 8125 	beq.w	3401695a <RCCEx_GetUARTCLKFreq+0x366>
34016710:	4a70      	ldr	r2, [pc, #448]	@ (340168d4 <RCCEx_GetUARTCLKFreq+0x2e0>)
34016712:	4293      	cmp	r3, r2
34016714:	f200 8183 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016718:	4a6f      	ldr	r2, [pc, #444]	@ (340168d8 <RCCEx_GetUARTCLKFreq+0x2e4>)
3401671a:	4293      	cmp	r3, r2
3401671c:	f000 811d 	beq.w	3401695a <RCCEx_GetUARTCLKFreq+0x366>
34016720:	4a6d      	ldr	r2, [pc, #436]	@ (340168d8 <RCCEx_GetUARTCLKFreq+0x2e4>)
34016722:	4293      	cmp	r3, r2
34016724:	f200 817b 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016728:	4a6c      	ldr	r2, [pc, #432]	@ (340168dc <RCCEx_GetUARTCLKFreq+0x2e8>)
3401672a:	4293      	cmp	r3, r2
3401672c:	f000 8115 	beq.w	3401695a <RCCEx_GetUARTCLKFreq+0x366>
34016730:	4a6a      	ldr	r2, [pc, #424]	@ (340168dc <RCCEx_GetUARTCLKFreq+0x2e8>)
34016732:	4293      	cmp	r3, r2
34016734:	f200 8173 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016738:	4a69      	ldr	r2, [pc, #420]	@ (340168e0 <RCCEx_GetUARTCLKFreq+0x2ec>)
3401673a:	4293      	cmp	r3, r2
3401673c:	f000 810d 	beq.w	3401695a <RCCEx_GetUARTCLKFreq+0x366>
34016740:	4a67      	ldr	r2, [pc, #412]	@ (340168e0 <RCCEx_GetUARTCLKFreq+0x2ec>)
34016742:	4293      	cmp	r3, r2
34016744:	f200 816b 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016748:	4a66      	ldr	r2, [pc, #408]	@ (340168e4 <RCCEx_GetUARTCLKFreq+0x2f0>)
3401674a:	4293      	cmp	r3, r2
3401674c:	d07b      	beq.n	34016846 <RCCEx_GetUARTCLKFreq+0x252>
3401674e:	4a65      	ldr	r2, [pc, #404]	@ (340168e4 <RCCEx_GetUARTCLKFreq+0x2f0>)
34016750:	4293      	cmp	r3, r2
34016752:	f200 8164 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016756:	4a64      	ldr	r2, [pc, #400]	@ (340168e8 <RCCEx_GetUARTCLKFreq+0x2f4>)
34016758:	4293      	cmp	r3, r2
3401675a:	d074      	beq.n	34016846 <RCCEx_GetUARTCLKFreq+0x252>
3401675c:	4a62      	ldr	r2, [pc, #392]	@ (340168e8 <RCCEx_GetUARTCLKFreq+0x2f4>)
3401675e:	4293      	cmp	r3, r2
34016760:	f200 815d 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016764:	4a61      	ldr	r2, [pc, #388]	@ (340168ec <RCCEx_GetUARTCLKFreq+0x2f8>)
34016766:	4293      	cmp	r3, r2
34016768:	d06d      	beq.n	34016846 <RCCEx_GetUARTCLKFreq+0x252>
3401676a:	4a60      	ldr	r2, [pc, #384]	@ (340168ec <RCCEx_GetUARTCLKFreq+0x2f8>)
3401676c:	4293      	cmp	r3, r2
3401676e:	f200 8156 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016772:	4a5f      	ldr	r2, [pc, #380]	@ (340168f0 <RCCEx_GetUARTCLKFreq+0x2fc>)
34016774:	4293      	cmp	r3, r2
34016776:	d066      	beq.n	34016846 <RCCEx_GetUARTCLKFreq+0x252>
34016778:	4a5d      	ldr	r2, [pc, #372]	@ (340168f0 <RCCEx_GetUARTCLKFreq+0x2fc>)
3401677a:	4293      	cmp	r3, r2
3401677c:	f200 814f 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
34016780:	4a5c      	ldr	r2, [pc, #368]	@ (340168f4 <RCCEx_GetUARTCLKFreq+0x300>)
34016782:	4293      	cmp	r3, r2
34016784:	d05f      	beq.n	34016846 <RCCEx_GetUARTCLKFreq+0x252>
34016786:	4a5b      	ldr	r2, [pc, #364]	@ (340168f4 <RCCEx_GetUARTCLKFreq+0x300>)
34016788:	4293      	cmp	r3, r2
3401678a:	f200 8148 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
3401678e:	4a5a      	ldr	r2, [pc, #360]	@ (340168f8 <RCCEx_GetUARTCLKFreq+0x304>)
34016790:	4293      	cmp	r3, r2
34016792:	d053      	beq.n	3401683c <RCCEx_GetUARTCLKFreq+0x248>
34016794:	4a58      	ldr	r2, [pc, #352]	@ (340168f8 <RCCEx_GetUARTCLKFreq+0x304>)
34016796:	4293      	cmp	r3, r2
34016798:	f200 8141 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
3401679c:	4a57      	ldr	r2, [pc, #348]	@ (340168fc <RCCEx_GetUARTCLKFreq+0x308>)
3401679e:	4293      	cmp	r3, r2
340167a0:	d04c      	beq.n	3401683c <RCCEx_GetUARTCLKFreq+0x248>
340167a2:	4a56      	ldr	r2, [pc, #344]	@ (340168fc <RCCEx_GetUARTCLKFreq+0x308>)
340167a4:	4293      	cmp	r3, r2
340167a6:	f200 813a 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167aa:	4a55      	ldr	r2, [pc, #340]	@ (34016900 <RCCEx_GetUARTCLKFreq+0x30c>)
340167ac:	4293      	cmp	r3, r2
340167ae:	d045      	beq.n	3401683c <RCCEx_GetUARTCLKFreq+0x248>
340167b0:	4a53      	ldr	r2, [pc, #332]	@ (34016900 <RCCEx_GetUARTCLKFreq+0x30c>)
340167b2:	4293      	cmp	r3, r2
340167b4:	f200 8133 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167b8:	4a52      	ldr	r2, [pc, #328]	@ (34016904 <RCCEx_GetUARTCLKFreq+0x310>)
340167ba:	4293      	cmp	r3, r2
340167bc:	d03e      	beq.n	3401683c <RCCEx_GetUARTCLKFreq+0x248>
340167be:	4a51      	ldr	r2, [pc, #324]	@ (34016904 <RCCEx_GetUARTCLKFreq+0x310>)
340167c0:	4293      	cmp	r3, r2
340167c2:	f200 812c 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167c6:	4a50      	ldr	r2, [pc, #320]	@ (34016908 <RCCEx_GetUARTCLKFreq+0x314>)
340167c8:	4293      	cmp	r3, r2
340167ca:	d037      	beq.n	3401683c <RCCEx_GetUARTCLKFreq+0x248>
340167cc:	4a4e      	ldr	r2, [pc, #312]	@ (34016908 <RCCEx_GetUARTCLKFreq+0x314>)
340167ce:	4293      	cmp	r3, r2
340167d0:	f200 8125 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167d4:	4a4d      	ldr	r2, [pc, #308]	@ (3401690c <RCCEx_GetUARTCLKFreq+0x318>)
340167d6:	4293      	cmp	r3, r2
340167d8:	d018      	beq.n	3401680c <RCCEx_GetUARTCLKFreq+0x218>
340167da:	4a4c      	ldr	r2, [pc, #304]	@ (3401690c <RCCEx_GetUARTCLKFreq+0x318>)
340167dc:	4293      	cmp	r3, r2
340167de:	f200 811e 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167e2:	4a4b      	ldr	r2, [pc, #300]	@ (34016910 <RCCEx_GetUARTCLKFreq+0x31c>)
340167e4:	4293      	cmp	r3, r2
340167e6:	d011      	beq.n	3401680c <RCCEx_GetUARTCLKFreq+0x218>
340167e8:	4a49      	ldr	r2, [pc, #292]	@ (34016910 <RCCEx_GetUARTCLKFreq+0x31c>)
340167ea:	4293      	cmp	r3, r2
340167ec:	f200 8117 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167f0:	4a48      	ldr	r2, [pc, #288]	@ (34016914 <RCCEx_GetUARTCLKFreq+0x320>)
340167f2:	4293      	cmp	r3, r2
340167f4:	d00a      	beq.n	3401680c <RCCEx_GetUARTCLKFreq+0x218>
340167f6:	4a47      	ldr	r2, [pc, #284]	@ (34016914 <RCCEx_GetUARTCLKFreq+0x320>)
340167f8:	4293      	cmp	r3, r2
340167fa:	f200 8110 	bhi.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
340167fe:	4a46      	ldr	r2, [pc, #280]	@ (34016918 <RCCEx_GetUARTCLKFreq+0x324>)
34016800:	4293      	cmp	r3, r2
34016802:	d00f      	beq.n	34016824 <RCCEx_GetUARTCLKFreq+0x230>
34016804:	4a45      	ldr	r2, [pc, #276]	@ (3401691c <RCCEx_GetUARTCLKFreq+0x328>)
34016806:	4293      	cmp	r3, r2
34016808:	f040 8109 	bne.w	34016a1e <RCCEx_GetUARTCLKFreq+0x42a>
  {
    case LL_RCC_UART4_CLKSOURCE_PCLK1:
    case LL_RCC_UART5_CLKSOURCE_PCLK1:
    case LL_RCC_UART7_CLKSOURCE_PCLK1:
    case LL_RCC_UART8_CLKSOURCE_PCLK1:
      uart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
3401680c:	f7f8 f9b8 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34016810:	4603      	mov	r3, r0
34016812:	4618      	mov	r0, r3
34016814:	f7fd f944 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34016818:	4603      	mov	r3, r0
3401681a:	4618      	mov	r0, r3
3401681c:	f7fd f951 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34016820:	60f8      	str	r0, [r7, #12]
      break;
34016822:	e107      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>

    case LL_RCC_UART9_CLKSOURCE_PCLK2:
      uart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016824:	f7f8 f9ac 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34016828:	4603      	mov	r3, r0
3401682a:	4618      	mov	r0, r3
3401682c:	f7fd f938 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34016830:	4603      	mov	r3, r0
34016832:	4618      	mov	r0, r3
34016834:	f7fd f955 	bl	34013ae2 <RCCEx_GetPCLK2Freq>
34016838:	60f8      	str	r0, [r7, #12]
      break;
3401683a:	e0fb      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_CLKP:
    case LL_RCC_UART5_CLKSOURCE_CLKP:
    case LL_RCC_UART7_CLKSOURCE_CLKP:
    case LL_RCC_UART8_CLKSOURCE_CLKP:
    case LL_RCC_UART9_CLKSOURCE_CLKP:
      uart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401683c:	2007      	movs	r0, #7
3401683e:	f7fd fc1b 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34016842:	60f8      	str	r0, [r7, #12]
      break;
34016844:	e0f6      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
    case LL_RCC_UART4_CLKSOURCE_IC9:
    case LL_RCC_UART5_CLKSOURCE_IC9:
    case LL_RCC_UART7_CLKSOURCE_IC9:
    case LL_RCC_UART8_CLKSOURCE_IC9:
    case LL_RCC_UART9_CLKSOURCE_IC9:
      if (LL_RCC_IC9_IsEnabled() != 0U)
34016846:	f7f9 fdbf 	bl	340103c8 <LL_RCC_IC9_IsEnabled>
3401684a:	4603      	mov	r3, r0
3401684c:	2b00      	cmp	r3, #0
3401684e:	f000 80e8 	beq.w	34016a22 <RCCEx_GetUARTCLKFreq+0x42e>
      {
        ic_divider = LL_RCC_IC9_GetDivider();
34016852:	f7f9 fddb 	bl	3401040c <LL_RCC_IC9_GetDivider>
34016856:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34016858:	f7f9 fdca 	bl	340103f0 <LL_RCC_IC9_GetSource>
3401685c:	4603      	mov	r3, r0
3401685e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016862:	d06f      	beq.n	34016944 <RCCEx_GetUARTCLKFreq+0x350>
34016864:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016868:	d875      	bhi.n	34016956 <RCCEx_GetUARTCLKFreq+0x362>
3401686a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401686e:	d060      	beq.n	34016932 <RCCEx_GetUARTCLKFreq+0x33e>
34016870:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016874:	d86f      	bhi.n	34016956 <RCCEx_GetUARTCLKFreq+0x362>
34016876:	2b00      	cmp	r3, #0
34016878:	d003      	beq.n	34016882 <RCCEx_GetUARTCLKFreq+0x28e>
3401687a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
3401687e:	d04f      	beq.n	34016920 <RCCEx_GetUARTCLKFreq+0x32c>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016880:	e069      	b.n	34016956 <RCCEx_GetUARTCLKFreq+0x362>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016882:	f7fc fff5 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016886:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34016888:	68fa      	ldr	r2, [r7, #12]
3401688a:	68bb      	ldr	r3, [r7, #8]
3401688c:	fbb2 f3f3 	udiv	r3, r2, r3
34016890:	60fb      	str	r3, [r7, #12]
            break;
34016892:	e061      	b.n	34016958 <RCCEx_GetUARTCLKFreq+0x364>
34016894:	07061c30 	.word	0x07061c30
34016898:	07061830 	.word	0x07061830
3401689c:	07061030 	.word	0x07061030
340168a0:	07060c30 	.word	0x07060c30
340168a4:	07060034 	.word	0x07060034
340168a8:	07051c30 	.word	0x07051c30
340168ac:	07051830 	.word	0x07051830
340168b0:	07051030 	.word	0x07051030
340168b4:	07050c30 	.word	0x07050c30
340168b8:	07050034 	.word	0x07050034
340168bc:	07041c30 	.word	0x07041c30
340168c0:	07041830 	.word	0x07041830
340168c4:	07041030 	.word	0x07041030
340168c8:	07040c30 	.word	0x07040c30
340168cc:	07040034 	.word	0x07040034
340168d0:	07031c30 	.word	0x07031c30
340168d4:	07031830 	.word	0x07031830
340168d8:	07031030 	.word	0x07031030
340168dc:	07030c30 	.word	0x07030c30
340168e0:	07030034 	.word	0x07030034
340168e4:	07021c30 	.word	0x07021c30
340168e8:	07021830 	.word	0x07021830
340168ec:	07021030 	.word	0x07021030
340168f0:	07020c30 	.word	0x07020c30
340168f4:	07020034 	.word	0x07020034
340168f8:	07011c30 	.word	0x07011c30
340168fc:	07011830 	.word	0x07011830
34016900:	07011030 	.word	0x07011030
34016904:	07010c30 	.word	0x07010c30
34016908:	07010034 	.word	0x07010034
3401690c:	07001c30 	.word	0x07001c30
34016910:	07001830 	.word	0x07001830
34016914:	07001030 	.word	0x07001030
34016918:	07000034 	.word	0x07000034
3401691c:	07000c30 	.word	0x07000c30
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016920:	f7fc ffec 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016924:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34016926:	68fa      	ldr	r2, [r7, #12]
34016928:	68bb      	ldr	r3, [r7, #8]
3401692a:	fbb2 f3f3 	udiv	r3, r2, r3
3401692e:	60fb      	str	r3, [r7, #12]
            break;
34016930:	e012      	b.n	34016958 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016932:	f7fd f829 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34016936:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
34016938:	68fa      	ldr	r2, [r7, #12]
3401693a:	68bb      	ldr	r3, [r7, #8]
3401693c:	fbb2 f3f3 	udiv	r3, r2, r3
34016940:	60fb      	str	r3, [r7, #12]
            break;
34016942:	e009      	b.n	34016958 <RCCEx_GetUARTCLKFreq+0x364>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016944:	f7fd f866 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34016948:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3401694a:	68fa      	ldr	r2, [r7, #12]
3401694c:	68bb      	ldr	r3, [r7, #8]
3401694e:	fbb2 f3f3 	udiv	r3, r2, r3
34016952:	60fb      	str	r3, [r7, #12]
            break;
34016954:	e000      	b.n	34016958 <RCCEx_GetUARTCLKFreq+0x364>
            break;
34016956:	bf00      	nop
        }
      }
      break;
34016958:	e063      	b.n	34016a22 <RCCEx_GetUARTCLKFreq+0x42e>
    case LL_RCC_UART4_CLKSOURCE_IC14:
    case LL_RCC_UART5_CLKSOURCE_IC14:
    case LL_RCC_UART7_CLKSOURCE_IC14:
    case LL_RCC_UART8_CLKSOURCE_IC14:
    case LL_RCC_UART9_CLKSOURCE_IC14:
      if (LL_RCC_IC14_IsEnabled() != 0U)
3401695a:	f7f9 fe35 	bl	340105c8 <LL_RCC_IC14_IsEnabled>
3401695e:	4603      	mov	r3, r0
34016960:	2b00      	cmp	r3, #0
34016962:	d060      	beq.n	34016a26 <RCCEx_GetUARTCLKFreq+0x432>
      {
        ic_divider = LL_RCC_IC14_GetDivider();
34016964:	f7f9 fe52 	bl	3401060c <LL_RCC_IC14_GetDivider>
34016968:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
3401696a:	f7f9 fe41 	bl	340105f0 <LL_RCC_IC14_GetSource>
3401696e:	4603      	mov	r3, r0
34016970:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016974:	d029      	beq.n	340169ca <RCCEx_GetUARTCLKFreq+0x3d6>
34016976:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401697a:	d82f      	bhi.n	340169dc <RCCEx_GetUARTCLKFreq+0x3e8>
3401697c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016980:	d01a      	beq.n	340169b8 <RCCEx_GetUARTCLKFreq+0x3c4>
34016982:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016986:	d829      	bhi.n	340169dc <RCCEx_GetUARTCLKFreq+0x3e8>
34016988:	2b00      	cmp	r3, #0
3401698a:	d003      	beq.n	34016994 <RCCEx_GetUARTCLKFreq+0x3a0>
3401698c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016990:	d009      	beq.n	340169a6 <RCCEx_GetUARTCLKFreq+0x3b2>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            uart_frequency = uart_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34016992:	e023      	b.n	340169dc <RCCEx_GetUARTCLKFreq+0x3e8>
            uart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016994:	f7fc ff6c 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016998:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
3401699a:	68fa      	ldr	r2, [r7, #12]
3401699c:	68bb      	ldr	r3, [r7, #8]
3401699e:	fbb2 f3f3 	udiv	r3, r2, r3
340169a2:	60fb      	str	r3, [r7, #12]
            break;
340169a4:	e01b      	b.n	340169de <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340169a6:	f7fc ffa9 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340169aa:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
340169ac:	68fa      	ldr	r2, [r7, #12]
340169ae:	68bb      	ldr	r3, [r7, #8]
340169b0:	fbb2 f3f3 	udiv	r3, r2, r3
340169b4:	60fb      	str	r3, [r7, #12]
            break;
340169b6:	e012      	b.n	340169de <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340169b8:	f7fc ffe6 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340169bc:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
340169be:	68fa      	ldr	r2, [r7, #12]
340169c0:	68bb      	ldr	r3, [r7, #8]
340169c2:	fbb2 f3f3 	udiv	r3, r2, r3
340169c6:	60fb      	str	r3, [r7, #12]
            break;
340169c8:	e009      	b.n	340169de <RCCEx_GetUARTCLKFreq+0x3ea>
            uart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340169ca:	f7fd f823 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340169ce:	60f8      	str	r0, [r7, #12]
            uart_frequency = uart_frequency / ic_divider;
340169d0:	68fa      	ldr	r2, [r7, #12]
340169d2:	68bb      	ldr	r3, [r7, #8]
340169d4:	fbb2 f3f3 	udiv	r3, r2, r3
340169d8:	60fb      	str	r3, [r7, #12]
            break;
340169da:	e000      	b.n	340169de <RCCEx_GetUARTCLKFreq+0x3ea>
            break;
340169dc:	bf00      	nop
        }
      }
      break;
340169de:	e022      	b.n	34016a26 <RCCEx_GetUARTCLKFreq+0x432>
    case LL_RCC_UART4_CLKSOURCE_HSI:
    case LL_RCC_UART5_CLKSOURCE_HSI:
    case LL_RCC_UART7_CLKSOURCE_HSI:
    case LL_RCC_UART8_CLKSOURCE_HSI:
    case LL_RCC_UART9_CLKSOURCE_HSI:
      if (LL_RCC_HSI_IsReady() != 0U)
340169e0:	f7f8 fcce 	bl	3400f380 <LL_RCC_HSI_IsReady>
340169e4:	4603      	mov	r3, r0
340169e6:	2b00      	cmp	r3, #0
340169e8:	d01f      	beq.n	34016a2a <RCCEx_GetUARTCLKFreq+0x436>
      {
        uart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
340169ea:	f7f8 fcdb 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
340169ee:	4603      	mov	r3, r0
340169f0:	09db      	lsrs	r3, r3, #7
340169f2:	4a13      	ldr	r2, [pc, #76]	@ (34016a40 <RCCEx_GetUARTCLKFreq+0x44c>)
340169f4:	fa22 f303 	lsr.w	r3, r2, r3
340169f8:	60fb      	str	r3, [r7, #12]
      }
      break;
340169fa:	e016      	b.n	34016a2a <RCCEx_GetUARTCLKFreq+0x436>
    case LL_RCC_UART4_CLKSOURCE_MSI:
    case LL_RCC_UART5_CLKSOURCE_MSI:
    case LL_RCC_UART7_CLKSOURCE_MSI:
    case LL_RCC_UART8_CLKSOURCE_MSI:
    case LL_RCC_UART9_CLKSOURCE_MSI:
      if (LL_RCC_MSI_IsReady() != 0U)
340169fc:	f7f8 fce0 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34016a00:	4603      	mov	r3, r0
34016a02:	2b00      	cmp	r3, #0
34016a04:	d013      	beq.n	34016a2e <RCCEx_GetUARTCLKFreq+0x43a>
      {
        uart_frequency = MSI_VALUE;
34016a06:	4b0f      	ldr	r3, [pc, #60]	@ (34016a44 <RCCEx_GetUARTCLKFreq+0x450>)
34016a08:	60fb      	str	r3, [r7, #12]
      }
      break;
34016a0a:	e010      	b.n	34016a2e <RCCEx_GetUARTCLKFreq+0x43a>
    case LL_RCC_UART4_CLKSOURCE_LSE:
    case LL_RCC_UART5_CLKSOURCE_LSE:
    case LL_RCC_UART7_CLKSOURCE_LSE:
    case LL_RCC_UART8_CLKSOURCE_LSE:
    case LL_RCC_UART9_CLKSOURCE_LSE:
      if (LL_RCC_LSE_IsReady() != 0U)
34016a0c:	f7f8 fcf8 	bl	3400f400 <LL_RCC_LSE_IsReady>
34016a10:	4603      	mov	r3, r0
34016a12:	2b00      	cmp	r3, #0
34016a14:	d00d      	beq.n	34016a32 <RCCEx_GetUARTCLKFreq+0x43e>
      {
        uart_frequency = LSE_VALUE;
34016a16:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34016a1a:	60fb      	str	r3, [r7, #12]
      }
      break;
34016a1c:	e009      	b.n	34016a32 <RCCEx_GetUARTCLKFreq+0x43e>

    default:
      /* Unexpected case */
      break;
34016a1e:	bf00      	nop
34016a20:	e008      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34016a22:	bf00      	nop
34016a24:	e006      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34016a26:	bf00      	nop
34016a28:	e004      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34016a2a:	bf00      	nop
34016a2c:	e002      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34016a2e:	bf00      	nop
34016a30:	e000      	b.n	34016a34 <RCCEx_GetUARTCLKFreq+0x440>
      break;
34016a32:	bf00      	nop
  }

  return uart_frequency;
34016a34:	68fb      	ldr	r3, [r7, #12]
}
34016a36:	4618      	mov	r0, r3
34016a38:	3710      	adds	r7, #16
34016a3a:	46bd      	mov	sp, r7
34016a3c:	bd80      	pop	{r7, pc}
34016a3e:	bf00      	nop
34016a40:	03d09000 	.word	0x03d09000
34016a44:	003d0900 	.word	0x003d0900

34016a48 <RCCEx_GetUSARTCLKFreq>:
  *         @arg @ref RCCEx_USART10_Clock_Source
  * @retval USART clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */
static uint32_t RCCEx_GetUSARTCLKFreq(uint32_t USARTxSource)
{
34016a48:	b580      	push	{r7, lr}
34016a4a:	b084      	sub	sp, #16
34016a4c:	af00      	add	r7, sp, #0
34016a4e:	6078      	str	r0, [r7, #4]
  uint32_t usart_frequency = RCC_PERIPH_FREQUENCY_NO;
34016a50:	2300      	movs	r3, #0
34016a52:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetUSARTClockSource(USARTxSource))
34016a54:	6878      	ldr	r0, [r7, #4]
34016a56:	f7f9 f87b 	bl	3400fb50 <LL_RCC_GetUSARTClockSource>
34016a5a:	4603      	mov	r3, r0
34016a5c:	4aa2      	ldr	r2, [pc, #648]	@ (34016ce8 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34016a5e:	4293      	cmp	r3, r2
34016a60:	f000 81e8 	beq.w	34016e34 <RCCEx_GetUSARTCLKFreq+0x3ec>
34016a64:	4aa0      	ldr	r2, [pc, #640]	@ (34016ce8 <RCCEx_GetUSARTCLKFreq+0x2a0>)
34016a66:	4293      	cmp	r3, r2
34016a68:	f200 8203 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016a6c:	4a9f      	ldr	r2, [pc, #636]	@ (34016cec <RCCEx_GetUSARTCLKFreq+0x2a4>)
34016a6e:	4293      	cmp	r3, r2
34016a70:	f000 81e0 	beq.w	34016e34 <RCCEx_GetUSARTCLKFreq+0x3ec>
34016a74:	4a9d      	ldr	r2, [pc, #628]	@ (34016cec <RCCEx_GetUSARTCLKFreq+0x2a4>)
34016a76:	4293      	cmp	r3, r2
34016a78:	f200 81fb 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016a7c:	4a9c      	ldr	r2, [pc, #624]	@ (34016cf0 <RCCEx_GetUSARTCLKFreq+0x2a8>)
34016a7e:	4293      	cmp	r3, r2
34016a80:	f000 81d8 	beq.w	34016e34 <RCCEx_GetUSARTCLKFreq+0x3ec>
34016a84:	4a9a      	ldr	r2, [pc, #616]	@ (34016cf0 <RCCEx_GetUSARTCLKFreq+0x2a8>)
34016a86:	4293      	cmp	r3, r2
34016a88:	f200 81f3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016a8c:	4a99      	ldr	r2, [pc, #612]	@ (34016cf4 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34016a8e:	4293      	cmp	r3, r2
34016a90:	f000 81d0 	beq.w	34016e34 <RCCEx_GetUSARTCLKFreq+0x3ec>
34016a94:	4a97      	ldr	r2, [pc, #604]	@ (34016cf4 <RCCEx_GetUSARTCLKFreq+0x2ac>)
34016a96:	4293      	cmp	r3, r2
34016a98:	f200 81eb 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016a9c:	4a96      	ldr	r2, [pc, #600]	@ (34016cf8 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34016a9e:	4293      	cmp	r3, r2
34016aa0:	f000 81c8 	beq.w	34016e34 <RCCEx_GetUSARTCLKFreq+0x3ec>
34016aa4:	4a94      	ldr	r2, [pc, #592]	@ (34016cf8 <RCCEx_GetUSARTCLKFreq+0x2b0>)
34016aa6:	4293      	cmp	r3, r2
34016aa8:	f200 81e3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016aac:	4a93      	ldr	r2, [pc, #588]	@ (34016cfc <RCCEx_GetUSARTCLKFreq+0x2b4>)
34016aae:	4293      	cmp	r3, r2
34016ab0:	f000 81ce 	beq.w	34016e50 <RCCEx_GetUSARTCLKFreq+0x408>
34016ab4:	4a91      	ldr	r2, [pc, #580]	@ (34016cfc <RCCEx_GetUSARTCLKFreq+0x2b4>)
34016ab6:	4293      	cmp	r3, r2
34016ab8:	f200 81db 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016abc:	4a90      	ldr	r2, [pc, #576]	@ (34016d00 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34016abe:	4293      	cmp	r3, r2
34016ac0:	f000 81c6 	beq.w	34016e50 <RCCEx_GetUSARTCLKFreq+0x408>
34016ac4:	4a8e      	ldr	r2, [pc, #568]	@ (34016d00 <RCCEx_GetUSARTCLKFreq+0x2b8>)
34016ac6:	4293      	cmp	r3, r2
34016ac8:	f200 81d3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016acc:	4a8d      	ldr	r2, [pc, #564]	@ (34016d04 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34016ace:	4293      	cmp	r3, r2
34016ad0:	f000 81be 	beq.w	34016e50 <RCCEx_GetUSARTCLKFreq+0x408>
34016ad4:	4a8b      	ldr	r2, [pc, #556]	@ (34016d04 <RCCEx_GetUSARTCLKFreq+0x2bc>)
34016ad6:	4293      	cmp	r3, r2
34016ad8:	f200 81cb 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016adc:	4a8a      	ldr	r2, [pc, #552]	@ (34016d08 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34016ade:	4293      	cmp	r3, r2
34016ae0:	f000 81b6 	beq.w	34016e50 <RCCEx_GetUSARTCLKFreq+0x408>
34016ae4:	4a88      	ldr	r2, [pc, #544]	@ (34016d08 <RCCEx_GetUSARTCLKFreq+0x2c0>)
34016ae6:	4293      	cmp	r3, r2
34016ae8:	f200 81c3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016aec:	4a87      	ldr	r2, [pc, #540]	@ (34016d0c <RCCEx_GetUSARTCLKFreq+0x2c4>)
34016aee:	4293      	cmp	r3, r2
34016af0:	f000 81ae 	beq.w	34016e50 <RCCEx_GetUSARTCLKFreq+0x408>
34016af4:	4a85      	ldr	r2, [pc, #532]	@ (34016d0c <RCCEx_GetUSARTCLKFreq+0x2c4>)
34016af6:	4293      	cmp	r3, r2
34016af8:	f200 81bb 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016afc:	4a84      	ldr	r2, [pc, #528]	@ (34016d10 <RCCEx_GetUSARTCLKFreq+0x2c8>)
34016afe:	4293      	cmp	r3, r2
34016b00:	f000 81ae 	beq.w	34016e60 <RCCEx_GetUSARTCLKFreq+0x418>
34016b04:	4a82      	ldr	r2, [pc, #520]	@ (34016d10 <RCCEx_GetUSARTCLKFreq+0x2c8>)
34016b06:	4293      	cmp	r3, r2
34016b08:	f200 81b3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b0c:	4a81      	ldr	r2, [pc, #516]	@ (34016d14 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34016b0e:	4293      	cmp	r3, r2
34016b10:	f000 81a6 	beq.w	34016e60 <RCCEx_GetUSARTCLKFreq+0x418>
34016b14:	4a7f      	ldr	r2, [pc, #508]	@ (34016d14 <RCCEx_GetUSARTCLKFreq+0x2cc>)
34016b16:	4293      	cmp	r3, r2
34016b18:	f200 81ab 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b1c:	4a7e      	ldr	r2, [pc, #504]	@ (34016d18 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34016b1e:	4293      	cmp	r3, r2
34016b20:	f000 819e 	beq.w	34016e60 <RCCEx_GetUSARTCLKFreq+0x418>
34016b24:	4a7c      	ldr	r2, [pc, #496]	@ (34016d18 <RCCEx_GetUSARTCLKFreq+0x2d0>)
34016b26:	4293      	cmp	r3, r2
34016b28:	f200 81a3 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b2c:	4a7b      	ldr	r2, [pc, #492]	@ (34016d1c <RCCEx_GetUSARTCLKFreq+0x2d4>)
34016b2e:	4293      	cmp	r3, r2
34016b30:	f000 8196 	beq.w	34016e60 <RCCEx_GetUSARTCLKFreq+0x418>
34016b34:	4a79      	ldr	r2, [pc, #484]	@ (34016d1c <RCCEx_GetUSARTCLKFreq+0x2d4>)
34016b36:	4293      	cmp	r3, r2
34016b38:	f200 819b 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b3c:	4a78      	ldr	r2, [pc, #480]	@ (34016d20 <RCCEx_GetUSARTCLKFreq+0x2d8>)
34016b3e:	4293      	cmp	r3, r2
34016b40:	f000 818e 	beq.w	34016e60 <RCCEx_GetUSARTCLKFreq+0x418>
34016b44:	4a76      	ldr	r2, [pc, #472]	@ (34016d20 <RCCEx_GetUSARTCLKFreq+0x2d8>)
34016b46:	4293      	cmp	r3, r2
34016b48:	f200 8193 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b4c:	4a75      	ldr	r2, [pc, #468]	@ (34016d24 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34016b4e:	4293      	cmp	r3, r2
34016b50:	f000 812d 	beq.w	34016dae <RCCEx_GetUSARTCLKFreq+0x366>
34016b54:	4a73      	ldr	r2, [pc, #460]	@ (34016d24 <RCCEx_GetUSARTCLKFreq+0x2dc>)
34016b56:	4293      	cmp	r3, r2
34016b58:	f200 818b 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b5c:	4a72      	ldr	r2, [pc, #456]	@ (34016d28 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34016b5e:	4293      	cmp	r3, r2
34016b60:	f000 8125 	beq.w	34016dae <RCCEx_GetUSARTCLKFreq+0x366>
34016b64:	4a70      	ldr	r2, [pc, #448]	@ (34016d28 <RCCEx_GetUSARTCLKFreq+0x2e0>)
34016b66:	4293      	cmp	r3, r2
34016b68:	f200 8183 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b6c:	4a6f      	ldr	r2, [pc, #444]	@ (34016d2c <RCCEx_GetUSARTCLKFreq+0x2e4>)
34016b6e:	4293      	cmp	r3, r2
34016b70:	f000 811d 	beq.w	34016dae <RCCEx_GetUSARTCLKFreq+0x366>
34016b74:	4a6d      	ldr	r2, [pc, #436]	@ (34016d2c <RCCEx_GetUSARTCLKFreq+0x2e4>)
34016b76:	4293      	cmp	r3, r2
34016b78:	f200 817b 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b7c:	4a6c      	ldr	r2, [pc, #432]	@ (34016d30 <RCCEx_GetUSARTCLKFreq+0x2e8>)
34016b7e:	4293      	cmp	r3, r2
34016b80:	f000 8115 	beq.w	34016dae <RCCEx_GetUSARTCLKFreq+0x366>
34016b84:	4a6a      	ldr	r2, [pc, #424]	@ (34016d30 <RCCEx_GetUSARTCLKFreq+0x2e8>)
34016b86:	4293      	cmp	r3, r2
34016b88:	f200 8173 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b8c:	4a69      	ldr	r2, [pc, #420]	@ (34016d34 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34016b8e:	4293      	cmp	r3, r2
34016b90:	f000 810d 	beq.w	34016dae <RCCEx_GetUSARTCLKFreq+0x366>
34016b94:	4a67      	ldr	r2, [pc, #412]	@ (34016d34 <RCCEx_GetUSARTCLKFreq+0x2ec>)
34016b96:	4293      	cmp	r3, r2
34016b98:	f200 816b 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016b9c:	4a66      	ldr	r2, [pc, #408]	@ (34016d38 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34016b9e:	4293      	cmp	r3, r2
34016ba0:	d07b      	beq.n	34016c9a <RCCEx_GetUSARTCLKFreq+0x252>
34016ba2:	4a65      	ldr	r2, [pc, #404]	@ (34016d38 <RCCEx_GetUSARTCLKFreq+0x2f0>)
34016ba4:	4293      	cmp	r3, r2
34016ba6:	f200 8164 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016baa:	4a64      	ldr	r2, [pc, #400]	@ (34016d3c <RCCEx_GetUSARTCLKFreq+0x2f4>)
34016bac:	4293      	cmp	r3, r2
34016bae:	d074      	beq.n	34016c9a <RCCEx_GetUSARTCLKFreq+0x252>
34016bb0:	4a62      	ldr	r2, [pc, #392]	@ (34016d3c <RCCEx_GetUSARTCLKFreq+0x2f4>)
34016bb2:	4293      	cmp	r3, r2
34016bb4:	f200 815d 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016bb8:	4a61      	ldr	r2, [pc, #388]	@ (34016d40 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34016bba:	4293      	cmp	r3, r2
34016bbc:	d06d      	beq.n	34016c9a <RCCEx_GetUSARTCLKFreq+0x252>
34016bbe:	4a60      	ldr	r2, [pc, #384]	@ (34016d40 <RCCEx_GetUSARTCLKFreq+0x2f8>)
34016bc0:	4293      	cmp	r3, r2
34016bc2:	f200 8156 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016bc6:	4a5f      	ldr	r2, [pc, #380]	@ (34016d44 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34016bc8:	4293      	cmp	r3, r2
34016bca:	d066      	beq.n	34016c9a <RCCEx_GetUSARTCLKFreq+0x252>
34016bcc:	4a5d      	ldr	r2, [pc, #372]	@ (34016d44 <RCCEx_GetUSARTCLKFreq+0x2fc>)
34016bce:	4293      	cmp	r3, r2
34016bd0:	f200 814f 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016bd4:	4a5c      	ldr	r2, [pc, #368]	@ (34016d48 <RCCEx_GetUSARTCLKFreq+0x300>)
34016bd6:	4293      	cmp	r3, r2
34016bd8:	d05f      	beq.n	34016c9a <RCCEx_GetUSARTCLKFreq+0x252>
34016bda:	4a5b      	ldr	r2, [pc, #364]	@ (34016d48 <RCCEx_GetUSARTCLKFreq+0x300>)
34016bdc:	4293      	cmp	r3, r2
34016bde:	f200 8148 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016be2:	4a5a      	ldr	r2, [pc, #360]	@ (34016d4c <RCCEx_GetUSARTCLKFreq+0x304>)
34016be4:	4293      	cmp	r3, r2
34016be6:	d053      	beq.n	34016c90 <RCCEx_GetUSARTCLKFreq+0x248>
34016be8:	4a58      	ldr	r2, [pc, #352]	@ (34016d4c <RCCEx_GetUSARTCLKFreq+0x304>)
34016bea:	4293      	cmp	r3, r2
34016bec:	f200 8141 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016bf0:	4a57      	ldr	r2, [pc, #348]	@ (34016d50 <RCCEx_GetUSARTCLKFreq+0x308>)
34016bf2:	4293      	cmp	r3, r2
34016bf4:	d04c      	beq.n	34016c90 <RCCEx_GetUSARTCLKFreq+0x248>
34016bf6:	4a56      	ldr	r2, [pc, #344]	@ (34016d50 <RCCEx_GetUSARTCLKFreq+0x308>)
34016bf8:	4293      	cmp	r3, r2
34016bfa:	f200 813a 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016bfe:	4a55      	ldr	r2, [pc, #340]	@ (34016d54 <RCCEx_GetUSARTCLKFreq+0x30c>)
34016c00:	4293      	cmp	r3, r2
34016c02:	d045      	beq.n	34016c90 <RCCEx_GetUSARTCLKFreq+0x248>
34016c04:	4a53      	ldr	r2, [pc, #332]	@ (34016d54 <RCCEx_GetUSARTCLKFreq+0x30c>)
34016c06:	4293      	cmp	r3, r2
34016c08:	f200 8133 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c0c:	4a52      	ldr	r2, [pc, #328]	@ (34016d58 <RCCEx_GetUSARTCLKFreq+0x310>)
34016c0e:	4293      	cmp	r3, r2
34016c10:	d03e      	beq.n	34016c90 <RCCEx_GetUSARTCLKFreq+0x248>
34016c12:	4a51      	ldr	r2, [pc, #324]	@ (34016d58 <RCCEx_GetUSARTCLKFreq+0x310>)
34016c14:	4293      	cmp	r3, r2
34016c16:	f200 812c 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c1a:	4a50      	ldr	r2, [pc, #320]	@ (34016d5c <RCCEx_GetUSARTCLKFreq+0x314>)
34016c1c:	4293      	cmp	r3, r2
34016c1e:	d037      	beq.n	34016c90 <RCCEx_GetUSARTCLKFreq+0x248>
34016c20:	4a4e      	ldr	r2, [pc, #312]	@ (34016d5c <RCCEx_GetUSARTCLKFreq+0x314>)
34016c22:	4293      	cmp	r3, r2
34016c24:	f200 8125 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c28:	4a4d      	ldr	r2, [pc, #308]	@ (34016d60 <RCCEx_GetUSARTCLKFreq+0x318>)
34016c2a:	4293      	cmp	r3, r2
34016c2c:	d018      	beq.n	34016c60 <RCCEx_GetUSARTCLKFreq+0x218>
34016c2e:	4a4c      	ldr	r2, [pc, #304]	@ (34016d60 <RCCEx_GetUSARTCLKFreq+0x318>)
34016c30:	4293      	cmp	r3, r2
34016c32:	f200 811e 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c36:	4a4b      	ldr	r2, [pc, #300]	@ (34016d64 <RCCEx_GetUSARTCLKFreq+0x31c>)
34016c38:	4293      	cmp	r3, r2
34016c3a:	d01d      	beq.n	34016c78 <RCCEx_GetUSARTCLKFreq+0x230>
34016c3c:	4a49      	ldr	r2, [pc, #292]	@ (34016d64 <RCCEx_GetUSARTCLKFreq+0x31c>)
34016c3e:	4293      	cmp	r3, r2
34016c40:	f200 8117 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c44:	4a48      	ldr	r2, [pc, #288]	@ (34016d68 <RCCEx_GetUSARTCLKFreq+0x320>)
34016c46:	4293      	cmp	r3, r2
34016c48:	d00a      	beq.n	34016c60 <RCCEx_GetUSARTCLKFreq+0x218>
34016c4a:	4a47      	ldr	r2, [pc, #284]	@ (34016d68 <RCCEx_GetUSARTCLKFreq+0x320>)
34016c4c:	4293      	cmp	r3, r2
34016c4e:	f200 8110 	bhi.w	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
34016c52:	4a46      	ldr	r2, [pc, #280]	@ (34016d6c <RCCEx_GetUSARTCLKFreq+0x324>)
34016c54:	4293      	cmp	r3, r2
34016c56:	d003      	beq.n	34016c60 <RCCEx_GetUSARTCLKFreq+0x218>
34016c58:	4a45      	ldr	r2, [pc, #276]	@ (34016d70 <RCCEx_GetUSARTCLKFreq+0x328>)
34016c5a:	4293      	cmp	r3, r2
34016c5c:	d00c      	beq.n	34016c78 <RCCEx_GetUSARTCLKFreq+0x230>
      }
      break;

    default:
      /* Unexpected case */
      break;
34016c5e:	e108      	b.n	34016e72 <RCCEx_GetUSARTCLKFreq+0x42a>
      usart_frequency = RCCEx_GetPCLK2Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016c60:	f7f7 ff8e 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34016c64:	4603      	mov	r3, r0
34016c66:	4618      	mov	r0, r3
34016c68:	f7fc ff1a 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34016c6c:	4603      	mov	r3, r0
34016c6e:	4618      	mov	r0, r3
34016c70:	f7fc ff37 	bl	34013ae2 <RCCEx_GetPCLK2Freq>
34016c74:	60f8      	str	r0, [r7, #12]
      break;
34016c76:	e107      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetPCLK1Freq(RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq()));
34016c78:	f7f7 ff82 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34016c7c:	4603      	mov	r3, r0
34016c7e:	4618      	mov	r0, r3
34016c80:	f7fc ff0e 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34016c84:	4603      	mov	r3, r0
34016c86:	4618      	mov	r0, r3
34016c88:	f7fc ff1b 	bl	34013ac2 <RCCEx_GetPCLK1Freq>
34016c8c:	60f8      	str	r0, [r7, #12]
      break;
34016c8e:	e0fb      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      usart_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016c90:	2007      	movs	r0, #7
34016c92:	f7fd f9f1 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34016c96:	60f8      	str	r0, [r7, #12]
      break;
34016c98:	e0f6      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      if (LL_RCC_IC9_IsEnabled() != 0U)
34016c9a:	f7f9 fb95 	bl	340103c8 <LL_RCC_IC9_IsEnabled>
34016c9e:	4603      	mov	r3, r0
34016ca0:	2b00      	cmp	r3, #0
34016ca2:	f000 80e8 	beq.w	34016e76 <RCCEx_GetUSARTCLKFreq+0x42e>
        ic_divider = LL_RCC_IC9_GetDivider();
34016ca6:	f7f9 fbb1 	bl	3401040c <LL_RCC_IC9_GetDivider>
34016caa:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC9_GetSource())
34016cac:	f7f9 fba0 	bl	340103f0 <LL_RCC_IC9_GetSource>
34016cb0:	4603      	mov	r3, r0
34016cb2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016cb6:	d06f      	beq.n	34016d98 <RCCEx_GetUSARTCLKFreq+0x350>
34016cb8:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016cbc:	d875      	bhi.n	34016daa <RCCEx_GetUSARTCLKFreq+0x362>
34016cbe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016cc2:	d060      	beq.n	34016d86 <RCCEx_GetUSARTCLKFreq+0x33e>
34016cc4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016cc8:	d86f      	bhi.n	34016daa <RCCEx_GetUSARTCLKFreq+0x362>
34016cca:	2b00      	cmp	r3, #0
34016ccc:	d003      	beq.n	34016cd6 <RCCEx_GetUSARTCLKFreq+0x28e>
34016cce:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016cd2:	d04f      	beq.n	34016d74 <RCCEx_GetUSARTCLKFreq+0x32c>
            break;
34016cd4:	e069      	b.n	34016daa <RCCEx_GetUSARTCLKFreq+0x362>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016cd6:	f7fc fdcb 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016cda:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016cdc:	68fa      	ldr	r2, [r7, #12]
34016cde:	68bb      	ldr	r3, [r7, #8]
34016ce0:	fbb2 f3f3 	udiv	r3, r2, r3
34016ce4:	60fb      	str	r3, [r7, #12]
            break;
34016ce6:	e061      	b.n	34016dac <RCCEx_GetUSARTCLKFreq+0x364>
34016ce8:	07061430 	.word	0x07061430
34016cec:	07060830 	.word	0x07060830
34016cf0:	07060434 	.word	0x07060434
34016cf4:	07060430 	.word	0x07060430
34016cf8:	07060030 	.word	0x07060030
34016cfc:	07051430 	.word	0x07051430
34016d00:	07050830 	.word	0x07050830
34016d04:	07050434 	.word	0x07050434
34016d08:	07050430 	.word	0x07050430
34016d0c:	07050030 	.word	0x07050030
34016d10:	07041430 	.word	0x07041430
34016d14:	07040830 	.word	0x07040830
34016d18:	07040434 	.word	0x07040434
34016d1c:	07040430 	.word	0x07040430
34016d20:	07040030 	.word	0x07040030
34016d24:	07031430 	.word	0x07031430
34016d28:	07030830 	.word	0x07030830
34016d2c:	07030434 	.word	0x07030434
34016d30:	07030430 	.word	0x07030430
34016d34:	07030030 	.word	0x07030030
34016d38:	07021430 	.word	0x07021430
34016d3c:	07020830 	.word	0x07020830
34016d40:	07020434 	.word	0x07020434
34016d44:	07020430 	.word	0x07020430
34016d48:	07020030 	.word	0x07020030
34016d4c:	07011430 	.word	0x07011430
34016d50:	07010830 	.word	0x07010830
34016d54:	07010434 	.word	0x07010434
34016d58:	07010430 	.word	0x07010430
34016d5c:	07010030 	.word	0x07010030
34016d60:	07001430 	.word	0x07001430
34016d64:	07000830 	.word	0x07000830
34016d68:	07000434 	.word	0x07000434
34016d6c:	07000030 	.word	0x07000030
34016d70:	07000430 	.word	0x07000430
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016d74:	f7fc fdc2 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016d78:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016d7a:	68fa      	ldr	r2, [r7, #12]
34016d7c:	68bb      	ldr	r3, [r7, #8]
34016d7e:	fbb2 f3f3 	udiv	r3, r2, r3
34016d82:	60fb      	str	r3, [r7, #12]
            break;
34016d84:	e012      	b.n	34016dac <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016d86:	f7fc fdff 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34016d8a:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016d8c:	68fa      	ldr	r2, [r7, #12]
34016d8e:	68bb      	ldr	r3, [r7, #8]
34016d90:	fbb2 f3f3 	udiv	r3, r2, r3
34016d94:	60fb      	str	r3, [r7, #12]
            break;
34016d96:	e009      	b.n	34016dac <RCCEx_GetUSARTCLKFreq+0x364>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016d98:	f7fc fe3c 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34016d9c:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016d9e:	68fa      	ldr	r2, [r7, #12]
34016da0:	68bb      	ldr	r3, [r7, #8]
34016da2:	fbb2 f3f3 	udiv	r3, r2, r3
34016da6:	60fb      	str	r3, [r7, #12]
            break;
34016da8:	e000      	b.n	34016dac <RCCEx_GetUSARTCLKFreq+0x364>
            break;
34016daa:	bf00      	nop
      break;
34016dac:	e063      	b.n	34016e76 <RCCEx_GetUSARTCLKFreq+0x42e>
      if (LL_RCC_IC14_IsEnabled() != 0U)
34016dae:	f7f9 fc0b 	bl	340105c8 <LL_RCC_IC14_IsEnabled>
34016db2:	4603      	mov	r3, r0
34016db4:	2b00      	cmp	r3, #0
34016db6:	d060      	beq.n	34016e7a <RCCEx_GetUSARTCLKFreq+0x432>
        ic_divider = LL_RCC_IC14_GetDivider();
34016db8:	f7f9 fc28 	bl	3401060c <LL_RCC_IC14_GetDivider>
34016dbc:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC14_GetSource())
34016dbe:	f7f9 fc17 	bl	340105f0 <LL_RCC_IC14_GetSource>
34016dc2:	4603      	mov	r3, r0
34016dc4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016dc8:	d029      	beq.n	34016e1e <RCCEx_GetUSARTCLKFreq+0x3d6>
34016dca:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016dce:	d82f      	bhi.n	34016e30 <RCCEx_GetUSARTCLKFreq+0x3e8>
34016dd0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016dd4:	d01a      	beq.n	34016e0c <RCCEx_GetUSARTCLKFreq+0x3c4>
34016dd6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016dda:	d829      	bhi.n	34016e30 <RCCEx_GetUSARTCLKFreq+0x3e8>
34016ddc:	2b00      	cmp	r3, #0
34016dde:	d003      	beq.n	34016de8 <RCCEx_GetUSARTCLKFreq+0x3a0>
34016de0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016de4:	d009      	beq.n	34016dfa <RCCEx_GetUSARTCLKFreq+0x3b2>
            break;
34016de6:	e023      	b.n	34016e30 <RCCEx_GetUSARTCLKFreq+0x3e8>
            usart_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016de8:	f7fc fd42 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016dec:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016dee:	68fa      	ldr	r2, [r7, #12]
34016df0:	68bb      	ldr	r3, [r7, #8]
34016df2:	fbb2 f3f3 	udiv	r3, r2, r3
34016df6:	60fb      	str	r3, [r7, #12]
            break;
34016df8:	e01b      	b.n	34016e32 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016dfa:	f7fc fd7f 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016dfe:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016e00:	68fa      	ldr	r2, [r7, #12]
34016e02:	68bb      	ldr	r3, [r7, #8]
34016e04:	fbb2 f3f3 	udiv	r3, r2, r3
34016e08:	60fb      	str	r3, [r7, #12]
            break;
34016e0a:	e012      	b.n	34016e32 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016e0c:	f7fc fdbc 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34016e10:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016e12:	68fa      	ldr	r2, [r7, #12]
34016e14:	68bb      	ldr	r3, [r7, #8]
34016e16:	fbb2 f3f3 	udiv	r3, r2, r3
34016e1a:	60fb      	str	r3, [r7, #12]
            break;
34016e1c:	e009      	b.n	34016e32 <RCCEx_GetUSARTCLKFreq+0x3ea>
            usart_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016e1e:	f7fc fdf9 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34016e22:	60f8      	str	r0, [r7, #12]
            usart_frequency = usart_frequency / ic_divider;
34016e24:	68fa      	ldr	r2, [r7, #12]
34016e26:	68bb      	ldr	r3, [r7, #8]
34016e28:	fbb2 f3f3 	udiv	r3, r2, r3
34016e2c:	60fb      	str	r3, [r7, #12]
            break;
34016e2e:	e000      	b.n	34016e32 <RCCEx_GetUSARTCLKFreq+0x3ea>
            break;
34016e30:	bf00      	nop
      break;
34016e32:	e022      	b.n	34016e7a <RCCEx_GetUSARTCLKFreq+0x432>
      if (LL_RCC_HSI_IsReady() != 0U)
34016e34:	f7f8 faa4 	bl	3400f380 <LL_RCC_HSI_IsReady>
34016e38:	4603      	mov	r3, r0
34016e3a:	2b00      	cmp	r3, #0
34016e3c:	d01f      	beq.n	34016e7e <RCCEx_GetUSARTCLKFreq+0x436>
        usart_frequency = HSI_VALUE >> (LL_RCC_HSI_GetDivider() >> RCC_HSICFGR_HSIDIV_Pos);
34016e3e:	f7f8 fab1 	bl	3400f3a4 <LL_RCC_HSI_GetDivider>
34016e42:	4603      	mov	r3, r0
34016e44:	09db      	lsrs	r3, r3, #7
34016e46:	4a13      	ldr	r2, [pc, #76]	@ (34016e94 <RCCEx_GetUSARTCLKFreq+0x44c>)
34016e48:	fa22 f303 	lsr.w	r3, r2, r3
34016e4c:	60fb      	str	r3, [r7, #12]
      break;
34016e4e:	e016      	b.n	34016e7e <RCCEx_GetUSARTCLKFreq+0x436>
      if (LL_RCC_MSI_IsReady() != 0U)
34016e50:	f7f8 fab6 	bl	3400f3c0 <LL_RCC_MSI_IsReady>
34016e54:	4603      	mov	r3, r0
34016e56:	2b00      	cmp	r3, #0
34016e58:	d013      	beq.n	34016e82 <RCCEx_GetUSARTCLKFreq+0x43a>
        usart_frequency = MSI_VALUE;
34016e5a:	4b0f      	ldr	r3, [pc, #60]	@ (34016e98 <RCCEx_GetUSARTCLKFreq+0x450>)
34016e5c:	60fb      	str	r3, [r7, #12]
      break;
34016e5e:	e010      	b.n	34016e82 <RCCEx_GetUSARTCLKFreq+0x43a>
      if (LL_RCC_LSE_IsReady() != 0U)
34016e60:	f7f8 face 	bl	3400f400 <LL_RCC_LSE_IsReady>
34016e64:	4603      	mov	r3, r0
34016e66:	2b00      	cmp	r3, #0
34016e68:	d00d      	beq.n	34016e86 <RCCEx_GetUSARTCLKFreq+0x43e>
        usart_frequency = LSE_VALUE;
34016e6a:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34016e6e:	60fb      	str	r3, [r7, #12]
      break;
34016e70:	e009      	b.n	34016e86 <RCCEx_GetUSARTCLKFreq+0x43e>
      break;
34016e72:	bf00      	nop
34016e74:	e008      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34016e76:	bf00      	nop
34016e78:	e006      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34016e7a:	bf00      	nop
34016e7c:	e004      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34016e7e:	bf00      	nop
34016e80:	e002      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34016e82:	bf00      	nop
34016e84:	e000      	b.n	34016e88 <RCCEx_GetUSARTCLKFreq+0x440>
      break;
34016e86:	bf00      	nop
  }

  return usart_frequency;
34016e88:	68fb      	ldr	r3, [r7, #12]
}
34016e8a:	4618      	mov	r0, r3
34016e8c:	3710      	adds	r7, #16
34016e8e:	46bd      	mov	sp, r7
34016e90:	bd80      	pop	{r7, pc}
34016e92:	bf00      	nop
34016e94:	03d09000 	.word	0x03d09000
34016e98:	003d0900 	.word	0x003d0900

34016e9c <RCCEx_GetOTGPHYCLKFreq>:
  *         @arg @ref RCCEx_USB_OTGHS2_Clock_Source
  * @retval OTGPHY clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCLKFreq(uint32_t OTGPHYxSource)
{
34016e9c:	b580      	push	{r7, lr}
34016e9e:	b084      	sub	sp, #16
34016ea0:	af00      	add	r7, sp, #0
34016ea2:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34016ea4:	2300      	movs	r3, #0
34016ea6:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxSource))
34016ea8:	6878      	ldr	r0, [r7, #4]
34016eaa:	f7f8 fe69 	bl	3400fb80 <LL_RCC_GetUSBClockSource>
34016eae:	4603      	mov	r3, r0
34016eb0:	4a4b      	ldr	r2, [pc, #300]	@ (34016fe0 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34016eb2:	4293      	cmp	r3, r2
34016eb4:	d035      	beq.n	34016f22 <RCCEx_GetOTGPHYCLKFreq+0x86>
34016eb6:	4a4a      	ldr	r2, [pc, #296]	@ (34016fe0 <RCCEx_GetOTGPHYCLKFreq+0x144>)
34016eb8:	4293      	cmp	r3, r2
34016eba:	f200 8085 	bhi.w	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016ebe:	4a49      	ldr	r2, [pc, #292]	@ (34016fe4 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34016ec0:	4293      	cmp	r3, r2
34016ec2:	d02e      	beq.n	34016f22 <RCCEx_GetOTGPHYCLKFreq+0x86>
34016ec4:	4a47      	ldr	r2, [pc, #284]	@ (34016fe4 <RCCEx_GetOTGPHYCLKFreq+0x148>)
34016ec6:	4293      	cmp	r3, r2
34016ec8:	d87e      	bhi.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016eca:	4a47      	ldr	r2, [pc, #284]	@ (34016fe8 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34016ecc:	4293      	cmp	r3, r2
34016ece:	d038      	beq.n	34016f42 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34016ed0:	4a45      	ldr	r2, [pc, #276]	@ (34016fe8 <RCCEx_GetOTGPHYCLKFreq+0x14c>)
34016ed2:	4293      	cmp	r3, r2
34016ed4:	d878      	bhi.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016ed6:	4a45      	ldr	r2, [pc, #276]	@ (34016fec <RCCEx_GetOTGPHYCLKFreq+0x150>)
34016ed8:	4293      	cmp	r3, r2
34016eda:	d032      	beq.n	34016f42 <RCCEx_GetOTGPHYCLKFreq+0xa6>
34016edc:	4a43      	ldr	r2, [pc, #268]	@ (34016fec <RCCEx_GetOTGPHYCLKFreq+0x150>)
34016ede:	4293      	cmp	r3, r2
34016ee0:	d872      	bhi.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016ee2:	4a43      	ldr	r2, [pc, #268]	@ (34016ff0 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34016ee4:	4293      	cmp	r3, r2
34016ee6:	d00f      	beq.n	34016f08 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34016ee8:	4a41      	ldr	r2, [pc, #260]	@ (34016ff0 <RCCEx_GetOTGPHYCLKFreq+0x154>)
34016eea:	4293      	cmp	r3, r2
34016eec:	d86c      	bhi.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016eee:	4a41      	ldr	r2, [pc, #260]	@ (34016ff4 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34016ef0:	4293      	cmp	r3, r2
34016ef2:	d009      	beq.n	34016f08 <RCCEx_GetOTGPHYCLKFreq+0x6c>
34016ef4:	4a3f      	ldr	r2, [pc, #252]	@ (34016ff4 <RCCEx_GetOTGPHYCLKFreq+0x158>)
34016ef6:	4293      	cmp	r3, r2
34016ef8:	d866      	bhi.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
34016efa:	4a3f      	ldr	r2, [pc, #252]	@ (34016ff8 <RCCEx_GetOTGPHYCLKFreq+0x15c>)
34016efc:	4293      	cmp	r3, r2
34016efe:	d008      	beq.n	34016f12 <RCCEx_GetOTGPHYCLKFreq+0x76>
34016f00:	4a3e      	ldr	r2, [pc, #248]	@ (34016ffc <RCCEx_GetOTGPHYCLKFreq+0x160>)
34016f02:	4293      	cmp	r3, r2
34016f04:	d005      	beq.n	34016f12 <RCCEx_GetOTGPHYCLKFreq+0x76>
      }
      break;

    default:
      /* Unexpected case */
      break;
34016f06:	e05f      	b.n	34016fc8 <RCCEx_GetOTGPHYCLKFreq+0x12c>
      usb_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
34016f08:	2007      	movs	r0, #7
34016f0a:	f7fd f8b5 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34016f0e:	60f8      	str	r0, [r7, #12]
      break;
34016f10:	e061      	b.n	34016fd6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      if (LL_RCC_HSE_IsReady() != 0U)
34016f12:	f7f8 fa23 	bl	3400f35c <LL_RCC_HSE_IsReady>
34016f16:	4603      	mov	r3, r0
34016f18:	2b00      	cmp	r3, #0
34016f1a:	d057      	beq.n	34016fcc <RCCEx_GetOTGPHYCLKFreq+0x130>
        usb_frequency = HSE_VALUE / 2U;
34016f1c:	4b38      	ldr	r3, [pc, #224]	@ (34017000 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34016f1e:	60fb      	str	r3, [r7, #12]
      break;
34016f20:	e054      	b.n	34016fcc <RCCEx_GetOTGPHYCLKFreq+0x130>
      if (LL_RCC_HSE_IsReady() != 0U)
34016f22:	f7f8 fa1b 	bl	3400f35c <LL_RCC_HSE_IsReady>
34016f26:	4603      	mov	r3, r0
34016f28:	2b00      	cmp	r3, #0
34016f2a:	d051      	beq.n	34016fd0 <RCCEx_GetOTGPHYCLKFreq+0x134>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
34016f2c:	f7f8 fa04 	bl	3400f338 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34016f30:	4603      	mov	r3, r0
34016f32:	2b00      	cmp	r3, #0
34016f34:	d102      	bne.n	34016f3c <RCCEx_GetOTGPHYCLKFreq+0xa0>
          usb_frequency = HSE_VALUE;
34016f36:	4b33      	ldr	r3, [pc, #204]	@ (34017004 <RCCEx_GetOTGPHYCLKFreq+0x168>)
34016f38:	60fb      	str	r3, [r7, #12]
      break;
34016f3a:	e049      	b.n	34016fd0 <RCCEx_GetOTGPHYCLKFreq+0x134>
          usb_frequency = HSE_VALUE / 2U;
34016f3c:	4b30      	ldr	r3, [pc, #192]	@ (34017000 <RCCEx_GetOTGPHYCLKFreq+0x164>)
34016f3e:	60fb      	str	r3, [r7, #12]
      break;
34016f40:	e046      	b.n	34016fd0 <RCCEx_GetOTGPHYCLKFreq+0x134>
      if (LL_RCC_IC15_IsEnabled() != 0U)
34016f42:	f7f9 fb81 	bl	34010648 <LL_RCC_IC15_IsEnabled>
34016f46:	4603      	mov	r3, r0
34016f48:	2b00      	cmp	r3, #0
34016f4a:	d043      	beq.n	34016fd4 <RCCEx_GetOTGPHYCLKFreq+0x138>
        uint32_t ic_divider = LL_RCC_IC15_GetDivider();
34016f4c:	f7f9 fb9e 	bl	3401068c <LL_RCC_IC15_GetDivider>
34016f50:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC15_GetSource())
34016f52:	f7f9 fb8d 	bl	34010670 <LL_RCC_IC15_GetSource>
34016f56:	4603      	mov	r3, r0
34016f58:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016f5c:	d029      	beq.n	34016fb2 <RCCEx_GetOTGPHYCLKFreq+0x116>
34016f5e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34016f62:	d82f      	bhi.n	34016fc4 <RCCEx_GetOTGPHYCLKFreq+0x128>
34016f64:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016f68:	d01a      	beq.n	34016fa0 <RCCEx_GetOTGPHYCLKFreq+0x104>
34016f6a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34016f6e:	d829      	bhi.n	34016fc4 <RCCEx_GetOTGPHYCLKFreq+0x128>
34016f70:	2b00      	cmp	r3, #0
34016f72:	d003      	beq.n	34016f7c <RCCEx_GetOTGPHYCLKFreq+0xe0>
34016f74:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34016f78:	d009      	beq.n	34016f8e <RCCEx_GetOTGPHYCLKFreq+0xf2>
            break;
34016f7a:	e023      	b.n	34016fc4 <RCCEx_GetOTGPHYCLKFreq+0x128>
            usb_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34016f7c:	f7fc fc78 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
34016f80:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34016f82:	68fa      	ldr	r2, [r7, #12]
34016f84:	68bb      	ldr	r3, [r7, #8]
34016f86:	fbb2 f3f3 	udiv	r3, r2, r3
34016f8a:	60fb      	str	r3, [r7, #12]
            break;
34016f8c:	e01b      	b.n	34016fc6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL2CLKFreq();
34016f8e:	f7fc fcb5 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
34016f92:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34016f94:	68fa      	ldr	r2, [r7, #12]
34016f96:	68bb      	ldr	r3, [r7, #8]
34016f98:	fbb2 f3f3 	udiv	r3, r2, r3
34016f9c:	60fb      	str	r3, [r7, #12]
            break;
34016f9e:	e012      	b.n	34016fc6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL3CLKFreq();
34016fa0:	f7fc fcf2 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34016fa4:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34016fa6:	68fa      	ldr	r2, [r7, #12]
34016fa8:	68bb      	ldr	r3, [r7, #8]
34016faa:	fbb2 f3f3 	udiv	r3, r2, r3
34016fae:	60fb      	str	r3, [r7, #12]
            break;
34016fb0:	e009      	b.n	34016fc6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            usb_frequency = HAL_RCCEx_GetPLL4CLKFreq();
34016fb2:	f7fc fd2f 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34016fb6:	60f8      	str	r0, [r7, #12]
            usb_frequency = usb_frequency / ic_divider;
34016fb8:	68fa      	ldr	r2, [r7, #12]
34016fba:	68bb      	ldr	r3, [r7, #8]
34016fbc:	fbb2 f3f3 	udiv	r3, r2, r3
34016fc0:	60fb      	str	r3, [r7, #12]
            break;
34016fc2:	e000      	b.n	34016fc6 <RCCEx_GetOTGPHYCLKFreq+0x12a>
            break;
34016fc4:	bf00      	nop
      break;
34016fc6:	e005      	b.n	34016fd4 <RCCEx_GetOTGPHYCLKFreq+0x138>
      break;
34016fc8:	bf00      	nop
34016fca:	e004      	b.n	34016fd6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34016fcc:	bf00      	nop
34016fce:	e002      	b.n	34016fd6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34016fd0:	bf00      	nop
34016fd2:	e000      	b.n	34016fd6 <RCCEx_GetOTGPHYCLKFreq+0x13a>
      break;
34016fd4:	bf00      	nop
  }

  return usb_frequency;
34016fd6:	68fb      	ldr	r3, [r7, #12]
}
34016fd8:	4618      	mov	r0, r3
34016fda:	3710      	adds	r7, #16
34016fdc:	46bd      	mov	sp, r7
34016fde:	bd80      	pop	{r7, pc}
34016fe0:	03031414 	.word	0x03031414
34016fe4:	03030c14 	.word	0x03030c14
34016fe8:	03021414 	.word	0x03021414
34016fec:	03020c14 	.word	0x03020c14
34016ff0:	03011414 	.word	0x03011414
34016ff4:	03010c14 	.word	0x03010c14
34016ff8:	03000c14 	.word	0x03000c14
34016ffc:	03001414 	.word	0x03001414
34017000:	016e3600 	.word	0x016e3600
34017004:	02dc6c00 	.word	0x02dc6c00

34017008 <RCCEx_GetOTGPHYCKREFCLKFreq>:
  *         @arg @ref RCCEx_USBPHY2_Clock_Source
  * @retval OTGPHYCKREF clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready or Disabled
  */
static uint32_t RCCEx_GetOTGPHYCKREFCLKFreq(uint32_t OTGPHYxCKREFSource)
{
34017008:	b580      	push	{r7, lr}
3401700a:	b084      	sub	sp, #16
3401700c:	af00      	add	r7, sp, #0
3401700e:	6078      	str	r0, [r7, #4]
  uint32_t usb_frequency = RCC_PERIPH_FREQUENCY_NO;
34017010:	2300      	movs	r3, #0
34017012:	60fb      	str	r3, [r7, #12]

  switch (LL_RCC_GetUSBClockSource(OTGPHYxCKREFSource))
34017014:	6878      	ldr	r0, [r7, #4]
34017016:	f7f8 fdb3 	bl	3400fb80 <LL_RCC_GetUSBClockSource>
3401701a:	4603      	mov	r3, r0
3401701c:	4a1a      	ldr	r2, [pc, #104]	@ (34017088 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
3401701e:	4293      	cmp	r3, r2
34017020:	d00f      	beq.n	34017042 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
34017022:	4a19      	ldr	r2, [pc, #100]	@ (34017088 <RCCEx_GetOTGPHYCKREFCLKFreq+0x80>)
34017024:	4293      	cmp	r3, r2
34017026:	d826      	bhi.n	34017076 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34017028:	4a18      	ldr	r2, [pc, #96]	@ (3401708c <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
3401702a:	4293      	cmp	r3, r2
3401702c:	d009      	beq.n	34017042 <RCCEx_GetOTGPHYCKREFCLKFreq+0x3a>
3401702e:	4a17      	ldr	r2, [pc, #92]	@ (3401708c <RCCEx_GetOTGPHYCKREFCLKFreq+0x84>)
34017030:	4293      	cmp	r3, r2
34017032:	d820      	bhi.n	34017076 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
34017034:	4a16      	ldr	r2, [pc, #88]	@ (34017090 <RCCEx_GetOTGPHYCKREFCLKFreq+0x88>)
34017036:	4293      	cmp	r3, r2
34017038:	d013      	beq.n	34017062 <RCCEx_GetOTGPHYCKREFCLKFreq+0x5a>
3401703a:	4a16      	ldr	r2, [pc, #88]	@ (34017094 <RCCEx_GetOTGPHYCKREFCLKFreq+0x8c>)
3401703c:	4293      	cmp	r3, r2
3401703e:	d015      	beq.n	3401706c <RCCEx_GetOTGPHYCKREFCLKFreq+0x64>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
      break;

    default:
      /* Unexpected case */
      break;
34017040:	e019      	b.n	34017076 <RCCEx_GetOTGPHYCKREFCLKFreq+0x6e>
      if (LL_RCC_HSE_IsReady() != 0U)
34017042:	f7f8 f98b 	bl	3400f35c <LL_RCC_HSE_IsReady>
34017046:	4603      	mov	r3, r0
34017048:	2b00      	cmp	r3, #0
3401704a:	d016      	beq.n	3401707a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
        if (LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock() == 0UL)
3401704c:	f7f8 f974 	bl	3400f338 <LL_RCC_HSE_IsSelectedHSEDiv2AsDiv2Clock>
34017050:	4603      	mov	r3, r0
34017052:	2b00      	cmp	r3, #0
34017054:	d102      	bne.n	3401705c <RCCEx_GetOTGPHYCKREFCLKFreq+0x54>
          usb_frequency = HSE_VALUE;
34017056:	4b10      	ldr	r3, [pc, #64]	@ (34017098 <RCCEx_GetOTGPHYCKREFCLKFreq+0x90>)
34017058:	60fb      	str	r3, [r7, #12]
      break;
3401705a:	e00e      	b.n	3401707a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
          usb_frequency = HSE_VALUE / 2U;
3401705c:	4b0f      	ldr	r3, [pc, #60]	@ (3401709c <RCCEx_GetOTGPHYCKREFCLKFreq+0x94>)
3401705e:	60fb      	str	r3, [r7, #12]
      break;
34017060:	e00b      	b.n	3401707a <RCCEx_GetOTGPHYCKREFCLKFreq+0x72>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY1_CLKSOURCE);
34017062:	480f      	ldr	r0, [pc, #60]	@ (340170a0 <RCCEx_GetOTGPHYCKREFCLKFreq+0x98>)
34017064:	f7ff ff1a 	bl	34016e9c <RCCEx_GetOTGPHYCLKFreq>
34017068:	60f8      	str	r0, [r7, #12]
      break;
3401706a:	e007      	b.n	3401707c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      usb_frequency = RCCEx_GetOTGPHYCLKFreq(LL_RCC_OTGPHY2_CLKSOURCE);
3401706c:	480d      	ldr	r0, [pc, #52]	@ (340170a4 <RCCEx_GetOTGPHYCKREFCLKFreq+0x9c>)
3401706e:	f7ff ff15 	bl	34016e9c <RCCEx_GetOTGPHYCLKFreq>
34017072:	60f8      	str	r0, [r7, #12]
      break;
34017074:	e002      	b.n	3401707c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
34017076:	bf00      	nop
34017078:	e000      	b.n	3401707c <RCCEx_GetOTGPHYCKREFCLKFreq+0x74>
      break;
3401707a:	bf00      	nop
  }

  return usb_frequency;
3401707c:	68fb      	ldr	r3, [r7, #12]
}
3401707e:	4618      	mov	r0, r3
34017080:	3710      	adds	r7, #16
34017082:	46bd      	mov	sp, r7
34017084:	bd80      	pop	{r7, pc}
34017086:	bf00      	nop
34017088:	01011814 	.word	0x01011814
3401708c:	01011014 	.word	0x01011014
34017090:	01001014 	.word	0x01001014
34017094:	01001814 	.word	0x01001814
34017098:	02dc6c00 	.word	0x02dc6c00
3401709c:	016e3600 	.word	0x016e3600
340170a0:	03000c14 	.word	0x03000c14
340170a4:	03001414 	.word	0x03001414

340170a8 <RCCEx_GetXSPICLKFreq>:
  * @retval XSPI clock frequency (in Hz)
  *         - @ref  RCC_PERIPH_FREQUENCY_NO indicates that oscillator is not ready
  */

static uint32_t RCCEx_GetXSPICLKFreq(uint32_t XSPIxSource)
{
340170a8:	b580      	push	{r7, lr}
340170aa:	b084      	sub	sp, #16
340170ac:	af00      	add	r7, sp, #0
340170ae:	6078      	str	r0, [r7, #4]
  uint32_t xspi_frequency = RCC_PERIPH_FREQUENCY_NO;
340170b0:	2300      	movs	r3, #0
340170b2:	60fb      	str	r3, [r7, #12]
  uint32_t ic_divider;

  switch (LL_RCC_GetXSPIClockSource(XSPIxSource))
340170b4:	6878      	ldr	r0, [r7, #4]
340170b6:	f7f8 fd6f 	bl	3400fb98 <LL_RCC_GetXSPIClockSource>
340170ba:	4603      	mov	r3, r0
340170bc:	4a76      	ldr	r2, [pc, #472]	@ (34017298 <RCCEx_GetXSPICLKFreq+0x1f0>)
340170be:	4293      	cmp	r3, r2
340170c0:	f000 809d 	beq.w	340171fe <RCCEx_GetXSPICLKFreq+0x156>
340170c4:	4a74      	ldr	r2, [pc, #464]	@ (34017298 <RCCEx_GetXSPICLKFreq+0x1f0>)
340170c6:	4293      	cmp	r3, r2
340170c8:	f200 80dc 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
340170cc:	4a73      	ldr	r2, [pc, #460]	@ (3401729c <RCCEx_GetXSPICLKFreq+0x1f4>)
340170ce:	4293      	cmp	r3, r2
340170d0:	f000 8095 	beq.w	340171fe <RCCEx_GetXSPICLKFreq+0x156>
340170d4:	4a71      	ldr	r2, [pc, #452]	@ (3401729c <RCCEx_GetXSPICLKFreq+0x1f4>)
340170d6:	4293      	cmp	r3, r2
340170d8:	f200 80d4 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
340170dc:	4a70      	ldr	r2, [pc, #448]	@ (340172a0 <RCCEx_GetXSPICLKFreq+0x1f8>)
340170de:	4293      	cmp	r3, r2
340170e0:	f000 808d 	beq.w	340171fe <RCCEx_GetXSPICLKFreq+0x156>
340170e4:	4a6e      	ldr	r2, [pc, #440]	@ (340172a0 <RCCEx_GetXSPICLKFreq+0x1f8>)
340170e6:	4293      	cmp	r3, r2
340170e8:	f200 80cc 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
340170ec:	4a6d      	ldr	r2, [pc, #436]	@ (340172a4 <RCCEx_GetXSPICLKFreq+0x1fc>)
340170ee:	4293      	cmp	r3, r2
340170f0:	d041      	beq.n	34017176 <RCCEx_GetXSPICLKFreq+0xce>
340170f2:	4a6c      	ldr	r2, [pc, #432]	@ (340172a4 <RCCEx_GetXSPICLKFreq+0x1fc>)
340170f4:	4293      	cmp	r3, r2
340170f6:	f200 80c5 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
340170fa:	4a6b      	ldr	r2, [pc, #428]	@ (340172a8 <RCCEx_GetXSPICLKFreq+0x200>)
340170fc:	4293      	cmp	r3, r2
340170fe:	d03a      	beq.n	34017176 <RCCEx_GetXSPICLKFreq+0xce>
34017100:	4a69      	ldr	r2, [pc, #420]	@ (340172a8 <RCCEx_GetXSPICLKFreq+0x200>)
34017102:	4293      	cmp	r3, r2
34017104:	f200 80be 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
34017108:	4a68      	ldr	r2, [pc, #416]	@ (340172ac <RCCEx_GetXSPICLKFreq+0x204>)
3401710a:	4293      	cmp	r3, r2
3401710c:	d033      	beq.n	34017176 <RCCEx_GetXSPICLKFreq+0xce>
3401710e:	4a67      	ldr	r2, [pc, #412]	@ (340172ac <RCCEx_GetXSPICLKFreq+0x204>)
34017110:	4293      	cmp	r3, r2
34017112:	f200 80b7 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
34017116:	4a66      	ldr	r2, [pc, #408]	@ (340172b0 <RCCEx_GetXSPICLKFreq+0x208>)
34017118:	4293      	cmp	r3, r2
3401711a:	d027      	beq.n	3401716c <RCCEx_GetXSPICLKFreq+0xc4>
3401711c:	4a64      	ldr	r2, [pc, #400]	@ (340172b0 <RCCEx_GetXSPICLKFreq+0x208>)
3401711e:	4293      	cmp	r3, r2
34017120:	f200 80b0 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
34017124:	4a63      	ldr	r2, [pc, #396]	@ (340172b4 <RCCEx_GetXSPICLKFreq+0x20c>)
34017126:	4293      	cmp	r3, r2
34017128:	d020      	beq.n	3401716c <RCCEx_GetXSPICLKFreq+0xc4>
3401712a:	4a62      	ldr	r2, [pc, #392]	@ (340172b4 <RCCEx_GetXSPICLKFreq+0x20c>)
3401712c:	4293      	cmp	r3, r2
3401712e:	f200 80a9 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
34017132:	4a61      	ldr	r2, [pc, #388]	@ (340172b8 <RCCEx_GetXSPICLKFreq+0x210>)
34017134:	4293      	cmp	r3, r2
34017136:	d019      	beq.n	3401716c <RCCEx_GetXSPICLKFreq+0xc4>
34017138:	4a5f      	ldr	r2, [pc, #380]	@ (340172b8 <RCCEx_GetXSPICLKFreq+0x210>)
3401713a:	4293      	cmp	r3, r2
3401713c:	f200 80a2 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
34017140:	4a5e      	ldr	r2, [pc, #376]	@ (340172bc <RCCEx_GetXSPICLKFreq+0x214>)
34017142:	4293      	cmp	r3, r2
34017144:	d00a      	beq.n	3401715c <RCCEx_GetXSPICLKFreq+0xb4>
34017146:	4a5d      	ldr	r2, [pc, #372]	@ (340172bc <RCCEx_GetXSPICLKFreq+0x214>)
34017148:	4293      	cmp	r3, r2
3401714a:	f200 809b 	bhi.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
3401714e:	4a5c      	ldr	r2, [pc, #368]	@ (340172c0 <RCCEx_GetXSPICLKFreq+0x218>)
34017150:	4293      	cmp	r3, r2
34017152:	d003      	beq.n	3401715c <RCCEx_GetXSPICLKFreq+0xb4>
34017154:	4a5b      	ldr	r2, [pc, #364]	@ (340172c4 <RCCEx_GetXSPICLKFreq+0x21c>)
34017156:	4293      	cmp	r3, r2
34017158:	f040 8094 	bne.w	34017284 <RCCEx_GetXSPICLKFreq+0x1dc>
  {
    case LL_RCC_XSPI1_CLKSOURCE_HCLK:
    case LL_RCC_XSPI2_CLKSOURCE_HCLK:
    case LL_RCC_XSPI3_CLKSOURCE_HCLK:
      xspi_frequency = RCCEx_GetHCLKFreq(HAL_RCC_GetSysClockFreq());
3401715c:	f7f7 fd10 	bl	3400eb80 <HAL_RCC_GetSysClockFreq>
34017160:	4603      	mov	r3, r0
34017162:	4618      	mov	r0, r3
34017164:	f7fc fc9c 	bl	34013aa0 <RCCEx_GetHCLKFreq>
34017168:	60f8      	str	r0, [r7, #12]
      break;
3401716a:	e090      	b.n	3401728e <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_CLKP:
    case LL_RCC_XSPI2_CLKSOURCE_CLKP:
    case LL_RCC_XSPI3_CLKSOURCE_CLKP:
      xspi_frequency = RCCEx_GetCLKPCLKFreq(LL_RCC_CLKP_CLKSOURCE);
3401716c:	2007      	movs	r0, #7
3401716e:	f7fc ff83 	bl	34014078 <RCCEx_GetCLKPCLKFreq>
34017172:	60f8      	str	r0, [r7, #12]
      break;
34017174:	e08b      	b.n	3401728e <RCCEx_GetXSPICLKFreq+0x1e6>

    case LL_RCC_XSPI1_CLKSOURCE_IC3:
    case LL_RCC_XSPI2_CLKSOURCE_IC3:
    case LL_RCC_XSPI3_CLKSOURCE_IC3:
      if (LL_RCC_IC3_IsEnabled() != 0U)
34017176:	f7f8 ffe7 	bl	34010148 <LL_RCC_IC3_IsEnabled>
3401717a:	4603      	mov	r3, r0
3401717c:	2b00      	cmp	r3, #0
3401717e:	f000 8083 	beq.w	34017288 <RCCEx_GetXSPICLKFreq+0x1e0>
      {
        ic_divider = LL_RCC_IC3_GetDivider();
34017182:	f7f9 f803 	bl	3401018c <LL_RCC_IC3_GetDivider>
34017186:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC3_GetSource())
34017188:	f7f8 fff2 	bl	34010170 <LL_RCC_IC3_GetSource>
3401718c:	4603      	mov	r3, r0
3401718e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017192:	d029      	beq.n	340171e8 <RCCEx_GetXSPICLKFreq+0x140>
34017194:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017198:	d82f      	bhi.n	340171fa <RCCEx_GetXSPICLKFreq+0x152>
3401719a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401719e:	d01a      	beq.n	340171d6 <RCCEx_GetXSPICLKFreq+0x12e>
340171a0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340171a4:	d829      	bhi.n	340171fa <RCCEx_GetXSPICLKFreq+0x152>
340171a6:	2b00      	cmp	r3, #0
340171a8:	d003      	beq.n	340171b2 <RCCEx_GetXSPICLKFreq+0x10a>
340171aa:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340171ae:	d009      	beq.n	340171c4 <RCCEx_GetXSPICLKFreq+0x11c>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
340171b0:	e023      	b.n	340171fa <RCCEx_GetXSPICLKFreq+0x152>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
340171b2:	f7fc fb5d 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
340171b6:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340171b8:	68fa      	ldr	r2, [r7, #12]
340171ba:	68bb      	ldr	r3, [r7, #8]
340171bc:	fbb2 f3f3 	udiv	r3, r2, r3
340171c0:	60fb      	str	r3, [r7, #12]
            break;
340171c2:	e01b      	b.n	340171fc <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
340171c4:	f7fc fb9a 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
340171c8:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340171ca:	68fa      	ldr	r2, [r7, #12]
340171cc:	68bb      	ldr	r3, [r7, #8]
340171ce:	fbb2 f3f3 	udiv	r3, r2, r3
340171d2:	60fb      	str	r3, [r7, #12]
            break;
340171d4:	e012      	b.n	340171fc <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
340171d6:	f7fc fbd7 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
340171da:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340171dc:	68fa      	ldr	r2, [r7, #12]
340171de:	68bb      	ldr	r3, [r7, #8]
340171e0:	fbb2 f3f3 	udiv	r3, r2, r3
340171e4:	60fb      	str	r3, [r7, #12]
            break;
340171e6:	e009      	b.n	340171fc <RCCEx_GetXSPICLKFreq+0x154>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
340171e8:	f7fc fc14 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
340171ec:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
340171ee:	68fa      	ldr	r2, [r7, #12]
340171f0:	68bb      	ldr	r3, [r7, #8]
340171f2:	fbb2 f3f3 	udiv	r3, r2, r3
340171f6:	60fb      	str	r3, [r7, #12]
            break;
340171f8:	e000      	b.n	340171fc <RCCEx_GetXSPICLKFreq+0x154>
            break;
340171fa:	bf00      	nop
        }
      }
      break;
340171fc:	e044      	b.n	34017288 <RCCEx_GetXSPICLKFreq+0x1e0>

    case LL_RCC_XSPI1_CLKSOURCE_IC4:
    case LL_RCC_XSPI2_CLKSOURCE_IC4:
    case LL_RCC_XSPI3_CLKSOURCE_IC4:
      if (LL_RCC_IC4_IsEnabled() != 0U)
340171fe:	f7f8 ffe3 	bl	340101c8 <LL_RCC_IC4_IsEnabled>
34017202:	4603      	mov	r3, r0
34017204:	2b00      	cmp	r3, #0
34017206:	d041      	beq.n	3401728c <RCCEx_GetXSPICLKFreq+0x1e4>
      {
        ic_divider = LL_RCC_IC4_GetDivider();
34017208:	f7f9 f800 	bl	3401020c <LL_RCC_IC4_GetDivider>
3401720c:	60b8      	str	r0, [r7, #8]
        switch (LL_RCC_IC4_GetSource())
3401720e:	f7f8 ffef 	bl	340101f0 <LL_RCC_IC4_GetSource>
34017212:	4603      	mov	r3, r0
34017214:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34017218:	d029      	beq.n	3401726e <RCCEx_GetXSPICLKFreq+0x1c6>
3401721a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3401721e:	d82f      	bhi.n	34017280 <RCCEx_GetXSPICLKFreq+0x1d8>
34017220:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34017224:	d01a      	beq.n	3401725c <RCCEx_GetXSPICLKFreq+0x1b4>
34017226:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3401722a:	d829      	bhi.n	34017280 <RCCEx_GetXSPICLKFreq+0x1d8>
3401722c:	2b00      	cmp	r3, #0
3401722e:	d003      	beq.n	34017238 <RCCEx_GetXSPICLKFreq+0x190>
34017230:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34017234:	d009      	beq.n	3401724a <RCCEx_GetXSPICLKFreq+0x1a2>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
            xspi_frequency = xspi_frequency / ic_divider;
            break;
          default:
            /* Unexpected case */
            break;
34017236:	e023      	b.n	34017280 <RCCEx_GetXSPICLKFreq+0x1d8>
            xspi_frequency = HAL_RCCEx_GetPLL1CLKFreq();
34017238:	f7fc fb1a 	bl	34013870 <HAL_RCCEx_GetPLL1CLKFreq>
3401723c:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
3401723e:	68fa      	ldr	r2, [r7, #12]
34017240:	68bb      	ldr	r3, [r7, #8]
34017242:	fbb2 f3f3 	udiv	r3, r2, r3
34017246:	60fb      	str	r3, [r7, #12]
            break;
34017248:	e01b      	b.n	34017282 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL2CLKFreq();
3401724a:	f7fc fb57 	bl	340138fc <HAL_RCCEx_GetPLL2CLKFreq>
3401724e:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34017250:	68fa      	ldr	r2, [r7, #12]
34017252:	68bb      	ldr	r3, [r7, #8]
34017254:	fbb2 f3f3 	udiv	r3, r2, r3
34017258:	60fb      	str	r3, [r7, #12]
            break;
3401725a:	e012      	b.n	34017282 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL3CLKFreq();
3401725c:	f7fc fb94 	bl	34013988 <HAL_RCCEx_GetPLL3CLKFreq>
34017260:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34017262:	68fa      	ldr	r2, [r7, #12]
34017264:	68bb      	ldr	r3, [r7, #8]
34017266:	fbb2 f3f3 	udiv	r3, r2, r3
3401726a:	60fb      	str	r3, [r7, #12]
            break;
3401726c:	e009      	b.n	34017282 <RCCEx_GetXSPICLKFreq+0x1da>
            xspi_frequency = HAL_RCCEx_GetPLL4CLKFreq();
3401726e:	f7fc fbd1 	bl	34013a14 <HAL_RCCEx_GetPLL4CLKFreq>
34017272:	60f8      	str	r0, [r7, #12]
            xspi_frequency = xspi_frequency / ic_divider;
34017274:	68fa      	ldr	r2, [r7, #12]
34017276:	68bb      	ldr	r3, [r7, #8]
34017278:	fbb2 f3f3 	udiv	r3, r2, r3
3401727c:	60fb      	str	r3, [r7, #12]
            break;
3401727e:	e000      	b.n	34017282 <RCCEx_GetXSPICLKFreq+0x1da>
            break;
34017280:	bf00      	nop
        }
      }
      break;
34017282:	e003      	b.n	3401728c <RCCEx_GetXSPICLKFreq+0x1e4>

    default:
      /* Nothing to do */
      break;
34017284:	bf00      	nop
34017286:	e002      	b.n	3401728e <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
34017288:	bf00      	nop
3401728a:	e000      	b.n	3401728e <RCCEx_GetXSPICLKFreq+0x1e6>
      break;
3401728c:	bf00      	nop
  }

  return xspi_frequency;
3401728e:	68fb      	ldr	r3, [r7, #12]
}
34017290:	4618      	mov	r0, r3
34017292:	3710      	adds	r7, #16
34017294:	46bd      	mov	sp, r7
34017296:	bd80      	pop	{r7, pc}
34017298:	03030814 	.word	0x03030814
3401729c:	03030414 	.word	0x03030414
340172a0:	03030014 	.word	0x03030014
340172a4:	03020814 	.word	0x03020814
340172a8:	03020414 	.word	0x03020414
340172ac:	03020014 	.word	0x03020014
340172b0:	03010814 	.word	0x03010814
340172b4:	03010414 	.word	0x03010414
340172b8:	03010014 	.word	0x03010014
340172bc:	03000814 	.word	0x03000814
340172c0:	03000014 	.word	0x03000014
340172c4:	03000414 	.word	0x03000414

340172c8 <HAL_RIF_RIMC_ConfigMasterAttributes>:
  *         This parameter can be one of @ref RIF_MASTER_INDEX
  * @param  pConfig Pointer on Master Isolation configuration structure
  * @retval None
  */
void HAL_RIF_RIMC_ConfigMasterAttributes(uint32_t MasterId, const RIMC_MasterConfig_t *pConfig)
{
340172c8:	b480      	push	{r7}
340172ca:	b089      	sub	sp, #36	@ 0x24
340172cc:	af00      	add	r7, sp, #0
340172ce:	6078      	str	r0, [r7, #4]
340172d0:	6039      	str	r1, [r7, #0]
  assert_param(IS_RIF_MASTER_INDEX(MasterId));
  assert_param(IS_RIF_SINGLE_CID(pConfig->MasterCID));
  assert_param(IS_RIF_MASTER_CID(pConfig->MasterCID));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(pConfig->SecPriv));

  master_cid = POSITION_VAL(pConfig->MasterCID);
340172d2:	683b      	ldr	r3, [r7, #0]
340172d4:	681b      	ldr	r3, [r3, #0]
340172d6:	613b      	str	r3, [r7, #16]
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
340172d8:	693b      	ldr	r3, [r7, #16]
340172da:	fa93 f3a3 	rbit	r3, r3
340172de:	60fb      	str	r3, [r7, #12]
  return result;
340172e0:	68fb      	ldr	r3, [r7, #12]
340172e2:	617b      	str	r3, [r7, #20]
  if (value == 0U)
340172e4:	697b      	ldr	r3, [r7, #20]
340172e6:	2b00      	cmp	r3, #0
340172e8:	d101      	bne.n	340172ee <HAL_RIF_RIMC_ConfigMasterAttributes+0x26>
    return 32U;
340172ea:	2320      	movs	r3, #32
340172ec:	e003      	b.n	340172f6 <HAL_RIF_RIMC_ConfigMasterAttributes+0x2e>
  return __builtin_clz(value);
340172ee:	697b      	ldr	r3, [r7, #20]
340172f0:	fab3 f383 	clz	r3, r3
340172f4:	b2db      	uxtb	r3, r3
340172f6:	61fb      	str	r3, [r7, #28]
  rimc_attr_val = RIFSC->RIMC_ATTRx[MasterId];
340172f8:	4a10      	ldr	r2, [pc, #64]	@ (3401733c <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
340172fa:	687b      	ldr	r3, [r7, #4]
340172fc:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34017300:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34017304:	61bb      	str	r3, [r7, #24]
  rimc_attr_val &= (~(RIFSC_RIMC_ATTRx_MCID | RIFSC_RIMC_ATTRx_MPRIV | RIFSC_RIMC_ATTRx_MSEC));
34017306:	69bb      	ldr	r3, [r7, #24]
34017308:	f423 735c 	bic.w	r3, r3, #880	@ 0x370
3401730c:	61bb      	str	r3, [r7, #24]
  rimc_attr_val |= ((master_cid << RIFSC_RIMC_ATTRx_MCID_Pos) | (pConfig->SecPriv << RIFSC_RIMC_ATTRx_MSEC_Pos));
3401730e:	69fb      	ldr	r3, [r7, #28]
34017310:	011a      	lsls	r2, r3, #4
34017312:	683b      	ldr	r3, [r7, #0]
34017314:	685b      	ldr	r3, [r3, #4]
34017316:	021b      	lsls	r3, r3, #8
34017318:	4313      	orrs	r3, r2
3401731a:	69ba      	ldr	r2, [r7, #24]
3401731c:	4313      	orrs	r3, r2
3401731e:	61bb      	str	r3, [r7, #24]
  RIFSC->RIMC_ATTRx[MasterId] = rimc_attr_val;
34017320:	4906      	ldr	r1, [pc, #24]	@ (3401733c <HAL_RIF_RIMC_ConfigMasterAttributes+0x74>)
34017322:	687b      	ldr	r3, [r7, #4]
34017324:	f503 7341 	add.w	r3, r3, #772	@ 0x304
34017328:	69ba      	ldr	r2, [r7, #24]
3401732a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3401732e:	bf00      	nop
34017330:	3724      	adds	r7, #36	@ 0x24
34017332:	46bd      	mov	sp, r7
34017334:	f85d 7b04 	ldr.w	r7, [sp], #4
34017338:	4770      	bx	lr
3401733a:	bf00      	nop
3401733c:	54024000 	.word	0x54024000

34017340 <HAL_RIF_RISC_SetSlaveSecureAttributes>:
  * @param  SecPriv specifies the security and privilege attributes of the peripheral.
  *         This parameter can be one or a combination of @ref RIF_SEC_PRIV
  * @retval None
  */
void HAL_RIF_RISC_SetSlaveSecureAttributes(uint32_t PeriphId, uint32_t SecPriv)
{
34017340:	b480      	push	{r7}
34017342:	b085      	sub	sp, #20
34017344:	af00      	add	r7, sp, #0
34017346:	6078      	str	r0, [r7, #4]
34017348:	6039      	str	r1, [r7, #0]
  __IO uint32_t sec_reg_val;

  assert_param(IS_RIF_RISC_PERIPH_INDEX(PeriphId) || IS_RIF_RCC_PERIPH_INDEX(PeriphId));
  assert_param(IS_RIF_SEC_PRIV_ATTRIBUTE(SecPriv));

  sec_reg_val = RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3401734a:	4a25      	ldr	r2, [pc, #148]	@ (340173e0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
3401734c:	687b      	ldr	r3, [r7, #4]
3401734e:	0f1b      	lsrs	r3, r3, #28
34017350:	3304      	adds	r3, #4
34017352:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34017356:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
34017358:	687b      	ldr	r3, [r7, #4]
3401735a:	f003 031f 	and.w	r3, r3, #31
3401735e:	2201      	movs	r2, #1
34017360:	fa02 f303 	lsl.w	r3, r2, r3
34017364:	43da      	mvns	r2, r3
34017366:	68fb      	ldr	r3, [r7, #12]
34017368:	4013      	ands	r3, r2
3401736a:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= ((SecPriv & RIF_ATTRIBUTE_SEC) << (PeriphId & RIF_PERIPH_BIT_POSITION));
3401736c:	683b      	ldr	r3, [r7, #0]
3401736e:	f003 0201 	and.w	r2, r3, #1
34017372:	687b      	ldr	r3, [r7, #4]
34017374:	f003 031f 	and.w	r3, r3, #31
34017378:	409a      	lsls	r2, r3
3401737a:	68fb      	ldr	r3, [r7, #12]
3401737c:	4313      	orrs	r3, r2
3401737e:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_SECCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
34017380:	4917      	ldr	r1, [pc, #92]	@ (340173e0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34017382:	687b      	ldr	r3, [r7, #4]
34017384:	0f1b      	lsrs	r3, r3, #28
34017386:	68fa      	ldr	r2, [r7, #12]
34017388:	3304      	adds	r3, #4
3401738a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  sec_reg_val = RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT];
3401738e:	4a14      	ldr	r2, [pc, #80]	@ (340173e0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
34017390:	687b      	ldr	r3, [r7, #4]
34017392:	0f1b      	lsrs	r3, r3, #28
34017394:	330c      	adds	r3, #12
34017396:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3401739a:	60fb      	str	r3, [r7, #12]
  sec_reg_val &= (~(1U << (PeriphId & RIF_PERIPH_BIT_POSITION)));
3401739c:	687b      	ldr	r3, [r7, #4]
3401739e:	f003 031f 	and.w	r3, r3, #31
340173a2:	2201      	movs	r2, #1
340173a4:	fa02 f303 	lsl.w	r3, r2, r3
340173a8:	43da      	mvns	r2, r3
340173aa:	68fb      	ldr	r3, [r7, #12]
340173ac:	4013      	ands	r3, r2
340173ae:	60fb      	str	r3, [r7, #12]
  sec_reg_val |= (((SecPriv & RIF_ATTRIBUTE_PRIV) >> 1U) << (PeriphId & RIF_PERIPH_BIT_POSITION));
340173b0:	683b      	ldr	r3, [r7, #0]
340173b2:	085b      	lsrs	r3, r3, #1
340173b4:	f003 0201 	and.w	r2, r3, #1
340173b8:	687b      	ldr	r3, [r7, #4]
340173ba:	f003 031f 	and.w	r3, r3, #31
340173be:	409a      	lsls	r2, r3
340173c0:	68fb      	ldr	r3, [r7, #12]
340173c2:	4313      	orrs	r3, r2
340173c4:	60fb      	str	r3, [r7, #12]
  RIFSC->RISC_PRIVCFGRx[PeriphId >> RIF_PERIPH_REG_SHIFT] = sec_reg_val;
340173c6:	4906      	ldr	r1, [pc, #24]	@ (340173e0 <HAL_RIF_RISC_SetSlaveSecureAttributes+0xa0>)
340173c8:	687b      	ldr	r3, [r7, #4]
340173ca:	0f1b      	lsrs	r3, r3, #28
340173cc:	68fa      	ldr	r2, [r7, #12]
340173ce:	330c      	adds	r3, #12
340173d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
340173d4:	bf00      	nop
340173d6:	3714      	adds	r7, #20
340173d8:	46bd      	mov	sp, r7
340173da:	f85d 7b04 	ldr.w	r7, [sp], #4
340173de:	4770      	bx	lr
340173e0:	54024000 	.word	0x54024000

340173e4 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
340173e4:	b580      	push	{r7, lr}
340173e6:	b082      	sub	sp, #8
340173e8:	af00      	add	r7, sp, #0
340173ea:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
340173ec:	687b      	ldr	r3, [r7, #4]
340173ee:	2b00      	cmp	r3, #0
340173f0:	d101      	bne.n	340173f6 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
340173f2:	2301      	movs	r3, #1
340173f4:	e042      	b.n	3401747c <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
340173f6:	687b      	ldr	r3, [r7, #4]
340173f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340173fc:	2b00      	cmp	r3, #0
340173fe:	d106      	bne.n	3401740e <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
34017400:	687b      	ldr	r3, [r7, #4]
34017402:	2200      	movs	r2, #0
34017404:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
34017408:	6878      	ldr	r0, [r7, #4]
3401740a:	f7ed fa99 	bl	34004940 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
3401740e:	687b      	ldr	r3, [r7, #4]
34017410:	2224      	movs	r2, #36	@ 0x24
34017412:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
34017416:	687b      	ldr	r3, [r7, #4]
34017418:	681b      	ldr	r3, [r3, #0]
3401741a:	681a      	ldr	r2, [r3, #0]
3401741c:	687b      	ldr	r3, [r7, #4]
3401741e:	681b      	ldr	r3, [r3, #0]
34017420:	f022 0201 	bic.w	r2, r2, #1
34017424:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
34017426:	687b      	ldr	r3, [r7, #4]
34017428:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401742a:	2b00      	cmp	r3, #0
3401742c:	d002      	beq.n	34017434 <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
3401742e:	6878      	ldr	r0, [r7, #4]
34017430:	f000 faa2 	bl	34017978 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
34017434:	6878      	ldr	r0, [r7, #4]
34017436:	f000 f8b3 	bl	340175a0 <UART_SetConfig>
3401743a:	4603      	mov	r3, r0
3401743c:	2b01      	cmp	r3, #1
3401743e:	d101      	bne.n	34017444 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
34017440:	2301      	movs	r3, #1
34017442:	e01b      	b.n	3401747c <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
34017444:	687b      	ldr	r3, [r7, #4]
34017446:	681b      	ldr	r3, [r3, #0]
34017448:	685a      	ldr	r2, [r3, #4]
3401744a:	687b      	ldr	r3, [r7, #4]
3401744c:	681b      	ldr	r3, [r3, #0]
3401744e:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
34017452:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
34017454:	687b      	ldr	r3, [r7, #4]
34017456:	681b      	ldr	r3, [r3, #0]
34017458:	689a      	ldr	r2, [r3, #8]
3401745a:	687b      	ldr	r3, [r7, #4]
3401745c:	681b      	ldr	r3, [r3, #0]
3401745e:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
34017462:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
34017464:	687b      	ldr	r3, [r7, #4]
34017466:	681b      	ldr	r3, [r3, #0]
34017468:	681a      	ldr	r2, [r3, #0]
3401746a:	687b      	ldr	r3, [r7, #4]
3401746c:	681b      	ldr	r3, [r3, #0]
3401746e:	f042 0201 	orr.w	r2, r2, #1
34017472:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
34017474:	6878      	ldr	r0, [r7, #4]
34017476:	f000 fb21 	bl	34017abc <UART_CheckIdleState>
3401747a:	4603      	mov	r3, r0
}
3401747c:	4618      	mov	r0, r3
3401747e:	3708      	adds	r7, #8
34017480:	46bd      	mov	sp, r7
34017482:	bd80      	pop	{r7, pc}

34017484 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
34017484:	b580      	push	{r7, lr}
34017486:	b08a      	sub	sp, #40	@ 0x28
34017488:	af02      	add	r7, sp, #8
3401748a:	60f8      	str	r0, [r7, #12]
3401748c:	60b9      	str	r1, [r7, #8]
3401748e:	603b      	str	r3, [r7, #0]
34017490:	4613      	mov	r3, r2
34017492:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
34017494:	68fb      	ldr	r3, [r7, #12]
34017496:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
3401749a:	2b20      	cmp	r3, #32
3401749c:	d17b      	bne.n	34017596 <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
3401749e:	68bb      	ldr	r3, [r7, #8]
340174a0:	2b00      	cmp	r3, #0
340174a2:	d002      	beq.n	340174aa <HAL_UART_Transmit+0x26>
340174a4:	88fb      	ldrh	r3, [r7, #6]
340174a6:	2b00      	cmp	r3, #0
340174a8:	d101      	bne.n	340174ae <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
340174aa:	2301      	movs	r3, #1
340174ac:	e074      	b.n	34017598 <HAL_UART_Transmit+0x114>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
340174ae:	68fb      	ldr	r3, [r7, #12]
340174b0:	2200      	movs	r2, #0
340174b2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
340174b6:	68fb      	ldr	r3, [r7, #12]
340174b8:	2221      	movs	r2, #33	@ 0x21
340174ba:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
340174be:	f7ed fbb6 	bl	34004c2e <HAL_GetTick>
340174c2:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
340174c4:	68fb      	ldr	r3, [r7, #12]
340174c6:	88fa      	ldrh	r2, [r7, #6]
340174c8:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
340174cc:	68fb      	ldr	r3, [r7, #12]
340174ce:	88fa      	ldrh	r2, [r7, #6]
340174d0:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
340174d4:	68fb      	ldr	r3, [r7, #12]
340174d6:	689b      	ldr	r3, [r3, #8]
340174d8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340174dc:	d108      	bne.n	340174f0 <HAL_UART_Transmit+0x6c>
340174de:	68fb      	ldr	r3, [r7, #12]
340174e0:	691b      	ldr	r3, [r3, #16]
340174e2:	2b00      	cmp	r3, #0
340174e4:	d104      	bne.n	340174f0 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
340174e6:	2300      	movs	r3, #0
340174e8:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
340174ea:	68bb      	ldr	r3, [r7, #8]
340174ec:	61bb      	str	r3, [r7, #24]
340174ee:	e003      	b.n	340174f8 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
340174f0:	68bb      	ldr	r3, [r7, #8]
340174f2:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
340174f4:	2300      	movs	r3, #0
340174f6:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
340174f8:	e030      	b.n	3401755c <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
340174fa:	683b      	ldr	r3, [r7, #0]
340174fc:	9300      	str	r3, [sp, #0]
340174fe:	697b      	ldr	r3, [r7, #20]
34017500:	2200      	movs	r2, #0
34017502:	2180      	movs	r1, #128	@ 0x80
34017504:	68f8      	ldr	r0, [r7, #12]
34017506:	f000 fb83 	bl	34017c10 <UART_WaitOnFlagUntilTimeout>
3401750a:	4603      	mov	r3, r0
3401750c:	2b00      	cmp	r3, #0
3401750e:	d005      	beq.n	3401751c <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
34017510:	68fb      	ldr	r3, [r7, #12]
34017512:	2220      	movs	r2, #32
34017514:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
34017518:	2303      	movs	r3, #3
3401751a:	e03d      	b.n	34017598 <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
3401751c:	69fb      	ldr	r3, [r7, #28]
3401751e:	2b00      	cmp	r3, #0
34017520:	d10b      	bne.n	3401753a <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
34017522:	69bb      	ldr	r3, [r7, #24]
34017524:	881b      	ldrh	r3, [r3, #0]
34017526:	461a      	mov	r2, r3
34017528:	68fb      	ldr	r3, [r7, #12]
3401752a:	681b      	ldr	r3, [r3, #0]
3401752c:	f3c2 0208 	ubfx	r2, r2, #0, #9
34017530:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
34017532:	69bb      	ldr	r3, [r7, #24]
34017534:	3302      	adds	r3, #2
34017536:	61bb      	str	r3, [r7, #24]
34017538:	e007      	b.n	3401754a <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
3401753a:	69fb      	ldr	r3, [r7, #28]
3401753c:	781a      	ldrb	r2, [r3, #0]
3401753e:	68fb      	ldr	r3, [r7, #12]
34017540:	681b      	ldr	r3, [r3, #0]
34017542:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
34017544:	69fb      	ldr	r3, [r7, #28]
34017546:	3301      	adds	r3, #1
34017548:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
3401754a:	68fb      	ldr	r3, [r7, #12]
3401754c:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
34017550:	b29b      	uxth	r3, r3
34017552:	3b01      	subs	r3, #1
34017554:	b29a      	uxth	r2, r3
34017556:	68fb      	ldr	r3, [r7, #12]
34017558:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
3401755c:	68fb      	ldr	r3, [r7, #12]
3401755e:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
34017562:	b29b      	uxth	r3, r3
34017564:	2b00      	cmp	r3, #0
34017566:	d1c8      	bne.n	340174fa <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
34017568:	683b      	ldr	r3, [r7, #0]
3401756a:	9300      	str	r3, [sp, #0]
3401756c:	697b      	ldr	r3, [r7, #20]
3401756e:	2200      	movs	r2, #0
34017570:	2140      	movs	r1, #64	@ 0x40
34017572:	68f8      	ldr	r0, [r7, #12]
34017574:	f000 fb4c 	bl	34017c10 <UART_WaitOnFlagUntilTimeout>
34017578:	4603      	mov	r3, r0
3401757a:	2b00      	cmp	r3, #0
3401757c:	d005      	beq.n	3401758a <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
3401757e:	68fb      	ldr	r3, [r7, #12]
34017580:	2220      	movs	r2, #32
34017582:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
34017586:	2303      	movs	r3, #3
34017588:	e006      	b.n	34017598 <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
3401758a:	68fb      	ldr	r3, [r7, #12]
3401758c:	2220      	movs	r2, #32
3401758e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
34017592:	2300      	movs	r3, #0
34017594:	e000      	b.n	34017598 <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
34017596:	2302      	movs	r3, #2
  }
}
34017598:	4618      	mov	r0, r3
3401759a:	3720      	adds	r7, #32
3401759c:	46bd      	mov	sp, r7
3401759e:	bd80      	pop	{r7, pc}

340175a0 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
340175a0:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
340175a4:	b090      	sub	sp, #64	@ 0x40
340175a6:	af00      	add	r7, sp, #0
340175a8:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  uint64_t clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
340175aa:	2300      	movs	r3, #0
340175ac:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
340175b0:	697b      	ldr	r3, [r7, #20]
340175b2:	681b      	ldr	r3, [r3, #0]
340175b4:	4aa3      	ldr	r2, [pc, #652]	@ (34017844 <UART_SetConfig+0x2a4>)
340175b6:	4293      	cmp	r3, r2
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
340175b8:	697b      	ldr	r3, [r7, #20]
340175ba:	689a      	ldr	r2, [r3, #8]
340175bc:	697b      	ldr	r3, [r7, #20]
340175be:	691b      	ldr	r3, [r3, #16]
340175c0:	431a      	orrs	r2, r3
340175c2:	697b      	ldr	r3, [r7, #20]
340175c4:	695b      	ldr	r3, [r3, #20]
340175c6:	431a      	orrs	r2, r3
340175c8:	697b      	ldr	r3, [r7, #20]
340175ca:	69db      	ldr	r3, [r3, #28]
340175cc:	4313      	orrs	r3, r2
340175ce:	63fb      	str	r3, [r7, #60]	@ 0x3c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
340175d0:	697b      	ldr	r3, [r7, #20]
340175d2:	681b      	ldr	r3, [r3, #0]
340175d4:	681a      	ldr	r2, [r3, #0]
340175d6:	4b9c      	ldr	r3, [pc, #624]	@ (34017848 <UART_SetConfig+0x2a8>)
340175d8:	4013      	ands	r3, r2
340175da:	697a      	ldr	r2, [r7, #20]
340175dc:	6812      	ldr	r2, [r2, #0]
340175de:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
340175e0:	430b      	orrs	r3, r1
340175e2:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
340175e4:	697b      	ldr	r3, [r7, #20]
340175e6:	681b      	ldr	r3, [r3, #0]
340175e8:	685b      	ldr	r3, [r3, #4]
340175ea:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
340175ee:	697b      	ldr	r3, [r7, #20]
340175f0:	68da      	ldr	r2, [r3, #12]
340175f2:	697b      	ldr	r3, [r7, #20]
340175f4:	681b      	ldr	r3, [r3, #0]
340175f6:	430a      	orrs	r2, r1
340175f8:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
340175fa:	697b      	ldr	r3, [r7, #20]
340175fc:	699b      	ldr	r3, [r3, #24]
340175fe:	63fb      	str	r3, [r7, #60]	@ 0x3c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
34017600:	697b      	ldr	r3, [r7, #20]
34017602:	681b      	ldr	r3, [r3, #0]
34017604:	4a8f      	ldr	r2, [pc, #572]	@ (34017844 <UART_SetConfig+0x2a4>)
34017606:	4293      	cmp	r3, r2
34017608:	d009      	beq.n	3401761e <UART_SetConfig+0x7e>
3401760a:	697b      	ldr	r3, [r7, #20]
3401760c:	681b      	ldr	r3, [r3, #0]
3401760e:	4a8f      	ldr	r2, [pc, #572]	@ (3401784c <UART_SetConfig+0x2ac>)
34017610:	4293      	cmp	r3, r2
34017612:	d004      	beq.n	3401761e <UART_SetConfig+0x7e>
  {
    tmpreg |= huart->Init.OneBitSampling;
34017614:	697b      	ldr	r3, [r7, #20]
34017616:	6a1b      	ldr	r3, [r3, #32]
34017618:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3401761a:	4313      	orrs	r3, r2
3401761c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
3401761e:	697b      	ldr	r3, [r7, #20]
34017620:	681b      	ldr	r3, [r3, #0]
34017622:	689b      	ldr	r3, [r3, #8]
34017624:	f023 436e 	bic.w	r3, r3, #3992977408	@ 0xee000000
34017628:	f423 6330 	bic.w	r3, r3, #2816	@ 0xb00
3401762c:	697a      	ldr	r2, [r7, #20]
3401762e:	6812      	ldr	r2, [r2, #0]
34017630:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
34017632:	430b      	orrs	r3, r1
34017634:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
34017636:	697b      	ldr	r3, [r7, #20]
34017638:	681b      	ldr	r3, [r3, #0]
3401763a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401763c:	f023 010f 	bic.w	r1, r3, #15
34017640:	697b      	ldr	r3, [r7, #20]
34017642:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34017644:	697b      	ldr	r3, [r7, #20]
34017646:	681b      	ldr	r3, [r3, #0]
34017648:	430a      	orrs	r2, r1
3401764a:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
3401764c:	697b      	ldr	r3, [r7, #20]
3401764e:	681b      	ldr	r3, [r3, #0]
34017650:	4a7f      	ldr	r2, [pc, #508]	@ (34017850 <UART_SetConfig+0x2b0>)
34017652:	4293      	cmp	r3, r2
34017654:	d106      	bne.n	34017664 <UART_SetConfig+0xc4>
34017656:	f04f 0200 	mov.w	r2, #0
3401765a:	f44f 7380 	mov.w	r3, #256	@ 0x100
3401765e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34017662:	e07d      	b.n	34017760 <UART_SetConfig+0x1c0>
34017664:	697b      	ldr	r3, [r7, #20]
34017666:	681b      	ldr	r3, [r3, #0]
34017668:	4a7a      	ldr	r2, [pc, #488]	@ (34017854 <UART_SetConfig+0x2b4>)
3401766a:	4293      	cmp	r3, r2
3401766c:	d106      	bne.n	3401767c <UART_SetConfig+0xdc>
3401766e:	f04f 0200 	mov.w	r2, #0
34017672:	f44f 7300 	mov.w	r3, #512	@ 0x200
34017676:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401767a:	e071      	b.n	34017760 <UART_SetConfig+0x1c0>
3401767c:	697b      	ldr	r3, [r7, #20]
3401767e:	681b      	ldr	r3, [r3, #0]
34017680:	4a75      	ldr	r2, [pc, #468]	@ (34017858 <UART_SetConfig+0x2b8>)
34017682:	4293      	cmp	r3, r2
34017684:	d106      	bne.n	34017694 <UART_SetConfig+0xf4>
34017686:	f04f 0200 	mov.w	r2, #0
3401768a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
3401768e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34017692:	e065      	b.n	34017760 <UART_SetConfig+0x1c0>
34017694:	697b      	ldr	r3, [r7, #20]
34017696:	681b      	ldr	r3, [r3, #0]
34017698:	4a70      	ldr	r2, [pc, #448]	@ (3401785c <UART_SetConfig+0x2bc>)
3401769a:	4293      	cmp	r3, r2
3401769c:	d106      	bne.n	340176ac <UART_SetConfig+0x10c>
3401769e:	f04f 0200 	mov.w	r2, #0
340176a2:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340176a6:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340176aa:	e059      	b.n	34017760 <UART_SetConfig+0x1c0>
340176ac:	697b      	ldr	r3, [r7, #20]
340176ae:	681b      	ldr	r3, [r3, #0]
340176b0:	f1b3 2f50 	cmp.w	r3, #1342197760	@ 0x50005000
340176b4:	d106      	bne.n	340176c4 <UART_SetConfig+0x124>
340176b6:	f04f 0200 	mov.w	r2, #0
340176ba:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
340176be:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340176c2:	e04d      	b.n	34017760 <UART_SetConfig+0x1c0>
340176c4:	697b      	ldr	r3, [r7, #20]
340176c6:	681b      	ldr	r3, [r3, #0]
340176c8:	4a65      	ldr	r2, [pc, #404]	@ (34017860 <UART_SetConfig+0x2c0>)
340176ca:	4293      	cmp	r3, r2
340176cc:	d106      	bne.n	340176dc <UART_SetConfig+0x13c>
340176ce:	f04f 0200 	mov.w	r2, #0
340176d2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340176d6:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340176da:	e041      	b.n	34017760 <UART_SetConfig+0x1c0>
340176dc:	697b      	ldr	r3, [r7, #20]
340176de:	681b      	ldr	r3, [r3, #0]
340176e0:	4a60      	ldr	r2, [pc, #384]	@ (34017864 <UART_SetConfig+0x2c4>)
340176e2:	4293      	cmp	r3, r2
340176e4:	d106      	bne.n	340176f4 <UART_SetConfig+0x154>
340176e6:	f04f 0200 	mov.w	r2, #0
340176ea:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
340176ee:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
340176f2:	e035      	b.n	34017760 <UART_SetConfig+0x1c0>
340176f4:	697b      	ldr	r3, [r7, #20]
340176f6:	681b      	ldr	r3, [r3, #0]
340176f8:	4a5b      	ldr	r2, [pc, #364]	@ (34017868 <UART_SetConfig+0x2c8>)
340176fa:	4293      	cmp	r3, r2
340176fc:	d106      	bne.n	3401770c <UART_SetConfig+0x16c>
340176fe:	f04f 0200 	mov.w	r2, #0
34017702:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
34017706:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401770a:	e029      	b.n	34017760 <UART_SetConfig+0x1c0>
3401770c:	697b      	ldr	r3, [r7, #20]
3401770e:	681b      	ldr	r3, [r3, #0]
34017710:	4a56      	ldr	r2, [pc, #344]	@ (3401786c <UART_SetConfig+0x2cc>)
34017712:	4293      	cmp	r3, r2
34017714:	d106      	bne.n	34017724 <UART_SetConfig+0x184>
34017716:	f04f 0200 	mov.w	r2, #0
3401771a:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
3401771e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34017722:	e01d      	b.n	34017760 <UART_SetConfig+0x1c0>
34017724:	697b      	ldr	r3, [r7, #20]
34017726:	681b      	ldr	r3, [r3, #0]
34017728:	4a51      	ldr	r2, [pc, #324]	@ (34017870 <UART_SetConfig+0x2d0>)
3401772a:	4293      	cmp	r3, r2
3401772c:	d106      	bne.n	3401773c <UART_SetConfig+0x19c>
3401772e:	f04f 0200 	mov.w	r2, #0
34017732:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
34017736:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
3401773a:	e011      	b.n	34017760 <UART_SetConfig+0x1c0>
3401773c:	697b      	ldr	r3, [r7, #20]
3401773e:	681b      	ldr	r3, [r3, #0]
34017740:	4a40      	ldr	r2, [pc, #256]	@ (34017844 <UART_SetConfig+0x2a4>)
34017742:	4293      	cmp	r3, r2
34017744:	d106      	bne.n	34017754 <UART_SetConfig+0x1b4>
34017746:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
3401774a:	f04f 0300 	mov.w	r3, #0
3401774e:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30
34017752:	e005      	b.n	34017760 <UART_SetConfig+0x1c0>
34017754:	f04f 0200 	mov.w	r2, #0
34017758:	f04f 0300 	mov.w	r3, #0
3401775c:	e9c7 230c 	strd	r2, r3, [r7, #48]	@ 0x30

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
34017760:	697b      	ldr	r3, [r7, #20]
34017762:	681b      	ldr	r3, [r3, #0]
34017764:	4a37      	ldr	r2, [pc, #220]	@ (34017844 <UART_SetConfig+0x2a4>)
34017766:	4293      	cmp	r3, r2
34017768:	d005      	beq.n	34017776 <UART_SetConfig+0x1d6>
3401776a:	697b      	ldr	r3, [r7, #20]
3401776c:	681b      	ldr	r3, [r3, #0]
3401776e:	4a37      	ldr	r2, [pc, #220]	@ (3401784c <UART_SetConfig+0x2ac>)
34017770:	4293      	cmp	r3, r2
34017772:	f040 8081 	bne.w	34017878 <UART_SetConfig+0x2d8>
  {
    /* Retrieve frequency clock */
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34017776:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3401777a:	f7fb fbdd 	bl	34012f38 <HAL_RCCEx_GetPeriphCLKFreq>
3401777e:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* If proper clock source reported */
    if (pclk != 0U)
34017780:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34017782:	2b00      	cmp	r3, #0
34017784:	f000 80e0 	beq.w	34017948 <UART_SetConfig+0x3a8>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
34017788:	697b      	ldr	r3, [r7, #20]
3401778a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401778c:	4a39      	ldr	r2, [pc, #228]	@ (34017874 <UART_SetConfig+0x2d4>)
3401778e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
34017792:	461a      	mov	r2, r3
34017794:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34017796:	fbb3 f3f2 	udiv	r3, r3, r2
3401779a:	61fb      	str	r3, [r7, #28]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
3401779c:	697b      	ldr	r3, [r7, #20]
3401779e:	685a      	ldr	r2, [r3, #4]
340177a0:	4613      	mov	r3, r2
340177a2:	005b      	lsls	r3, r3, #1
340177a4:	4413      	add	r3, r2
340177a6:	69fa      	ldr	r2, [r7, #28]
340177a8:	429a      	cmp	r2, r3
340177aa:	d305      	bcc.n	340177b8 <UART_SetConfig+0x218>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
340177ac:	697b      	ldr	r3, [r7, #20]
340177ae:	685b      	ldr	r3, [r3, #4]
340177b0:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
340177b2:	69fa      	ldr	r2, [r7, #28]
340177b4:	429a      	cmp	r2, r3
340177b6:	d903      	bls.n	340177c0 <UART_SetConfig+0x220>
      {
        ret = HAL_ERROR;
340177b8:	2301      	movs	r3, #1
340177ba:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
340177be:	e040      	b.n	34017842 <UART_SetConfig+0x2a2>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
340177c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340177c2:	2200      	movs	r2, #0
340177c4:	60bb      	str	r3, [r7, #8]
340177c6:	60fa      	str	r2, [r7, #12]
340177c8:	697b      	ldr	r3, [r7, #20]
340177ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340177cc:	4a29      	ldr	r2, [pc, #164]	@ (34017874 <UART_SetConfig+0x2d4>)
340177ce:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
340177d2:	b29b      	uxth	r3, r3
340177d4:	2200      	movs	r2, #0
340177d6:	603b      	str	r3, [r7, #0]
340177d8:	607a      	str	r2, [r7, #4]
340177da:	e9d7 2300 	ldrd	r2, r3, [r7]
340177de:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
340177e2:	f7ea f9e7 	bl	34001bb4 <__aeabi_uldivmod>
340177e6:	4602      	mov	r2, r0
340177e8:	460b      	mov	r3, r1
340177ea:	ea52 230f 	orrs.w	r3, r2, pc, lsl #8
340177ee:	6979      	ldr	r1, [r7, #20]
340177f0:	6849      	ldr	r1, [r1, #4]
340177f2:	0849      	lsrs	r1, r1, #1
340177f4:	2000      	movs	r0, #0
340177f6:	460c      	mov	r4, r1
340177f8:	4605      	mov	r5, r0
340177fa:	eb12 0804 	adds.w	r8, r2, r4
340177fe:	eb43 0905 	adc.w	r9, r3, r5
34017802:	697b      	ldr	r3, [r7, #20]
34017804:	685b      	ldr	r3, [r3, #4]
34017806:	2200      	movs	r2, #0
34017808:	469a      	mov	sl, r3
3401780a:	4693      	mov	fp, r2
3401780c:	4652      	mov	r2, sl
3401780e:	465b      	mov	r3, fp
34017810:	4640      	mov	r0, r8
34017812:	4649      	mov	r1, r9
34017814:	f7ea f9ce 	bl	34001bb4 <__aeabi_uldivmod>
34017818:	4602      	mov	r2, r0
3401781a:	460b      	mov	r3, r1
3401781c:	4613      	mov	r3, r2
3401781e:	627b      	str	r3, [r7, #36]	@ 0x24
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
34017820:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34017822:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34017826:	d308      	bcc.n	3401783a <UART_SetConfig+0x29a>
34017828:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401782a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3401782e:	d204      	bcs.n	3401783a <UART_SetConfig+0x29a>
        {
          huart->Instance->BRR = usartdiv;
34017830:	697b      	ldr	r3, [r7, #20]
34017832:	681b      	ldr	r3, [r3, #0]
34017834:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34017836:	60da      	str	r2, [r3, #12]
34017838:	e003      	b.n	34017842 <UART_SetConfig+0x2a2>
        }
        else
        {
          ret = HAL_ERROR;
3401783a:	2301      	movs	r3, #1
3401783c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if (pclk != 0U)
34017840:	e082      	b.n	34017948 <UART_SetConfig+0x3a8>
34017842:	e081      	b.n	34017948 <UART_SetConfig+0x3a8>
34017844:	56000c00 	.word	0x56000c00
34017848:	cfff69f3 	.word	0xcfff69f3
3401784c:	46000c00 	.word	0x46000c00
34017850:	52001000 	.word	0x52001000
34017854:	50004400 	.word	0x50004400
34017858:	50004800 	.word	0x50004800
3401785c:	50004c00 	.word	0x50004c00
34017860:	52001400 	.word	0x52001400
34017864:	50007800 	.word	0x50007800
34017868:	50007c00 	.word	0x50007c00
3401786c:	52001800 	.word	0x52001800
34017870:	52001c00 	.word	0x52001c00
34017874:	3402be58 	.word	0x3402be58
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
34017878:	697b      	ldr	r3, [r7, #20]
3401787a:	69db      	ldr	r3, [r3, #28]
3401787c:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34017880:	d138      	bne.n	340178f4 <UART_SetConfig+0x354>
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
34017882:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
34017886:	f7fb fb57 	bl	34012f38 <HAL_RCCEx_GetPeriphCLKFreq>
3401788a:	62b8      	str	r0, [r7, #40]	@ 0x28

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
3401788c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401788e:	2b00      	cmp	r3, #0
34017890:	d05a      	beq.n	34017948 <UART_SetConfig+0x3a8>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34017892:	697b      	ldr	r3, [r7, #20]
34017894:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34017896:	4a37      	ldr	r2, [pc, #220]	@ (34017974 <UART_SetConfig+0x3d4>)
34017898:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401789c:	461a      	mov	r2, r3
3401789e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340178a0:	fbb3 f3f2 	udiv	r3, r3, r2
340178a4:	005a      	lsls	r2, r3, #1
340178a6:	697b      	ldr	r3, [r7, #20]
340178a8:	685b      	ldr	r3, [r3, #4]
340178aa:	085b      	lsrs	r3, r3, #1
340178ac:	441a      	add	r2, r3
340178ae:	697b      	ldr	r3, [r7, #20]
340178b0:	685b      	ldr	r3, [r3, #4]
340178b2:	fbb2 f3f3 	udiv	r3, r2, r3
340178b6:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
340178b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340178ba:	2b0f      	cmp	r3, #15
340178bc:	d916      	bls.n	340178ec <UART_SetConfig+0x34c>
340178be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340178c0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
340178c4:	d212      	bcs.n	340178ec <UART_SetConfig+0x34c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
340178c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340178c8:	b29b      	uxth	r3, r3
340178ca:	f023 030f 	bic.w	r3, r3, #15
340178ce:	847b      	strh	r3, [r7, #34]	@ 0x22
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
340178d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340178d2:	085b      	lsrs	r3, r3, #1
340178d4:	b29b      	uxth	r3, r3
340178d6:	f003 0307 	and.w	r3, r3, #7
340178da:	b29a      	uxth	r2, r3
340178dc:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
340178de:	4313      	orrs	r3, r2
340178e0:	847b      	strh	r3, [r7, #34]	@ 0x22
        huart->Instance->BRR = brrtemp;
340178e2:	697b      	ldr	r3, [r7, #20]
340178e4:	681b      	ldr	r3, [r3, #0]
340178e6:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
340178e8:	60da      	str	r2, [r3, #12]
340178ea:	e02d      	b.n	34017948 <UART_SetConfig+0x3a8>
      }
      else
      {
        ret = HAL_ERROR;
340178ec:	2301      	movs	r3, #1
340178ee:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
340178f2:	e029      	b.n	34017948 <UART_SetConfig+0x3a8>
      }
    }
  }
  else
  {
    pclk = HAL_RCCEx_GetPeriphCLKFreq(clocksource);
340178f4:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
340178f8:	f7fb fb1e 	bl	34012f38 <HAL_RCCEx_GetPeriphCLKFreq>
340178fc:	62b8      	str	r0, [r7, #40]	@ 0x28

    if (pclk != 0U)
340178fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34017900:	2b00      	cmp	r3, #0
34017902:	d021      	beq.n	34017948 <UART_SetConfig+0x3a8>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
34017904:	697b      	ldr	r3, [r7, #20]
34017906:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34017908:	4a1a      	ldr	r2, [pc, #104]	@ (34017974 <UART_SetConfig+0x3d4>)
3401790a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
3401790e:	461a      	mov	r2, r3
34017910:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34017912:	fbb3 f2f2 	udiv	r2, r3, r2
34017916:	697b      	ldr	r3, [r7, #20]
34017918:	685b      	ldr	r3, [r3, #4]
3401791a:	085b      	lsrs	r3, r3, #1
3401791c:	441a      	add	r2, r3
3401791e:	697b      	ldr	r3, [r7, #20]
34017920:	685b      	ldr	r3, [r3, #4]
34017922:	fbb2 f3f3 	udiv	r3, r2, r3
34017926:	627b      	str	r3, [r7, #36]	@ 0x24
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
34017928:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401792a:	2b0f      	cmp	r3, #15
3401792c:	d909      	bls.n	34017942 <UART_SetConfig+0x3a2>
3401792e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34017930:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34017934:	d205      	bcs.n	34017942 <UART_SetConfig+0x3a2>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
34017936:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34017938:	b29a      	uxth	r2, r3
3401793a:	697b      	ldr	r3, [r7, #20]
3401793c:	681b      	ldr	r3, [r3, #0]
3401793e:	60da      	str	r2, [r3, #12]
34017940:	e002      	b.n	34017948 <UART_SetConfig+0x3a8>
      }
      else
      {
        ret = HAL_ERROR;
34017942:	2301      	movs	r3, #1
34017944:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
34017948:	697b      	ldr	r3, [r7, #20]
3401794a:	2201      	movs	r2, #1
3401794c:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
34017950:	697b      	ldr	r3, [r7, #20]
34017952:	2201      	movs	r2, #1
34017954:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
34017958:	697b      	ldr	r3, [r7, #20]
3401795a:	2200      	movs	r2, #0
3401795c:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
3401795e:	697b      	ldr	r3, [r7, #20]
34017960:	2200      	movs	r2, #0
34017962:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
34017964:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
34017968:	4618      	mov	r0, r3
3401796a:	3740      	adds	r7, #64	@ 0x40
3401796c:	46bd      	mov	sp, r7
3401796e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
34017972:	bf00      	nop
34017974:	3402be58 	.word	0x3402be58

34017978 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
34017978:	b480      	push	{r7}
3401797a:	b083      	sub	sp, #12
3401797c:	af00      	add	r7, sp, #0
3401797e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
34017980:	687b      	ldr	r3, [r7, #4]
34017982:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017984:	f003 0308 	and.w	r3, r3, #8
34017988:	2b00      	cmp	r3, #0
3401798a:	d00a      	beq.n	340179a2 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
3401798c:	687b      	ldr	r3, [r7, #4]
3401798e:	681b      	ldr	r3, [r3, #0]
34017990:	685b      	ldr	r3, [r3, #4]
34017992:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
34017996:	687b      	ldr	r3, [r7, #4]
34017998:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
3401799a:	687b      	ldr	r3, [r7, #4]
3401799c:	681b      	ldr	r3, [r3, #0]
3401799e:	430a      	orrs	r2, r1
340179a0:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
340179a2:	687b      	ldr	r3, [r7, #4]
340179a4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340179a6:	f003 0301 	and.w	r3, r3, #1
340179aa:	2b00      	cmp	r3, #0
340179ac:	d00a      	beq.n	340179c4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
340179ae:	687b      	ldr	r3, [r7, #4]
340179b0:	681b      	ldr	r3, [r3, #0]
340179b2:	685b      	ldr	r3, [r3, #4]
340179b4:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
340179b8:	687b      	ldr	r3, [r7, #4]
340179ba:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340179bc:	687b      	ldr	r3, [r7, #4]
340179be:	681b      	ldr	r3, [r3, #0]
340179c0:	430a      	orrs	r2, r1
340179c2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
340179c4:	687b      	ldr	r3, [r7, #4]
340179c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340179c8:	f003 0302 	and.w	r3, r3, #2
340179cc:	2b00      	cmp	r3, #0
340179ce:	d00a      	beq.n	340179e6 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
340179d0:	687b      	ldr	r3, [r7, #4]
340179d2:	681b      	ldr	r3, [r3, #0]
340179d4:	685b      	ldr	r3, [r3, #4]
340179d6:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
340179da:	687b      	ldr	r3, [r7, #4]
340179dc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
340179de:	687b      	ldr	r3, [r7, #4]
340179e0:	681b      	ldr	r3, [r3, #0]
340179e2:	430a      	orrs	r2, r1
340179e4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
340179e6:	687b      	ldr	r3, [r7, #4]
340179e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340179ea:	f003 0304 	and.w	r3, r3, #4
340179ee:	2b00      	cmp	r3, #0
340179f0:	d00a      	beq.n	34017a08 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
340179f2:	687b      	ldr	r3, [r7, #4]
340179f4:	681b      	ldr	r3, [r3, #0]
340179f6:	685b      	ldr	r3, [r3, #4]
340179f8:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
340179fc:	687b      	ldr	r3, [r7, #4]
340179fe:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34017a00:	687b      	ldr	r3, [r7, #4]
34017a02:	681b      	ldr	r3, [r3, #0]
34017a04:	430a      	orrs	r2, r1
34017a06:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
34017a08:	687b      	ldr	r3, [r7, #4]
34017a0a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017a0c:	f003 0310 	and.w	r3, r3, #16
34017a10:	2b00      	cmp	r3, #0
34017a12:	d00a      	beq.n	34017a2a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
34017a14:	687b      	ldr	r3, [r7, #4]
34017a16:	681b      	ldr	r3, [r3, #0]
34017a18:	689b      	ldr	r3, [r3, #8]
34017a1a:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
34017a1e:	687b      	ldr	r3, [r7, #4]
34017a20:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34017a22:	687b      	ldr	r3, [r7, #4]
34017a24:	681b      	ldr	r3, [r3, #0]
34017a26:	430a      	orrs	r2, r1
34017a28:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
34017a2a:	687b      	ldr	r3, [r7, #4]
34017a2c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017a2e:	f003 0320 	and.w	r3, r3, #32
34017a32:	2b00      	cmp	r3, #0
34017a34:	d00a      	beq.n	34017a4c <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
34017a36:	687b      	ldr	r3, [r7, #4]
34017a38:	681b      	ldr	r3, [r3, #0]
34017a3a:	689b      	ldr	r3, [r3, #8]
34017a3c:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
34017a40:	687b      	ldr	r3, [r7, #4]
34017a42:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34017a44:	687b      	ldr	r3, [r7, #4]
34017a46:	681b      	ldr	r3, [r3, #0]
34017a48:	430a      	orrs	r2, r1
34017a4a:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
34017a4c:	687b      	ldr	r3, [r7, #4]
34017a4e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017a50:	f003 0340 	and.w	r3, r3, #64	@ 0x40
34017a54:	2b00      	cmp	r3, #0
34017a56:	d01a      	beq.n	34017a8e <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
34017a58:	687b      	ldr	r3, [r7, #4]
34017a5a:	681b      	ldr	r3, [r3, #0]
34017a5c:	685b      	ldr	r3, [r3, #4]
34017a5e:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
34017a62:	687b      	ldr	r3, [r7, #4]
34017a64:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
34017a66:	687b      	ldr	r3, [r7, #4]
34017a68:	681b      	ldr	r3, [r3, #0]
34017a6a:	430a      	orrs	r2, r1
34017a6c:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
34017a6e:	687b      	ldr	r3, [r7, #4]
34017a70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34017a72:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34017a76:	d10a      	bne.n	34017a8e <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
34017a78:	687b      	ldr	r3, [r7, #4]
34017a7a:	681b      	ldr	r3, [r3, #0]
34017a7c:	685b      	ldr	r3, [r3, #4]
34017a7e:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
34017a82:	687b      	ldr	r3, [r7, #4]
34017a84:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34017a86:	687b      	ldr	r3, [r7, #4]
34017a88:	681b      	ldr	r3, [r3, #0]
34017a8a:	430a      	orrs	r2, r1
34017a8c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
34017a8e:	687b      	ldr	r3, [r7, #4]
34017a90:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34017a92:	f003 0380 	and.w	r3, r3, #128	@ 0x80
34017a96:	2b00      	cmp	r3, #0
34017a98:	d00a      	beq.n	34017ab0 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
34017a9a:	687b      	ldr	r3, [r7, #4]
34017a9c:	681b      	ldr	r3, [r3, #0]
34017a9e:	685b      	ldr	r3, [r3, #4]
34017aa0:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
34017aa4:	687b      	ldr	r3, [r7, #4]
34017aa6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
34017aa8:	687b      	ldr	r3, [r7, #4]
34017aaa:	681b      	ldr	r3, [r3, #0]
34017aac:	430a      	orrs	r2, r1
34017aae:	605a      	str	r2, [r3, #4]
  }
}
34017ab0:	bf00      	nop
34017ab2:	370c      	adds	r7, #12
34017ab4:	46bd      	mov	sp, r7
34017ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
34017aba:	4770      	bx	lr

34017abc <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
34017abc:	b580      	push	{r7, lr}
34017abe:	b098      	sub	sp, #96	@ 0x60
34017ac0:	af02      	add	r7, sp, #8
34017ac2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
34017ac4:	687b      	ldr	r3, [r7, #4]
34017ac6:	2200      	movs	r2, #0
34017ac8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
34017acc:	f7ed f8af 	bl	34004c2e <HAL_GetTick>
34017ad0:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
34017ad2:	687b      	ldr	r3, [r7, #4]
34017ad4:	681b      	ldr	r3, [r3, #0]
34017ad6:	681b      	ldr	r3, [r3, #0]
34017ad8:	f003 0308 	and.w	r3, r3, #8
34017adc:	2b08      	cmp	r3, #8
34017ade:	d12f      	bne.n	34017b40 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34017ae0:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34017ae4:	9300      	str	r3, [sp, #0]
34017ae6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34017ae8:	2200      	movs	r2, #0
34017aea:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
34017aee:	6878      	ldr	r0, [r7, #4]
34017af0:	f000 f88e 	bl	34017c10 <UART_WaitOnFlagUntilTimeout>
34017af4:	4603      	mov	r3, r0
34017af6:	2b00      	cmp	r3, #0
34017af8:	d022      	beq.n	34017b40 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
34017afa:	687b      	ldr	r3, [r7, #4]
34017afc:	681b      	ldr	r3, [r3, #0]
34017afe:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017b00:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34017b02:	e853 3f00 	ldrex	r3, [r3]
34017b06:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
34017b08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34017b0a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
34017b0e:	653b      	str	r3, [r7, #80]	@ 0x50
34017b10:	687b      	ldr	r3, [r7, #4]
34017b12:	681b      	ldr	r3, [r3, #0]
34017b14:	461a      	mov	r2, r3
34017b16:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34017b18:	647b      	str	r3, [r7, #68]	@ 0x44
34017b1a:	643a      	str	r2, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017b1c:	6c39      	ldr	r1, [r7, #64]	@ 0x40
34017b1e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34017b20:	e841 2300 	strex	r3, r2, [r1]
34017b24:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
34017b26:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34017b28:	2b00      	cmp	r3, #0
34017b2a:	d1e6      	bne.n	34017afa <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
34017b2c:	687b      	ldr	r3, [r7, #4]
34017b2e:	2220      	movs	r2, #32
34017b30:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
34017b34:	687b      	ldr	r3, [r7, #4]
34017b36:	2200      	movs	r2, #0
34017b38:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
34017b3c:	2303      	movs	r3, #3
34017b3e:	e063      	b.n	34017c08 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
34017b40:	687b      	ldr	r3, [r7, #4]
34017b42:	681b      	ldr	r3, [r3, #0]
34017b44:	681b      	ldr	r3, [r3, #0]
34017b46:	f003 0304 	and.w	r3, r3, #4
34017b4a:	2b04      	cmp	r3, #4
34017b4c:	d149      	bne.n	34017be2 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
34017b4e:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
34017b52:	9300      	str	r3, [sp, #0]
34017b54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34017b56:	2200      	movs	r2, #0
34017b58:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
34017b5c:	6878      	ldr	r0, [r7, #4]
34017b5e:	f000 f857 	bl	34017c10 <UART_WaitOnFlagUntilTimeout>
34017b62:	4603      	mov	r3, r0
34017b64:	2b00      	cmp	r3, #0
34017b66:	d03c      	beq.n	34017be2 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
34017b68:	687b      	ldr	r3, [r7, #4]
34017b6a:	681b      	ldr	r3, [r3, #0]
34017b6c:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017b6e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34017b70:	e853 3f00 	ldrex	r3, [r3]
34017b74:	623b      	str	r3, [r7, #32]
   return(result);
34017b76:	6a3b      	ldr	r3, [r7, #32]
34017b78:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
34017b7c:	64fb      	str	r3, [r7, #76]	@ 0x4c
34017b7e:	687b      	ldr	r3, [r7, #4]
34017b80:	681b      	ldr	r3, [r3, #0]
34017b82:	461a      	mov	r2, r3
34017b84:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34017b86:	633b      	str	r3, [r7, #48]	@ 0x30
34017b88:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017b8a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34017b8c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
34017b8e:	e841 2300 	strex	r3, r2, [r1]
34017b92:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
34017b94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34017b96:	2b00      	cmp	r3, #0
34017b98:	d1e6      	bne.n	34017b68 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
34017b9a:	687b      	ldr	r3, [r7, #4]
34017b9c:	681b      	ldr	r3, [r3, #0]
34017b9e:	3308      	adds	r3, #8
34017ba0:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017ba2:	693b      	ldr	r3, [r7, #16]
34017ba4:	e853 3f00 	ldrex	r3, [r3]
34017ba8:	60fb      	str	r3, [r7, #12]
   return(result);
34017baa:	68fb      	ldr	r3, [r7, #12]
34017bac:	f023 0301 	bic.w	r3, r3, #1
34017bb0:	64bb      	str	r3, [r7, #72]	@ 0x48
34017bb2:	687b      	ldr	r3, [r7, #4]
34017bb4:	681b      	ldr	r3, [r3, #0]
34017bb6:	3308      	adds	r3, #8
34017bb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34017bba:	61fa      	str	r2, [r7, #28]
34017bbc:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017bbe:	69b9      	ldr	r1, [r7, #24]
34017bc0:	69fa      	ldr	r2, [r7, #28]
34017bc2:	e841 2300 	strex	r3, r2, [r1]
34017bc6:	617b      	str	r3, [r7, #20]
   return(result);
34017bc8:	697b      	ldr	r3, [r7, #20]
34017bca:	2b00      	cmp	r3, #0
34017bcc:	d1e5      	bne.n	34017b9a <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
34017bce:	687b      	ldr	r3, [r7, #4]
34017bd0:	2220      	movs	r2, #32
34017bd2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
34017bd6:	687b      	ldr	r3, [r7, #4]
34017bd8:	2200      	movs	r2, #0
34017bda:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
34017bde:	2303      	movs	r3, #3
34017be0:	e012      	b.n	34017c08 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
34017be2:	687b      	ldr	r3, [r7, #4]
34017be4:	2220      	movs	r2, #32
34017be6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
34017bea:	687b      	ldr	r3, [r7, #4]
34017bec:	2220      	movs	r2, #32
34017bee:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34017bf2:	687b      	ldr	r3, [r7, #4]
34017bf4:	2200      	movs	r2, #0
34017bf6:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
34017bf8:	687b      	ldr	r3, [r7, #4]
34017bfa:	2200      	movs	r2, #0
34017bfc:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
34017bfe:	687b      	ldr	r3, [r7, #4]
34017c00:	2200      	movs	r2, #0
34017c02:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
34017c06:	2300      	movs	r3, #0
}
34017c08:	4618      	mov	r0, r3
34017c0a:	3758      	adds	r7, #88	@ 0x58
34017c0c:	46bd      	mov	sp, r7
34017c0e:	bd80      	pop	{r7, pc}

34017c10 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
34017c10:	b580      	push	{r7, lr}
34017c12:	b084      	sub	sp, #16
34017c14:	af00      	add	r7, sp, #0
34017c16:	60f8      	str	r0, [r7, #12]
34017c18:	60b9      	str	r1, [r7, #8]
34017c1a:	603b      	str	r3, [r7, #0]
34017c1c:	4613      	mov	r3, r2
34017c1e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34017c20:	e04f      	b.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34017c22:	69bb      	ldr	r3, [r7, #24]
34017c24:	f1b3 3fff 	cmp.w	r3, #4294967295
34017c28:	d04b      	beq.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34017c2a:	f7ed f800 	bl	34004c2e <HAL_GetTick>
34017c2e:	4602      	mov	r2, r0
34017c30:	683b      	ldr	r3, [r7, #0]
34017c32:	1ad3      	subs	r3, r2, r3
34017c34:	69ba      	ldr	r2, [r7, #24]
34017c36:	429a      	cmp	r2, r3
34017c38:	d302      	bcc.n	34017c40 <UART_WaitOnFlagUntilTimeout+0x30>
34017c3a:	69bb      	ldr	r3, [r7, #24]
34017c3c:	2b00      	cmp	r3, #0
34017c3e:	d101      	bne.n	34017c44 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
34017c40:	2303      	movs	r3, #3
34017c42:	e04e      	b.n	34017ce2 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
34017c44:	68fb      	ldr	r3, [r7, #12]
34017c46:	681b      	ldr	r3, [r3, #0]
34017c48:	681b      	ldr	r3, [r3, #0]
34017c4a:	f003 0304 	and.w	r3, r3, #4
34017c4e:	2b00      	cmp	r3, #0
34017c50:	d037      	beq.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
34017c52:	68bb      	ldr	r3, [r7, #8]
34017c54:	2b80      	cmp	r3, #128	@ 0x80
34017c56:	d034      	beq.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
34017c58:	68bb      	ldr	r3, [r7, #8]
34017c5a:	2b40      	cmp	r3, #64	@ 0x40
34017c5c:	d031      	beq.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
34017c5e:	68fb      	ldr	r3, [r7, #12]
34017c60:	681b      	ldr	r3, [r3, #0]
34017c62:	69db      	ldr	r3, [r3, #28]
34017c64:	f003 0308 	and.w	r3, r3, #8
34017c68:	2b08      	cmp	r3, #8
34017c6a:	d110      	bne.n	34017c8e <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
34017c6c:	68fb      	ldr	r3, [r7, #12]
34017c6e:	681b      	ldr	r3, [r3, #0]
34017c70:	2208      	movs	r2, #8
34017c72:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
34017c74:	68f8      	ldr	r0, [r7, #12]
34017c76:	f000 f838 	bl	34017cea <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
34017c7a:	68fb      	ldr	r3, [r7, #12]
34017c7c:	2208      	movs	r2, #8
34017c7e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
34017c82:	68fb      	ldr	r3, [r7, #12]
34017c84:	2200      	movs	r2, #0
34017c86:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
34017c8a:	2301      	movs	r3, #1
34017c8c:	e029      	b.n	34017ce2 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
34017c8e:	68fb      	ldr	r3, [r7, #12]
34017c90:	681b      	ldr	r3, [r3, #0]
34017c92:	69db      	ldr	r3, [r3, #28]
34017c94:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
34017c98:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
34017c9c:	d111      	bne.n	34017cc2 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
34017c9e:	68fb      	ldr	r3, [r7, #12]
34017ca0:	681b      	ldr	r3, [r3, #0]
34017ca2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
34017ca6:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
34017ca8:	68f8      	ldr	r0, [r7, #12]
34017caa:	f000 f81e 	bl	34017cea <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
34017cae:	68fb      	ldr	r3, [r7, #12]
34017cb0:	2220      	movs	r2, #32
34017cb2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
34017cb6:	68fb      	ldr	r3, [r7, #12]
34017cb8:	2200      	movs	r2, #0
34017cba:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
34017cbe:	2303      	movs	r3, #3
34017cc0:	e00f      	b.n	34017ce2 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
34017cc2:	68fb      	ldr	r3, [r7, #12]
34017cc4:	681b      	ldr	r3, [r3, #0]
34017cc6:	69da      	ldr	r2, [r3, #28]
34017cc8:	68bb      	ldr	r3, [r7, #8]
34017cca:	4013      	ands	r3, r2
34017ccc:	68ba      	ldr	r2, [r7, #8]
34017cce:	429a      	cmp	r2, r3
34017cd0:	bf0c      	ite	eq
34017cd2:	2301      	moveq	r3, #1
34017cd4:	2300      	movne	r3, #0
34017cd6:	b2db      	uxtb	r3, r3
34017cd8:	461a      	mov	r2, r3
34017cda:	79fb      	ldrb	r3, [r7, #7]
34017cdc:	429a      	cmp	r2, r3
34017cde:	d0a0      	beq.n	34017c22 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
34017ce0:	2300      	movs	r3, #0
}
34017ce2:	4618      	mov	r0, r3
34017ce4:	3710      	adds	r7, #16
34017ce6:	46bd      	mov	sp, r7
34017ce8:	bd80      	pop	{r7, pc}

34017cea <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
34017cea:	b480      	push	{r7}
34017cec:	b095      	sub	sp, #84	@ 0x54
34017cee:	af00      	add	r7, sp, #0
34017cf0:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
34017cf2:	687b      	ldr	r3, [r7, #4]
34017cf4:	681b      	ldr	r3, [r3, #0]
34017cf6:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017cf8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34017cfa:	e853 3f00 	ldrex	r3, [r3]
34017cfe:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
34017d00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34017d02:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
34017d06:	64fb      	str	r3, [r7, #76]	@ 0x4c
34017d08:	687b      	ldr	r3, [r7, #4]
34017d0a:	681b      	ldr	r3, [r3, #0]
34017d0c:	461a      	mov	r2, r3
34017d0e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34017d10:	643b      	str	r3, [r7, #64]	@ 0x40
34017d12:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017d14:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
34017d16:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34017d18:	e841 2300 	strex	r3, r2, [r1]
34017d1c:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
34017d1e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34017d20:	2b00      	cmp	r3, #0
34017d22:	d1e6      	bne.n	34017cf2 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
34017d24:	687b      	ldr	r3, [r7, #4]
34017d26:	681b      	ldr	r3, [r3, #0]
34017d28:	3308      	adds	r3, #8
34017d2a:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017d2c:	6a3b      	ldr	r3, [r7, #32]
34017d2e:	e853 3f00 	ldrex	r3, [r3]
34017d32:	61fb      	str	r3, [r7, #28]
   return(result);
34017d34:	69fb      	ldr	r3, [r7, #28]
34017d36:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
34017d3a:	f023 0301 	bic.w	r3, r3, #1
34017d3e:	64bb      	str	r3, [r7, #72]	@ 0x48
34017d40:	687b      	ldr	r3, [r7, #4]
34017d42:	681b      	ldr	r3, [r3, #0]
34017d44:	3308      	adds	r3, #8
34017d46:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34017d48:	62fa      	str	r2, [r7, #44]	@ 0x2c
34017d4a:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017d4c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34017d4e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34017d50:	e841 2300 	strex	r3, r2, [r1]
34017d54:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
34017d56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34017d58:	2b00      	cmp	r3, #0
34017d5a:	d1e3      	bne.n	34017d24 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
34017d5c:	687b      	ldr	r3, [r7, #4]
34017d5e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34017d60:	2b01      	cmp	r3, #1
34017d62:	d118      	bne.n	34017d96 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
34017d64:	687b      	ldr	r3, [r7, #4]
34017d66:	681b      	ldr	r3, [r3, #0]
34017d68:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
34017d6a:	68fb      	ldr	r3, [r7, #12]
34017d6c:	e853 3f00 	ldrex	r3, [r3]
34017d70:	60bb      	str	r3, [r7, #8]
   return(result);
34017d72:	68bb      	ldr	r3, [r7, #8]
34017d74:	f023 0310 	bic.w	r3, r3, #16
34017d78:	647b      	str	r3, [r7, #68]	@ 0x44
34017d7a:	687b      	ldr	r3, [r7, #4]
34017d7c:	681b      	ldr	r3, [r3, #0]
34017d7e:	461a      	mov	r2, r3
34017d80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34017d82:	61bb      	str	r3, [r7, #24]
34017d84:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
34017d86:	6979      	ldr	r1, [r7, #20]
34017d88:	69ba      	ldr	r2, [r7, #24]
34017d8a:	e841 2300 	strex	r3, r2, [r1]
34017d8e:	613b      	str	r3, [r7, #16]
   return(result);
34017d90:	693b      	ldr	r3, [r7, #16]
34017d92:	2b00      	cmp	r3, #0
34017d94:	d1e6      	bne.n	34017d64 <UART_EndRxTransfer+0x7a>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
34017d96:	687b      	ldr	r3, [r7, #4]
34017d98:	2220      	movs	r2, #32
34017d9a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
34017d9e:	687b      	ldr	r3, [r7, #4]
34017da0:	2200      	movs	r2, #0
34017da2:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
34017da4:	687b      	ldr	r3, [r7, #4]
34017da6:	2200      	movs	r2, #0
34017da8:	675a      	str	r2, [r3, #116]	@ 0x74
}
34017daa:	bf00      	nop
34017dac:	3754      	adds	r7, #84	@ 0x54
34017dae:	46bd      	mov	sp, r7
34017db0:	f85d 7b04 	ldr.w	r7, [sp], #4
34017db4:	4770      	bx	lr

34017db6 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
34017db6:	b480      	push	{r7}
34017db8:	b085      	sub	sp, #20
34017dba:	af00      	add	r7, sp, #0
34017dbc:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
34017dbe:	687b      	ldr	r3, [r7, #4]
34017dc0:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
34017dc4:	2b01      	cmp	r3, #1
34017dc6:	d101      	bne.n	34017dcc <HAL_UARTEx_DisableFifoMode+0x16>
34017dc8:	2302      	movs	r3, #2
34017dca:	e027      	b.n	34017e1c <HAL_UARTEx_DisableFifoMode+0x66>
34017dcc:	687b      	ldr	r3, [r7, #4]
34017dce:	2201      	movs	r2, #1
34017dd0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
34017dd4:	687b      	ldr	r3, [r7, #4]
34017dd6:	2224      	movs	r2, #36	@ 0x24
34017dd8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
34017ddc:	687b      	ldr	r3, [r7, #4]
34017dde:	681b      	ldr	r3, [r3, #0]
34017de0:	681b      	ldr	r3, [r3, #0]
34017de2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
34017de4:	687b      	ldr	r3, [r7, #4]
34017de6:	681b      	ldr	r3, [r3, #0]
34017de8:	681a      	ldr	r2, [r3, #0]
34017dea:	687b      	ldr	r3, [r7, #4]
34017dec:	681b      	ldr	r3, [r3, #0]
34017dee:	f022 0201 	bic.w	r2, r2, #1
34017df2:	601a      	str	r2, [r3, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
34017df4:	68fb      	ldr	r3, [r7, #12]
34017df6:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
34017dfa:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
34017dfc:	687b      	ldr	r3, [r7, #4]
34017dfe:	2200      	movs	r2, #0
34017e00:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34017e02:	687b      	ldr	r3, [r7, #4]
34017e04:	681b      	ldr	r3, [r3, #0]
34017e06:	68fa      	ldr	r2, [r7, #12]
34017e08:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
34017e0a:	687b      	ldr	r3, [r7, #4]
34017e0c:	2220      	movs	r2, #32
34017e0e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
34017e12:	687b      	ldr	r3, [r7, #4]
34017e14:	2200      	movs	r2, #0
34017e16:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
34017e1a:	2300      	movs	r3, #0
}
34017e1c:	4618      	mov	r0, r3
34017e1e:	3714      	adds	r7, #20
34017e20:	46bd      	mov	sp, r7
34017e22:	f85d 7b04 	ldr.w	r7, [sp], #4
34017e26:	4770      	bx	lr

34017e28 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
34017e28:	b580      	push	{r7, lr}
34017e2a:	b084      	sub	sp, #16
34017e2c:	af00      	add	r7, sp, #0
34017e2e:	6078      	str	r0, [r7, #4]
34017e30:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
34017e32:	687b      	ldr	r3, [r7, #4]
34017e34:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
34017e38:	2b01      	cmp	r3, #1
34017e3a:	d101      	bne.n	34017e40 <HAL_UARTEx_SetTxFifoThreshold+0x18>
34017e3c:	2302      	movs	r3, #2
34017e3e:	e02d      	b.n	34017e9c <HAL_UARTEx_SetTxFifoThreshold+0x74>
34017e40:	687b      	ldr	r3, [r7, #4]
34017e42:	2201      	movs	r2, #1
34017e44:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
34017e48:	687b      	ldr	r3, [r7, #4]
34017e4a:	2224      	movs	r2, #36	@ 0x24
34017e4c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
34017e50:	687b      	ldr	r3, [r7, #4]
34017e52:	681b      	ldr	r3, [r3, #0]
34017e54:	681b      	ldr	r3, [r3, #0]
34017e56:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
34017e58:	687b      	ldr	r3, [r7, #4]
34017e5a:	681b      	ldr	r3, [r3, #0]
34017e5c:	681a      	ldr	r2, [r3, #0]
34017e5e:	687b      	ldr	r3, [r7, #4]
34017e60:	681b      	ldr	r3, [r3, #0]
34017e62:	f022 0201 	bic.w	r2, r2, #1
34017e66:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
34017e68:	687b      	ldr	r3, [r7, #4]
34017e6a:	681b      	ldr	r3, [r3, #0]
34017e6c:	689b      	ldr	r3, [r3, #8]
34017e6e:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
34017e72:	687b      	ldr	r3, [r7, #4]
34017e74:	681b      	ldr	r3, [r3, #0]
34017e76:	683a      	ldr	r2, [r7, #0]
34017e78:	430a      	orrs	r2, r1
34017e7a:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
34017e7c:	6878      	ldr	r0, [r7, #4]
34017e7e:	f000 f84f 	bl	34017f20 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34017e82:	687b      	ldr	r3, [r7, #4]
34017e84:	681b      	ldr	r3, [r3, #0]
34017e86:	68fa      	ldr	r2, [r7, #12]
34017e88:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
34017e8a:	687b      	ldr	r3, [r7, #4]
34017e8c:	2220      	movs	r2, #32
34017e8e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
34017e92:	687b      	ldr	r3, [r7, #4]
34017e94:	2200      	movs	r2, #0
34017e96:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
34017e9a:	2300      	movs	r3, #0
}
34017e9c:	4618      	mov	r0, r3
34017e9e:	3710      	adds	r7, #16
34017ea0:	46bd      	mov	sp, r7
34017ea2:	bd80      	pop	{r7, pc}

34017ea4 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
34017ea4:	b580      	push	{r7, lr}
34017ea6:	b084      	sub	sp, #16
34017ea8:	af00      	add	r7, sp, #0
34017eaa:	6078      	str	r0, [r7, #4]
34017eac:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
34017eae:	687b      	ldr	r3, [r7, #4]
34017eb0:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
34017eb4:	2b01      	cmp	r3, #1
34017eb6:	d101      	bne.n	34017ebc <HAL_UARTEx_SetRxFifoThreshold+0x18>
34017eb8:	2302      	movs	r3, #2
34017eba:	e02d      	b.n	34017f18 <HAL_UARTEx_SetRxFifoThreshold+0x74>
34017ebc:	687b      	ldr	r3, [r7, #4]
34017ebe:	2201      	movs	r2, #1
34017ec0:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
34017ec4:	687b      	ldr	r3, [r7, #4]
34017ec6:	2224      	movs	r2, #36	@ 0x24
34017ec8:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
34017ecc:	687b      	ldr	r3, [r7, #4]
34017ece:	681b      	ldr	r3, [r3, #0]
34017ed0:	681b      	ldr	r3, [r3, #0]
34017ed2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
34017ed4:	687b      	ldr	r3, [r7, #4]
34017ed6:	681b      	ldr	r3, [r3, #0]
34017ed8:	681a      	ldr	r2, [r3, #0]
34017eda:	687b      	ldr	r3, [r7, #4]
34017edc:	681b      	ldr	r3, [r3, #0]
34017ede:	f022 0201 	bic.w	r2, r2, #1
34017ee2:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
34017ee4:	687b      	ldr	r3, [r7, #4]
34017ee6:	681b      	ldr	r3, [r3, #0]
34017ee8:	689b      	ldr	r3, [r3, #8]
34017eea:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
34017eee:	687b      	ldr	r3, [r7, #4]
34017ef0:	681b      	ldr	r3, [r3, #0]
34017ef2:	683a      	ldr	r2, [r7, #0]
34017ef4:	430a      	orrs	r2, r1
34017ef6:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
34017ef8:	6878      	ldr	r0, [r7, #4]
34017efa:	f000 f811 	bl	34017f20 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
34017efe:	687b      	ldr	r3, [r7, #4]
34017f00:	681b      	ldr	r3, [r3, #0]
34017f02:	68fa      	ldr	r2, [r7, #12]
34017f04:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
34017f06:	687b      	ldr	r3, [r7, #4]
34017f08:	2220      	movs	r2, #32
34017f0a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
34017f0e:	687b      	ldr	r3, [r7, #4]
34017f10:	2200      	movs	r2, #0
34017f12:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
34017f16:	2300      	movs	r3, #0
}
34017f18:	4618      	mov	r0, r3
34017f1a:	3710      	adds	r7, #16
34017f1c:	46bd      	mov	sp, r7
34017f1e:	bd80      	pop	{r7, pc}

34017f20 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
34017f20:	b480      	push	{r7}
34017f22:	b085      	sub	sp, #20
34017f24:	af00      	add	r7, sp, #0
34017f26:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
34017f28:	687b      	ldr	r3, [r7, #4]
34017f2a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34017f2c:	2b00      	cmp	r3, #0
34017f2e:	d108      	bne.n	34017f42 <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
34017f30:	687b      	ldr	r3, [r7, #4]
34017f32:	2201      	movs	r2, #1
34017f34:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
34017f38:	687b      	ldr	r3, [r7, #4]
34017f3a:	2201      	movs	r2, #1
34017f3c:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
34017f40:	e031      	b.n	34017fa6 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
34017f42:	2310      	movs	r3, #16
34017f44:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
34017f46:	2310      	movs	r3, #16
34017f48:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
34017f4a:	687b      	ldr	r3, [r7, #4]
34017f4c:	681b      	ldr	r3, [r3, #0]
34017f4e:	689b      	ldr	r3, [r3, #8]
34017f50:	0e5b      	lsrs	r3, r3, #25
34017f52:	b2db      	uxtb	r3, r3
34017f54:	f003 0307 	and.w	r3, r3, #7
34017f58:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
34017f5a:	687b      	ldr	r3, [r7, #4]
34017f5c:	681b      	ldr	r3, [r3, #0]
34017f5e:	689b      	ldr	r3, [r3, #8]
34017f60:	0f5b      	lsrs	r3, r3, #29
34017f62:	b2db      	uxtb	r3, r3
34017f64:	f003 0307 	and.w	r3, r3, #7
34017f68:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34017f6a:	7bbb      	ldrb	r3, [r7, #14]
34017f6c:	7b3a      	ldrb	r2, [r7, #12]
34017f6e:	4911      	ldr	r1, [pc, #68]	@ (34017fb4 <UARTEx_SetNbDataToProcess+0x94>)
34017f70:	5c8a      	ldrb	r2, [r1, r2]
34017f72:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
34017f76:	7b3a      	ldrb	r2, [r7, #12]
34017f78:	490f      	ldr	r1, [pc, #60]	@ (34017fb8 <UARTEx_SetNbDataToProcess+0x98>)
34017f7a:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
34017f7c:	fb93 f3f2 	sdiv	r3, r3, r2
34017f80:	b29a      	uxth	r2, r3
34017f82:	687b      	ldr	r3, [r7, #4]
34017f84:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
34017f88:	7bfb      	ldrb	r3, [r7, #15]
34017f8a:	7b7a      	ldrb	r2, [r7, #13]
34017f8c:	4909      	ldr	r1, [pc, #36]	@ (34017fb4 <UARTEx_SetNbDataToProcess+0x94>)
34017f8e:	5c8a      	ldrb	r2, [r1, r2]
34017f90:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
34017f94:	7b7a      	ldrb	r2, [r7, #13]
34017f96:	4908      	ldr	r1, [pc, #32]	@ (34017fb8 <UARTEx_SetNbDataToProcess+0x98>)
34017f98:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
34017f9a:	fb93 f3f2 	sdiv	r3, r3, r2
34017f9e:	b29a      	uxth	r2, r3
34017fa0:	687b      	ldr	r3, [r7, #4]
34017fa2:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
34017fa6:	bf00      	nop
34017fa8:	3714      	adds	r7, #20
34017faa:	46bd      	mov	sp, r7
34017fac:	f85d 7b04 	ldr.w	r7, [sp], #4
34017fb0:	4770      	bx	lr
34017fb2:	bf00      	nop
34017fb4:	3402be70 	.word	0x3402be70
34017fb8:	3402be78 	.word	0x3402be78

34017fbc <LL_AHB5_GRP1_IsEnabledClock>:
{
34017fbc:	b480      	push	{r7}
34017fbe:	b083      	sub	sp, #12
34017fc0:	af00      	add	r7, sp, #0
34017fc2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(RCC->AHB5ENR, Periphs) == Periphs) ? 1UL : 0UL);
34017fc4:	4b08      	ldr	r3, [pc, #32]	@ (34017fe8 <LL_AHB5_GRP1_IsEnabledClock+0x2c>)
34017fc6:	f8d3 2260 	ldr.w	r2, [r3, #608]	@ 0x260
34017fca:	687b      	ldr	r3, [r7, #4]
34017fcc:	4013      	ands	r3, r2
34017fce:	687a      	ldr	r2, [r7, #4]
34017fd0:	429a      	cmp	r2, r3
34017fd2:	d101      	bne.n	34017fd8 <LL_AHB5_GRP1_IsEnabledClock+0x1c>
34017fd4:	2301      	movs	r3, #1
34017fd6:	e000      	b.n	34017fda <LL_AHB5_GRP1_IsEnabledClock+0x1e>
34017fd8:	2300      	movs	r3, #0
}
34017fda:	4618      	mov	r0, r3
34017fdc:	370c      	adds	r7, #12
34017fde:	46bd      	mov	sp, r7
34017fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
34017fe4:	4770      	bx	lr
34017fe6:	bf00      	nop
34017fe8:	56028000 	.word	0x56028000

34017fec <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
34017fec:	b580      	push	{r7, lr}
34017fee:	b086      	sub	sp, #24
34017ff0:	af02      	add	r7, sp, #8
34017ff2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34017ff4:	2300      	movs	r3, #0
34017ff6:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
34017ff8:	f7ec fe19 	bl	34004c2e <HAL_GetTick>
34017ffc:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
34017ffe:	687b      	ldr	r3, [r7, #4]
34018000:	2b00      	cmp	r3, #0
34018002:	d102      	bne.n	3401800a <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
34018004:	2301      	movs	r3, #1
34018006:	73fb      	strb	r3, [r7, #15]
34018008:	e0ef      	b.n	340181ea <HAL_XSPI_Init+0x1fe>
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    assert_param(IS_XSPI_EXTENDMEM(hxspi->Init.MemoryExtended));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
3401800a:	687b      	ldr	r3, [r7, #4]
3401800c:	2200      	movs	r2, #0
3401800e:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
34018010:	687b      	ldr	r3, [r7, #4]
34018012:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34018014:	2b00      	cmp	r3, #0
34018016:	f040 80e8 	bne.w	340181ea <HAL_XSPI_Init+0x1fe>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
3401801a:	6878      	ldr	r0, [r7, #4]
3401801c:	f7ec fcf6 	bl	34004a0c <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
34018020:	f241 3188 	movw	r1, #5000	@ 0x1388
34018024:	6878      	ldr	r0, [r7, #4]
34018026:	f000 fcee 	bl	34018a06 <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
3401802a:	687b      	ldr	r3, [r7, #4]
3401802c:	681b      	ldr	r3, [r3, #0]
3401802e:	689a      	ldr	r2, [r3, #8]
34018030:	4b70      	ldr	r3, [pc, #448]	@ (340181f4 <HAL_XSPI_Init+0x208>)
34018032:	4013      	ands	r3, r2
34018034:	687a      	ldr	r2, [r7, #4]
34018036:	68d1      	ldr	r1, [r2, #12]
34018038:	687a      	ldr	r2, [r7, #4]
3401803a:	6912      	ldr	r2, [r2, #16]
3401803c:	0412      	lsls	r2, r2, #16
3401803e:	4311      	orrs	r1, r2
34018040:	687a      	ldr	r2, [r7, #4]
34018042:	6952      	ldr	r2, [r2, #20]
34018044:	3a01      	subs	r2, #1
34018046:	0212      	lsls	r2, r2, #8
34018048:	4311      	orrs	r1, r2
3401804a:	687a      	ldr	r2, [r7, #4]
3401804c:	69d2      	ldr	r2, [r2, #28]
3401804e:	4311      	orrs	r1, r2
34018050:	687a      	ldr	r2, [r7, #4]
34018052:	6812      	ldr	r2, [r2, #0]
34018054:	430b      	orrs	r3, r1
34018056:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
34018058:	687b      	ldr	r3, [r7, #4]
3401805a:	681b      	ldr	r3, [r3, #0]
3401805c:	68db      	ldr	r3, [r3, #12]
3401805e:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
34018062:	687b      	ldr	r3, [r7, #4]
34018064:	6a1a      	ldr	r2, [r3, #32]
34018066:	687b      	ldr	r3, [r7, #4]
34018068:	681b      	ldr	r3, [r3, #0]
3401806a:	430a      	orrs	r2, r1
3401806c:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
3401806e:	687b      	ldr	r3, [r7, #4]
34018070:	681b      	ldr	r3, [r3, #0]
34018072:	691b      	ldr	r3, [r3, #16]
34018074:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
34018078:	687b      	ldr	r3, [r7, #4]
3401807a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401807c:	041a      	lsls	r2, r3, #16
3401807e:	687b      	ldr	r3, [r7, #4]
34018080:	681b      	ldr	r3, [r3, #0]
34018082:	430a      	orrs	r2, r1
34018084:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
34018086:	687b      	ldr	r3, [r7, #4]
34018088:	681b      	ldr	r3, [r3, #0]
3401808a:	691b      	ldr	r3, [r3, #16]
3401808c:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
34018090:	687b      	ldr	r3, [r7, #4]
34018092:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
34018094:	687b      	ldr	r3, [r7, #4]
34018096:	681b      	ldr	r3, [r3, #0]
34018098:	430a      	orrs	r2, r1
3401809a:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
3401809c:	687b      	ldr	r3, [r7, #4]
3401809e:	681b      	ldr	r3, [r3, #0]
340180a0:	687a      	ldr	r2, [r7, #4]
340180a2:	6b92      	ldr	r2, [r2, #56]	@ 0x38
340180a4:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
340180a6:	687b      	ldr	r3, [r7, #4]
340180a8:	681b      	ldr	r3, [r3, #0]
340180aa:	681b      	ldr	r3, [r3, #0]
340180ac:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
340180b0:	687b      	ldr	r3, [r7, #4]
340180b2:	685b      	ldr	r3, [r3, #4]
340180b4:	3b01      	subs	r3, #1
340180b6:	021a      	lsls	r2, r3, #8
340180b8:	687b      	ldr	r3, [r7, #4]
340180ba:	681b      	ldr	r3, [r3, #0]
340180bc:	430a      	orrs	r2, r1
340180be:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
340180c0:	687b      	ldr	r3, [r7, #4]
340180c2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340180c4:	9300      	str	r3, [sp, #0]
340180c6:	68bb      	ldr	r3, [r7, #8]
340180c8:	2200      	movs	r2, #0
340180ca:	2120      	movs	r1, #32
340180cc:	6878      	ldr	r0, [r7, #4]
340180ce:	f000 fdd5 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
340180d2:	4603      	mov	r3, r0
340180d4:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
340180d6:	7bfb      	ldrb	r3, [r7, #15]
340180d8:	2b00      	cmp	r3, #0
340180da:	f040 8086 	bne.w	340181ea <HAL_XSPI_Init+0x1fe>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340180de:	687b      	ldr	r3, [r7, #4]
340180e0:	681b      	ldr	r3, [r3, #0]
340180e2:	68db      	ldr	r3, [r3, #12]
340180e4:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
340180e8:	687b      	ldr	r3, [r7, #4]
340180ea:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340180ec:	687b      	ldr	r3, [r7, #4]
340180ee:	681b      	ldr	r3, [r3, #0]
340180f0:	430a      	orrs	r2, r1
340180f2:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
340180f4:	687b      	ldr	r3, [r7, #4]
340180f6:	681b      	ldr	r3, [r3, #0]
340180f8:	4a3f      	ldr	r2, [pc, #252]	@ (340181f8 <HAL_XSPI_Init+0x20c>)
340180fa:	4293      	cmp	r3, r2
340180fc:	d018      	beq.n	34018130 <HAL_XSPI_Init+0x144>
340180fe:	687b      	ldr	r3, [r7, #4]
34018100:	681b      	ldr	r3, [r3, #0]
34018102:	4a3e      	ldr	r2, [pc, #248]	@ (340181fc <HAL_XSPI_Init+0x210>)
34018104:	4293      	cmp	r3, r2
34018106:	d013      	beq.n	34018130 <HAL_XSPI_Init+0x144>
34018108:	687b      	ldr	r3, [r7, #4]
3401810a:	681b      	ldr	r3, [r3, #0]
3401810c:	4a3c      	ldr	r2, [pc, #240]	@ (34018200 <HAL_XSPI_Init+0x214>)
3401810e:	4293      	cmp	r3, r2
34018110:	d00e      	beq.n	34018130 <HAL_XSPI_Init+0x144>
34018112:	687b      	ldr	r3, [r7, #4]
34018114:	681b      	ldr	r3, [r3, #0]
34018116:	4a3b      	ldr	r2, [pc, #236]	@ (34018204 <HAL_XSPI_Init+0x218>)
34018118:	4293      	cmp	r3, r2
3401811a:	d009      	beq.n	34018130 <HAL_XSPI_Init+0x144>
3401811c:	687b      	ldr	r3, [r7, #4]
3401811e:	681b      	ldr	r3, [r3, #0]
34018120:	4a39      	ldr	r2, [pc, #228]	@ (34018208 <HAL_XSPI_Init+0x21c>)
34018122:	4293      	cmp	r3, r2
34018124:	d004      	beq.n	34018130 <HAL_XSPI_Init+0x144>
34018126:	687b      	ldr	r3, [r7, #4]
34018128:	681b      	ldr	r3, [r3, #0]
3401812a:	4a38      	ldr	r2, [pc, #224]	@ (3401820c <HAL_XSPI_Init+0x220>)
3401812c:	4293      	cmp	r3, r2
3401812e:	d10f      	bne.n	34018150 <HAL_XSPI_Init+0x164>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34018130:	687b      	ldr	r3, [r7, #4]
34018132:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34018134:	9300      	str	r3, [sp, #0]
34018136:	68bb      	ldr	r3, [r7, #8]
34018138:	2200      	movs	r2, #0
3401813a:	2120      	movs	r1, #32
3401813c:	6878      	ldr	r0, [r7, #4]
3401813e:	f000 fd9d 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018142:	4603      	mov	r3, r0
34018144:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
34018146:	7bfb      	ldrb	r3, [r7, #15]
34018148:	2b00      	cmp	r3, #0
3401814a:	d001      	beq.n	34018150 <HAL_XSPI_Init+0x164>
          {
            return status;
3401814c:	7bfb      	ldrb	r3, [r7, #15]
3401814e:	e04d      	b.n	340181ec <HAL_XSPI_Init+0x200>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
34018150:	687b      	ldr	r3, [r7, #4]
34018152:	681b      	ldr	r3, [r3, #0]
34018154:	681b      	ldr	r3, [r3, #0]
34018156:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
3401815a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3401815e:	687a      	ldr	r2, [r7, #4]
34018160:	6891      	ldr	r1, [r2, #8]
34018162:	687a      	ldr	r2, [r7, #4]
34018164:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
34018166:	4311      	orrs	r1, r2
34018168:	687a      	ldr	r2, [r7, #4]
3401816a:	6812      	ldr	r2, [r2, #0]
3401816c:	430b      	orrs	r3, r1
3401816e:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT | XSPI_TCR_DHQC),
34018170:	687b      	ldr	r3, [r7, #4]
34018172:	681b      	ldr	r3, [r3, #0]
34018174:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34018178:	f023 41a0 	bic.w	r1, r3, #1342177280	@ 0x50000000
3401817c:	687b      	ldr	r3, [r7, #4]
3401817e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34018180:	687b      	ldr	r3, [r7, #4]
34018182:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34018184:	431a      	orrs	r2, r3
34018186:	687b      	ldr	r3, [r7, #4]
34018188:	681b      	ldr	r3, [r3, #0]
3401818a:	430a      	orrs	r2, r1
3401818c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
                   (hxspi->Init.SampleShifting | hxspi->Init.DelayHoldQuarterCycle));

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
34018190:	687b      	ldr	r3, [r7, #4]
34018192:	681b      	ldr	r3, [r3, #0]
34018194:	681a      	ldr	r2, [r3, #0]
34018196:	687b      	ldr	r3, [r7, #4]
34018198:	681b      	ldr	r3, [r3, #0]
3401819a:	f042 0201 	orr.w	r2, r2, #1
3401819e:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
340181a0:	687b      	ldr	r3, [r7, #4]
340181a2:	699b      	ldr	r3, [r3, #24]
340181a4:	2b02      	cmp	r3, #2
340181a6:	d107      	bne.n	340181b8 <HAL_XSPI_Init+0x1cc>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
340181a8:	687b      	ldr	r3, [r7, #4]
340181aa:	681b      	ldr	r3, [r3, #0]
340181ac:	689a      	ldr	r2, [r3, #8]
340181ae:	687b      	ldr	r3, [r7, #4]
340181b0:	681b      	ldr	r3, [r3, #0]
340181b2:	f042 0202 	orr.w	r2, r2, #2
340181b6:	609a      	str	r2, [r3, #8]
        }

        if (hxspi->Init.MemoryExtended == HAL_XSPI_CSSEL_HW)
340181b8:	687b      	ldr	r3, [r7, #4]
340181ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340181bc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
340181c0:	d107      	bne.n	340181d2 <HAL_XSPI_Init+0x1e6>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_EXTENDMEM);
340181c2:	687b      	ldr	r3, [r7, #4]
340181c4:	681b      	ldr	r3, [r3, #0]
340181c6:	689a      	ldr	r2, [r3, #8]
340181c8:	687b      	ldr	r3, [r7, #4]
340181ca:	681b      	ldr	r3, [r3, #0]
340181cc:	f442 1200 	orr.w	r2, r2, #2097152	@ 0x200000
340181d0:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340181d2:	687b      	ldr	r3, [r7, #4]
340181d4:	68db      	ldr	r3, [r3, #12]
340181d6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
340181da:	d103      	bne.n	340181e4 <HAL_XSPI_Init+0x1f8>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
340181dc:	687b      	ldr	r3, [r7, #4]
340181de:	2201      	movs	r2, #1
340181e0:	659a      	str	r2, [r3, #88]	@ 0x58
340181e2:	e002      	b.n	340181ea <HAL_XSPI_Init+0x1fe>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
340181e4:	687b      	ldr	r3, [r7, #4]
340181e6:	2202      	movs	r2, #2
340181e8:	659a      	str	r2, [r3, #88]	@ 0x58
        }
      }
    }
  }
  return status;
340181ea:	7bfb      	ldrb	r3, [r7, #15]
}
340181ec:	4618      	mov	r0, r3
340181ee:	3710      	adds	r7, #16
340181f0:	46bd      	mov	sp, r7
340181f2:	bd80      	pop	{r7, pc}
340181f4:	f8e0c0fc 	.word	0xf8e0c0fc
340181f8:	58025000 	.word	0x58025000
340181fc:	48025000 	.word	0x48025000
34018200:	5802a000 	.word	0x5802a000
34018204:	4802a000 	.word	0x4802a000
34018208:	5802d000 	.word	0x5802d000
3401820c:	4802d000 	.word	0x4802d000

34018210 <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, XSPI_RegularCmdTypeDef *const pCmd, uint32_t Timeout)
{
34018210:	b580      	push	{r7, lr}
34018212:	b08a      	sub	sp, #40	@ 0x28
34018214:	af02      	add	r7, sp, #8
34018216:	60f8      	str	r0, [r7, #12]
34018218:	60b9      	str	r1, [r7, #8]
3401821a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
3401821c:	f7ec fd07 	bl	34004c2e <HAL_GetTick>
34018220:	61b8      	str	r0, [r7, #24]
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018222:	68bb      	ldr	r3, [r7, #8]
34018224:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018226:	2b00      	cmp	r3, #0
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));

  /* Check the state of the driver */
  state = hxspi->State;
34018228:	68fb      	ldr	r3, [r7, #12]
3401822a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401822c:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
3401822e:	697b      	ldr	r3, [r7, #20]
34018230:	2b02      	cmp	r3, #2
34018232:	d104      	bne.n	3401823e <HAL_XSPI_Command+0x2e>
34018234:	68fb      	ldr	r3, [r7, #12]
34018236:	68db      	ldr	r3, [r3, #12]
34018238:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
3401823c:	d115      	bne.n	3401826a <HAL_XSPI_Command+0x5a>
3401823e:	697b      	ldr	r3, [r7, #20]
34018240:	2b14      	cmp	r3, #20
34018242:	d107      	bne.n	34018254 <HAL_XSPI_Command+0x44>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34018244:	68bb      	ldr	r3, [r7, #8]
34018246:	681b      	ldr	r3, [r3, #0]
34018248:	2b02      	cmp	r3, #2
3401824a:	d00e      	beq.n	3401826a <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
3401824c:	68bb      	ldr	r3, [r7, #8]
3401824e:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
34018250:	2b03      	cmp	r3, #3
34018252:	d00a      	beq.n	3401826a <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
34018254:	697b      	ldr	r3, [r7, #20]
34018256:	2b24      	cmp	r3, #36	@ 0x24
34018258:	d15e      	bne.n	34018318 <HAL_XSPI_Command+0x108>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
3401825a:	68bb      	ldr	r3, [r7, #8]
3401825c:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
3401825e:	2b01      	cmp	r3, #1
34018260:	d003      	beq.n	3401826a <HAL_XSPI_Command+0x5a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
34018262:	68bb      	ldr	r3, [r7, #8]
34018264:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
34018266:	2b03      	cmp	r3, #3
34018268:	d156      	bne.n	34018318 <HAL_XSPI_Command+0x108>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
3401826a:	687b      	ldr	r3, [r7, #4]
3401826c:	9300      	str	r3, [sp, #0]
3401826e:	69bb      	ldr	r3, [r7, #24]
34018270:	2200      	movs	r2, #0
34018272:	2120      	movs	r1, #32
34018274:	68f8      	ldr	r0, [r7, #12]
34018276:	f000 fd01 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
3401827a:	4603      	mov	r3, r0
3401827c:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
3401827e:	7ffb      	ldrb	r3, [r7, #31]
34018280:	2b00      	cmp	r3, #0
34018282:	d146      	bne.n	34018312 <HAL_XSPI_Command+0x102>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
34018284:	68fb      	ldr	r3, [r7, #12]
34018286:	2200      	movs	r2, #0
34018288:	65da      	str	r2, [r3, #92]	@ 0x5c

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
3401828a:	68b9      	ldr	r1, [r7, #8]
3401828c:	68f8      	ldr	r0, [r7, #12]
3401828e:	f000 fd2b 	bl	34018ce8 <XSPI_ConfigCmd>
34018292:	4603      	mov	r3, r0
34018294:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
34018296:	7ffb      	ldrb	r3, [r7, #31]
34018298:	2b00      	cmp	r3, #0
3401829a:	d143      	bne.n	34018324 <HAL_XSPI_Command+0x114>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
3401829c:	68bb      	ldr	r3, [r7, #8]
3401829e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340182a0:	2b00      	cmp	r3, #0
340182a2:	d10e      	bne.n	340182c2 <HAL_XSPI_Command+0xb2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until TC flag is set to go back in idle state */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
340182a4:	687b      	ldr	r3, [r7, #4]
340182a6:	9300      	str	r3, [sp, #0]
340182a8:	69bb      	ldr	r3, [r7, #24]
340182aa:	2201      	movs	r2, #1
340182ac:	2102      	movs	r1, #2
340182ae:	68f8      	ldr	r0, [r7, #12]
340182b0:	f000 fce4 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
340182b4:	4603      	mov	r3, r0
340182b6:	77fb      	strb	r3, [r7, #31]

          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
340182b8:	68fb      	ldr	r3, [r7, #12]
340182ba:	681b      	ldr	r3, [r3, #0]
340182bc:	2202      	movs	r2, #2
340182be:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
340182c0:	e030      	b.n	34018324 <HAL_XSPI_Command+0x114>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
340182c2:	68bb      	ldr	r3, [r7, #8]
340182c4:	681b      	ldr	r3, [r3, #0]
340182c6:	2b00      	cmp	r3, #0
340182c8:	d103      	bne.n	340182d2 <HAL_XSPI_Command+0xc2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
340182ca:	68fb      	ldr	r3, [r7, #12]
340182cc:	2204      	movs	r2, #4
340182ce:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340182d0:	e028      	b.n	34018324 <HAL_XSPI_Command+0x114>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
340182d2:	68bb      	ldr	r3, [r7, #8]
340182d4:	681b      	ldr	r3, [r3, #0]
340182d6:	2b01      	cmp	r3, #1
340182d8:	d10b      	bne.n	340182f2 <HAL_XSPI_Command+0xe2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
340182da:	68fb      	ldr	r3, [r7, #12]
340182dc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340182de:	2b24      	cmp	r3, #36	@ 0x24
340182e0:	d103      	bne.n	340182ea <HAL_XSPI_Command+0xda>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
340182e2:	68fb      	ldr	r3, [r7, #12]
340182e4:	2204      	movs	r2, #4
340182e6:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340182e8:	e01c      	b.n	34018324 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
340182ea:	68fb      	ldr	r3, [r7, #12]
340182ec:	2214      	movs	r2, #20
340182ee:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340182f0:	e018      	b.n	34018324 <HAL_XSPI_Command+0x114>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
340182f2:	68bb      	ldr	r3, [r7, #8]
340182f4:	681b      	ldr	r3, [r3, #0]
340182f6:	2b02      	cmp	r3, #2
340182f8:	d114      	bne.n	34018324 <HAL_XSPI_Command+0x114>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
340182fa:	68fb      	ldr	r3, [r7, #12]
340182fc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340182fe:	2b14      	cmp	r3, #20
34018300:	d103      	bne.n	3401830a <HAL_XSPI_Command+0xfa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
34018302:	68fb      	ldr	r3, [r7, #12]
34018304:	2204      	movs	r2, #4
34018306:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34018308:	e00c      	b.n	34018324 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
3401830a:	68fb      	ldr	r3, [r7, #12]
3401830c:	2224      	movs	r2, #36	@ 0x24
3401830e:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34018310:	e008      	b.n	34018324 <HAL_XSPI_Command+0x114>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
34018312:	2302      	movs	r3, #2
34018314:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
34018316:	e005      	b.n	34018324 <HAL_XSPI_Command+0x114>
    }
  }
  else
  {
    status = HAL_ERROR;
34018318:	2301      	movs	r3, #1
3401831a:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
3401831c:	68fb      	ldr	r3, [r7, #12]
3401831e:	2210      	movs	r2, #16
34018320:	65da      	str	r2, [r3, #92]	@ 0x5c
34018322:	e000      	b.n	34018326 <HAL_XSPI_Command+0x116>
    if (status == HAL_OK)
34018324:	bf00      	nop
  }

  return status;
34018326:	7ffb      	ldrb	r3, [r7, #31]
}
34018328:	4618      	mov	r0, r3
3401832a:	3720      	adds	r7, #32
3401832c:	46bd      	mov	sp, r7
3401832e:	bd80      	pop	{r7, pc}

34018330 <HAL_XSPI_HyperbusCfg>:
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_HyperbusCfg(XSPI_HandleTypeDef *hxspi, XSPI_HyperbusCfgTypeDef *const pCfg,
                                       uint32_t Timeout)
{
34018330:	b580      	push	{r7, lr}
34018332:	b08a      	sub	sp, #40	@ 0x28
34018334:	af02      	add	r7, sp, #8
34018336:	60f8      	str	r0, [r7, #12]
34018338:	60b9      	str	r1, [r7, #8]
3401833a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
3401833c:	f7ec fc77 	bl	34004c2e <HAL_GetTick>
34018340:	61b8      	str	r0, [r7, #24]
  assert_param(IS_XSPI_ACCESS_TIME_CYCLE(pCfg->AccessTimeCycle));
  assert_param(IS_XSPI_WRITE_ZERO_LATENCY(pCfg->WriteZeroLatency));
  assert_param(IS_XSPI_LATENCY_MODE(pCfg->LatencyMode));

  /* Check the state of the driver */
  state = hxspi->State;
34018342:	68fb      	ldr	r3, [r7, #12]
34018344:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34018346:	617b      	str	r3, [r7, #20]
  if ((state == HAL_XSPI_STATE_HYPERBUS_INIT) || (state == HAL_XSPI_STATE_READY))
34018348:	697b      	ldr	r3, [r7, #20]
3401834a:	2b01      	cmp	r3, #1
3401834c:	d002      	beq.n	34018354 <HAL_XSPI_HyperbusCfg+0x24>
3401834e:	697b      	ldr	r3, [r7, #20]
34018350:	2b02      	cmp	r3, #2
34018352:	d125      	bne.n	340183a0 <HAL_XSPI_HyperbusCfg+0x70>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
34018354:	687b      	ldr	r3, [r7, #4]
34018356:	9300      	str	r3, [sp, #0]
34018358:	69bb      	ldr	r3, [r7, #24]
3401835a:	2200      	movs	r2, #0
3401835c:	2120      	movs	r1, #32
3401835e:	68f8      	ldr	r0, [r7, #12]
34018360:	f000 fc8c 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018364:	4603      	mov	r3, r0
34018366:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
34018368:	7ffb      	ldrb	r3, [r7, #31]
3401836a:	2b00      	cmp	r3, #0
3401836c:	d115      	bne.n	3401839a <HAL_XSPI_HyperbusCfg+0x6a>
    {
      /* Configure Hyperbus configuration Latency register */
      WRITE_REG(hxspi->Instance->HLCR, ((pCfg->RWRecoveryTimeCycle << XSPI_HLCR_TRWR_Pos) |
3401836e:	68bb      	ldr	r3, [r7, #8]
34018370:	681b      	ldr	r3, [r3, #0]
34018372:	041a      	lsls	r2, r3, #16
34018374:	68bb      	ldr	r3, [r7, #8]
34018376:	685b      	ldr	r3, [r3, #4]
34018378:	021b      	lsls	r3, r3, #8
3401837a:	431a      	orrs	r2, r3
3401837c:	68bb      	ldr	r3, [r7, #8]
3401837e:	689b      	ldr	r3, [r3, #8]
34018380:	ea42 0103 	orr.w	r1, r2, r3
34018384:	68bb      	ldr	r3, [r7, #8]
34018386:	68da      	ldr	r2, [r3, #12]
34018388:	68fb      	ldr	r3, [r7, #12]
3401838a:	681b      	ldr	r3, [r3, #0]
3401838c:	430a      	orrs	r2, r1
3401838e:	f8c3 2200 	str.w	r2, [r3, #512]	@ 0x200
                                        (pCfg->AccessTimeCycle << XSPI_HLCR_TACC_Pos)     |
                                        pCfg->WriteZeroLatency | pCfg->LatencyMode));

      /* Update the state */
      hxspi->State = HAL_XSPI_STATE_READY;
34018392:	68fb      	ldr	r3, [r7, #12]
34018394:	2202      	movs	r2, #2
34018396:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34018398:	e007      	b.n	340183aa <HAL_XSPI_HyperbusCfg+0x7a>
    }
    else
    {
      status = HAL_BUSY;
3401839a:	2302      	movs	r3, #2
3401839c:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
3401839e:	e004      	b.n	340183aa <HAL_XSPI_HyperbusCfg+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
340183a0:	2301      	movs	r3, #1
340183a2:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340183a4:	68fb      	ldr	r3, [r7, #12]
340183a6:	2210      	movs	r2, #16
340183a8:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
340183aa:	7ffb      	ldrb	r3, [r7, #31]
}
340183ac:	4618      	mov	r0, r3
340183ae:	3720      	adds	r7, #32
340183b0:	46bd      	mov	sp, r7
340183b2:	bd80      	pop	{r7, pc}

340183b4 <HAL_XSPI_HyperbusCmd>:
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_HyperbusCmd(XSPI_HandleTypeDef *hxspi, XSPI_HyperbusCmdTypeDef *const pCmd,
                                       uint32_t Timeout)
{
340183b4:	b580      	push	{r7, lr}
340183b6:	b088      	sub	sp, #32
340183b8:	af02      	add	r7, sp, #8
340183ba:	60f8      	str	r0, [r7, #12]
340183bc:	60b9      	str	r1, [r7, #8]
340183be:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
340183c0:	f7ec fc35 	bl	34004c2e <HAL_GetTick>
340183c4:	6138      	str	r0, [r7, #16]
  assert_param(IS_XSPI_DATA_LENGTH(pCmd->DataLength));
  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));
  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));

  /* Check the state of the driver */
  if ((hxspi->State == HAL_XSPI_STATE_READY) && (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS))
340183c6:	68fb      	ldr	r3, [r7, #12]
340183c8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340183ca:	2b02      	cmp	r3, #2
340183cc:	d156      	bne.n	3401847c <HAL_XSPI_HyperbusCmd+0xc8>
340183ce:	68fb      	ldr	r3, [r7, #12]
340183d0:	68db      	ldr	r3, [r3, #12]
340183d2:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
340183d6:	d151      	bne.n	3401847c <HAL_XSPI_HyperbusCmd+0xc8>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
340183d8:	687b      	ldr	r3, [r7, #4]
340183da:	9300      	str	r3, [sp, #0]
340183dc:	693b      	ldr	r3, [r7, #16]
340183de:	2200      	movs	r2, #0
340183e0:	2120      	movs	r1, #32
340183e2:	68f8      	ldr	r0, [r7, #12]
340183e4:	f000 fc4a 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
340183e8:	4603      	mov	r3, r0
340183ea:	75fb      	strb	r3, [r7, #23]

    if (status == HAL_OK)
340183ec:	7dfb      	ldrb	r3, [r7, #23]
340183ee:	2b00      	cmp	r3, #0
340183f0:	d141      	bne.n	34018476 <HAL_XSPI_HyperbusCmd+0xc2>
    {
      /* Re-initialize the value of the functional mode */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
340183f2:	68fb      	ldr	r3, [r7, #12]
340183f4:	681b      	ldr	r3, [r3, #0]
340183f6:	681a      	ldr	r2, [r3, #0]
340183f8:	68fb      	ldr	r3, [r7, #12]
340183fa:	681b      	ldr	r3, [r3, #0]
340183fc:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34018400:	601a      	str	r2, [r3, #0]

      /* Configure the address space in the DCR1 register */
      MODIFY_REG(hxspi->Instance->DCR1, XSPI_DCR1_MTYP_0, pCmd->AddressSpace);
34018402:	68fb      	ldr	r3, [r7, #12]
34018404:	681b      	ldr	r3, [r3, #0]
34018406:	689b      	ldr	r3, [r3, #8]
34018408:	f023 7180 	bic.w	r1, r3, #16777216	@ 0x1000000
3401840c:	68bb      	ldr	r3, [r7, #8]
3401840e:	681a      	ldr	r2, [r3, #0]
34018410:	68fb      	ldr	r3, [r7, #12]
34018412:	681b      	ldr	r3, [r3, #0]
34018414:	430a      	orrs	r2, r1
34018416:	609a      	str	r2, [r3, #8]

      /* Configure the CCR and WCCR registers with the address size and the following configuration :
         - DQS signal enabled (used as RWDS)
         - DTR mode enabled on address and data */
      /* - address and data on 8 or 16 lines */
      WRITE_REG(hxspi->Instance->CCR, (pCmd->DQSMode | XSPI_CCR_DDTR | pCmd->DataMode |
34018418:	68bb      	ldr	r3, [r7, #8]
3401841a:	691a      	ldr	r2, [r3, #16]
3401841c:	68bb      	ldr	r3, [r7, #8]
3401841e:	695b      	ldr	r3, [r3, #20]
34018420:	431a      	orrs	r2, r3
34018422:	68bb      	ldr	r3, [r7, #8]
34018424:	689b      	ldr	r3, [r3, #8]
34018426:	4313      	orrs	r3, r2
34018428:	68fa      	ldr	r2, [r7, #12]
3401842a:	6812      	ldr	r2, [r2, #0]
3401842c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34018430:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
34018434:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                                       pCmd->AddressWidth | XSPI_CCR_ADDTR | XSPI_CCR_ADMODE_2));
      WRITE_REG(hxspi->Instance->WCCR, (pCmd->DQSMode | XSPI_WCCR_DDTR | pCmd->DataMode |
34018438:	68bb      	ldr	r3, [r7, #8]
3401843a:	691a      	ldr	r2, [r3, #16]
3401843c:	68bb      	ldr	r3, [r7, #8]
3401843e:	695b      	ldr	r3, [r3, #20]
34018440:	431a      	orrs	r2, r3
34018442:	68bb      	ldr	r3, [r7, #8]
34018444:	689b      	ldr	r3, [r3, #8]
34018446:	4313      	orrs	r3, r2
34018448:	68fa      	ldr	r2, [r7, #12]
3401844a:	6812      	ldr	r2, [r2, #0]
3401844c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
34018450:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
34018454:	f8c2 3180 	str.w	r3, [r2, #384]	@ 0x180
                                        pCmd->AddressWidth | XSPI_WCCR_ADDTR | XSPI_WCCR_ADMODE_2));

      /* Configure the DLR register with the number of data */
      WRITE_REG(hxspi->Instance->DLR, (pCmd->DataLength - 1U));
34018458:	68bb      	ldr	r3, [r7, #8]
3401845a:	68da      	ldr	r2, [r3, #12]
3401845c:	68fb      	ldr	r3, [r7, #12]
3401845e:	681b      	ldr	r3, [r3, #0]
34018460:	3a01      	subs	r2, #1
34018462:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Configure the AR register with the address value */
      WRITE_REG(hxspi->Instance->AR, pCmd->Address);
34018464:	68fb      	ldr	r3, [r7, #12]
34018466:	681b      	ldr	r3, [r3, #0]
34018468:	68ba      	ldr	r2, [r7, #8]
3401846a:	6852      	ldr	r2, [r2, #4]
3401846c:	649a      	str	r2, [r3, #72]	@ 0x48

      /* Update the state */
      hxspi->State = HAL_XSPI_STATE_CMD_CFG;
3401846e:	68fb      	ldr	r3, [r7, #12]
34018470:	2204      	movs	r2, #4
34018472:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
34018474:	e007      	b.n	34018486 <HAL_XSPI_HyperbusCmd+0xd2>
    }
    else
    {
      status = HAL_BUSY;
34018476:	2302      	movs	r3, #2
34018478:	75fb      	strb	r3, [r7, #23]
    if (status == HAL_OK)
3401847a:	e004      	b.n	34018486 <HAL_XSPI_HyperbusCmd+0xd2>
    }
  }
  else
  {
    status = HAL_ERROR;
3401847c:	2301      	movs	r3, #1
3401847e:	75fb      	strb	r3, [r7, #23]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34018480:	68fb      	ldr	r3, [r7, #12]
34018482:	2210      	movs	r2, #16
34018484:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
34018486:	7dfb      	ldrb	r3, [r7, #23]
}
34018488:	4618      	mov	r0, r3
3401848a:	3718      	adds	r7, #24
3401848c:	46bd      	mov	sp, r7
3401848e:	bd80      	pop	{r7, pc}

34018490 <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
34018490:	b580      	push	{r7, lr}
34018492:	b08a      	sub	sp, #40	@ 0x28
34018494:	af02      	add	r7, sp, #8
34018496:	60f8      	str	r0, [r7, #12]
34018498:	60b9      	str	r1, [r7, #8]
3401849a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
3401849c:	f7ec fbc7 	bl	34004c2e <HAL_GetTick>
340184a0:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
340184a2:	68fb      	ldr	r3, [r7, #12]
340184a4:	681b      	ldr	r3, [r3, #0]
340184a6:	3350      	adds	r3, #80	@ 0x50
340184a8:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
340184aa:	68bb      	ldr	r3, [r7, #8]
340184ac:	2b00      	cmp	r3, #0
340184ae:	d105      	bne.n	340184bc <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
340184b0:	2301      	movs	r3, #1
340184b2:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
340184b4:	68fb      	ldr	r3, [r7, #12]
340184b6:	2208      	movs	r2, #8
340184b8:	65da      	str	r2, [r3, #92]	@ 0x5c
340184ba:	e057      	b.n	3401856c <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340184bc:	68fb      	ldr	r3, [r7, #12]
340184be:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340184c0:	2b04      	cmp	r3, #4
340184c2:	d14e      	bne.n	34018562 <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
340184c4:	68fb      	ldr	r3, [r7, #12]
340184c6:	681b      	ldr	r3, [r3, #0]
340184c8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340184ca:	1c5a      	adds	r2, r3, #1
340184cc:	68fb      	ldr	r3, [r7, #12]
340184ce:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
340184d0:	68fb      	ldr	r3, [r7, #12]
340184d2:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
340184d4:	68fb      	ldr	r3, [r7, #12]
340184d6:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = (uint8_t *)pData;
340184d8:	68fb      	ldr	r3, [r7, #12]
340184da:	68ba      	ldr	r2, [r7, #8]
340184dc:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
340184de:	68fb      	ldr	r3, [r7, #12]
340184e0:	681b      	ldr	r3, [r3, #0]
340184e2:	681a      	ldr	r2, [r3, #0]
340184e4:	68fb      	ldr	r3, [r7, #12]
340184e6:	681b      	ldr	r3, [r3, #0]
340184e8:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
340184ec:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
340184ee:	687b      	ldr	r3, [r7, #4]
340184f0:	9300      	str	r3, [sp, #0]
340184f2:	69bb      	ldr	r3, [r7, #24]
340184f4:	2201      	movs	r2, #1
340184f6:	2104      	movs	r1, #4
340184f8:	68f8      	ldr	r0, [r7, #12]
340184fa:	f000 fbbf 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
340184fe:	4603      	mov	r3, r0
34018500:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
34018502:	7ffb      	ldrb	r3, [r7, #31]
34018504:	2b00      	cmp	r3, #0
34018506:	d113      	bne.n	34018530 <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
34018508:	68fb      	ldr	r3, [r7, #12]
3401850a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401850c:	781a      	ldrb	r2, [r3, #0]
3401850e:	697b      	ldr	r3, [r7, #20]
34018510:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
34018512:	68fb      	ldr	r3, [r7, #12]
34018514:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34018516:	1c5a      	adds	r2, r3, #1
34018518:	68fb      	ldr	r3, [r7, #12]
3401851a:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
3401851c:	68fb      	ldr	r3, [r7, #12]
3401851e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34018520:	1e5a      	subs	r2, r3, #1
34018522:	68fb      	ldr	r3, [r7, #12]
34018524:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34018526:	68fb      	ldr	r3, [r7, #12]
34018528:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401852a:	2b00      	cmp	r3, #0
3401852c:	d1df      	bne.n	340184ee <HAL_XSPI_Transmit+0x5e>
3401852e:	e000      	b.n	34018532 <HAL_XSPI_Transmit+0xa2>
          break;
34018530:	bf00      	nop

      if (status == HAL_OK)
34018532:	7ffb      	ldrb	r3, [r7, #31]
34018534:	2b00      	cmp	r3, #0
34018536:	d119      	bne.n	3401856c <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
34018538:	687b      	ldr	r3, [r7, #4]
3401853a:	9300      	str	r3, [sp, #0]
3401853c:	69bb      	ldr	r3, [r7, #24]
3401853e:	2201      	movs	r2, #1
34018540:	2102      	movs	r1, #2
34018542:	68f8      	ldr	r0, [r7, #12]
34018544:	f000 fb9a 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018548:	4603      	mov	r3, r0
3401854a:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
3401854c:	7ffb      	ldrb	r3, [r7, #31]
3401854e:	2b00      	cmp	r3, #0
34018550:	d10c      	bne.n	3401856c <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34018552:	68fb      	ldr	r3, [r7, #12]
34018554:	681b      	ldr	r3, [r3, #0]
34018556:	2202      	movs	r2, #2
34018558:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3401855a:	68fb      	ldr	r3, [r7, #12]
3401855c:	2202      	movs	r2, #2
3401855e:	659a      	str	r2, [r3, #88]	@ 0x58
34018560:	e004      	b.n	3401856c <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
34018562:	2301      	movs	r3, #1
34018564:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34018566:	68fb      	ldr	r3, [r7, #12]
34018568:	2210      	movs	r2, #16
3401856a:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
3401856c:	7ffb      	ldrb	r3, [r7, #31]
}
3401856e:	4618      	mov	r0, r3
34018570:	3720      	adds	r7, #32
34018572:	46bd      	mov	sp, r7
34018574:	bd80      	pop	{r7, pc}

34018576 <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *const pData, uint32_t Timeout)
{
34018576:	b580      	push	{r7, lr}
34018578:	b08c      	sub	sp, #48	@ 0x30
3401857a:	af02      	add	r7, sp, #8
3401857c:	60f8      	str	r0, [r7, #12]
3401857e:	60b9      	str	r1, [r7, #8]
34018580:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
34018582:	f7ec fb54 	bl	34004c2e <HAL_GetTick>
34018586:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
34018588:	68fb      	ldr	r3, [r7, #12]
3401858a:	681b      	ldr	r3, [r3, #0]
3401858c:	3350      	adds	r3, #80	@ 0x50
3401858e:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
34018590:	68fb      	ldr	r3, [r7, #12]
34018592:	681b      	ldr	r3, [r3, #0]
34018594:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34018596:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
34018598:	68fb      	ldr	r3, [r7, #12]
3401859a:	681b      	ldr	r3, [r3, #0]
3401859c:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
340185a0:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
340185a2:	68bb      	ldr	r3, [r7, #8]
340185a4:	2b00      	cmp	r3, #0
340185a6:	d106      	bne.n	340185b6 <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
340185a8:	2301      	movs	r3, #1
340185aa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
340185ae:	68fb      	ldr	r3, [r7, #12]
340185b0:	2208      	movs	r2, #8
340185b2:	65da      	str	r2, [r3, #92]	@ 0x5c
340185b4:	e07c      	b.n	340186b0 <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340185b6:	68fb      	ldr	r3, [r7, #12]
340185b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340185ba:	2b04      	cmp	r3, #4
340185bc:	d172      	bne.n	340186a4 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
340185be:	68fb      	ldr	r3, [r7, #12]
340185c0:	681b      	ldr	r3, [r3, #0]
340185c2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
340185c4:	1c5a      	adds	r2, r3, #1
340185c6:	68fb      	ldr	r3, [r7, #12]
340185c8:	64da      	str	r2, [r3, #76]	@ 0x4c
      hxspi->XferSize  = hxspi->XferCount;
340185ca:	68fb      	ldr	r3, [r7, #12]
340185cc:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
340185ce:	68fb      	ldr	r3, [r7, #12]
340185d0:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->pBuffPtr  = pData;
340185d2:	68fb      	ldr	r3, [r7, #12]
340185d4:	68ba      	ldr	r2, [r7, #8]
340185d6:	645a      	str	r2, [r3, #68]	@ 0x44

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
340185d8:	68fb      	ldr	r3, [r7, #12]
340185da:	681b      	ldr	r3, [r3, #0]
340185dc:	681b      	ldr	r3, [r3, #0]
340185de:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
340185e2:	68fb      	ldr	r3, [r7, #12]
340185e4:	681b      	ldr	r3, [r3, #0]
340185e6:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
340185ea:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
340185ec:	68fb      	ldr	r3, [r7, #12]
340185ee:	68db      	ldr	r3, [r3, #12]
340185f0:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
340185f4:	d104      	bne.n	34018600 <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
340185f6:	68fb      	ldr	r3, [r7, #12]
340185f8:	681b      	ldr	r3, [r3, #0]
340185fa:	69ba      	ldr	r2, [r7, #24]
340185fc:	649a      	str	r2, [r3, #72]	@ 0x48
340185fe:	e011      	b.n	34018624 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34018600:	68fb      	ldr	r3, [r7, #12]
34018602:	681b      	ldr	r3, [r3, #0]
34018604:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34018608:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
3401860c:	2b00      	cmp	r3, #0
3401860e:	d004      	beq.n	3401861a <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34018610:	68fb      	ldr	r3, [r7, #12]
34018612:	681b      	ldr	r3, [r3, #0]
34018614:	69ba      	ldr	r2, [r7, #24]
34018616:	649a      	str	r2, [r3, #72]	@ 0x48
34018618:	e004      	b.n	34018624 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401861a:	68fb      	ldr	r3, [r7, #12]
3401861c:	681b      	ldr	r3, [r3, #0]
3401861e:	697a      	ldr	r2, [r7, #20]
34018620:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
34018624:	687b      	ldr	r3, [r7, #4]
34018626:	9300      	str	r3, [sp, #0]
34018628:	6a3b      	ldr	r3, [r7, #32]
3401862a:	2201      	movs	r2, #1
3401862c:	2106      	movs	r1, #6
3401862e:	68f8      	ldr	r0, [r7, #12]
34018630:	f000 fb24 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018634:	4603      	mov	r3, r0
34018636:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
3401863a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401863e:	2b00      	cmp	r3, #0
34018640:	d114      	bne.n	3401866c <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
34018642:	68fb      	ldr	r3, [r7, #12]
34018644:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34018646:	69fa      	ldr	r2, [r7, #28]
34018648:	7812      	ldrb	r2, [r2, #0]
3401864a:	b2d2      	uxtb	r2, r2
3401864c:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
3401864e:	68fb      	ldr	r3, [r7, #12]
34018650:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34018652:	1c5a      	adds	r2, r3, #1
34018654:	68fb      	ldr	r3, [r7, #12]
34018656:	645a      	str	r2, [r3, #68]	@ 0x44
        hxspi->XferCount--;
34018658:	68fb      	ldr	r3, [r7, #12]
3401865a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401865c:	1e5a      	subs	r2, r3, #1
3401865e:	68fb      	ldr	r3, [r7, #12]
34018660:	64da      	str	r2, [r3, #76]	@ 0x4c
      } while (hxspi->XferCount > 0U);
34018662:	68fb      	ldr	r3, [r7, #12]
34018664:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34018666:	2b00      	cmp	r3, #0
34018668:	d1dc      	bne.n	34018624 <HAL_XSPI_Receive+0xae>
3401866a:	e000      	b.n	3401866e <HAL_XSPI_Receive+0xf8>
          break;
3401866c:	bf00      	nop

      if (status == HAL_OK)
3401866e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34018672:	2b00      	cmp	r3, #0
34018674:	d11c      	bne.n	340186b0 <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
34018676:	687b      	ldr	r3, [r7, #4]
34018678:	9300      	str	r3, [sp, #0]
3401867a:	6a3b      	ldr	r3, [r7, #32]
3401867c:	2201      	movs	r2, #1
3401867e:	2102      	movs	r1, #2
34018680:	68f8      	ldr	r0, [r7, #12]
34018682:	f000 fafb 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018686:	4603      	mov	r3, r0
34018688:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
3401868c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
34018690:	2b00      	cmp	r3, #0
34018692:	d10d      	bne.n	340186b0 <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
34018694:	68fb      	ldr	r3, [r7, #12]
34018696:	681b      	ldr	r3, [r3, #0]
34018698:	2202      	movs	r2, #2
3401869a:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
3401869c:	68fb      	ldr	r3, [r7, #12]
3401869e:	2202      	movs	r2, #2
340186a0:	659a      	str	r2, [r3, #88]	@ 0x58
340186a2:	e005      	b.n	340186b0 <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
340186a4:	2301      	movs	r3, #1
340186a6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340186aa:	68fb      	ldr	r3, [r7, #12]
340186ac:	2210      	movs	r2, #16
340186ae:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
340186b0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
340186b4:	4618      	mov	r0, r3
340186b6:	3728      	adds	r7, #40	@ 0x28
340186b8:	46bd      	mov	sp, r7
340186ba:	bd80      	pop	{r7, pc}

340186bc <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, XSPI_AutoPollingTypeDef *const pCfg,
                                       uint32_t Timeout)
{
340186bc:	b580      	push	{r7, lr}
340186be:	b08a      	sub	sp, #40	@ 0x28
340186c0:	af02      	add	r7, sp, #8
340186c2:	60f8      	str	r0, [r7, #12]
340186c4:	60b9      	str	r1, [r7, #8]
340186c6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
340186c8:	f7ec fab1 	bl	34004c2e <HAL_GetTick>
340186cc:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = hxspi->Instance->AR;
340186ce:	68fb      	ldr	r3, [r7, #12]
340186d0:	681b      	ldr	r3, [r3, #0]
340186d2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340186d4:	617b      	str	r3, [r7, #20]
  uint32_t ir_reg = hxspi->Instance->IR;
340186d6:	68fb      	ldr	r3, [r7, #12]
340186d8:	681b      	ldr	r3, [r3, #0]
340186da:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
340186de:	613b      	str	r3, [r7, #16]
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
340186e0:	68fb      	ldr	r3, [r7, #12]
340186e2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340186e4:	2b04      	cmp	r3, #4
340186e6:	d167      	bne.n	340187b8 <HAL_XSPI_AutoPolling+0xfc>
340186e8:	68bb      	ldr	r3, [r7, #8]
340186ea:	68db      	ldr	r3, [r3, #12]
340186ec:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
340186f0:	d162      	bne.n	340187b8 <HAL_XSPI_AutoPolling+0xfc>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
340186f2:	687b      	ldr	r3, [r7, #4]
340186f4:	9300      	str	r3, [sp, #0]
340186f6:	69bb      	ldr	r3, [r7, #24]
340186f8:	2200      	movs	r2, #0
340186fa:	2120      	movs	r1, #32
340186fc:	68f8      	ldr	r0, [r7, #12]
340186fe:	f000 fabd 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018702:	4603      	mov	r3, r0
34018704:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
34018706:	7ffb      	ldrb	r3, [r7, #31]
34018708:	2b00      	cmp	r3, #0
3401870a:	d152      	bne.n	340187b2 <HAL_XSPI_AutoPolling+0xf6>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
3401870c:	68fb      	ldr	r3, [r7, #12]
3401870e:	681b      	ldr	r3, [r3, #0]
34018710:	68ba      	ldr	r2, [r7, #8]
34018712:	6812      	ldr	r2, [r2, #0]
34018714:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
34018718:	68fb      	ldr	r3, [r7, #12]
3401871a:	681b      	ldr	r3, [r3, #0]
3401871c:	68ba      	ldr	r2, [r7, #8]
3401871e:	6852      	ldr	r2, [r2, #4]
34018720:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
34018724:	68fb      	ldr	r3, [r7, #12]
34018726:	681b      	ldr	r3, [r3, #0]
34018728:	68ba      	ldr	r2, [r7, #8]
3401872a:	6912      	ldr	r2, [r2, #16]
3401872c:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
34018730:	68fb      	ldr	r3, [r7, #12]
34018732:	681b      	ldr	r3, [r3, #0]
34018734:	681b      	ldr	r3, [r3, #0]
34018736:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
3401873a:	68bb      	ldr	r3, [r7, #8]
3401873c:	6899      	ldr	r1, [r3, #8]
3401873e:	68bb      	ldr	r3, [r7, #8]
34018740:	68db      	ldr	r3, [r3, #12]
34018742:	430b      	orrs	r3, r1
34018744:	431a      	orrs	r2, r3
34018746:	68fb      	ldr	r3, [r7, #12]
34018748:	681b      	ldr	r3, [r3, #0]
3401874a:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
3401874e:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
34018750:	68fb      	ldr	r3, [r7, #12]
34018752:	68db      	ldr	r3, [r3, #12]
34018754:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
34018758:	d104      	bne.n	34018764 <HAL_XSPI_AutoPolling+0xa8>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
3401875a:	68fb      	ldr	r3, [r7, #12]
3401875c:	681b      	ldr	r3, [r3, #0]
3401875e:	697a      	ldr	r2, [r7, #20]
34018760:	649a      	str	r2, [r3, #72]	@ 0x48
34018762:	e011      	b.n	34018788 <HAL_XSPI_AutoPolling+0xcc>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
34018764:	68fb      	ldr	r3, [r7, #12]
34018766:	681b      	ldr	r3, [r3, #0]
34018768:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401876c:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
34018770:	2b00      	cmp	r3, #0
34018772:	d004      	beq.n	3401877e <HAL_XSPI_AutoPolling+0xc2>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
34018774:	68fb      	ldr	r3, [r7, #12]
34018776:	681b      	ldr	r3, [r3, #0]
34018778:	697a      	ldr	r2, [r7, #20]
3401877a:	649a      	str	r2, [r3, #72]	@ 0x48
3401877c:	e004      	b.n	34018788 <HAL_XSPI_AutoPolling+0xcc>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
3401877e:	68fb      	ldr	r3, [r7, #12]
34018780:	681b      	ldr	r3, [r3, #0]
34018782:	693a      	ldr	r2, [r7, #16]
34018784:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
34018788:	687b      	ldr	r3, [r7, #4]
3401878a:	9300      	str	r3, [sp, #0]
3401878c:	69bb      	ldr	r3, [r7, #24]
3401878e:	2201      	movs	r2, #1
34018790:	2108      	movs	r1, #8
34018792:	68f8      	ldr	r0, [r7, #12]
34018794:	f000 fa72 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018798:	4603      	mov	r3, r0
3401879a:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
3401879c:	7ffb      	ldrb	r3, [r7, #31]
3401879e:	2b00      	cmp	r3, #0
340187a0:	d110      	bne.n	340187c4 <HAL_XSPI_AutoPolling+0x108>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
340187a2:	68fb      	ldr	r3, [r7, #12]
340187a4:	681b      	ldr	r3, [r3, #0]
340187a6:	2208      	movs	r2, #8
340187a8:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
340187aa:	68fb      	ldr	r3, [r7, #12]
340187ac:	2202      	movs	r2, #2
340187ae:	659a      	str	r2, [r3, #88]	@ 0x58
    if (status == HAL_OK)
340187b0:	e008      	b.n	340187c4 <HAL_XSPI_AutoPolling+0x108>
      }
    }
    else
    {
      status = HAL_BUSY;
340187b2:	2302      	movs	r3, #2
340187b4:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
340187b6:	e005      	b.n	340187c4 <HAL_XSPI_AutoPolling+0x108>
    }
  }
  else
  {
    status = HAL_ERROR;
340187b8:	2301      	movs	r3, #1
340187ba:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340187bc:	68fb      	ldr	r3, [r7, #12]
340187be:	2210      	movs	r2, #16
340187c0:	65da      	str	r2, [r3, #92]	@ 0x5c
340187c2:	e000      	b.n	340187c6 <HAL_XSPI_AutoPolling+0x10a>
    if (status == HAL_OK)
340187c4:	bf00      	nop
  }

  return status;
340187c6:	7ffb      	ldrb	r3, [r7, #31]
}
340187c8:	4618      	mov	r0, r3
340187ca:	3720      	adds	r7, #32
340187cc:	46bd      	mov	sp, r7
340187ce:	bd80      	pop	{r7, pc}

340187d0 <HAL_XSPI_MemoryMapped>:
  * @param  pCfg   : Pointer to structure that contains the memory mapped configuration information.
  * @note   This function is used only in Memory mapped Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_MemoryMapped(XSPI_HandleTypeDef *hxspi, XSPI_MemoryMappedTypeDef *const pCfg)
{
340187d0:	b580      	push	{r7, lr}
340187d2:	b086      	sub	sp, #24
340187d4:	af02      	add	r7, sp, #8
340187d6:	6078      	str	r0, [r7, #4]
340187d8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
340187da:	f7ec fa28 	bl	34004c2e <HAL_GetTick>
340187de:	60b8      	str	r0, [r7, #8]
  /* Check the parameters of the memory-mapped configuration structure */
  assert_param(IS_XSPI_TIMEOUT_ACTIVATION(pCfg->TimeOutActivation));
  assert_param(IS_XSPI_NO_PREFETCH_DATA(pCfg->NoPrefetchData));

  /* Check the state */
  if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
340187e0:	687b      	ldr	r3, [r7, #4]
340187e2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340187e4:	2b04      	cmp	r3, #4
340187e6:	d155      	bne.n	34018894 <HAL_XSPI_MemoryMapped+0xc4>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
340187e8:	687b      	ldr	r3, [r7, #4]
340187ea:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
340187ec:	9300      	str	r3, [sp, #0]
340187ee:	68bb      	ldr	r3, [r7, #8]
340187f0:	2200      	movs	r2, #0
340187f2:	2120      	movs	r1, #32
340187f4:	6878      	ldr	r0, [r7, #4]
340187f6:	f000 fa41 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
340187fa:	4603      	mov	r3, r0
340187fc:	73fb      	strb	r3, [r7, #15]

    if (status == HAL_OK)
340187fe:	7bfb      	ldrb	r3, [r7, #15]
34018800:	2b00      	cmp	r3, #0
34018802:	d14c      	bne.n	3401889e <HAL_XSPI_MemoryMapped+0xce>
    {
      hxspi->State = HAL_XSPI_STATE_BUSY_MEM_MAPPED;
34018804:	687b      	ldr	r3, [r7, #4]
34018806:	2288      	movs	r2, #136	@ 0x88
34018808:	659a      	str	r2, [r3, #88]	@ 0x58

      if (pCfg->NoPrefetchData == HAL_XSPI_AUTOMATIC_PREFETCH_DISABLE)
3401880a:	683b      	ldr	r3, [r7, #0]
3401880c:	689b      	ldr	r3, [r3, #8]
3401880e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34018812:	d10b      	bne.n	3401882c <HAL_XSPI_MemoryMapped+0x5c>
      {
        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, XSPI_CR_NOPREF, pCfg->NoPrefetchData);
34018814:	687b      	ldr	r3, [r7, #4]
34018816:	681b      	ldr	r3, [r3, #0]
34018818:	681b      	ldr	r3, [r3, #0]
3401881a:	f023 7100 	bic.w	r1, r3, #33554432	@ 0x2000000
3401881e:	683b      	ldr	r3, [r7, #0]
34018820:	689a      	ldr	r2, [r3, #8]
34018822:	687b      	ldr	r3, [r7, #4]
34018824:	681b      	ldr	r3, [r3, #0]
34018826:	430a      	orrs	r2, r1
34018828:	601a      	str	r2, [r3, #0]
3401882a:	e00d      	b.n	34018848 <HAL_XSPI_MemoryMapped+0x78>
      else
      {
        assert_param(IS_XSPI_NO_PREFETCH_AXI(pCfg->NoPrefetchAXI));

        /* Configure register */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_NOPREF | XSPI_CR_NOPREF_AXI),
3401882c:	687b      	ldr	r3, [r7, #4]
3401882e:	681b      	ldr	r3, [r3, #0]
34018830:	681b      	ldr	r3, [r3, #0]
34018832:	f023 61c0 	bic.w	r1, r3, #100663296	@ 0x6000000
34018836:	683b      	ldr	r3, [r7, #0]
34018838:	689a      	ldr	r2, [r3, #8]
3401883a:	683b      	ldr	r3, [r7, #0]
3401883c:	68db      	ldr	r3, [r3, #12]
3401883e:	431a      	orrs	r2, r3
34018840:	687b      	ldr	r3, [r7, #4]
34018842:	681b      	ldr	r3, [r3, #0]
34018844:	430a      	orrs	r2, r1
34018846:	601a      	str	r2, [r3, #0]
                   (pCfg->NoPrefetchData | pCfg->NoPrefetchAXI));
      }
      if (pCfg->TimeOutActivation == HAL_XSPI_TIMEOUT_COUNTER_ENABLE)
34018848:	683b      	ldr	r3, [r7, #0]
3401884a:	681b      	ldr	r3, [r3, #0]
3401884c:	2b08      	cmp	r3, #8
3401884e:	d111      	bne.n	34018874 <HAL_XSPI_MemoryMapped+0xa4>
      {
        assert_param(IS_XSPI_TIMEOUT_PERIOD(pCfg->TimeoutPeriodClock));

        /* Configure register */
        WRITE_REG(hxspi->Instance->LPTR, pCfg->TimeoutPeriodClock);
34018850:	687b      	ldr	r3, [r7, #4]
34018852:	681b      	ldr	r3, [r3, #0]
34018854:	683a      	ldr	r2, [r7, #0]
34018856:	6852      	ldr	r2, [r2, #4]
34018858:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

        /* Clear flags related to interrupt */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TO);
3401885c:	687b      	ldr	r3, [r7, #4]
3401885e:	681b      	ldr	r3, [r3, #0]
34018860:	2210      	movs	r2, #16
34018862:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Enable the timeout interrupt */
        HAL_XSPI_ENABLE_IT(hxspi, HAL_XSPI_IT_TO);
34018864:	687b      	ldr	r3, [r7, #4]
34018866:	681b      	ldr	r3, [r3, #0]
34018868:	681a      	ldr	r2, [r3, #0]
3401886a:	687b      	ldr	r3, [r7, #4]
3401886c:	681b      	ldr	r3, [r3, #0]
3401886e:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
34018872:	601a      	str	r2, [r3, #0]
      }

      /* Configure CR register with functional mode as memory-mapped */
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_TCEN | XSPI_CR_FMODE),
34018874:	687b      	ldr	r3, [r7, #4]
34018876:	681b      	ldr	r3, [r3, #0]
34018878:	681b      	ldr	r3, [r3, #0]
3401887a:	f023 5340 	bic.w	r3, r3, #805306368	@ 0x30000000
3401887e:	f023 0308 	bic.w	r3, r3, #8
34018882:	683a      	ldr	r2, [r7, #0]
34018884:	6812      	ldr	r2, [r2, #0]
34018886:	431a      	orrs	r2, r3
34018888:	687b      	ldr	r3, [r7, #4]
3401888a:	681b      	ldr	r3, [r3, #0]
3401888c:	f042 5240 	orr.w	r2, r2, #805306368	@ 0x30000000
34018890:	601a      	str	r2, [r3, #0]
34018892:	e004      	b.n	3401889e <HAL_XSPI_MemoryMapped+0xce>
                 (pCfg->TimeOutActivation | XSPI_FUNCTIONAL_MODE_MEMORY_MAPPED));
    }
  }
  else
  {
    status = HAL_ERROR;
34018894:	2301      	movs	r3, #1
34018896:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
34018898:	687b      	ldr	r3, [r7, #4]
3401889a:	2210      	movs	r2, #16
3401889c:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
3401889e:	7bfb      	ldrb	r3, [r7, #15]
}
340188a0:	4618      	mov	r0, r3
340188a2:	3710      	adds	r7, #16
340188a4:	46bd      	mov	sp, r7
340188a6:	bd80      	pop	{r7, pc}

340188a8 <HAL_XSPI_Abort>:
  * @brief  Abort the current operation, return to the indirect mode.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Abort(XSPI_HandleTypeDef *hxspi)
{
340188a8:	b580      	push	{r7, lr}
340188aa:	b086      	sub	sp, #24
340188ac:	af02      	add	r7, sp, #8
340188ae:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
340188b0:	2300      	movs	r3, #0
340188b2:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
340188b4:	f7ec f9bb 	bl	34004c2e <HAL_GetTick>
340188b8:	60b8      	str	r0, [r7, #8]

  /* Check if the state is not in reset state */
  if (hxspi->State != HAL_XSPI_STATE_RESET)
340188ba:	687b      	ldr	r3, [r7, #4]
340188bc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340188be:	2b00      	cmp	r3, #0
340188c0:	d06f      	beq.n	340189a2 <HAL_XSPI_Abort+0xfa>
  {
    /* Check if the DMA is enabled */
    if ((hxspi->Instance->CR & XSPI_CR_DMAEN) != 0U)
340188c2:	687b      	ldr	r3, [r7, #4]
340188c4:	681b      	ldr	r3, [r3, #0]
340188c6:	681b      	ldr	r3, [r3, #0]
340188c8:	f003 0304 	and.w	r3, r3, #4
340188cc:	2b00      	cmp	r3, #0
340188ce:	d021      	beq.n	34018914 <HAL_XSPI_Abort+0x6c>
    {
      /* Disable the DMA transfer on the XSPI side */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_DMAEN);
340188d0:	687b      	ldr	r3, [r7, #4]
340188d2:	681b      	ldr	r3, [r3, #0]
340188d4:	681a      	ldr	r2, [r3, #0]
340188d6:	687b      	ldr	r3, [r7, #4]
340188d8:	681b      	ldr	r3, [r3, #0]
340188da:	f022 0204 	bic.w	r2, r2, #4
340188de:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transmit on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmatx);
340188e0:	687b      	ldr	r3, [r7, #4]
340188e2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
340188e4:	4618      	mov	r0, r3
340188e6:	f7f1 fd43 	bl	3400a370 <HAL_DMA_Abort>
340188ea:	4603      	mov	r3, r0
340188ec:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
340188ee:	7bfb      	ldrb	r3, [r7, #15]
340188f0:	2b00      	cmp	r3, #0
340188f2:	d002      	beq.n	340188fa <HAL_XSPI_Abort+0x52>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
340188f4:	687b      	ldr	r3, [r7, #4]
340188f6:	2204      	movs	r2, #4
340188f8:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Disable the DMA receive on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmarx);
340188fa:	687b      	ldr	r3, [r7, #4]
340188fc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340188fe:	4618      	mov	r0, r3
34018900:	f7f1 fd36 	bl	3400a370 <HAL_DMA_Abort>
34018904:	4603      	mov	r3, r0
34018906:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
34018908:	7bfb      	ldrb	r3, [r7, #15]
3401890a:	2b00      	cmp	r3, #0
3401890c:	d002      	beq.n	34018914 <HAL_XSPI_Abort+0x6c>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
3401890e:	687b      	ldr	r3, [r7, #4]
34018910:	2204      	movs	r2, #4
34018912:	65da      	str	r2, [r3, #92]	@ 0x5c
      }
    }

    if (HAL_XSPI_GET_FLAG(hxspi, HAL_XSPI_FLAG_BUSY) != RESET)
34018914:	687b      	ldr	r3, [r7, #4]
34018916:	681b      	ldr	r3, [r3, #0]
34018918:	6a1b      	ldr	r3, [r3, #32]
3401891a:	f003 0320 	and.w	r3, r3, #32
3401891e:	2b00      	cmp	r3, #0
34018920:	d033      	beq.n	3401898a <HAL_XSPI_Abort+0xe2>
    {
      /* Perform an abort of the XSPI */
      SET_BIT(hxspi->Instance->CR, XSPI_CR_ABORT);
34018922:	687b      	ldr	r3, [r7, #4]
34018924:	681b      	ldr	r3, [r3, #0]
34018926:	681a      	ldr	r2, [r3, #0]
34018928:	687b      	ldr	r3, [r7, #4]
3401892a:	681b      	ldr	r3, [r3, #0]
3401892c:	f042 0202 	orr.w	r2, r2, #2
34018930:	601a      	str	r2, [r3, #0]

      /* Wait until the transfer complete flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, hxspi->Timeout);
34018932:	687b      	ldr	r3, [r7, #4]
34018934:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
34018936:	9300      	str	r3, [sp, #0]
34018938:	68bb      	ldr	r3, [r7, #8]
3401893a:	2201      	movs	r2, #1
3401893c:	2102      	movs	r1, #2
3401893e:	6878      	ldr	r0, [r7, #4]
34018940:	f000 f99c 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018944:	4603      	mov	r3, r0
34018946:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
34018948:	7bfb      	ldrb	r3, [r7, #15]
3401894a:	2b00      	cmp	r3, #0
3401894c:	d12e      	bne.n	340189ac <HAL_XSPI_Abort+0x104>
      {
        /* Clear transfer complete flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
3401894e:	687b      	ldr	r3, [r7, #4]
34018950:	681b      	ldr	r3, [r3, #0]
34018952:	2202      	movs	r2, #2
34018954:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Wait until the busy flag is reset to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
34018956:	687b      	ldr	r3, [r7, #4]
34018958:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3401895a:	9300      	str	r3, [sp, #0]
3401895c:	68bb      	ldr	r3, [r7, #8]
3401895e:	2200      	movs	r2, #0
34018960:	2120      	movs	r1, #32
34018962:	6878      	ldr	r0, [r7, #4]
34018964:	f000 f98a 	bl	34018c7c <XSPI_WaitFlagStateUntilTimeout>
34018968:	4603      	mov	r3, r0
3401896a:	73fb      	strb	r3, [r7, #15]

        if (status == HAL_OK)
3401896c:	7bfb      	ldrb	r3, [r7, #15]
3401896e:	2b00      	cmp	r3, #0
34018970:	d11c      	bne.n	340189ac <HAL_XSPI_Abort+0x104>
        {
          /* Return to indirect mode */
          CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
34018972:	687b      	ldr	r3, [r7, #4]
34018974:	681b      	ldr	r3, [r3, #0]
34018976:	681a      	ldr	r2, [r3, #0]
34018978:	687b      	ldr	r3, [r7, #4]
3401897a:	681b      	ldr	r3, [r3, #0]
3401897c:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34018980:	601a      	str	r2, [r3, #0]

          hxspi->State = HAL_XSPI_STATE_READY;
34018982:	687b      	ldr	r3, [r7, #4]
34018984:	2202      	movs	r2, #2
34018986:	659a      	str	r2, [r3, #88]	@ 0x58
34018988:	e010      	b.n	340189ac <HAL_XSPI_Abort+0x104>
      }
    }
    else
    {
      /* Return to indirect mode */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
3401898a:	687b      	ldr	r3, [r7, #4]
3401898c:	681b      	ldr	r3, [r3, #0]
3401898e:	681a      	ldr	r2, [r3, #0]
34018990:	687b      	ldr	r3, [r7, #4]
34018992:	681b      	ldr	r3, [r3, #0]
34018994:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34018998:	601a      	str	r2, [r3, #0]

      hxspi->State = HAL_XSPI_STATE_READY;
3401899a:	687b      	ldr	r3, [r7, #4]
3401899c:	2202      	movs	r2, #2
3401899e:	659a      	str	r2, [r3, #88]	@ 0x58
340189a0:	e004      	b.n	340189ac <HAL_XSPI_Abort+0x104>
    }
  }
  else
  {
    status = HAL_ERROR;
340189a2:	2301      	movs	r3, #1
340189a4:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340189a6:	687b      	ldr	r3, [r7, #4]
340189a8:	2210      	movs	r2, #16
340189aa:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
340189ac:	7bfb      	ldrb	r3, [r7, #15]
}
340189ae:	4618      	mov	r0, r3
340189b0:	3710      	adds	r7, #16
340189b2:	46bd      	mov	sp, r7
340189b4:	bd80      	pop	{r7, pc}

340189b6 <HAL_XSPI_SetClockPrescaler>:
  * @param  hxspi     : XSPI handle.
  * @param  Prescaler : Clock prescaler.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_SetClockPrescaler(XSPI_HandleTypeDef *hxspi, uint32_t Prescaler)
{
340189b6:	b480      	push	{r7}
340189b8:	b085      	sub	sp, #20
340189ba:	af00      	add	r7, sp, #0
340189bc:	6078      	str	r0, [r7, #4]
340189be:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
340189c0:	2300      	movs	r3, #0
340189c2:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_XSPI_CLK_PRESCALER(Prescaler));

  /* Check the state */
  if ((hxspi->State & XSPI_BUSY_STATE_MASK) == 0U)
340189c4:	687b      	ldr	r3, [r7, #4]
340189c6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340189c8:	f003 0308 	and.w	r3, r3, #8
340189cc:	2b00      	cmp	r3, #0
340189ce:	d10e      	bne.n	340189ee <HAL_XSPI_SetClockPrescaler+0x38>
  {
    /* Synchronize initialization structure with the new clock prescaler value */
    hxspi->Init.ClockPrescaler = Prescaler;
340189d0:	687b      	ldr	r3, [r7, #4]
340189d2:	683a      	ldr	r2, [r7, #0]
340189d4:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Configure clock prescaler */
    MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
340189d6:	687b      	ldr	r3, [r7, #4]
340189d8:	681b      	ldr	r3, [r3, #0]
340189da:	68db      	ldr	r3, [r3, #12]
340189dc:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
340189e0:	687b      	ldr	r3, [r7, #4]
340189e2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340189e4:	687b      	ldr	r3, [r7, #4]
340189e6:	681b      	ldr	r3, [r3, #0]
340189e8:	430a      	orrs	r2, r1
340189ea:	60da      	str	r2, [r3, #12]
340189ec:	e004      	b.n	340189f8 <HAL_XSPI_SetClockPrescaler+0x42>
               ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));
  }
  else
  {
    status = HAL_ERROR;
340189ee:	2301      	movs	r3, #1
340189f0:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
340189f2:	687b      	ldr	r3, [r7, #4]
340189f4:	2210      	movs	r2, #16
340189f6:	65da      	str	r2, [r3, #92]	@ 0x5c
  }

  return status;
340189f8:	7bfb      	ldrb	r3, [r7, #15]
}
340189fa:	4618      	mov	r0, r3
340189fc:	3714      	adds	r7, #20
340189fe:	46bd      	mov	sp, r7
34018a00:	f85d 7b04 	ldr.w	r7, [sp], #4
34018a04:	4770      	bx	lr

34018a06 <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
34018a06:	b480      	push	{r7}
34018a08:	b083      	sub	sp, #12
34018a0a:	af00      	add	r7, sp, #0
34018a0c:	6078      	str	r0, [r7, #4]
34018a0e:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
34018a10:	687b      	ldr	r3, [r7, #4]
34018a12:	683a      	ldr	r2, [r7, #0]
34018a14:	661a      	str	r2, [r3, #96]	@ 0x60
  return HAL_OK;
34018a16:	2300      	movs	r3, #0
}
34018a18:	4618      	mov	r0, r3
34018a1a:	370c      	adds	r7, #12
34018a1c:	46bd      	mov	sp, r7
34018a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34018a22:	4770      	bx	lr

34018a24 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *const hxspi, XSPIM_CfgTypeDef *const pCfg, uint32_t Timeout)
{
34018a24:	b580      	push	{r7, lr}
34018a26:	b08e      	sub	sp, #56	@ 0x38
34018a28:	af00      	add	r7, sp, #0
34018a2a:	60f8      	str	r0, [r7, #12]
34018a2c:	60b9      	str	r1, [r7, #8]
34018a2e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
34018a30:	2300      	movs	r3, #0
34018a32:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
  uint8_t index;
  uint8_t xspi_enabled = 0U;
34018a36:	2300      	movs	r3, #0
34018a38:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
34018a3c:	f107 0310 	add.w	r3, r7, #16
34018a40:	2224      	movs	r2, #36	@ 0x24
34018a42:	2100      	movs	r1, #0
34018a44:	4618      	mov	r0, r3
34018a46:	f00e fba5 	bl	34027194 <memset>
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34018a4a:	2300      	movs	r3, #0
34018a4c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34018a50:	e014      	b.n	34018a7c <HAL_XSPIM_Config+0x58>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
34018a52:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018a56:	3301      	adds	r3, #1
34018a58:	b2d8      	uxtb	r0, r3
34018a5a:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34018a5e:	f107 0110 	add.w	r1, r7, #16
34018a62:	4613      	mov	r3, r2
34018a64:	005b      	lsls	r3, r3, #1
34018a66:	4413      	add	r3, r2
34018a68:	009b      	lsls	r3, r3, #2
34018a6a:	440b      	add	r3, r1
34018a6c:	4619      	mov	r1, r3
34018a6e:	f000 fad5 	bl	3401901c <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
34018a72:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018a76:	3301      	adds	r3, #1
34018a78:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34018a7c:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018a80:	2b02      	cmp	r3, #2
34018a82:	d9e6      	bls.n	34018a52 <HAL_XSPIM_Config+0x2e>
  }

  /********** Disable all XSPI to configure XSPI IO Manager **********/
  if (__HAL_RCC_XSPI1_IS_CLK_ENABLED() != 0U)
34018a84:	2020      	movs	r0, #32
34018a86:	f7ff fa99 	bl	34017fbc <LL_AHB5_GRP1_IsEnabledClock>
34018a8a:	4603      	mov	r3, r0
34018a8c:	2b00      	cmp	r3, #0
34018a8e:	d011      	beq.n	34018ab4 <HAL_XSPIM_Config+0x90>
  {
    if ((XSPI1->CR & XSPI_CR_EN) != 0U)
34018a90:	4b76      	ldr	r3, [pc, #472]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018a92:	681b      	ldr	r3, [r3, #0]
34018a94:	f003 0301 	and.w	r3, r3, #1
34018a98:	2b00      	cmp	r3, #0
34018a9a:	d00b      	beq.n	34018ab4 <HAL_XSPIM_Config+0x90>
    {
      CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
34018a9c:	4b73      	ldr	r3, [pc, #460]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018a9e:	681b      	ldr	r3, [r3, #0]
34018aa0:	4a72      	ldr	r2, [pc, #456]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018aa2:	f023 0301 	bic.w	r3, r3, #1
34018aa6:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x1U;
34018aa8:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34018aac:	f043 0301 	orr.w	r3, r3, #1
34018ab0:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI2_IS_CLK_ENABLED() != 0U)
34018ab4:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
34018ab8:	f7ff fa80 	bl	34017fbc <LL_AHB5_GRP1_IsEnabledClock>
34018abc:	4603      	mov	r3, r0
34018abe:	2b00      	cmp	r3, #0
34018ac0:	d011      	beq.n	34018ae6 <HAL_XSPIM_Config+0xc2>
  {
    if ((XSPI2->CR & XSPI_CR_EN) != 0U)
34018ac2:	4b6b      	ldr	r3, [pc, #428]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018ac4:	681b      	ldr	r3, [r3, #0]
34018ac6:	f003 0301 	and.w	r3, r3, #1
34018aca:	2b00      	cmp	r3, #0
34018acc:	d00b      	beq.n	34018ae6 <HAL_XSPIM_Config+0xc2>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34018ace:	4b68      	ldr	r3, [pc, #416]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018ad0:	681b      	ldr	r3, [r3, #0]
34018ad2:	4a67      	ldr	r2, [pc, #412]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018ad4:	f023 0301 	bic.w	r3, r3, #1
34018ad8:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x2U;
34018ada:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34018ade:	f043 0302 	orr.w	r3, r3, #2
34018ae2:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }
  if (__HAL_RCC_XSPI3_IS_CLK_ENABLED() != 0U)
34018ae6:	f44f 3000 	mov.w	r0, #131072	@ 0x20000
34018aea:	f7ff fa67 	bl	34017fbc <LL_AHB5_GRP1_IsEnabledClock>
34018aee:	4603      	mov	r3, r0
34018af0:	2b00      	cmp	r3, #0
34018af2:	d011      	beq.n	34018b18 <HAL_XSPIM_Config+0xf4>
  {
    if ((XSPI3->CR & XSPI_CR_EN) != 0U)
34018af4:	4b5f      	ldr	r3, [pc, #380]	@ (34018c74 <HAL_XSPIM_Config+0x250>)
34018af6:	681b      	ldr	r3, [r3, #0]
34018af8:	f003 0301 	and.w	r3, r3, #1
34018afc:	2b00      	cmp	r3, #0
34018afe:	d00b      	beq.n	34018b18 <HAL_XSPIM_Config+0xf4>
    {
      CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
34018b00:	4b5b      	ldr	r3, [pc, #364]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018b02:	681b      	ldr	r3, [r3, #0]
34018b04:	4a5a      	ldr	r2, [pc, #360]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018b06:	f023 0301 	bic.w	r3, r3, #1
34018b0a:	6013      	str	r3, [r2, #0]
      xspi_enabled |= 0x4U;
34018b0c:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34018b10:	f043 0304 	orr.w	r3, r3, #4
34018b14:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
    }
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
34018b18:	4b57      	ldr	r3, [pc, #348]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b1a:	2200      	movs	r2, #0
34018b1c:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
34018b1e:	4b56      	ldr	r3, [pc, #344]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b20:	681b      	ldr	r3, [r3, #0]
34018b22:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
34018b26:	68bb      	ldr	r3, [r7, #8]
34018b28:	689b      	ldr	r3, [r3, #8]
34018b2a:	3b01      	subs	r3, #1
34018b2c:	041b      	lsls	r3, r3, #16
34018b2e:	4952      	ldr	r1, [pc, #328]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b30:	4313      	orrs	r3, r2
34018b32:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
34018b34:	68fb      	ldr	r3, [r7, #12]
34018b36:	681b      	ldr	r3, [r3, #0]
34018b38:	4a4c      	ldr	r2, [pc, #304]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018b3a:	4293      	cmp	r3, r2
34018b3c:	d110      	bne.n	34018b60 <HAL_XSPIM_Config+0x13c>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
34018b3e:	68bb      	ldr	r3, [r7, #8]
34018b40:	685b      	ldr	r3, [r3, #4]
34018b42:	617b      	str	r3, [r7, #20]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34018b44:	68bb      	ldr	r3, [r7, #8]
34018b46:	681b      	ldr	r3, [r3, #0]
34018b48:	2b00      	cmp	r3, #0
34018b4a:	d03e      	beq.n	34018bca <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34018b4c:	4b4a      	ldr	r3, [pc, #296]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b4e:	681b      	ldr	r3, [r3, #0]
34018b50:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
34018b54:	68bb      	ldr	r3, [r7, #8]
34018b56:	681b      	ldr	r3, [r3, #0]
34018b58:	4947      	ldr	r1, [pc, #284]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b5a:	4313      	orrs	r3, r2
34018b5c:	600b      	str	r3, [r1, #0]
34018b5e:	e034      	b.n	34018bca <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
34018b60:	68fb      	ldr	r3, [r7, #12]
34018b62:	681b      	ldr	r3, [r3, #0]
34018b64:	4a42      	ldr	r2, [pc, #264]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018b66:	4293      	cmp	r3, r2
34018b68:	d110      	bne.n	34018b8c <HAL_XSPIM_Config+0x168>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
34018b6a:	68bb      	ldr	r3, [r7, #8]
34018b6c:	685b      	ldr	r3, [r3, #4]
34018b6e:	623b      	str	r3, [r7, #32]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
34018b70:	68bb      	ldr	r3, [r7, #8]
34018b72:	681b      	ldr	r3, [r3, #0]
34018b74:	2b00      	cmp	r3, #0
34018b76:	d028      	beq.n	34018bca <HAL_XSPIM_Config+0x1a6>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
34018b78:	4b3f      	ldr	r3, [pc, #252]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b7a:	681b      	ldr	r3, [r3, #0]
34018b7c:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
34018b80:	68bb      	ldr	r3, [r7, #8]
34018b82:	681b      	ldr	r3, [r3, #0]
34018b84:	493c      	ldr	r1, [pc, #240]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018b86:	4313      	orrs	r3, r2
34018b88:	600b      	str	r3, [r1, #0]
34018b8a:	e01e      	b.n	34018bca <HAL_XSPIM_Config+0x1a6>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI3)
34018b8c:	68fb      	ldr	r3, [r7, #12]
34018b8e:	681b      	ldr	r3, [r3, #0]
34018b90:	4a38      	ldr	r2, [pc, #224]	@ (34018c74 <HAL_XSPIM_Config+0x250>)
34018b92:	4293      	cmp	r3, r2
34018b94:	d111      	bne.n	34018bba <HAL_XSPIM_Config+0x196>
  {
    if (pCfg->IOPort == HAL_XSPIM_IOPORT_1)
34018b96:	68bb      	ldr	r3, [r7, #8]
34018b98:	685b      	ldr	r3, [r3, #4]
34018b9a:	2b00      	cmp	r3, #0
34018b9c:	d104      	bne.n	34018ba8 <HAL_XSPIM_Config+0x184>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_2 ;
34018b9e:	2301      	movs	r3, #1
34018ba0:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_2 ;
34018ba2:	2301      	movs	r3, #1
34018ba4:	623b      	str	r3, [r7, #32]
34018ba6:	e010      	b.n	34018bca <HAL_XSPIM_Config+0x1a6>
    }
    else if (pCfg->IOPort == HAL_XSPIM_IOPORT_2)
34018ba8:	68bb      	ldr	r3, [r7, #8]
34018baa:	685b      	ldr	r3, [r3, #4]
34018bac:	2b01      	cmp	r3, #1
34018bae:	d10c      	bne.n	34018bca <HAL_XSPIM_Config+0x1a6>
    {
      IOM_cfg[0].IOPort = HAL_XSPIM_IOPORT_1 ;
34018bb0:	2300      	movs	r3, #0
34018bb2:	617b      	str	r3, [r7, #20]
      IOM_cfg[1].IOPort = HAL_XSPIM_IOPORT_1 ;
34018bb4:	2300      	movs	r3, #0
34018bb6:	623b      	str	r3, [r7, #32]
34018bb8:	e007      	b.n	34018bca <HAL_XSPIM_Config+0x1a6>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
34018bba:	68fb      	ldr	r3, [r7, #12]
34018bbc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34018bbe:	f043 0208 	orr.w	r2, r3, #8
34018bc2:	68fb      	ldr	r3, [r7, #12]
34018bc4:	65da      	str	r2, [r3, #92]	@ 0x5c
    return HAL_ERROR;
34018bc6:	2301      	movs	r3, #1
34018bc8:	e04c      	b.n	34018c64 <HAL_XSPIM_Config+0x240>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34018bca:	2300      	movs	r3, #0
34018bcc:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34018bd0:	e02a      	b.n	34018c28 <HAL_XSPIM_Config+0x204>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
34018bd2:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
34018bd6:	4613      	mov	r3, r2
34018bd8:	005b      	lsls	r3, r3, #1
34018bda:	4413      	add	r3, r2
34018bdc:	009b      	lsls	r3, r3, #2
34018bde:	3338      	adds	r3, #56	@ 0x38
34018be0:	443b      	add	r3, r7
34018be2:	3b24      	subs	r3, #36	@ 0x24
34018be4:	6819      	ldr	r1, [r3, #0]
34018be6:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018bea:	1c5a      	adds	r2, r3, #1
34018bec:	4613      	mov	r3, r2
34018bee:	005b      	lsls	r3, r3, #1
34018bf0:	4413      	add	r3, r2
34018bf2:	009b      	lsls	r3, r3, #2
34018bf4:	3338      	adds	r3, #56	@ 0x38
34018bf6:	443b      	add	r3, r7
34018bf8:	3b24      	subs	r3, #36	@ 0x24
34018bfa:	681b      	ldr	r3, [r3, #0]
34018bfc:	4299      	cmp	r1, r3
34018bfe:	d105      	bne.n	34018c0c <HAL_XSPIM_Config+0x1e8>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
34018c00:	4b1d      	ldr	r3, [pc, #116]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018c02:	681b      	ldr	r3, [r3, #0]
34018c04:	4a1c      	ldr	r2, [pc, #112]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018c06:	f043 0301 	orr.w	r3, r3, #1
34018c0a:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
34018c0c:	697b      	ldr	r3, [r7, #20]
34018c0e:	2b01      	cmp	r3, #1
34018c10:	d105      	bne.n	34018c1e <HAL_XSPIM_Config+0x1fa>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
34018c12:	4b19      	ldr	r3, [pc, #100]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018c14:	681b      	ldr	r3, [r3, #0]
34018c16:	4a18      	ldr	r2, [pc, #96]	@ (34018c78 <HAL_XSPIM_Config+0x254>)
34018c18:	f043 0302 	orr.w	r3, r3, #2
34018c1c:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 2U); index++)
34018c1e:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018c22:	3301      	adds	r3, #1
34018c24:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
34018c28:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
34018c2c:	2b00      	cmp	r3, #0
34018c2e:	d0d0      	beq.n	34018bd2 <HAL_XSPIM_Config+0x1ae>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
34018c30:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34018c34:	f003 0301 	and.w	r3, r3, #1
34018c38:	2b00      	cmp	r3, #0
34018c3a:	d005      	beq.n	34018c48 <HAL_XSPIM_Config+0x224>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
34018c3c:	4b0b      	ldr	r3, [pc, #44]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018c3e:	681b      	ldr	r3, [r3, #0]
34018c40:	4a0a      	ldr	r2, [pc, #40]	@ (34018c6c <HAL_XSPIM_Config+0x248>)
34018c42:	f043 0301 	orr.w	r3, r3, #1
34018c46:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
34018c48:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
34018c4c:	f003 0302 	and.w	r3, r3, #2
34018c50:	2b00      	cmp	r3, #0
34018c52:	d005      	beq.n	34018c60 <HAL_XSPIM_Config+0x23c>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
34018c54:	4b06      	ldr	r3, [pc, #24]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018c56:	681b      	ldr	r3, [r3, #0]
34018c58:	4a05      	ldr	r2, [pc, #20]	@ (34018c70 <HAL_XSPIM_Config+0x24c>)
34018c5a:	f043 0301 	orr.w	r3, r3, #1
34018c5e:	6013      	str	r3, [r2, #0]
  }

  return status;
34018c60:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
}
34018c64:	4618      	mov	r0, r3
34018c66:	3738      	adds	r7, #56	@ 0x38
34018c68:	46bd      	mov	sp, r7
34018c6a:	bd80      	pop	{r7, pc}
34018c6c:	58025000 	.word	0x58025000
34018c70:	5802a000 	.word	0x5802a000
34018c74:	5802d000 	.word	0x5802d000
34018c78:	5802b400 	.word	0x5802b400

34018c7c <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
34018c7c:	b580      	push	{r7, lr}
34018c7e:	b084      	sub	sp, #16
34018c80:	af00      	add	r7, sp, #0
34018c82:	60f8      	str	r0, [r7, #12]
34018c84:	60b9      	str	r1, [r7, #8]
34018c86:	603b      	str	r3, [r7, #0]
34018c88:	4613      	mov	r3, r2
34018c8a:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34018c8c:	e019      	b.n	34018cc2 <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
34018c8e:	69bb      	ldr	r3, [r7, #24]
34018c90:	f1b3 3fff 	cmp.w	r3, #4294967295
34018c94:	d015      	beq.n	34018cc2 <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
34018c96:	f7eb ffca 	bl	34004c2e <HAL_GetTick>
34018c9a:	4602      	mov	r2, r0
34018c9c:	683b      	ldr	r3, [r7, #0]
34018c9e:	1ad3      	subs	r3, r2, r3
34018ca0:	69ba      	ldr	r2, [r7, #24]
34018ca2:	429a      	cmp	r2, r3
34018ca4:	d302      	bcc.n	34018cac <XSPI_WaitFlagStateUntilTimeout+0x30>
34018ca6:	69bb      	ldr	r3, [r7, #24]
34018ca8:	2b00      	cmp	r3, #0
34018caa:	d10a      	bne.n	34018cc2 <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
34018cac:	68fb      	ldr	r3, [r7, #12]
34018cae:	2202      	movs	r2, #2
34018cb0:	659a      	str	r2, [r3, #88]	@ 0x58
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
34018cb2:	68fb      	ldr	r3, [r7, #12]
34018cb4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34018cb6:	f043 0201 	orr.w	r2, r3, #1
34018cba:	68fb      	ldr	r3, [r7, #12]
34018cbc:	65da      	str	r2, [r3, #92]	@ 0x5c

        return HAL_TIMEOUT;
34018cbe:	2303      	movs	r3, #3
34018cc0:	e00e      	b.n	34018ce0 <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
34018cc2:	68fb      	ldr	r3, [r7, #12]
34018cc4:	681b      	ldr	r3, [r3, #0]
34018cc6:	6a1a      	ldr	r2, [r3, #32]
34018cc8:	68bb      	ldr	r3, [r7, #8]
34018cca:	4013      	ands	r3, r2
34018ccc:	2b00      	cmp	r3, #0
34018cce:	bf14      	ite	ne
34018cd0:	2301      	movne	r3, #1
34018cd2:	2300      	moveq	r3, #0
34018cd4:	b2db      	uxtb	r3, r3
34018cd6:	461a      	mov	r2, r3
34018cd8:	79fb      	ldrb	r3, [r7, #7]
34018cda:	429a      	cmp	r2, r3
34018cdc:	d1d7      	bne.n	34018c8e <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
34018cde:	2300      	movs	r3, #0
}
34018ce0:	4618      	mov	r0, r3
34018ce2:	3710      	adds	r7, #16
34018ce4:	46bd      	mov	sp, r7
34018ce6:	bd80      	pop	{r7, pc}

34018ce8 <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, XSPI_RegularCmdTypeDef *pCmd)
{
34018ce8:	b480      	push	{r7}
34018cea:	b089      	sub	sp, #36	@ 0x24
34018cec:	af00      	add	r7, sp, #0
34018cee:	6078      	str	r0, [r7, #4]
34018cf0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
34018cf2:	2300      	movs	r3, #0
34018cf4:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
34018cf6:	687b      	ldr	r3, [r7, #4]
34018cf8:	681b      	ldr	r3, [r3, #0]
34018cfa:	681a      	ldr	r2, [r3, #0]
34018cfc:	687b      	ldr	r3, [r7, #4]
34018cfe:	681b      	ldr	r3, [r3, #0]
34018d00:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
34018d04:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
34018d06:	687b      	ldr	r3, [r7, #4]
34018d08:	689b      	ldr	r3, [r3, #8]
34018d0a:	2b00      	cmp	r3, #0
34018d0c:	d10a      	bne.n	34018d24 <XSPI_ConfigCmd+0x3c>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
34018d0e:	687b      	ldr	r3, [r7, #4]
34018d10:	681b      	ldr	r3, [r3, #0]
34018d12:	681b      	ldr	r3, [r3, #0]
34018d14:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
34018d18:	683b      	ldr	r3, [r7, #0]
34018d1a:	685a      	ldr	r2, [r3, #4]
34018d1c:	687b      	ldr	r3, [r7, #4]
34018d1e:	681b      	ldr	r3, [r3, #0]
34018d20:	430a      	orrs	r2, r1
34018d22:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
34018d24:	683b      	ldr	r3, [r7, #0]
34018d26:	681b      	ldr	r3, [r3, #0]
34018d28:	2b02      	cmp	r3, #2
34018d2a:	d114      	bne.n	34018d56 <XSPI_ConfigCmd+0x6e>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
34018d2c:	687b      	ldr	r3, [r7, #4]
34018d2e:	681b      	ldr	r3, [r3, #0]
34018d30:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
34018d34:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
34018d36:	687b      	ldr	r3, [r7, #4]
34018d38:	681b      	ldr	r3, [r3, #0]
34018d3a:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
34018d3e:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
34018d40:	687b      	ldr	r3, [r7, #4]
34018d42:	681b      	ldr	r3, [r3, #0]
34018d44:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
34018d48:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
34018d4a:	687b      	ldr	r3, [r7, #4]
34018d4c:	681b      	ldr	r3, [r3, #0]
34018d4e:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
34018d52:	60fb      	str	r3, [r7, #12]
34018d54:	e02c      	b.n	34018db0 <XSPI_ConfigCmd+0xc8>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
34018d56:	683b      	ldr	r3, [r7, #0]
34018d58:	681b      	ldr	r3, [r3, #0]
34018d5a:	2b03      	cmp	r3, #3
34018d5c:	d114      	bne.n	34018d88 <XSPI_ConfigCmd+0xa0>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
34018d5e:	687b      	ldr	r3, [r7, #4]
34018d60:	681b      	ldr	r3, [r3, #0]
34018d62:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
34018d66:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
34018d68:	687b      	ldr	r3, [r7, #4]
34018d6a:	681b      	ldr	r3, [r3, #0]
34018d6c:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
34018d70:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
34018d72:	687b      	ldr	r3, [r7, #4]
34018d74:	681b      	ldr	r3, [r3, #0]
34018d76:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
34018d7a:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
34018d7c:	687b      	ldr	r3, [r7, #4]
34018d7e:	681b      	ldr	r3, [r3, #0]
34018d80:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
34018d84:	60fb      	str	r3, [r7, #12]
34018d86:	e013      	b.n	34018db0 <XSPI_ConfigCmd+0xc8>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
34018d88:	687b      	ldr	r3, [r7, #4]
34018d8a:	681b      	ldr	r3, [r3, #0]
34018d8c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34018d90:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
34018d92:	687b      	ldr	r3, [r7, #4]
34018d94:	681b      	ldr	r3, [r3, #0]
34018d96:	f503 7384 	add.w	r3, r3, #264	@ 0x108
34018d9a:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
34018d9c:	687b      	ldr	r3, [r7, #4]
34018d9e:	681b      	ldr	r3, [r3, #0]
34018da0:	f503 7388 	add.w	r3, r3, #272	@ 0x110
34018da4:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
34018da6:	687b      	ldr	r3, [r7, #4]
34018da8:	681b      	ldr	r3, [r3, #0]
34018daa:	f503 7390 	add.w	r3, r3, #288	@ 0x120
34018dae:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = pCmd->DQSMode;
34018db0:	683b      	ldr	r3, [r7, #0]
34018db2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34018db4:	69bb      	ldr	r3, [r7, #24]
34018db6:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
34018db8:	683b      	ldr	r3, [r7, #0]
34018dba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34018dbc:	2b00      	cmp	r3, #0
34018dbe:	d012      	beq.n	34018de6 <XSPI_ConfigCmd+0xfe>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
34018dc0:	683b      	ldr	r3, [r7, #0]
34018dc2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34018dc4:	68fb      	ldr	r3, [r7, #12]
34018dc6:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
34018dc8:	69bb      	ldr	r3, [r7, #24]
34018dca:	681b      	ldr	r3, [r3, #0]
34018dcc:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
34018dd0:	683b      	ldr	r3, [r7, #0]
34018dd2:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34018dd4:	683b      	ldr	r3, [r7, #0]
34018dd6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34018dd8:	4319      	orrs	r1, r3
34018dda:	683b      	ldr	r3, [r7, #0]
34018ddc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34018dde:	430b      	orrs	r3, r1
34018de0:	431a      	orrs	r2, r3
34018de2:	69bb      	ldr	r3, [r7, #24]
34018de4:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
34018de6:	697b      	ldr	r3, [r7, #20]
34018de8:	681b      	ldr	r3, [r3, #0]
34018dea:	f023 021f 	bic.w	r2, r3, #31
34018dee:	683b      	ldr	r3, [r7, #0]
34018df0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34018df2:	431a      	orrs	r2, r3
34018df4:	697b      	ldr	r3, [r7, #20]
34018df6:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018df8:	683b      	ldr	r3, [r7, #0]
34018dfa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018dfc:	2b00      	cmp	r3, #0
34018dfe:	d009      	beq.n	34018e14 <XSPI_ConfigCmd+0x12c>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
34018e00:	683b      	ldr	r3, [r7, #0]
34018e02:	681b      	ldr	r3, [r3, #0]
34018e04:	2b00      	cmp	r3, #0
34018e06:	d105      	bne.n	34018e14 <XSPI_ConfigCmd+0x12c>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
34018e08:	683b      	ldr	r3, [r7, #0]
34018e0a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34018e0c:	687b      	ldr	r3, [r7, #4]
34018e0e:	681b      	ldr	r3, [r3, #0]
34018e10:	3a01      	subs	r2, #1
34018e12:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018e14:	683b      	ldr	r3, [r7, #0]
34018e16:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018e18:	2b00      	cmp	r3, #0
34018e1a:	d01e      	beq.n	34018e5a <XSPI_ConfigCmd+0x172>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
34018e1c:	683b      	ldr	r3, [r7, #0]
34018e1e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34018e20:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
34018e24:	d10a      	bne.n	34018e3c <XSPI_ConfigCmd+0x154>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34018e26:	687b      	ldr	r3, [r7, #4]
34018e28:	681b      	ldr	r3, [r3, #0]
34018e2a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34018e2e:	687b      	ldr	r3, [r7, #4]
34018e30:	681b      	ldr	r3, [r3, #0]
34018e32:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
34018e36:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
34018e3a:	e00e      	b.n	34018e5a <XSPI_ConfigCmd+0x172>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
34018e3c:	687b      	ldr	r3, [r7, #4]
34018e3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34018e40:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
34018e44:	d109      	bne.n	34018e5a <XSPI_ConfigCmd+0x172>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
34018e46:	687b      	ldr	r3, [r7, #4]
34018e48:	681b      	ldr	r3, [r3, #0]
34018e4a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34018e4e:	687b      	ldr	r3, [r7, #4]
34018e50:	681b      	ldr	r3, [r3, #0]
34018e52:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
34018e56:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
34018e5a:	683b      	ldr	r3, [r7, #0]
34018e5c:	68db      	ldr	r3, [r3, #12]
34018e5e:	2b00      	cmp	r3, #0
34018e60:	f000 8099 	beq.w	34018f96 <XSPI_ConfigCmd+0x2ae>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34018e64:	683b      	ldr	r3, [r7, #0]
34018e66:	69db      	ldr	r3, [r3, #28]
34018e68:	2b00      	cmp	r3, #0
34018e6a:	d055      	beq.n	34018f18 <XSPI_ConfigCmd+0x230>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018e6c:	683b      	ldr	r3, [r7, #0]
34018e6e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018e70:	2b00      	cmp	r3, #0
34018e72:	d01e      	beq.n	34018eb2 <XSPI_ConfigCmd+0x1ca>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34018e74:	69bb      	ldr	r3, [r7, #24]
34018e76:	681a      	ldr	r2, [r3, #0]
34018e78:	4b67      	ldr	r3, [pc, #412]	@ (34019018 <XSPI_ConfigCmd+0x330>)
34018e7a:	4013      	ands	r3, r2
34018e7c:	683a      	ldr	r2, [r7, #0]
34018e7e:	68d1      	ldr	r1, [r2, #12]
34018e80:	683a      	ldr	r2, [r7, #0]
34018e82:	6952      	ldr	r2, [r2, #20]
34018e84:	4311      	orrs	r1, r2
34018e86:	683a      	ldr	r2, [r7, #0]
34018e88:	6912      	ldr	r2, [r2, #16]
34018e8a:	4311      	orrs	r1, r2
34018e8c:	683a      	ldr	r2, [r7, #0]
34018e8e:	69d2      	ldr	r2, [r2, #28]
34018e90:	4311      	orrs	r1, r2
34018e92:	683a      	ldr	r2, [r7, #0]
34018e94:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34018e96:	4311      	orrs	r1, r2
34018e98:	683a      	ldr	r2, [r7, #0]
34018e9a:	6a12      	ldr	r2, [r2, #32]
34018e9c:	4311      	orrs	r1, r2
34018e9e:	683a      	ldr	r2, [r7, #0]
34018ea0:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34018ea2:	4311      	orrs	r1, r2
34018ea4:	683a      	ldr	r2, [r7, #0]
34018ea6:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34018ea8:	430a      	orrs	r2, r1
34018eaa:	431a      	orrs	r2, r3
34018eac:	69bb      	ldr	r3, [r7, #24]
34018eae:	601a      	str	r2, [r3, #0]
34018eb0:	e028      	b.n	34018f04 <XSPI_ConfigCmd+0x21c>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
34018eb2:	69bb      	ldr	r3, [r7, #24]
34018eb4:	681b      	ldr	r3, [r3, #0]
34018eb6:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34018eba:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34018ebe:	683a      	ldr	r2, [r7, #0]
34018ec0:	68d1      	ldr	r1, [r2, #12]
34018ec2:	683a      	ldr	r2, [r7, #0]
34018ec4:	6952      	ldr	r2, [r2, #20]
34018ec6:	4311      	orrs	r1, r2
34018ec8:	683a      	ldr	r2, [r7, #0]
34018eca:	6912      	ldr	r2, [r2, #16]
34018ecc:	4311      	orrs	r1, r2
34018ece:	683a      	ldr	r2, [r7, #0]
34018ed0:	69d2      	ldr	r2, [r2, #28]
34018ed2:	4311      	orrs	r1, r2
34018ed4:	683a      	ldr	r2, [r7, #0]
34018ed6:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34018ed8:	4311      	orrs	r1, r2
34018eda:	683a      	ldr	r2, [r7, #0]
34018edc:	6a12      	ldr	r2, [r2, #32]
34018ede:	430a      	orrs	r2, r1
34018ee0:	431a      	orrs	r2, r3
34018ee2:	69bb      	ldr	r3, [r7, #24]
34018ee4:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34018ee6:	687b      	ldr	r3, [r7, #4]
34018ee8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34018eea:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018eee:	d109      	bne.n	34018f04 <XSPI_ConfigCmd+0x21c>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
34018ef0:	683b      	ldr	r3, [r7, #0]
34018ef2:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34018ef4:	2b08      	cmp	r3, #8
34018ef6:	d105      	bne.n	34018f04 <XSPI_ConfigCmd+0x21c>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34018ef8:	69bb      	ldr	r3, [r7, #24]
34018efa:	681b      	ldr	r3, [r3, #0]
34018efc:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34018f00:	69bb      	ldr	r3, [r7, #24]
34018f02:	601a      	str	r2, [r3, #0]
        }
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34018f04:	683b      	ldr	r3, [r7, #0]
34018f06:	689a      	ldr	r2, [r3, #8]
34018f08:	693b      	ldr	r3, [r7, #16]
34018f0a:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
34018f0c:	687b      	ldr	r3, [r7, #4]
34018f0e:	681b      	ldr	r3, [r3, #0]
34018f10:	683a      	ldr	r2, [r7, #0]
34018f12:	6992      	ldr	r2, [r2, #24]
34018f14:	649a      	str	r2, [r3, #72]	@ 0x48
34018f16:	e078      	b.n	3401900a <XSPI_ConfigCmd+0x322>
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018f18:	683b      	ldr	r3, [r7, #0]
34018f1a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018f1c:	2b00      	cmp	r3, #0
34018f1e:	d017      	beq.n	34018f50 <XSPI_ConfigCmd+0x268>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
34018f20:	69bb      	ldr	r3, [r7, #24]
34018f22:	681b      	ldr	r3, [r3, #0]
34018f24:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34018f28:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34018f2c:	683a      	ldr	r2, [r7, #0]
34018f2e:	68d1      	ldr	r1, [r2, #12]
34018f30:	683a      	ldr	r2, [r7, #0]
34018f32:	6952      	ldr	r2, [r2, #20]
34018f34:	4311      	orrs	r1, r2
34018f36:	683a      	ldr	r2, [r7, #0]
34018f38:	6912      	ldr	r2, [r2, #16]
34018f3a:	4311      	orrs	r1, r2
34018f3c:	683a      	ldr	r2, [r7, #0]
34018f3e:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34018f40:	4311      	orrs	r1, r2
34018f42:	683a      	ldr	r2, [r7, #0]
34018f44:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34018f46:	430a      	orrs	r2, r1
34018f48:	431a      	orrs	r2, r3
34018f4a:	69bb      	ldr	r3, [r7, #24]
34018f4c:	601a      	str	r2, [r3, #0]
34018f4e:	e01d      	b.n	34018f8c <XSPI_ConfigCmd+0x2a4>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
34018f50:	69bb      	ldr	r3, [r7, #24]
34018f52:	681b      	ldr	r3, [r3, #0]
34018f54:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
34018f58:	683b      	ldr	r3, [r7, #0]
34018f5a:	68d9      	ldr	r1, [r3, #12]
34018f5c:	683b      	ldr	r3, [r7, #0]
34018f5e:	695b      	ldr	r3, [r3, #20]
34018f60:	4319      	orrs	r1, r3
34018f62:	683b      	ldr	r3, [r7, #0]
34018f64:	691b      	ldr	r3, [r3, #16]
34018f66:	430b      	orrs	r3, r1
34018f68:	431a      	orrs	r2, r3
34018f6a:	69bb      	ldr	r3, [r7, #24]
34018f6c:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34018f6e:	687b      	ldr	r3, [r7, #4]
34018f70:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34018f72:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34018f76:	d109      	bne.n	34018f8c <XSPI_ConfigCmd+0x2a4>
            (pCmd->InstructionDTRMode == HAL_XSPI_INSTRUCTION_DTR_ENABLE))
34018f78:	683b      	ldr	r3, [r7, #0]
34018f7a:	695b      	ldr	r3, [r3, #20]
        if ((hxspi->Init.DelayHoldQuarterCycle == HAL_XSPI_DHQC_ENABLE) &&
34018f7c:	2b08      	cmp	r3, #8
34018f7e:	d105      	bne.n	34018f8c <XSPI_ConfigCmd+0x2a4>
        {
          MODIFY_REG((*ccr_reg), XSPI_CCR_DDTR, HAL_XSPI_DATA_DTR_ENABLE);
34018f80:	69bb      	ldr	r3, [r7, #24]
34018f82:	681b      	ldr	r3, [r3, #0]
34018f84:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
34018f88:	69bb      	ldr	r3, [r7, #24]
34018f8a:	601a      	str	r2, [r3, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
34018f8c:	683b      	ldr	r3, [r7, #0]
34018f8e:	689a      	ldr	r2, [r3, #8]
34018f90:	693b      	ldr	r3, [r7, #16]
34018f92:	601a      	str	r2, [r3, #0]
34018f94:	e039      	b.n	3401900a <XSPI_ConfigCmd+0x322>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
34018f96:	683b      	ldr	r3, [r7, #0]
34018f98:	69db      	ldr	r3, [r3, #28]
34018f9a:	2b00      	cmp	r3, #0
34018f9c:	d030      	beq.n	34019000 <XSPI_ConfigCmd+0x318>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
34018f9e:	683b      	ldr	r3, [r7, #0]
34018fa0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34018fa2:	2b00      	cmp	r3, #0
34018fa4:	d017      	beq.n	34018fd6 <XSPI_ConfigCmd+0x2ee>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
34018fa6:	69bb      	ldr	r3, [r7, #24]
34018fa8:	681b      	ldr	r3, [r3, #0]
34018faa:	f023 6370 	bic.w	r3, r3, #251658240	@ 0xf000000
34018fae:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
34018fb2:	683a      	ldr	r2, [r7, #0]
34018fb4:	69d1      	ldr	r1, [r2, #28]
34018fb6:	683a      	ldr	r2, [r7, #0]
34018fb8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
34018fba:	4311      	orrs	r1, r2
34018fbc:	683a      	ldr	r2, [r7, #0]
34018fbe:	6a12      	ldr	r2, [r2, #32]
34018fc0:	4311      	orrs	r1, r2
34018fc2:	683a      	ldr	r2, [r7, #0]
34018fc4:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34018fc6:	4311      	orrs	r1, r2
34018fc8:	683a      	ldr	r2, [r7, #0]
34018fca:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34018fcc:	430a      	orrs	r2, r1
34018fce:	431a      	orrs	r2, r3
34018fd0:	69bb      	ldr	r3, [r7, #24]
34018fd2:	601a      	str	r2, [r3, #0]
34018fd4:	e00e      	b.n	34018ff4 <XSPI_ConfigCmd+0x30c>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
34018fd6:	69bb      	ldr	r3, [r7, #24]
34018fd8:	681b      	ldr	r3, [r3, #0]
34018fda:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
34018fde:	683b      	ldr	r3, [r7, #0]
34018fe0:	69d9      	ldr	r1, [r3, #28]
34018fe2:	683b      	ldr	r3, [r7, #0]
34018fe4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34018fe6:	4319      	orrs	r1, r3
34018fe8:	683b      	ldr	r3, [r7, #0]
34018fea:	6a1b      	ldr	r3, [r3, #32]
34018fec:	430b      	orrs	r3, r1
34018fee:	431a      	orrs	r2, r3
34018ff0:	69bb      	ldr	r3, [r7, #24]
34018ff2:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
34018ff4:	687b      	ldr	r3, [r7, #4]
34018ff6:	681b      	ldr	r3, [r3, #0]
34018ff8:	683a      	ldr	r2, [r7, #0]
34018ffa:	6992      	ldr	r2, [r2, #24]
34018ffc:	649a      	str	r2, [r3, #72]	@ 0x48
34018ffe:	e004      	b.n	3401900a <XSPI_ConfigCmd+0x322>
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
34019000:	2301      	movs	r3, #1
34019002:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
34019004:	687b      	ldr	r3, [r7, #4]
34019006:	2208      	movs	r2, #8
34019008:	65da      	str	r2, [r3, #92]	@ 0x5c
    }
  }

  return status;
3401900a:	7ffb      	ldrb	r3, [r7, #31]
}
3401900c:	4618      	mov	r0, r3
3401900e:	3724      	adds	r7, #36	@ 0x24
34019010:	46bd      	mov	sp, r7
34019012:	f85d 7b04 	ldr.w	r7, [sp], #4
34019016:	4770      	bx	lr
34019018:	f0ffc0c0 	.word	0xf0ffc0c0

3401901c <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *const pCfg)
{
3401901c:	b480      	push	{r7}
3401901e:	b085      	sub	sp, #20
34019020:	af00      	add	r7, sp, #0
34019022:	4603      	mov	r3, r0
34019024:	6039      	str	r1, [r7, #0]
34019026:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
34019028:	79fb      	ldrb	r3, [r7, #7]
3401902a:	2b01      	cmp	r3, #1
3401902c:	d124      	bne.n	34019078 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
3401902e:	4b2c      	ldr	r3, [pc, #176]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
34019030:	681b      	ldr	r3, [r3, #0]
34019032:	f003 0302 	and.w	r3, r3, #2
34019036:	2b00      	cmp	r3, #0
34019038:	d103      	bne.n	34019042 <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
3401903a:	683b      	ldr	r3, [r7, #0]
3401903c:	2200      	movs	r2, #0
3401903e:	605a      	str	r2, [r3, #4]
34019040:	e002      	b.n	34019048 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
34019042:	683b      	ldr	r3, [r7, #0]
34019044:	2201      	movs	r2, #1
34019046:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
34019048:	4b25      	ldr	r3, [pc, #148]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
3401904a:	681b      	ldr	r3, [r3, #0]
3401904c:	f003 0310 	and.w	r3, r3, #16
34019050:	2b10      	cmp	r3, #16
34019052:	d003      	beq.n	3401905c <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
34019054:	683b      	ldr	r3, [r7, #0]
34019056:	2200      	movs	r2, #0
34019058:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
3401905a:	e03a      	b.n	340190d2 <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
3401905c:	4b20      	ldr	r3, [pc, #128]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
3401905e:	681b      	ldr	r3, [r3, #0]
34019060:	f003 0320 	and.w	r3, r3, #32
34019064:	2b20      	cmp	r3, #32
34019066:	d103      	bne.n	34019070 <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
34019068:	683b      	ldr	r3, [r7, #0]
3401906a:	2270      	movs	r2, #112	@ 0x70
3401906c:	601a      	str	r2, [r3, #0]
}
3401906e:	e030      	b.n	340190d2 <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
34019070:	683b      	ldr	r3, [r7, #0]
34019072:	2210      	movs	r2, #16
34019074:	601a      	str	r2, [r3, #0]
}
34019076:	e02c      	b.n	340190d2 <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
34019078:	4b19      	ldr	r3, [pc, #100]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
3401907a:	681b      	ldr	r3, [r3, #0]
3401907c:	f003 0301 	and.w	r3, r3, #1
34019080:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
34019082:	4b17      	ldr	r3, [pc, #92]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
34019084:	681b      	ldr	r3, [r3, #0]
34019086:	085b      	lsrs	r3, r3, #1
34019088:	f003 0301 	and.w	r3, r3, #1
3401908c:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
3401908e:	68fa      	ldr	r2, [r7, #12]
34019090:	68bb      	ldr	r3, [r7, #8]
34019092:	429a      	cmp	r2, r3
34019094:	d003      	beq.n	3401909e <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
34019096:	683b      	ldr	r3, [r7, #0]
34019098:	2200      	movs	r2, #0
3401909a:	605a      	str	r2, [r3, #4]
3401909c:	e002      	b.n	340190a4 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
3401909e:	683b      	ldr	r3, [r7, #0]
340190a0:	2201      	movs	r2, #1
340190a2:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
340190a4:	4b0e      	ldr	r3, [pc, #56]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
340190a6:	681b      	ldr	r3, [r3, #0]
340190a8:	f003 0310 	and.w	r3, r3, #16
340190ac:	2b10      	cmp	r3, #16
340190ae:	d003      	beq.n	340190b8 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
340190b0:	683b      	ldr	r3, [r7, #0]
340190b2:	2200      	movs	r2, #0
340190b4:	601a      	str	r2, [r3, #0]
}
340190b6:	e00c      	b.n	340190d2 <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
340190b8:	4b09      	ldr	r3, [pc, #36]	@ (340190e0 <XSPIM_GetConfig+0xc4>)
340190ba:	681b      	ldr	r3, [r3, #0]
340190bc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340190c0:	2b40      	cmp	r3, #64	@ 0x40
340190c2:	d103      	bne.n	340190cc <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
340190c4:	683b      	ldr	r3, [r7, #0]
340190c6:	2270      	movs	r2, #112	@ 0x70
340190c8:	601a      	str	r2, [r3, #0]
}
340190ca:	e002      	b.n	340190d2 <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
340190cc:	683b      	ldr	r3, [r7, #0]
340190ce:	2210      	movs	r2, #16
340190d0:	601a      	str	r2, [r3, #0]
}
340190d2:	bf00      	nop
340190d4:	3714      	adds	r7, #20
340190d6:	46bd      	mov	sp, r7
340190d8:	f85d 7b04 	ldr.w	r7, [sp], #4
340190dc:	4770      	bx	lr
340190de:	bf00      	nop
340190e0:	5802b400 	.word	0x5802b400

340190e4 <mcu_cache_invalidate_range>:
  }  
  return 0;
}

int mcu_cache_invalidate_range(uint32_t start_addr, uint32_t end_addr) 
{
340190e4:	b480      	push	{r7}
340190e6:	b087      	sub	sp, #28
340190e8:	af00      	add	r7, sp, #0
340190ea:	6078      	str	r0, [r7, #4]
340190ec:	6039      	str	r1, [r7, #0]

#include "stm32n6xx_hal.h"

__STATIC_FORCEINLINE int mcu_cache_enabled(void) {
#if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
340190ee:	4b1d      	ldr	r3, [pc, #116]	@ (34019164 <mcu_cache_invalidate_range+0x80>)
340190f0:	695b      	ldr	r3, [r3, #20]
340190f2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
340190f6:	2b00      	cmp	r3, #0
340190f8:	d001      	beq.n	340190fe <mcu_cache_invalidate_range+0x1a>
340190fa:	2301      	movs	r3, #1
340190fc:	e000      	b.n	34019100 <mcu_cache_invalidate_range+0x1c>
#endif // (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)

  return 0;
340190fe:	2300      	movs	r3, #0
  if(mcu_cache_enabled()) {
34019100:	2b00      	cmp	r3, #0
34019102:	d027      	beq.n	34019154 <mcu_cache_invalidate_range+0x70>
    SCB_InvalidateDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34019104:	687b      	ldr	r3, [r7, #4]
34019106:	6839      	ldr	r1, [r7, #0]
34019108:	687a      	ldr	r2, [r7, #4]
3401910a:	1a8a      	subs	r2, r1, r2
3401910c:	617b      	str	r3, [r7, #20]
3401910e:	613a      	str	r2, [r7, #16]
    if ( dsize > 0 ) {
34019110:	693b      	ldr	r3, [r7, #16]
34019112:	2b00      	cmp	r3, #0
34019114:	dd1d      	ble.n	34019152 <mcu_cache_invalidate_range+0x6e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
34019116:	697b      	ldr	r3, [r7, #20]
34019118:	f003 021f 	and.w	r2, r3, #31
3401911c:	693b      	ldr	r3, [r7, #16]
3401911e:	4413      	add	r3, r2
34019120:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
34019122:	697b      	ldr	r3, [r7, #20]
34019124:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
34019126:	f3bf 8f4f 	dsb	sy
}
3401912a:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
3401912c:	4a0d      	ldr	r2, [pc, #52]	@ (34019164 <mcu_cache_invalidate_range+0x80>)
3401912e:	68bb      	ldr	r3, [r7, #8]
34019130:	f8c2 325c 	str.w	r3, [r2, #604]	@ 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
34019134:	68bb      	ldr	r3, [r7, #8]
34019136:	3320      	adds	r3, #32
34019138:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
3401913a:	68fb      	ldr	r3, [r7, #12]
3401913c:	3b20      	subs	r3, #32
3401913e:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
34019140:	68fb      	ldr	r3, [r7, #12]
34019142:	2b00      	cmp	r3, #0
34019144:	dcf2      	bgt.n	3401912c <mcu_cache_invalidate_range+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
34019146:	f3bf 8f4f 	dsb	sy
}
3401914a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3401914c:	f3bf 8f6f 	isb	sy
}
34019150:	bf00      	nop
}
34019152:	bf00      	nop
  }
  return 0;
34019154:	2300      	movs	r3, #0
}
34019156:	4618      	mov	r0, r3
34019158:	371c      	adds	r7, #28
3401915a:	46bd      	mov	sp, r7
3401915c:	f85d 7b04 	ldr.w	r7, [sp], #4
34019160:	4770      	bx	lr
34019162:	bf00      	nop
34019164:	e000ed00 	.word	0xe000ed00

34019168 <mcu_cache_clean_range>:

int mcu_cache_clean_range(uint32_t start_addr, uint32_t end_addr) {
34019168:	b480      	push	{r7}
3401916a:	b087      	sub	sp, #28
3401916c:	af00      	add	r7, sp, #0
3401916e:	6078      	str	r0, [r7, #4]
34019170:	6039      	str	r1, [r7, #0]
   if (SCB->CCR & SCB_CCR_DC_Msk) return 1;  /* return `1` if DCache is enabled */
34019172:	4b1d      	ldr	r3, [pc, #116]	@ (340191e8 <mcu_cache_clean_range+0x80>)
34019174:	695b      	ldr	r3, [r3, #20]
34019176:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3401917a:	2b00      	cmp	r3, #0
3401917c:	d001      	beq.n	34019182 <mcu_cache_clean_range+0x1a>
3401917e:	2301      	movs	r3, #1
34019180:	e000      	b.n	34019184 <mcu_cache_clean_range+0x1c>
  return 0;
34019182:	2300      	movs	r3, #0
  if(mcu_cache_enabled()) {
34019184:	2b00      	cmp	r3, #0
34019186:	d027      	beq.n	340191d8 <mcu_cache_clean_range+0x70>
    SCB_CleanDCache_by_Addr((volatile void *)start_addr, (int32_t)(end_addr - start_addr));
34019188:	687b      	ldr	r3, [r7, #4]
3401918a:	6839      	ldr	r1, [r7, #0]
3401918c:	687a      	ldr	r2, [r7, #4]
3401918e:	1a8a      	subs	r2, r1, r2
34019190:	617b      	str	r3, [r7, #20]
34019192:	613a      	str	r2, [r7, #16]
    if ( dsize > 0 ) {
34019194:	693b      	ldr	r3, [r7, #16]
34019196:	2b00      	cmp	r3, #0
34019198:	dd1d      	ble.n	340191d6 <mcu_cache_clean_range+0x6e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
3401919a:	697b      	ldr	r3, [r7, #20]
3401919c:	f003 021f 	and.w	r2, r3, #31
340191a0:	693b      	ldr	r3, [r7, #16]
340191a2:	4413      	add	r3, r2
340191a4:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
340191a6:	697b      	ldr	r3, [r7, #20]
340191a8:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
340191aa:	f3bf 8f4f 	dsb	sy
}
340191ae:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
340191b0:	4a0d      	ldr	r2, [pc, #52]	@ (340191e8 <mcu_cache_clean_range+0x80>)
340191b2:	68bb      	ldr	r3, [r7, #8]
340191b4:	f8c2 3268 	str.w	r3, [r2, #616]	@ 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
340191b8:	68bb      	ldr	r3, [r7, #8]
340191ba:	3320      	adds	r3, #32
340191bc:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
340191be:	68fb      	ldr	r3, [r7, #12]
340191c0:	3b20      	subs	r3, #32
340191c2:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
340191c4:	68fb      	ldr	r3, [r7, #12]
340191c6:	2b00      	cmp	r3, #0
340191c8:	dcf2      	bgt.n	340191b0 <mcu_cache_clean_range+0x48>
  __ASM volatile ("dsb 0xF":::"memory");
340191ca:	f3bf 8f4f 	dsb	sy
}
340191ce:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
340191d0:	f3bf 8f6f 	isb	sy
}
340191d4:	bf00      	nop
}
340191d6:	bf00      	nop
  }
  return 0;
340191d8:	2300      	movs	r3, #0
}
340191da:	4618      	mov	r0, r3
340191dc:	371c      	adds	r7, #28
340191de:	46bd      	mov	sp, r7
340191e0:	f85d 7b04 	ldr.w	r7, [sp], #4
340191e4:	4770      	bx	lr
340191e6:	bf00      	nop
340191e8:	e000ed00 	.word	0xe000ed00

340191ec <npu_cache_init>:
#include "stm32n6xx_hal_cacheaxi.h"

static CACHEAXI_HandleTypeDef hcacheaxi_s;

void npu_cache_init(void)
{
340191ec:	b580      	push	{r7, lr}
340191ee:	af00      	add	r7, sp, #0
  hcacheaxi_s.Instance = CACHEAXI;
340191f0:	4b03      	ldr	r3, [pc, #12]	@ (34019200 <npu_cache_init+0x14>)
340191f2:	4a04      	ldr	r2, [pc, #16]	@ (34019204 <npu_cache_init+0x18>)
340191f4:	601a      	str	r2, [r3, #0]
  HAL_CACHEAXI_Init(&hcacheaxi_s);      // Side effect: cacheaxi should be enabled (but one should call npu_enable_cache to be sure)
340191f6:	4802      	ldr	r0, [pc, #8]	@ (34019200 <npu_cache_init+0x14>)
340191f8:	f7ed fe0a 	bl	34006e10 <HAL_CACHEAXI_Init>
}
340191fc:	bf00      	nop
340191fe:	bd80      	pop	{r7, pc}
34019200:	3404a1f0 	.word	0x3404a1f0
34019204:	580dfc00 	.word	0x580dfc00

34019208 <npu_cache_enable>:

void npu_cache_enable(void)
{
34019208:	b580      	push	{r7, lr}
3401920a:	b082      	sub	sp, #8
3401920c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status;
  // Enable is wrapped in a loop because most of times, the first call returns
  //    HAL_BUSY, resulting in a cache not enabled.
  do
  {
    status = HAL_CACHEAXI_Enable(&hcacheaxi_s);
3401920e:	4806      	ldr	r0, [pc, #24]	@ (34019228 <npu_cache_enable+0x20>)
34019210:	f7ed fe1f 	bl	34006e52 <HAL_CACHEAXI_Enable>
34019214:	4603      	mov	r3, r0
34019216:	71fb      	strb	r3, [r7, #7]
  } while (status == HAL_BUSY);
34019218:	79fb      	ldrb	r3, [r7, #7]
3401921a:	2b02      	cmp	r3, #2
3401921c:	d0f7      	beq.n	3401920e <npu_cache_enable+0x6>
}
3401921e:	bf00      	nop
34019220:	bf00      	nop
34019222:	3708      	adds	r7, #8
34019224:	46bd      	mov	sp, r7
34019226:	bd80      	pop	{r7, pc}
34019228:	3404a1f0 	.word	0x3404a1f0

3401922c <npu_cache_clean_invalidate_range>:
{
  HAL_CACHEAXI_CleanByAddr(&hcacheaxi_s, (uint32_t*)start_addr, end_addr-start_addr);
}

void npu_cache_clean_invalidate_range(uint32_t start_addr, uint32_t end_addr)
{
3401922c:	b580      	push	{r7, lr}
3401922e:	b082      	sub	sp, #8
34019230:	af00      	add	r7, sp, #0
34019232:	6078      	str	r0, [r7, #4]
34019234:	6039      	str	r1, [r7, #0]
  HAL_CACHEAXI_CleanInvalidByAddr(&hcacheaxi_s, (uint32_t*)start_addr, end_addr-start_addr);
34019236:	6879      	ldr	r1, [r7, #4]
34019238:	683a      	ldr	r2, [r7, #0]
3401923a:	687b      	ldr	r3, [r7, #4]
3401923c:	1ad3      	subs	r3, r2, r3
3401923e:	461a      	mov	r2, r3
34019240:	4803      	ldr	r0, [pc, #12]	@ (34019250 <npu_cache_clean_invalidate_range+0x24>)
34019242:	f7ed fe4a 	bl	34006eda <HAL_CACHEAXI_CleanInvalidByAddr>
}
34019246:	bf00      	nop
34019248:	3708      	adds	r7, #8
3401924a:	46bd      	mov	sp, r7
3401924c:	bd80      	pop	{r7, pc}
3401924e:	bf00      	nop
34019250:	3404a1f0 	.word	0x3404a1f0

34019254 <ec_copy_program>:
 * \retval \e true  on success
 * \retval \e false otherwise
 */

bool ec_copy_program(const uint8_t *file_ptr, ECInstr *program, unsigned int *program_size)
{
34019254:	b580      	push	{r7, lr}
34019256:	b08a      	sub	sp, #40	@ 0x28
34019258:	af00      	add	r7, sp, #0
3401925a:	60f8      	str	r0, [r7, #12]
3401925c:	60b9      	str	r1, [r7, #8]
3401925e:	607a      	str	r2, [r7, #4]
  const uint8_t *ptr = file_ptr;
34019260:	68fb      	ldr	r3, [r7, #12]
34019262:	627b      	str	r3, [r7, #36]	@ 0x24

  // read the file header

  ECFileEntry magic = 0;
34019264:	2300      	movs	r3, #0
34019266:	61fb      	str	r3, [r7, #28]
  ECFileEntry program_offset = 0;
34019268:	2300      	movs	r3, #0
3401926a:	61bb      	str	r3, [r7, #24]

  magic = *((ECFileEntry *)ptr);
3401926c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401926e:	681b      	ldr	r3, [r3, #0]
34019270:	61fb      	str	r3, [r7, #28]

  ptr += sizeof(ECFileEntry);
34019272:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019274:	3304      	adds	r3, #4
34019276:	627b      	str	r3, [r7, #36]	@ 0x24

  if (magic != ECASM_BINARY_MAGIC)
34019278:	69fb      	ldr	r3, [r7, #28]
3401927a:	4a41      	ldr	r2, [pc, #260]	@ (34019380 <ec_copy_program+0x12c>)
3401927c:	4293      	cmp	r3, r2
3401927e:	d004      	beq.n	3401928a <ec_copy_program+0x36>
  {
    LL_ATON_PRINTF("Error: Epoch Controller binary is invalid\n");
34019280:	4840      	ldr	r0, [pc, #256]	@ (34019384 <ec_copy_program+0x130>)
34019282:	f00d fd67 	bl	34026d54 <puts>

    return false;
34019286:	2300      	movs	r3, #0
34019288:	e075      	b.n	34019376 <ec_copy_program+0x122>
  }

  ptr = file_ptr + sizeof(ECFileEntry) + 2 * sizeof(ECFileEntry);
3401928a:	68fb      	ldr	r3, [r7, #12]
3401928c:	330c      	adds	r3, #12
3401928e:	627b      	str	r3, [r7, #36]	@ 0x24

  program_offset = *((ECFileEntry *)ptr);
34019290:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019292:	681b      	ldr	r3, [r3, #0]
34019294:	61bb      	str	r3, [r7, #24]

  ptr += sizeof(ECFileEntry);
34019296:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019298:	3304      	adds	r3, #4
3401929a:	627b      	str	r3, [r7, #36]	@ 0x24

  if (program_offset == 0)
3401929c:	69bb      	ldr	r3, [r7, #24]
3401929e:	2b00      	cmp	r3, #0
340192a0:	d104      	bne.n	340192ac <ec_copy_program+0x58>
  {
    LL_ATON_PRINTF("Error: Program section offset in binary file is invalid\n");
340192a2:	4839      	ldr	r0, [pc, #228]	@ (34019388 <ec_copy_program+0x134>)
340192a4:	f00d fd56 	bl	34026d54 <puts>

    return false;
340192a8:	2300      	movs	r3, #0
340192aa:	e064      	b.n	34019376 <ec_copy_program+0x122>
  }

  // read the Epoch Controller program section

  ptr = file_ptr + program_offset;
340192ac:	68fa      	ldr	r2, [r7, #12]
340192ae:	69bb      	ldr	r3, [r7, #24]
340192b0:	4413      	add	r3, r2
340192b2:	627b      	str	r3, [r7, #36]	@ 0x24

  ECInstr program_magic = 0;
340192b4:	2300      	movs	r3, #0
340192b6:	617b      	str	r3, [r7, #20]

  program_magic = *((ECInstr *)ptr);
340192b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340192ba:	681b      	ldr	r3, [r3, #0]
340192bc:	617b      	str	r3, [r7, #20]

  ptr += sizeof(ECInstr);
340192be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340192c0:	3304      	adds	r3, #4
340192c2:	627b      	str	r3, [r7, #36]	@ 0x24

  if (program_magic != ECASM_PROGRAM_MAGIC)
340192c4:	697b      	ldr	r3, [r7, #20]
340192c6:	4a31      	ldr	r2, [pc, #196]	@ (3401938c <ec_copy_program+0x138>)
340192c8:	4293      	cmp	r3, r2
340192ca:	d004      	beq.n	340192d6 <ec_copy_program+0x82>
  {
    LL_ATON_PRINTF("Error: Invalid magic number of Epoch Controller program\n");
340192cc:	4830      	ldr	r0, [pc, #192]	@ (34019390 <ec_copy_program+0x13c>)
340192ce:	f00d fd41 	bl	34026d54 <puts>

    return false;
340192d2:	2300      	movs	r3, #0
340192d4:	e04f      	b.n	34019376 <ec_copy_program+0x122>
  }

  ECInstr size = 0;
340192d6:	2300      	movs	r3, #0
340192d8:	613b      	str	r3, [r7, #16]

  size = *((ECInstr *)ptr);
340192da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340192dc:	681b      	ldr	r3, [r3, #0]
340192de:	613b      	str	r3, [r7, #16]

  ptr += sizeof(ECInstr);
340192e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340192e2:	3304      	adds	r3, #4
340192e4:	627b      	str	r3, [r7, #36]	@ 0x24

  if (program == NULL)
340192e6:	68bb      	ldr	r3, [r7, #8]
340192e8:	2b00      	cmp	r3, #0
340192ea:	d107      	bne.n	340192fc <ec_copy_program+0xa8>
  {
    if (program_size != NULL)
340192ec:	687b      	ldr	r3, [r7, #4]
340192ee:	2b00      	cmp	r3, #0
340192f0:	d040      	beq.n	34019374 <ec_copy_program+0x120>
      *program_size = size + 2;
340192f2:	693b      	ldr	r3, [r7, #16]
340192f4:	1c9a      	adds	r2, r3, #2
340192f6:	687b      	ldr	r3, [r7, #4]
340192f8:	601a      	str	r2, [r3, #0]
340192fa:	e03b      	b.n	34019374 <ec_copy_program+0x120>
  }
  else
  {
    if ((((intptr_t)program) % 8) != 0)
340192fc:	68bb      	ldr	r3, [r7, #8]
340192fe:	f003 0307 	and.w	r3, r3, #7
34019302:	2b00      	cmp	r3, #0
34019304:	d004      	beq.n	34019310 <ec_copy_program+0xbc>
    {
      LL_ATON_PRINTF("Error: Memory allocated for the Epoch Controller program must be 8-byte aligned\n");
34019306:	4823      	ldr	r0, [pc, #140]	@ (34019394 <ec_copy_program+0x140>)
34019308:	f00d fd24 	bl	34026d54 <puts>

      return false;
3401930c:	2300      	movs	r3, #0
3401930e:	e032      	b.n	34019376 <ec_copy_program+0x122>
    }

    if (program_size == NULL)
34019310:	687b      	ldr	r3, [r7, #4]
34019312:	2b00      	cmp	r3, #0
34019314:	d104      	bne.n	34019320 <ec_copy_program+0xcc>
    {
      LL_ATON_PRINTF("Error: Size of memory allocated for the Epoch Controller program has not been specified\n");
34019316:	4820      	ldr	r0, [pc, #128]	@ (34019398 <ec_copy_program+0x144>)
34019318:	f00d fd1c 	bl	34026d54 <puts>

      return false;
3401931c:	2300      	movs	r3, #0
3401931e:	e02a      	b.n	34019376 <ec_copy_program+0x122>
    }

    if (*program_size < (size + 2))
34019320:	687b      	ldr	r3, [r7, #4]
34019322:	681a      	ldr	r2, [r3, #0]
34019324:	693b      	ldr	r3, [r7, #16]
34019326:	3302      	adds	r3, #2
34019328:	429a      	cmp	r2, r3
3401932a:	d207      	bcs.n	3401933c <ec_copy_program+0xe8>
    {
      LL_ATON_PRINTF(
3401932c:	693b      	ldr	r3, [r7, #16]
3401932e:	3302      	adds	r3, #2
34019330:	4619      	mov	r1, r3
34019332:	481a      	ldr	r0, [pc, #104]	@ (3401939c <ec_copy_program+0x148>)
34019334:	f00d fca6 	bl	34026c84 <iprintf>
          "Error: Memory allocated for the Epoch Controller program is not sufficient (at least space for %u "
          "32-bit words must be allocated)\n",
          size + 2);

      return false;
34019338:	2300      	movs	r3, #0
3401933a:	e01c      	b.n	34019376 <ec_copy_program+0x122>
    }

    program[0] = program_magic;
3401933c:	68bb      	ldr	r3, [r7, #8]
3401933e:	697a      	ldr	r2, [r7, #20]
34019340:	601a      	str	r2, [r3, #0]
    program[1] = size;
34019342:	68bb      	ldr	r3, [r7, #8]
34019344:	3304      	adds	r3, #4
34019346:	693a      	ldr	r2, [r7, #16]
34019348:	601a      	str	r2, [r3, #0]

    for (unsigned int i = 0; i < size; i++, ptr += sizeof(ECInstr))
3401934a:	2300      	movs	r3, #0
3401934c:	623b      	str	r3, [r7, #32]
3401934e:	e00d      	b.n	3401936c <ec_copy_program+0x118>
      program[i + 2] = *((ECInstr *)ptr);
34019350:	6a3b      	ldr	r3, [r7, #32]
34019352:	3302      	adds	r3, #2
34019354:	009b      	lsls	r3, r3, #2
34019356:	68ba      	ldr	r2, [r7, #8]
34019358:	4413      	add	r3, r2
3401935a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401935c:	6812      	ldr	r2, [r2, #0]
3401935e:	601a      	str	r2, [r3, #0]
    for (unsigned int i = 0; i < size; i++, ptr += sizeof(ECInstr))
34019360:	6a3b      	ldr	r3, [r7, #32]
34019362:	3301      	adds	r3, #1
34019364:	623b      	str	r3, [r7, #32]
34019366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019368:	3304      	adds	r3, #4
3401936a:	627b      	str	r3, [r7, #36]	@ 0x24
3401936c:	6a3a      	ldr	r2, [r7, #32]
3401936e:	693b      	ldr	r3, [r7, #16]
34019370:	429a      	cmp	r2, r3
34019372:	d3ed      	bcc.n	34019350 <ec_copy_program+0xfc>
  }

  return true;
34019374:	2301      	movs	r3, #1
}
34019376:	4618      	mov	r0, r3
34019378:	3728      	adds	r7, #40	@ 0x28
3401937a:	46bd      	mov	sp, r7
3401937c:	bd80      	pop	{r7, pc}
3401937e:	bf00      	nop
34019380:	ecbf0020 	.word	0xecbf0020
34019384:	3402a40c 	.word	0x3402a40c
34019388:	3402a438 	.word	0x3402a438
3401938c:	ca057a7a 	.word	0xca057a7a
34019390:	3402a470 	.word	0x3402a470
34019394:	3402a4a8 	.word	0x3402a4a8
34019398:	3402a4f8 	.word	0x3402a4f8
3401939c:	3402a550 	.word	0x3402a550

340193a0 <ec_get_reloc_table_ptr>:
 * \return the pointer to the relocation table contained in the Epoch Controller binary pointed by \e file_ptr, or \e
 * NULL if the Epoch Controller binary does not contain any relocation table or on errors
 */

const ECFileEntry *ec_get_reloc_table_ptr(const uint8_t *file_ptr)
{
340193a0:	b580      	push	{r7, lr}
340193a2:	b086      	sub	sp, #24
340193a4:	af00      	add	r7, sp, #0
340193a6:	6078      	str	r0, [r7, #4]
  const uint8_t *ptr = file_ptr;
340193a8:	687b      	ldr	r3, [r7, #4]
340193aa:	617b      	str	r3, [r7, #20]

  // read the file header

  ECFileEntry magic = 0;
340193ac:	2300      	movs	r3, #0
340193ae:	613b      	str	r3, [r7, #16]
  ECFileEntry reloc_offset = 0;
340193b0:	2300      	movs	r3, #0
340193b2:	60fb      	str	r3, [r7, #12]

  magic = *((ECFileEntry *)ptr);
340193b4:	697b      	ldr	r3, [r7, #20]
340193b6:	681b      	ldr	r3, [r3, #0]
340193b8:	613b      	str	r3, [r7, #16]

  ptr += sizeof(ECFileEntry);
340193ba:	697b      	ldr	r3, [r7, #20]
340193bc:	3304      	adds	r3, #4
340193be:	617b      	str	r3, [r7, #20]

  if (magic != ECASM_BINARY_MAGIC)
340193c0:	693b      	ldr	r3, [r7, #16]
340193c2:	4a0b      	ldr	r2, [pc, #44]	@ (340193f0 <ec_get_reloc_table_ptr+0x50>)
340193c4:	4293      	cmp	r3, r2
340193c6:	d004      	beq.n	340193d2 <ec_get_reloc_table_ptr+0x32>
  {
    LL_ATON_PRINTF("Error: Epoch Controller binary is invalid\n");
340193c8:	480a      	ldr	r0, [pc, #40]	@ (340193f4 <ec_get_reloc_table_ptr+0x54>)
340193ca:	f00d fcc3 	bl	34026d54 <puts>

    return NULL;
340193ce:	2300      	movs	r3, #0
340193d0:	e00a      	b.n	340193e8 <ec_get_reloc_table_ptr+0x48>
  }

  reloc_offset = *((ECFileEntry *)ptr);
340193d2:	697b      	ldr	r3, [r7, #20]
340193d4:	681b      	ldr	r3, [r3, #0]
340193d6:	60fb      	str	r3, [r7, #12]

  return (reloc_offset == 0) ? NULL : (const ECFileEntry *)(file_ptr + reloc_offset);
340193d8:	68fb      	ldr	r3, [r7, #12]
340193da:	2b00      	cmp	r3, #0
340193dc:	d003      	beq.n	340193e6 <ec_get_reloc_table_ptr+0x46>
340193de:	687a      	ldr	r2, [r7, #4]
340193e0:	68fb      	ldr	r3, [r7, #12]
340193e2:	4413      	add	r3, r2
340193e4:	e000      	b.n	340193e8 <ec_get_reloc_table_ptr+0x48>
340193e6:	2300      	movs	r3, #0
}
340193e8:	4618      	mov	r0, r3
340193ea:	3718      	adds	r7, #24
340193ec:	46bd      	mov	sp, r7
340193ee:	bd80      	pop	{r7, pc}
340193f0:	ecbf0020 	.word	0xecbf0020
340193f4:	3402a40c 	.word	0x3402a40c

340193f8 <ec_reloc>:
 * \retval \e true  on success
 * \retval \e false otherwise
 */

bool ec_reloc(const ECFileEntry *reloc_table_ptr, ECInstr *program, unsigned int idx, ECAddr base, ECAddr *prev_base)
{
340193f8:	b580      	push	{r7, lr}
340193fa:	b08a      	sub	sp, #40	@ 0x28
340193fc:	af00      	add	r7, sp, #0
340193fe:	60f8      	str	r0, [r7, #12]
34019400:	60b9      	str	r1, [r7, #8]
34019402:	607a      	str	r2, [r7, #4]
34019404:	603b      	str	r3, [r7, #0]
  if (reloc_table_ptr == NULL)
34019406:	68fb      	ldr	r3, [r7, #12]
34019408:	2b00      	cmp	r3, #0
3401940a:	d104      	bne.n	34019416 <ec_reloc+0x1e>
  {
    LL_ATON_PRINTF("Error: Cannot relocate because the pointer to the Epoch Controller relocation table is invalid\n");
3401940c:	482e      	ldr	r0, [pc, #184]	@ (340194c8 <ec_reloc+0xd0>)
3401940e:	f00d fca1 	bl	34026d54 <puts>

    return false;
34019412:	2300      	movs	r3, #0
34019414:	e053      	b.n	340194be <ec_reloc+0xc6>
  }

  if (base == *prev_base)
34019416:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019418:	681b      	ldr	r3, [r3, #0]
3401941a:	683a      	ldr	r2, [r7, #0]
3401941c:	429a      	cmp	r2, r3
3401941e:	d101      	bne.n	34019424 <ec_reloc+0x2c>
    return true;
34019420:	2301      	movs	r3, #1
34019422:	e04c      	b.n	340194be <ec_reloc+0xc6>

  const ECFileEntry *ptr = reloc_table_ptr;
34019424:	68fb      	ldr	r3, [r7, #12]
34019426:	627b      	str	r3, [r7, #36]	@ 0x24

  ECFileEntry size = *ptr;
34019428:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401942a:	681b      	ldr	r3, [r3, #0]
3401942c:	61fb      	str	r3, [r7, #28]

  if (idx < size)
3401942e:	687a      	ldr	r2, [r7, #4]
34019430:	69fb      	ldr	r3, [r7, #28]
34019432:	429a      	cmp	r2, r3
34019434:	d23f      	bcs.n	340194b6 <ec_reloc+0xbe>
  {
    ptr = reloc_table_ptr + 3 * idx + 2;
34019436:	687a      	ldr	r2, [r7, #4]
34019438:	4613      	mov	r3, r2
3401943a:	005b      	lsls	r3, r3, #1
3401943c:	4413      	add	r3, r2
3401943e:	009b      	lsls	r3, r3, #2
34019440:	3308      	adds	r3, #8
34019442:	68fa      	ldr	r2, [r7, #12]
34019444:	4413      	add	r3, r2
34019446:	627b      	str	r3, [r7, #36]	@ 0x24

    ECFileEntry num = *ptr++;
34019448:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401944a:	1d1a      	adds	r2, r3, #4
3401944c:	627a      	str	r2, [r7, #36]	@ 0x24
3401944e:	681b      	ldr	r3, [r3, #0]
34019450:	61bb      	str	r3, [r7, #24]

    ECFileEntry offset = *ptr;
34019452:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34019454:	681b      	ldr	r3, [r3, #0]
34019456:	617b      	str	r3, [r7, #20]

    if ((offset % sizeof(ECFileEntry)) != 0)
34019458:	697b      	ldr	r3, [r7, #20]
3401945a:	f003 0303 	and.w	r3, r3, #3
3401945e:	2b00      	cmp	r3, #0
34019460:	d005      	beq.n	3401946e <ec_reloc+0x76>
    {
      LL_ATON_PRINTF("Error: Offset %lu in Epoch Controller binary is invalid\n", (unsigned long)offset);
34019462:	6979      	ldr	r1, [r7, #20]
34019464:	4819      	ldr	r0, [pc, #100]	@ (340194cc <ec_reloc+0xd4>)
34019466:	f00d fc0d 	bl	34026c84 <iprintf>

      return false;
3401946a:	2300      	movs	r3, #0
3401946c:	e027      	b.n	340194be <ec_reloc+0xc6>
    }

    ptr = (const ECFileEntry *)((const uint8_t *)reloc_table_ptr + offset);
3401946e:	68fa      	ldr	r2, [r7, #12]
34019470:	697b      	ldr	r3, [r7, #20]
34019472:	4413      	add	r3, r2
34019474:	627b      	str	r3, [r7, #36]	@ 0x24

    for (unsigned int i = 0; i < num; i++)
34019476:	2300      	movs	r3, #0
34019478:	623b      	str	r3, [r7, #32]
3401947a:	e018      	b.n	340194ae <ec_reloc+0xb6>
    {
      ECFileEntry offset = *ptr++;
3401947c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401947e:	1d1a      	adds	r2, r3, #4
34019480:	627a      	str	r2, [r7, #36]	@ 0x24
34019482:	681b      	ldr	r3, [r3, #0]
34019484:	613b      	str	r3, [r7, #16]

      // offset is from the real beginning of the EC program, that is, from the first real instruction (the one
      // following the magic number of the EC program and its size)
      program[offset + 2] += base - *prev_base;
34019486:	693b      	ldr	r3, [r7, #16]
34019488:	3302      	adds	r3, #2
3401948a:	009b      	lsls	r3, r3, #2
3401948c:	68ba      	ldr	r2, [r7, #8]
3401948e:	4413      	add	r3, r2
34019490:	6819      	ldr	r1, [r3, #0]
34019492:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34019494:	681b      	ldr	r3, [r3, #0]
34019496:	683a      	ldr	r2, [r7, #0]
34019498:	1ad2      	subs	r2, r2, r3
3401949a:	693b      	ldr	r3, [r7, #16]
3401949c:	3302      	adds	r3, #2
3401949e:	009b      	lsls	r3, r3, #2
340194a0:	68b8      	ldr	r0, [r7, #8]
340194a2:	4403      	add	r3, r0
340194a4:	440a      	add	r2, r1
340194a6:	601a      	str	r2, [r3, #0]
    for (unsigned int i = 0; i < num; i++)
340194a8:	6a3b      	ldr	r3, [r7, #32]
340194aa:	3301      	adds	r3, #1
340194ac:	623b      	str	r3, [r7, #32]
340194ae:	6a3a      	ldr	r2, [r7, #32]
340194b0:	69bb      	ldr	r3, [r7, #24]
340194b2:	429a      	cmp	r2, r3
340194b4:	d3e2      	bcc.n	3401947c <ec_reloc+0x84>
    }
  }

  *prev_base = base;
340194b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340194b8:	683a      	ldr	r2, [r7, #0]
340194ba:	601a      	str	r2, [r3, #0]

  return true;
340194bc:	2301      	movs	r3, #1
}
340194be:	4618      	mov	r0, r3
340194c0:	3728      	adds	r7, #40	@ 0x28
340194c2:	46bd      	mov	sp, r7
340194c4:	bd80      	pop	{r7, pc}
340194c6:	bf00      	nop
340194c8:	3402a7c4 	.word	0x3402a7c4
340194cc:	3402a824 	.word	0x3402a824

340194d0 <ll_aton_static_checks>:
 *  Used to exit from LL_Streng_Wait() in case epoch locks
 * @{
 */

static inline void ll_aton_static_checks(void)
{
340194d0:	b580      	push	{r7, lr}
340194d2:	b082      	sub	sp, #8
340194d4:	af02      	add	r7, sp, #8
  static char done = 0;

  if (done != 0)
340194d6:	4b27      	ldr	r3, [pc, #156]	@ (34019574 <ll_aton_static_checks+0xa4>)
340194d8:	781b      	ldrb	r3, [r3, #0]
340194da:	2b00      	cmp	r3, #0
340194dc:	d146      	bne.n	3401956c <ll_aton_static_checks+0x9c>
    return;
  done = 1;
340194de:	4b25      	ldr	r3, [pc, #148]	@ (34019574 <ll_aton_static_checks+0xa4>)
340194e0:	2201      	movs	r2, #1
340194e2:	701a      	strb	r2, [r3, #0]
  LL_ATON_ASSERT(ATONN_CONST_SRCPORT(S, J, U, I, P) == __atonn_getSrcPortID(S, J, U, I, P))
#define ASSERT_ATONN_DSTPORT(S, J, U, I, P)                                                                            \
  LL_ATON_ASSERT(ATONN_CONST_DSTPORT(S, J, U, I, P) == __atonn_getDstPortID(S, J, U, I, P))

#if ATON_STRENG_NUM > 1
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 1, 0);
340194e4:	2300      	movs	r3, #0
340194e6:	9300      	str	r3, [sp, #0]
340194e8:	2301      	movs	r3, #1
340194ea:	2200      	movs	r2, #0
340194ec:	2100      	movs	r1, #0
340194ee:	2000      	movs	r0, #0
340194f0:	f000 fc58 	bl	34019da4 <__atonn_getSrcPortID>
340194f4:	4603      	mov	r3, r0
340194f6:	2b01      	cmp	r3, #1
340194f8:	d005      	beq.n	34019506 <ll_aton_static_checks+0x36>
340194fa:	4b1f      	ldr	r3, [pc, #124]	@ (34019578 <ll_aton_static_checks+0xa8>)
340194fc:	4a1f      	ldr	r2, [pc, #124]	@ (3401957c <ll_aton_static_checks+0xac>)
340194fe:	214e      	movs	r1, #78	@ 0x4e
34019500:	481f      	ldr	r0, [pc, #124]	@ (34019580 <ll_aton_static_checks+0xb0>)
34019502:	f00c fc31 	bl	34025d68 <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 1, 0);
34019506:	2300      	movs	r3, #0
34019508:	9300      	str	r3, [sp, #0]
3401950a:	2301      	movs	r3, #1
3401950c:	2200      	movs	r2, #0
3401950e:	2100      	movs	r1, #0
34019510:	2000      	movs	r0, #0
34019512:	f000 fd37 	bl	34019f84 <__atonn_getDstPortID>
34019516:	4603      	mov	r3, r0
34019518:	2b0c      	cmp	r3, #12
3401951a:	d005      	beq.n	34019528 <ll_aton_static_checks+0x58>
3401951c:	4b19      	ldr	r3, [pc, #100]	@ (34019584 <ll_aton_static_checks+0xb4>)
3401951e:	4a17      	ldr	r2, [pc, #92]	@ (3401957c <ll_aton_static_checks+0xac>)
34019520:	214f      	movs	r1, #79	@ 0x4f
34019522:	4817      	ldr	r0, [pc, #92]	@ (34019580 <ll_aton_static_checks+0xb0>)
34019524:	f00c fc20 	bl	34025d68 <__assert_func>
#endif
#if ATON_STRENG_NUM > 2
  ASSERT_ATONN_SRCPORT(STRSWITCH, 0, STRENG, 2, 0);
34019528:	2300      	movs	r3, #0
3401952a:	9300      	str	r3, [sp, #0]
3401952c:	2302      	movs	r3, #2
3401952e:	2200      	movs	r2, #0
34019530:	2100      	movs	r1, #0
34019532:	2000      	movs	r0, #0
34019534:	f000 fc36 	bl	34019da4 <__atonn_getSrcPortID>
34019538:	4603      	mov	r3, r0
3401953a:	2b02      	cmp	r3, #2
3401953c:	d005      	beq.n	3401954a <ll_aton_static_checks+0x7a>
3401953e:	4b12      	ldr	r3, [pc, #72]	@ (34019588 <ll_aton_static_checks+0xb8>)
34019540:	4a0e      	ldr	r2, [pc, #56]	@ (3401957c <ll_aton_static_checks+0xac>)
34019542:	2152      	movs	r1, #82	@ 0x52
34019544:	480e      	ldr	r0, [pc, #56]	@ (34019580 <ll_aton_static_checks+0xb0>)
34019546:	f00c fc0f 	bl	34025d68 <__assert_func>
  ASSERT_ATONN_DSTPORT(STRSWITCH, 0, STRENG, 2, 0);
3401954a:	2300      	movs	r3, #0
3401954c:	9300      	str	r3, [sp, #0]
3401954e:	2302      	movs	r3, #2
34019550:	2200      	movs	r2, #0
34019552:	2100      	movs	r1, #0
34019554:	2000      	movs	r0, #0
34019556:	f000 fd15 	bl	34019f84 <__atonn_getDstPortID>
3401955a:	4603      	mov	r3, r0
3401955c:	2b10      	cmp	r3, #16
3401955e:	d006      	beq.n	3401956e <ll_aton_static_checks+0x9e>
34019560:	4b0a      	ldr	r3, [pc, #40]	@ (3401958c <ll_aton_static_checks+0xbc>)
34019562:	4a06      	ldr	r2, [pc, #24]	@ (3401957c <ll_aton_static_checks+0xac>)
34019564:	2153      	movs	r1, #83	@ 0x53
34019566:	4806      	ldr	r0, [pc, #24]	@ (34019580 <ll_aton_static_checks+0xb0>)
34019568:	f00c fbfe 	bl	34025d68 <__assert_func>
    return;
3401956c:	bf00      	nop

#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)

#undef ASSERT_ATONN_SRCPORT
#undef ASSERT_ATONN_DSTPORT
}
3401956e:	46bd      	mov	sp, r7
34019570:	bd80      	pop	{r7, pc}
34019572:	bf00      	nop
34019574:	3404a1fc 	.word	0x3404a1fc
34019578:	3402a8b0 	.word	0x3402a8b0
3401957c:	3402be90 	.word	0x3402be90
34019580:	3402a8ec 	.word	0x3402a8ec
34019584:	3402a928 	.word	0x3402a928
34019588:	3402a974 	.word	0x3402a974
3401958c:	3402a9b0 	.word	0x3402a9b0

34019590 <LL_ATON_Init>:
/**
 * @brief  ATON global initialization. Initializes clocks and bus interfaces. Must be called before anything else
 * @retval Always zero
 */
int LL_ATON_Init(void)
{
34019590:	b590      	push	{r4, r7, lr}
34019592:	b08b      	sub	sp, #44	@ 0x2c
34019594:	af08      	add	r7, sp, #32
  uint32_t t;
  int i;

  ll_aton_static_checks();
34019596:	f7ff ff9b 	bl	340194d0 <ll_aton_static_checks>

  /* Clear pipeline */
  t = ATON_CLKCTRL_CTRL_GET(0);
3401959a:	4b97      	ldr	r3, [pc, #604]	@ (340197f8 <LL_ATON_Init+0x268>)
3401959c:	681b      	ldr	r3, [r3, #0]
3401959e:	607b      	str	r3, [r7, #4]
  t = ATON_CLKCTRL_CTRL_SET_CLR(t, 1);
340195a0:	687b      	ldr	r3, [r7, #4]
340195a2:	f043 0302 	orr.w	r3, r3, #2
340195a6:	607b      	str	r3, [r7, #4]
  ATON_CLKCTRL_CTRL_SET(0, t);
340195a8:	4a93      	ldr	r2, [pc, #588]	@ (340197f8 <LL_ATON_Init+0x268>)
340195aa:	687b      	ldr	r3, [r7, #4]
340195ac:	6013      	str	r3, [r2, #0]

  /* Enable all ATON clocks */
  ATON_CLKCTRL_CTRL_SET(0, 1);
340195ae:	4b92      	ldr	r3, [pc, #584]	@ (340197f8 <LL_ATON_Init+0x268>)
340195b0:	2201      	movs	r2, #1
340195b2:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES0_SET(0, 0xffffffff);
340195b4:	4b91      	ldr	r3, [pc, #580]	@ (340197fc <LL_ATON_Init+0x26c>)
340195b6:	f04f 32ff 	mov.w	r2, #4294967295
340195ba:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0xffffffff);
340195bc:	4b90      	ldr	r3, [pc, #576]	@ (34019800 <LL_ATON_Init+0x270>)
340195be:	f04f 32ff 	mov.w	r2, #4294967295
340195c2:	601a      	str	r2, [r3, #0]

#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_EC_TRACE)
  ATON_CLKCTRL_BGATES_SET(0, (1 << ATON_EPOCHCTRL_CLKB_CLK(0)));
#else
  ATON_CLKCTRL_BGATES_SET(0, 0x0);
340195c4:	4b8f      	ldr	r3, [pc, #572]	@ (34019804 <LL_ATON_Init+0x274>)
340195c6:	2200      	movs	r2, #0
340195c8:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0xffffffff);
#endif

  /* Check that RTL and ATON.h match. Only check first unit */
  ASSERT_UNITS_VERS_W_MSG(STRENG, t);
340195ca:	4b8f      	ldr	r3, [pc, #572]	@ (34019808 <LL_ATON_Init+0x278>)
340195cc:	681b      	ldr	r3, [r3, #0]
340195ce:	607b      	str	r3, [r7, #4]
340195d0:	687b      	ldr	r3, [r7, #4]
340195d2:	2b00      	cmp	r3, #0
340195d4:	d0f9      	beq.n	340195ca <LL_ATON_Init+0x3a>
340195d6:	687b      	ldr	r3, [r7, #4]
340195d8:	b2db      	uxtb	r3, r3
340195da:	2b01      	cmp	r3, #1
340195dc:	d10a      	bne.n	340195f4 <LL_ATON_Init+0x64>
340195de:	687b      	ldr	r3, [r7, #4]
340195e0:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340195e4:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
340195e8:	d104      	bne.n	340195f4 <LL_ATON_Init+0x64>
340195ea:	687b      	ldr	r3, [r7, #4]
340195ec:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340195f0:	2b00      	cmp	r3, #0
340195f2:	d02f      	beq.n	34019654 <LL_ATON_Init+0xc4>
340195f4:	f00e f822 	bl	3402763c <__errno>
340195f8:	4603      	mov	r3, r0
340195fa:	681b      	ldr	r3, [r3, #0]
340195fc:	2b00      	cmp	r3, #0
340195fe:	d008      	beq.n	34019612 <LL_ATON_Init+0x82>
34019600:	f00e f81c 	bl	3402763c <__errno>
34019604:	4603      	mov	r3, r0
34019606:	681b      	ldr	r3, [r3, #0]
34019608:	4618      	mov	r0, r3
3401960a:	f00d ffb1 	bl	34027570 <strerror>
3401960e:	4603      	mov	r3, r0
34019610:	e000      	b.n	34019614 <LL_ATON_Init+0x84>
34019612:	4b7e      	ldr	r3, [pc, #504]	@ (3401980c <LL_ATON_Init+0x27c>)
34019614:	687a      	ldr	r2, [r7, #4]
34019616:	b2d2      	uxtb	r2, r2
34019618:	6879      	ldr	r1, [r7, #4]
3401961a:	0b09      	lsrs	r1, r1, #12
3401961c:	f001 010f 	and.w	r1, r1, #15
34019620:	6878      	ldr	r0, [r7, #4]
34019622:	0a00      	lsrs	r0, r0, #8
34019624:	f000 000f 	and.w	r0, r0, #15
34019628:	2400      	movs	r4, #0
3401962a:	9406      	str	r4, [sp, #24]
3401962c:	2405      	movs	r4, #5
3401962e:	9405      	str	r4, [sp, #20]
34019630:	2401      	movs	r4, #1
34019632:	9404      	str	r4, [sp, #16]
34019634:	9003      	str	r0, [sp, #12]
34019636:	9102      	str	r1, [sp, #8]
34019638:	9201      	str	r2, [sp, #4]
3401963a:	4a75      	ldr	r2, [pc, #468]	@ (34019810 <LL_ATON_Init+0x280>)
3401963c:	9200      	str	r2, [sp, #0]
3401963e:	22c9      	movs	r2, #201	@ 0xc9
34019640:	4974      	ldr	r1, [pc, #464]	@ (34019814 <LL_ATON_Init+0x284>)
34019642:	4875      	ldr	r0, [pc, #468]	@ (34019818 <LL_ATON_Init+0x288>)
34019644:	f00d fb1e 	bl	34026c84 <iprintf>
34019648:	4b74      	ldr	r3, [pc, #464]	@ (3401981c <LL_ATON_Init+0x28c>)
3401964a:	4a75      	ldr	r2, [pc, #468]	@ (34019820 <LL_ATON_Init+0x290>)
3401964c:	21c9      	movs	r1, #201	@ 0xc9
3401964e:	4871      	ldr	r0, [pc, #452]	@ (34019814 <LL_ATON_Init+0x284>)
34019650:	f00c fb8a 	bl	34025d68 <__assert_func>

#ifdef ATON_CONVACC_NUM
  ASSERT_UNITS_VERS_W_MSG(CONVACC, t);
34019654:	4b73      	ldr	r3, [pc, #460]	@ (34019824 <LL_ATON_Init+0x294>)
34019656:	681b      	ldr	r3, [r3, #0]
34019658:	607b      	str	r3, [r7, #4]
3401965a:	687b      	ldr	r3, [r7, #4]
3401965c:	2b00      	cmp	r3, #0
3401965e:	d0f9      	beq.n	34019654 <LL_ATON_Init+0xc4>
34019660:	687b      	ldr	r3, [r7, #4]
34019662:	b2db      	uxtb	r3, r3
34019664:	2b17      	cmp	r3, #23
34019666:	d10b      	bne.n	34019680 <LL_ATON_Init+0xf0>
34019668:	687b      	ldr	r3, [r7, #4]
3401966a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401966e:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
34019672:	d105      	bne.n	34019680 <LL_ATON_Init+0xf0>
34019674:	687b      	ldr	r3, [r7, #4]
34019676:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401967a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401967e:	d02f      	beq.n	340196e0 <LL_ATON_Init+0x150>
34019680:	f00d ffdc 	bl	3402763c <__errno>
34019684:	4603      	mov	r3, r0
34019686:	681b      	ldr	r3, [r3, #0]
34019688:	2b00      	cmp	r3, #0
3401968a:	d008      	beq.n	3401969e <LL_ATON_Init+0x10e>
3401968c:	f00d ffd6 	bl	3402763c <__errno>
34019690:	4603      	mov	r3, r0
34019692:	681b      	ldr	r3, [r3, #0]
34019694:	4618      	mov	r0, r3
34019696:	f00d ff6b 	bl	34027570 <strerror>
3401969a:	4603      	mov	r3, r0
3401969c:	e000      	b.n	340196a0 <LL_ATON_Init+0x110>
3401969e:	4b5b      	ldr	r3, [pc, #364]	@ (3401980c <LL_ATON_Init+0x27c>)
340196a0:	687a      	ldr	r2, [r7, #4]
340196a2:	b2d2      	uxtb	r2, r2
340196a4:	6879      	ldr	r1, [r7, #4]
340196a6:	0b09      	lsrs	r1, r1, #12
340196a8:	f001 010f 	and.w	r1, r1, #15
340196ac:	6878      	ldr	r0, [r7, #4]
340196ae:	0a00      	lsrs	r0, r0, #8
340196b0:	f000 000f 	and.w	r0, r0, #15
340196b4:	2401      	movs	r4, #1
340196b6:	9406      	str	r4, [sp, #24]
340196b8:	2405      	movs	r4, #5
340196ba:	9405      	str	r4, [sp, #20]
340196bc:	2417      	movs	r4, #23
340196be:	9404      	str	r4, [sp, #16]
340196c0:	9003      	str	r0, [sp, #12]
340196c2:	9102      	str	r1, [sp, #8]
340196c4:	9201      	str	r2, [sp, #4]
340196c6:	4a58      	ldr	r2, [pc, #352]	@ (34019828 <LL_ATON_Init+0x298>)
340196c8:	9200      	str	r2, [sp, #0]
340196ca:	22cc      	movs	r2, #204	@ 0xcc
340196cc:	4951      	ldr	r1, [pc, #324]	@ (34019814 <LL_ATON_Init+0x284>)
340196ce:	4852      	ldr	r0, [pc, #328]	@ (34019818 <LL_ATON_Init+0x288>)
340196d0:	f00d fad8 	bl	34026c84 <iprintf>
340196d4:	4b51      	ldr	r3, [pc, #324]	@ (3401981c <LL_ATON_Init+0x28c>)
340196d6:	4a52      	ldr	r2, [pc, #328]	@ (34019820 <LL_ATON_Init+0x290>)
340196d8:	21cc      	movs	r1, #204	@ 0xcc
340196da:	484e      	ldr	r0, [pc, #312]	@ (34019814 <LL_ATON_Init+0x284>)
340196dc:	f00c fb44 	bl	34025d68 <__assert_func>
#endif

#ifdef ATON_POOL_NUM
  ASSERT_UNITS_VERS_W_MSG(POOL, t);
340196e0:	4b52      	ldr	r3, [pc, #328]	@ (3401982c <LL_ATON_Init+0x29c>)
340196e2:	681b      	ldr	r3, [r3, #0]
340196e4:	607b      	str	r3, [r7, #4]
340196e6:	687b      	ldr	r3, [r7, #4]
340196e8:	2b00      	cmp	r3, #0
340196ea:	d0f9      	beq.n	340196e0 <LL_ATON_Init+0x150>
340196ec:	687b      	ldr	r3, [r7, #4]
340196ee:	b2db      	uxtb	r3, r3
340196f0:	2b1c      	cmp	r3, #28
340196f2:	d10b      	bne.n	3401970c <LL_ATON_Init+0x17c>
340196f4:	687b      	ldr	r3, [r7, #4]
340196f6:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340196fa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340196fe:	d105      	bne.n	3401970c <LL_ATON_Init+0x17c>
34019700:	687b      	ldr	r3, [r7, #4]
34019702:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019706:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401970a:	d02f      	beq.n	3401976c <LL_ATON_Init+0x1dc>
3401970c:	f00d ff96 	bl	3402763c <__errno>
34019710:	4603      	mov	r3, r0
34019712:	681b      	ldr	r3, [r3, #0]
34019714:	2b00      	cmp	r3, #0
34019716:	d008      	beq.n	3401972a <LL_ATON_Init+0x19a>
34019718:	f00d ff90 	bl	3402763c <__errno>
3401971c:	4603      	mov	r3, r0
3401971e:	681b      	ldr	r3, [r3, #0]
34019720:	4618      	mov	r0, r3
34019722:	f00d ff25 	bl	34027570 <strerror>
34019726:	4603      	mov	r3, r0
34019728:	e000      	b.n	3401972c <LL_ATON_Init+0x19c>
3401972a:	4b38      	ldr	r3, [pc, #224]	@ (3401980c <LL_ATON_Init+0x27c>)
3401972c:	687a      	ldr	r2, [r7, #4]
3401972e:	b2d2      	uxtb	r2, r2
34019730:	6879      	ldr	r1, [r7, #4]
34019732:	0b09      	lsrs	r1, r1, #12
34019734:	f001 010f 	and.w	r1, r1, #15
34019738:	6878      	ldr	r0, [r7, #4]
3401973a:	0a00      	lsrs	r0, r0, #8
3401973c:	f000 000f 	and.w	r0, r0, #15
34019740:	2401      	movs	r4, #1
34019742:	9406      	str	r4, [sp, #24]
34019744:	2401      	movs	r4, #1
34019746:	9405      	str	r4, [sp, #20]
34019748:	241c      	movs	r4, #28
3401974a:	9404      	str	r4, [sp, #16]
3401974c:	9003      	str	r0, [sp, #12]
3401974e:	9102      	str	r1, [sp, #8]
34019750:	9201      	str	r2, [sp, #4]
34019752:	4a37      	ldr	r2, [pc, #220]	@ (34019830 <LL_ATON_Init+0x2a0>)
34019754:	9200      	str	r2, [sp, #0]
34019756:	22d0      	movs	r2, #208	@ 0xd0
34019758:	492e      	ldr	r1, [pc, #184]	@ (34019814 <LL_ATON_Init+0x284>)
3401975a:	482f      	ldr	r0, [pc, #188]	@ (34019818 <LL_ATON_Init+0x288>)
3401975c:	f00d fa92 	bl	34026c84 <iprintf>
34019760:	4b2e      	ldr	r3, [pc, #184]	@ (3401981c <LL_ATON_Init+0x28c>)
34019762:	4a2f      	ldr	r2, [pc, #188]	@ (34019820 <LL_ATON_Init+0x290>)
34019764:	21d0      	movs	r1, #208	@ 0xd0
34019766:	482b      	ldr	r0, [pc, #172]	@ (34019814 <LL_ATON_Init+0x284>)
34019768:	f00c fafe 	bl	34025d68 <__assert_func>
#endif

#ifdef ATON_ARITH_NUM
  ASSERT_UNITS_VERS_W_MSG(ARITH, t);
3401976c:	4b31      	ldr	r3, [pc, #196]	@ (34019834 <LL_ATON_Init+0x2a4>)
3401976e:	681b      	ldr	r3, [r3, #0]
34019770:	607b      	str	r3, [r7, #4]
34019772:	687b      	ldr	r3, [r7, #4]
34019774:	2b00      	cmp	r3, #0
34019776:	d0f9      	beq.n	3401976c <LL_ATON_Init+0x1dc>
34019778:	687b      	ldr	r3, [r7, #4]
3401977a:	b2db      	uxtb	r3, r3
3401977c:	2b1a      	cmp	r3, #26
3401977e:	d10a      	bne.n	34019796 <LL_ATON_Init+0x206>
34019780:	687b      	ldr	r3, [r7, #4]
34019782:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019786:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401978a:	d104      	bne.n	34019796 <LL_ATON_Init+0x206>
3401978c:	687b      	ldr	r3, [r7, #4]
3401978e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019792:	2b00      	cmp	r3, #0
34019794:	d052      	beq.n	3401983c <LL_ATON_Init+0x2ac>
34019796:	f00d ff51 	bl	3402763c <__errno>
3401979a:	4603      	mov	r3, r0
3401979c:	681b      	ldr	r3, [r3, #0]
3401979e:	2b00      	cmp	r3, #0
340197a0:	d008      	beq.n	340197b4 <LL_ATON_Init+0x224>
340197a2:	f00d ff4b 	bl	3402763c <__errno>
340197a6:	4603      	mov	r3, r0
340197a8:	681b      	ldr	r3, [r3, #0]
340197aa:	4618      	mov	r0, r3
340197ac:	f00d fee0 	bl	34027570 <strerror>
340197b0:	4603      	mov	r3, r0
340197b2:	e000      	b.n	340197b6 <LL_ATON_Init+0x226>
340197b4:	4b15      	ldr	r3, [pc, #84]	@ (3401980c <LL_ATON_Init+0x27c>)
340197b6:	687a      	ldr	r2, [r7, #4]
340197b8:	b2d2      	uxtb	r2, r2
340197ba:	6879      	ldr	r1, [r7, #4]
340197bc:	0b09      	lsrs	r1, r1, #12
340197be:	f001 010f 	and.w	r1, r1, #15
340197c2:	6878      	ldr	r0, [r7, #4]
340197c4:	0a00      	lsrs	r0, r0, #8
340197c6:	f000 000f 	and.w	r0, r0, #15
340197ca:	2400      	movs	r4, #0
340197cc:	9406      	str	r4, [sp, #24]
340197ce:	2401      	movs	r4, #1
340197d0:	9405      	str	r4, [sp, #20]
340197d2:	241a      	movs	r4, #26
340197d4:	9404      	str	r4, [sp, #16]
340197d6:	9003      	str	r0, [sp, #12]
340197d8:	9102      	str	r1, [sp, #8]
340197da:	9201      	str	r2, [sp, #4]
340197dc:	4a16      	ldr	r2, [pc, #88]	@ (34019838 <LL_ATON_Init+0x2a8>)
340197de:	9200      	str	r2, [sp, #0]
340197e0:	22d4      	movs	r2, #212	@ 0xd4
340197e2:	490c      	ldr	r1, [pc, #48]	@ (34019814 <LL_ATON_Init+0x284>)
340197e4:	480c      	ldr	r0, [pc, #48]	@ (34019818 <LL_ATON_Init+0x288>)
340197e6:	f00d fa4d 	bl	34026c84 <iprintf>
340197ea:	4b0c      	ldr	r3, [pc, #48]	@ (3401981c <LL_ATON_Init+0x28c>)
340197ec:	4a0c      	ldr	r2, [pc, #48]	@ (34019820 <LL_ATON_Init+0x290>)
340197ee:	21d4      	movs	r1, #212	@ 0xd4
340197f0:	4808      	ldr	r0, [pc, #32]	@ (34019814 <LL_ATON_Init+0x284>)
340197f2:	f00c fab9 	bl	34025d68 <__assert_func>
340197f6:	bf00      	nop
340197f8:	580e0000 	.word	0x580e0000
340197fc:	580e0008 	.word	0x580e0008
34019800:	580e000c 	.word	0x580e000c
34019804:	580e0010 	.word	0x580e0010
34019808:	580e5004 	.word	0x580e5004
3401980c:	3402a9fc 	.word	0x3402a9fc
34019810:	3402aa68 	.word	0x3402aa68
34019814:	3402a8ec 	.word	0x3402a8ec
34019818:	3402aa04 	.word	0x3402aa04
3401981c:	3402aa70 	.word	0x3402aa70
34019820:	3402be80 	.word	0x3402be80
34019824:	580ef004 	.word	0x580ef004
34019828:	3402aa74 	.word	0x3402aa74
3401982c:	580fb004 	.word	0x580fb004
34019830:	3402aa7c 	.word	0x3402aa7c
34019834:	580f7004 	.word	0x580f7004
34019838:	3402aa84 	.word	0x3402aa84
#endif

#ifdef ATON_ACTIV_NUM
  ASSERT_UNITS_VERS_W_MSG(ACTIV, t);
3401983c:	4b9e      	ldr	r3, [pc, #632]	@ (34019ab8 <LL_ATON_Init+0x528>)
3401983e:	681b      	ldr	r3, [r3, #0]
34019840:	607b      	str	r3, [r7, #4]
34019842:	687b      	ldr	r3, [r7, #4]
34019844:	2b00      	cmp	r3, #0
34019846:	d0f9      	beq.n	3401983c <LL_ATON_Init+0x2ac>
34019848:	687b      	ldr	r3, [r7, #4]
3401984a:	b2db      	uxtb	r3, r3
3401984c:	2b1b      	cmp	r3, #27
3401984e:	d10b      	bne.n	34019868 <LL_ATON_Init+0x2d8>
34019850:	687b      	ldr	r3, [r7, #4]
34019852:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019856:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
3401985a:	d105      	bne.n	34019868 <LL_ATON_Init+0x2d8>
3401985c:	687b      	ldr	r3, [r7, #4]
3401985e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019862:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34019866:	d02f      	beq.n	340198c8 <LL_ATON_Init+0x338>
34019868:	f00d fee8 	bl	3402763c <__errno>
3401986c:	4603      	mov	r3, r0
3401986e:	681b      	ldr	r3, [r3, #0]
34019870:	2b00      	cmp	r3, #0
34019872:	d008      	beq.n	34019886 <LL_ATON_Init+0x2f6>
34019874:	f00d fee2 	bl	3402763c <__errno>
34019878:	4603      	mov	r3, r0
3401987a:	681b      	ldr	r3, [r3, #0]
3401987c:	4618      	mov	r0, r3
3401987e:	f00d fe77 	bl	34027570 <strerror>
34019882:	4603      	mov	r3, r0
34019884:	e000      	b.n	34019888 <LL_ATON_Init+0x2f8>
34019886:	4b8d      	ldr	r3, [pc, #564]	@ (34019abc <LL_ATON_Init+0x52c>)
34019888:	687a      	ldr	r2, [r7, #4]
3401988a:	b2d2      	uxtb	r2, r2
3401988c:	6879      	ldr	r1, [r7, #4]
3401988e:	0b09      	lsrs	r1, r1, #12
34019890:	f001 010f 	and.w	r1, r1, #15
34019894:	6878      	ldr	r0, [r7, #4]
34019896:	0a00      	lsrs	r0, r0, #8
34019898:	f000 000f 	and.w	r0, r0, #15
3401989c:	2401      	movs	r4, #1
3401989e:	9406      	str	r4, [sp, #24]
340198a0:	2401      	movs	r4, #1
340198a2:	9405      	str	r4, [sp, #20]
340198a4:	241b      	movs	r4, #27
340198a6:	9404      	str	r4, [sp, #16]
340198a8:	9003      	str	r0, [sp, #12]
340198aa:	9102      	str	r1, [sp, #8]
340198ac:	9201      	str	r2, [sp, #4]
340198ae:	4a84      	ldr	r2, [pc, #528]	@ (34019ac0 <LL_ATON_Init+0x530>)
340198b0:	9200      	str	r2, [sp, #0]
340198b2:	22d8      	movs	r2, #216	@ 0xd8
340198b4:	4983      	ldr	r1, [pc, #524]	@ (34019ac4 <LL_ATON_Init+0x534>)
340198b6:	4884      	ldr	r0, [pc, #528]	@ (34019ac8 <LL_ATON_Init+0x538>)
340198b8:	f00d f9e4 	bl	34026c84 <iprintf>
340198bc:	4b83      	ldr	r3, [pc, #524]	@ (34019acc <LL_ATON_Init+0x53c>)
340198be:	4a84      	ldr	r2, [pc, #528]	@ (34019ad0 <LL_ATON_Init+0x540>)
340198c0:	21d8      	movs	r1, #216	@ 0xd8
340198c2:	4880      	ldr	r0, [pc, #512]	@ (34019ac4 <LL_ATON_Init+0x534>)
340198c4:	f00c fa50 	bl	34025d68 <__assert_func>
#endif

#ifdef ATON_DECUN_NUM
  ASSERT_UNITS_VERS_W_MSG(DECUN, t);
340198c8:	4b82      	ldr	r3, [pc, #520]	@ (34019ad4 <LL_ATON_Init+0x544>)
340198ca:	681b      	ldr	r3, [r3, #0]
340198cc:	607b      	str	r3, [r7, #4]
340198ce:	687b      	ldr	r3, [r7, #4]
340198d0:	2b00      	cmp	r3, #0
340198d2:	d0f9      	beq.n	340198c8 <LL_ATON_Init+0x338>
340198d4:	687b      	ldr	r3, [r7, #4]
340198d6:	b2db      	uxtb	r3, r3
340198d8:	2b19      	cmp	r3, #25
340198da:	d10b      	bne.n	340198f4 <LL_ATON_Init+0x364>
340198dc:	687b      	ldr	r3, [r7, #4]
340198de:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340198e2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340198e6:	d105      	bne.n	340198f4 <LL_ATON_Init+0x364>
340198e8:	687b      	ldr	r3, [r7, #4]
340198ea:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340198ee:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
340198f2:	d02f      	beq.n	34019954 <LL_ATON_Init+0x3c4>
340198f4:	f00d fea2 	bl	3402763c <__errno>
340198f8:	4603      	mov	r3, r0
340198fa:	681b      	ldr	r3, [r3, #0]
340198fc:	2b00      	cmp	r3, #0
340198fe:	d008      	beq.n	34019912 <LL_ATON_Init+0x382>
34019900:	f00d fe9c 	bl	3402763c <__errno>
34019904:	4603      	mov	r3, r0
34019906:	681b      	ldr	r3, [r3, #0]
34019908:	4618      	mov	r0, r3
3401990a:	f00d fe31 	bl	34027570 <strerror>
3401990e:	4603      	mov	r3, r0
34019910:	e000      	b.n	34019914 <LL_ATON_Init+0x384>
34019912:	4b6a      	ldr	r3, [pc, #424]	@ (34019abc <LL_ATON_Init+0x52c>)
34019914:	687a      	ldr	r2, [r7, #4]
34019916:	b2d2      	uxtb	r2, r2
34019918:	6879      	ldr	r1, [r7, #4]
3401991a:	0b09      	lsrs	r1, r1, #12
3401991c:	f001 010f 	and.w	r1, r1, #15
34019920:	6878      	ldr	r0, [r7, #4]
34019922:	0a00      	lsrs	r0, r0, #8
34019924:	f000 000f 	and.w	r0, r0, #15
34019928:	240a      	movs	r4, #10
3401992a:	9406      	str	r4, [sp, #24]
3401992c:	2401      	movs	r4, #1
3401992e:	9405      	str	r4, [sp, #20]
34019930:	2419      	movs	r4, #25
34019932:	9404      	str	r4, [sp, #16]
34019934:	9003      	str	r0, [sp, #12]
34019936:	9102      	str	r1, [sp, #8]
34019938:	9201      	str	r2, [sp, #4]
3401993a:	4a67      	ldr	r2, [pc, #412]	@ (34019ad8 <LL_ATON_Init+0x548>)
3401993c:	9200      	str	r2, [sp, #0]
3401993e:	22dc      	movs	r2, #220	@ 0xdc
34019940:	4960      	ldr	r1, [pc, #384]	@ (34019ac4 <LL_ATON_Init+0x534>)
34019942:	4861      	ldr	r0, [pc, #388]	@ (34019ac8 <LL_ATON_Init+0x538>)
34019944:	f00d f99e 	bl	34026c84 <iprintf>
34019948:	4b60      	ldr	r3, [pc, #384]	@ (34019acc <LL_ATON_Init+0x53c>)
3401994a:	4a61      	ldr	r2, [pc, #388]	@ (34019ad0 <LL_ATON_Init+0x540>)
3401994c:	21dc      	movs	r1, #220	@ 0xdc
3401994e:	485d      	ldr	r0, [pc, #372]	@ (34019ac4 <LL_ATON_Init+0x534>)
34019950:	f00c fa0a 	bl	34025d68 <__assert_func>
#endif

#ifdef ATON_EPOCHCTRL_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(EPOCHCTRL, t);
34019954:	4b61      	ldr	r3, [pc, #388]	@ (34019adc <LL_ATON_Init+0x54c>)
34019956:	681b      	ldr	r3, [r3, #0]
34019958:	607b      	str	r3, [r7, #4]
3401995a:	687b      	ldr	r3, [r7, #4]
3401995c:	2b00      	cmp	r3, #0
3401995e:	d0f9      	beq.n	34019954 <LL_ATON_Init+0x3c4>
34019960:	687b      	ldr	r3, [r7, #4]
34019962:	b2db      	uxtb	r3, r3
34019964:	2b21      	cmp	r3, #33	@ 0x21
34019966:	d10b      	bne.n	34019980 <LL_ATON_Init+0x3f0>
34019968:	687b      	ldr	r3, [r7, #4]
3401996a:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
3401996e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34019972:	d105      	bne.n	34019980 <LL_ATON_Init+0x3f0>
34019974:	687b      	ldr	r3, [r7, #4]
34019976:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
3401997a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3401997e:	d02f      	beq.n	340199e0 <LL_ATON_Init+0x450>
34019980:	f00d fe5c 	bl	3402763c <__errno>
34019984:	4603      	mov	r3, r0
34019986:	681b      	ldr	r3, [r3, #0]
34019988:	2b00      	cmp	r3, #0
3401998a:	d008      	beq.n	3401999e <LL_ATON_Init+0x40e>
3401998c:	f00d fe56 	bl	3402763c <__errno>
34019990:	4603      	mov	r3, r0
34019992:	681b      	ldr	r3, [r3, #0]
34019994:	4618      	mov	r0, r3
34019996:	f00d fdeb 	bl	34027570 <strerror>
3401999a:	4603      	mov	r3, r0
3401999c:	e000      	b.n	340199a0 <LL_ATON_Init+0x410>
3401999e:	4b47      	ldr	r3, [pc, #284]	@ (34019abc <LL_ATON_Init+0x52c>)
340199a0:	687a      	ldr	r2, [r7, #4]
340199a2:	b2d2      	uxtb	r2, r2
340199a4:	6879      	ldr	r1, [r7, #4]
340199a6:	0b09      	lsrs	r1, r1, #12
340199a8:	f001 010f 	and.w	r1, r1, #15
340199ac:	6878      	ldr	r0, [r7, #4]
340199ae:	0a00      	lsrs	r0, r0, #8
340199b0:	f000 000f 	and.w	r0, r0, #15
340199b4:	2401      	movs	r4, #1
340199b6:	9406      	str	r4, [sp, #24]
340199b8:	2401      	movs	r4, #1
340199ba:	9405      	str	r4, [sp, #20]
340199bc:	2421      	movs	r4, #33	@ 0x21
340199be:	9404      	str	r4, [sp, #16]
340199c0:	9003      	str	r0, [sp, #12]
340199c2:	9102      	str	r1, [sp, #8]
340199c4:	9201      	str	r2, [sp, #4]
340199c6:	4a46      	ldr	r2, [pc, #280]	@ (34019ae0 <LL_ATON_Init+0x550>)
340199c8:	9200      	str	r2, [sp, #0]
340199ca:	22e0      	movs	r2, #224	@ 0xe0
340199cc:	493d      	ldr	r1, [pc, #244]	@ (34019ac4 <LL_ATON_Init+0x534>)
340199ce:	483e      	ldr	r0, [pc, #248]	@ (34019ac8 <LL_ATON_Init+0x538>)
340199d0:	f00d f958 	bl	34026c84 <iprintf>
340199d4:	4b3d      	ldr	r3, [pc, #244]	@ (34019acc <LL_ATON_Init+0x53c>)
340199d6:	4a3e      	ldr	r2, [pc, #248]	@ (34019ad0 <LL_ATON_Init+0x540>)
340199d8:	21e0      	movs	r1, #224	@ 0xe0
340199da:	483a      	ldr	r0, [pc, #232]	@ (34019ac4 <LL_ATON_Init+0x534>)
340199dc:	f00c f9c4 	bl	34025d68 <__assert_func>
#endif

#ifdef ATON_RECBUF_VERSION_TYPE_DT
  ASSERT_UNITS_VERS_W_MSG(RECBUF, t);
340199e0:	4b40      	ldr	r3, [pc, #256]	@ (34019ae4 <LL_ATON_Init+0x554>)
340199e2:	681b      	ldr	r3, [r3, #0]
340199e4:	607b      	str	r3, [r7, #4]
340199e6:	687b      	ldr	r3, [r7, #4]
340199e8:	2b00      	cmp	r3, #0
340199ea:	d0f9      	beq.n	340199e0 <LL_ATON_Init+0x450>
340199ec:	687b      	ldr	r3, [r7, #4]
340199ee:	b2db      	uxtb	r3, r3
340199f0:	2b20      	cmp	r3, #32
340199f2:	d10b      	bne.n	34019a0c <LL_ATON_Init+0x47c>
340199f4:	687b      	ldr	r3, [r7, #4]
340199f6:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
340199fa:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
340199fe:	d105      	bne.n	34019a0c <LL_ATON_Init+0x47c>
34019a00:	687b      	ldr	r3, [r7, #4]
34019a02:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019a06:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34019a0a:	d02f      	beq.n	34019a6c <LL_ATON_Init+0x4dc>
34019a0c:	f00d fe16 	bl	3402763c <__errno>
34019a10:	4603      	mov	r3, r0
34019a12:	681b      	ldr	r3, [r3, #0]
34019a14:	2b00      	cmp	r3, #0
34019a16:	d008      	beq.n	34019a2a <LL_ATON_Init+0x49a>
34019a18:	f00d fe10 	bl	3402763c <__errno>
34019a1c:	4603      	mov	r3, r0
34019a1e:	681b      	ldr	r3, [r3, #0]
34019a20:	4618      	mov	r0, r3
34019a22:	f00d fda5 	bl	34027570 <strerror>
34019a26:	4603      	mov	r3, r0
34019a28:	e000      	b.n	34019a2c <LL_ATON_Init+0x49c>
34019a2a:	4b24      	ldr	r3, [pc, #144]	@ (34019abc <LL_ATON_Init+0x52c>)
34019a2c:	687a      	ldr	r2, [r7, #4]
34019a2e:	b2d2      	uxtb	r2, r2
34019a30:	6879      	ldr	r1, [r7, #4]
34019a32:	0b09      	lsrs	r1, r1, #12
34019a34:	f001 010f 	and.w	r1, r1, #15
34019a38:	6878      	ldr	r0, [r7, #4]
34019a3a:	0a00      	lsrs	r0, r0, #8
34019a3c:	f000 000f 	and.w	r0, r0, #15
34019a40:	2402      	movs	r4, #2
34019a42:	9406      	str	r4, [sp, #24]
34019a44:	2403      	movs	r4, #3
34019a46:	9405      	str	r4, [sp, #20]
34019a48:	2420      	movs	r4, #32
34019a4a:	9404      	str	r4, [sp, #16]
34019a4c:	9003      	str	r0, [sp, #12]
34019a4e:	9102      	str	r1, [sp, #8]
34019a50:	9201      	str	r2, [sp, #4]
34019a52:	4a25      	ldr	r2, [pc, #148]	@ (34019ae8 <LL_ATON_Init+0x558>)
34019a54:	9200      	str	r2, [sp, #0]
34019a56:	22e4      	movs	r2, #228	@ 0xe4
34019a58:	491a      	ldr	r1, [pc, #104]	@ (34019ac4 <LL_ATON_Init+0x534>)
34019a5a:	481b      	ldr	r0, [pc, #108]	@ (34019ac8 <LL_ATON_Init+0x538>)
34019a5c:	f00d f912 	bl	34026c84 <iprintf>
34019a60:	4b1a      	ldr	r3, [pc, #104]	@ (34019acc <LL_ATON_Init+0x53c>)
34019a62:	4a1b      	ldr	r2, [pc, #108]	@ (34019ad0 <LL_ATON_Init+0x540>)
34019a64:	21e4      	movs	r1, #228	@ 0xe4
34019a66:	4817      	ldr	r0, [pc, #92]	@ (34019ac4 <LL_ATON_Init+0x534>)
34019a68:	f00c f97e 	bl	34025d68 <__assert_func>

#ifdef ATON_IMC_NUM
  ASSERT_UNITS_VERS_W_MSG(IMC, t);
#endif

  ASSERT_UNITS_VERS_W_MSG(CLKCTRL, t);
34019a6c:	4b1f      	ldr	r3, [pc, #124]	@ (34019aec <LL_ATON_Init+0x55c>)
34019a6e:	681b      	ldr	r3, [r3, #0]
34019a70:	607b      	str	r3, [r7, #4]
34019a72:	687b      	ldr	r3, [r7, #4]
34019a74:	2b00      	cmp	r3, #0
34019a76:	d0f9      	beq.n	34019a6c <LL_ATON_Init+0x4dc>
34019a78:	687b      	ldr	r3, [r7, #4]
34019a7a:	b2db      	uxtb	r3, r3
34019a7c:	2b1f      	cmp	r3, #31
34019a7e:	d10b      	bne.n	34019a98 <LL_ATON_Init+0x508>
34019a80:	687b      	ldr	r3, [r7, #4]
34019a82:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019a86:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34019a8a:	d105      	bne.n	34019a98 <LL_ATON_Init+0x508>
34019a8c:	687b      	ldr	r3, [r7, #4]
34019a8e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019a92:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34019a96:	d04c      	beq.n	34019b32 <LL_ATON_Init+0x5a2>
34019a98:	f00d fdd0 	bl	3402763c <__errno>
34019a9c:	4603      	mov	r3, r0
34019a9e:	681b      	ldr	r3, [r3, #0]
34019aa0:	2b00      	cmp	r3, #0
34019aa2:	d025      	beq.n	34019af0 <LL_ATON_Init+0x560>
34019aa4:	f00d fdca 	bl	3402763c <__errno>
34019aa8:	4603      	mov	r3, r0
34019aaa:	681b      	ldr	r3, [r3, #0]
34019aac:	4618      	mov	r0, r3
34019aae:	f00d fd5f 	bl	34027570 <strerror>
34019ab2:	4603      	mov	r3, r0
34019ab4:	e01d      	b.n	34019af2 <LL_ATON_Init+0x562>
34019ab6:	bf00      	nop
34019ab8:	580f5004 	.word	0x580f5004
34019abc:	3402a9fc 	.word	0x3402a9fc
34019ac0:	3402aa8c 	.word	0x3402aa8c
34019ac4:	3402a8ec 	.word	0x3402a8ec
34019ac8:	3402aa04 	.word	0x3402aa04
34019acc:	3402aa70 	.word	0x3402aa70
34019ad0:	3402be80 	.word	0x3402be80
34019ad4:	580f3004 	.word	0x580f3004
34019ad8:	3402aa94 	.word	0x3402aa94
34019adc:	580fe004 	.word	0x580fe004
34019ae0:	3402aa9c 	.word	0x3402aa9c
34019ae4:	580fd004 	.word	0x580fd004
34019ae8:	3402aaa8 	.word	0x3402aaa8
34019aec:	580e0004 	.word	0x580e0004
34019af0:	4b85      	ldr	r3, [pc, #532]	@ (34019d08 <LL_ATON_Init+0x778>)
34019af2:	687a      	ldr	r2, [r7, #4]
34019af4:	b2d2      	uxtb	r2, r2
34019af6:	6879      	ldr	r1, [r7, #4]
34019af8:	0b09      	lsrs	r1, r1, #12
34019afa:	f001 010f 	and.w	r1, r1, #15
34019afe:	6878      	ldr	r0, [r7, #4]
34019b00:	0a00      	lsrs	r0, r0, #8
34019b02:	f000 000f 	and.w	r0, r0, #15
34019b06:	2402      	movs	r4, #2
34019b08:	9406      	str	r4, [sp, #24]
34019b0a:	2401      	movs	r4, #1
34019b0c:	9405      	str	r4, [sp, #20]
34019b0e:	241f      	movs	r4, #31
34019b10:	9404      	str	r4, [sp, #16]
34019b12:	9003      	str	r0, [sp, #12]
34019b14:	9102      	str	r1, [sp, #8]
34019b16:	9201      	str	r2, [sp, #4]
34019b18:	4a7c      	ldr	r2, [pc, #496]	@ (34019d0c <LL_ATON_Init+0x77c>)
34019b1a:	9200      	str	r2, [sp, #0]
34019b1c:	22f7      	movs	r2, #247	@ 0xf7
34019b1e:	497c      	ldr	r1, [pc, #496]	@ (34019d10 <LL_ATON_Init+0x780>)
34019b20:	487c      	ldr	r0, [pc, #496]	@ (34019d14 <LL_ATON_Init+0x784>)
34019b22:	f00d f8af 	bl	34026c84 <iprintf>
34019b26:	4b7c      	ldr	r3, [pc, #496]	@ (34019d18 <LL_ATON_Init+0x788>)
34019b28:	4a7c      	ldr	r2, [pc, #496]	@ (34019d1c <LL_ATON_Init+0x78c>)
34019b2a:	21f7      	movs	r1, #247	@ 0xf7
34019b2c:	4878      	ldr	r0, [pc, #480]	@ (34019d10 <LL_ATON_Init+0x780>)
34019b2e:	f00c f91b 	bl	34025d68 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(INTCTRL, t);
34019b32:	4b7b      	ldr	r3, [pc, #492]	@ (34019d20 <LL_ATON_Init+0x790>)
34019b34:	681b      	ldr	r3, [r3, #0]
34019b36:	607b      	str	r3, [r7, #4]
34019b38:	687b      	ldr	r3, [r7, #4]
34019b3a:	2b00      	cmp	r3, #0
34019b3c:	d0f9      	beq.n	34019b32 <LL_ATON_Init+0x5a2>
34019b3e:	687b      	ldr	r3, [r7, #4]
34019b40:	b2db      	uxtb	r3, r3
34019b42:	2b1e      	cmp	r3, #30
34019b44:	d10b      	bne.n	34019b5e <LL_ATON_Init+0x5ce>
34019b46:	687b      	ldr	r3, [r7, #4]
34019b48:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019b4c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34019b50:	d105      	bne.n	34019b5e <LL_ATON_Init+0x5ce>
34019b52:	687b      	ldr	r3, [r7, #4]
34019b54:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019b58:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34019b5c:	d02f      	beq.n	34019bbe <LL_ATON_Init+0x62e>
34019b5e:	f00d fd6d 	bl	3402763c <__errno>
34019b62:	4603      	mov	r3, r0
34019b64:	681b      	ldr	r3, [r3, #0]
34019b66:	2b00      	cmp	r3, #0
34019b68:	d008      	beq.n	34019b7c <LL_ATON_Init+0x5ec>
34019b6a:	f00d fd67 	bl	3402763c <__errno>
34019b6e:	4603      	mov	r3, r0
34019b70:	681b      	ldr	r3, [r3, #0]
34019b72:	4618      	mov	r0, r3
34019b74:	f00d fcfc 	bl	34027570 <strerror>
34019b78:	4603      	mov	r3, r0
34019b7a:	e000      	b.n	34019b7e <LL_ATON_Init+0x5ee>
34019b7c:	4b62      	ldr	r3, [pc, #392]	@ (34019d08 <LL_ATON_Init+0x778>)
34019b7e:	687a      	ldr	r2, [r7, #4]
34019b80:	b2d2      	uxtb	r2, r2
34019b82:	6879      	ldr	r1, [r7, #4]
34019b84:	0b09      	lsrs	r1, r1, #12
34019b86:	f001 010f 	and.w	r1, r1, #15
34019b8a:	6878      	ldr	r0, [r7, #4]
34019b8c:	0a00      	lsrs	r0, r0, #8
34019b8e:	f000 000f 	and.w	r0, r0, #15
34019b92:	2401      	movs	r4, #1
34019b94:	9406      	str	r4, [sp, #24]
34019b96:	2401      	movs	r4, #1
34019b98:	9405      	str	r4, [sp, #20]
34019b9a:	241e      	movs	r4, #30
34019b9c:	9404      	str	r4, [sp, #16]
34019b9e:	9003      	str	r0, [sp, #12]
34019ba0:	9102      	str	r1, [sp, #8]
34019ba2:	9201      	str	r2, [sp, #4]
34019ba4:	4a5f      	ldr	r2, [pc, #380]	@ (34019d24 <LL_ATON_Init+0x794>)
34019ba6:	9200      	str	r2, [sp, #0]
34019ba8:	22f9      	movs	r2, #249	@ 0xf9
34019baa:	4959      	ldr	r1, [pc, #356]	@ (34019d10 <LL_ATON_Init+0x780>)
34019bac:	4859      	ldr	r0, [pc, #356]	@ (34019d14 <LL_ATON_Init+0x784>)
34019bae:	f00d f869 	bl	34026c84 <iprintf>
34019bb2:	4b59      	ldr	r3, [pc, #356]	@ (34019d18 <LL_ATON_Init+0x788>)
34019bb4:	4a59      	ldr	r2, [pc, #356]	@ (34019d1c <LL_ATON_Init+0x78c>)
34019bb6:	21f9      	movs	r1, #249	@ 0xf9
34019bb8:	4855      	ldr	r0, [pc, #340]	@ (34019d10 <LL_ATON_Init+0x780>)
34019bba:	f00c f8d5 	bl	34025d68 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(STRSWITCH, t);
34019bbe:	4b5a      	ldr	r3, [pc, #360]	@ (34019d28 <LL_ATON_Init+0x798>)
34019bc0:	681b      	ldr	r3, [r3, #0]
34019bc2:	607b      	str	r3, [r7, #4]
34019bc4:	687b      	ldr	r3, [r7, #4]
34019bc6:	2b00      	cmp	r3, #0
34019bc8:	d0f9      	beq.n	34019bbe <LL_ATON_Init+0x62e>
34019bca:	687b      	ldr	r3, [r7, #4]
34019bcc:	b2db      	uxtb	r3, r3
34019bce:	2b00      	cmp	r3, #0
34019bd0:	d10b      	bne.n	34019bea <LL_ATON_Init+0x65a>
34019bd2:	687b      	ldr	r3, [r7, #4]
34019bd4:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019bd8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
34019bdc:	d105      	bne.n	34019bea <LL_ATON_Init+0x65a>
34019bde:	687b      	ldr	r3, [r7, #4]
34019be0:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019be4:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
34019be8:	d02f      	beq.n	34019c4a <LL_ATON_Init+0x6ba>
34019bea:	f00d fd27 	bl	3402763c <__errno>
34019bee:	4603      	mov	r3, r0
34019bf0:	681b      	ldr	r3, [r3, #0]
34019bf2:	2b00      	cmp	r3, #0
34019bf4:	d008      	beq.n	34019c08 <LL_ATON_Init+0x678>
34019bf6:	f00d fd21 	bl	3402763c <__errno>
34019bfa:	4603      	mov	r3, r0
34019bfc:	681b      	ldr	r3, [r3, #0]
34019bfe:	4618      	mov	r0, r3
34019c00:	f00d fcb6 	bl	34027570 <strerror>
34019c04:	4603      	mov	r3, r0
34019c06:	e000      	b.n	34019c0a <LL_ATON_Init+0x67a>
34019c08:	4b3f      	ldr	r3, [pc, #252]	@ (34019d08 <LL_ATON_Init+0x778>)
34019c0a:	687a      	ldr	r2, [r7, #4]
34019c0c:	b2d2      	uxtb	r2, r2
34019c0e:	6879      	ldr	r1, [r7, #4]
34019c10:	0b09      	lsrs	r1, r1, #12
34019c12:	f001 010f 	and.w	r1, r1, #15
34019c16:	6878      	ldr	r0, [r7, #4]
34019c18:	0a00      	lsrs	r0, r0, #8
34019c1a:	f000 000f 	and.w	r0, r0, #15
34019c1e:	2406      	movs	r4, #6
34019c20:	9406      	str	r4, [sp, #24]
34019c22:	2401      	movs	r4, #1
34019c24:	9405      	str	r4, [sp, #20]
34019c26:	2400      	movs	r4, #0
34019c28:	9404      	str	r4, [sp, #16]
34019c2a:	9003      	str	r0, [sp, #12]
34019c2c:	9102      	str	r1, [sp, #8]
34019c2e:	9201      	str	r2, [sp, #4]
34019c30:	4a3e      	ldr	r2, [pc, #248]	@ (34019d2c <LL_ATON_Init+0x79c>)
34019c32:	9200      	str	r2, [sp, #0]
34019c34:	22fb      	movs	r2, #251	@ 0xfb
34019c36:	4936      	ldr	r1, [pc, #216]	@ (34019d10 <LL_ATON_Init+0x780>)
34019c38:	4836      	ldr	r0, [pc, #216]	@ (34019d14 <LL_ATON_Init+0x784>)
34019c3a:	f00d f823 	bl	34026c84 <iprintf>
34019c3e:	4b36      	ldr	r3, [pc, #216]	@ (34019d18 <LL_ATON_Init+0x788>)
34019c40:	4a36      	ldr	r2, [pc, #216]	@ (34019d1c <LL_ATON_Init+0x78c>)
34019c42:	21fb      	movs	r1, #251	@ 0xfb
34019c44:	4832      	ldr	r0, [pc, #200]	@ (34019d10 <LL_ATON_Init+0x780>)
34019c46:	f00c f88f 	bl	34025d68 <__assert_func>

  ASSERT_UNITS_VERS_W_MSG(BUSIF, t);
34019c4a:	4b39      	ldr	r3, [pc, #228]	@ (34019d30 <LL_ATON_Init+0x7a0>)
34019c4c:	681b      	ldr	r3, [r3, #0]
34019c4e:	607b      	str	r3, [r7, #4]
34019c50:	687b      	ldr	r3, [r7, #4]
34019c52:	2b00      	cmp	r3, #0
34019c54:	d0f9      	beq.n	34019c4a <LL_ATON_Init+0x6ba>
34019c56:	687b      	ldr	r3, [r7, #4]
34019c58:	b2db      	uxtb	r3, r3
34019c5a:	2b1d      	cmp	r3, #29
34019c5c:	d10a      	bne.n	34019c74 <LL_ATON_Init+0x6e4>
34019c5e:	687b      	ldr	r3, [r7, #4]
34019c60:	f403 4370 	and.w	r3, r3, #61440	@ 0xf000
34019c64:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
34019c68:	d104      	bne.n	34019c74 <LL_ATON_Init+0x6e4>
34019c6a:	687b      	ldr	r3, [r7, #4]
34019c6c:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34019c70:	2b00      	cmp	r3, #0
34019c72:	d02f      	beq.n	34019cd4 <LL_ATON_Init+0x744>
34019c74:	f00d fce2 	bl	3402763c <__errno>
34019c78:	4603      	mov	r3, r0
34019c7a:	681b      	ldr	r3, [r3, #0]
34019c7c:	2b00      	cmp	r3, #0
34019c7e:	d008      	beq.n	34019c92 <LL_ATON_Init+0x702>
34019c80:	f00d fcdc 	bl	3402763c <__errno>
34019c84:	4603      	mov	r3, r0
34019c86:	681b      	ldr	r3, [r3, #0]
34019c88:	4618      	mov	r0, r3
34019c8a:	f00d fc71 	bl	34027570 <strerror>
34019c8e:	4603      	mov	r3, r0
34019c90:	e000      	b.n	34019c94 <LL_ATON_Init+0x704>
34019c92:	4b1d      	ldr	r3, [pc, #116]	@ (34019d08 <LL_ATON_Init+0x778>)
34019c94:	687a      	ldr	r2, [r7, #4]
34019c96:	b2d2      	uxtb	r2, r2
34019c98:	6879      	ldr	r1, [r7, #4]
34019c9a:	0b09      	lsrs	r1, r1, #12
34019c9c:	f001 010f 	and.w	r1, r1, #15
34019ca0:	6878      	ldr	r0, [r7, #4]
34019ca2:	0a00      	lsrs	r0, r0, #8
34019ca4:	f000 000f 	and.w	r0, r0, #15
34019ca8:	2400      	movs	r4, #0
34019caa:	9406      	str	r4, [sp, #24]
34019cac:	2405      	movs	r4, #5
34019cae:	9405      	str	r4, [sp, #20]
34019cb0:	241d      	movs	r4, #29
34019cb2:	9404      	str	r4, [sp, #16]
34019cb4:	9003      	str	r0, [sp, #12]
34019cb6:	9102      	str	r1, [sp, #8]
34019cb8:	9201      	str	r2, [sp, #4]
34019cba:	4a1e      	ldr	r2, [pc, #120]	@ (34019d34 <LL_ATON_Init+0x7a4>)
34019cbc:	9200      	str	r2, [sp, #0]
34019cbe:	22fd      	movs	r2, #253	@ 0xfd
34019cc0:	4913      	ldr	r1, [pc, #76]	@ (34019d10 <LL_ATON_Init+0x780>)
34019cc2:	4814      	ldr	r0, [pc, #80]	@ (34019d14 <LL_ATON_Init+0x784>)
34019cc4:	f00c ffde 	bl	34026c84 <iprintf>
34019cc8:	4b13      	ldr	r3, [pc, #76]	@ (34019d18 <LL_ATON_Init+0x788>)
34019cca:	4a14      	ldr	r2, [pc, #80]	@ (34019d1c <LL_ATON_Init+0x78c>)
34019ccc:	21fd      	movs	r1, #253	@ 0xfd
34019cce:	4810      	ldr	r0, [pc, #64]	@ (34019d10 <LL_ATON_Init+0x780>)
34019cd0:	f00c f84a 	bl	34025d68 <__assert_func>

  /* Enable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34019cd4:	2300      	movs	r3, #0
34019cd6:	603b      	str	r3, [r7, #0]
34019cd8:	e00a      	b.n	34019cf0 <LL_ATON_Init+0x760>
  {
    ATON_BUSIF_CTRL_SET(i, 1);
34019cda:	683b      	ldr	r3, [r7, #0]
34019cdc:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019ce0:	33e2      	adds	r3, #226	@ 0xe2
34019ce2:	031b      	lsls	r3, r3, #12
34019ce4:	461a      	mov	r2, r3
34019ce6:	2301      	movs	r3, #1
34019ce8:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34019cea:	683b      	ldr	r3, [r7, #0]
34019cec:	3301      	adds	r3, #1
34019cee:	603b      	str	r3, [r7, #0]
34019cf0:	683b      	ldr	r3, [r7, #0]
34019cf2:	2b01      	cmp	r3, #1
34019cf4:	ddf1      	ble.n	34019cda <LL_ATON_Init+0x74a>
  }

  /* Enable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 1);
34019cf6:	4b10      	ldr	r3, [pc, #64]	@ (34019d38 <LL_ATON_Init+0x7a8>)
34019cf8:	2201      	movs	r2, #1
34019cfa:	601a      	str	r2, [r3, #0]

  return 0;
34019cfc:	2300      	movs	r3, #0
}
34019cfe:	4618      	mov	r0, r3
34019d00:	370c      	adds	r7, #12
34019d02:	46bd      	mov	sp, r7
34019d04:	bd90      	pop	{r4, r7, pc}
34019d06:	bf00      	nop
34019d08:	3402a9fc 	.word	0x3402a9fc
34019d0c:	3402aab0 	.word	0x3402aab0
34019d10:	3402a8ec 	.word	0x3402a8ec
34019d14:	3402aa04 	.word	0x3402aa04
34019d18:	3402aa70 	.word	0x3402aa70
34019d1c:	3402be80 	.word	0x3402be80
34019d20:	580e1004 	.word	0x580e1004
34019d24:	3402aab8 	.word	0x3402aab8
34019d28:	580e4004 	.word	0x580e4004
34019d2c:	3402aac0 	.word	0x3402aac0
34019d30:	580e2004 	.word	0x580e2004
34019d34:	3402aacc 	.word	0x3402aacc
34019d38:	580e1000 	.word	0x580e1000

34019d3c <LL_ATON_DeInit>:
/**
 * @brief  ATON global de-initialization. Must be called at the very end
 * @retval Always zero
 */
int LL_ATON_DeInit(void)
{
34019d3c:	b480      	push	{r7}
34019d3e:	b083      	sub	sp, #12
34019d40:	af00      	add	r7, sp, #0
  int i;

  /* Disable Interrupt Controller */
  ATON_INTCTRL_CTRL_SET(0, 0);
34019d42:	4b13      	ldr	r3, [pc, #76]	@ (34019d90 <LL_ATON_DeInit+0x54>)
34019d44:	2200      	movs	r2, #0
34019d46:	601a      	str	r2, [r3, #0]

  /* Disable Bus Interfaces */
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34019d48:	2300      	movs	r3, #0
34019d4a:	607b      	str	r3, [r7, #4]
34019d4c:	e00a      	b.n	34019d64 <LL_ATON_DeInit+0x28>
  {
    ATON_BUSIF_CTRL_SET(i, 0);
34019d4e:	687b      	ldr	r3, [r7, #4]
34019d50:	f503 23b0 	add.w	r3, r3, #360448	@ 0x58000
34019d54:	33e2      	adds	r3, #226	@ 0xe2
34019d56:	031b      	lsls	r3, r3, #12
34019d58:	461a      	mov	r2, r3
34019d5a:	2300      	movs	r3, #0
34019d5c:	6013      	str	r3, [r2, #0]
  for (i = 0; i < ATON_BUSIF_NUM; i++)
34019d5e:	687b      	ldr	r3, [r7, #4]
34019d60:	3301      	adds	r3, #1
34019d62:	607b      	str	r3, [r7, #4]
34019d64:	687b      	ldr	r3, [r7, #4]
34019d66:	2b01      	cmp	r3, #1
34019d68:	ddf1      	ble.n	34019d4e <LL_ATON_DeInit+0x12>
  }

  /* Disable all ATON clocks */
  ATON_CLKCTRL_AGATES0_SET(0, 0);
34019d6a:	4b0a      	ldr	r3, [pc, #40]	@ (34019d94 <LL_ATON_DeInit+0x58>)
34019d6c:	2200      	movs	r2, #0
34019d6e:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_AGATES1_SET(0, 0);
34019d70:	4b09      	ldr	r3, [pc, #36]	@ (34019d98 <LL_ATON_DeInit+0x5c>)
34019d72:	2200      	movs	r2, #0
34019d74:	601a      	str	r2, [r3, #0]
  ATON_CLKCTRL_BGATES_SET(0, 0);
34019d76:	4b09      	ldr	r3, [pc, #36]	@ (34019d9c <LL_ATON_DeInit+0x60>)
34019d78:	2200      	movs	r2, #0
34019d7a:	601a      	str	r2, [r3, #0]
#ifdef ATON_CLKCTRL_BGATES1_OFFSET
  ATON_CLKCTRL_BGATES1_SET(0, 0);
#endif
  ATON_CLKCTRL_CTRL_SET(0, 0);
34019d7c:	4b08      	ldr	r3, [pc, #32]	@ (34019da0 <LL_ATON_DeInit+0x64>)
34019d7e:	2200      	movs	r2, #0
34019d80:	601a      	str	r2, [r3, #0]

  return 0;
34019d82:	2300      	movs	r3, #0
}
34019d84:	4618      	mov	r0, r3
34019d86:	370c      	adds	r7, #12
34019d88:	46bd      	mov	sp, r7
34019d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34019d8e:	4770      	bx	lr
34019d90:	580e1000 	.word	0x580e1000
34019d94:	580e0008 	.word	0x580e0008
34019d98:	580e000c 	.word	0x580e000c
34019d9c:	580e0010 	.word	0x580e0010
34019da0:	580e0000 	.word	0x580e0000

34019da4 <__atonn_getSrcPortID>:
}
#endif

unsigned __atonn_getSrcPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
34019da4:	b590      	push	{r4, r7, lr}
34019da6:	b083      	sub	sp, #12
34019da8:	af00      	add	r7, sp, #0
34019daa:	4604      	mov	r4, r0
34019dac:	4608      	mov	r0, r1
34019dae:	4611      	mov	r1, r2
34019db0:	461a      	mov	r2, r3
34019db2:	4623      	mov	r3, r4
34019db4:	71fb      	strb	r3, [r7, #7]
34019db6:	4603      	mov	r3, r0
34019db8:	71bb      	strb	r3, [r7, #6]
34019dba:	460b      	mov	r3, r1
34019dbc:	717b      	strb	r3, [r7, #5]
34019dbe:	4613      	mov	r3, r2
34019dc0:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
34019dc2:	79bb      	ldrb	r3, [r7, #6]
34019dc4:	2b00      	cmp	r3, #0
34019dc6:	d006      	beq.n	34019dd6 <__atonn_getSrcPortID+0x32>
34019dc8:	4b66      	ldr	r3, [pc, #408]	@ (34019f64 <__atonn_getSrcPortID+0x1c0>)
34019dca:	4a67      	ldr	r2, [pc, #412]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019dcc:	f44f 7150 	mov.w	r1, #832	@ 0x340
34019dd0:	4866      	ldr	r0, [pc, #408]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019dd2:	f00b ffc9 	bl	34025d68 <__assert_func>
  switch (sut)
34019dd6:	79fb      	ldrb	r3, [r7, #7]
34019dd8:	2b02      	cmp	r3, #2
34019dda:	f000 80b6 	beq.w	34019f4a <__atonn_getSrcPortID+0x1a6>
34019dde:	2b02      	cmp	r3, #2
34019de0:	f300 80ba 	bgt.w	34019f58 <__atonn_getSrcPortID+0x1b4>
34019de4:	2b00      	cmp	r3, #0
34019de6:	d003      	beq.n	34019df0 <__atonn_getSrcPortID+0x4c>
34019de8:	2b01      	cmp	r3, #1
34019dea:	f000 80a7 	beq.w	34019f3c <__atonn_getSrcPortID+0x198>
34019dee:	e0b3      	b.n	34019f58 <__atonn_getSrcPortID+0x1b4>
  {
  case STRSWITCH:
    switch (aut)
34019df0:	797b      	ldrb	r3, [r7, #5]
34019df2:	2b06      	cmp	r3, #6
34019df4:	f200 809b 	bhi.w	34019f2e <__atonn_getSrcPortID+0x18a>
34019df8:	a201      	add	r2, pc, #4	@ (adr r2, 34019e00 <__atonn_getSrcPortID+0x5c>)
34019dfa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34019dfe:	bf00      	nop
34019e00:	34019e1d 	.word	0x34019e1d
34019e04:	34019f2f 	.word	0x34019f2f
34019e08:	34019e49 	.word	0x34019e49
34019e0c:	34019e77 	.word	0x34019e77
34019e10:	34019ea5 	.word	0x34019ea5
34019e14:	34019ed3 	.word	0x34019ed3
34019e18:	34019f01 	.word	0x34019f01
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
34019e1c:	7e3b      	ldrb	r3, [r7, #24]
34019e1e:	2b00      	cmp	r3, #0
34019e20:	d006      	beq.n	34019e30 <__atonn_getSrcPortID+0x8c>
34019e22:	4b53      	ldr	r3, [pc, #332]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019e24:	4a50      	ldr	r2, [pc, #320]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e26:	f44f 7152 	mov.w	r1, #840	@ 0x348
34019e2a:	4850      	ldr	r0, [pc, #320]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e2c:	f00b ff9c 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
34019e30:	793b      	ldrb	r3, [r7, #4]
34019e32:	2b09      	cmp	r3, #9
34019e34:	d906      	bls.n	34019e44 <__atonn_getSrcPortID+0xa0>
34019e36:	4b4f      	ldr	r3, [pc, #316]	@ (34019f74 <__atonn_getSrcPortID+0x1d0>)
34019e38:	4a4b      	ldr	r2, [pc, #300]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e3a:	f240 3149 	movw	r1, #841	@ 0x349
34019e3e:	484b      	ldr	r0, [pc, #300]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e40:	f00b ff92 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, STRENG, 0, 0) + au_num;
34019e44:	793b      	ldrb	r3, [r7, #4]
34019e46:	e088      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port == 0);
34019e48:	7e3b      	ldrb	r3, [r7, #24]
34019e4a:	2b00      	cmp	r3, #0
34019e4c:	d006      	beq.n	34019e5c <__atonn_getSrcPortID+0xb8>
34019e4e:	4b48      	ldr	r3, [pc, #288]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019e50:	4a45      	ldr	r2, [pc, #276]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e52:	f240 314f 	movw	r1, #847	@ 0x34f
34019e56:	4845      	ldr	r0, [pc, #276]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e58:	f00b ff86 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
34019e5c:	793b      	ldrb	r3, [r7, #4]
34019e5e:	2b03      	cmp	r3, #3
34019e60:	d906      	bls.n	34019e70 <__atonn_getSrcPortID+0xcc>
34019e62:	4b45      	ldr	r3, [pc, #276]	@ (34019f78 <__atonn_getSrcPortID+0x1d4>)
34019e64:	4a40      	ldr	r2, [pc, #256]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e66:	f44f 7154 	mov.w	r1, #848	@ 0x350
34019e6a:	4840      	ldr	r0, [pc, #256]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e6c:	f00b ff7c 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, CONVACC, 0, 0) + au_num;
34019e70:	793b      	ldrb	r3, [r7, #4]
34019e72:	330a      	adds	r3, #10
34019e74:	e071      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port == 0);
34019e76:	7e3b      	ldrb	r3, [r7, #24]
34019e78:	2b00      	cmp	r3, #0
34019e7a:	d006      	beq.n	34019e8a <__atonn_getSrcPortID+0xe6>
34019e7c:	4b3c      	ldr	r3, [pc, #240]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019e7e:	4a3a      	ldr	r2, [pc, #232]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e80:	f240 3156 	movw	r1, #854	@ 0x356
34019e84:	4839      	ldr	r0, [pc, #228]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e86:	f00b ff6f 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
34019e8a:	793b      	ldrb	r3, [r7, #4]
34019e8c:	2b01      	cmp	r3, #1
34019e8e:	d906      	bls.n	34019e9e <__atonn_getSrcPortID+0xfa>
34019e90:	4b3a      	ldr	r3, [pc, #232]	@ (34019f7c <__atonn_getSrcPortID+0x1d8>)
34019e92:	4a35      	ldr	r2, [pc, #212]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019e94:	f240 3157 	movw	r1, #855	@ 0x357
34019e98:	4834      	ldr	r0, [pc, #208]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019e9a:	f00b ff65 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, DECUN, 0, 0) + au_num;
34019e9e:	793b      	ldrb	r3, [r7, #4]
34019ea0:	330e      	adds	r3, #14
34019ea2:	e05a      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
34019ea4:	7e3b      	ldrb	r3, [r7, #24]
34019ea6:	2b00      	cmp	r3, #0
34019ea8:	d006      	beq.n	34019eb8 <__atonn_getSrcPortID+0x114>
34019eaa:	4b31      	ldr	r3, [pc, #196]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019eac:	4a2e      	ldr	r2, [pc, #184]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019eae:	f240 315d 	movw	r1, #861	@ 0x35d
34019eb2:	482e      	ldr	r0, [pc, #184]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019eb4:	f00b ff58 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
34019eb8:	793b      	ldrb	r3, [r7, #4]
34019eba:	2b01      	cmp	r3, #1
34019ebc:	d906      	bls.n	34019ecc <__atonn_getSrcPortID+0x128>
34019ebe:	4b2f      	ldr	r3, [pc, #188]	@ (34019f7c <__atonn_getSrcPortID+0x1d8>)
34019ec0:	4a29      	ldr	r2, [pc, #164]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019ec2:	f240 315e 	movw	r1, #862	@ 0x35e
34019ec6:	4829      	ldr	r0, [pc, #164]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019ec8:	f00b ff4e 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ACTIV, 0, 0) + au_num;
34019ecc:	793b      	ldrb	r3, [r7, #4]
34019ece:	3310      	adds	r3, #16
34019ed0:	e043      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port == 0);
34019ed2:	7e3b      	ldrb	r3, [r7, #24]
34019ed4:	2b00      	cmp	r3, #0
34019ed6:	d006      	beq.n	34019ee6 <__atonn_getSrcPortID+0x142>
34019ed8:	4b25      	ldr	r3, [pc, #148]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019eda:	4a23      	ldr	r2, [pc, #140]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019edc:	f44f 7159 	mov.w	r1, #868	@ 0x364
34019ee0:	4822      	ldr	r0, [pc, #136]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019ee2:	f00b ff41 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
34019ee6:	793b      	ldrb	r3, [r7, #4]
34019ee8:	2b03      	cmp	r3, #3
34019eea:	d906      	bls.n	34019efa <__atonn_getSrcPortID+0x156>
34019eec:	4b22      	ldr	r3, [pc, #136]	@ (34019f78 <__atonn_getSrcPortID+0x1d4>)
34019eee:	4a1e      	ldr	r2, [pc, #120]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019ef0:	f240 3165 	movw	r1, #869	@ 0x365
34019ef4:	481d      	ldr	r0, [pc, #116]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019ef6:	f00b ff37 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, ARITH, 0, 0) + au_num;
34019efa:	793b      	ldrb	r3, [r7, #4]
34019efc:	3312      	adds	r3, #18
34019efe:	e02c      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
34019f00:	7e3b      	ldrb	r3, [r7, #24]
34019f02:	2b00      	cmp	r3, #0
34019f04:	d006      	beq.n	34019f14 <__atonn_getSrcPortID+0x170>
34019f06:	4b1a      	ldr	r3, [pc, #104]	@ (34019f70 <__atonn_getSrcPortID+0x1cc>)
34019f08:	4a17      	ldr	r2, [pc, #92]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019f0a:	f240 316b 	movw	r1, #875	@ 0x36b
34019f0e:	4817      	ldr	r0, [pc, #92]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019f10:	f00b ff2a 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
34019f14:	793b      	ldrb	r3, [r7, #4]
34019f16:	2b01      	cmp	r3, #1
34019f18:	d906      	bls.n	34019f28 <__atonn_getSrcPortID+0x184>
34019f1a:	4b18      	ldr	r3, [pc, #96]	@ (34019f7c <__atonn_getSrcPortID+0x1d8>)
34019f1c:	4a12      	ldr	r2, [pc, #72]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019f1e:	f44f 715b 	mov.w	r1, #876	@ 0x36c
34019f22:	4812      	ldr	r0, [pc, #72]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019f24:	f00b ff20 	bl	34025d68 <__assert_func>
      return ATONN_CONST_SRCPORT(STRSWITCH, 0, POOL, 0, 0) + au_num;
34019f28:	793b      	ldrb	r3, [r7, #4]
34019f2a:	3316      	adds	r3, #22
34019f2c:	e015      	b.n	34019f5a <__atonn_getSrcPortID+0x1b6>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
34019f2e:	4b14      	ldr	r3, [pc, #80]	@ (34019f80 <__atonn_getSrcPortID+0x1dc>)
34019f30:	4a0d      	ldr	r2, [pc, #52]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019f32:	f240 3171 	movw	r1, #881	@ 0x371
34019f36:	480d      	ldr	r0, [pc, #52]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019f38:	f00b ff16 	bl	34025d68 <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
34019f3c:	4b10      	ldr	r3, [pc, #64]	@ (34019f80 <__atonn_getSrcPortID+0x1dc>)
34019f3e:	4a0a      	ldr	r2, [pc, #40]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019f40:	f240 3177 	movw	r1, #887	@ 0x377
34019f44:	4809      	ldr	r0, [pc, #36]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019f46:	f00b ff0f 	bl	34025d68 <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
34019f4a:	4b0d      	ldr	r3, [pc, #52]	@ (34019f80 <__atonn_getSrcPortID+0x1dc>)
34019f4c:	4a06      	ldr	r2, [pc, #24]	@ (34019f68 <__atonn_getSrcPortID+0x1c4>)
34019f4e:	f240 317b 	movw	r1, #891	@ 0x37b
34019f52:	4806      	ldr	r0, [pc, #24]	@ (34019f6c <__atonn_getSrcPortID+0x1c8>)
34019f54:	f00b ff08 	bl	34025d68 <__assert_func>
    break;
  }
  return 0;
34019f58:	2300      	movs	r3, #0
}
34019f5a:	4618      	mov	r0, r3
34019f5c:	370c      	adds	r7, #12
34019f5e:	46bd      	mov	sp, r7
34019f60:	bd90      	pop	{r4, r7, pc}
34019f62:	bf00      	nop
34019f64:	3402aaec 	.word	0x3402aaec
34019f68:	3402bea8 	.word	0x3402bea8
34019f6c:	3402a8ec 	.word	0x3402a8ec
34019f70:	3402aaf8 	.word	0x3402aaf8
34019f74:	3402ab04 	.word	0x3402ab04
34019f78:	3402ab10 	.word	0x3402ab10
34019f7c:	3402ab1c 	.word	0x3402ab1c
34019f80:	3402aa70 	.word	0x3402aa70

34019f84 <__atonn_getDstPortID>:

unsigned __atonn_getDstPortID(enum SwitchUnitsType sut, unsigned char su_num, enum AccelUnitsType aut,
                              unsigned char au_num, unsigned char port)
{
34019f84:	b590      	push	{r4, r7, lr}
34019f86:	b083      	sub	sp, #12
34019f88:	af00      	add	r7, sp, #0
34019f8a:	4604      	mov	r4, r0
34019f8c:	4608      	mov	r0, r1
34019f8e:	4611      	mov	r1, r2
34019f90:	461a      	mov	r2, r3
34019f92:	4623      	mov	r3, r4
34019f94:	71fb      	strb	r3, [r7, #7]
34019f96:	4603      	mov	r3, r0
34019f98:	71bb      	strb	r3, [r7, #6]
34019f9a:	460b      	mov	r3, r1
34019f9c:	717b      	strb	r3, [r7, #5]
34019f9e:	4613      	mov	r3, r2
34019fa0:	713b      	strb	r3, [r7, #4]
  // FIXME
  LL_ATON_ASSERT(su_num == 0);
34019fa2:	79bb      	ldrb	r3, [r7, #6]
34019fa4:	2b00      	cmp	r3, #0
34019fa6:	d006      	beq.n	34019fb6 <__atonn_getDstPortID+0x32>
34019fa8:	4b6f      	ldr	r3, [pc, #444]	@ (3401a168 <__atonn_getDstPortID+0x1e4>)
34019faa:	4a70      	ldr	r2, [pc, #448]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
34019fac:	f240 3185 	movw	r1, #901	@ 0x385
34019fb0:	486f      	ldr	r0, [pc, #444]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
34019fb2:	f00b fed9 	bl	34025d68 <__assert_func>
  switch (sut)
34019fb6:	79fb      	ldrb	r3, [r7, #7]
34019fb8:	2b02      	cmp	r3, #2
34019fba:	f000 80c8 	beq.w	3401a14e <__atonn_getDstPortID+0x1ca>
34019fbe:	2b02      	cmp	r3, #2
34019fc0:	f300 80cc 	bgt.w	3401a15c <__atonn_getDstPortID+0x1d8>
34019fc4:	2b00      	cmp	r3, #0
34019fc6:	d003      	beq.n	34019fd0 <__atonn_getDstPortID+0x4c>
34019fc8:	2b01      	cmp	r3, #1
34019fca:	f000 80b9 	beq.w	3401a140 <__atonn_getDstPortID+0x1bc>
34019fce:	e0c5      	b.n	3401a15c <__atonn_getDstPortID+0x1d8>
  {
  case STRSWITCH:
    switch (aut)
34019fd0:	797b      	ldrb	r3, [r7, #5]
34019fd2:	2b06      	cmp	r3, #6
34019fd4:	f200 80ad 	bhi.w	3401a132 <__atonn_getDstPortID+0x1ae>
34019fd8:	a201      	add	r2, pc, #4	@ (adr r2, 34019fe0 <__atonn_getDstPortID+0x5c>)
34019fda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34019fde:	bf00      	nop
34019fe0:	34019ffd 	.word	0x34019ffd
34019fe4:	3401a133 	.word	0x3401a133
34019fe8:	3401a02d 	.word	0x3401a02d
34019fec:	3401a067 	.word	0x3401a067
34019ff0:	3401a09d 	.word	0x3401a09d
34019ff4:	3401a0cd 	.word	0x3401a0cd
34019ff8:	3401a103 	.word	0x3401a103
    {
#if defined(ATON_STRENG_NUM)
    case STRENG:
      LL_ATON_ASSERT(port == 0);
34019ffc:	7e3b      	ldrb	r3, [r7, #24]
34019ffe:	2b00      	cmp	r3, #0
3401a000:	d006      	beq.n	3401a010 <__atonn_getDstPortID+0x8c>
3401a002:	4b5c      	ldr	r3, [pc, #368]	@ (3401a174 <__atonn_getDstPortID+0x1f0>)
3401a004:	4a59      	ldr	r2, [pc, #356]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a006:	f240 318d 	movw	r1, #909	@ 0x38d
3401a00a:	4859      	ldr	r0, [pc, #356]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a00c:	f00b feac 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_STRENG_NUM);
3401a010:	793b      	ldrb	r3, [r7, #4]
3401a012:	2b09      	cmp	r3, #9
3401a014:	d906      	bls.n	3401a024 <__atonn_getDstPortID+0xa0>
3401a016:	4b58      	ldr	r3, [pc, #352]	@ (3401a178 <__atonn_getDstPortID+0x1f4>)
3401a018:	4a54      	ldr	r2, [pc, #336]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a01a:	f240 318e 	movw	r1, #910	@ 0x38e
3401a01e:	4854      	ldr	r0, [pc, #336]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a020:	f00b fea2 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, STRENG, 0, 0) + (0x4 * au_num);
3401a024:	793b      	ldrb	r3, [r7, #4]
3401a026:	009b      	lsls	r3, r3, #2
3401a028:	3308      	adds	r3, #8
3401a02a:	e098      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_CONVACC_NUM)
    case CONVACC:
      LL_ATON_ASSERT(port < 3);
3401a02c:	7e3b      	ldrb	r3, [r7, #24]
3401a02e:	2b02      	cmp	r3, #2
3401a030:	d906      	bls.n	3401a040 <__atonn_getDstPortID+0xbc>
3401a032:	4b52      	ldr	r3, [pc, #328]	@ (3401a17c <__atonn_getDstPortID+0x1f8>)
3401a034:	4a4d      	ldr	r2, [pc, #308]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a036:	f44f 7165 	mov.w	r1, #916	@ 0x394
3401a03a:	484d      	ldr	r0, [pc, #308]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a03c:	f00b fe94 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_CONVACC_NUM);
3401a040:	793b      	ldrb	r3, [r7, #4]
3401a042:	2b03      	cmp	r3, #3
3401a044:	d906      	bls.n	3401a054 <__atonn_getDstPortID+0xd0>
3401a046:	4b4e      	ldr	r3, [pc, #312]	@ (3401a180 <__atonn_getDstPortID+0x1fc>)
3401a048:	4a48      	ldr	r2, [pc, #288]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a04a:	f240 3195 	movw	r1, #917	@ 0x395
3401a04e:	4848      	ldr	r0, [pc, #288]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a050:	f00b fe8a 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, CONVACC, 0, 0) + (0x4 * (3 * au_num + port));
3401a054:	793a      	ldrb	r2, [r7, #4]
3401a056:	4613      	mov	r3, r2
3401a058:	005b      	lsls	r3, r3, #1
3401a05a:	441a      	add	r2, r3
3401a05c:	7e3b      	ldrb	r3, [r7, #24]
3401a05e:	4413      	add	r3, r2
3401a060:	009b      	lsls	r3, r3, #2
3401a062:	3330      	adds	r3, #48	@ 0x30
3401a064:	e07b      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_DECUN_NUM)
    case DECUN:
      LL_ATON_ASSERT(port < 2);
3401a066:	7e3b      	ldrb	r3, [r7, #24]
3401a068:	2b01      	cmp	r3, #1
3401a06a:	d906      	bls.n	3401a07a <__atonn_getDstPortID+0xf6>
3401a06c:	4b45      	ldr	r3, [pc, #276]	@ (3401a184 <__atonn_getDstPortID+0x200>)
3401a06e:	4a3f      	ldr	r2, [pc, #252]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a070:	f240 319b 	movw	r1, #923	@ 0x39b
3401a074:	483e      	ldr	r0, [pc, #248]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a076:	f00b fe77 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_DECUN_NUM);
3401a07a:	793b      	ldrb	r3, [r7, #4]
3401a07c:	2b01      	cmp	r3, #1
3401a07e:	d906      	bls.n	3401a08e <__atonn_getDstPortID+0x10a>
3401a080:	4b41      	ldr	r3, [pc, #260]	@ (3401a188 <__atonn_getDstPortID+0x204>)
3401a082:	4a3a      	ldr	r2, [pc, #232]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a084:	f44f 7167 	mov.w	r1, #924	@ 0x39c
3401a088:	4839      	ldr	r0, [pc, #228]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a08a:	f00b fe6d 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, DECUN, 0, 0) + (0x4 * (2 * au_num + port));
3401a08e:	793b      	ldrb	r3, [r7, #4]
3401a090:	005a      	lsls	r2, r3, #1
3401a092:	7e3b      	ldrb	r3, [r7, #24]
3401a094:	4413      	add	r3, r2
3401a096:	009b      	lsls	r3, r3, #2
3401a098:	3360      	adds	r3, #96	@ 0x60
3401a09a:	e060      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ACTIV_NUM)
    case ACTIV:
      LL_ATON_ASSERT(port == 0);
3401a09c:	7e3b      	ldrb	r3, [r7, #24]
3401a09e:	2b00      	cmp	r3, #0
3401a0a0:	d006      	beq.n	3401a0b0 <__atonn_getDstPortID+0x12c>
3401a0a2:	4b34      	ldr	r3, [pc, #208]	@ (3401a174 <__atonn_getDstPortID+0x1f0>)
3401a0a4:	4a31      	ldr	r2, [pc, #196]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a0a6:	f240 31a2 	movw	r1, #930	@ 0x3a2
3401a0aa:	4831      	ldr	r0, [pc, #196]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a0ac:	f00b fe5c 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ACTIV_NUM);
3401a0b0:	793b      	ldrb	r3, [r7, #4]
3401a0b2:	2b01      	cmp	r3, #1
3401a0b4:	d906      	bls.n	3401a0c4 <__atonn_getDstPortID+0x140>
3401a0b6:	4b34      	ldr	r3, [pc, #208]	@ (3401a188 <__atonn_getDstPortID+0x204>)
3401a0b8:	4a2c      	ldr	r2, [pc, #176]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a0ba:	f240 31a3 	movw	r1, #931	@ 0x3a3
3401a0be:	482c      	ldr	r0, [pc, #176]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a0c0:	f00b fe52 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ACTIV, 0, 0) + (0x4 * au_num);
3401a0c4:	793b      	ldrb	r3, [r7, #4]
3401a0c6:	009b      	lsls	r3, r3, #2
3401a0c8:	3370      	adds	r3, #112	@ 0x70
3401a0ca:	e048      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_ARITH_NUM)
    case ARITH:
      LL_ATON_ASSERT(port < 2);
3401a0cc:	7e3b      	ldrb	r3, [r7, #24]
3401a0ce:	2b01      	cmp	r3, #1
3401a0d0:	d906      	bls.n	3401a0e0 <__atonn_getDstPortID+0x15c>
3401a0d2:	4b2c      	ldr	r3, [pc, #176]	@ (3401a184 <__atonn_getDstPortID+0x200>)
3401a0d4:	4a25      	ldr	r2, [pc, #148]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a0d6:	f240 31a9 	movw	r1, #937	@ 0x3a9
3401a0da:	4825      	ldr	r0, [pc, #148]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a0dc:	f00b fe44 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_ARITH_NUM);
3401a0e0:	793b      	ldrb	r3, [r7, #4]
3401a0e2:	2b03      	cmp	r3, #3
3401a0e4:	d906      	bls.n	3401a0f4 <__atonn_getDstPortID+0x170>
3401a0e6:	4b26      	ldr	r3, [pc, #152]	@ (3401a180 <__atonn_getDstPortID+0x1fc>)
3401a0e8:	4a20      	ldr	r2, [pc, #128]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a0ea:	f240 31aa 	movw	r1, #938	@ 0x3aa
3401a0ee:	4820      	ldr	r0, [pc, #128]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a0f0:	f00b fe3a 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, ARITH, 0, 0) + (0x4 * (2 * au_num + port));
3401a0f4:	793b      	ldrb	r3, [r7, #4]
3401a0f6:	005a      	lsls	r2, r3, #1
3401a0f8:	7e3b      	ldrb	r3, [r7, #24]
3401a0fa:	4413      	add	r3, r2
3401a0fc:	009b      	lsls	r3, r3, #2
3401a0fe:	3378      	adds	r3, #120	@ 0x78
3401a100:	e02d      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
#if defined(ATON_POOL_NUM)
    case POOL:
      LL_ATON_ASSERT(port == 0);
3401a102:	7e3b      	ldrb	r3, [r7, #24]
3401a104:	2b00      	cmp	r3, #0
3401a106:	d006      	beq.n	3401a116 <__atonn_getDstPortID+0x192>
3401a108:	4b1a      	ldr	r3, [pc, #104]	@ (3401a174 <__atonn_getDstPortID+0x1f0>)
3401a10a:	4a18      	ldr	r2, [pc, #96]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a10c:	f44f 716c 	mov.w	r1, #944	@ 0x3b0
3401a110:	4817      	ldr	r0, [pc, #92]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a112:	f00b fe29 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(au_num < ATON_POOL_NUM);
3401a116:	793b      	ldrb	r3, [r7, #4]
3401a118:	2b01      	cmp	r3, #1
3401a11a:	d906      	bls.n	3401a12a <__atonn_getDstPortID+0x1a6>
3401a11c:	4b1a      	ldr	r3, [pc, #104]	@ (3401a188 <__atonn_getDstPortID+0x204>)
3401a11e:	4a13      	ldr	r2, [pc, #76]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a120:	f240 31b1 	movw	r1, #945	@ 0x3b1
3401a124:	4812      	ldr	r0, [pc, #72]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a126:	f00b fe1f 	bl	34025d68 <__assert_func>
      return ATONN_CONST_DSTPORT(STRSWITCH, 0, POOL, 0, 0) + (0x4 * au_num);
3401a12a:	793b      	ldrb	r3, [r7, #4]
3401a12c:	009b      	lsls	r3, r3, #2
3401a12e:	3398      	adds	r3, #152	@ 0x98
3401a130:	e015      	b.n	3401a15e <__atonn_getDstPortID+0x1da>
      break;
#endif
    default:
      LL_ATON_ASSERT(0);
3401a132:	4b16      	ldr	r3, [pc, #88]	@ (3401a18c <__atonn_getDstPortID+0x208>)
3401a134:	4a0d      	ldr	r2, [pc, #52]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a136:	f240 31b6 	movw	r1, #950	@ 0x3b6
3401a13a:	480d      	ldr	r0, [pc, #52]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a13c:	f00b fe14 	bl	34025d68 <__assert_func>
      break;
    }
    break;
  case STRSWITCH64:
    // TODO
    LL_ATON_ASSERT(0);
3401a140:	4b12      	ldr	r3, [pc, #72]	@ (3401a18c <__atonn_getDstPortID+0x208>)
3401a142:	4a0a      	ldr	r2, [pc, #40]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a144:	f44f 716f 	mov.w	r1, #956	@ 0x3bc
3401a148:	4809      	ldr	r0, [pc, #36]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a14a:	f00b fe0d 	bl	34025d68 <__assert_func>
    break;
  case STRSWITCH_VC:
    // TODO
    LL_ATON_ASSERT(0);
3401a14e:	4b0f      	ldr	r3, [pc, #60]	@ (3401a18c <__atonn_getDstPortID+0x208>)
3401a150:	4a06      	ldr	r2, [pc, #24]	@ (3401a16c <__atonn_getDstPortID+0x1e8>)
3401a152:	f44f 7170 	mov.w	r1, #960	@ 0x3c0
3401a156:	4806      	ldr	r0, [pc, #24]	@ (3401a170 <__atonn_getDstPortID+0x1ec>)
3401a158:	f00b fe06 	bl	34025d68 <__assert_func>
    break;
  }
  return 0;
3401a15c:	2300      	movs	r3, #0
}
3401a15e:	4618      	mov	r0, r3
3401a160:	370c      	adds	r7, #12
3401a162:	46bd      	mov	sp, r7
3401a164:	bd90      	pop	{r4, r7, pc}
3401a166:	bf00      	nop
3401a168:	3402aaec 	.word	0x3402aaec
3401a16c:	3402bec0 	.word	0x3402bec0
3401a170:	3402a8ec 	.word	0x3402a8ec
3401a174:	3402aaf8 	.word	0x3402aaf8
3401a178:	3402ab04 	.word	0x3402ab04
3401a17c:	3402ab28 	.word	0x3402ab28
3401a180:	3402ab10 	.word	0x3402ab10
3401a184:	3402ab34 	.word	0x3402ab34
3401a188:	3402ab1c 	.word	0x3402ab1c
3401a18c:	3402aa70 	.word	0x3402aa70

3401a190 <LL_EpochCtrl_Init>:
 * @param  id Epoch Controller identifier [0..ATON_EPOCHCTRL_NUM-1]
 * @param  conf Structure describing Epoch Controller initialization parameters
 * @retval Error code
 */
int LL_EpochCtrl_Init(int id, const LL_EpochCtrl_InitTypeDef *conf)
{
3401a190:	b580      	push	{r7, lr}
3401a192:	b084      	sub	sp, #16
3401a194:	af00      	add	r7, sp, #0
3401a196:	6078      	str	r0, [r7, #4]
3401a198:	6039      	str	r1, [r7, #0]
  uint32_t t;

  if (id >= ATON_EPOCHCTRL_NUM)
3401a19a:	687b      	ldr	r3, [r7, #4]
3401a19c:	2b00      	cmp	r3, #0
3401a19e:	dd02      	ble.n	3401a1a6 <LL_EpochCtrl_Init+0x16>
    return LL_ATON_INVALID_ID;
3401a1a0:	f04f 33ff 	mov.w	r3, #4294967295
3401a1a4:	e024      	b.n	3401a1f0 <LL_EpochCtrl_Init+0x60>

  LL_ATON_EnableClock(ATON_EPOCHCTRL_CLKB_CLK(id));
3401a1a6:	687b      	ldr	r3, [r7, #4]
3401a1a8:	3319      	adds	r3, #25
3401a1aa:	4618      	mov	r0, r3
3401a1ac:	f000 f828 	bl	3401a200 <LL_ATON_EnableClock>

  /* Configure CTRL register */
  t = ATON_EPOCHCTRL_CTRL_DT;
3401a1b0:	2300      	movs	r3, #0
3401a1b2:	60fb      	str	r3, [r7, #12]
  t = ATON_EPOCHCTRL_CTRL_SET_SM(t, conf->stepmode);
3401a1b4:	68fb      	ldr	r3, [r7, #12]
3401a1b6:	f023 0208 	bic.w	r2, r3, #8
3401a1ba:	683b      	ldr	r3, [r7, #0]
3401a1bc:	791b      	ldrb	r3, [r3, #4]
3401a1be:	f3c3 0300 	ubfx	r3, r3, #0, #1
3401a1c2:	b2db      	uxtb	r3, r3
3401a1c4:	00db      	lsls	r3, r3, #3
3401a1c6:	f003 0308 	and.w	r3, r3, #8
3401a1ca:	4313      	orrs	r3, r2
3401a1cc:	60fb      	str	r3, [r7, #12]
  ATON_EPOCHCTRL_CTRL_SET(id, t);
3401a1ce:	4a0a      	ldr	r2, [pc, #40]	@ (3401a1f8 <LL_EpochCtrl_Init+0x68>)
3401a1d0:	68fb      	ldr	r3, [r7, #12]
3401a1d2:	6013      	str	r3, [r2, #0]

  /* Check address is 8 byte aligned */
  if (conf->blobaddr & 0x7)
3401a1d4:	683b      	ldr	r3, [r7, #0]
3401a1d6:	681b      	ldr	r3, [r3, #0]
3401a1d8:	f003 0307 	and.w	r3, r3, #7
3401a1dc:	2b00      	cmp	r3, #0
3401a1de:	d002      	beq.n	3401a1e6 <LL_EpochCtrl_Init+0x56>
    return LL_ATON_INVALID_PARAM;
3401a1e0:	f06f 0301 	mvn.w	r3, #1
3401a1e4:	e004      	b.n	3401a1f0 <LL_EpochCtrl_Init+0x60>

  ATON_EPOCHCTRL_ADDR_SET(id, conf->blobaddr);
3401a1e6:	4a05      	ldr	r2, [pc, #20]	@ (3401a1fc <LL_EpochCtrl_Init+0x6c>)
3401a1e8:	683b      	ldr	r3, [r7, #0]
3401a1ea:	681b      	ldr	r3, [r3, #0]
3401a1ec:	6013      	str	r3, [r2, #0]

  return LL_ATON_OK;
3401a1ee:	2300      	movs	r3, #0
}
3401a1f0:	4618      	mov	r0, r3
3401a1f2:	3710      	adds	r7, #16
3401a1f4:	46bd      	mov	sp, r7
3401a1f6:	bd80      	pop	{r7, pc}
3401a1f8:	580fe000 	.word	0x580fe000
3401a1fc:	580fe008 	.word	0x580fe008

3401a200 <LL_ATON_EnableClock>:
  return bloblines * 4;
}
#endif // ATON_EPOCHCTRL_NUM

void LL_ATON_EnableClock(unsigned int clock)
{
3401a200:	b490      	push	{r4, r7}
3401a202:	b084      	sub	sp, #16
3401a204:	af00      	add	r7, sp, #0
3401a206:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 1);
3401a208:	4b13      	ldr	r3, [pc, #76]	@ (3401a258 <LL_ATON_EnableClock+0x58>)
3401a20a:	681b      	ldr	r3, [r3, #0]
3401a20c:	60fb      	str	r3, [r7, #12]
3401a20e:	f04f 0201 	mov.w	r2, #1
3401a212:	f04f 0300 	mov.w	r3, #0
3401a216:	6879      	ldr	r1, [r7, #4]
3401a218:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401a21c:	4613      	mov	r3, r2
3401a21e:	43da      	mvns	r2, r3
3401a220:	68fb      	ldr	r3, [r7, #12]
3401a222:	ea02 0103 	and.w	r1, r2, r3
3401a226:	2201      	movs	r2, #1
3401a228:	687b      	ldr	r3, [r7, #4]
3401a22a:	fa02 f303 	lsl.w	r3, r2, r3
3401a22e:	461c      	mov	r4, r3
3401a230:	f04f 0201 	mov.w	r2, #1
3401a234:	f04f 0300 	mov.w	r3, #0
3401a238:	6878      	ldr	r0, [r7, #4]
3401a23a:	ea52 030d 	orrs.w	r3, r2, sp
3401a23e:	4613      	mov	r3, r2
3401a240:	4023      	ands	r3, r4
3401a242:	430b      	orrs	r3, r1
3401a244:	60fb      	str	r3, [r7, #12]
3401a246:	4a04      	ldr	r2, [pc, #16]	@ (3401a258 <LL_ATON_EnableClock+0x58>)
3401a248:	68fb      	ldr	r3, [r7, #12]
3401a24a:	6013      	str	r3, [r2, #0]
#endif
}
3401a24c:	bf00      	nop
3401a24e:	3710      	adds	r7, #16
3401a250:	46bd      	mov	sp, r7
3401a252:	bc90      	pop	{r4, r7}
3401a254:	4770      	bx	lr
3401a256:	bf00      	nop
3401a258:	580e0010 	.word	0x580e0010

3401a25c <LL_ATON_DisableClock>:

void LL_ATON_DisableClock(unsigned int clock)
{
3401a25c:	b480      	push	{r7}
3401a25e:	b085      	sub	sp, #20
3401a260:	af00      	add	r7, sp, #0
3401a262:	6078      	str	r0, [r7, #4]
#if (LL_ATON_ENABLE_CLOCK_GATING == 1)
  LL_ATON_REG_WRITE_FIELD_RANGE(CLKCTRL, 0, BGATES, clock, 1, 0);
3401a264:	4b0b      	ldr	r3, [pc, #44]	@ (3401a294 <LL_ATON_DisableClock+0x38>)
3401a266:	681b      	ldr	r3, [r3, #0]
3401a268:	60fb      	str	r3, [r7, #12]
3401a26a:	f04f 0201 	mov.w	r2, #1
3401a26e:	f04f 0300 	mov.w	r3, #0
3401a272:	6879      	ldr	r1, [r7, #4]
3401a274:	ea52 130d 	orrs.w	r3, r2, sp, lsl #4
3401a278:	4613      	mov	r3, r2
3401a27a:	43db      	mvns	r3, r3
3401a27c:	68fa      	ldr	r2, [r7, #12]
3401a27e:	4013      	ands	r3, r2
3401a280:	60fb      	str	r3, [r7, #12]
3401a282:	4a04      	ldr	r2, [pc, #16]	@ (3401a294 <LL_ATON_DisableClock+0x38>)
3401a284:	68fb      	ldr	r3, [r7, #12]
3401a286:	6013      	str	r3, [r2, #0]
#endif
}
3401a288:	bf00      	nop
3401a28a:	3714      	adds	r7, #20
3401a28c:	46bd      	mov	sp, r7
3401a28e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a292:	4770      	bx	lr
3401a294:	580e0010 	.word	0x580e0010

3401a298 <aton_osal_threadx_init>:

/**
 * @brief Initialize ThreadX OSAL implementation
 */
void aton_osal_threadx_init()
{
3401a298:	b580      	push	{r7, lr}
3401a29a:	b082      	sub	sp, #8
3401a29c:	af00      	add	r7, sp, #0
  UINT ret;

  /* create main priority based mechanism mutex */
  ret = tx_mutex_create(&_pb_mutex, NULL,
3401a29e:	2334      	movs	r3, #52	@ 0x34
3401a2a0:	2200      	movs	r2, #0
3401a2a2:	2100      	movs	r1, #0
3401a2a4:	4820      	ldr	r0, [pc, #128]	@ (3401a328 <aton_osal_threadx_init+0x90>)
3401a2a6:	f009 f8d7 	bl	34023458 <_txe_mutex_create>
3401a2aa:	6078      	str	r0, [r7, #4]
                        TX_NO_INHERIT); // no thread will ever wait on this mutex so priority inheritance will never
                                        // take place (this is most likely the most important downside of this OSAL
                                        // implementation, see "hand-made priority inheritance")
  SUCCESS_ASSERT(ret);
3401a2ac:	687b      	ldr	r3, [r7, #4]
3401a2ae:	2b00      	cmp	r3, #0
3401a2b0:	d005      	beq.n	3401a2be <aton_osal_threadx_init+0x26>
3401a2b2:	4b1e      	ldr	r3, [pc, #120]	@ (3401a32c <aton_osal_threadx_init+0x94>)
3401a2b4:	4a1e      	ldr	r2, [pc, #120]	@ (3401a330 <aton_osal_threadx_init+0x98>)
3401a2b6:	217b      	movs	r1, #123	@ 0x7b
3401a2b8:	481e      	ldr	r0, [pc, #120]	@ (3401a334 <aton_osal_threadx_init+0x9c>)
3401a2ba:	f00b fd55 	bl	34025d68 <__assert_func>

  /* create priority based mechanism semaphore */
  ret = tx_semaphore_create(&_pb_wait_queue, NULL, 0);
3401a2be:	2320      	movs	r3, #32
3401a2c0:	2200      	movs	r2, #0
3401a2c2:	2100      	movs	r1, #0
3401a2c4:	481c      	ldr	r0, [pc, #112]	@ (3401a338 <aton_osal_threadx_init+0xa0>)
3401a2c6:	f009 fa5d 	bl	34023784 <_txe_semaphore_create>
3401a2ca:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a2cc:	687b      	ldr	r3, [r7, #4]
3401a2ce:	2b00      	cmp	r3, #0
3401a2d0:	d005      	beq.n	3401a2de <aton_osal_threadx_init+0x46>
3401a2d2:	4b16      	ldr	r3, [pc, #88]	@ (3401a32c <aton_osal_threadx_init+0x94>)
3401a2d4:	4a16      	ldr	r2, [pc, #88]	@ (3401a330 <aton_osal_threadx_init+0x98>)
3401a2d6:	217f      	movs	r1, #127	@ 0x7f
3401a2d8:	4816      	ldr	r0, [pc, #88]	@ (3401a334 <aton_osal_threadx_init+0x9c>)
3401a2da:	f00b fd45 	bl	34025d68 <__assert_func>

  /* create WFE semaphore */
  ret = tx_semaphore_create(&_wfe_sem, NULL, 0);
3401a2de:	2320      	movs	r3, #32
3401a2e0:	2200      	movs	r2, #0
3401a2e2:	2100      	movs	r1, #0
3401a2e4:	4815      	ldr	r0, [pc, #84]	@ (3401a33c <aton_osal_threadx_init+0xa4>)
3401a2e6:	f009 fa4d 	bl	34023784 <_txe_semaphore_create>
3401a2ea:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a2ec:	687b      	ldr	r3, [r7, #4]
3401a2ee:	2b00      	cmp	r3, #0
3401a2f0:	d005      	beq.n	3401a2fe <aton_osal_threadx_init+0x66>
3401a2f2:	4b0e      	ldr	r3, [pc, #56]	@ (3401a32c <aton_osal_threadx_init+0x94>)
3401a2f4:	4a0e      	ldr	r2, [pc, #56]	@ (3401a330 <aton_osal_threadx_init+0x98>)
3401a2f6:	2183      	movs	r1, #131	@ 0x83
3401a2f8:	480e      	ldr	r0, [pc, #56]	@ (3401a334 <aton_osal_threadx_init+0x9c>)
3401a2fa:	f00b fd35 	bl	34025d68 <__assert_func>

  /* create cache mutex */
  ret = tx_mutex_create(&_cache_mutex, NULL, TX_INHERIT);
3401a2fe:	2334      	movs	r3, #52	@ 0x34
3401a300:	2201      	movs	r2, #1
3401a302:	2100      	movs	r1, #0
3401a304:	480e      	ldr	r0, [pc, #56]	@ (3401a340 <aton_osal_threadx_init+0xa8>)
3401a306:	f009 f8a7 	bl	34023458 <_txe_mutex_create>
3401a30a:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a30c:	687b      	ldr	r3, [r7, #4]
3401a30e:	2b00      	cmp	r3, #0
3401a310:	d005      	beq.n	3401a31e <aton_osal_threadx_init+0x86>
3401a312:	4b06      	ldr	r3, [pc, #24]	@ (3401a32c <aton_osal_threadx_init+0x94>)
3401a314:	4a06      	ldr	r2, [pc, #24]	@ (3401a330 <aton_osal_threadx_init+0x98>)
3401a316:	2187      	movs	r1, #135	@ 0x87
3401a318:	4806      	ldr	r0, [pc, #24]	@ (3401a334 <aton_osal_threadx_init+0x9c>)
3401a31a:	f00b fd25 	bl	34025d68 <__assert_func>
}
3401a31e:	bf00      	nop
3401a320:	3708      	adds	r7, #8
3401a322:	46bd      	mov	sp, r7
3401a324:	bd80      	pop	{r7, pc}
3401a326:	bf00      	nop
3401a328:	3404a200 	.word	0x3404a200
3401a32c:	3402abec 	.word	0x3402abec
3401a330:	3402bed8 	.word	0x3402bed8
3401a334:	3402aba4 	.word	0x3402aba4
3401a338:	3404a234 	.word	0x3404a234
3401a33c:	3404a254 	.word	0x3404a254
3401a340:	3404a274 	.word	0x3404a274

3401a344 <aton_osal_threadx_deinit>:

/**
 * @brief De-initialize ThreadX OSAL implementation
 */
void aton_osal_threadx_deinit()
{
3401a344:	b580      	push	{r7, lr}
3401a346:	b082      	sub	sp, #8
3401a348:	af00      	add	r7, sp, #0
  UINT ret;

  /* delete main priority based mechanism mutex */
  ret = tx_mutex_delete(&_pb_mutex);
3401a34a:	481c      	ldr	r0, [pc, #112]	@ (3401a3bc <aton_osal_threadx_deinit+0x78>)
3401a34c:	f009 f922 	bl	34023594 <_txe_mutex_delete>
3401a350:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a352:	687b      	ldr	r3, [r7, #4]
3401a354:	2b00      	cmp	r3, #0
3401a356:	d005      	beq.n	3401a364 <aton_osal_threadx_deinit+0x20>
3401a358:	4b19      	ldr	r3, [pc, #100]	@ (3401a3c0 <aton_osal_threadx_deinit+0x7c>)
3401a35a:	4a1a      	ldr	r2, [pc, #104]	@ (3401a3c4 <aton_osal_threadx_deinit+0x80>)
3401a35c:	2193      	movs	r1, #147	@ 0x93
3401a35e:	481a      	ldr	r0, [pc, #104]	@ (3401a3c8 <aton_osal_threadx_deinit+0x84>)
3401a360:	f00b fd02 	bl	34025d68 <__assert_func>

  /* delete priority based mechanism semaphore */
  ret = tx_semaphore_delete(&_pb_wait_queue);
3401a364:	4819      	ldr	r0, [pc, #100]	@ (3401a3cc <aton_osal_threadx_deinit+0x88>)
3401a366:	f009 faa3 	bl	340238b0 <_txe_semaphore_delete>
3401a36a:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a36c:	687b      	ldr	r3, [r7, #4]
3401a36e:	2b00      	cmp	r3, #0
3401a370:	d005      	beq.n	3401a37e <aton_osal_threadx_deinit+0x3a>
3401a372:	4b13      	ldr	r3, [pc, #76]	@ (3401a3c0 <aton_osal_threadx_deinit+0x7c>)
3401a374:	4a13      	ldr	r2, [pc, #76]	@ (3401a3c4 <aton_osal_threadx_deinit+0x80>)
3401a376:	2197      	movs	r1, #151	@ 0x97
3401a378:	4813      	ldr	r0, [pc, #76]	@ (3401a3c8 <aton_osal_threadx_deinit+0x84>)
3401a37a:	f00b fcf5 	bl	34025d68 <__assert_func>

  /* delete WFE semaphore */
  ret = tx_semaphore_delete(&_wfe_sem);
3401a37e:	4814      	ldr	r0, [pc, #80]	@ (3401a3d0 <aton_osal_threadx_deinit+0x8c>)
3401a380:	f009 fa96 	bl	340238b0 <_txe_semaphore_delete>
3401a384:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a386:	687b      	ldr	r3, [r7, #4]
3401a388:	2b00      	cmp	r3, #0
3401a38a:	d005      	beq.n	3401a398 <aton_osal_threadx_deinit+0x54>
3401a38c:	4b0c      	ldr	r3, [pc, #48]	@ (3401a3c0 <aton_osal_threadx_deinit+0x7c>)
3401a38e:	4a0d      	ldr	r2, [pc, #52]	@ (3401a3c4 <aton_osal_threadx_deinit+0x80>)
3401a390:	219b      	movs	r1, #155	@ 0x9b
3401a392:	480d      	ldr	r0, [pc, #52]	@ (3401a3c8 <aton_osal_threadx_deinit+0x84>)
3401a394:	f00b fce8 	bl	34025d68 <__assert_func>

  /* delete cache mutex */
  ret = tx_mutex_delete(&_cache_mutex);
3401a398:	480e      	ldr	r0, [pc, #56]	@ (3401a3d4 <aton_osal_threadx_deinit+0x90>)
3401a39a:	f009 f8fb 	bl	34023594 <_txe_mutex_delete>
3401a39e:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a3a0:	687b      	ldr	r3, [r7, #4]
3401a3a2:	2b00      	cmp	r3, #0
3401a3a4:	d005      	beq.n	3401a3b2 <aton_osal_threadx_deinit+0x6e>
3401a3a6:	4b06      	ldr	r3, [pc, #24]	@ (3401a3c0 <aton_osal_threadx_deinit+0x7c>)
3401a3a8:	4a06      	ldr	r2, [pc, #24]	@ (3401a3c4 <aton_osal_threadx_deinit+0x80>)
3401a3aa:	219f      	movs	r1, #159	@ 0x9f
3401a3ac:	4806      	ldr	r0, [pc, #24]	@ (3401a3c8 <aton_osal_threadx_deinit+0x84>)
3401a3ae:	f00b fcdb 	bl	34025d68 <__assert_func>
}
3401a3b2:	bf00      	nop
3401a3b4:	3708      	adds	r7, #8
3401a3b6:	46bd      	mov	sp, r7
3401a3b8:	bd80      	pop	{r7, pc}
3401a3ba:	bf00      	nop
3401a3bc:	3404a200 	.word	0x3404a200
3401a3c0:	3402abec 	.word	0x3402abec
3401a3c4:	3402bef0 	.word	0x3402bef0
3401a3c8:	3402aba4 	.word	0x3402aba4
3401a3cc:	3404a234 	.word	0x3404a234
3401a3d0:	3404a254 	.word	0x3404a254
3401a3d4:	3404a274 	.word	0x3404a274

3401a3d8 <aton_osal_threadx_wfe>:

/**
 * @brief Wait for event
 */
void aton_osal_threadx_wfe()
{
3401a3d8:	b580      	push	{r7, lr}
3401a3da:	b082      	sub	sp, #8
3401a3dc:	af00      	add	r7, sp, #0
  UINT ret;

  ret = tx_semaphore_get(&_wfe_sem, TX_WAIT_FOREVER);
3401a3de:	f04f 31ff 	mov.w	r1, #4294967295
3401a3e2:	4809      	ldr	r0, [pc, #36]	@ (3401a408 <aton_osal_threadx_wfe+0x30>)
3401a3e4:	f009 faa2 	bl	3402392c <_txe_semaphore_get>
3401a3e8:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a3ea:	687b      	ldr	r3, [r7, #4]
3401a3ec:	2b00      	cmp	r3, #0
3401a3ee:	d006      	beq.n	3401a3fe <aton_osal_threadx_wfe+0x26>
3401a3f0:	4b06      	ldr	r3, [pc, #24]	@ (3401a40c <aton_osal_threadx_wfe+0x34>)
3401a3f2:	4a07      	ldr	r2, [pc, #28]	@ (3401a410 <aton_osal_threadx_wfe+0x38>)
3401a3f4:	f240 111f 	movw	r1, #287	@ 0x11f
3401a3f8:	4806      	ldr	r0, [pc, #24]	@ (3401a414 <aton_osal_threadx_wfe+0x3c>)
3401a3fa:	f00b fcb5 	bl	34025d68 <__assert_func>
}
3401a3fe:	bf00      	nop
3401a400:	3708      	adds	r7, #8
3401a402:	46bd      	mov	sp, r7
3401a404:	bd80      	pop	{r7, pc}
3401a406:	bf00      	nop
3401a408:	3404a254 	.word	0x3404a254
3401a40c:	3402abec 	.word	0x3402abec
3401a410:	3402bf0c 	.word	0x3402bf0c
3401a414:	3402aba4 	.word	0x3402aba4

3401a418 <aton_osal_threadx_signal_event>:

/**
 * @brief Signal event
 */
void aton_osal_threadx_signal_event()
{
3401a418:	b580      	push	{r7, lr}
3401a41a:	b082      	sub	sp, #8
3401a41c:	af00      	add	r7, sp, #0
  UINT ret;

  ret = tx_semaphore_put(&_wfe_sem); // only one thread may be blocked on `_wfe_sem` at a time
3401a41e:	4809      	ldr	r0, [pc, #36]	@ (3401a444 <aton_osal_threadx_signal_event+0x2c>)
3401a420:	f009 fac6 	bl	340239b0 <_txe_semaphore_put>
3401a424:	6078      	str	r0, [r7, #4]
  SUCCESS_ASSERT(ret);
3401a426:	687b      	ldr	r3, [r7, #4]
3401a428:	2b00      	cmp	r3, #0
3401a42a:	d006      	beq.n	3401a43a <aton_osal_threadx_signal_event+0x22>
3401a42c:	4b06      	ldr	r3, [pc, #24]	@ (3401a448 <aton_osal_threadx_signal_event+0x30>)
3401a42e:	4a07      	ldr	r2, [pc, #28]	@ (3401a44c <aton_osal_threadx_signal_event+0x34>)
3401a430:	f44f 7195 	mov.w	r1, #298	@ 0x12a
3401a434:	4806      	ldr	r0, [pc, #24]	@ (3401a450 <aton_osal_threadx_signal_event+0x38>)
3401a436:	f00b fc97 	bl	34025d68 <__assert_func>
}
3401a43a:	bf00      	nop
3401a43c:	3708      	adds	r7, #8
3401a43e:	46bd      	mov	sp, r7
3401a440:	bd80      	pop	{r7, pc}
3401a442:	bf00      	nop
3401a444:	3404a254 	.word	0x3404a254
3401a448:	3402abec 	.word	0x3402abec
3401a44c:	3402bf24 	.word	0x3402bf24
3401a450:	3402aba4 	.word	0x3402aba4

3401a454 <LL_ATON_RT_Main>:
 *                         and the network interface, or macros
 *                         `LL_ATON_DECLARE_NAMED_NN_INTERFACE()` & `LL_ATON_DECLARE_NAMED_NN_INSTANCE()` to
 *                         create/instantiate the objects separately.
 */
void LL_ATON_RT_Main(NN_Instance_TypeDef *network_instance)
{
3401a454:	b580      	push	{r7, lr}
3401a456:	b084      	sub	sp, #16
3401a458:	af00      	add	r7, sp, #0
3401a45a:	6078      	str	r0, [r7, #4]

  /*** Start of user initialization code ***/

  /*** End of user initialization code ***/

  LL_ATON_ASSERT(network_instance != NULL);
3401a45c:	687b      	ldr	r3, [r7, #4]
3401a45e:	2b00      	cmp	r3, #0
3401a460:	d105      	bne.n	3401a46e <LL_ATON_RT_Main+0x1a>
3401a462:	4b15      	ldr	r3, [pc, #84]	@ (3401a4b8 <LL_ATON_RT_Main+0x64>)
3401a464:	4a15      	ldr	r2, [pc, #84]	@ (3401a4bc <LL_ATON_RT_Main+0x68>)
3401a466:	2130      	movs	r1, #48	@ 0x30
3401a468:	4815      	ldr	r0, [pc, #84]	@ (3401a4c0 <LL_ATON_RT_Main+0x6c>)
3401a46a:	f00b fc7d 	bl	34025d68 <__assert_func>
  LL_ATON_ASSERT(network_instance->network != NULL);
3401a46e:	687b      	ldr	r3, [r7, #4]
3401a470:	681b      	ldr	r3, [r3, #0]
3401a472:	2b00      	cmp	r3, #0
3401a474:	d105      	bne.n	3401a482 <LL_ATON_RT_Main+0x2e>
3401a476:	4b13      	ldr	r3, [pc, #76]	@ (3401a4c4 <LL_ATON_RT_Main+0x70>)
3401a478:	4a10      	ldr	r2, [pc, #64]	@ (3401a4bc <LL_ATON_RT_Main+0x68>)
3401a47a:	2131      	movs	r1, #49	@ 0x31
3401a47c:	4810      	ldr	r0, [pc, #64]	@ (3401a4c0 <LL_ATON_RT_Main+0x6c>)
3401a47e:	f00b fc73 	bl	34025d68 <__assert_func>
  LL_ATON_RT_RuntimeInit();                  // Initialize runtime
3401a482:	f000 fd11 	bl	3401aea8 <LL_ATON_RT_RuntimeInit>
  LL_ATON_RT_Init_Network(network_instance); // Initialize passed network instance object
3401a486:	6878      	ldr	r0, [r7, #4]
3401a488:	f000 fc96 	bl	3401adb8 <LL_ATON_RT_Init_Network>

  do
  {
    /* Execute first/next step of Cube.AI/ATON runtime */
    ll_aton_rt_ret = LL_ATON_RT_RunEpochBlock(network_instance);
3401a48c:	6878      	ldr	r0, [r7, #4]
3401a48e:	f000 fd87 	bl	3401afa0 <LL_ATON_RT_RunEpochBlock>
3401a492:	4603      	mov	r3, r0
3401a494:	73fb      	strb	r3, [r7, #15]
    /*** Start of user event handling code ***/

    /*** End of user event handling code ***/

    /* Wait for next event */
    if (ll_aton_rt_ret == LL_ATON_RT_WFE)
3401a496:	7bfb      	ldrb	r3, [r7, #15]
3401a498:	2b01      	cmp	r3, #1
3401a49a:	d101      	bne.n	3401a4a0 <LL_ATON_RT_Main+0x4c>
    { /*** subject to change to fit also user code requirements ***/
      LL_ATON_OSAL_WFE();
3401a49c:	f7ff ff9c 	bl	3401a3d8 <aton_osal_threadx_wfe>
    }
  } while (ll_aton_rt_ret != LL_ATON_RT_DONE); /*** subject to change to fit also user code requirements ***/
3401a4a0:	7bfb      	ldrb	r3, [r7, #15]
3401a4a2:	2b02      	cmp	r3, #2
3401a4a4:	d1f2      	bne.n	3401a48c <LL_ATON_RT_Main+0x38>

  LL_ATON_RT_DeInit_Network(network_instance); // De-initialize the network instance object
3401a4a6:	6878      	ldr	r0, [r7, #4]
3401a4a8:	f000 fcc0 	bl	3401ae2c <LL_ATON_RT_DeInit_Network>
  LL_ATON_RT_RuntimeDeInit();                  // De-initialize runtime
3401a4ac:	f000 fd5a 	bl	3401af64 <LL_ATON_RT_RuntimeDeInit>

  /*** Start of user de-initialization code ***/

  /*** End of user de-initialization code ***/
}
3401a4b0:	bf00      	nop
3401a4b2:	3710      	adds	r7, #16
3401a4b4:	46bd      	mov	sp, r7
3401a4b6:	bd80      	pop	{r7, pc}
3401a4b8:	3402ac54 	.word	0x3402ac54
3401a4bc:	3402bf44 	.word	0x3402bf44
3401a4c0:	3402ac74 	.word	0x3402ac74
3401a4c4:	3402acb8 	.word	0x3402acb8

3401a4c8 <__NVIC_EnableIRQ>:
{
3401a4c8:	b480      	push	{r7}
3401a4ca:	b083      	sub	sp, #12
3401a4cc:	af00      	add	r7, sp, #0
3401a4ce:	4603      	mov	r3, r0
3401a4d0:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401a4d2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a4d6:	2b00      	cmp	r3, #0
3401a4d8:	db0b      	blt.n	3401a4f2 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401a4da:	88fb      	ldrh	r3, [r7, #6]
3401a4dc:	f003 021f 	and.w	r2, r3, #31
3401a4e0:	4907      	ldr	r1, [pc, #28]	@ (3401a500 <__NVIC_EnableIRQ+0x38>)
3401a4e2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a4e6:	095b      	lsrs	r3, r3, #5
3401a4e8:	2001      	movs	r0, #1
3401a4ea:	fa00 f202 	lsl.w	r2, r0, r2
3401a4ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
3401a4f2:	bf00      	nop
3401a4f4:	370c      	adds	r7, #12
3401a4f6:	46bd      	mov	sp, r7
3401a4f8:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a4fc:	4770      	bx	lr
3401a4fe:	bf00      	nop
3401a500:	e000e100 	.word	0xe000e100

3401a504 <__NVIC_DisableIRQ>:
{
3401a504:	b480      	push	{r7}
3401a506:	b083      	sub	sp, #12
3401a508:	af00      	add	r7, sp, #0
3401a50a:	4603      	mov	r3, r0
3401a50c:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
3401a50e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a512:	2b00      	cmp	r3, #0
3401a514:	db12      	blt.n	3401a53c <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
3401a516:	88fb      	ldrh	r3, [r7, #6]
3401a518:	f003 021f 	and.w	r2, r3, #31
3401a51c:	490a      	ldr	r1, [pc, #40]	@ (3401a548 <__NVIC_DisableIRQ+0x44>)
3401a51e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3401a522:	095b      	lsrs	r3, r3, #5
3401a524:	2001      	movs	r0, #1
3401a526:	fa00 f202 	lsl.w	r2, r0, r2
3401a52a:	3320      	adds	r3, #32
3401a52c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
3401a530:	f3bf 8f4f 	dsb	sy
}
3401a534:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
3401a536:	f3bf 8f6f 	isb	sy
}
3401a53a:	bf00      	nop
}
3401a53c:	bf00      	nop
3401a53e:	370c      	adds	r7, #12
3401a540:	46bd      	mov	sp, r7
3401a542:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a546:	4770      	bx	lr
3401a548:	e000e100 	.word	0xe000e100

3401a54c <EpochBlock_IsLastEpochBlock>:
  {
3401a54c:	b480      	push	{r7}
3401a54e:	b083      	sub	sp, #12
3401a550:	af00      	add	r7, sp, #0
3401a552:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_last_eb) != 0);
3401a554:	687b      	ldr	r3, [r7, #4]
3401a556:	8a1b      	ldrh	r3, [r3, #16]
3401a558:	f003 0308 	and.w	r3, r3, #8
3401a55c:	2b00      	cmp	r3, #0
3401a55e:	bf14      	ite	ne
3401a560:	2301      	movne	r3, #1
3401a562:	2300      	moveq	r3, #0
3401a564:	b2db      	uxtb	r3, r3
  }
3401a566:	4618      	mov	r0, r3
3401a568:	370c      	adds	r7, #12
3401a56a:	46bd      	mov	sp, r7
3401a56c:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a570:	4770      	bx	lr

3401a572 <EpochBlock_IsEpochStart>:
  {
3401a572:	b480      	push	{r7}
3401a574:	b083      	sub	sp, #12
3401a576:	af00      	add	r7, sp, #0
3401a578:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
3401a57a:	687b      	ldr	r3, [r7, #4]
3401a57c:	8a1b      	ldrh	r3, [r3, #16]
3401a57e:	f003 0301 	and.w	r3, r3, #1
3401a582:	2b00      	cmp	r3, #0
3401a584:	bf14      	ite	ne
3401a586:	2301      	movne	r3, #1
3401a588:	2300      	moveq	r3, #0
3401a58a:	b2db      	uxtb	r3, r3
  }
3401a58c:	4618      	mov	r0, r3
3401a58e:	370c      	adds	r7, #12
3401a590:	46bd      	mov	sp, r7
3401a592:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a596:	4770      	bx	lr

3401a598 <EpochBlock_IsEpochBlob>:
  {
3401a598:	b480      	push	{r7}
3401a59a:	b083      	sub	sp, #12
3401a59c:	af00      	add	r7, sp, #0
3401a59e:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_blob) != 0);
3401a5a0:	687b      	ldr	r3, [r7, #4]
3401a5a2:	8a1b      	ldrh	r3, [r3, #16]
3401a5a4:	f003 0304 	and.w	r3, r3, #4
3401a5a8:	2b00      	cmp	r3, #0
3401a5aa:	bf14      	ite	ne
3401a5ac:	2301      	movne	r3, #1
3401a5ae:	2300      	moveq	r3, #0
3401a5b0:	b2db      	uxtb	r3, r3
  }
3401a5b2:	4618      	mov	r0, r3
3401a5b4:	370c      	adds	r7, #12
3401a5b6:	46bd      	mov	sp, r7
3401a5b8:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a5bc:	4770      	bx	lr

3401a5be <EpochBlock_IsEpochPureHW>:
  {
3401a5be:	b480      	push	{r7}
3401a5c0:	b083      	sub	sp, #12
3401a5c2:	af00      	add	r7, sp, #0
3401a5c4:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
3401a5c6:	687b      	ldr	r3, [r7, #4]
3401a5c8:	8a1b      	ldrh	r3, [r3, #16]
3401a5ca:	f003 0310 	and.w	r3, r3, #16
3401a5ce:	2b00      	cmp	r3, #0
3401a5d0:	bf14      	ite	ne
3401a5d2:	2301      	movne	r3, #1
3401a5d4:	2300      	moveq	r3, #0
3401a5d6:	b2db      	uxtb	r3, r3
  }
3401a5d8:	4618      	mov	r0, r3
3401a5da:	370c      	adds	r7, #12
3401a5dc:	46bd      	mov	sp, r7
3401a5de:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a5e2:	4770      	bx	lr

3401a5e4 <EpochBlock_IsEpochHybrid>:
  {
3401a5e4:	b480      	push	{r7}
3401a5e6:	b083      	sub	sp, #12
3401a5e8:	af00      	add	r7, sp, #0
3401a5ea:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_hybrid) != 0);
3401a5ec:	687b      	ldr	r3, [r7, #4]
3401a5ee:	8a1b      	ldrh	r3, [r3, #16]
3401a5f0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3401a5f4:	2b00      	cmp	r3, #0
3401a5f6:	bf14      	ite	ne
3401a5f8:	2301      	movne	r3, #1
3401a5fa:	2300      	moveq	r3, #0
3401a5fc:	b2db      	uxtb	r3, r3
  }
3401a5fe:	4618      	mov	r0, r3
3401a600:	370c      	adds	r7, #12
3401a602:	46bd      	mov	sp, r7
3401a604:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a608:	4770      	bx	lr

3401a60a <EpochBlock_IsEpochInternal>:
  {
3401a60a:	b480      	push	{r7}
3401a60c:	b083      	sub	sp, #12
3401a60e:	af00      	add	r7, sp, #0
3401a610:	6078      	str	r0, [r7, #4]
    return ((eb->flags & EpochBlock_Flags_internal) != 0);
3401a612:	687b      	ldr	r3, [r7, #4]
3401a614:	8a1b      	ldrh	r3, [r3, #16]
3401a616:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3401a61a:	2b00      	cmp	r3, #0
3401a61c:	bf14      	ite	ne
3401a61e:	2301      	movne	r3, #1
3401a620:	2300      	moveq	r3, #0
3401a622:	b2db      	uxtb	r3, r3
  }
3401a624:	4618      	mov	r0, r3
3401a626:	370c      	adds	r7, #12
3401a628:	46bd      	mov	sp, r7
3401a62a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a62e:	4770      	bx	lr

3401a630 <EpochBlock_EpochControllerUnit>:
  {
3401a630:	b580      	push	{r7, lr}
3401a632:	b082      	sub	sp, #8
3401a634:	af00      	add	r7, sp, #0
3401a636:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401a638:	6878      	ldr	r0, [r7, #4]
3401a63a:	f7ff ffad 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401a63e:	4603      	mov	r3, r0
3401a640:	2b00      	cmp	r3, #0
3401a642:	d106      	bne.n	3401a652 <EpochBlock_EpochControllerUnit+0x22>
3401a644:	4b06      	ldr	r3, [pc, #24]	@ (3401a660 <EpochBlock_EpochControllerUnit+0x30>)
3401a646:	4a07      	ldr	r2, [pc, #28]	@ (3401a664 <EpochBlock_EpochControllerUnit+0x34>)
3401a648:	f240 212a 	movw	r1, #554	@ 0x22a
3401a64c:	4806      	ldr	r0, [pc, #24]	@ (3401a668 <EpochBlock_EpochControllerUnit+0x38>)
3401a64e:	f00b fb8b 	bl	34025d68 <__assert_func>
    return eb->wait_mask;
3401a652:	687b      	ldr	r3, [r7, #4]
3401a654:	68db      	ldr	r3, [r3, #12]
  }
3401a656:	4618      	mov	r0, r3
3401a658:	3708      	adds	r7, #8
3401a65a:	46bd      	mov	sp, r7
3401a65c:	bd80      	pop	{r7, pc}
3401a65e:	bf00      	nop
3401a660:	3402ace4 	.word	0x3402ace4
3401a664:	3402c064 	.word	0x3402c064
3401a668:	3402ad00 	.word	0x3402ad00

3401a66c <EpochBlock_EpochBlobAddr>:
  {
3401a66c:	b580      	push	{r7, lr}
3401a66e:	b082      	sub	sp, #8
3401a670:	af00      	add	r7, sp, #0
3401a672:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
3401a674:	6878      	ldr	r0, [r7, #4]
3401a676:	f7ff ff8f 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401a67a:	4603      	mov	r3, r0
3401a67c:	2b00      	cmp	r3, #0
3401a67e:	d106      	bne.n	3401a68e <EpochBlock_EpochBlobAddr+0x22>
3401a680:	4b06      	ldr	r3, [pc, #24]	@ (3401a69c <EpochBlock_EpochBlobAddr+0x30>)
3401a682:	4a07      	ldr	r2, [pc, #28]	@ (3401a6a0 <EpochBlock_EpochBlobAddr+0x34>)
3401a684:	f44f 710c 	mov.w	r1, #560	@ 0x230
3401a688:	4806      	ldr	r0, [pc, #24]	@ (3401a6a4 <EpochBlock_EpochBlobAddr+0x38>)
3401a68a:	f00b fb6d 	bl	34025d68 <__assert_func>
    return eb->blob_address;
3401a68e:	687b      	ldr	r3, [r7, #4]
3401a690:	689b      	ldr	r3, [r3, #8]
  }
3401a692:	4618      	mov	r0, r3
3401a694:	3708      	adds	r7, #8
3401a696:	46bd      	mov	sp, r7
3401a698:	bd80      	pop	{r7, pc}
3401a69a:	bf00      	nop
3401a69c:	3402ace4 	.word	0x3402ace4
3401a6a0:	3402c084 	.word	0x3402c084
3401a6a4:	3402ad00 	.word	0x3402ad00

3401a6a8 <__ll_set_aton_owner>:
  typedef EpochBlock_ItemTypeDef LL_ATON_RT_EpochBlockItem_t;

  /*** Helper Functions ***/

  static inline void __ll_set_aton_owner(NN_Instance_TypeDef *new_owner)
  {
3401a6a8:	b580      	push	{r7, lr}
3401a6aa:	b082      	sub	sp, #8
3401a6ac:	af00      	add	r7, sp, #0
3401a6ae:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(new_owner != __ll_current_aton_ip_owner);
3401a6b0:	4b12      	ldr	r3, [pc, #72]	@ (3401a6fc <__ll_set_aton_owner+0x54>)
3401a6b2:	681b      	ldr	r3, [r3, #0]
3401a6b4:	687a      	ldr	r2, [r7, #4]
3401a6b6:	429a      	cmp	r2, r3
3401a6b8:	d105      	bne.n	3401a6c6 <__ll_set_aton_owner+0x1e>
3401a6ba:	4b11      	ldr	r3, [pc, #68]	@ (3401a700 <__ll_set_aton_owner+0x58>)
3401a6bc:	4a11      	ldr	r2, [pc, #68]	@ (3401a704 <__ll_set_aton_owner+0x5c>)
3401a6be:	2131      	movs	r1, #49	@ 0x31
3401a6c0:	4811      	ldr	r0, [pc, #68]	@ (3401a708 <__ll_set_aton_owner+0x60>)
3401a6c2:	f00b fb51 	bl	34025d68 <__assert_func>

    LL_ATON_LOCK_ATON();

    LL_ATON_ASSERT(__ll_current_aton_ip_owner == NULL);
3401a6c6:	4b0d      	ldr	r3, [pc, #52]	@ (3401a6fc <__ll_set_aton_owner+0x54>)
3401a6c8:	681b      	ldr	r3, [r3, #0]
3401a6ca:	2b00      	cmp	r3, #0
3401a6cc:	d005      	beq.n	3401a6da <__ll_set_aton_owner+0x32>
3401a6ce:	4b0f      	ldr	r3, [pc, #60]	@ (3401a70c <__ll_set_aton_owner+0x64>)
3401a6d0:	4a0c      	ldr	r2, [pc, #48]	@ (3401a704 <__ll_set_aton_owner+0x5c>)
3401a6d2:	2135      	movs	r1, #53	@ 0x35
3401a6d4:	480c      	ldr	r0, [pc, #48]	@ (3401a708 <__ll_set_aton_owner+0x60>)
3401a6d6:	f00b fb47 	bl	34025d68 <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401a6da:	4b0d      	ldr	r3, [pc, #52]	@ (3401a710 <__ll_set_aton_owner+0x68>)
3401a6dc:	681b      	ldr	r3, [r3, #0]
3401a6de:	2b00      	cmp	r3, #0
3401a6e0:	d005      	beq.n	3401a6ee <__ll_set_aton_owner+0x46>
3401a6e2:	4b0c      	ldr	r3, [pc, #48]	@ (3401a714 <__ll_set_aton_owner+0x6c>)
3401a6e4:	4a07      	ldr	r2, [pc, #28]	@ (3401a704 <__ll_set_aton_owner+0x5c>)
3401a6e6:	2139      	movs	r1, #57	@ 0x39
3401a6e8:	4807      	ldr	r0, [pc, #28]	@ (3401a708 <__ll_set_aton_owner+0x60>)
3401a6ea:	f00b fb3d 	bl	34025d68 <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = new_owner;
3401a6ee:	4a03      	ldr	r2, [pc, #12]	@ (3401a6fc <__ll_set_aton_owner+0x54>)
3401a6f0:	687b      	ldr	r3, [r7, #4]
3401a6f2:	6013      	str	r3, [r2, #0]
  }
3401a6f4:	bf00      	nop
3401a6f6:	3708      	adds	r7, #8
3401a6f8:	46bd      	mov	sp, r7
3401a6fa:	bd80      	pop	{r7, pc}
3401a6fc:	3404a2a8 	.word	0x3404a2a8
3401a700:	3402ad48 	.word	0x3402ad48
3401a704:	3402c034 	.word	0x3402c034
3401a708:	3402ad70 	.word	0x3402ad70
3401a70c:	3402adb4 	.word	0x3402adb4
3401a710:	3404a2ac 	.word	0x3404a2ac
3401a714:	3402ade0 	.word	0x3402ade0

3401a718 <__ll_clear_aton_owner>:

  static inline void __ll_clear_aton_owner(NN_Instance_TypeDef *current_owner)
  {
3401a718:	b580      	push	{r7, lr}
3401a71a:	b082      	sub	sp, #8
3401a71c:	af00      	add	r7, sp, #0
3401a71e:	6078      	str	r0, [r7, #4]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(current_owner == __ll_current_aton_ip_owner);
3401a720:	4b0d      	ldr	r3, [pc, #52]	@ (3401a758 <__ll_clear_aton_owner+0x40>)
3401a722:	681b      	ldr	r3, [r3, #0]
3401a724:	687a      	ldr	r2, [r7, #4]
3401a726:	429a      	cmp	r2, r3
3401a728:	d005      	beq.n	3401a736 <__ll_clear_aton_owner+0x1e>
3401a72a:	4b0c      	ldr	r3, [pc, #48]	@ (3401a75c <__ll_clear_aton_owner+0x44>)
3401a72c:	4a0c      	ldr	r2, [pc, #48]	@ (3401a760 <__ll_clear_aton_owner+0x48>)
3401a72e:	2142      	movs	r1, #66	@ 0x42
3401a730:	480c      	ldr	r0, [pc, #48]	@ (3401a764 <__ll_clear_aton_owner+0x4c>)
3401a732:	f00b fb19 	bl	34025d68 <__assert_func>

#ifndef NDEBUG
    extern uint32_t volatile __ll_current_wait_mask;
    LL_ATON_ASSERT(__ll_current_wait_mask == 0);
3401a736:	4b0c      	ldr	r3, [pc, #48]	@ (3401a768 <__ll_clear_aton_owner+0x50>)
3401a738:	681b      	ldr	r3, [r3, #0]
3401a73a:	2b00      	cmp	r3, #0
3401a73c:	d005      	beq.n	3401a74a <__ll_clear_aton_owner+0x32>
3401a73e:	4b0b      	ldr	r3, [pc, #44]	@ (3401a76c <__ll_clear_aton_owner+0x54>)
3401a740:	4a07      	ldr	r2, [pc, #28]	@ (3401a760 <__ll_clear_aton_owner+0x48>)
3401a742:	2146      	movs	r1, #70	@ 0x46
3401a744:	4807      	ldr	r0, [pc, #28]	@ (3401a764 <__ll_clear_aton_owner+0x4c>)
3401a746:	f00b fb0f 	bl	34025d68 <__assert_func>
#endif // NDEBUG

    __ll_current_aton_ip_owner = NULL;
3401a74a:	4b03      	ldr	r3, [pc, #12]	@ (3401a758 <__ll_clear_aton_owner+0x40>)
3401a74c:	2200      	movs	r2, #0
3401a74e:	601a      	str	r2, [r3, #0]
    LL_ATON_UNLOCK_ATON();
  }
3401a750:	bf00      	nop
3401a752:	3708      	adds	r7, #8
3401a754:	46bd      	mov	sp, r7
3401a756:	bd80      	pop	{r7, pc}
3401a758:	3404a2a8 	.word	0x3404a2a8
3401a75c:	3402adfc 	.word	0x3402adfc
3401a760:	3402bf94 	.word	0x3402bf94
3401a764:	3402ad70 	.word	0x3402ad70
3401a768:	3404a2ac 	.word	0x3404a2ac
3401a76c:	3402ade0 	.word	0x3402ade0

3401a770 <__LL_ATON_RT_Start_AtoNN_Epoch>:
   *  Note: the following function may only be called at the beginning of
   *       `LL_ATON_Start_EpochBlock<n>()` functions, assuming also that at that point
   *       no streaming engine interrupts might trigger (anymore)!
   **/
  static inline void __LL_ATON_RT_Start_AtoNN_Epoch(NN_Instance_TypeDef *nn_instance)
  {
3401a770:	b580      	push	{r7, lr}
3401a772:	b082      	sub	sp, #8
3401a774:	af00      	add	r7, sp, #0
3401a776:	6078      	str	r0, [r7, #4]
    LL_ATON_ASSERT(nn_instance != NULL);
3401a778:	687b      	ldr	r3, [r7, #4]
3401a77a:	2b00      	cmp	r3, #0
3401a77c:	d105      	bne.n	3401a78a <__LL_ATON_RT_Start_AtoNN_Epoch+0x1a>
3401a77e:	4b0a      	ldr	r3, [pc, #40]	@ (3401a7a8 <__LL_ATON_RT_Start_AtoNN_Epoch+0x38>)
3401a780:	4a0a      	ldr	r2, [pc, #40]	@ (3401a7ac <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401a782:	2154      	movs	r1, #84	@ 0x54
3401a784:	480a      	ldr	r0, [pc, #40]	@ (3401a7b0 <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401a786:	f00b faef 	bl	34025d68 <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401a78a:	687b      	ldr	r3, [r7, #4]
3401a78c:	69db      	ldr	r3, [r3, #28]
3401a78e:	2b00      	cmp	r3, #0
3401a790:	d005      	beq.n	3401a79e <__LL_ATON_RT_Start_AtoNN_Epoch+0x2e>
3401a792:	4b08      	ldr	r3, [pc, #32]	@ (3401a7b4 <__LL_ATON_RT_Start_AtoNN_Epoch+0x44>)
3401a794:	4a05      	ldr	r2, [pc, #20]	@ (3401a7ac <__LL_ATON_RT_Start_AtoNN_Epoch+0x3c>)
3401a796:	2156      	movs	r1, #86	@ 0x56
3401a798:	4805      	ldr	r0, [pc, #20]	@ (3401a7b0 <__LL_ATON_RT_Start_AtoNN_Epoch+0x40>)
3401a79a:	f00b fae5 	bl	34025d68 <__assert_func>
                   0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                         // cleared at this point in time!
#endif
  }
3401a79e:	bf00      	nop
3401a7a0:	3708      	adds	r7, #8
3401a7a2:	46bd      	mov	sp, r7
3401a7a4:	bd80      	pop	{r7, pc}
3401a7a6:	bf00      	nop
3401a7a8:	3402ae28 	.word	0x3402ae28
3401a7ac:	3402c014 	.word	0x3402c014
3401a7b0:	3402ad70 	.word	0x3402ad70
3401a7b4:	3402ae44 	.word	0x3402ae44

3401a7b8 <__LL_ATON_RT_SetWaitMask>:
    nn_instance->exec_state.current_epoch_block = &nn_instance->exec_state.first_epoch_block[index];
  }

  /* set wait mask(s) in interrupt controller */
  static inline void __LL_ATON_RT_SetWaitMask(uint32_t wait_mask)
  {
3401a7b8:	b580      	push	{r7, lr}
3401a7ba:	b082      	sub	sp, #8
3401a7bc:	af00      	add	r7, sp, #0
3401a7be:	6078      	str	r0, [r7, #4]
#ifndef NDEBUG
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;
    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401a7c0:	4b0a      	ldr	r3, [pc, #40]	@ (3401a7ec <__LL_ATON_RT_SetWaitMask+0x34>)
3401a7c2:	681b      	ldr	r3, [r3, #0]
3401a7c4:	2b00      	cmp	r3, #0
3401a7c6:	d105      	bne.n	3401a7d4 <__LL_ATON_RT_SetWaitMask+0x1c>
3401a7c8:	4b09      	ldr	r3, [pc, #36]	@ (3401a7f0 <__LL_ATON_RT_SetWaitMask+0x38>)
3401a7ca:	4a0a      	ldr	r2, [pc, #40]	@ (3401a7f4 <__LL_ATON_RT_SetWaitMask+0x3c>)
3401a7cc:	2175      	movs	r1, #117	@ 0x75
3401a7ce:	480a      	ldr	r0, [pc, #40]	@ (3401a7f8 <__LL_ATON_RT_SetWaitMask+0x40>)
3401a7d0:	f00b faca 	bl	34025d68 <__assert_func>

    extern uint32_t volatile __ll_current_wait_mask;
    __ll_current_wait_mask = wait_mask;
3401a7d4:	4a09      	ldr	r2, [pc, #36]	@ (3401a7fc <__LL_ATON_RT_SetWaitMask+0x44>)
3401a7d6:	687b      	ldr	r3, [r7, #4]
3401a7d8:	6013      	str	r3, [r2, #0]

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    wait_mask <<= ATON_STRENG_INT(0);
#ifndef LL_ATON_RT_USE_IRQ_OR_MASK
    /* configure interrupt controller AND mask for epoch block */
    ATON_INTCTRL_STD_INTANDMSK_SET(~wait_mask);
3401a7da:	4a09      	ldr	r2, [pc, #36]	@ (3401a800 <__LL_ATON_RT_SetWaitMask+0x48>)
3401a7dc:	687b      	ldr	r3, [r7, #4]
3401a7de:	43db      	mvns	r3, r3
3401a7e0:	6013      	str	r3, [r2, #0]
                                                                // (all other events & errors are enabled)
    val &= ~wait_mask;
    ATON_INTCTRL_STD_INTORMSK_SET(val);
#endif // LL_ATON_RT_USE_IRQ_OR_MASK
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  }
3401a7e2:	bf00      	nop
3401a7e4:	3708      	adds	r7, #8
3401a7e6:	46bd      	mov	sp, r7
3401a7e8:	bd80      	pop	{r7, pc}
3401a7ea:	bf00      	nop
3401a7ec:	3404a2a8 	.word	0x3404a2a8
3401a7f0:	3402ae74 	.word	0x3402ae74
3401a7f4:	3402c048 	.word	0x3402c048
3401a7f8:	3402ad70 	.word	0x3402ad70
3401a7fc:	3404a2ac 	.word	0x3404a2ac
3401a800:	580e1024 	.word	0x580e1024

3401a804 <__LL_ATON_RT_RetFromLibEpochBlockArray>:

  /* return from inserted epoch block */
  static inline void __LL_ATON_RT_RetFromLibEpochBlockArray(bool unlock, NN_Instance_TypeDef *nn_instance)
  {
3401a804:	b580      	push	{r7, lr}
3401a806:	b082      	sub	sp, #8
3401a808:	af00      	add	r7, sp, #0
3401a80a:	4603      	mov	r3, r0
3401a80c:	6039      	str	r1, [r7, #0]
3401a80e:	71fb      	strb	r3, [r7, #7]
    extern NN_Instance_TypeDef *volatile __ll_current_aton_ip_owner;

    if (!unlock)
3401a810:	79fb      	ldrb	r3, [r7, #7]
3401a812:	f083 0301 	eor.w	r3, r3, #1
3401a816:	b2db      	uxtb	r3, r3
3401a818:	2b00      	cmp	r3, #0
3401a81a:	d015      	beq.n	3401a848 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x44>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401a81c:	4b38      	ldr	r3, [pc, #224]	@ (3401a900 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401a81e:	681b      	ldr	r3, [r3, #0]
3401a820:	2b00      	cmp	r3, #0
3401a822:	d105      	bne.n	3401a830 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x2c>
3401a824:	4b37      	ldr	r3, [pc, #220]	@ (3401a904 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401a826:	4a38      	ldr	r2, [pc, #224]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a828:	2191      	movs	r1, #145	@ 0x91
3401a82a:	4838      	ldr	r0, [pc, #224]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a82c:	f00b fa9c 	bl	34025d68 <__assert_func>
      LL_ATON_ASSERT(nn_instance == NULL);
3401a830:	683b      	ldr	r3, [r7, #0]
3401a832:	2b00      	cmp	r3, #0
3401a834:	d005      	beq.n	3401a842 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x3e>
3401a836:	4b36      	ldr	r3, [pc, #216]	@ (3401a910 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x10c>)
3401a838:	4a33      	ldr	r2, [pc, #204]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a83a:	2192      	movs	r1, #146	@ 0x92
3401a83c:	4833      	ldr	r0, [pc, #204]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a83e:	f00b fa93 	bl	34025d68 <__assert_func>

      nn_instance = __ll_current_aton_ip_owner;
3401a842:	4b2f      	ldr	r3, [pc, #188]	@ (3401a900 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401a844:	681b      	ldr	r3, [r3, #0]
3401a846:	603b      	str	r3, [r7, #0]
    }

    LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401a848:	4b2d      	ldr	r3, [pc, #180]	@ (3401a900 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401a84a:	681b      	ldr	r3, [r3, #0]
3401a84c:	2b00      	cmp	r3, #0
3401a84e:	d105      	bne.n	3401a85c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x58>
3401a850:	4b2c      	ldr	r3, [pc, #176]	@ (3401a904 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x100>)
3401a852:	4a2d      	ldr	r2, [pc, #180]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a854:	2197      	movs	r1, #151	@ 0x97
3401a856:	482d      	ldr	r0, [pc, #180]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a858:	f00b fa86 	bl	34025d68 <__assert_func>
    LL_ATON_ASSERT(unlock ? EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block)
3401a85c:	79fb      	ldrb	r3, [r7, #7]
3401a85e:	2b00      	cmp	r3, #0
3401a860:	d006      	beq.n	3401a870 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x6c>
3401a862:	683b      	ldr	r3, [r7, #0]
3401a864:	685b      	ldr	r3, [r3, #4]
3401a866:	4618      	mov	r0, r3
3401a868:	f7ff fe70 	bl	3401a54c <EpochBlock_IsLastEpochBlock>
3401a86c:	4603      	mov	r3, r0
3401a86e:	e005      	b.n	3401a87c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x78>
3401a870:	683b      	ldr	r3, [r7, #0]
3401a872:	685b      	ldr	r3, [r3, #4]
3401a874:	4618      	mov	r0, r3
3401a876:	f7ff fec8 	bl	3401a60a <EpochBlock_IsEpochInternal>
3401a87a:	4603      	mov	r3, r0
3401a87c:	2b00      	cmp	r3, #0
3401a87e:	d105      	bne.n	3401a88c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x88>
3401a880:	4b24      	ldr	r3, [pc, #144]	@ (3401a914 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x110>)
3401a882:	4a21      	ldr	r2, [pc, #132]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a884:	2198      	movs	r1, #152	@ 0x98
3401a886:	4821      	ldr	r0, [pc, #132]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a888:	f00b fa6e 	bl	34025d68 <__assert_func>
                          : EpochBlock_IsEpochInternal(nn_instance->exec_state.current_epoch_block));
    LL_ATON_ASSERT(EpochBlock_IsEpochHybrid(nn_instance->exec_state.saved_current_epoch_block));
3401a88c:	683b      	ldr	r3, [r7, #0]
3401a88e:	691b      	ldr	r3, [r3, #16]
3401a890:	4618      	mov	r0, r3
3401a892:	f7ff fea7 	bl	3401a5e4 <EpochBlock_IsEpochHybrid>
3401a896:	4603      	mov	r3, r0
3401a898:	2b00      	cmp	r3, #0
3401a89a:	d105      	bne.n	3401a8a8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xa4>
3401a89c:	4b1e      	ldr	r3, [pc, #120]	@ (3401a918 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x114>)
3401a89e:	4a1a      	ldr	r2, [pc, #104]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a8a0:	219a      	movs	r1, #154	@ 0x9a
3401a8a2:	481a      	ldr	r0, [pc, #104]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a8a4:	f00b fa60 	bl	34025d68 <__assert_func>

    /* Clear owner */
    if (unlock)
3401a8a8:	79fb      	ldrb	r3, [r7, #7]
3401a8aa:	2b00      	cmp	r3, #0
3401a8ac:	d004      	beq.n	3401a8b8 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xb4>
    {
      __ll_clear_aton_owner(__ll_current_aton_ip_owner);
3401a8ae:	4b14      	ldr	r3, [pc, #80]	@ (3401a900 <__LL_ATON_RT_RetFromLibEpochBlockArray+0xfc>)
3401a8b0:	681b      	ldr	r3, [r3, #0]
3401a8b2:	4618      	mov	r0, r3
3401a8b4:	f7ff ff30 	bl	3401a718 <__ll_clear_aton_owner>
    }

    /* set old context */
    LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401a8b8:	683b      	ldr	r3, [r7, #0]
3401a8ba:	68db      	ldr	r3, [r3, #12]
3401a8bc:	2b00      	cmp	r3, #0
3401a8be:	d005      	beq.n	3401a8cc <__LL_ATON_RT_RetFromLibEpochBlockArray+0xc8>
3401a8c0:	4b16      	ldr	r3, [pc, #88]	@ (3401a91c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x118>)
3401a8c2:	4a11      	ldr	r2, [pc, #68]	@ (3401a908 <__LL_ATON_RT_RetFromLibEpochBlockArray+0x104>)
3401a8c4:	21a3      	movs	r1, #163	@ 0xa3
3401a8c6:	4811      	ldr	r0, [pc, #68]	@ (3401a90c <__LL_ATON_RT_RetFromLibEpochBlockArray+0x108>)
3401a8c8:	f00b fa4e 	bl	34025d68 <__assert_func>
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.saved_current_epoch_block;
3401a8cc:	683b      	ldr	r3, [r7, #0]
3401a8ce:	691a      	ldr	r2, [r3, #16]
3401a8d0:	683b      	ldr	r3, [r7, #0]
3401a8d2:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.saved_first_epoch_block;
3401a8d4:	683b      	ldr	r3, [r7, #0]
3401a8d6:	695a      	ldr	r2, [r3, #20]
3401a8d8:	683b      	ldr	r3, [r7, #0]
3401a8da:	609a      	str	r2, [r3, #8]

#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = nn_instance->exec_state.saved_nr_of_epoch_blocks;
3401a8dc:	683b      	ldr	r3, [r7, #0]
3401a8de:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3401a8e0:	683b      	ldr	r3, [r7, #0]
3401a8e2:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset saved context */
    nn_instance->exec_state.saved_current_epoch_block = NULL;
3401a8e4:	683b      	ldr	r3, [r7, #0]
3401a8e6:	2200      	movs	r2, #0
3401a8e8:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = NULL;
3401a8ea:	683b      	ldr	r3, [r7, #0]
3401a8ec:	2200      	movs	r2, #0
3401a8ee:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401a8f0:	683b      	ldr	r3, [r7, #0]
3401a8f2:	2200      	movs	r2, #0
3401a8f4:	629a      	str	r2, [r3, #40]	@ 0x28
#endif
  }
3401a8f6:	bf00      	nop
3401a8f8:	3708      	adds	r7, #8
3401a8fa:	46bd      	mov	sp, r7
3401a8fc:	bd80      	pop	{r7, pc}
3401a8fe:	bf00      	nop
3401a900:	3404a2a8 	.word	0x3404a2a8
3401a904:	3402ae74 	.word	0x3402ae74
3401a908:	3402bfc8 	.word	0x3402bfc8
3401a90c:	3402ad70 	.word	0x3402ad70
3401a910:	3402aea0 	.word	0x3402aea0
3401a914:	3402aebc 	.word	0x3402aebc
3401a918:	3402af58 	.word	0x3402af58
3401a91c:	3402afa4 	.word	0x3402afa4

3401a920 <dump_dma_state>:
#error current ATON runtime supports only up to 32 epoch controllers!
#endif // (ATON_EPOCHCTRL_NUM > 32)

#endif // `ATON_INT_NR` and `ATON_STRENG_NUM` are defined

LL_ATON_WEAK void dump_dma_state(void){};
3401a920:	b480      	push	{r7}
3401a922:	af00      	add	r7, sp, #0
3401a924:	bf00      	nop
3401a926:	46bd      	mov	sp, r7
3401a928:	f85d 7b04 	ldr.w	r7, [sp], #4
3401a92c:	4770      	bx	lr

3401a92e <__LL_ATON_RT_CntEpochBlocks>:

/*** Helper Functions ***/

#ifndef NDEBUG
static uint32_t __LL_ATON_RT_CntEpochBlocks(const LL_ATON_RT_EpochBlockItem_t *list)
{
3401a92e:	b580      	push	{r7, lr}
3401a930:	b084      	sub	sp, #16
3401a932:	af00      	add	r7, sp, #0
3401a934:	6078      	str	r0, [r7, #4]
  int i = 0;
3401a936:	2300      	movs	r3, #0
3401a938:	60fb      	str	r3, [r7, #12]

  if (list != NULL)
3401a93a:	687b      	ldr	r3, [r7, #4]
3401a93c:	2b00      	cmp	r3, #0
3401a93e:	d011      	beq.n	3401a964 <__LL_ATON_RT_CntEpochBlocks+0x36>
  {
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401a940:	2301      	movs	r3, #1
3401a942:	60fb      	str	r3, [r7, #12]
3401a944:	e005      	b.n	3401a952 <__LL_ATON_RT_CntEpochBlocks+0x24>
    { // Note: also terminating empty epoch block is counted
      list++;
3401a946:	687b      	ldr	r3, [r7, #4]
3401a948:	3314      	adds	r3, #20
3401a94a:	607b      	str	r3, [r7, #4]
    for (i = 1; !EpochBlock_IsLastEpochBlock(list); i++)
3401a94c:	68fb      	ldr	r3, [r7, #12]
3401a94e:	3301      	adds	r3, #1
3401a950:	60fb      	str	r3, [r7, #12]
3401a952:	6878      	ldr	r0, [r7, #4]
3401a954:	f7ff fdfa 	bl	3401a54c <EpochBlock_IsLastEpochBlock>
3401a958:	4603      	mov	r3, r0
3401a95a:	f083 0301 	eor.w	r3, r3, #1
3401a95e:	b2db      	uxtb	r3, r3
3401a960:	2b00      	cmp	r3, #0
3401a962:	d1f0      	bne.n	3401a946 <__LL_ATON_RT_CntEpochBlocks+0x18>
    }
  }

  return i;
3401a964:	68fb      	ldr	r3, [r7, #12]
}
3401a966:	4618      	mov	r0, r3
3401a968:	3710      	adds	r7, #16
3401a96a:	46bd      	mov	sp, r7
3401a96c:	bd80      	pop	{r7, pc}
	...

3401a970 <__LL_ATON_RT_ExecStartEpochBlock>:
#endif

static inline void __LL_ATON_RT_ExecStartEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                    NN_Instance_TypeDef *nn_instance)
{
3401a970:	b580      	push	{r7, lr}
3401a972:	b086      	sub	sp, #24
3401a974:	af00      	add	r7, sp, #0
3401a976:	6078      	str	r0, [r7, #4]
3401a978:	6039      	str	r1, [r7, #0]
  LL_ATON_ASSERT(nn_instance->exec_state.next_epoch_block == NULL);
3401a97a:	683b      	ldr	r3, [r7, #0]
3401a97c:	68db      	ldr	r3, [r3, #12]
3401a97e:	2b00      	cmp	r3, #0
3401a980:	d005      	beq.n	3401a98e <__LL_ATON_RT_ExecStartEpochBlock+0x1e>
3401a982:	4b4a      	ldr	r3, [pc, #296]	@ (3401aaac <__LL_ATON_RT_ExecStartEpochBlock+0x13c>)
3401a984:	4a4a      	ldr	r2, [pc, #296]	@ (3401aab0 <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401a986:	215f      	movs	r1, #95	@ 0x5f
3401a988:	484a      	ldr	r0, [pc, #296]	@ (3401aab4 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401a98a:	f00b f9ed 	bl	34025d68 <__assert_func>

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401a98e:	683b      	ldr	r3, [r7, #0]
3401a990:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401a992:	2b00      	cmp	r3, #0
3401a994:	d005      	beq.n	3401a9a2 <__LL_ATON_RT_ExecStartEpochBlock+0x32>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_START, nn_instance, eb);
3401a996:	683b      	ldr	r3, [r7, #0]
3401a998:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401a99a:	687a      	ldr	r2, [r7, #4]
3401a99c:	6839      	ldr	r1, [r7, #0]
3401a99e:	2000      	movs	r0, #0
3401a9a0:	4798      	blx	r3

  /* Is it the first epoch block in an AtoNN epoch? */
  if (EpochBlock_IsEpochStart(eb))
3401a9a2:	6878      	ldr	r0, [r7, #4]
3401a9a4:	f7ff fde5 	bl	3401a572 <EpochBlock_IsEpochStart>
3401a9a8:	4603      	mov	r3, r0
3401a9aa:	2b00      	cmp	r3, #0
3401a9ac:	d002      	beq.n	3401a9b4 <__LL_ATON_RT_ExecStartEpochBlock+0x44>
  {
    __LL_ATON_RT_Start_AtoNN_Epoch(nn_instance);
3401a9ae:	6838      	ldr	r0, [r7, #0]
3401a9b0:	f7ff fede 	bl	3401a770 <__LL_ATON_RT_Start_AtoNN_Epoch>
  }

  /* Grab ATON IP lock in case not a pure SW or internal epoch */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401a9b4:	6878      	ldr	r0, [r7, #4]
3401a9b6:	f7ff fe02 	bl	3401a5be <EpochBlock_IsEpochPureHW>
3401a9ba:	4603      	mov	r3, r0
3401a9bc:	2b00      	cmp	r3, #0
3401a9be:	d105      	bne.n	3401a9cc <__LL_ATON_RT_ExecStartEpochBlock+0x5c>
      EpochBlock_IsEpochHybrid(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401a9c0:	6878      	ldr	r0, [r7, #4]
3401a9c2:	f7ff fe0f 	bl	3401a5e4 <EpochBlock_IsEpochHybrid>
3401a9c6:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401a9c8:	2b00      	cmp	r3, #0
3401a9ca:	d002      	beq.n	3401a9d2 <__LL_ATON_RT_ExecStartEpochBlock+0x62>
  {
    __ll_set_aton_owner(nn_instance);
3401a9cc:	6838      	ldr	r0, [r7, #0]
3401a9ce:	f7ff fe6b 	bl	3401a6a8 <__ll_set_aton_owner>
  }

  if (!EpochBlock_IsEpochBlob(eb))
3401a9d2:	6878      	ldr	r0, [r7, #4]
3401a9d4:	f7ff fde0 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401a9d8:	4603      	mov	r3, r0
3401a9da:	f083 0301 	eor.w	r3, r3, #1
3401a9de:	b2db      	uxtb	r3, r3
3401a9e0:	2b00      	cmp	r3, #0
3401a9e2:	d01c      	beq.n	3401aa1e <__LL_ATON_RT_ExecStartEpochBlock+0xae>
  { // standard epoch block handling based on streaming engines
    /* set wait mask(s) in interrupt controller */
    if (EpochBlock_IsEpochPureHW(eb) || EpochBlock_IsEpochInternal(eb))
3401a9e4:	6878      	ldr	r0, [r7, #4]
3401a9e6:	f7ff fdea 	bl	3401a5be <EpochBlock_IsEpochPureHW>
3401a9ea:	4603      	mov	r3, r0
3401a9ec:	2b00      	cmp	r3, #0
3401a9ee:	d105      	bne.n	3401a9fc <__LL_ATON_RT_ExecStartEpochBlock+0x8c>
3401a9f0:	6878      	ldr	r0, [r7, #4]
3401a9f2:	f7ff fe0a 	bl	3401a60a <EpochBlock_IsEpochInternal>
3401a9f6:	4603      	mov	r3, r0
3401a9f8:	2b00      	cmp	r3, #0
3401a9fa:	d014      	beq.n	3401aa26 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
    {
      LL_ATON_ASSERT(__ll_current_aton_ip_owner == nn_instance);
3401a9fc:	4b2e      	ldr	r3, [pc, #184]	@ (3401aab8 <__LL_ATON_RT_ExecStartEpochBlock+0x148>)
3401a9fe:	681b      	ldr	r3, [r3, #0]
3401aa00:	683a      	ldr	r2, [r7, #0]
3401aa02:	429a      	cmp	r2, r3
3401aa04:	d005      	beq.n	3401aa12 <__LL_ATON_RT_ExecStartEpochBlock+0xa2>
3401aa06:	4b2d      	ldr	r3, [pc, #180]	@ (3401aabc <__LL_ATON_RT_ExecStartEpochBlock+0x14c>)
3401aa08:	4a29      	ldr	r2, [pc, #164]	@ (3401aab0 <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401aa0a:	2176      	movs	r1, #118	@ 0x76
3401aa0c:	4829      	ldr	r0, [pc, #164]	@ (3401aab4 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401aa0e:	f00b f9ab 	bl	34025d68 <__assert_func>
      __LL_ATON_RT_SetWaitMask(eb->wait_mask);
3401aa12:	687b      	ldr	r3, [r7, #4]
3401aa14:	68db      	ldr	r3, [r3, #12]
3401aa16:	4618      	mov	r0, r3
3401aa18:	f7ff fece 	bl	3401a7b8 <__LL_ATON_RT_SetWaitMask>
3401aa1c:	e003      	b.n	3401aa26 <__LL_ATON_RT_ExecStartEpochBlock+0xb6>
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM) &&                                                                                     \
    (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC) // Polling mode is not allowed/supported when using the epoch controller
    /* reset wait mask(s) in interrupt controller, but ignore stream engine completion event interrupts */
    __LL_ATON_RT_SetWaitMask(ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0));
3401aa1e:	f240 30ff 	movw	r0, #1023	@ 0x3ff
3401aa22:	f7ff fec9 	bl	3401a7b8 <__LL_ATON_RT_SetWaitMask>
#endif // LL_ATON_HAVE_FFLUSH
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM || LL_ATON_RT_POLLING
  }

  if (eb->start_epoch_block != NULL)
3401aa26:	687b      	ldr	r3, [r7, #4]
3401aa28:	681b      	ldr	r3, [r3, #0]
3401aa2a:	2b00      	cmp	r3, #0
3401aa2c:	d003      	beq.n	3401aa36 <__LL_ATON_RT_ExecStartEpochBlock+0xc6>
  {
    /* start epoch block */
    eb->start_epoch_block((const void *)eb);
3401aa2e:	687b      	ldr	r3, [r7, #4]
3401aa30:	681b      	ldr	r3, [r3, #0]
3401aa32:	6878      	ldr	r0, [r7, #4]
3401aa34:	4798      	blx	r3
  }

  if (EpochBlock_IsEpochBlob(eb))
3401aa36:	6878      	ldr	r0, [r7, #4]
3401aa38:	f7ff fdae 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401aa3c:	4603      	mov	r3, r0
3401aa3e:	2b00      	cmp	r3, #0
3401aa40:	d026      	beq.n	3401aa90 <__LL_ATON_RT_ExecStartEpochBlock+0x120>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* configure epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401aa42:	6878      	ldr	r0, [r7, #4]
3401aa44:	f7ff fdf4 	bl	3401a630 <EpochBlock_EpochControllerUnit>
3401aa48:	6178      	str	r0, [r7, #20]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401aa4a:	697b      	ldr	r3, [r7, #20]
3401aa4c:	2b00      	cmp	r3, #0
3401aa4e:	d005      	beq.n	3401aa5c <__LL_ATON_RT_ExecStartEpochBlock+0xec>
3401aa50:	4b1b      	ldr	r3, [pc, #108]	@ (3401aac0 <__LL_ATON_RT_ExecStartEpochBlock+0x150>)
3401aa52:	4a17      	ldr	r2, [pc, #92]	@ (3401aab0 <__LL_ATON_RT_ExecStartEpochBlock+0x140>)
3401aa54:	2197      	movs	r1, #151	@ 0x97
3401aa56:	4817      	ldr	r0, [pc, #92]	@ (3401aab4 <__LL_ATON_RT_ExecStartEpochBlock+0x144>)
3401aa58:	f00b f986 	bl	34025d68 <__assert_func>

    LL_EpochCtrl_InitTypeDef conf;
    conf.stepmode = 0;
3401aa5c:	7b3b      	ldrb	r3, [r7, #12]
3401aa5e:	f023 0301 	bic.w	r3, r3, #1
3401aa62:	733b      	strb	r3, [r7, #12]
    conf.blobaddr = EpochBlock_EpochBlobAddr(eb);
3401aa64:	6878      	ldr	r0, [r7, #4]
3401aa66:	f7ff fe01 	bl	3401a66c <EpochBlock_EpochBlobAddr>
3401aa6a:	4603      	mov	r3, r0
3401aa6c:	60bb      	str	r3, [r7, #8]

    LL_EpochCtrl_Init(ecId, &conf);
3401aa6e:	697b      	ldr	r3, [r7, #20]
3401aa70:	f107 0208 	add.w	r2, r7, #8
3401aa74:	4611      	mov	r1, r2
3401aa76:	4618      	mov	r0, r3
3401aa78:	f7ff fb8a 	bl	3401a190 <LL_EpochCtrl_Init>

    /* start/enable epoch controller */
    ATON_ENABLE(EPOCHCTRL, ecId);
3401aa7c:	4b11      	ldr	r3, [pc, #68]	@ (3401aac4 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401aa7e:	681b      	ldr	r3, [r3, #0]
3401aa80:	613b      	str	r3, [r7, #16]
3401aa82:	693b      	ldr	r3, [r7, #16]
3401aa84:	f043 0301 	orr.w	r3, r3, #1
3401aa88:	613b      	str	r3, [r7, #16]
3401aa8a:	4a0e      	ldr	r2, [pc, #56]	@ (3401aac4 <__LL_ATON_RT_ExecStartEpochBlock+0x154>)
3401aa8c:	693b      	ldr	r3, [r7, #16]
3401aa8e:	6013      	str	r3, [r2, #0]
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401aa90:	683b      	ldr	r3, [r7, #0]
3401aa92:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401aa94:	2b00      	cmp	r3, #0
3401aa96:	d005      	beq.n	3401aaa4 <__LL_ATON_RT_ExecStartEpochBlock+0x134>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_START, nn_instance, eb);
3401aa98:	683b      	ldr	r3, [r7, #0]
3401aa9a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401aa9c:	687a      	ldr	r2, [r7, #4]
3401aa9e:	6839      	ldr	r1, [r7, #0]
3401aaa0:	2001      	movs	r0, #1
3401aaa2:	4798      	blx	r3
}
3401aaa4:	bf00      	nop
3401aaa6:	3718      	adds	r7, #24
3401aaa8:	46bd      	mov	sp, r7
3401aaaa:	bd80      	pop	{r7, pc}
3401aaac:	3402afa4 	.word	0x3402afa4
3401aab0:	3402bff0 	.word	0x3402bff0
3401aab4:	3402afdc 	.word	0x3402afdc
3401aab8:	3404a2a8 	.word	0x3404a2a8
3401aabc:	3402b020 	.word	0x3402b020
3401aac0:	3402b04c 	.word	0x3402b04c
3401aac4:	580fe000 	.word	0x580fe000

3401aac8 <__LL_ATON_RT_ExecEndEpochBlock>:

static inline void __LL_ATON_RT_ExecEndEpochBlock(const LL_ATON_RT_EpochBlockItem_t *eb,
                                                  NN_Instance_TypeDef *nn_instance)
{
3401aac8:	b580      	push	{r7, lr}
3401aaca:	b084      	sub	sp, #16
3401aacc:	af00      	add	r7, sp, #0
3401aace:	6078      	str	r0, [r7, #4]
3401aad0:	6039      	str	r1, [r7, #0]
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401aad2:	683b      	ldr	r3, [r7, #0]
3401aad4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401aad6:	2b00      	cmp	r3, #0
3401aad8:	d005      	beq.n	3401aae6 <__LL_ATON_RT_ExecEndEpochBlock+0x1e>
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_PRE_END, nn_instance, eb);
3401aada:	683b      	ldr	r3, [r7, #0]
3401aadc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401aade:	687a      	ldr	r2, [r7, #4]
3401aae0:	6839      	ldr	r1, [r7, #0]
3401aae2:	2002      	movs	r0, #2
3401aae4:	4798      	blx	r3

  if (EpochBlock_IsEpochBlob(eb))
3401aae6:	6878      	ldr	r0, [r7, #4]
3401aae8:	f7ff fd56 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401aaec:	4603      	mov	r3, r0
3401aaee:	2b00      	cmp	r3, #0
3401aaf0:	d033      	beq.n	3401ab5a <__LL_ATON_RT_ExecEndEpochBlock+0x92>
  {
#if defined(ATON_EPOCHCTRL_NUM)
    /* stop/disable epoch controller */
    uint32_t ecId = EpochBlock_EpochControllerUnit(eb);
3401aaf2:	6878      	ldr	r0, [r7, #4]
3401aaf4:	f7ff fd9c 	bl	3401a630 <EpochBlock_EpochControllerUnit>
3401aaf8:	60f8      	str	r0, [r7, #12]
    LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401aafa:	68fb      	ldr	r3, [r7, #12]
3401aafc:	2b00      	cmp	r3, #0
3401aafe:	d005      	beq.n	3401ab0c <__LL_ATON_RT_ExecEndEpochBlock+0x44>
3401ab00:	4b48      	ldr	r3, [pc, #288]	@ (3401ac24 <__LL_ATON_RT_ExecEndEpochBlock+0x15c>)
3401ab02:	4a49      	ldr	r2, [pc, #292]	@ (3401ac28 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401ab04:	21b5      	movs	r1, #181	@ 0xb5
3401ab06:	4849      	ldr	r0, [pc, #292]	@ (3401ac2c <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401ab08:	f00b f92e 	bl	34025d68 <__assert_func>
    uint32_t t;
    ATON_DISABLE_CLR_CONFCLR(EPOCHCTRL, ecId);
3401ab0c:	2300      	movs	r3, #0
3401ab0e:	60bb      	str	r3, [r7, #8]
3401ab10:	68bb      	ldr	r3, [r7, #8]
3401ab12:	f023 0301 	bic.w	r3, r3, #1
3401ab16:	60bb      	str	r3, [r7, #8]
3401ab18:	68bb      	ldr	r3, [r7, #8]
3401ab1a:	f043 0302 	orr.w	r3, r3, #2
3401ab1e:	60bb      	str	r3, [r7, #8]
3401ab20:	4a43      	ldr	r2, [pc, #268]	@ (3401ac30 <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ab22:	68bb      	ldr	r3, [r7, #8]
3401ab24:	6013      	str	r3, [r2, #0]
3401ab26:	4b42      	ldr	r3, [pc, #264]	@ (3401ac30 <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ab28:	681b      	ldr	r3, [r3, #0]
3401ab2a:	f003 0302 	and.w	r3, r3, #2
3401ab2e:	2b00      	cmp	r3, #0
3401ab30:	d1f9      	bne.n	3401ab26 <__LL_ATON_RT_ExecEndEpochBlock+0x5e>
3401ab32:	2300      	movs	r3, #0
3401ab34:	60bb      	str	r3, [r7, #8]
3401ab36:	68bb      	ldr	r3, [r7, #8]
3401ab38:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401ab3c:	60bb      	str	r3, [r7, #8]
3401ab3e:	4a3c      	ldr	r2, [pc, #240]	@ (3401ac30 <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ab40:	68bb      	ldr	r3, [r7, #8]
3401ab42:	6013      	str	r3, [r2, #0]
3401ab44:	4b3a      	ldr	r3, [pc, #232]	@ (3401ac30 <__LL_ATON_RT_ExecEndEpochBlock+0x168>)
3401ab46:	681b      	ldr	r3, [r3, #0]
3401ab48:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401ab4c:	2b00      	cmp	r3, #0
3401ab4e:	d1f9      	bne.n	3401ab44 <__LL_ATON_RT_ExecEndEpochBlock+0x7c>

    /* disable epoch controller clock */
    LL_ATON_DisableClock(ATON_EPOCHCTRL_CLKB_CLK(ecId));
3401ab50:	68fb      	ldr	r3, [r7, #12]
3401ab52:	3319      	adds	r3, #25
3401ab54:	4618      	mov	r0, r3
3401ab56:	f7ff fb81 	bl	3401a25c <LL_ATON_DisableClock>
#else  // !ATON_EPOCHCTRL_NUM
    LL_ATON_ASSERT(false); // may never happen
#endif // !ATON_EPOCHCTRL_NUM
  }

  if (eb->end_epoch_block != NULL)
3401ab5a:	687b      	ldr	r3, [r7, #4]
3401ab5c:	685b      	ldr	r3, [r3, #4]
3401ab5e:	2b00      	cmp	r3, #0
3401ab60:	d003      	beq.n	3401ab6a <__LL_ATON_RT_ExecEndEpochBlock+0xa2>
  {
    eb->end_epoch_block((const void *)eb);
3401ab62:	687b      	ldr	r3, [r7, #4]
3401ab64:	685b      	ldr	r3, [r3, #4]
3401ab66:	6878      	ldr	r0, [r7, #4]
3401ab68:	4798      	blx	r3
  }

  /* Reset wait mask */
  if (EpochBlock_IsEpochPureHW(eb) ||
3401ab6a:	6878      	ldr	r0, [r7, #4]
3401ab6c:	f7ff fd27 	bl	3401a5be <EpochBlock_IsEpochPureHW>
3401ab70:	4603      	mov	r3, r0
3401ab72:	2b00      	cmp	r3, #0
3401ab74:	d105      	bne.n	3401ab82 <__LL_ATON_RT_ExecEndEpochBlock+0xba>
      EpochBlock_IsEpochInternal(eb)) // epoch blobs are flagged as pure HW, so checking for epoch blob is not necessary
3401ab76:	6878      	ldr	r0, [r7, #4]
3401ab78:	f7ff fd47 	bl	3401a60a <EpochBlock_IsEpochInternal>
3401ab7c:	4603      	mov	r3, r0
  if (EpochBlock_IsEpochPureHW(eb) ||
3401ab7e:	2b00      	cmp	r3, #0
3401ab80:	d00d      	beq.n	3401ab9e <__LL_ATON_RT_ExecEndEpochBlock+0xd6>
  {
    LL_ATON_ASSERT(nn_instance == __ll_current_aton_ip_owner);
3401ab82:	4b2c      	ldr	r3, [pc, #176]	@ (3401ac34 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401ab84:	681b      	ldr	r3, [r3, #0]
3401ab86:	683a      	ldr	r2, [r7, #0]
3401ab88:	429a      	cmp	r2, r3
3401ab8a:	d005      	beq.n	3401ab98 <__LL_ATON_RT_ExecEndEpochBlock+0xd0>
3401ab8c:	4b2a      	ldr	r3, [pc, #168]	@ (3401ac38 <__LL_ATON_RT_ExecEndEpochBlock+0x170>)
3401ab8e:	4a26      	ldr	r2, [pc, #152]	@ (3401ac28 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401ab90:	21c9      	movs	r1, #201	@ 0xc9
3401ab92:	4826      	ldr	r0, [pc, #152]	@ (3401ac2c <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401ab94:	f00b f8e8 	bl	34025d68 <__assert_func>
    __LL_ATON_RT_SetWaitMask(0);
3401ab98:	2000      	movs	r0, #0
3401ab9a:	f7ff fe0d 	bl	3401a7b8 <__LL_ATON_RT_SetWaitMask>
  }

  /* Release ATON IP unlock in case it's a pure HW epoch */
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401ab9e:	6878      	ldr	r0, [r7, #4]
3401aba0:	f7ff fd0d 	bl	3401a5be <EpochBlock_IsEpochPureHW>
3401aba4:	4603      	mov	r3, r0
3401aba6:	2b00      	cmp	r3, #0
3401aba8:	d113      	bne.n	3401abd2 <__LL_ATON_RT_ExecEndEpochBlock+0x10a>
3401abaa:	6878      	ldr	r0, [r7, #4]
3401abac:	f7ff fd1a 	bl	3401a5e4 <EpochBlock_IsEpochHybrid>
3401abb0:	4603      	mov	r3, r0
3401abb2:	2b00      	cmp	r3, #0
3401abb4:	d105      	bne.n	3401abc2 <__LL_ATON_RT_ExecEndEpochBlock+0xfa>
3401abb6:	6878      	ldr	r0, [r7, #4]
3401abb8:	f7ff fd27 	bl	3401a60a <EpochBlock_IsEpochInternal>
3401abbc:	4603      	mov	r3, r0
3401abbe:	2b00      	cmp	r3, #0
3401abc0:	d00a      	beq.n	3401abd8 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401abc2:	683b      	ldr	r3, [r7, #0]
3401abc4:	691b      	ldr	r3, [r3, #16]
  if (EpochBlock_IsEpochPureHW(eb) || ((EpochBlock_IsEpochHybrid(eb) || EpochBlock_IsEpochInternal(eb)) &&
3401abc6:	2b00      	cmp	r3, #0
3401abc8:	d106      	bne.n	3401abd8 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                       (nn_instance->exec_state.next_epoch_block ==
3401abca:	683b      	ldr	r3, [r7, #0]
3401abcc:	68db      	ldr	r3, [r3, #12]
                                       (nn_instance->exec_state.saved_current_epoch_block == NULL) &&
3401abce:	2b00      	cmp	r3, #0
3401abd0:	d102      	bne.n	3401abd8 <__LL_ATON_RT_ExecEndEpochBlock+0x110>
                                        NULL))) /* hybrid has finished after that last part has been executed in SW */
  {
    __ll_clear_aton_owner(nn_instance);
3401abd2:	6838      	ldr	r0, [r7, #0]
3401abd4:	f7ff fda0 	bl	3401a718 <__ll_clear_aton_owner>
  }
  LL_ATON_ASSERT(EpochBlock_IsEpochInternal(eb) || EpochBlock_IsEpochHybrid(eb) ||
3401abd8:	6878      	ldr	r0, [r7, #4]
3401abda:	f7ff fd16 	bl	3401a60a <EpochBlock_IsEpochInternal>
3401abde:	4603      	mov	r3, r0
3401abe0:	2b00      	cmp	r3, #0
3401abe2:	d110      	bne.n	3401ac06 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401abe4:	6878      	ldr	r0, [r7, #4]
3401abe6:	f7ff fcfd 	bl	3401a5e4 <EpochBlock_IsEpochHybrid>
3401abea:	4603      	mov	r3, r0
3401abec:	2b00      	cmp	r3, #0
3401abee:	d10a      	bne.n	3401ac06 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401abf0:	4b10      	ldr	r3, [pc, #64]	@ (3401ac34 <__LL_ATON_RT_ExecEndEpochBlock+0x16c>)
3401abf2:	681b      	ldr	r3, [r3, #0]
3401abf4:	683a      	ldr	r2, [r7, #0]
3401abf6:	429a      	cmp	r2, r3
3401abf8:	d105      	bne.n	3401ac06 <__LL_ATON_RT_ExecEndEpochBlock+0x13e>
3401abfa:	4b10      	ldr	r3, [pc, #64]	@ (3401ac3c <__LL_ATON_RT_ExecEndEpochBlock+0x174>)
3401abfc:	4a0a      	ldr	r2, [pc, #40]	@ (3401ac28 <__LL_ATON_RT_ExecEndEpochBlock+0x160>)
3401abfe:	21d5      	movs	r1, #213	@ 0xd5
3401ac00:	480a      	ldr	r0, [pc, #40]	@ (3401ac2c <__LL_ATON_RT_ExecEndEpochBlock+0x164>)
3401ac02:	f00b f8b1 	bl	34025d68 <__assert_func>
                 (__ll_current_aton_ip_owner != nn_instance));

  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ac06:	683b      	ldr	r3, [r7, #0]
3401ac08:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ac0a:	2b00      	cmp	r3, #0
3401ac0c:	d005      	beq.n	3401ac1a <__LL_ATON_RT_ExecEndEpochBlock+0x152>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_POST_END, nn_instance, eb);
3401ac0e:	683b      	ldr	r3, [r7, #0]
3401ac10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ac12:	687a      	ldr	r2, [r7, #4]
3401ac14:	6839      	ldr	r1, [r7, #0]
3401ac16:	2003      	movs	r0, #3
3401ac18:	4798      	blx	r3
  }
}
3401ac1a:	bf00      	nop
3401ac1c:	3710      	adds	r7, #16
3401ac1e:	46bd      	mov	sp, r7
3401ac20:	bd80      	pop	{r7, pc}
3401ac22:	bf00      	nop
3401ac24:	3402b04c 	.word	0x3402b04c
3401ac28:	3402c0a0 	.word	0x3402c0a0
3401ac2c:	3402afdc 	.word	0x3402afdc
3401ac30:	580fe000 	.word	0x580fe000
3401ac34:	3404a2a8 	.word	0x3404a2a8
3401ac38:	3402b058 	.word	0x3402b058
3401ac3c:	3402b084 	.word	0x3402b084

3401ac40 <__LL_ATON_RT_DetermineNextEpochBlock>:

static void __LL_ATON_RT_DetermineNextEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401ac40:	b580      	push	{r7, lr}
3401ac42:	b082      	sub	sp, #8
3401ac44:	af00      	add	r7, sp, #0
3401ac46:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401ac48:	687b      	ldr	r3, [r7, #4]
3401ac4a:	2b00      	cmp	r3, #0
3401ac4c:	d105      	bne.n	3401ac5a <__LL_ATON_RT_DetermineNextEpochBlock+0x1a>
3401ac4e:	4b26      	ldr	r3, [pc, #152]	@ (3401ace8 <__LL_ATON_RT_DetermineNextEpochBlock+0xa8>)
3401ac50:	4a26      	ldr	r2, [pc, #152]	@ (3401acec <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401ac52:	21e0      	movs	r1, #224	@ 0xe0
3401ac54:	4826      	ldr	r0, [pc, #152]	@ (3401acf0 <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401ac56:	f00b f887 	bl	34025d68 <__assert_func>
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(nn_instance->exec_state.triggered_events ==
3401ac5a:	687b      	ldr	r3, [r7, #4]
3401ac5c:	69db      	ldr	r3, [r3, #28]
3401ac5e:	2b00      	cmp	r3, #0
3401ac60:	d005      	beq.n	3401ac6e <__LL_ATON_RT_DetermineNextEpochBlock+0x2e>
3401ac62:	4b24      	ldr	r3, [pc, #144]	@ (3401acf4 <__LL_ATON_RT_DetermineNextEpochBlock+0xb4>)
3401ac64:	4a21      	ldr	r2, [pc, #132]	@ (3401acec <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401ac66:	21e2      	movs	r1, #226	@ 0xe2
3401ac68:	4821      	ldr	r0, [pc, #132]	@ (3401acf0 <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401ac6a:	f00b f87d 	bl	34025d68 <__assert_func>
                 0x0); // with the removal of parallel SW/HW epochs execution all triggered events must have been
                       // cleared at this point in time!
#endif                 // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /* Determine if there is a new inserted epoch block array */
  if ((nn_instance->exec_state.next_epoch_block != NULL))
3401ac6e:	687b      	ldr	r3, [r7, #4]
3401ac70:	68db      	ldr	r3, [r3, #12]
3401ac72:	2b00      	cmp	r3, #0
3401ac74:	d029      	beq.n	3401acca <__LL_ATON_RT_DetermineNextEpochBlock+0x8a>
  {
    LL_ATON_ASSERT(nn_instance->exec_state.saved_current_epoch_block == NULL);
3401ac76:	687b      	ldr	r3, [r7, #4]
3401ac78:	691b      	ldr	r3, [r3, #16]
3401ac7a:	2b00      	cmp	r3, #0
3401ac7c:	d005      	beq.n	3401ac8a <__LL_ATON_RT_DetermineNextEpochBlock+0x4a>
3401ac7e:	4b1e      	ldr	r3, [pc, #120]	@ (3401acf8 <__LL_ATON_RT_DetermineNextEpochBlock+0xb8>)
3401ac80:	4a1a      	ldr	r2, [pc, #104]	@ (3401acec <__LL_ATON_RT_DetermineNextEpochBlock+0xac>)
3401ac82:	21ea      	movs	r1, #234	@ 0xea
3401ac84:	481a      	ldr	r0, [pc, #104]	@ (3401acf0 <__LL_ATON_RT_DetermineNextEpochBlock+0xb0>)
3401ac86:	f00b f86f 	bl	34025d68 <__assert_func>

    /* save current context */
    nn_instance->exec_state.saved_current_epoch_block = nn_instance->exec_state.current_epoch_block;
3401ac8a:	687b      	ldr	r3, [r7, #4]
3401ac8c:	685a      	ldr	r2, [r3, #4]
3401ac8e:	687b      	ldr	r3, [r7, #4]
3401ac90:	611a      	str	r2, [r3, #16]
    nn_instance->exec_state.saved_first_epoch_block = nn_instance->exec_state.first_epoch_block;
3401ac92:	687b      	ldr	r3, [r7, #4]
3401ac94:	689a      	ldr	r2, [r3, #8]
3401ac96:	687b      	ldr	r3, [r7, #4]
3401ac98:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
    nn_instance->exec_state.saved_nr_of_epoch_blocks = nn_instance->exec_state.nr_of_epoch_blocks;
3401ac9a:	687b      	ldr	r3, [r7, #4]
3401ac9c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401ac9e:	687b      	ldr	r3, [r7, #4]
3401aca0:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

    /* set new context */
    nn_instance->exec_state.current_epoch_block = nn_instance->exec_state.next_epoch_block;
3401aca2:	687b      	ldr	r3, [r7, #4]
3401aca4:	68da      	ldr	r2, [r3, #12]
3401aca6:	687b      	ldr	r3, [r7, #4]
3401aca8:	605a      	str	r2, [r3, #4]
    nn_instance->exec_state.first_epoch_block = nn_instance->exec_state.next_epoch_block;
3401acaa:	687b      	ldr	r3, [r7, #4]
3401acac:	68da      	ldr	r2, [r3, #12]
3401acae:	687b      	ldr	r3, [r7, #4]
3401acb0:	609a      	str	r2, [r3, #8]
#ifndef NDEBUG
    nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.first_epoch_block);
3401acb2:	687b      	ldr	r3, [r7, #4]
3401acb4:	689b      	ldr	r3, [r3, #8]
3401acb6:	4618      	mov	r0, r3
3401acb8:	f7ff fe39 	bl	3401a92e <__LL_ATON_RT_CntEpochBlocks>
3401acbc:	4602      	mov	r2, r0
3401acbe:	687b      	ldr	r3, [r7, #4]
3401acc0:	625a      	str	r2, [r3, #36]	@ 0x24
#endif

    /* reset next epoch block */
    nn_instance->exec_state.next_epoch_block = NULL;
3401acc2:	687b      	ldr	r3, [r7, #4]
3401acc4:	2200      	movs	r2, #0
3401acc6:	60da      	str	r2, [r3, #12]
3401acc8:	e005      	b.n	3401acd6 <__LL_ATON_RT_DetermineNextEpochBlock+0x96>
  }
  else
  {
    nn_instance->exec_state.current_epoch_block++;
3401acca:	687b      	ldr	r3, [r7, #4]
3401accc:	685b      	ldr	r3, [r3, #4]
3401acce:	f103 0214 	add.w	r2, r3, #20
3401acd2:	687b      	ldr	r3, [r7, #4]
3401acd4:	605a      	str	r2, [r3, #4]
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.current_epoch_block_started = false;
3401acd6:	687b      	ldr	r3, [r7, #4]
3401acd8:	2200      	movs	r2, #0
3401acda:	f883 2020 	strb.w	r2, [r3, #32]
#endif
}
3401acde:	bf00      	nop
3401ace0:	3708      	adds	r7, #8
3401ace2:	46bd      	mov	sp, r7
3401ace4:	bd80      	pop	{r7, pc}
3401ace6:	bf00      	nop
3401ace8:	3402ae28 	.word	0x3402ae28
3401acec:	3402bf54 	.word	0x3402bf54
3401acf0:	3402afdc 	.word	0x3402afdc
3401acf4:	3402ae44 	.word	0x3402ae44
3401acf8:	3402b0f4 	.word	0x3402b0f4

3401acfc <__LL_ATON_RT_GetWaitMask>:

static inline uint32_t __LL_ATON_RT_GetWaitMask(const LL_ATON_RT_EpochBlockItem_t *eb)
{
3401acfc:	b580      	push	{r7, lr}
3401acfe:	b082      	sub	sp, #8
3401ad00:	af00      	add	r7, sp, #0
3401ad02:	6078      	str	r0, [r7, #4]
  if (EpochBlock_IsEpochBlob(eb))
3401ad04:	6878      	ldr	r0, [r7, #4]
3401ad06:	f7ff fc47 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401ad0a:	4603      	mov	r3, r0
3401ad0c:	2b00      	cmp	r3, #0
3401ad0e:	d007      	beq.n	3401ad20 <__LL_ATON_RT_GetWaitMask+0x24>
  {
    // in case of epoch blob `wait_mask` contains unit number of epoch controller to use
    return (1 << EpochBlock_EpochControllerUnit(eb));
3401ad10:	6878      	ldr	r0, [r7, #4]
3401ad12:	f7ff fc8d 	bl	3401a630 <EpochBlock_EpochControllerUnit>
3401ad16:	4603      	mov	r3, r0
3401ad18:	2201      	movs	r2, #1
3401ad1a:	fa02 f303 	lsl.w	r3, r2, r3
3401ad1e:	e001      	b.n	3401ad24 <__LL_ATON_RT_GetWaitMask+0x28>
  }
  else
  {
    return eb->wait_mask; // in case of "normal" epoch block `wait_mask` contains bitmask of (output) stream engines to
3401ad20:	687b      	ldr	r3, [r7, #4]
3401ad22:	68db      	ldr	r3, [r3, #12]
                          // wait for
  }
}
3401ad24:	4618      	mov	r0, r3
3401ad26:	3708      	adds	r7, #8
3401ad28:	46bd      	mov	sp, r7
3401ad2a:	bd80      	pop	{r7, pc}

3401ad2c <__LL_ATON_RT_Init_Network>:

static inline void __LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401ad2c:	b580      	push	{r7, lr}
3401ad2e:	b084      	sub	sp, #16
3401ad30:	af00      	add	r7, sp, #0
3401ad32:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401ad34:	687b      	ldr	r3, [r7, #4]
3401ad36:	2b00      	cmp	r3, #0
3401ad38:	d037      	beq.n	3401adaa <__LL_ATON_RT_Init_Network+0x7e>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401ad3a:	687b      	ldr	r3, [r7, #4]
3401ad3c:	681b      	ldr	r3, [r3, #0]
3401ad3e:	2b00      	cmp	r3, #0
3401ad40:	d035      	beq.n	3401adae <__LL_ATON_RT_Init_Network+0x82>
    return;
  }

  /** Initialize static variables **/
  /* set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = nn_instance->network->epoch_block_items();
3401ad42:	687b      	ldr	r3, [r7, #4]
3401ad44:	681b      	ldr	r3, [r3, #0]
3401ad46:	69db      	ldr	r3, [r3, #28]
3401ad48:	4798      	blx	r3
3401ad4a:	60f8      	str	r0, [r7, #12]
  nn_instance->exec_state.current_epoch_block = eb_list;
3401ad4c:	687b      	ldr	r3, [r7, #4]
3401ad4e:	68fa      	ldr	r2, [r7, #12]
3401ad50:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401ad52:	687b      	ldr	r3, [r7, #4]
3401ad54:	68fa      	ldr	r2, [r7, #12]
3401ad56:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401ad58:	687b      	ldr	r3, [r7, #4]
3401ad5a:	2200      	movs	r2, #0
3401ad5c:	60da      	str	r2, [r3, #12]

  /* set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401ad5e:	687b      	ldr	r3, [r7, #4]
3401ad60:	2200      	movs	r2, #0
3401ad62:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401ad64:	687b      	ldr	r3, [r7, #4]
3401ad66:	2200      	movs	r2, #0
3401ad68:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = __LL_ATON_RT_CntEpochBlocks(nn_instance->exec_state.current_epoch_block);
3401ad6a:	687b      	ldr	r3, [r7, #4]
3401ad6c:	685b      	ldr	r3, [r3, #4]
3401ad6e:	4618      	mov	r0, r3
3401ad70:	f7ff fddd 	bl	3401a92e <__LL_ATON_RT_CntEpochBlocks>
3401ad74:	4602      	mov	r2, r0
3401ad76:	687b      	ldr	r3, [r7, #4]
3401ad78:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401ad7a:	687b      	ldr	r3, [r7, #4]
3401ad7c:	2200      	movs	r2, #0
3401ad7e:	629a      	str	r2, [r3, #40]	@ 0x28
#endif

  /* set information about running inference */
  nn_instance->exec_state.inference_started = false;
3401ad80:	687b      	ldr	r3, [r7, #4]
3401ad82:	2200      	movs	r2, #0
3401ad84:	761a      	strb	r2, [r3, #24]

  /* set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401ad86:	687b      	ldr	r3, [r7, #4]
3401ad88:	2200      	movs	r2, #0
3401ad8a:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401ad8c:	687b      	ldr	r3, [r7, #4]
3401ad8e:	2200      	movs	r2, #0
3401ad90:	f883 2020 	strb.w	r2, [r3, #32]
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_Init` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ad94:	687b      	ldr	r3, [r7, #4]
3401ad96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ad98:	2b00      	cmp	r3, #0
3401ad9a:	d009      	beq.n	3401adb0 <__LL_ATON_RT_Init_Network+0x84>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_Init, nn_instance, NULL);
3401ad9c:	687b      	ldr	r3, [r7, #4]
3401ad9e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ada0:	2200      	movs	r2, #0
3401ada2:	6879      	ldr	r1, [r7, #4]
3401ada4:	2004      	movs	r0, #4
3401ada6:	4798      	blx	r3
3401ada8:	e002      	b.n	3401adb0 <__LL_ATON_RT_Init_Network+0x84>
    return;
3401adaa:	bf00      	nop
3401adac:	e000      	b.n	3401adb0 <__LL_ATON_RT_Init_Network+0x84>
    return;
3401adae:	bf00      	nop
  }
}
3401adb0:	3710      	adds	r7, #16
3401adb2:	46bd      	mov	sp, r7
3401adb4:	bd80      	pop	{r7, pc}
	...

3401adb8 <LL_ATON_RT_Init_Network>:
/**
 * @brief Initialize a network instance
 * @param nn_instance Pointer to network instance to initialize
 */
void LL_ATON_RT_Init_Network(NN_Instance_TypeDef *nn_instance)
{
3401adb8:	b580      	push	{r7, lr}
3401adba:	b084      	sub	sp, #16
3401adbc:	af00      	add	r7, sp, #0
3401adbe:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401adc0:	687b      	ldr	r3, [r7, #4]
3401adc2:	2b00      	cmp	r3, #0
3401adc4:	d023      	beq.n	3401ae0e <LL_ATON_RT_Init_Network+0x56>
  {
    return;
  }

  /** Exit if `nn_instance->network` is equal to NULL **/
  if (nn_instance->network == NULL)
3401adc6:	687b      	ldr	r3, [r7, #4]
3401adc8:	681b      	ldr	r3, [r3, #0]
3401adca:	2b00      	cmp	r3, #0
3401adcc:	d021      	beq.n	3401ae12 <LL_ATON_RT_Init_Network+0x5a>
  {
    return;
  }

  /* Care about epoch controller blobs relocation */
  LL_ATON_ASSERT(nn_instance->network->ec_network_init != NULL);
3401adce:	687b      	ldr	r3, [r7, #4]
3401add0:	681b      	ldr	r3, [r3, #0]
3401add2:	685b      	ldr	r3, [r3, #4]
3401add4:	2b00      	cmp	r3, #0
3401add6:	d106      	bne.n	3401ade6 <LL_ATON_RT_Init_Network+0x2e>
3401add8:	4b10      	ldr	r3, [pc, #64]	@ (3401ae1c <LL_ATON_RT_Init_Network+0x64>)
3401adda:	4a11      	ldr	r2, [pc, #68]	@ (3401ae20 <LL_ATON_RT_Init_Network+0x68>)
3401addc:	f44f 71bb 	mov.w	r1, #374	@ 0x176
3401ade0:	4810      	ldr	r0, [pc, #64]	@ (3401ae24 <LL_ATON_RT_Init_Network+0x6c>)
3401ade2:	f00a ffc1 	bl	34025d68 <__assert_func>
  bool ret = nn_instance->network->ec_network_init();
3401ade6:	687b      	ldr	r3, [r7, #4]
3401ade8:	681b      	ldr	r3, [r3, #0]
3401adea:	685b      	ldr	r3, [r3, #4]
3401adec:	4798      	blx	r3
3401adee:	4603      	mov	r3, r0
3401adf0:	73fb      	strb	r3, [r7, #15]
  LL_ATON_ASSERT(ret == true);
3401adf2:	7bfb      	ldrb	r3, [r7, #15]
3401adf4:	2b01      	cmp	r3, #1
3401adf6:	d006      	beq.n	3401ae06 <LL_ATON_RT_Init_Network+0x4e>
3401adf8:	4b0b      	ldr	r3, [pc, #44]	@ (3401ae28 <LL_ATON_RT_Init_Network+0x70>)
3401adfa:	4a09      	ldr	r2, [pc, #36]	@ (3401ae20 <LL_ATON_RT_Init_Network+0x68>)
3401adfc:	f44f 71bc 	mov.w	r1, #376	@ 0x178
3401ae00:	4808      	ldr	r0, [pc, #32]	@ (3401ae24 <LL_ATON_RT_Init_Network+0x6c>)
3401ae02:	f00a ffb1 	bl	34025d68 <__assert_func>
  LL_ATON_LIB_UNUSED(ret);

  /* Call actual network instance initialization */
  __LL_ATON_RT_Init_Network(nn_instance);
3401ae06:	6878      	ldr	r0, [r7, #4]
3401ae08:	f7ff ff90 	bl	3401ad2c <__LL_ATON_RT_Init_Network>
3401ae0c:	e002      	b.n	3401ae14 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401ae0e:	bf00      	nop
3401ae10:	e000      	b.n	3401ae14 <LL_ATON_RT_Init_Network+0x5c>
    return;
3401ae12:	bf00      	nop
}
3401ae14:	3710      	adds	r7, #16
3401ae16:	46bd      	mov	sp, r7
3401ae18:	bd80      	pop	{r7, pc}
3401ae1a:	bf00      	nop
3401ae1c:	3402b138 	.word	0x3402b138
3401ae20:	3402bf7c 	.word	0x3402bf7c
3401ae24:	3402afdc 	.word	0x3402afdc
3401ae28:	3402b170 	.word	0x3402b170

3401ae2c <LL_ATON_RT_DeInit_Network>:
/**
 * @brief De-initialize a network instance
 * @param nn_instance Pointer to network instance to de-initialize
 */
void LL_ATON_RT_DeInit_Network(NN_Instance_TypeDef *nn_instance)
{
3401ae2c:	b580      	push	{r7, lr}
3401ae2e:	b084      	sub	sp, #16
3401ae30:	af00      	add	r7, sp, #0
3401ae32:	6078      	str	r0, [r7, #4]
  /** Exit if `nn_instance` is equal to NULL **/
  if (nn_instance == NULL)
3401ae34:	687b      	ldr	r3, [r7, #4]
3401ae36:	2b00      	cmp	r3, #0
3401ae38:	d030      	beq.n	3401ae9c <LL_ATON_RT_DeInit_Network+0x70>
  {
    return;
  }

  /** Call epoch callback with callback type `LL_ATON_RT_Callbacktype_NN_DeInit` and network instance **/
  if (nn_instance->exec_state.epoch_callback_function != NULL)
3401ae3a:	687b      	ldr	r3, [r7, #4]
3401ae3c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ae3e:	2b00      	cmp	r3, #0
3401ae40:	d005      	beq.n	3401ae4e <LL_ATON_RT_DeInit_Network+0x22>
  {
    nn_instance->exec_state.epoch_callback_function(LL_ATON_RT_Callbacktype_NN_DeInit, nn_instance, NULL);
3401ae42:	687b      	ldr	r3, [r7, #4]
3401ae44:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401ae46:	2200      	movs	r2, #0
3401ae48:	6879      	ldr	r1, [r7, #4]
3401ae4a:	2005      	movs	r0, #5
3401ae4c:	4798      	blx	r3
  }

  /** Re-set ATON IP owner */
  if (nn_instance == __ll_current_aton_ip_owner)
3401ae4e:	4b15      	ldr	r3, [pc, #84]	@ (3401aea4 <LL_ATON_RT_DeInit_Network+0x78>)
3401ae50:	681b      	ldr	r3, [r3, #0]
3401ae52:	687a      	ldr	r2, [r7, #4]
3401ae54:	429a      	cmp	r2, r3
3401ae56:	d102      	bne.n	3401ae5e <LL_ATON_RT_DeInit_Network+0x32>
  { // In case this function gets called while an ATON lib internal EpochBlock (used to implement hybrid epochs) is
    // under execution we might still be owner of the ATON IP
    __ll_clear_aton_owner(nn_instance);
3401ae58:	6878      	ldr	r0, [r7, #4]
3401ae5a:	f7ff fc5d 	bl	3401a718 <__ll_clear_aton_owner>
  }

  /** De-initialize static variables **/
  /* re-set context */
  const LL_ATON_RT_EpochBlockItem_t *eb_list = NULL;
3401ae5e:	2300      	movs	r3, #0
3401ae60:	60fb      	str	r3, [r7, #12]
  nn_instance->exec_state.current_epoch_block = eb_list;
3401ae62:	687b      	ldr	r3, [r7, #4]
3401ae64:	68fa      	ldr	r2, [r7, #12]
3401ae66:	605a      	str	r2, [r3, #4]
  nn_instance->exec_state.first_epoch_block = eb_list;
3401ae68:	687b      	ldr	r3, [r7, #4]
3401ae6a:	68fa      	ldr	r2, [r7, #12]
3401ae6c:	609a      	str	r2, [r3, #8]
  nn_instance->exec_state.next_epoch_block = NULL;
3401ae6e:	687b      	ldr	r3, [r7, #4]
3401ae70:	2200      	movs	r2, #0
3401ae72:	60da      	str	r2, [r3, #12]

  /* re-set saved context */
  nn_instance->exec_state.saved_current_epoch_block = NULL;
3401ae74:	687b      	ldr	r3, [r7, #4]
3401ae76:	2200      	movs	r2, #0
3401ae78:	611a      	str	r2, [r3, #16]
  nn_instance->exec_state.saved_first_epoch_block = NULL;
3401ae7a:	687b      	ldr	r3, [r7, #4]
3401ae7c:	2200      	movs	r2, #0
3401ae7e:	615a      	str	r2, [r3, #20]
#ifndef NDEBUG
  nn_instance->exec_state.nr_of_epoch_blocks = 0;
3401ae80:	687b      	ldr	r3, [r7, #4]
3401ae82:	2200      	movs	r2, #0
3401ae84:	625a      	str	r2, [r3, #36]	@ 0x24
  nn_instance->exec_state.saved_nr_of_epoch_blocks = 0;
3401ae86:	687b      	ldr	r3, [r7, #4]
3401ae88:	2200      	movs	r2, #0
3401ae8a:	629a      	str	r2, [r3, #40]	@ 0x28

  /* intentional do not re-set information about running inference `nn_instance->exec_state.inference_started` */

  /* re-set asynchronous status variables */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  nn_instance->exec_state.triggered_events = 0x0;
3401ae8c:	687b      	ldr	r3, [r7, #4]
3401ae8e:	2200      	movs	r2, #0
3401ae90:	61da      	str	r2, [r3, #28]
  nn_instance->exec_state.current_epoch_block_started = false;
3401ae92:	687b      	ldr	r3, [r7, #4]
3401ae94:	2200      	movs	r2, #0
3401ae96:	f883 2020 	strb.w	r2, [r3, #32]
3401ae9a:	e000      	b.n	3401ae9e <LL_ATON_RT_DeInit_Network+0x72>
    return;
3401ae9c:	bf00      	nop
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
}
3401ae9e:	3710      	adds	r7, #16
3401aea0:	46bd      	mov	sp, r7
3401aea2:	bd80      	pop	{r7, pc}
3401aea4:	3404a2a8 	.word	0x3404a2a8

3401aea8 <LL_ATON_RT_RuntimeInit>:

/**
 * @brief Initialize the ATON runtime
 */
void LL_ATON_RT_RuntimeInit(void)
{
3401aea8:	b580      	push	{r7, lr}
3401aeaa:	b082      	sub	sp, #8
3401aeac:	af00      	add	r7, sp, #0
  /** Initialize ATON IPs **/
  LL_ATON_Init();
3401aeae:	f7fe fb6f 	bl	34019590 <LL_ATON_Init>
  /** Initialize IRQ Context **/
  {
    uint32_t t;

    /* Disable & Clear interrupt controller */
    ATON_DISABLE_CLR_CONFCLR(INTCTRL, 0);
3401aeb2:	2300      	movs	r3, #0
3401aeb4:	607b      	str	r3, [r7, #4]
3401aeb6:	687b      	ldr	r3, [r7, #4]
3401aeb8:	f023 0301 	bic.w	r3, r3, #1
3401aebc:	607b      	str	r3, [r7, #4]
3401aebe:	687b      	ldr	r3, [r7, #4]
3401aec0:	f043 0302 	orr.w	r3, r3, #2
3401aec4:	607b      	str	r3, [r7, #4]
3401aec6:	4a23      	ldr	r2, [pc, #140]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401aec8:	687b      	ldr	r3, [r7, #4]
3401aeca:	6013      	str	r3, [r2, #0]
3401aecc:	4b21      	ldr	r3, [pc, #132]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401aece:	681b      	ldr	r3, [r3, #0]
3401aed0:	f003 0302 	and.w	r3, r3, #2
3401aed4:	2b00      	cmp	r3, #0
3401aed6:	d1f9      	bne.n	3401aecc <LL_ATON_RT_RuntimeInit+0x24>
3401aed8:	2300      	movs	r3, #0
3401aeda:	607b      	str	r3, [r7, #4]
3401aedc:	687b      	ldr	r3, [r7, #4]
3401aede:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
3401aee2:	607b      	str	r3, [r7, #4]
3401aee4:	4a1b      	ldr	r2, [pc, #108]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401aee6:	687b      	ldr	r3, [r7, #4]
3401aee8:	6013      	str	r3, [r2, #0]
3401aeea:	4b1a      	ldr	r3, [pc, #104]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401aeec:	681b      	ldr	r3, [r3, #0]
3401aeee:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401aef2:	2b00      	cmp	r3, #0
3401aef4:	d1f9      	bne.n	3401aeea <LL_ATON_RT_RuntimeInit+0x42>

    /* Preset Interrupt Controller masks */
    ATON_INTCTRL_STD_INTORMSK_SET(ATON_STRENG_INT_MASK(
3401aef6:	4b18      	ldr	r3, [pc, #96]	@ (3401af58 <LL_ATON_RT_RuntimeInit+0xb0>)
3401aef8:	f240 32ff 	movw	r2, #1023	@ 0x3ff
3401aefc:	601a      	str	r2, [r3, #0]
        ATON_STRENG_NUM, 0, 0)); // OR-mask: disable all streaming engine events and enable all other events & errors
    ATON_INTCTRL_STD_INTANDMSK_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
3401aefe:	4b17      	ldr	r3, [pc, #92]	@ (3401af5c <LL_ATON_RT_RuntimeInit+0xb4>)
3401af00:	f04f 32ff 	mov.w	r2, #4294967295
3401af04:	601a      	str	r2, [r3, #0]
    ATON_INTCTRL_STD_INTORMSK_H_SET(0);           // OR-mask: enable all events & errors
    ATON_INTCTRL_STD_INTANDMSK_H_SET(0xFFFFFFFF); // AND-mask: disable all events & errors
#endif

    /* Enable Interrupt Controller (again) */
    ATON_ENABLE(INTCTRL, 0);
3401af06:	4b13      	ldr	r3, [pc, #76]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401af08:	681b      	ldr	r3, [r3, #0]
3401af0a:	603b      	str	r3, [r7, #0]
3401af0c:	683b      	ldr	r3, [r7, #0]
3401af0e:	f043 0301 	orr.w	r3, r3, #1
3401af12:	603b      	str	r3, [r7, #0]
3401af14:	4a0f      	ldr	r2, [pc, #60]	@ (3401af54 <LL_ATON_RT_RuntimeInit+0xac>)
3401af16:	683b      	ldr	r3, [r7, #0]
3401af18:	6013      	str	r3, [r2, #0]
  }

  /** Initialize OSAL layer **/
  LL_ATON_OSAL_INIT();
3401af1a:	f7ff f9bd 	bl	3401a298 <aton_osal_threadx_init>

  /** Disable all four ATON interrupts **/
  LL_ATON_DISABLE_ALL_IRQs();
3401af1e:	2035      	movs	r0, #53	@ 0x35
3401af20:	f7ff faf0 	bl	3401a504 <__NVIC_DisableIRQ>
3401af24:	2036      	movs	r0, #54	@ 0x36
3401af26:	f7ff faed 	bl	3401a504 <__NVIC_DisableIRQ>
3401af2a:	2037      	movs	r0, #55	@ 0x37
3401af2c:	f7ff faea 	bl	3401a504 <__NVIC_DisableIRQ>
3401af30:	2038      	movs	r0, #56	@ 0x38
3401af32:	f7ff fae7 	bl	3401a504 <__NVIC_DisableIRQ>

  /** Install IRQ handler **/
  LL_ATON_OSAL_INSTALL_IRQ(ATON_STD_IRQ_LINE, ATON_STD_IRQHandler);

  /** Enable ATON `ATON_STD_IRQ_LINE` interrupt **/
  LL_ATON_OSAL_ENABLE_IRQ(ATON_STD_IRQ_LINE);
3401af36:	2035      	movs	r0, #53	@ 0x35
3401af38:	f7ff fac6 	bl	3401a4c8 <__NVIC_EnableIRQ>

  /** After having initialized ATON call callback (which among others might initialize further subsystems) */
  if (ll_aton_init_deinit_trace)
3401af3c:	4b08      	ldr	r3, [pc, #32]	@ (3401af60 <LL_ATON_RT_RuntimeInit+0xb8>)
3401af3e:	681b      	ldr	r3, [r3, #0]
3401af40:	2b00      	cmp	r3, #0
3401af42:	d003      	beq.n	3401af4c <LL_ATON_RT_RuntimeInit+0xa4>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Init);
3401af44:	4b06      	ldr	r3, [pc, #24]	@ (3401af60 <LL_ATON_RT_RuntimeInit+0xb8>)
3401af46:	681b      	ldr	r3, [r3, #0]
3401af48:	2006      	movs	r0, #6
3401af4a:	4798      	blx	r3
}
3401af4c:	bf00      	nop
3401af4e:	3708      	adds	r7, #8
3401af50:	46bd      	mov	sp, r7
3401af52:	bd80      	pop	{r7, pc}
3401af54:	580e1000 	.word	0x580e1000
3401af58:	580e1014 	.word	0x580e1014
3401af5c:	580e1024 	.word	0x580e1024
3401af60:	3404a2b0 	.word	0x3404a2b0

3401af64 <LL_ATON_RT_RuntimeDeInit>:
 * @brief De-initialize the ATON runtime
 * @param nn_instance Pointer to network instance to de-initialize (optional - i.e. may be `NULL`, see
 * `LL_ATON_RT_DeInit_Network()`)
 */
void LL_ATON_RT_RuntimeDeInit(void)
{
3401af64:	b580      	push	{r7, lr}
3401af66:	af00      	add	r7, sp, #0
  /* Call runtime de-init callback */
  if (ll_aton_init_deinit_trace)
3401af68:	4b0c      	ldr	r3, [pc, #48]	@ (3401af9c <LL_ATON_RT_RuntimeDeInit+0x38>)
3401af6a:	681b      	ldr	r3, [r3, #0]
3401af6c:	2b00      	cmp	r3, #0
3401af6e:	d003      	beq.n	3401af78 <LL_ATON_RT_RuntimeDeInit+0x14>
    ll_aton_init_deinit_trace(LL_ATON_RT_Callbacktype_RT_Deinit);
3401af70:	4b0a      	ldr	r3, [pc, #40]	@ (3401af9c <LL_ATON_RT_RuntimeDeInit+0x38>)
3401af72:	681b      	ldr	r3, [r3, #0]
3401af74:	2007      	movs	r0, #7
3401af76:	4798      	blx	r3

  /* Disable all four ATON interrupts */
  LL_ATON_DISABLE_ALL_IRQs();
3401af78:	2035      	movs	r0, #53	@ 0x35
3401af7a:	f7ff fac3 	bl	3401a504 <__NVIC_DisableIRQ>
3401af7e:	2036      	movs	r0, #54	@ 0x36
3401af80:	f7ff fac0 	bl	3401a504 <__NVIC_DisableIRQ>
3401af84:	2037      	movs	r0, #55	@ 0x37
3401af86:	f7ff fabd 	bl	3401a504 <__NVIC_DisableIRQ>
3401af8a:	2038      	movs	r0, #56	@ 0x38
3401af8c:	f7ff faba 	bl	3401a504 <__NVIC_DisableIRQ>

  /* Remove IRQ handler */
  LL_ATON_OSAL_REMOVE_IRQ(ATON_STD_IRQ_LINE);

  /* De-initialize OSAL layer */
  LL_ATON_OSAL_DEINIT();
3401af90:	f7ff f9d8 	bl	3401a344 <aton_osal_threadx_deinit>

  /* De-initialize ATON IPs */
  LL_ATON_DeInit();
3401af94:	f7fe fed2 	bl	34019d3c <LL_ATON_DeInit>
}
3401af98:	bf00      	nop
3401af9a:	bd80      	pop	{r7, pc}
3401af9c:	3404a2b0 	.word	0x3404a2b0

3401afa0 <LL_ATON_RT_RunEpochBlock>:
 *                            same thread!
 *                            It is entirely the user's responsibility to comply with this restriction!
 * @retval LL_ATON_RT_DONE    NN execution finished
 */
LL_ATON_RT_RetValues_t LL_ATON_RT_RunEpochBlock(NN_Instance_TypeDef *nn_instance)
{
3401afa0:	b580      	push	{r7, lr}
3401afa2:	b084      	sub	sp, #16
3401afa4:	af00      	add	r7, sp, #0
3401afa6:	6078      	str	r0, [r7, #4]
  LL_ATON_ASSERT(nn_instance != NULL);
3401afa8:	687b      	ldr	r3, [r7, #4]
3401afaa:	2b00      	cmp	r3, #0
3401afac:	d106      	bne.n	3401afbc <LL_ATON_RT_RunEpochBlock+0x1c>
3401afae:	4b63      	ldr	r3, [pc, #396]	@ (3401b13c <LL_ATON_RT_RunEpochBlock+0x19c>)
3401afb0:	4a63      	ldr	r2, [pc, #396]	@ (3401b140 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401afb2:	f240 210f 	movw	r1, #527	@ 0x20f
3401afb6:	4863      	ldr	r0, [pc, #396]	@ (3401b144 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401afb8:	f00a fed6 	bl	34025d68 <__assert_func>

  /* Test for wrong/missing initialization */
  LL_ATON_ASSERT(nn_instance->exec_state.current_epoch_block != NULL); // should never happen
3401afbc:	687b      	ldr	r3, [r7, #4]
3401afbe:	685b      	ldr	r3, [r3, #4]
3401afc0:	2b00      	cmp	r3, #0
3401afc2:	d106      	bne.n	3401afd2 <LL_ATON_RT_RunEpochBlock+0x32>
3401afc4:	4b60      	ldr	r3, [pc, #384]	@ (3401b148 <LL_ATON_RT_RunEpochBlock+0x1a8>)
3401afc6:	4a5e      	ldr	r2, [pc, #376]	@ (3401b140 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401afc8:	f240 2112 	movw	r1, #530	@ 0x212
3401afcc:	485d      	ldr	r0, [pc, #372]	@ (3401b144 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401afce:	f00a fecb 	bl	34025d68 <__assert_func>

  /* Check if network is starting a new inference */
  if (nn_instance->exec_state.inference_started == false)
3401afd2:	687b      	ldr	r3, [r7, #4]
3401afd4:	7e1b      	ldrb	r3, [r3, #24]
3401afd6:	f083 0301 	eor.w	r3, r3, #1
3401afda:	b2db      	uxtb	r3, r3
3401afdc:	2b00      	cmp	r3, #0
3401afde:	d022      	beq.n	3401b026 <LL_ATON_RT_RunEpochBlock+0x86>
  {
    /* Perform epoch controller blob relocation updates */
    LL_ATON_ASSERT((nn_instance->network != NULL) && (nn_instance->network->ec_inference_init != NULL));
3401afe0:	687b      	ldr	r3, [r7, #4]
3401afe2:	681b      	ldr	r3, [r3, #0]
3401afe4:	2b00      	cmp	r3, #0
3401afe6:	d004      	beq.n	3401aff2 <LL_ATON_RT_RunEpochBlock+0x52>
3401afe8:	687b      	ldr	r3, [r7, #4]
3401afea:	681b      	ldr	r3, [r3, #0]
3401afec:	689b      	ldr	r3, [r3, #8]
3401afee:	2b00      	cmp	r3, #0
3401aff0:	d106      	bne.n	3401b000 <LL_ATON_RT_RunEpochBlock+0x60>
3401aff2:	4b56      	ldr	r3, [pc, #344]	@ (3401b14c <LL_ATON_RT_RunEpochBlock+0x1ac>)
3401aff4:	4a52      	ldr	r2, [pc, #328]	@ (3401b140 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401aff6:	f44f 7106 	mov.w	r1, #536	@ 0x218
3401affa:	4852      	ldr	r0, [pc, #328]	@ (3401b144 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401affc:	f00a feb4 	bl	34025d68 <__assert_func>
    bool ret = nn_instance->network->ec_inference_init();
3401b000:	687b      	ldr	r3, [r7, #4]
3401b002:	681b      	ldr	r3, [r3, #0]
3401b004:	689b      	ldr	r3, [r3, #8]
3401b006:	4798      	blx	r3
3401b008:	4603      	mov	r3, r0
3401b00a:	73bb      	strb	r3, [r7, #14]
    LL_ATON_ASSERT(ret == true);
3401b00c:	7bbb      	ldrb	r3, [r7, #14]
3401b00e:	2b01      	cmp	r3, #1
3401b010:	d006      	beq.n	3401b020 <LL_ATON_RT_RunEpochBlock+0x80>
3401b012:	4b4f      	ldr	r3, [pc, #316]	@ (3401b150 <LL_ATON_RT_RunEpochBlock+0x1b0>)
3401b014:	4a4a      	ldr	r2, [pc, #296]	@ (3401b140 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b016:	f240 211a 	movw	r1, #538	@ 0x21a
3401b01a:	484a      	ldr	r0, [pc, #296]	@ (3401b144 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b01c:	f00a fea4 	bl	34025d68 <__assert_func>
    LL_ATON_LIB_UNUSED(ret);

    /* Set inference started flag to `true` */
    nn_instance->exec_state.inference_started = true;
3401b020:	687b      	ldr	r3, [r7, #4]
3401b022:	2201      	movs	r2, #1
3401b024:	761a      	strb	r2, [r3, #24]
    /* Placeholder for things which need to be done before starting an inference */
    /* ==> here <== */
  }

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  bool this_run_executed_end_epoch = false;
3401b026:	2300      	movs	r3, #0
3401b028:	73fb      	strb	r3, [r7, #15]

  while (true)
  {
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    /* wait for current epoch block to finish */
    uint32_t _wait_mask = __LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block);
3401b02a:	687b      	ldr	r3, [r7, #4]
3401b02c:	685b      	ldr	r3, [r3, #4]
3401b02e:	4618      	mov	r0, r3
3401b030:	f7ff fe64 	bl	3401acfc <__LL_ATON_RT_GetWaitMask>
3401b034:	60b8      	str	r0, [r7, #8]
    if (nn_instance->exec_state.current_epoch_block_started && (_wait_mask != 0))
3401b036:	687b      	ldr	r3, [r7, #4]
3401b038:	f893 3020 	ldrb.w	r3, [r3, #32]
3401b03c:	b2db      	uxtb	r3, r3
3401b03e:	2b00      	cmp	r3, #0
3401b040:	d030      	beq.n	3401b0a4 <LL_ATON_RT_RunEpochBlock+0x104>
3401b042:	68bb      	ldr	r3, [r7, #8]
3401b044:	2b00      	cmp	r3, #0
3401b046:	d02d      	beq.n	3401b0a4 <LL_ATON_RT_RunEpochBlock+0x104>
    {
      if ((nn_instance->exec_state.triggered_events & _wait_mask) == _wait_mask)
3401b048:	687b      	ldr	r3, [r7, #4]
3401b04a:	69da      	ldr	r2, [r3, #28]
3401b04c:	68bb      	ldr	r3, [r7, #8]
3401b04e:	4013      	ands	r3, r2
3401b050:	68ba      	ldr	r2, [r7, #8]
3401b052:	429a      	cmp	r2, r3
3401b054:	d124      	bne.n	3401b0a0 <LL_ATON_RT_RunEpochBlock+0x100>
      {
        /* Enter critical section */
        LL_ATON_ASSERT(__ll_current_aton_ip_owner ==
3401b056:	4b3f      	ldr	r3, [pc, #252]	@ (3401b154 <LL_ATON_RT_RunEpochBlock+0x1b4>)
3401b058:	681b      	ldr	r3, [r3, #0]
3401b05a:	687a      	ldr	r2, [r7, #4]
3401b05c:	429a      	cmp	r2, r3
3401b05e:	d006      	beq.n	3401b06e <LL_ATON_RT_RunEpochBlock+0xce>
3401b060:	4b3d      	ldr	r3, [pc, #244]	@ (3401b158 <LL_ATON_RT_RunEpochBlock+0x1b8>)
3401b062:	4a37      	ldr	r2, [pc, #220]	@ (3401b140 <LL_ATON_RT_RunEpochBlock+0x1a0>)
3401b064:	f240 2132 	movw	r1, #562	@ 0x232
3401b068:	4836      	ldr	r0, [pc, #216]	@ (3401b144 <LL_ATON_RT_RunEpochBlock+0x1a4>)
3401b06a:	f00a fe7d 	bl	34025d68 <__assert_func>
                       nn_instance); // when entering a critical section we MUST hold the ATON IP lock
        LL_ATON_OSAL_ENTER_CS();
3401b06e:	2035      	movs	r0, #53	@ 0x35
3401b070:	f7ff fa48 	bl	3401a504 <__NVIC_DisableIRQ>

        /* reset triggered events */
        nn_instance->exec_state.triggered_events &= ~_wait_mask;
3401b074:	687b      	ldr	r3, [r7, #4]
3401b076:	69da      	ldr	r2, [r3, #28]
3401b078:	68bb      	ldr	r3, [r7, #8]
3401b07a:	43db      	mvns	r3, r3
3401b07c:	401a      	ands	r2, r3
3401b07e:	687b      	ldr	r3, [r7, #4]
3401b080:	61da      	str	r2, [r3, #28]

        /* Exit critical section */
        LL_ATON_OSAL_EXIT_CS();
3401b082:	2035      	movs	r0, #53	@ 0x35
3401b084:	f7ff fa20 	bl	3401a4c8 <__NVIC_EnableIRQ>

        /* end/clean-up epoch block */
        __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b088:	687b      	ldr	r3, [r7, #4]
3401b08a:	685b      	ldr	r3, [r3, #4]
3401b08c:	6879      	ldr	r1, [r7, #4]
3401b08e:	4618      	mov	r0, r3
3401b090:	f7ff fd1a 	bl	3401aac8 <__LL_ATON_RT_ExecEndEpochBlock>
        this_run_executed_end_epoch = true;
3401b094:	2301      	movs	r3, #1
3401b096:	73fb      	strb	r3, [r7, #15]

        /* advance epoch block */
        __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401b098:	6878      	ldr	r0, [r7, #4]
3401b09a:	f7ff fdd1 	bl	3401ac40 <__LL_ATON_RT_DetermineNextEpochBlock>
3401b09e:	e001      	b.n	3401b0a4 <LL_ATON_RT_RunEpochBlock+0x104>
      }
      else
      {
        /* Return to main loop */
        return LL_ATON_RT_WFE;
3401b0a0:	2301      	movs	r3, #1
3401b0a2:	e047      	b.n	3401b134 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

    /* test for last epoch block */
    if (EpochBlock_IsLastEpochBlock(nn_instance->exec_state.current_epoch_block))
3401b0a4:	687b      	ldr	r3, [r7, #4]
3401b0a6:	685b      	ldr	r3, [r3, #4]
3401b0a8:	4618      	mov	r0, r3
3401b0aa:	f7ff fa4f 	bl	3401a54c <EpochBlock_IsLastEpochBlock>
3401b0ae:	4603      	mov	r3, r0
3401b0b0:	2b00      	cmp	r3, #0
3401b0b2:	d011      	beq.n	3401b0d8 <LL_ATON_RT_RunEpochBlock+0x138>
    {
      if (nn_instance->exec_state.saved_current_epoch_block != NULL)
3401b0b4:	687b      	ldr	r3, [r7, #4]
3401b0b6:	691b      	ldr	r3, [r3, #16]
3401b0b8:	2b00      	cmp	r3, #0
3401b0ba:	d00b      	beq.n	3401b0d4 <LL_ATON_RT_RunEpochBlock+0x134>
      {
        /* return from inserted epoch block */
        __LL_ATON_RT_RetFromLibEpochBlockArray(true, nn_instance);
3401b0bc:	6879      	ldr	r1, [r7, #4]
3401b0be:	2001      	movs	r0, #1
3401b0c0:	f7ff fba0 	bl	3401a804 <__LL_ATON_RT_RetFromLibEpochBlockArray>

        /* advance epoch block */
        nn_instance->exec_state.current_epoch_block++;
3401b0c4:	687b      	ldr	r3, [r7, #4]
3401b0c6:	685b      	ldr	r3, [r3, #4]
3401b0c8:	f103 0214 	add.w	r2, r3, #20
3401b0cc:	687b      	ldr	r3, [r7, #4]
3401b0ce:	605a      	str	r2, [r3, #4]

        /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
        return LL_ATON_RT_NO_WFE;
3401b0d0:	2300      	movs	r3, #0
3401b0d2:	e02f      	b.n	3401b134 <LL_ATON_RT_RunEpochBlock+0x194>
      }
      else
      {
        /* Reached end of execution */
        return LL_ATON_RT_DONE;
3401b0d4:	2302      	movs	r3, #2
3401b0d6:	e02d      	b.n	3401b134 <LL_ATON_RT_RunEpochBlock+0x194>
      }
    }

    /* run/start current epoch block */
#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
    if (this_run_executed_end_epoch)
3401b0d8:	7bfb      	ldrb	r3, [r7, #15]
3401b0da:	2b00      	cmp	r3, #0
3401b0dc:	d001      	beq.n	3401b0e2 <LL_ATON_RT_RunEpochBlock+0x142>
    { // alow reset of network (see function `LL_ATON_RT_Reset_Network()`)
      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401b0de:	2300      	movs	r3, #0
3401b0e0:	e028      	b.n	3401b134 <LL_ATON_RT_RunEpochBlock+0x194>
    }

    if (!nn_instance->exec_state.current_epoch_block_started)
3401b0e2:	687b      	ldr	r3, [r7, #4]
3401b0e4:	f893 3020 	ldrb.w	r3, [r3, #32]
3401b0e8:	b2db      	uxtb	r3, r3
3401b0ea:	f083 0301 	eor.w	r3, r3, #1
3401b0ee:	b2db      	uxtb	r3, r3
3401b0f0:	2b00      	cmp	r3, #0
3401b0f2:	d009      	beq.n	3401b108 <LL_ATON_RT_RunEpochBlock+0x168>
    {
      nn_instance->exec_state.current_epoch_block_started = true;
3401b0f4:	687b      	ldr	r3, [r7, #4]
3401b0f6:	2201      	movs	r2, #1
3401b0f8:	f883 2020 	strb.w	r2, [r3, #32]

      __LL_ATON_RT_ExecStartEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b0fc:	687b      	ldr	r3, [r7, #4]
3401b0fe:	685b      	ldr	r3, [r3, #4]
3401b100:	6879      	ldr	r1, [r7, #4]
3401b102:	4618      	mov	r0, r3
3401b104:	f7ff fc34 	bl	3401a970 <__LL_ATON_RT_ExecStartEpochBlock>
    }

    /* End epoch block and advance to next one */
    if (__LL_ATON_RT_GetWaitMask(nn_instance->exec_state.current_epoch_block) == 0x0)
3401b108:	687b      	ldr	r3, [r7, #4]
3401b10a:	685b      	ldr	r3, [r3, #4]
3401b10c:	4618      	mov	r0, r3
3401b10e:	f7ff fdf5 	bl	3401acfc <__LL_ATON_RT_GetWaitMask>
3401b112:	4603      	mov	r3, r0
3401b114:	2b00      	cmp	r3, #0
3401b116:	d10c      	bne.n	3401b132 <LL_ATON_RT_RunEpochBlock+0x192>
    {
      /* end/clean-up epoch block */
      __LL_ATON_RT_ExecEndEpochBlock(nn_instance->exec_state.current_epoch_block, nn_instance);
3401b118:	687b      	ldr	r3, [r7, #4]
3401b11a:	685b      	ldr	r3, [r3, #4]
3401b11c:	6879      	ldr	r1, [r7, #4]
3401b11e:	4618      	mov	r0, r3
3401b120:	f7ff fcd2 	bl	3401aac8 <__LL_ATON_RT_ExecEndEpochBlock>
      this_run_executed_end_epoch = true; // has no effect (just for cosmetics)
3401b124:	2301      	movs	r3, #1
3401b126:	73fb      	strb	r3, [r7, #15]

      /* advance epoch block */
      __LL_ATON_RT_DetermineNextEpochBlock(nn_instance);
3401b128:	6878      	ldr	r0, [r7, #4]
3401b12a:	f7ff fd89 	bl	3401ac40 <__LL_ATON_RT_DetermineNextEpochBlock>

      /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
      return LL_ATON_RT_NO_WFE;
3401b12e:	2300      	movs	r3, #0
3401b130:	e000      	b.n	3401b134 <LL_ATON_RT_RunEpochBlock+0x194>
    }
    else
    {
      /* Return to main loop */
      return LL_ATON_RT_WFE;
3401b132:	2301      	movs	r3, #1
    /* Return to main loop (but do NOT call `LL_ATON_OSAL_WFE())`) */
    return LL_ATON_RT_NO_WFE;

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  }
}
3401b134:	4618      	mov	r0, r3
3401b136:	3710      	adds	r7, #16
3401b138:	46bd      	mov	sp, r7
3401b13a:	bd80      	pop	{r7, pc}
3401b13c:	3402ae28 	.word	0x3402ae28
3401b140:	3402bfac 	.word	0x3402bfac
3401b144:	3402afdc 	.word	0x3402afdc
3401b148:	3402b17c 	.word	0x3402b17c
3401b14c:	3402b1b8 	.word	0x3402b1b8
3401b150:	3402b170 	.word	0x3402b170
3401b154:	3404a2a8 	.word	0x3404a2a8
3401b158:	3402b020 	.word	0x3402b020

3401b15c <__LL_ATON_RT_IrqErr>:
#if (ATON_INT_NR > 32)
static void __LL_ATON_RT_IrqErr(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static void __LL_ATON_RT_IrqErr(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b15c:	b5b0      	push	{r4, r5, r7, lr}
3401b15e:	b084      	sub	sp, #16
3401b160:	af00      	add	r7, sp, #0
3401b162:	6078      	str	r0, [r7, #4]
  extern void dump_dma_state(void);
  int32_t i;

  if (!irqs)
3401b164:	687b      	ldr	r3, [r7, #4]
3401b166:	2b00      	cmp	r3, #0
3401b168:	d07d      	beq.n	3401b266 <__LL_ATON_RT_IrqErr+0x10a>
    return;

#ifdef ATON_STRENG_NUM
  /* Streaming Engine Error interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRENG_ERR_INT_MASK, ATON_STRENG_NUM))
3401b16a:	687a      	ldr	r2, [r7, #4]
3401b16c:	4b40      	ldr	r3, [pc, #256]	@ (3401b270 <__LL_ATON_RT_IrqErr+0x114>)
3401b16e:	4013      	ands	r3, r2
3401b170:	2b00      	cmp	r3, #0
3401b172:	d002      	beq.n	3401b17a <__LL_ATON_RT_IrqErr+0x1e>
  {
    LL_ATON_PRINTF("Streaming engine error interrupt\n");
3401b174:	483f      	ldr	r0, [pc, #252]	@ (3401b274 <__LL_ATON_RT_IrqErr+0x118>)
3401b176:	f00b fded 	bl	34026d54 <puts>
  }
  /* Streaming Engine interrupts */
  if (irqs & ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0))
3401b17a:	687b      	ldr	r3, [r7, #4]
3401b17c:	f3c3 0309 	ubfx	r3, r3, #0, #10
3401b180:	2b00      	cmp	r3, #0
3401b182:	d002      	beq.n	3401b18a <__LL_ATON_RT_IrqErr+0x2e>
  {
    LL_ATON_PRINTF("Streaming engine completion interrupt\n");
3401b184:	483c      	ldr	r0, [pc, #240]	@ (3401b278 <__LL_ATON_RT_IrqErr+0x11c>)
3401b186:	f00b fde5 	bl	34026d54 <puts>
  }
#endif // ATON_STRENG_NUM

#ifdef ATON_CONVACC_NUM
  /* Convolutional accelerators interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_CONVACC_INT_MASK, ATON_CONVACC_NUM))
3401b18a:	687b      	ldr	r3, [r7, #4]
3401b18c:	f403 0370 	and.w	r3, r3, #15728640	@ 0xf00000
3401b190:	2b00      	cmp	r3, #0
3401b192:	d002      	beq.n	3401b19a <__LL_ATON_RT_IrqErr+0x3e>
  {
    LL_ATON_PRINTF("Convolutional accelerator interrupt\n");
3401b194:	4839      	ldr	r0, [pc, #228]	@ (3401b27c <__LL_ATON_RT_IrqErr+0x120>)
3401b196:	f00b fddd 	bl	34026d54 <puts>
  }
#endif // ATON_CONVACC_NUM

#if defined(ATON_RECBUF_NUM)
  /* Reconfigurable buffer interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_RECBUF_INT_MASK, ATON_RECBUF_NUM))
3401b19a:	687b      	ldr	r3, [r7, #4]
3401b19c:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
3401b1a0:	2b00      	cmp	r3, #0
3401b1a2:	d002      	beq.n	3401b1aa <__LL_ATON_RT_IrqErr+0x4e>
  {
    LL_ATON_PRINTF("Reconfigurable buffer interrupt\n");
3401b1a4:	4836      	ldr	r0, [pc, #216]	@ (3401b280 <__LL_ATON_RT_IrqErr+0x124>)
3401b1a6:	f00b fdd5 	bl	34026d54 <puts>
  }
#endif // ATON_RECBUF_NUM

#ifdef ATON_BUSIF_NUM
  /* Bus interface interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_BUSIF_INT_MASK, ATON_BUSIF_NUM))
3401b1aa:	687b      	ldr	r3, [r7, #4]
3401b1ac:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
3401b1b0:	2b00      	cmp	r3, #0
3401b1b2:	d015      	beq.n	3401b1e0 <__LL_ATON_RT_IrqErr+0x84>
  {
    LL_ATON_PRINTF("Bus interface interrupt\n");
3401b1b4:	4833      	ldr	r0, [pc, #204]	@ (3401b284 <__LL_ATON_RT_IrqErr+0x128>)
3401b1b6:	f00b fdcd 	bl	34026d54 <puts>

    /* Report offending stream engine */
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401b1ba:	2300      	movs	r3, #0
3401b1bc:	60fb      	str	r3, [r7, #12]
3401b1be:	e00c      	b.n	3401b1da <__LL_ATON_RT_IrqErr+0x7e>
      LL_ATON_PRINTF("BUSIF%" PRId32 " ERR: 0x%" PRIx32 "\n", i, ATON_BUSIF_ERR_GET(i));
3401b1c0:	68fb      	ldr	r3, [r7, #12]
3401b1c2:	031a      	lsls	r2, r3, #12
3401b1c4:	4b30      	ldr	r3, [pc, #192]	@ (3401b288 <__LL_ATON_RT_IrqErr+0x12c>)
3401b1c6:	4413      	add	r3, r2
3401b1c8:	681b      	ldr	r3, [r3, #0]
3401b1ca:	461a      	mov	r2, r3
3401b1cc:	68f9      	ldr	r1, [r7, #12]
3401b1ce:	482f      	ldr	r0, [pc, #188]	@ (3401b28c <__LL_ATON_RT_IrqErr+0x130>)
3401b1d0:	f00b fd58 	bl	34026c84 <iprintf>
    for (i = 0; i < ATON_BUSIF_NUM; i++)
3401b1d4:	68fb      	ldr	r3, [r7, #12]
3401b1d6:	3301      	adds	r3, #1
3401b1d8:	60fb      	str	r3, [r7, #12]
3401b1da:	68fb      	ldr	r3, [r7, #12]
3401b1dc:	2b01      	cmp	r3, #1
3401b1de:	ddef      	ble.n	3401b1c0 <__LL_ATON_RT_IrqErr+0x64>
  }
#endif // ATON_BUSIF_NUM

#if defined(ATON_STRSWITCH_NUM)
  /* Stream switch interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_STRSWITCH_INT_MASK, ATON_STRSWITCH_NUM))
3401b1e0:	687b      	ldr	r3, [r7, #4]
3401b1e2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3401b1e6:	2b00      	cmp	r3, #0
3401b1e8:	d002      	beq.n	3401b1f0 <__LL_ATON_RT_IrqErr+0x94>
  {
    LL_ATON_PRINTF("Stream switch interrupt\n");
3401b1ea:	4829      	ldr	r0, [pc, #164]	@ (3401b290 <__LL_ATON_RT_IrqErr+0x134>)
3401b1ec:	f00b fdb2 	bl	34026d54 <puts>
  }
#endif // ATON_STRSWITCH_NUM

#if defined(ATON_EPOCHCTRL_NUM)
  /* Epoch Controller interrupts */
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_ERR_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b1f0:	687b      	ldr	r3, [r7, #4]
3401b1f2:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3401b1f6:	2b00      	cmp	r3, #0
3401b1f8:	d011      	beq.n	3401b21e <__LL_ATON_RT_IrqErr+0xc2>
  {
    LL_ATON_PRINTF("Epoch Controller ERROR interrupt: EC_IRQ = 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_IRQ_GET(0));
3401b1fa:	4b26      	ldr	r3, [pc, #152]	@ (3401b294 <__LL_ATON_RT_IrqErr+0x138>)
3401b1fc:	681b      	ldr	r3, [r3, #0]
3401b1fe:	4619      	mov	r1, r3
3401b200:	4825      	ldr	r0, [pc, #148]	@ (3401b298 <__LL_ATON_RT_IrqErr+0x13c>)
3401b202:	f00b fd3f 	bl	34026c84 <iprintf>
    LL_ATON_PRINTF("Epoch Controller opcode counter: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_BC_GET(0));
3401b206:	4b25      	ldr	r3, [pc, #148]	@ (3401b29c <__LL_ATON_RT_IrqErr+0x140>)
3401b208:	681b      	ldr	r3, [r3, #0]
3401b20a:	4619      	mov	r1, r3
3401b20c:	4824      	ldr	r0, [pc, #144]	@ (3401b2a0 <__LL_ATON_RT_IrqErr+0x144>)
3401b20e:	f00b fd39 	bl	34026c84 <iprintf>
    LL_ATON_PRINTF("Epoch Controller label: 0x%08" PRIx32 "\n", ATON_EPOCHCTRL_LABEL_GET(0));
3401b212:	4b24      	ldr	r3, [pc, #144]	@ (3401b2a4 <__LL_ATON_RT_IrqErr+0x148>)
3401b214:	681b      	ldr	r3, [r3, #0]
3401b216:	4619      	mov	r1, r3
3401b218:	4823      	ldr	r0, [pc, #140]	@ (3401b2a8 <__LL_ATON_RT_IrqErr+0x14c>)
3401b21a:	f00b fd33 	bl	34026c84 <iprintf>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_NOACK_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b21e:	687b      	ldr	r3, [r7, #4]
3401b220:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
3401b224:	2b00      	cmp	r3, #0
3401b226:	d002      	beq.n	3401b22e <__LL_ATON_RT_IrqErr+0xd2>
  {
    LL_ATON_PRINTF("Epoch Controller NOACK interrupt\n");
3401b228:	4820      	ldr	r0, [pc, #128]	@ (3401b2ac <__LL_ATON_RT_IrqErr+0x150>)
3401b22a:	f00b fd93 	bl	34026d54 <puts>
  }
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ATON_EPOCHCTRL_NUM))
3401b22e:	687b      	ldr	r3, [r7, #4]
3401b230:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
3401b234:	2b00      	cmp	r3, #0
3401b236:	d002      	beq.n	3401b23e <__LL_ATON_RT_IrqErr+0xe2>
  {
    LL_ATON_PRINTF("Epoch Controller interrupt\n");
3401b238:	481d      	ldr	r0, [pc, #116]	@ (3401b2b0 <__LL_ATON_RT_IrqErr+0x154>)
3401b23a:	f00b fd8b 	bl	34026d54 <puts>
  }
#endif // ATON_EPOCHCTRL_NUM

  /* default error handling */
  dump_dma_state();
3401b23e:	f7ff fb6f 	bl	3401a920 <dump_dma_state>
  IRQ_ERR_MSG(); // just for debug
3401b242:	687b      	ldr	r3, [r7, #4]
3401b244:	2200      	movs	r2, #0
3401b246:	461c      	mov	r4, r3
3401b248:	4615      	mov	r5, r2
3401b24a:	4622      	mov	r2, r4
3401b24c:	462b      	mov	r3, r5
3401b24e:	f240 21fb 	movw	r1, #763	@ 0x2fb
3401b252:	4818      	ldr	r0, [pc, #96]	@ (3401b2b4 <__LL_ATON_RT_IrqErr+0x158>)
3401b254:	f00b fd16 	bl	34026c84 <iprintf>
#if (LL_ATON_HAVE_FFLUSH)
  LL_ATON_FFLUSH(stdout);
#endif
  LL_ATON_ASSERT(false); // may never happen
3401b258:	4b17      	ldr	r3, [pc, #92]	@ (3401b2b8 <__LL_ATON_RT_IrqErr+0x15c>)
3401b25a:	4a18      	ldr	r2, [pc, #96]	@ (3401b2bc <__LL_ATON_RT_IrqErr+0x160>)
3401b25c:	f240 21ff 	movw	r1, #767	@ 0x2ff
3401b260:	4817      	ldr	r0, [pc, #92]	@ (3401b2c0 <__LL_ATON_RT_IrqErr+0x164>)
3401b262:	f00a fd81 	bl	34025d68 <__assert_func>
    return;
3401b266:	bf00      	nop
  // All of the above not handled interrupts should be changed in a way that allows both a return from
  // this IRQ handler (w/o immediate re-entry) and to return control back to the user's main loop e.g. by using an
  // internal flag/variable to signal the error, then performing a `LL_ATON_RT_RuntimeDeInit()`, and returning with a
  // respective (new) return value (of type `LL_ATON_RT_RetValues_t`), reporting about the error, from the latest
  // call to `LL_ATON_RT_RunEpochBlock()`
}
3401b268:	3710      	adds	r7, #16
3401b26a:	46bd      	mov	sp, r7
3401b26c:	bdb0      	pop	{r4, r5, r7, pc}
3401b26e:	bf00      	nop
3401b270:	000ffc00 	.word	0x000ffc00
3401b274:	3402b21c 	.word	0x3402b21c
3401b278:	3402b240 	.word	0x3402b240
3401b27c:	3402b268 	.word	0x3402b268
3401b280:	3402b28c 	.word	0x3402b28c
3401b284:	3402b2ac 	.word	0x3402b2ac
3401b288:	580e2010 	.word	0x580e2010
3401b28c:	3402b2c4 	.word	0x3402b2c4
3401b290:	3402b2dc 	.word	0x3402b2dc
3401b294:	580fe00c 	.word	0x580fe00c
3401b298:	3402b2f4 	.word	0x3402b2f4
3401b29c:	580fe020 	.word	0x580fe020
3401b2a0:	3402b328 	.word	0x3402b328
3401b2a4:	580fe01c 	.word	0x580fe01c
3401b2a8:	3402b354 	.word	0x3402b354
3401b2ac:	3402b378 	.word	0x3402b378
3401b2b0:	3402b39c 	.word	0x3402b39c
3401b2b4:	3402b3b8 	.word	0x3402b3b8
3401b2b8:	3402b3e0 	.word	0x3402b3e0
3401b2bc:	3402c0c0 	.word	0x3402c0c0
3401b2c0:	3402afdc 	.word	0x3402afdc

3401b2c4 <__LL_ATON_RT_IrqEpochBlock>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlock(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b2c4:	b480      	push	{r7}
3401b2c6:	b087      	sub	sp, #28
3401b2c8:	af00      	add	r7, sp, #0
3401b2ca:	6078      	str	r0, [r7, #4]
   * consecutive bits within the `INTREG` register (and within all other interrupt controller registers, like e.g.
   * status/mask/clear)! */
  irqs >>= ATON_STRENG_INT(0);
  wait_irqs =
      irqs &
      __ll_current_aton_ip_owner->exec_state.current_epoch_block
3401b2cc:	4b1e      	ldr	r3, [pc, #120]	@ (3401b348 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b2ce:	681b      	ldr	r3, [r3, #0]
3401b2d0:	685b      	ldr	r3, [r3, #4]
          ->wait_mask; /* treat only IRQs we are currently waiting for
3401b2d2:	68db      	ldr	r3, [r3, #12]
  wait_irqs =
3401b2d4:	687a      	ldr	r2, [r7, #4]
3401b2d6:	4013      	ands	r3, r2
3401b2d8:	60fb      	str	r3, [r7, #12]
                          (Note: we might be running in a hybrid function which uses DMAs in parallel with a "normal"
                          ATON execution and we must not clear the IRQs of this "normal" ATON execution here) */
  if (wait_irqs)
3401b2da:	68fb      	ldr	r3, [r7, #12]
3401b2dc:	2b00      	cmp	r3, #0
3401b2de:	d02d      	beq.n	3401b33c <__LL_ATON_RT_IrqEpochBlock+0x78>
  {
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401b2e0:	4b19      	ldr	r3, [pc, #100]	@ (3401b348 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b2e2:	681b      	ldr	r3, [r3, #0]
3401b2e4:	69db      	ldr	r3, [r3, #28]
3401b2e6:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401b2e8:	2300      	movs	r3, #0
3401b2ea:	617b      	str	r3, [r7, #20]
3401b2ec:	e01f      	b.n	3401b32e <__LL_ATON_RT_IrqEpochBlock+0x6a>
    {
      /* Handle event interrupts */
      if ((wait_irqs >> i) & 1)
3401b2ee:	68fa      	ldr	r2, [r7, #12]
3401b2f0:	697b      	ldr	r3, [r7, #20]
3401b2f2:	fa22 f303 	lsr.w	r3, r2, r3
3401b2f6:	f003 0301 	and.w	r3, r3, #1
3401b2fa:	2b00      	cmp	r3, #0
3401b2fc:	d014      	beq.n	3401b328 <__LL_ATON_RT_IrqEpochBlock+0x64>
      { /* more future-proofed but less efficient alternative:
           `if (wait_irqs & ATON_STRENG_INT_MASK(i, 0, 0))`
         */
        uint32_t strengIrqs = ATON_STRENG_IRQ_GET(i);
3401b2fe:	697b      	ldr	r3, [r7, #20]
3401b300:	031a      	lsls	r2, r3, #12
3401b302:	4b12      	ldr	r3, [pc, #72]	@ (3401b34c <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401b304:	4413      	add	r3, r2
3401b306:	681b      	ldr	r3, [r3, #0]
3401b308:	60bb      	str	r3, [r7, #8]
        ATON_STRENG_IRQ_SET(
3401b30a:	697b      	ldr	r3, [r7, #20]
3401b30c:	031a      	lsls	r2, r3, #12
3401b30e:	4b0f      	ldr	r3, [pc, #60]	@ (3401b34c <__LL_ATON_RT_IrqEpochBlock+0x88>)
3401b310:	4413      	add	r3, r2
3401b312:	461a      	mov	r2, r3
3401b314:	68bb      	ldr	r3, [r7, #8]
3401b316:	6013      	str	r3, [r2, #0]
            i, strengIrqs); /* Acknowledge ATON interrupt source (i.e. stream engine #i) - could be more fine grain */

        /* Handle RT integration */
        _tmp_triggered_events |= (1 << i);
3401b318:	2201      	movs	r2, #1
3401b31a:	697b      	ldr	r3, [r7, #20]
3401b31c:	fa02 f303 	lsl.w	r3, r2, r3
3401b320:	461a      	mov	r2, r3
3401b322:	693b      	ldr	r3, [r7, #16]
3401b324:	4313      	orrs	r3, r2
3401b326:	613b      	str	r3, [r7, #16]
    for (i = 0; i < ATON_STRENG_NUM; i++)
3401b328:	697b      	ldr	r3, [r7, #20]
3401b32a:	3301      	adds	r3, #1
3401b32c:	617b      	str	r3, [r7, #20]
3401b32e:	697b      	ldr	r3, [r7, #20]
3401b330:	2b09      	cmp	r3, #9
3401b332:	dddc      	ble.n	3401b2ee <__LL_ATON_RT_IrqEpochBlock+0x2a>
      }
    }
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401b334:	4b04      	ldr	r3, [pc, #16]	@ (3401b348 <__LL_ATON_RT_IrqEpochBlock+0x84>)
3401b336:	681b      	ldr	r3, [r3, #0]
3401b338:	693a      	ldr	r2, [r7, #16]
3401b33a:	61da      	str	r2, [r3, #28]
  }
}
3401b33c:	bf00      	nop
3401b33e:	371c      	adds	r7, #28
3401b340:	46bd      	mov	sp, r7
3401b342:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b346:	4770      	bx	lr
3401b348:	3404a2a8 	.word	0x3404a2a8
3401b34c:	580e503c 	.word	0x580e503c

3401b350 <__LL_ATON_RT_IrqEpochBlob>:
#if (ATON_INT_NR > 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint64_t irqs)
#else  //(ATON_INT_NR <= 32)
static inline void __LL_ATON_RT_IrqEpochBlob(uint32_t irqs)
#endif //(ATON_INT_NR <= 32)
{
3401b350:	b580      	push	{r7, lr}
3401b352:	b086      	sub	sp, #24
3401b354:	af00      	add	r7, sp, #0
3401b356:	6078      	str	r0, [r7, #4]
  uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401b358:	4b1d      	ldr	r3, [pc, #116]	@ (3401b3d0 <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b35a:	681b      	ldr	r3, [r3, #0]
3401b35c:	685b      	ldr	r3, [r3, #4]
3401b35e:	4618      	mov	r0, r3
3401b360:	f7ff f966 	bl	3401a630 <EpochBlock_EpochControllerUnit>
3401b364:	6178      	str	r0, [r7, #20]
  LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401b366:	697b      	ldr	r3, [r7, #20]
3401b368:	2b00      	cmp	r3, #0
3401b36a:	d006      	beq.n	3401b37a <__LL_ATON_RT_IrqEpochBlob+0x2a>
3401b36c:	4b19      	ldr	r3, [pc, #100]	@ (3401b3d4 <__LL_ATON_RT_IrqEpochBlob+0x84>)
3401b36e:	4a1a      	ldr	r2, [pc, #104]	@ (3401b3d8 <__LL_ATON_RT_IrqEpochBlob+0x88>)
3401b370:	f240 3142 	movw	r1, #834	@ 0x342
3401b374:	4819      	ldr	r0, [pc, #100]	@ (3401b3dc <__LL_ATON_RT_IrqEpochBlob+0x8c>)
3401b376:	f00a fcf7 	bl	34025d68 <__assert_func>
  if (irqs & ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK, ecId))
3401b37a:	697b      	ldr	r3, [r7, #20]
3401b37c:	2b00      	cmp	r3, #0
3401b37e:	d007      	beq.n	3401b390 <__LL_ATON_RT_IrqEpochBlob+0x40>
3401b380:	697b      	ldr	r3, [r7, #20]
3401b382:	2b01      	cmp	r3, #1
3401b384:	d102      	bne.n	3401b38c <__LL_ATON_RT_IrqEpochBlob+0x3c>
3401b386:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401b38a:	e003      	b.n	3401b394 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401b38c:	2300      	movs	r3, #0
3401b38e:	e001      	b.n	3401b394 <__LL_ATON_RT_IrqEpochBlob+0x44>
3401b390:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
3401b394:	687a      	ldr	r2, [r7, #4]
3401b396:	4013      	ands	r3, r2
3401b398:	2b00      	cmp	r3, #0
3401b39a:	d015      	beq.n	3401b3c8 <__LL_ATON_RT_IrqEpochBlob+0x78>
  {
    /* Acknowledge interrupts in active epoch controller unit - could be more fine grain */
    uint32_t ecIrqs = ATON_EPOCHCTRL_IRQ_GET(ecId);
3401b39c:	4b10      	ldr	r3, [pc, #64]	@ (3401b3e0 <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401b39e:	681b      	ldr	r3, [r3, #0]
3401b3a0:	613b      	str	r3, [r7, #16]
    ATON_EPOCHCTRL_IRQ_SET(ecId, ecIrqs);
3401b3a2:	4a0f      	ldr	r2, [pc, #60]	@ (3401b3e0 <__LL_ATON_RT_IrqEpochBlob+0x90>)
3401b3a4:	693b      	ldr	r3, [r7, #16]
3401b3a6:	6013      	str	r3, [r2, #0]

    /* Handle RT integration */
    uint32_t _tmp_triggered_events = __ll_current_aton_ip_owner->exec_state.triggered_events;
3401b3a8:	4b09      	ldr	r3, [pc, #36]	@ (3401b3d0 <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b3aa:	681b      	ldr	r3, [r3, #0]
3401b3ac:	69db      	ldr	r3, [r3, #28]
3401b3ae:	60fb      	str	r3, [r7, #12]
    _tmp_triggered_events |= (1 << ecId);
3401b3b0:	2201      	movs	r2, #1
3401b3b2:	697b      	ldr	r3, [r7, #20]
3401b3b4:	fa02 f303 	lsl.w	r3, r2, r3
3401b3b8:	461a      	mov	r2, r3
3401b3ba:	68fb      	ldr	r3, [r7, #12]
3401b3bc:	4313      	orrs	r3, r2
3401b3be:	60fb      	str	r3, [r7, #12]
    __ll_current_aton_ip_owner->exec_state.triggered_events = _tmp_triggered_events;
3401b3c0:	4b03      	ldr	r3, [pc, #12]	@ (3401b3d0 <__LL_ATON_RT_IrqEpochBlob+0x80>)
3401b3c2:	681b      	ldr	r3, [r3, #0]
3401b3c4:	68fa      	ldr	r2, [r7, #12]
3401b3c6:	61da      	str	r2, [r3, #28]
  }
}
3401b3c8:	bf00      	nop
3401b3ca:	3718      	adds	r7, #24
3401b3cc:	46bd      	mov	sp, r7
3401b3ce:	bd80      	pop	{r7, pc}
3401b3d0:	3404a2a8 	.word	0x3404a2a8
3401b3d4:	3402b04c 	.word	0x3402b04c
3401b3d8:	3402c0e4 	.word	0x3402c0e4
3401b3dc:	3402afdc 	.word	0x3402afdc
3401b3e0:	580fe00c 	.word	0x580fe00c

3401b3e4 <NPU0_IRQHandler>:
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

/* ATON ISR
 * ll_aton routes all interrupts to `ATON_STD_IRQ_LINE` interrupt line */
void ATON_STD_IRQHandler(void)
{
3401b3e4:	b580      	push	{r7, lr}
3401b3e6:	b082      	sub	sp, #8
3401b3e8:	af00      	add	r7, sp, #0
#if (ATON_INT_NR > 32)
  uint32_t irqs_l = ATON_INTCTRL_INTREG_GET(0);
  uint32_t irqs_h = ATON_INTCTRL_INTREG_H_GET(0);
  uint64_t irqs = irqs_l | (irqs_h << 32);
#else  //(ATON_INT_NR <= 32)
  uint32_t irqs = ATON_INTCTRL_INTREG_GET(0);
3401b3ea:	4b3e      	ldr	r3, [pc, #248]	@ (3401b4e4 <NPU0_IRQHandler+0x100>)
3401b3ec:	681b      	ldr	r3, [r3, #0]
3401b3ee:	607b      	str	r3, [r7, #4]
#endif //(ATON_INT_NR <= 32)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  if (__ll_current_aton_ip_owner != NULL)
3401b3f0:	4b3d      	ldr	r3, [pc, #244]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b3f2:	681b      	ldr	r3, [r3, #0]
3401b3f4:	2b00      	cmp	r3, #0
3401b3f6:	d045      	beq.n	3401b484 <NPU0_IRQHandler+0xa0>
  {
    LL_ATON_ASSERT(__ll_current_aton_ip_owner->exec_state.current_epoch_block != NULL);
3401b3f8:	4b3b      	ldr	r3, [pc, #236]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b3fa:	681b      	ldr	r3, [r3, #0]
3401b3fc:	685b      	ldr	r3, [r3, #4]
3401b3fe:	2b00      	cmp	r3, #0
3401b400:	d106      	bne.n	3401b410 <NPU0_IRQHandler+0x2c>
3401b402:	4b3a      	ldr	r3, [pc, #232]	@ (3401b4ec <NPU0_IRQHandler+0x108>)
3401b404:	4a3a      	ldr	r2, [pc, #232]	@ (3401b4f0 <NPU0_IRQHandler+0x10c>)
3401b406:	f240 3162 	movw	r1, #866	@ 0x362
3401b40a:	483a      	ldr	r0, [pc, #232]	@ (3401b4f4 <NPU0_IRQHandler+0x110>)
3401b40c:	f00a fcac 	bl	34025d68 <__assert_func>

    /** OR-mask interrupts MUST be handled first **/
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401b410:	4b35      	ldr	r3, [pc, #212]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b412:	681b      	ldr	r3, [r3, #0]
                                    .current_epoch_block)) // standard epoch block handling based on streaming engines
3401b414:	685b      	ldr	r3, [r3, #4]
    if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state
3401b416:	4618      	mov	r0, r3
3401b418:	f7ff f8be 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401b41c:	4603      	mov	r3, r0
3401b41e:	f083 0301 	eor.w	r3, r3, #1
3401b422:	b2db      	uxtb	r3, r3
3401b424:	2b00      	cmp	r3, #0
3401b426:	d008      	beq.n	3401b43a <NPU0_IRQHandler+0x56>
    {
      __LL_ATON_RT_IrqErr(
3401b428:	687b      	ldr	r3, [r7, #4]
3401b42a:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
3401b42e:	f023 0303 	bic.w	r3, r3, #3
3401b432:	4618      	mov	r0, r3
3401b434:	f7ff fe92 	bl	3401b15c <__LL_ATON_RT_IrqErr>
3401b438:	e027      	b.n	3401b48a <NPU0_IRQHandler+0xa6>
          irqs & ~ATON_STRENG_INT_MASK(ATON_STRENG_NUM, 0, 0)); /* exclude all streaming engine completion interrupts */
    }
    else // epoch blob handling based on epoch controller
    {
#if defined(ATON_EPOCHCTRL_NUM)
      uint32_t ecId = EpochBlock_EpochControllerUnit(__ll_current_aton_ip_owner->exec_state.current_epoch_block);
3401b43a:	4b2b      	ldr	r3, [pc, #172]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b43c:	681b      	ldr	r3, [r3, #0]
3401b43e:	685b      	ldr	r3, [r3, #4]
3401b440:	4618      	mov	r0, r3
3401b442:	f7ff f8f5 	bl	3401a630 <EpochBlock_EpochControllerUnit>
3401b446:	6038      	str	r0, [r7, #0]
      LL_ATON_ASSERT(ecId < ATON_EPOCHCTRL_NUM); // may never happen
3401b448:	683b      	ldr	r3, [r7, #0]
3401b44a:	2b00      	cmp	r3, #0
3401b44c:	d006      	beq.n	3401b45c <NPU0_IRQHandler+0x78>
3401b44e:	4b2a      	ldr	r3, [pc, #168]	@ (3401b4f8 <NPU0_IRQHandler+0x114>)
3401b450:	4a27      	ldr	r2, [pc, #156]	@ (3401b4f0 <NPU0_IRQHandler+0x10c>)
3401b452:	f240 316f 	movw	r1, #879	@ 0x36f
3401b456:	4827      	ldr	r0, [pc, #156]	@ (3401b4f4 <NPU0_IRQHandler+0x110>)
3401b458:	f00a fc86 	bl	34025d68 <__assert_func>

      // epoch blob handling based on epoch controller interrupt
      __LL_ATON_RT_IrqErr(
          irqs & ~ATON_INT_GET_MASK(ATON_EPOCHCTRL_INT_MASK,
3401b45c:	683b      	ldr	r3, [r7, #0]
3401b45e:	2b00      	cmp	r3, #0
3401b460:	d008      	beq.n	3401b474 <NPU0_IRQHandler+0x90>
3401b462:	683b      	ldr	r3, [r7, #0]
3401b464:	2b01      	cmp	r3, #1
3401b466:	d102      	bne.n	3401b46e <NPU0_IRQHandler+0x8a>
3401b468:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
3401b46c:	e004      	b.n	3401b478 <NPU0_IRQHandler+0x94>
3401b46e:	f04f 33ff 	mov.w	r3, #4294967295
3401b472:	e001      	b.n	3401b478 <NPU0_IRQHandler+0x94>
3401b474:	f06f 5380 	mvn.w	r3, #268435456	@ 0x10000000
      __LL_ATON_RT_IrqErr(
3401b478:	687a      	ldr	r2, [r7, #4]
3401b47a:	4013      	ands	r3, r2
3401b47c:	4618      	mov	r0, r3
3401b47e:	f7ff fe6d 	bl	3401b15c <__LL_ATON_RT_IrqErr>
3401b482:	e002      	b.n	3401b48a <NPU0_IRQHandler+0xa6>
#endif                                      // !ATON_EPOCHCTRL_NUM
    }
  }
  else // `__ll_current_aton_ip_owner == NULL`
  {
    __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
3401b484:	6878      	ldr	r0, [r7, #4]
3401b486:	f7ff fe69 	bl	3401b15c <__LL_ATON_RT_IrqErr>
#else  // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)
  __LL_ATON_RT_IrqErr(irqs); /* treat all interrupts as errors */
#endif // (LL_ATON_RT_MODE == LL_ATON_RT_POLLING)

#if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
  LL_ATON_ASSERT(__ll_current_aton_ip_owner != NULL);
3401b48a:	4b17      	ldr	r3, [pc, #92]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b48c:	681b      	ldr	r3, [r3, #0]
3401b48e:	2b00      	cmp	r3, #0
3401b490:	d106      	bne.n	3401b4a0 <NPU0_IRQHandler+0xbc>
3401b492:	4b1a      	ldr	r3, [pc, #104]	@ (3401b4fc <NPU0_IRQHandler+0x118>)
3401b494:	4a16      	ldr	r2, [pc, #88]	@ (3401b4f0 <NPU0_IRQHandler+0x10c>)
3401b496:	f240 3183 	movw	r1, #899	@ 0x383
3401b49a:	4816      	ldr	r0, [pc, #88]	@ (3401b4f4 <NPU0_IRQHandler+0x110>)
3401b49c:	f00a fc64 	bl	34025d68 <__assert_func>

  if (!EpochBlock_IsEpochBlob(__ll_current_aton_ip_owner->exec_state.current_epoch_block))
3401b4a0:	4b11      	ldr	r3, [pc, #68]	@ (3401b4e8 <NPU0_IRQHandler+0x104>)
3401b4a2:	681b      	ldr	r3, [r3, #0]
3401b4a4:	685b      	ldr	r3, [r3, #4]
3401b4a6:	4618      	mov	r0, r3
3401b4a8:	f7ff f876 	bl	3401a598 <EpochBlock_IsEpochBlob>
3401b4ac:	4603      	mov	r3, r0
3401b4ae:	f083 0301 	eor.w	r3, r3, #1
3401b4b2:	b2db      	uxtb	r3, r3
3401b4b4:	2b00      	cmp	r3, #0
3401b4b6:	d003      	beq.n	3401b4c0 <NPU0_IRQHandler+0xdc>
  { // standard epoch block handling based on streaming engines
    __LL_ATON_RT_IrqEpochBlock(irqs);
3401b4b8:	6878      	ldr	r0, [r7, #4]
3401b4ba:	f7ff ff03 	bl	3401b2c4 <__LL_ATON_RT_IrqEpochBlock>
3401b4be:	e002      	b.n	3401b4c6 <NPU0_IRQHandler+0xe2>
  }
  else
  { // epoch blob handling based on epoch controller
#if defined(ATON_EPOCHCTRL_NUM)
    __LL_ATON_RT_IrqEpochBlob(irqs);
3401b4c0:	6878      	ldr	r0, [r7, #4]
3401b4c2:	f7ff ff45 	bl	3401b350 <__LL_ATON_RT_IrqEpochBlob>
  __ASM volatile ("dsb 0xF":::"memory");
3401b4c6:	f3bf 8f4f 	dsb	sy
}
3401b4ca:	bf00      	nop
   */
#if (ATON_INT_NR > 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs_l);
  ATON_INTCTRL_INTCLR_H_SET(0, irqs_h);
#else  //(ATON_INT_NR <= 32)
  ATON_INTCTRL_INTCLR_SET(0, irqs);
3401b4cc:	4a0c      	ldr	r2, [pc, #48]	@ (3401b500 <NPU0_IRQHandler+0x11c>)
3401b4ce:	687b      	ldr	r3, [r7, #4]
3401b4d0:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
3401b4d2:	f3bf 8f4f 	dsb	sy
}
3401b4d6:	bf00      	nop

  /* Data Synchronization Barrier */
  LL_ATON_OSAL_DSB();

  /* Signal event */
  LL_ATON_OSAL_SIGNAL_EVENT();
3401b4d8:	f7fe ff9e 	bl	3401a418 <aton_osal_threadx_signal_event>

#endif // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)

  return;
3401b4dc:	bf00      	nop
}
3401b4de:	3708      	adds	r7, #8
3401b4e0:	46bd      	mov	sp, r7
3401b4e2:	bd80      	pop	{r7, pc}
3401b4e4:	580e1008 	.word	0x580e1008
3401b4e8:	3404a2a8 	.word	0x3404a2a8
3401b4ec:	3402b3e4 	.word	0x3402b3e4
3401b4f0:	3402c0d4 	.word	0x3402c0d4
3401b4f4:	3402afdc 	.word	0x3402afdc
3401b4f8:	3402b04c 	.word	0x3402b04c
3401b4fc:	3402ae74 	.word	0x3402ae74
3401b500:	580e1010 	.word	0x580e1010

3401b504 <ll_sw_forward_dequantizelinear>:
}

//##########################################################################################
/** Dequantizelinear forward function */
void ll_sw_forward_dequantizelinear(/* int processor, */ void *sw_info_struct)
{
3401b504:	b580      	push	{r7, lr}
3401b506:	b0ca      	sub	sp, #296	@ 0x128
3401b508:	af00      	add	r7, sp, #0
3401b50a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b50e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
3401b512:	6018      	str	r0, [r3, #0]
  Dequantizelinear_sw_info *sw_info = (Dequantizelinear_sw_info *)sw_info_struct;
3401b514:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b518:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
3401b51c:	681b      	ldr	r3, [r3, #0]
3401b51e:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124

  // array init
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
3401b522:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b526:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
                                                           : (AI_ARRAY_FORMAT_U8 | AI_FMT_FLAG_IS_IO);
3401b52a:	2b00      	cmp	r3, #0
3401b52c:	d001      	beq.n	3401b532 <ll_sw_forward_dequantizelinear+0x2e>
3401b52e:	4bb4      	ldr	r3, [pc, #720]	@ (3401b800 <ll_sw_forward_dequantizelinear+0x2fc>)
3401b530:	e000      	b.n	3401b534 <ll_sw_forward_dequantizelinear+0x30>
3401b532:	4bb4      	ldr	r3, [pc, #720]	@ (3401b804 <ll_sw_forward_dequantizelinear+0x300>)
  int32_t format = sw_info->general.input.format.is_signed ? (AI_ARRAY_FORMAT_S8 | AI_FMT_FLAG_IS_IO)
3401b534:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
  AI_ARRAY_OBJ_DECLARE(input_output_array, format, sw_info->general.input.mem.start_offset,
3401b538:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
3401b53c:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3401b540:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b544:	695b      	ldr	r3, [r3, #20]
3401b546:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
3401b54a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b54e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401b550:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
3401b554:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b558:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401b55a:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
                       sw_info->general.input.mem.start_offset, sw_info->general.input.dim.num_elem, )
  AI_ARRAY_OBJ_DECLARE(dequantize_output_array, FORMAT, sw_info->general.output.mem.start_offset,
3401b55e:	4baa      	ldr	r3, [pc, #680]	@ (3401b808 <ll_sw_forward_dequantizelinear+0x304>)
3401b560:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
3401b564:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b568:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401b56a:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
3401b56e:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b572:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401b574:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
3401b578:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b57c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3401b57e:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
                       sw_info->general.output.mem.start_offset, sw_info->general.output.dim.num_elem, )

  uint16_t offset_format =
      sw_info->is.format.is_signed ? (AI_BUFFER_META_FLAG_ZEROPOINT_S8) : (AI_BUFFER_META_FLAG_ZEROPOINT_U8);
3401b582:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b586:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
  uint16_t offset_format =
3401b58a:	2b00      	cmp	r3, #0
3401b58c:	d001      	beq.n	3401b592 <ll_sw_forward_dequantizelinear+0x8e>
3401b58e:	2304      	movs	r3, #4
3401b590:	e000      	b.n	3401b594 <ll_sw_forward_dequantizelinear+0x90>
3401b592:	2302      	movs	r3, #2
3401b594:	f8a7 311e 	strh.w	r3, [r7, #286]	@ 0x11e
  uint16_t scale_format = AI_BUFFER_META_FLAG_SCALE_FLOAT;
3401b598:	2301      	movs	r3, #1
3401b59a:	f8a7 311c 	strh.w	r3, [r7, #284]	@ 0x11c
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401b59e:	f8b7 211e 	ldrh.w	r2, [r7, #286]	@ 0x11e
3401b5a2:	f8b7 311c 	ldrh.w	r3, [r7, #284]	@ 0x11c
3401b5a6:	4313      	orrs	r3, r2
3401b5a8:	b29b      	uxth	r3, r3
3401b5aa:	f8a7 30f4 	strh.w	r3, [r7, #244]	@ 0xf4
                                  .size = sw_info->is.dim.num_elem,
3401b5ae:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b5b2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401b5b4:	b29b      	uxth	r3, r3
3401b5b6:	f8a7 30f6 	strh.w	r3, [r7, #246]	@ 0xf6
                                  .info = (const ai_intq_info[1]){{
                                      .scale = ((float *)sw_info->is.mem.start_offset),
3401b5ba:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b5be:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
                                  .info = (const ai_intq_info[1]){{
3401b5c2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
                                      .zeropoint = ((void *)sw_info->izp.mem.start_offset),
3401b5c6:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b5ca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
                                  .info = (const ai_intq_info[1]){{
3401b5ce:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  ai_intq_info_list input_intq = {.flags = (offset_format | scale_format),
3401b5d2:	f107 03ec 	add.w	r3, r7, #236	@ 0xec
3401b5d6:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
                                  }}};

  AI_TENSOR_OBJ_DECLARE(input_output, , 0x0, 4,
3401b5da:	f107 03f4 	add.w	r3, r7, #244	@ 0xf4
3401b5de:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
3401b5e2:	2300      	movs	r3, #0
3401b5e4:	f8a7 30d4 	strh.w	r3, [r7, #212]	@ 0xd4
3401b5e8:	2304      	movs	r3, #4
3401b5ea:	f887 30d6 	strb.w	r3, [r7, #214]	@ 0xd6
3401b5ee:	2301      	movs	r3, #1
3401b5f0:	f887 30d7 	strb.w	r3, [r7, #215]	@ 0xd7
3401b5f4:	2301      	movs	r3, #1
3401b5f6:	f887 30d8 	strb.w	r3, [r7, #216]	@ 0xd8
3401b5fa:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
3401b5fe:	2204      	movs	r2, #4
3401b600:	f362 231f 	bfi	r3, r2, #8, #24
3401b604:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
3401b608:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b60c:	691b      	ldr	r3, [r3, #16]
3401b60e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3401b612:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b616:	68db      	ldr	r3, [r3, #12]
3401b618:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3401b61c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b620:	689b      	ldr	r3, [r3, #8]
3401b622:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
3401b626:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b62a:	685b      	ldr	r3, [r3, #4]
3401b62c:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
3401b630:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
3401b634:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3401b638:	2302      	movs	r3, #2
3401b63a:	f887 30e0 	strb.w	r3, [r7, #224]	@ 0xe0
3401b63e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
3401b642:	2204      	movs	r2, #4
3401b644:	f362 231f 	bfi	r3, r2, #8, #24
3401b648:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
3401b64c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b650:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401b652:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
3401b656:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b65a:	6a1b      	ldr	r3, [r3, #32]
3401b65c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3401b660:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b664:	69db      	ldr	r3, [r3, #28]
3401b666:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401b66a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b66e:	699b      	ldr	r3, [r3, #24]
3401b670:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3401b674:	f107 03b0 	add.w	r3, r7, #176	@ 0xb0
3401b678:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3401b67c:	f507 7386 	add.w	r3, r7, #268	@ 0x10c
3401b680:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
                                   sw_info->general.input.dim.tensor_c, sw_info->general.input.dim.tensor_b),
                        STRIDE_INIT(sw_info->general.input.stride.h, sw_info->general.input.stride.w,
                                    sw_info->general.input.stride.c, sw_info->general.input.stride.b),
                        1, &input_output_array, &input_intq);

  AI_TENSOR_OBJ_DECLARE(dequantize_output, , 0x0, 4,
3401b684:	2300      	movs	r3, #0
3401b686:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
3401b68a:	2300      	movs	r3, #0
3401b68c:	f8a7 3098 	strh.w	r3, [r7, #152]	@ 0x98
3401b690:	2304      	movs	r3, #4
3401b692:	f887 309a 	strb.w	r3, [r7, #154]	@ 0x9a
3401b696:	2301      	movs	r3, #1
3401b698:	f887 309b 	strb.w	r3, [r7, #155]	@ 0x9b
3401b69c:	2301      	movs	r3, #1
3401b69e:	f887 309c 	strb.w	r3, [r7, #156]	@ 0x9c
3401b6a2:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
3401b6a6:	2204      	movs	r2, #4
3401b6a8:	f362 231f 	bfi	r3, r2, #8, #24
3401b6ac:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
3401b6b0:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b6b4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3401b6b6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3401b6ba:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b6be:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401b6c0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
3401b6c4:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b6c8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401b6ca:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
3401b6ce:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b6d2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401b6d4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3401b6d8:	f107 0384 	add.w	r3, r7, #132	@ 0x84
3401b6dc:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
3401b6e0:	2302      	movs	r3, #2
3401b6e2:	f887 30a4 	strb.w	r3, [r7, #164]	@ 0xa4
3401b6e6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
3401b6ea:	2204      	movs	r2, #4
3401b6ec:	f362 231f 	bfi	r3, r2, #8, #24
3401b6f0:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
3401b6f4:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b6f8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3401b6fa:	677b      	str	r3, [r7, #116]	@ 0x74
3401b6fc:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b700:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401b702:	67bb      	str	r3, [r7, #120]	@ 0x78
3401b704:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b708:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401b70a:	67fb      	str	r3, [r7, #124]	@ 0x7c
3401b70c:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401b710:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401b712:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
3401b716:	f107 0374 	add.w	r3, r7, #116	@ 0x74
3401b71a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
3401b71e:	f107 03fc 	add.w	r3, r7, #252	@ 0xfc
3401b722:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
                        STRIDE_INIT(sw_info->general.output.stride.h, sw_info->general.output.stride.w,
                                    sw_info->general.output.stride.c, sw_info->general.output.stride.b),
                        1, &dequantize_output_array, NULL);

  // tensor chain initialization
  AI_TENSOR_CHAIN_OBJ_DECLARE(dequantize_chain, , 4, AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&input_output)),
3401b726:	2304      	movs	r3, #4
3401b728:	f8a7 306c 	strh.w	r3, [r7, #108]	@ 0x6c
3401b72c:	2300      	movs	r3, #0
3401b72e:	f8a7 306e 	strh.w	r3, [r7, #110]	@ 0x6e
3401b732:	2301      	movs	r3, #1
3401b734:	85bb      	strh	r3, [r7, #44]	@ 0x2c
3401b736:	2300      	movs	r3, #0
3401b738:	85fb      	strh	r3, [r7, #46]	@ 0x2e
3401b73a:	f107 03d0 	add.w	r3, r7, #208	@ 0xd0
3401b73e:	66bb      	str	r3, [r7, #104]	@ 0x68
3401b740:	f107 0368 	add.w	r3, r7, #104	@ 0x68
3401b744:	633b      	str	r3, [r7, #48]	@ 0x30
3401b746:	2300      	movs	r3, #0
3401b748:	637b      	str	r3, [r7, #52]	@ 0x34
3401b74a:	2301      	movs	r3, #1
3401b74c:	873b      	strh	r3, [r7, #56]	@ 0x38
3401b74e:	2300      	movs	r3, #0
3401b750:	877b      	strh	r3, [r7, #58]	@ 0x3a
3401b752:	f107 0394 	add.w	r3, r7, #148	@ 0x94
3401b756:	667b      	str	r3, [r7, #100]	@ 0x64
3401b758:	f107 0364 	add.w	r3, r7, #100	@ 0x64
3401b75c:	63fb      	str	r3, [r7, #60]	@ 0x3c
3401b75e:	2300      	movs	r3, #0
3401b760:	643b      	str	r3, [r7, #64]	@ 0x40
3401b762:	2300      	movs	r3, #0
3401b764:	f8a7 3044 	strh.w	r3, [r7, #68]	@ 0x44
3401b768:	2300      	movs	r3, #0
3401b76a:	f8a7 3046 	strh.w	r3, [r7, #70]	@ 0x46
3401b76e:	2300      	movs	r3, #0
3401b770:	663b      	str	r3, [r7, #96]	@ 0x60
3401b772:	f107 0360 	add.w	r3, r7, #96	@ 0x60
3401b776:	64bb      	str	r3, [r7, #72]	@ 0x48
3401b778:	2300      	movs	r3, #0
3401b77a:	64fb      	str	r3, [r7, #76]	@ 0x4c
3401b77c:	2300      	movs	r3, #0
3401b77e:	f8a7 3050 	strh.w	r3, [r7, #80]	@ 0x50
3401b782:	2300      	movs	r3, #0
3401b784:	f8a7 3052 	strh.w	r3, [r7, #82]	@ 0x52
3401b788:	2300      	movs	r3, #0
3401b78a:	65fb      	str	r3, [r7, #92]	@ 0x5c
3401b78c:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
3401b790:	657b      	str	r3, [r7, #84]	@ 0x54
3401b792:	2300      	movs	r3, #0
3401b794:	65bb      	str	r3, [r7, #88]	@ 0x58
3401b796:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
3401b79a:	673b      	str	r3, [r7, #112]	@ 0x70
                              AI_TENSOR_LIST_OBJ_INIT(AI_FLAG_NONE, 1, TENSORS(&dequantize_output)),
                              AI_TENSOR_LIST_OBJ_EMPTY, AI_TENSOR_LIST_OBJ_EMPTY)

  // layer initialization
  AI_LAYER_OBJ_DECLARE(dequantize_layer, 1, NL_TYPE, 0x0, NULL, nl, node_convert /*_fixed*/, &dequantize_chain, NULL,
3401b79c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7a0:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7a4:	4618      	mov	r0, r3
3401b7a6:	2320      	movs	r3, #32
3401b7a8:	461a      	mov	r2, r3
3401b7aa:	2100      	movs	r1, #0
3401b7ac:	f00b fcf2 	bl	34027194 <memset>
3401b7b0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7b4:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7b8:	f240 1207 	movw	r2, #263	@ 0x107
3401b7bc:	801a      	strh	r2, [r3, #0]
3401b7be:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7c2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7c6:	2201      	movs	r2, #1
3401b7c8:	805a      	strh	r2, [r3, #2]
3401b7ca:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7ce:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7d2:	4a0e      	ldr	r2, [pc, #56]	@ (3401b80c <ll_sw_forward_dequantizelinear+0x308>)
3401b7d4:	615a      	str	r2, [r3, #20]
3401b7d6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7da:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7de:	f107 026c 	add.w	r2, r7, #108	@ 0x6c
3401b7e2:	619a      	str	r2, [r3, #24]
                       NULL, )
  dequantize_layer.forward(AI_LAYER_OBJ(&dequantize_layer));
3401b7e4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
3401b7e8:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
3401b7ec:	695b      	ldr	r3, [r3, #20]
3401b7ee:	f107 020c 	add.w	r2, r7, #12
3401b7f2:	4610      	mov	r0, r2
3401b7f4:	4798      	blx	r3
}
3401b7f6:	bf00      	nop
3401b7f8:	f507 7794 	add.w	r7, r7, #296	@ 0x128
3401b7fc:	46bd      	mov	sp, r7
3401b7fe:	bd80      	pop	{r7, pc}
3401b800:	08840440 	.word	0x08840440
3401b804:	08040440 	.word	0x08040440
3401b808:	00821040 	.word	0x00821040
3401b80c:	340250a1 	.word	0x340250a1

3401b810 <LL_AHB4_GRP1_EnableClock>:
{
3401b810:	b480      	push	{r7}
3401b812:	b085      	sub	sp, #20
3401b814:	af00      	add	r7, sp, #0
3401b816:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
3401b818:	4a07      	ldr	r2, [pc, #28]	@ (3401b838 <LL_AHB4_GRP1_EnableClock+0x28>)
3401b81a:	687b      	ldr	r3, [r7, #4]
3401b81c:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
3401b820:	4b05      	ldr	r3, [pc, #20]	@ (3401b838 <LL_AHB4_GRP1_EnableClock+0x28>)
3401b822:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3401b826:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3401b828:	68fb      	ldr	r3, [r7, #12]
}
3401b82a:	bf00      	nop
3401b82c:	3714      	adds	r7, #20
3401b82e:	46bd      	mov	sp, r7
3401b830:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b834:	4770      	bx	lr
3401b836:	bf00      	nop
3401b838:	56028000 	.word	0x56028000

3401b83c <LL_APB5_GRP1_EnableClock>:
{
3401b83c:	b480      	push	{r7}
3401b83e:	b085      	sub	sp, #20
3401b840:	af00      	add	r7, sp, #0
3401b842:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5ENSR, Periphs);
3401b844:	4a07      	ldr	r2, [pc, #28]	@ (3401b864 <LL_APB5_GRP1_EnableClock+0x28>)
3401b846:	687b      	ldr	r3, [r7, #4]
3401b848:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  tmpreg = READ_REG(RCC->APB5ENR);
3401b84c:	4b05      	ldr	r3, [pc, #20]	@ (3401b864 <LL_APB5_GRP1_EnableClock+0x28>)
3401b84e:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
3401b852:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3401b854:	68fb      	ldr	r3, [r7, #12]
}
3401b856:	bf00      	nop
3401b858:	3714      	adds	r7, #20
3401b85a:	46bd      	mov	sp, r7
3401b85c:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b860:	4770      	bx	lr
3401b862:	bf00      	nop
3401b864:	56028000 	.word	0x56028000

3401b868 <LL_APB5_GRP1_ForceReset>:
{
3401b868:	b480      	push	{r7}
3401b86a:	b083      	sub	sp, #12
3401b86c:	af00      	add	r7, sp, #0
3401b86e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
3401b870:	4a04      	ldr	r2, [pc, #16]	@ (3401b884 <LL_APB5_GRP1_ForceReset+0x1c>)
3401b872:	687b      	ldr	r3, [r7, #4]
3401b874:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
3401b878:	bf00      	nop
3401b87a:	370c      	adds	r7, #12
3401b87c:	46bd      	mov	sp, r7
3401b87e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b882:	4770      	bx	lr
3401b884:	56028000 	.word	0x56028000

3401b888 <LL_APB5_GRP1_ReleaseReset>:
{
3401b888:	b480      	push	{r7}
3401b88a:	b083      	sub	sp, #12
3401b88c:	af00      	add	r7, sp, #0
3401b88e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
3401b890:	4b06      	ldr	r3, [pc, #24]	@ (3401b8ac <LL_APB5_GRP1_ReleaseReset+0x24>)
3401b892:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
3401b896:	461a      	mov	r2, r3
3401b898:	687b      	ldr	r3, [r7, #4]
3401b89a:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
3401b89e:	bf00      	nop
3401b8a0:	370c      	adds	r7, #12
3401b8a2:	46bd      	mov	sp, r7
3401b8a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b8a8:	4770      	bx	lr
3401b8aa:	bf00      	nop
3401b8ac:	56028000 	.word	0x56028000

3401b8b0 <LL_APB5_GRP1_EnableClockLowPower>:
{
3401b8b0:	b480      	push	{r7}
3401b8b2:	b085      	sub	sp, #20
3401b8b4:	af00      	add	r7, sp, #0
3401b8b6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5LPENSR, Periphs);
3401b8b8:	4a07      	ldr	r2, [pc, #28]	@ (3401b8d8 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
3401b8ba:	687b      	ldr	r3, [r7, #4]
3401b8bc:	f8c2 3abc 	str.w	r3, [r2, #2748]	@ 0xabc
  tmpreg = READ_REG(RCC->APB5LPENR);
3401b8c0:	4b05      	ldr	r3, [pc, #20]	@ (3401b8d8 <LL_APB5_GRP1_EnableClockLowPower+0x28>)
3401b8c2:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
3401b8c6:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3401b8c8:	68fb      	ldr	r3, [r7, #12]
}
3401b8ca:	bf00      	nop
3401b8cc:	3714      	adds	r7, #20
3401b8ce:	46bd      	mov	sp, r7
3401b8d0:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b8d4:	4770      	bx	lr
3401b8d6:	bf00      	nop
3401b8d8:	56028000 	.word	0x56028000

3401b8dc <CMW_CAMERA_GetDCMIPPHandle>:
static void CMW_CAMERA_PwrDown(void);
static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch);
static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName);

DCMIPP_HandleTypeDef* CMW_CAMERA_GetDCMIPPHandle(void)
{
3401b8dc:	b480      	push	{r7}
3401b8de:	af00      	add	r7, sp, #0
    return &hcamera_dcmipp;
3401b8e0:	4b02      	ldr	r3, [pc, #8]	@ (3401b8ec <CMW_CAMERA_GetDCMIPPHandle+0x10>)
}
3401b8e2:	4618      	mov	r0, r3
3401b8e4:	46bd      	mov	sp, r7
3401b8e6:	f85d 7b04 	ldr.w	r7, [sp], #4
3401b8ea:	4770      	bx	lr
3401b8ec:	3404a310 	.word	0x3404a310

3401b8f0 <CMW_CAMERA_SetPipeConfig>:

int32_t CMW_CAMERA_SetPipeConfig(uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3401b8f0:	b580      	push	{r7, lr}
3401b8f2:	b084      	sub	sp, #16
3401b8f4:	af00      	add	r7, sp, #0
3401b8f6:	60f8      	str	r0, [r7, #12]
3401b8f8:	60b9      	str	r1, [r7, #8]
3401b8fa:	607a      	str	r2, [r7, #4]
  return CMW_CAMERA_SetPipe(&hcamera_dcmipp, pipe, p_conf, pitch);
3401b8fc:	687b      	ldr	r3, [r7, #4]
3401b8fe:	68ba      	ldr	r2, [r7, #8]
3401b900:	68f9      	ldr	r1, [r7, #12]
3401b902:	4804      	ldr	r0, [pc, #16]	@ (3401b914 <CMW_CAMERA_SetPipeConfig+0x24>)
3401b904:	f000 fbae 	bl	3401c064 <CMW_CAMERA_SetPipe>
3401b908:	4603      	mov	r3, r0
}
3401b90a:	4618      	mov	r0, r3
3401b90c:	3710      	adds	r7, #16
3401b90e:	46bd      	mov	sp, r7
3401b910:	bd80      	pop	{r7, pc}
3401b912:	bf00      	nop
3401b914:	3404a310 	.word	0x3404a310

3401b918 <CMW_CAMERA_Probe_Sensor>:
  *sensorName = detected_sensor;
  return CMW_ERROR_NONE;
}

static int CMW_CAMERA_Probe_Sensor(CMW_Sensor_Init_t *initValues, CMW_Sensor_Name_t *sensorName)
{
3401b918:	b580      	push	{r7, lr}
3401b91a:	b084      	sub	sp, #16
3401b91c:	af00      	add	r7, sp, #0
3401b91e:	6078      	str	r0, [r7, #4]
3401b920:	6039      	str	r1, [r7, #0]
    *sensorName = CMW_VD66GY_Sensor;
    return ret;
  }
#endif
#if defined(USE_IMX335_SENSOR)
  ret = CMW_CAMERA_IMX335_Init(initValues);
3401b922:	6878      	ldr	r0, [r7, #4]
3401b924:	f000 faae 	bl	3401be84 <CMW_CAMERA_IMX335_Init>
3401b928:	60f8      	str	r0, [r7, #12]
  if (ret == CMW_ERROR_NONE)
3401b92a:	68fb      	ldr	r3, [r7, #12]
3401b92c:	2b00      	cmp	r3, #0
3401b92e:	d104      	bne.n	3401b93a <CMW_CAMERA_Probe_Sensor+0x22>
  {
    *sensorName = CMW_IMX335_Sensor;
3401b930:	683b      	ldr	r3, [r7, #0]
3401b932:	2201      	movs	r2, #1
3401b934:	701a      	strb	r2, [r3, #0]
    return ret;
3401b936:	68fb      	ldr	r3, [r7, #12]
3401b938:	e001      	b.n	3401b93e <CMW_CAMERA_Probe_Sensor+0x26>
  }
#endif
  else
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401b93a:	f06f 0306 	mvn.w	r3, #6
  }
}
3401b93e:	4618      	mov	r0, r3
3401b940:	3710      	adds	r7, #16
3401b942:	46bd      	mov	sp, r7
3401b944:	bd80      	pop	{r7, pc}
	...

3401b948 <CMW_CAMERA_Init>:
  * @brief  Initializes the camera.
  * @param  initConf  Camera sensor requested config
  * @retval CMW status
  */
int32_t CMW_CAMERA_Init(CMW_CameraInit_t *initConf)
{
3401b948:	b5b0      	push	{r4, r5, r7, lr}
3401b94a:	b098      	sub	sp, #96	@ 0x60
3401b94c:	af00      	add	r7, sp, #0
3401b94e:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3401b950:	2300      	movs	r3, #0
3401b952:	65fb      	str	r3, [r7, #92]	@ 0x5c
  CMW_Sensor_Init_t initValues;
  ISP_SensorInfoTypeDef info = {0};
3401b954:	f107 030c 	add.w	r3, r7, #12
3401b958:	223c      	movs	r2, #60	@ 0x3c
3401b95a:	2100      	movs	r1, #0
3401b95c:	4618      	mov	r0, r3
3401b95e:	f00b fc19 	bl	34027194 <memset>

  initValues.width = initConf->width;
3401b962:	687b      	ldr	r3, [r7, #4]
3401b964:	681b      	ldr	r3, [r3, #0]
3401b966:	64bb      	str	r3, [r7, #72]	@ 0x48
  initValues.height = initConf->height;
3401b968:	687b      	ldr	r3, [r7, #4]
3401b96a:	685b      	ldr	r3, [r3, #4]
3401b96c:	64fb      	str	r3, [r7, #76]	@ 0x4c
  initValues.fps = initConf->fps;
3401b96e:	687b      	ldr	r3, [r7, #4]
3401b970:	689b      	ldr	r3, [r3, #8]
3401b972:	653b      	str	r3, [r7, #80]	@ 0x50
  initValues.pixel_format = initConf->pixel_format;
3401b974:	687b      	ldr	r3, [r7, #4]
3401b976:	68db      	ldr	r3, [r3, #12]
3401b978:	657b      	str	r3, [r7, #84]	@ 0x54
  initValues.mirrorFlip = initConf->mirror_flip;
3401b97a:	687b      	ldr	r3, [r7, #4]
3401b97c:	695b      	ldr	r3, [r3, #20]
3401b97e:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (is_camera_init != 0)
3401b980:	4b37      	ldr	r3, [pc, #220]	@ (3401ba60 <CMW_CAMERA_Init+0x118>)
3401b982:	681b      	ldr	r3, [r3, #0]
3401b984:	2b00      	cmp	r3, #0
3401b986:	d001      	beq.n	3401b98c <CMW_CAMERA_Init+0x44>
  {
    return CMW_ERROR_NONE;
3401b988:	2300      	movs	r3, #0
3401b98a:	e064      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }

  /* Set DCMIPP instance */
  hcamera_dcmipp.Instance = DCMIPP;
3401b98c:	4b35      	ldr	r3, [pc, #212]	@ (3401ba64 <CMW_CAMERA_Init+0x11c>)
3401b98e:	4a36      	ldr	r2, [pc, #216]	@ (3401ba68 <CMW_CAMERA_Init+0x120>)
3401b990:	601a      	str	r2, [r3, #0]

  /* Configure DCMIPP clock */
  ret = MX_DCMIPP_ClockConfig(&hcamera_dcmipp);
3401b992:	4834      	ldr	r0, [pc, #208]	@ (3401ba64 <CMW_CAMERA_Init+0x11c>)
3401b994:	f7e7 f90a 	bl	34002bac <MX_DCMIPP_ClockConfig>
3401b998:	4603      	mov	r3, r0
3401b99a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3401b99c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401b99e:	2b00      	cmp	r3, #0
3401b9a0:	d002      	beq.n	3401b9a8 <CMW_CAMERA_Init+0x60>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3401b9a2:	f06f 0303 	mvn.w	r3, #3
3401b9a6:	e056      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }
  /* Enable DCMIPP clock */
  ret = HAL_DCMIPP_Init(&hcamera_dcmipp);
3401b9a8:	482e      	ldr	r0, [pc, #184]	@ (3401ba64 <CMW_CAMERA_Init+0x11c>)
3401b9aa:	f7eb fc1a 	bl	340071e2 <HAL_DCMIPP_Init>
3401b9ae:	4603      	mov	r3, r0
3401b9b0:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (ret != HAL_OK)
3401b9b2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401b9b4:	2b00      	cmp	r3, #0
3401b9b6:	d002      	beq.n	3401b9be <CMW_CAMERA_Init+0x76>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3401b9b8:	f06f 0303 	mvn.w	r3, #3
3401b9bc:	e04b      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }

  CMW_CAMERA_EnableGPIOs();
3401b9be:	f000 f9a1 	bl	3401bd04 <CMW_CAMERA_EnableGPIOs>

  ret = CMW_CAMERA_Probe_Sensor(&initValues, &detected_sensor);
3401b9c2:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3401b9c6:	4929      	ldr	r1, [pc, #164]	@ (3401ba6c <CMW_CAMERA_Init+0x124>)
3401b9c8:	4618      	mov	r0, r3
3401b9ca:	f7ff ffa5 	bl	3401b918 <CMW_CAMERA_Probe_Sensor>
3401b9ce:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret != CMW_ERROR_NONE)
3401b9d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401b9d2:	2b00      	cmp	r3, #0
3401b9d4:	d002      	beq.n	3401b9dc <CMW_CAMERA_Init+0x94>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401b9d6:	f06f 0306 	mvn.w	r3, #6
3401b9da:	e03c      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }

  /* Configure exposure and gain for a more suitable quality */
  ret = CMW_CAMERA_GetSensorInfo(&info);
3401b9dc:	f107 030c 	add.w	r3, r7, #12
3401b9e0:	4618      	mov	r0, r3
3401b9e2:	f000 f8f7 	bl	3401bbd4 <CMW_CAMERA_GetSensorInfo>
3401b9e6:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3401b9e8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401b9ea:	f113 0f05 	cmn.w	r3, #5
3401b9ee:	d102      	bne.n	3401b9f6 <CMW_CAMERA_Init+0xae>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401b9f0:	f06f 0306 	mvn.w	r3, #6
3401b9f4:	e02f      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }
  ret = CMW_CAMERA_SetExposure(info.exposure_min);
3401b9f6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401b9f8:	4618      	mov	r0, r3
3401b9fa:	f000 f8b3 	bl	3401bb64 <CMW_CAMERA_SetExposure>
3401b9fe:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3401ba00:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401ba02:	f113 0f05 	cmn.w	r3, #5
3401ba06:	d102      	bne.n	3401ba0e <CMW_CAMERA_Init+0xc6>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401ba08:	f06f 0306 	mvn.w	r3, #6
3401ba0c:	e023      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }
  ret = CMW_CAMERA_SetGain(info.gain_min);
3401ba0e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3401ba10:	4618      	mov	r0, r3
3401ba12:	f000 f86f 	bl	3401baf4 <CMW_CAMERA_SetGain>
3401ba16:	65f8      	str	r0, [r7, #92]	@ 0x5c
  if (ret == CMW_ERROR_COMPONENT_FAILURE)
3401ba18:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3401ba1a:	f113 0f05 	cmn.w	r3, #5
3401ba1e:	d102      	bne.n	3401ba26 <CMW_CAMERA_Init+0xde>
  {
    return CMW_ERROR_UNKNOWN_COMPONENT;
3401ba20:	f06f 0306 	mvn.w	r3, #6
3401ba24:	e017      	b.n	3401ba56 <CMW_CAMERA_Init+0x10e>
  }

  /* Write back the initValue width and height that might be changed */
  initConf->width = initValues.width;
3401ba26:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3401ba28:	687b      	ldr	r3, [r7, #4]
3401ba2a:	601a      	str	r2, [r3, #0]
  initConf->height = initValues.height ;
3401ba2c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
3401ba2e:	687b      	ldr	r3, [r7, #4]
3401ba30:	605a      	str	r2, [r3, #4]
  camera_conf = *initConf;
3401ba32:	4a0f      	ldr	r2, [pc, #60]	@ (3401ba70 <CMW_CAMERA_Init+0x128>)
3401ba34:	687b      	ldr	r3, [r7, #4]
3401ba36:	4614      	mov	r4, r2
3401ba38:	461d      	mov	r5, r3
3401ba3a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3401ba3c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3401ba3e:	e895 0003 	ldmia.w	r5, {r0, r1}
3401ba42:	e884 0003 	stmia.w	r4, {r0, r1}

  is_camera_init++;
3401ba46:	4b06      	ldr	r3, [pc, #24]	@ (3401ba60 <CMW_CAMERA_Init+0x118>)
3401ba48:	681b      	ldr	r3, [r3, #0]
3401ba4a:	3301      	adds	r3, #1
3401ba4c:	4a04      	ldr	r2, [pc, #16]	@ (3401ba60 <CMW_CAMERA_Init+0x118>)
3401ba4e:	6013      	str	r3, [r2, #0]
  /* CMW status */
  ret = CMW_ERROR_NONE;
3401ba50:	2300      	movs	r3, #0
3401ba52:	65fb      	str	r3, [r7, #92]	@ 0x5c
  return ret;
3401ba54:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
}
3401ba56:	4618      	mov	r0, r3
3401ba58:	3760      	adds	r7, #96	@ 0x60
3401ba5a:	46bd      	mov	sp, r7
3401ba5c:	bdb0      	pop	{r4, r5, r7, pc}
3401ba5e:	bf00      	nop
3401ba60:	3404a480 	.word	0x3404a480
3401ba64:	3404a310 	.word	0x3404a310
3401ba68:	58002000 	.word	0x58002000
3401ba6c:	3404a2cc 	.word	0x3404a2cc
3401ba70:	3404a2b4 	.word	0x3404a2b4

3401ba74 <CMW_CAMERA_Start>:
  * @param  pbuff pointer to the camera output buffer
  * @param  mode  CMW_MODE_CONTINUOUS or CMW_MODE_SNAPSHOT
  * @retval CMW status
  */
int32_t CMW_CAMERA_Start(uint32_t pipe, uint8_t *pbuff, uint32_t mode)
{
3401ba74:	b580      	push	{r7, lr}
3401ba76:	b088      	sub	sp, #32
3401ba78:	af02      	add	r7, sp, #8
3401ba7a:	60f8      	str	r0, [r7, #12]
3401ba7c:	60b9      	str	r1, [r7, #8]
3401ba7e:	607a      	str	r2, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3401ba80:	2300      	movs	r3, #0
3401ba82:	617b      	str	r3, [r7, #20]

  if (pipe >= DCMIPP_NUM_OF_PIPES)
3401ba84:	68fb      	ldr	r3, [r7, #12]
3401ba86:	2b02      	cmp	r3, #2
3401ba88:	d902      	bls.n	3401ba90 <CMW_CAMERA_Start+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3401ba8a:	f06f 0301 	mvn.w	r3, #1
3401ba8e:	e025      	b.n	3401badc <CMW_CAMERA_Start+0x68>
  }

  ret = HAL_DCMIPP_CSI_PIPE_Start(&hcamera_dcmipp, pipe, DCMIPP_VIRTUAL_CHANNEL0, (uint32_t)pbuff, mode);
3401ba90:	68ba      	ldr	r2, [r7, #8]
3401ba92:	687b      	ldr	r3, [r7, #4]
3401ba94:	9300      	str	r3, [sp, #0]
3401ba96:	4613      	mov	r3, r2
3401ba98:	2200      	movs	r2, #0
3401ba9a:	68f9      	ldr	r1, [r7, #12]
3401ba9c:	4811      	ldr	r0, [pc, #68]	@ (3401bae4 <CMW_CAMERA_Start+0x70>)
3401ba9e:	f7eb fe57 	bl	34007750 <HAL_DCMIPP_CSI_PIPE_Start>
3401baa2:	4603      	mov	r3, r0
3401baa4:	617b      	str	r3, [r7, #20]
  if (ret != HAL_OK)
3401baa6:	697b      	ldr	r3, [r7, #20]
3401baa8:	2b00      	cmp	r3, #0
3401baaa:	d002      	beq.n	3401bab2 <CMW_CAMERA_Start+0x3e>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3401baac:	f06f 0303 	mvn.w	r3, #3
3401bab0:	e014      	b.n	3401badc <CMW_CAMERA_Start+0x68>
  }

  if (!is_camera_started)
3401bab2:	4b0d      	ldr	r3, [pc, #52]	@ (3401bae8 <CMW_CAMERA_Start+0x74>)
3401bab4:	681b      	ldr	r3, [r3, #0]
3401bab6:	2b00      	cmp	r3, #0
3401bab8:	d10f      	bne.n	3401bada <CMW_CAMERA_Start+0x66>
  {
    ret = Camera_Drv.Start(&camera_bsp);
3401baba:	4b0c      	ldr	r3, [pc, #48]	@ (3401baec <CMW_CAMERA_Start+0x78>)
3401babc:	689b      	ldr	r3, [r3, #8]
3401babe:	480c      	ldr	r0, [pc, #48]	@ (3401baf0 <CMW_CAMERA_Start+0x7c>)
3401bac0:	4798      	blx	r3
3401bac2:	6178      	str	r0, [r7, #20]
    if (ret != CMW_ERROR_NONE)
3401bac4:	697b      	ldr	r3, [r7, #20]
3401bac6:	2b00      	cmp	r3, #0
3401bac8:	d002      	beq.n	3401bad0 <CMW_CAMERA_Start+0x5c>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401baca:	f06f 0304 	mvn.w	r3, #4
3401bace:	e005      	b.n	3401badc <CMW_CAMERA_Start+0x68>
    }
    is_camera_started++;
3401bad0:	4b05      	ldr	r3, [pc, #20]	@ (3401bae8 <CMW_CAMERA_Start+0x74>)
3401bad2:	681b      	ldr	r3, [r3, #0]
3401bad4:	3301      	adds	r3, #1
3401bad6:	4a04      	ldr	r2, [pc, #16]	@ (3401bae8 <CMW_CAMERA_Start+0x74>)
3401bad8:	6013      	str	r3, [r2, #0]
  }

  /* Return CMW status */
  return ret;
3401bada:	697b      	ldr	r3, [r7, #20]
}
3401badc:	4618      	mov	r0, r3
3401bade:	3718      	adds	r7, #24
3401bae0:	46bd      	mov	sp, r7
3401bae2:	bd80      	pop	{r7, pc}
3401bae4:	3404a310 	.word	0x3404a310
3401bae8:	3404a484 	.word	0x3404a484
3401baec:	3404a31c 	.word	0x3404a31c
3401baf0:	3404a37c 	.word	0x3404a37c

3401baf4 <CMW_CAMERA_SetGain>:
  * @brief  Set the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_SetGain(int32_t Gain)
{
3401baf4:	b580      	push	{r7, lr}
3401baf6:	b084      	sub	sp, #16
3401baf8:	af00      	add	r7, sp, #0
3401bafa:	6078      	str	r0, [r7, #4]
  int ret;
  if(Camera_Drv.SetGain == NULL)
3401bafc:	4b0d      	ldr	r3, [pc, #52]	@ (3401bb34 <CMW_CAMERA_SetGain+0x40>)
3401bafe:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401bb00:	2b00      	cmp	r3, #0
3401bb02:	d102      	bne.n	3401bb0a <CMW_CAMERA_SetGain+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3401bb04:	f06f 030a 	mvn.w	r3, #10
3401bb08:	e00f      	b.n	3401bb2a <CMW_CAMERA_SetGain+0x36>
  }

  ret = Camera_Drv.SetGain(&camera_bsp, Gain);
3401bb0a:	4b0a      	ldr	r3, [pc, #40]	@ (3401bb34 <CMW_CAMERA_SetGain+0x40>)
3401bb0c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401bb0e:	6879      	ldr	r1, [r7, #4]
3401bb10:	4809      	ldr	r0, [pc, #36]	@ (3401bb38 <CMW_CAMERA_SetGain+0x44>)
3401bb12:	4798      	blx	r3
3401bb14:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3401bb16:	68fb      	ldr	r3, [r7, #12]
3401bb18:	2b00      	cmp	r3, #0
3401bb1a:	d002      	beq.n	3401bb22 <CMW_CAMERA_SetGain+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bb1c:	f06f 0304 	mvn.w	r3, #4
3401bb20:	e003      	b.n	3401bb2a <CMW_CAMERA_SetGain+0x36>
  }

  Camera_Ctx.Gain = Gain;
3401bb22:	4a06      	ldr	r2, [pc, #24]	@ (3401bb3c <CMW_CAMERA_SetGain+0x48>)
3401bb24:	687b      	ldr	r3, [r7, #4]
3401bb26:	6213      	str	r3, [r2, #32]
  return CMW_ERROR_NONE;
3401bb28:	2300      	movs	r3, #0
}
3401bb2a:	4618      	mov	r0, r3
3401bb2c:	3710      	adds	r7, #16
3401bb2e:	46bd      	mov	sp, r7
3401bb30:	bd80      	pop	{r7, pc}
3401bb32:	bf00      	nop
3401bb34:	3404a31c 	.word	0x3404a31c
3401bb38:	3404a37c 	.word	0x3404a37c
3401bb3c:	3404a2d0 	.word	0x3404a2d0

3401bb40 <CMW_CAMERA_GetGain>:
  * @brief  Get the camera gain.
  * @param  Gain     Gain in mdB
  * @retval CMW status
  */
int CMW_CAMERA_GetGain(int32_t *Gain)
{
3401bb40:	b480      	push	{r7}
3401bb42:	b083      	sub	sp, #12
3401bb44:	af00      	add	r7, sp, #0
3401bb46:	6078      	str	r0, [r7, #4]
  *Gain = Camera_Ctx.Gain;
3401bb48:	4b05      	ldr	r3, [pc, #20]	@ (3401bb60 <CMW_CAMERA_GetGain+0x20>)
3401bb4a:	6a1a      	ldr	r2, [r3, #32]
3401bb4c:	687b      	ldr	r3, [r7, #4]
3401bb4e:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3401bb50:	2300      	movs	r3, #0
}
3401bb52:	4618      	mov	r0, r3
3401bb54:	370c      	adds	r7, #12
3401bb56:	46bd      	mov	sp, r7
3401bb58:	f85d 7b04 	ldr.w	r7, [sp], #4
3401bb5c:	4770      	bx	lr
3401bb5e:	bf00      	nop
3401bb60:	3404a2d0 	.word	0x3404a2d0

3401bb64 <CMW_CAMERA_SetExposure>:
  * @brief  Set the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_SetExposure(int32_t exposure)
{
3401bb64:	b580      	push	{r7, lr}
3401bb66:	b084      	sub	sp, #16
3401bb68:	af00      	add	r7, sp, #0
3401bb6a:	6078      	str	r0, [r7, #4]
  int ret;

  if(Camera_Drv.SetExposure == NULL)
3401bb6c:	4b0d      	ldr	r3, [pc, #52]	@ (3401bba4 <CMW_CAMERA_SetExposure+0x40>)
3401bb6e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401bb70:	2b00      	cmp	r3, #0
3401bb72:	d102      	bne.n	3401bb7a <CMW_CAMERA_SetExposure+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3401bb74:	f06f 030a 	mvn.w	r3, #10
3401bb78:	e00f      	b.n	3401bb9a <CMW_CAMERA_SetExposure+0x36>
  }

  ret = Camera_Drv.SetExposure(&camera_bsp, exposure);
3401bb7a:	4b0a      	ldr	r3, [pc, #40]	@ (3401bba4 <CMW_CAMERA_SetExposure+0x40>)
3401bb7c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401bb7e:	6879      	ldr	r1, [r7, #4]
3401bb80:	4809      	ldr	r0, [pc, #36]	@ (3401bba8 <CMW_CAMERA_SetExposure+0x44>)
3401bb82:	4798      	blx	r3
3401bb84:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3401bb86:	68fb      	ldr	r3, [r7, #12]
3401bb88:	2b00      	cmp	r3, #0
3401bb8a:	d002      	beq.n	3401bb92 <CMW_CAMERA_SetExposure+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bb8c:	f06f 0304 	mvn.w	r3, #4
3401bb90:	e003      	b.n	3401bb9a <CMW_CAMERA_SetExposure+0x36>
  }

  Camera_Ctx.Exposure = exposure;
3401bb92:	4a06      	ldr	r2, [pc, #24]	@ (3401bbac <CMW_CAMERA_SetExposure+0x48>)
3401bb94:	687b      	ldr	r3, [r7, #4]
3401bb96:	6253      	str	r3, [r2, #36]	@ 0x24
  return CMW_ERROR_NONE;
3401bb98:	2300      	movs	r3, #0
}
3401bb9a:	4618      	mov	r0, r3
3401bb9c:	3710      	adds	r7, #16
3401bb9e:	46bd      	mov	sp, r7
3401bba0:	bd80      	pop	{r7, pc}
3401bba2:	bf00      	nop
3401bba4:	3404a31c 	.word	0x3404a31c
3401bba8:	3404a37c 	.word	0x3404a37c
3401bbac:	3404a2d0 	.word	0x3404a2d0

3401bbb0 <CMW_CAMERA_GetExposure>:
  * @brief  Get the camera exposure.
  * @param  exposure exposure in microseconds
  * @retval CMW status
  */
int CMW_CAMERA_GetExposure(int32_t *exposure)
{
3401bbb0:	b480      	push	{r7}
3401bbb2:	b083      	sub	sp, #12
3401bbb4:	af00      	add	r7, sp, #0
3401bbb6:	6078      	str	r0, [r7, #4]
  *exposure = Camera_Ctx.Exposure;
3401bbb8:	4b05      	ldr	r3, [pc, #20]	@ (3401bbd0 <CMW_CAMERA_GetExposure+0x20>)
3401bbba:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
3401bbbc:	687b      	ldr	r3, [r7, #4]
3401bbbe:	601a      	str	r2, [r3, #0]
  return CMW_ERROR_NONE;
3401bbc0:	2300      	movs	r3, #0
}
3401bbc2:	4618      	mov	r0, r3
3401bbc4:	370c      	adds	r7, #12
3401bbc6:	46bd      	mov	sp, r7
3401bbc8:	f85d 7b04 	ldr.w	r7, [sp], #4
3401bbcc:	4770      	bx	lr
3401bbce:	bf00      	nop
3401bbd0:	3404a2d0 	.word	0x3404a2d0

3401bbd4 <CMW_CAMERA_GetSensorInfo>:
  * @note   This function should be called after the init. This to get Capabilities
  *         from the camera sensor
  * @retval Component status
  */
int32_t CMW_CAMERA_GetSensorInfo(ISP_SensorInfoTypeDef *info)
{
3401bbd4:	b580      	push	{r7, lr}
3401bbd6:	b084      	sub	sp, #16
3401bbd8:	af00      	add	r7, sp, #0
3401bbda:	6078      	str	r0, [r7, #4]

  int32_t ret;

  if(Camera_Drv.GetSensorInfo == NULL)
3401bbdc:	4b0b      	ldr	r3, [pc, #44]	@ (3401bc0c <CMW_CAMERA_GetSensorInfo+0x38>)
3401bbde:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401bbe0:	2b00      	cmp	r3, #0
3401bbe2:	d102      	bne.n	3401bbea <CMW_CAMERA_GetSensorInfo+0x16>
  {
    return CMW_ERROR_FEATURE_NOT_SUPPORTED;
3401bbe4:	f06f 030a 	mvn.w	r3, #10
3401bbe8:	e00c      	b.n	3401bc04 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  ret = Camera_Drv.GetSensorInfo(&camera_bsp, info);
3401bbea:	4b08      	ldr	r3, [pc, #32]	@ (3401bc0c <CMW_CAMERA_GetSensorInfo+0x38>)
3401bbec:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401bbee:	6879      	ldr	r1, [r7, #4]
3401bbf0:	4807      	ldr	r0, [pc, #28]	@ (3401bc10 <CMW_CAMERA_GetSensorInfo+0x3c>)
3401bbf2:	4798      	blx	r3
3401bbf4:	60f8      	str	r0, [r7, #12]
  if (ret != CMW_ERROR_NONE)
3401bbf6:	68fb      	ldr	r3, [r7, #12]
3401bbf8:	2b00      	cmp	r3, #0
3401bbfa:	d002      	beq.n	3401bc02 <CMW_CAMERA_GetSensorInfo+0x2e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bbfc:	f06f 0304 	mvn.w	r3, #4
3401bc00:	e000      	b.n	3401bc04 <CMW_CAMERA_GetSensorInfo+0x30>
  }

  return CMW_ERROR_NONE;
3401bc02:	2300      	movs	r3, #0
}
3401bc04:	4618      	mov	r0, r3
3401bc06:	3710      	adds	r7, #16
3401bc08:	46bd      	mov	sp, r7
3401bc0a:	bd80      	pop	{r7, pc}
3401bc0c:	3404a31c 	.word	0x3404a31c
3401bc10:	3404a37c 	.word	0x3404a37c

3401bc14 <CMW_CAMERA_Run>:



int32_t CMW_CAMERA_Run()
{
3401bc14:	b580      	push	{r7, lr}
3401bc16:	af00      	add	r7, sp, #0
  if(Camera_Drv.Run != NULL)
3401bc18:	4b06      	ldr	r3, [pc, #24]	@ (3401bc34 <CMW_CAMERA_Run+0x20>)
3401bc1a:	68db      	ldr	r3, [r3, #12]
3401bc1c:	2b00      	cmp	r3, #0
3401bc1e:	d005      	beq.n	3401bc2c <CMW_CAMERA_Run+0x18>
  {
      return Camera_Drv.Run(&camera_bsp);
3401bc20:	4b04      	ldr	r3, [pc, #16]	@ (3401bc34 <CMW_CAMERA_Run+0x20>)
3401bc22:	68db      	ldr	r3, [r3, #12]
3401bc24:	4804      	ldr	r0, [pc, #16]	@ (3401bc38 <CMW_CAMERA_Run+0x24>)
3401bc26:	4798      	blx	r3
3401bc28:	4603      	mov	r3, r0
3401bc2a:	e000      	b.n	3401bc2e <CMW_CAMERA_Run+0x1a>
  }
  return CMW_ERROR_NONE;
3401bc2c:	2300      	movs	r3, #0
}
3401bc2e:	4618      	mov	r0, r3
3401bc30:	bd80      	pop	{r7, pc}
3401bc32:	bf00      	nop
3401bc34:	3404a31c 	.word	0x3404a31c
3401bc38:	3404a37c 	.word	0x3404a37c

3401bc3c <HAL_DCMIPP_PIPE_VsyncEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_VsyncEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3401bc3c:	b580      	push	{r7, lr}
3401bc3e:	b082      	sub	sp, #8
3401bc40:	af00      	add	r7, sp, #0
3401bc42:	6078      	str	r0, [r7, #4]
3401bc44:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.VsyncEventCallback != NULL)
3401bc46:	4b08      	ldr	r3, [pc, #32]	@ (3401bc68 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
3401bc48:	691b      	ldr	r3, [r3, #16]
3401bc4a:	2b00      	cmp	r3, #0
3401bc4c:	d004      	beq.n	3401bc58 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x1c>
  {
      Camera_Drv.VsyncEventCallback(&camera_bsp, Pipe);
3401bc4e:	4b06      	ldr	r3, [pc, #24]	@ (3401bc68 <HAL_DCMIPP_PIPE_VsyncEventCallback+0x2c>)
3401bc50:	691b      	ldr	r3, [r3, #16]
3401bc52:	6839      	ldr	r1, [r7, #0]
3401bc54:	4805      	ldr	r0, [pc, #20]	@ (3401bc6c <HAL_DCMIPP_PIPE_VsyncEventCallback+0x30>)
3401bc56:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_VsyncEventCallback(Pipe);
3401bc58:	6838      	ldr	r0, [r7, #0]
3401bc5a:	f7e6 fff9 	bl	34002c50 <CMW_CAMERA_PIPE_VsyncEventCallback>
}
3401bc5e:	bf00      	nop
3401bc60:	3708      	adds	r7, #8
3401bc62:	46bd      	mov	sp, r7
3401bc64:	bd80      	pop	{r7, pc}
3401bc66:	bf00      	nop
3401bc68:	3404a31c 	.word	0x3404a31c
3401bc6c:	3404a37c 	.word	0x3404a37c

3401bc70 <HAL_DCMIPP_PIPE_FrameEventCallback>:
 * @param  hdcmipp DCMIPP device handle
 *         Pipe    Pipe receiving the callback
 * @retval None
 */
void HAL_DCMIPP_PIPE_FrameEventCallback(DCMIPP_HandleTypeDef *hdcmipp, uint32_t Pipe)
{
3401bc70:	b580      	push	{r7, lr}
3401bc72:	b082      	sub	sp, #8
3401bc74:	af00      	add	r7, sp, #0
3401bc76:	6078      	str	r0, [r7, #4]
3401bc78:	6039      	str	r1, [r7, #0]
  UNUSED(hdcmipp);
  if(Camera_Drv.FrameEventCallback != NULL)
3401bc7a:	4b08      	ldr	r3, [pc, #32]	@ (3401bc9c <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
3401bc7c:	695b      	ldr	r3, [r3, #20]
3401bc7e:	2b00      	cmp	r3, #0
3401bc80:	d004      	beq.n	3401bc8c <HAL_DCMIPP_PIPE_FrameEventCallback+0x1c>
  {
      Camera_Drv.FrameEventCallback(&camera_bsp, Pipe);
3401bc82:	4b06      	ldr	r3, [pc, #24]	@ (3401bc9c <HAL_DCMIPP_PIPE_FrameEventCallback+0x2c>)
3401bc84:	695b      	ldr	r3, [r3, #20]
3401bc86:	6839      	ldr	r1, [r7, #0]
3401bc88:	4805      	ldr	r0, [pc, #20]	@ (3401bca0 <HAL_DCMIPP_PIPE_FrameEventCallback+0x30>)
3401bc8a:	4798      	blx	r3
  }
  CMW_CAMERA_PIPE_FrameEventCallback(Pipe);
3401bc8c:	6838      	ldr	r0, [r7, #0]
3401bc8e:	f7e7 f801 	bl	34002c94 <CMW_CAMERA_PIPE_FrameEventCallback>
}
3401bc92:	bf00      	nop
3401bc94:	3708      	adds	r7, #8
3401bc96:	46bd      	mov	sp, r7
3401bc98:	bd80      	pop	{r7, pc}
3401bc9a:	bf00      	nop
3401bc9c:	3404a31c 	.word	0x3404a31c
3401bca0:	3404a37c 	.word	0x3404a37c

3401bca4 <HAL_DCMIPP_MspInit>:
  * @brief  Initializes the DCMIPP MSP.
  * @param  hdcmipp  DCMIPP handle
  * @retval None
  */
void HAL_DCMIPP_MspInit(DCMIPP_HandleTypeDef *hdcmipp)
{
3401bca4:	b580      	push	{r7, lr}
3401bca6:	b082      	sub	sp, #8
3401bca8:	af00      	add	r7, sp, #0
3401bcaa:	6078      	str	r0, [r7, #4]
  UNUSED(hdcmipp);

  /*** Enable peripheral clock ***/
  /* Enable DCMIPP clock */
  __HAL_RCC_DCMIPP_CLK_ENABLE();
3401bcac:	2004      	movs	r0, #4
3401bcae:	f7ff fdc5 	bl	3401b83c <LL_APB5_GRP1_EnableClock>
  __HAL_RCC_DCMIPP_CLK_SLEEP_ENABLE();
3401bcb2:	2004      	movs	r0, #4
3401bcb4:	f7ff fdfc 	bl	3401b8b0 <LL_APB5_GRP1_EnableClockLowPower>
  __HAL_RCC_DCMIPP_FORCE_RESET();
3401bcb8:	2004      	movs	r0, #4
3401bcba:	f7ff fdd5 	bl	3401b868 <LL_APB5_GRP1_ForceReset>
  __HAL_RCC_DCMIPP_RELEASE_RESET();
3401bcbe:	2004      	movs	r0, #4
3401bcc0:	f7ff fde2 	bl	3401b888 <LL_APB5_GRP1_ReleaseReset>

  /*** Configure the NVIC for DCMIPP ***/
  /* NVIC configuration for DCMIPP transfer complete interrupt */
  HAL_NVIC_SetPriority(DCMIPP_IRQn, 0x07, 0);
3401bcc4:	2200      	movs	r2, #0
3401bcc6:	2107      	movs	r1, #7
3401bcc8:	2030      	movs	r0, #48	@ 0x30
3401bcca:	f7eb fa5f 	bl	3400718c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DCMIPP_IRQn);
3401bcce:	2030      	movs	r0, #48	@ 0x30
3401bcd0:	f7eb fa79 	bl	340071c6 <HAL_NVIC_EnableIRQ>

  /*** Enable peripheral clock ***/
  /* Enable CSI clock */
  __HAL_RCC_CSI_CLK_ENABLE();
3401bcd4:	2040      	movs	r0, #64	@ 0x40
3401bcd6:	f7ff fdb1 	bl	3401b83c <LL_APB5_GRP1_EnableClock>
  __HAL_RCC_CSI_CLK_SLEEP_ENABLE();
3401bcda:	2040      	movs	r0, #64	@ 0x40
3401bcdc:	f7ff fde8 	bl	3401b8b0 <LL_APB5_GRP1_EnableClockLowPower>
  __HAL_RCC_CSI_FORCE_RESET();
3401bce0:	2040      	movs	r0, #64	@ 0x40
3401bce2:	f7ff fdc1 	bl	3401b868 <LL_APB5_GRP1_ForceReset>
  __HAL_RCC_CSI_RELEASE_RESET();
3401bce6:	2040      	movs	r0, #64	@ 0x40
3401bce8:	f7ff fdce 	bl	3401b888 <LL_APB5_GRP1_ReleaseReset>

  /*** Configure the NVIC for CSI ***/
  /* NVIC configuration for CSI transfer complete interrupt */
  HAL_NVIC_SetPriority(CSI_IRQn, 0x07, 0);
3401bcec:	2200      	movs	r2, #0
3401bcee:	2107      	movs	r1, #7
3401bcf0:	202f      	movs	r0, #47	@ 0x2f
3401bcf2:	f7eb fa4b 	bl	3400718c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(CSI_IRQn);
3401bcf6:	202f      	movs	r0, #47	@ 0x2f
3401bcf8:	f7eb fa65 	bl	340071c6 <HAL_NVIC_EnableIRQ>

}
3401bcfc:	bf00      	nop
3401bcfe:	3708      	adds	r7, #8
3401bd00:	46bd      	mov	sp, r7
3401bd02:	bd80      	pop	{r7, pc}

3401bd04 <CMW_CAMERA_EnableGPIOs>:
/**
  * @brief  CAMERA hardware reset
  * @retval CMW status
  */
static void CMW_CAMERA_EnableGPIOs(void)
{
3401bd04:	b580      	push	{r7, lr}
3401bd06:	b086      	sub	sp, #24
3401bd08:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef gpio_init_structure = {0};
3401bd0a:	1d3b      	adds	r3, r7, #4
3401bd0c:	2200      	movs	r2, #0
3401bd0e:	601a      	str	r2, [r3, #0]
3401bd10:	605a      	str	r2, [r3, #4]
3401bd12:	609a      	str	r2, [r3, #8]
3401bd14:	60da      	str	r2, [r3, #12]
3401bd16:	611a      	str	r2, [r3, #16]

  /* Enable GPIO clocks */
  EN_CAM_GPIO_ENABLE_VDDIO();
  EN_CAM_GPIO_CLK_ENABLE();
3401bd18:	2040      	movs	r0, #64	@ 0x40
3401bd1a:	f7ff fd79 	bl	3401b810 <LL_AHB4_GRP1_EnableClock>
  NRST_CAM_GPIO_ENABLE_VDDIO();
  NRST_CAM_GPIO_CLK_ENABLE();
3401bd1e:	2040      	movs	r0, #64	@ 0x40
3401bd20:	f7ff fd76 	bl	3401b810 <LL_AHB4_GRP1_EnableClock>

  gpio_init_structure.Pin       = EN_CAM_PIN;
3401bd24:	2340      	movs	r3, #64	@ 0x40
3401bd26:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3401bd28:	2300      	movs	r3, #0
3401bd2a:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3401bd2c:	2301      	movs	r3, #1
3401bd2e:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3401bd30:	2303      	movs	r3, #3
3401bd32:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(EN_CAM_PORT, &gpio_init_structure);
3401bd34:	1d3b      	adds	r3, r7, #4
3401bd36:	4619      	mov	r1, r3
3401bd38:	4809      	ldr	r0, [pc, #36]	@ (3401bd60 <CMW_CAMERA_EnableGPIOs+0x5c>)
3401bd3a:	f7ee fe5f 	bl	3400a9fc <HAL_GPIO_Init>

  gpio_init_structure.Pin       = NRST_CAM_PIN;
3401bd3e:	2310      	movs	r3, #16
3401bd40:	607b      	str	r3, [r7, #4]
  gpio_init_structure.Pull      = GPIO_NOPULL;
3401bd42:	2300      	movs	r3, #0
3401bd44:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3401bd46:	2301      	movs	r3, #1
3401bd48:	60bb      	str	r3, [r7, #8]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
3401bd4a:	2303      	movs	r3, #3
3401bd4c:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(NRST_CAM_PORT, &gpio_init_structure);
3401bd4e:	1d3b      	adds	r3, r7, #4
3401bd50:	4619      	mov	r1, r3
3401bd52:	4803      	ldr	r0, [pc, #12]	@ (3401bd60 <CMW_CAMERA_EnableGPIOs+0x5c>)
3401bd54:	f7ee fe52 	bl	3400a9fc <HAL_GPIO_Init>
}
3401bd58:	bf00      	nop
3401bd5a:	3718      	adds	r7, #24
3401bd5c:	46bd      	mov	sp, r7
3401bd5e:	bd80      	pop	{r7, pc}
3401bd60:	56021800 	.word	0x56021800

3401bd64 <CMW_CAMERA_ShutdownPin>:
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, GPIO_PIN_RESET);

}

static void CMW_CAMERA_ShutdownPin(int value)
{
3401bd64:	b580      	push	{r7, lr}
3401bd66:	b082      	sub	sp, #8
3401bd68:	af00      	add	r7, sp, #0
3401bd6a:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(NRST_CAM_PORT, NRST_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3401bd6c:	687b      	ldr	r3, [r7, #4]
3401bd6e:	2b00      	cmp	r3, #0
3401bd70:	bf14      	ite	ne
3401bd72:	2301      	movne	r3, #1
3401bd74:	2300      	moveq	r3, #0
3401bd76:	b2db      	uxtb	r3, r3
3401bd78:	461a      	mov	r2, r3
3401bd7a:	2110      	movs	r1, #16
3401bd7c:	4803      	ldr	r0, [pc, #12]	@ (3401bd8c <CMW_CAMERA_ShutdownPin+0x28>)
3401bd7e:	f7ef f92f 	bl	3400afe0 <HAL_GPIO_WritePin>
}
3401bd82:	bf00      	nop
3401bd84:	3708      	adds	r7, #8
3401bd86:	46bd      	mov	sp, r7
3401bd88:	bd80      	pop	{r7, pc}
3401bd8a:	bf00      	nop
3401bd8c:	56021800 	.word	0x56021800

3401bd90 <CMW_CAMERA_EnablePin>:

static void CMW_CAMERA_EnablePin(int value)
{
3401bd90:	b580      	push	{r7, lr}
3401bd92:	b082      	sub	sp, #8
3401bd94:	af00      	add	r7, sp, #0
3401bd96:	6078      	str	r0, [r7, #4]
  HAL_GPIO_WritePin(EN_CAM_PORT, EN_CAM_PIN, value ? GPIO_PIN_SET : GPIO_PIN_RESET);
3401bd98:	687b      	ldr	r3, [r7, #4]
3401bd9a:	2b00      	cmp	r3, #0
3401bd9c:	bf14      	ite	ne
3401bd9e:	2301      	movne	r3, #1
3401bda0:	2300      	moveq	r3, #0
3401bda2:	b2db      	uxtb	r3, r3
3401bda4:	461a      	mov	r2, r3
3401bda6:	2140      	movs	r1, #64	@ 0x40
3401bda8:	4803      	ldr	r0, [pc, #12]	@ (3401bdb8 <CMW_CAMERA_EnablePin+0x28>)
3401bdaa:	f7ef f919 	bl	3400afe0 <HAL_GPIO_WritePin>
}
3401bdae:	bf00      	nop
3401bdb0:	3708      	adds	r7, #8
3401bdb2:	46bd      	mov	sp, r7
3401bdb4:	bd80      	pop	{r7, pc}
3401bdb6:	bf00      	nop
3401bdb8:	56021800 	.word	0x56021800

3401bdbc <CB_ISP_SetSensorGain>:

#if defined(USE_VD66GY_SENSOR) || defined(USE_IMX335_SENSOR)
static ISP_StatusTypeDef CB_ISP_SetSensorGain(uint32_t camera_instance, int32_t gain)
{
3401bdbc:	b580      	push	{r7, lr}
3401bdbe:	b082      	sub	sp, #8
3401bdc0:	af00      	add	r7, sp, #0
3401bdc2:	6078      	str	r0, [r7, #4]
3401bdc4:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetGain(gain) != CMW_ERROR_NONE)
3401bdc6:	6838      	ldr	r0, [r7, #0]
3401bdc8:	f7ff fe94 	bl	3401baf4 <CMW_CAMERA_SetGain>
3401bdcc:	4603      	mov	r3, r0
3401bdce:	2b00      	cmp	r3, #0
3401bdd0:	d001      	beq.n	3401bdd6 <CB_ISP_SetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3401bdd2:	2379      	movs	r3, #121	@ 0x79
3401bdd4:	e000      	b.n	3401bdd8 <CB_ISP_SetSensorGain+0x1c>

  return ISP_OK;
3401bdd6:	2300      	movs	r3, #0
}
3401bdd8:	4618      	mov	r0, r3
3401bdda:	3708      	adds	r7, #8
3401bddc:	46bd      	mov	sp, r7
3401bdde:	bd80      	pop	{r7, pc}

3401bde0 <CB_ISP_GetSensorGain>:

static ISP_StatusTypeDef CB_ISP_GetSensorGain(uint32_t camera_instance, int32_t *gain)
{
3401bde0:	b580      	push	{r7, lr}
3401bde2:	b082      	sub	sp, #8
3401bde4:	af00      	add	r7, sp, #0
3401bde6:	6078      	str	r0, [r7, #4]
3401bde8:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetGain(gain) != CMW_ERROR_NONE)
3401bdea:	6838      	ldr	r0, [r7, #0]
3401bdec:	f7ff fea8 	bl	3401bb40 <CMW_CAMERA_GetGain>
3401bdf0:	4603      	mov	r3, r0
3401bdf2:	2b00      	cmp	r3, #0
3401bdf4:	d001      	beq.n	3401bdfa <CB_ISP_GetSensorGain+0x1a>
    return ISP_ERR_SENSORGAIN;
3401bdf6:	2379      	movs	r3, #121	@ 0x79
3401bdf8:	e000      	b.n	3401bdfc <CB_ISP_GetSensorGain+0x1c>

  return ISP_OK;
3401bdfa:	2300      	movs	r3, #0
}
3401bdfc:	4618      	mov	r0, r3
3401bdfe:	3708      	adds	r7, #8
3401be00:	46bd      	mov	sp, r7
3401be02:	bd80      	pop	{r7, pc}

3401be04 <CB_ISP_SetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_SetSensorExposure(uint32_t camera_instance, int32_t exposure)
{
3401be04:	b580      	push	{r7, lr}
3401be06:	b082      	sub	sp, #8
3401be08:	af00      	add	r7, sp, #0
3401be0a:	6078      	str	r0, [r7, #4]
3401be0c:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_SetExposure(exposure) != CMW_ERROR_NONE)
3401be0e:	6838      	ldr	r0, [r7, #0]
3401be10:	f7ff fea8 	bl	3401bb64 <CMW_CAMERA_SetExposure>
3401be14:	4603      	mov	r3, r0
3401be16:	2b00      	cmp	r3, #0
3401be18:	d001      	beq.n	3401be1e <CB_ISP_SetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3401be1a:	2383      	movs	r3, #131	@ 0x83
3401be1c:	e000      	b.n	3401be20 <CB_ISP_SetSensorExposure+0x1c>

  return ISP_OK;
3401be1e:	2300      	movs	r3, #0
}
3401be20:	4618      	mov	r0, r3
3401be22:	3708      	adds	r7, #8
3401be24:	46bd      	mov	sp, r7
3401be26:	bd80      	pop	{r7, pc}

3401be28 <CB_ISP_GetSensorExposure>:

static ISP_StatusTypeDef CB_ISP_GetSensorExposure(uint32_t camera_instance, int32_t *exposure)
{
3401be28:	b580      	push	{r7, lr}
3401be2a:	b082      	sub	sp, #8
3401be2c:	af00      	add	r7, sp, #0
3401be2e:	6078      	str	r0, [r7, #4]
3401be30:	6039      	str	r1, [r7, #0]
  if (CMW_CAMERA_GetExposure(exposure) != CMW_ERROR_NONE)
3401be32:	6838      	ldr	r0, [r7, #0]
3401be34:	f7ff febc 	bl	3401bbb0 <CMW_CAMERA_GetExposure>
3401be38:	4603      	mov	r3, r0
3401be3a:	2b00      	cmp	r3, #0
3401be3c:	d001      	beq.n	3401be42 <CB_ISP_GetSensorExposure+0x1a>
    return ISP_ERR_SENSOREXPOSURE;
3401be3e:	2383      	movs	r3, #131	@ 0x83
3401be40:	e000      	b.n	3401be44 <CB_ISP_GetSensorExposure+0x1c>

  return ISP_OK;
3401be42:	2300      	movs	r3, #0
}
3401be44:	4618      	mov	r0, r3
3401be46:	3708      	adds	r7, #8
3401be48:	46bd      	mov	sp, r7
3401be4a:	bd80      	pop	{r7, pc}

3401be4c <CB_ISP_GetSensorInfo>:

static ISP_StatusTypeDef CB_ISP_GetSensorInfo(uint32_t camera_instance, ISP_SensorInfoTypeDef *Info)
{
3401be4c:	b580      	push	{r7, lr}
3401be4e:	b082      	sub	sp, #8
3401be50:	af00      	add	r7, sp, #0
3401be52:	6078      	str	r0, [r7, #4]
3401be54:	6039      	str	r1, [r7, #0]
  if(Camera_Drv.GetSensorInfo != NULL)
3401be56:	4b09      	ldr	r3, [pc, #36]	@ (3401be7c <CB_ISP_GetSensorInfo+0x30>)
3401be58:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401be5a:	2b00      	cmp	r3, #0
3401be5c:	d009      	beq.n	3401be72 <CB_ISP_GetSensorInfo+0x26>
  {
    if (Camera_Drv.GetSensorInfo(&camera_bsp, Info) != CMW_ERROR_NONE)
3401be5e:	4b07      	ldr	r3, [pc, #28]	@ (3401be7c <CB_ISP_GetSensorInfo+0x30>)
3401be60:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401be62:	6839      	ldr	r1, [r7, #0]
3401be64:	4806      	ldr	r0, [pc, #24]	@ (3401be80 <CB_ISP_GetSensorInfo+0x34>)
3401be66:	4798      	blx	r3
3401be68:	4603      	mov	r3, r0
3401be6a:	2b00      	cmp	r3, #0
3401be6c:	d001      	beq.n	3401be72 <CB_ISP_GetSensorInfo+0x26>
      return ISP_ERR_SENSOREXPOSURE;
3401be6e:	2383      	movs	r3, #131	@ 0x83
3401be70:	e000      	b.n	3401be74 <CB_ISP_GetSensorInfo+0x28>
  }
  return ISP_OK;
3401be72:	2300      	movs	r3, #0
}
3401be74:	4618      	mov	r0, r3
3401be76:	3708      	adds	r7, #8
3401be78:	46bd      	mov	sp, r7
3401be7a:	bd80      	pop	{r7, pc}
3401be7c:	3404a31c 	.word	0x3404a31c
3401be80:	3404a37c 	.word	0x3404a37c

3401be84 <CMW_CAMERA_IMX335_Init>:
}
#endif

#if defined(USE_IMX335_SENSOR)
static int32_t CMW_CAMERA_IMX335_Init( CMW_Sensor_Init_t *initSensors_params)
{
3401be84:	b580      	push	{r7, lr}
3401be86:	b09a      	sub	sp, #104	@ 0x68
3401be88:	af00      	add	r7, sp, #0
3401be8a:	6078      	str	r0, [r7, #4]
  int32_t ret = CMW_ERROR_NONE;
3401be8c:	2300      	movs	r3, #0
3401be8e:	667b      	str	r3, [r7, #100]	@ 0x64
  DCMIPP_CSI_ConfTypeDef csi_conf = { 0 };
3401be90:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3401be94:	2200      	movs	r2, #0
3401be96:	601a      	str	r2, [r3, #0]
3401be98:	605a      	str	r2, [r3, #4]
3401be9a:	609a      	str	r2, [r3, #8]
  DCMIPP_CSI_PIPE_ConfTypeDef csi_pipe_conf = { 0 };
3401be9c:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3401bea0:	2200      	movs	r2, #0
3401bea2:	601a      	str	r2, [r3, #0]
3401bea4:	605a      	str	r2, [r3, #4]
3401bea6:	609a      	str	r2, [r3, #8]

  memset(&camera_bsp, 0, sizeof(camera_bsp));
3401bea8:	f44f 7282 	mov.w	r2, #260	@ 0x104
3401beac:	2100      	movs	r1, #0
3401beae:	485d      	ldr	r0, [pc, #372]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401beb0:	f00b f970 	bl	34027194 <memset>
  camera_bsp.imx335_bsp.Address     = CAMERA_IMX335_ADDRESS;
3401beb4:	4b5b      	ldr	r3, [pc, #364]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401beb6:	2234      	movs	r2, #52	@ 0x34
3401beb8:	801a      	strh	r2, [r3, #0]
  camera_bsp.imx335_bsp.Init        = CMW_I2C_INIT;
3401beba:	4b5a      	ldr	r3, [pc, #360]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bebc:	4a5a      	ldr	r2, [pc, #360]	@ (3401c028 <CMW_CAMERA_IMX335_Init+0x1a4>)
3401bebe:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
  camera_bsp.imx335_bsp.DeInit      = CMW_I2C_DEINIT;
3401bec2:	4b58      	ldr	r3, [pc, #352]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bec4:	4a59      	ldr	r2, [pc, #356]	@ (3401c02c <CMW_CAMERA_IMX335_Init+0x1a8>)
3401bec6:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
  camera_bsp.imx335_bsp.ReadReg     = CMW_I2C_READREG16;
3401beca:	4b56      	ldr	r3, [pc, #344]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401becc:	4a58      	ldr	r2, [pc, #352]	@ (3401c030 <CMW_CAMERA_IMX335_Init+0x1ac>)
3401bece:	f8c3 20f0 	str.w	r2, [r3, #240]	@ 0xf0
  camera_bsp.imx335_bsp.WriteReg    = CMW_I2C_WRITEREG16;
3401bed2:	4b54      	ldr	r3, [pc, #336]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bed4:	4a57      	ldr	r2, [pc, #348]	@ (3401c034 <CMW_CAMERA_IMX335_Init+0x1b0>)
3401bed6:	f8c3 20ec 	str.w	r2, [r3, #236]	@ 0xec
  camera_bsp.imx335_bsp.GetTick     = BSP_GetTick;
3401beda:	4b52      	ldr	r3, [pc, #328]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bedc:	4a56      	ldr	r2, [pc, #344]	@ (3401c038 <CMW_CAMERA_IMX335_Init+0x1b4>)
3401bede:	f8c3 20f4 	str.w	r2, [r3, #244]	@ 0xf4
  camera_bsp.imx335_bsp.Delay       = HAL_Delay;
3401bee2:	4b50      	ldr	r3, [pc, #320]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bee4:	4a55      	ldr	r2, [pc, #340]	@ (3401c03c <CMW_CAMERA_IMX335_Init+0x1b8>)
3401bee6:	f8c3 20f8 	str.w	r2, [r3, #248]	@ 0xf8
  camera_bsp.imx335_bsp.ShutdownPin = CMW_CAMERA_ShutdownPin;
3401beea:	4b4e      	ldr	r3, [pc, #312]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401beec:	4a54      	ldr	r2, [pc, #336]	@ (3401c040 <CMW_CAMERA_IMX335_Init+0x1bc>)
3401beee:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
  camera_bsp.imx335_bsp.EnablePin   = CMW_CAMERA_EnablePin;
3401bef2:	4b4c      	ldr	r3, [pc, #304]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bef4:	4a53      	ldr	r2, [pc, #332]	@ (3401c044 <CMW_CAMERA_IMX335_Init+0x1c0>)
3401bef6:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  camera_bsp.imx335_bsp.hdcmipp     = &hcamera_dcmipp;
3401befa:	4b4a      	ldr	r3, [pc, #296]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401befc:	4a52      	ldr	r2, [pc, #328]	@ (3401c048 <CMW_CAMERA_IMX335_Init+0x1c4>)
3401befe:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorGain = CB_ISP_SetSensorGain;
3401bf02:	4b48      	ldr	r3, [pc, #288]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf04:	4a51      	ldr	r2, [pc, #324]	@ (3401c04c <CMW_CAMERA_IMX335_Init+0x1c8>)
3401bf06:	f8c3 20c8 	str.w	r2, [r3, #200]	@ 0xc8
  camera_bsp.imx335_bsp.appliHelpers.GetSensorGain = CB_ISP_GetSensorGain;
3401bf0a:	4b46      	ldr	r3, [pc, #280]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf0c:	4a50      	ldr	r2, [pc, #320]	@ (3401c050 <CMW_CAMERA_IMX335_Init+0x1cc>)
3401bf0e:	f8c3 20cc 	str.w	r2, [r3, #204]	@ 0xcc
  camera_bsp.imx335_bsp.appliHelpers.SetSensorExposure = CB_ISP_SetSensorExposure;
3401bf12:	4b44      	ldr	r3, [pc, #272]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf14:	4a4f      	ldr	r2, [pc, #316]	@ (3401c054 <CMW_CAMERA_IMX335_Init+0x1d0>)
3401bf16:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
  camera_bsp.imx335_bsp.appliHelpers.GetSensorExposure = CB_ISP_GetSensorExposure;
3401bf1a:	4b42      	ldr	r3, [pc, #264]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf1c:	4a4e      	ldr	r2, [pc, #312]	@ (3401c058 <CMW_CAMERA_IMX335_Init+0x1d4>)
3401bf1e:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
  camera_bsp.imx335_bsp.appliHelpers.GetSensorInfo = CB_ISP_GetSensorInfo;
3401bf22:	4b40      	ldr	r3, [pc, #256]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf24:	4a4d      	ldr	r2, [pc, #308]	@ (3401c05c <CMW_CAMERA_IMX335_Init+0x1d8>)
3401bf26:	f8c3 20c4 	str.w	r2, [r3, #196]	@ 0xc4

  ret = CMW_IMX335_Probe(&camera_bsp.imx335_bsp, &Camera_Drv);
3401bf2a:	494d      	ldr	r1, [pc, #308]	@ (3401c060 <CMW_CAMERA_IMX335_Init+0x1dc>)
3401bf2c:	483d      	ldr	r0, [pc, #244]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf2e:	f000 fe6b 	bl	3401cc08 <CMW_IMX335_Probe>
3401bf32:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3401bf34:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401bf36:	2b00      	cmp	r3, #0
3401bf38:	d002      	beq.n	3401bf40 <CMW_CAMERA_IMX335_Init+0xbc>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bf3a:	f06f 0304 	mvn.w	r3, #4
3401bf3e:	e06d      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  }

  /* Special case: when resolution is not specified take the full sensor resolution */
  if ((initSensors_params->width == 0) || (initSensors_params->height == 0))
3401bf40:	687b      	ldr	r3, [r7, #4]
3401bf42:	681b      	ldr	r3, [r3, #0]
3401bf44:	2b00      	cmp	r3, #0
3401bf46:	d003      	beq.n	3401bf50 <CMW_CAMERA_IMX335_Init+0xcc>
3401bf48:	687b      	ldr	r3, [r7, #4]
3401bf4a:	685b      	ldr	r3, [r3, #4]
3401bf4c:	2b00      	cmp	r3, #0
3401bf4e:	d10c      	bne.n	3401bf6a <CMW_CAMERA_IMX335_Init+0xe6>
  {
    ISP_SensorInfoTypeDef sensor_info;
    Camera_Drv.GetSensorInfo(&camera_bsp, &sensor_info);
3401bf50:	4b43      	ldr	r3, [pc, #268]	@ (3401c060 <CMW_CAMERA_IMX335_Init+0x1dc>)
3401bf52:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3401bf54:	f107 020c 	add.w	r2, r7, #12
3401bf58:	4611      	mov	r1, r2
3401bf5a:	4832      	ldr	r0, [pc, #200]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf5c:	4798      	blx	r3
    initSensors_params->width = sensor_info.width;
3401bf5e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3401bf60:	687b      	ldr	r3, [r7, #4]
3401bf62:	601a      	str	r2, [r3, #0]
    initSensors_params->height = sensor_info.height;
3401bf64:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
3401bf66:	687b      	ldr	r3, [r7, #4]
3401bf68:	605a      	str	r2, [r3, #4]
  }

  ret = Camera_Drv.Init(&camera_bsp, initSensors_params);
3401bf6a:	4b3d      	ldr	r3, [pc, #244]	@ (3401c060 <CMW_CAMERA_IMX335_Init+0x1dc>)
3401bf6c:	681b      	ldr	r3, [r3, #0]
3401bf6e:	6879      	ldr	r1, [r7, #4]
3401bf70:	482c      	ldr	r0, [pc, #176]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf72:	4798      	blx	r3
3401bf74:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3401bf76:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401bf78:	2b00      	cmp	r3, #0
3401bf7a:	d002      	beq.n	3401bf82 <CMW_CAMERA_IMX335_Init+0xfe>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bf7c:	f06f 0304 	mvn.w	r3, #4
3401bf80:	e04c      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  }

  ret = Camera_Drv.SetFrequency(&camera_bsp, IMX335_INCK_37MHZ);
3401bf82:	4b37      	ldr	r3, [pc, #220]	@ (3401c060 <CMW_CAMERA_IMX335_Init+0x1dc>)
3401bf84:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401bf86:	2105      	movs	r1, #5
3401bf88:	4826      	ldr	r0, [pc, #152]	@ (3401c024 <CMW_CAMERA_IMX335_Init+0x1a0>)
3401bf8a:	4798      	blx	r3
3401bf8c:	6678      	str	r0, [r7, #100]	@ 0x64
  if (ret != CMW_ERROR_NONE)
3401bf8e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401bf90:	2b00      	cmp	r3, #0
3401bf92:	d002      	beq.n	3401bf9a <CMW_CAMERA_IMX335_Init+0x116>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401bf94:	f06f 0304 	mvn.w	r3, #4
3401bf98:	e040      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  }

  csi_conf.NumberOfLanes = DCMIPP_CSI_TWO_DATA_LANES;
3401bf9a:	f44f 7300 	mov.w	r3, #512	@ 0x200
3401bf9e:	657b      	str	r3, [r7, #84]	@ 0x54
  csi_conf.DataLaneMapping = DCMIPP_CSI_PHYSICAL_DATA_LANES;
3401bfa0:	2301      	movs	r3, #1
3401bfa2:	65bb      	str	r3, [r7, #88]	@ 0x58
  csi_conf.PHYBitrate = DCMIPP_CSI_PHY_BT_1600;
3401bfa4:	232c      	movs	r3, #44	@ 0x2c
3401bfa6:	65fb      	str	r3, [r7, #92]	@ 0x5c
  ret = HAL_DCMIPP_CSI_SetConfig(&hcamera_dcmipp, &csi_conf);
3401bfa8:	f107 0354 	add.w	r3, r7, #84	@ 0x54
3401bfac:	4619      	mov	r1, r3
3401bfae:	4826      	ldr	r0, [pc, #152]	@ (3401c048 <CMW_CAMERA_IMX335_Init+0x1c4>)
3401bfb0:	f7eb f946 	bl	34007240 <HAL_DCMIPP_CSI_SetConfig>
3401bfb4:	4603      	mov	r3, r0
3401bfb6:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3401bfb8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401bfba:	2b00      	cmp	r3, #0
3401bfbc:	d002      	beq.n	3401bfc4 <CMW_CAMERA_IMX335_Init+0x140>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3401bfbe:	f06f 0303 	mvn.w	r3, #3
3401bfc2:	e02b      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  }

  ret = HAL_DCMIPP_CSI_SetVCConfig(&hcamera_dcmipp, DCMIPP_VIRTUAL_CHANNEL0, DCMIPP_CSI_DT_BPP10);
3401bfc4:	2203      	movs	r2, #3
3401bfc6:	2100      	movs	r1, #0
3401bfc8:	481f      	ldr	r0, [pc, #124]	@ (3401c048 <CMW_CAMERA_IMX335_Init+0x1c4>)
3401bfca:	f7eb fb3d 	bl	34007648 <HAL_DCMIPP_CSI_SetVCConfig>
3401bfce:	4603      	mov	r3, r0
3401bfd0:	667b      	str	r3, [r7, #100]	@ 0x64
  if (ret != HAL_OK)
3401bfd2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401bfd4:	2b00      	cmp	r3, #0
3401bfd6:	d002      	beq.n	3401bfde <CMW_CAMERA_IMX335_Init+0x15a>
  {
    return CMW_ERROR_PERIPH_FAILURE;
3401bfd8:	f06f 0303 	mvn.w	r3, #3
3401bfdc:	e01e      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  }

  csi_pipe_conf.DataTypeMode = DCMIPP_DTMODE_DTIDA;
3401bfde:	2300      	movs	r3, #0
3401bfe0:	64bb      	str	r3, [r7, #72]	@ 0x48
  csi_pipe_conf.DataTypeIDA = DCMIPP_DT_RAW10;
3401bfe2:	232b      	movs	r3, #43	@ 0x2b
3401bfe4:	64fb      	str	r3, [r7, #76]	@ 0x4c
  csi_pipe_conf.DataTypeIDB = 0;
3401bfe6:	2300      	movs	r3, #0
3401bfe8:	653b      	str	r3, [r7, #80]	@ 0x50
  /* Pre-initialize CSI config for all the pipes */
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3401bfea:	2300      	movs	r3, #0
3401bfec:	663b      	str	r3, [r7, #96]	@ 0x60
3401bfee:	e011      	b.n	3401c014 <CMW_CAMERA_IMX335_Init+0x190>
  {
    ret = HAL_DCMIPP_CSI_PIPE_SetConfig(&hcamera_dcmipp, i, &csi_pipe_conf);
3401bff0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
3401bff4:	461a      	mov	r2, r3
3401bff6:	6e39      	ldr	r1, [r7, #96]	@ 0x60
3401bff8:	4813      	ldr	r0, [pc, #76]	@ (3401c048 <CMW_CAMERA_IMX335_Init+0x1c4>)
3401bffa:	f7eb fa85 	bl	34007508 <HAL_DCMIPP_CSI_PIPE_SetConfig>
3401bffe:	4603      	mov	r3, r0
3401c000:	667b      	str	r3, [r7, #100]	@ 0x64
    if (ret != HAL_OK)
3401c002:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401c004:	2b00      	cmp	r3, #0
3401c006:	d002      	beq.n	3401c00e <CMW_CAMERA_IMX335_Init+0x18a>
    {
      return CMW_ERROR_PERIPH_FAILURE;
3401c008:	f06f 0303 	mvn.w	r3, #3
3401c00c:	e006      	b.n	3401c01c <CMW_CAMERA_IMX335_Init+0x198>
  for (uint32_t i = DCMIPP_PIPE0; i <= DCMIPP_PIPE2; i++)
3401c00e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3401c010:	3301      	adds	r3, #1
3401c012:	663b      	str	r3, [r7, #96]	@ 0x60
3401c014:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3401c016:	2b02      	cmp	r3, #2
3401c018:	d9ea      	bls.n	3401bff0 <CMW_CAMERA_IMX335_Init+0x16c>
    }
  }


  return ret;
3401c01a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
}
3401c01c:	4618      	mov	r0, r3
3401c01e:	3768      	adds	r7, #104	@ 0x68
3401c020:	46bd      	mov	sp, r7
3401c022:	bd80      	pop	{r7, pc}
3401c024:	3404a37c 	.word	0x3404a37c
3401c028:	34004eb5 	.word	0x34004eb5
3401c02c:	34004edd 	.word	0x34004edd
3401c030:	34004f61 	.word	0x34004f61
3401c034:	34004f15 	.word	0x34004f15
3401c038:	34004fad 	.word	0x34004fad
3401c03c:	34004c3d 	.word	0x34004c3d
3401c040:	3401bd65 	.word	0x3401bd65
3401c044:	3401bd91 	.word	0x3401bd91
3401c048:	3404a310 	.word	0x3404a310
3401c04c:	3401bdbd 	.word	0x3401bdbd
3401c050:	3401bde1 	.word	0x3401bde1
3401c054:	3401be05 	.word	0x3401be05
3401c058:	3401be29 	.word	0x3401be29
3401c05c:	3401be4d 	.word	0x3401be4d
3401c060:	3404a31c 	.word	0x3404a31c

3401c064 <CMW_CAMERA_SetPipe>:
#endif

static int32_t CMW_CAMERA_SetPipe(DCMIPP_HandleTypeDef *hdcmipp, uint32_t pipe, CMW_DCMIPP_Conf_t *p_conf, uint32_t *pitch)
{
3401c064:	b580      	push	{r7, lr}
3401c066:	b098      	sub	sp, #96	@ 0x60
3401c068:	af02      	add	r7, sp, #8
3401c06a:	60f8      	str	r0, [r7, #12]
3401c06c:	60b9      	str	r1, [r7, #8]
3401c06e:	607a      	str	r2, [r7, #4]
3401c070:	603b      	str	r3, [r7, #0]
  DCMIPP_DecimationConfTypeDef dec_conf = { 0 };
3401c072:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3401c076:	2200      	movs	r2, #0
3401c078:	601a      	str	r2, [r3, #0]
3401c07a:	605a      	str	r2, [r3, #4]
  DCMIPP_PipeConfTypeDef pipe_conf = { 0 };
3401c07c:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3401c080:	2200      	movs	r2, #0
3401c082:	601a      	str	r2, [r3, #0]
3401c084:	605a      	str	r2, [r3, #4]
3401c086:	609a      	str	r2, [r3, #8]
  DCMIPP_DownsizeTypeDef down_conf = { 0 };
3401c088:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3401c08c:	2200      	movs	r2, #0
3401c08e:	601a      	str	r2, [r3, #0]
3401c090:	605a      	str	r2, [r3, #4]
3401c092:	609a      	str	r2, [r3, #8]
3401c094:	60da      	str	r2, [r3, #12]
3401c096:	611a      	str	r2, [r3, #16]
3401c098:	615a      	str	r2, [r3, #20]
  DCMIPP_CropConfTypeDef crop_conf = { 0 };
3401c09a:	f107 0314 	add.w	r3, r7, #20
3401c09e:	2200      	movs	r2, #0
3401c0a0:	601a      	str	r2, [r3, #0]
3401c0a2:	605a      	str	r2, [r3, #4]
3401c0a4:	609a      	str	r2, [r3, #8]
3401c0a6:	60da      	str	r2, [r3, #12]
3401c0a8:	611a      	str	r2, [r3, #16]
  int ret;

  /* specific case for pipe0 which is only a dump pipe */
  if (pipe == DCMIPP_PIPE0)
3401c0aa:	68bb      	ldr	r3, [r7, #8]
3401c0ac:	2b00      	cmp	r3, #0
3401c0ae:	d112      	bne.n	3401c0d6 <CMW_CAMERA_SetPipe+0x72>
  {
    /*  TODO: properly configure the dump pipe with decimation and crop */
    pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3401c0b0:	2300      	movs	r3, #0
3401c0b2:	643b      	str	r3, [r7, #64]	@ 0x40
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3401c0b4:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3401c0b8:	461a      	mov	r2, r3
3401c0ba:	68b9      	ldr	r1, [r7, #8]
3401c0bc:	68f8      	ldr	r0, [r7, #12]
3401c0be:	f7eb fb05 	bl	340076cc <HAL_DCMIPP_PIPE_SetConfig>
3401c0c2:	4603      	mov	r3, r0
3401c0c4:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c0c6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c0c8:	2b00      	cmp	r3, #0
3401c0ca:	d002      	beq.n	3401c0d2 <CMW_CAMERA_SetPipe+0x6e>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c0cc:	f06f 0304 	mvn.w	r3, #4
3401c0d0:	e11e      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }

    return HAL_OK;
3401c0d2:	2300      	movs	r3, #0
3401c0d4:	e11c      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
  }

  CMW_UTILS_GetPipeConfig(camera_conf.width, camera_conf.height, p_conf, &crop_conf, &dec_conf, &down_conf);
3401c0d6:	4b90      	ldr	r3, [pc, #576]	@ (3401c318 <CMW_CAMERA_SetPipe+0x2b4>)
3401c0d8:	6818      	ldr	r0, [r3, #0]
3401c0da:	4b8f      	ldr	r3, [pc, #572]	@ (3401c318 <CMW_CAMERA_SetPipe+0x2b4>)
3401c0dc:	6859      	ldr	r1, [r3, #4]
3401c0de:	f107 0214 	add.w	r2, r7, #20
3401c0e2:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3401c0e6:	9301      	str	r3, [sp, #4]
3401c0e8:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3401c0ec:	9300      	str	r3, [sp, #0]
3401c0ee:	4613      	mov	r3, r2
3401c0f0:	687a      	ldr	r2, [r7, #4]
3401c0f2:	f000 f917 	bl	3401c324 <CMW_UTILS_GetPipeConfig>

  if (crop_conf.VSize != 0 || crop_conf.HSize != 0)
3401c0f6:	69fb      	ldr	r3, [r7, #28]
3401c0f8:	2b00      	cmp	r3, #0
3401c0fa:	d102      	bne.n	3401c102 <CMW_CAMERA_SetPipe+0x9e>
3401c0fc:	6a3b      	ldr	r3, [r7, #32]
3401c0fe:	2b00      	cmp	r3, #0
3401c100:	d01a      	beq.n	3401c138 <CMW_CAMERA_SetPipe+0xd4>
  {
    ret = HAL_DCMIPP_PIPE_SetCropConfig(hdcmipp, pipe, &crop_conf);
3401c102:	f107 0314 	add.w	r3, r7, #20
3401c106:	461a      	mov	r2, r3
3401c108:	68b9      	ldr	r1, [r7, #8]
3401c10a:	68f8      	ldr	r0, [r7, #12]
3401c10c:	f7ec fa62 	bl	340085d4 <HAL_DCMIPP_PIPE_SetCropConfig>
3401c110:	4603      	mov	r3, r0
3401c112:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c114:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c116:	2b00      	cmp	r3, #0
3401c118:	d002      	beq.n	3401c120 <CMW_CAMERA_SetPipe+0xbc>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c11a:	f06f 0304 	mvn.w	r3, #4
3401c11e:	e0f7      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableCrop(hdcmipp, pipe);
3401c120:	68b9      	ldr	r1, [r7, #8]
3401c122:	68f8      	ldr	r0, [r7, #12]
3401c124:	f7ec fafe 	bl	34008724 <HAL_DCMIPP_PIPE_EnableCrop>
3401c128:	4603      	mov	r3, r0
3401c12a:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c12c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c12e:	2b00      	cmp	r3, #0
3401c130:	d00e      	beq.n	3401c150 <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c132:	f06f 0304 	mvn.w	r3, #4
3401c136:	e0eb      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableCrop(hdcmipp, pipe);
3401c138:	68b9      	ldr	r1, [r7, #8]
3401c13a:	68f8      	ldr	r0, [r7, #12]
3401c13c:	f7ec fb50 	bl	340087e0 <HAL_DCMIPP_PIPE_DisableCrop>
3401c140:	4603      	mov	r3, r0
3401c142:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c144:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c146:	2b00      	cmp	r3, #0
3401c148:	d002      	beq.n	3401c150 <CMW_CAMERA_SetPipe+0xec>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c14a:	f06f 0304 	mvn.w	r3, #4
3401c14e:	e0df      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  if (dec_conf.VRatio != 0 || dec_conf.HRatio != 0)
3401c150:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3401c152:	2b00      	cmp	r3, #0
3401c154:	d102      	bne.n	3401c15c <CMW_CAMERA_SetPipe+0xf8>
3401c156:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3401c158:	2b00      	cmp	r3, #0
3401c15a:	d01a      	beq.n	3401c192 <CMW_CAMERA_SetPipe+0x12e>
  {
    ret = HAL_DCMIPP_PIPE_SetDecimationConfig(hdcmipp, pipe, &dec_conf);
3401c15c:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
3401c160:	461a      	mov	r2, r3
3401c162:	68b9      	ldr	r1, [r7, #8]
3401c164:	68f8      	ldr	r0, [r7, #12]
3401c166:	f7ec fbc9 	bl	340088fc <HAL_DCMIPP_PIPE_SetDecimationConfig>
3401c16a:	4603      	mov	r3, r0
3401c16c:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c16e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c170:	2b00      	cmp	r3, #0
3401c172:	d002      	beq.n	3401c17a <CMW_CAMERA_SetPipe+0x116>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c174:	f06f 0304 	mvn.w	r3, #4
3401c178:	e0ca      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }

    ret = HAL_DCMIPP_PIPE_EnableDecimation(hdcmipp, pipe);
3401c17a:	68b9      	ldr	r1, [r7, #8]
3401c17c:	68f8      	ldr	r0, [r7, #12]
3401c17e:	f7ec fc00 	bl	34008982 <HAL_DCMIPP_PIPE_EnableDecimation>
3401c182:	4603      	mov	r3, r0
3401c184:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c186:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c188:	2b00      	cmp	r3, #0
3401c18a:	d00e      	beq.n	3401c1aa <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c18c:	f06f 0304 	mvn.w	r3, #4
3401c190:	e0be      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableDecimation(hdcmipp, pipe);
3401c192:	68b9      	ldr	r1, [r7, #8]
3401c194:	68f8      	ldr	r0, [r7, #12]
3401c196:	f7ec fc23 	bl	340089e0 <HAL_DCMIPP_PIPE_DisableDecimation>
3401c19a:	4603      	mov	r3, r0
3401c19c:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c19e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c1a0:	2b00      	cmp	r3, #0
3401c1a2:	d002      	beq.n	3401c1aa <CMW_CAMERA_SetPipe+0x146>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c1a4:	f06f 0304 	mvn.w	r3, #4
3401c1a8:	e0b2      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  ret = HAL_DCMIPP_PIPE_SetDownsizeConfig(hdcmipp, pipe, &down_conf);
3401c1aa:	f107 0328 	add.w	r3, r7, #40	@ 0x28
3401c1ae:	461a      	mov	r2, r3
3401c1b0:	68b9      	ldr	r1, [r7, #8]
3401c1b2:	68f8      	ldr	r0, [r7, #12]
3401c1b4:	f7ec fc43 	bl	34008a3e <HAL_DCMIPP_PIPE_SetDownsizeConfig>
3401c1b8:	4603      	mov	r3, r0
3401c1ba:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3401c1bc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c1be:	2b00      	cmp	r3, #0
3401c1c0:	d002      	beq.n	3401c1c8 <CMW_CAMERA_SetPipe+0x164>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401c1c2:	f06f 0304 	mvn.w	r3, #4
3401c1c6:	e0a3      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
  }

  ret = HAL_DCMIPP_PIPE_EnableDownsize(hdcmipp, pipe);
3401c1c8:	68b9      	ldr	r1, [r7, #8]
3401c1ca:	68f8      	ldr	r0, [r7, #12]
3401c1cc:	f7ec fcb5 	bl	34008b3a <HAL_DCMIPP_PIPE_EnableDownsize>
3401c1d0:	4603      	mov	r3, r0
3401c1d2:	657b      	str	r3, [r7, #84]	@ 0x54
  if (ret != HAL_OK)
3401c1d4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c1d6:	2b00      	cmp	r3, #0
3401c1d8:	d002      	beq.n	3401c1e0 <CMW_CAMERA_SetPipe+0x17c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401c1da:	f06f 0304 	mvn.w	r3, #4
3401c1de:	e097      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
  }

  if (p_conf->enable_swap)
3401c1e0:	687b      	ldr	r3, [r7, #4]
3401c1e2:	691b      	ldr	r3, [r3, #16]
3401c1e4:	2b00      	cmp	r3, #0
3401c1e6:	d00b      	beq.n	3401c200 <CMW_CAMERA_SetPipe+0x19c>
  {
    /* Config pipe */
    ret = HAL_DCMIPP_PIPE_EnableRedBlueSwap(hdcmipp, pipe);
3401c1e8:	68b9      	ldr	r1, [r7, #8]
3401c1ea:	68f8      	ldr	r0, [r7, #12]
3401c1ec:	f7ed fbca 	bl	34009984 <HAL_DCMIPP_PIPE_EnableRedBlueSwap>
3401c1f0:	4603      	mov	r3, r0
3401c1f2:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c1f4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c1f6:	2b00      	cmp	r3, #0
3401c1f8:	d00e      	beq.n	3401c218 <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c1fa:	f06f 0304 	mvn.w	r3, #4
3401c1fe:	e087      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    ret = HAL_DCMIPP_PIPE_DisableRedBlueSwap(hdcmipp, pipe);
3401c200:	68b9      	ldr	r1, [r7, #8]
3401c202:	68f8      	ldr	r0, [r7, #12]
3401c204:	f7ed fbf2 	bl	340099ec <HAL_DCMIPP_PIPE_DisableRedBlueSwap>
3401c208:	4603      	mov	r3, r0
3401c20a:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c20c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c20e:	2b00      	cmp	r3, #0
3401c210:	d002      	beq.n	3401c218 <CMW_CAMERA_SetPipe+0x1b4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c212:	f06f 0304 	mvn.w	r3, #4
3401c216:	e07b      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
  }

  /* Ignore the configuration of gamma if -1
   * Activation is then done by the ISP Library
   */
  if (p_conf->enable_gamma_conversion > -1)
3401c218:	687b      	ldr	r3, [r7, #4]
3401c21a:	695b      	ldr	r3, [r3, #20]
3401c21c:	2b00      	cmp	r3, #0
3401c21e:	db1b      	blt.n	3401c258 <CMW_CAMERA_SetPipe+0x1f4>
  {
    if (p_conf->enable_gamma_conversion)
3401c220:	687b      	ldr	r3, [r7, #4]
3401c222:	695b      	ldr	r3, [r3, #20]
3401c224:	2b00      	cmp	r3, #0
3401c226:	d00b      	beq.n	3401c240 <CMW_CAMERA_SetPipe+0x1dc>
    {
      ret = HAL_DCMIPP_PIPE_EnableGammaConversion(hdcmipp, pipe);
3401c228:	68b9      	ldr	r1, [r7, #8]
3401c22a:	68f8      	ldr	r0, [r7, #12]
3401c22c:	f7ec fcb4 	bl	34008b98 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3401c230:	4603      	mov	r3, r0
3401c232:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3401c234:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c236:	2b00      	cmp	r3, #0
3401c238:	d00e      	beq.n	3401c258 <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3401c23a:	f06f 0304 	mvn.w	r3, #4
3401c23e:	e067      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
    else
    {
      ret = HAL_DCMIPP_PIPE_DisableGammaConversion(hdcmipp, pipe);
3401c240:	68b9      	ldr	r1, [r7, #8]
3401c242:	68f8      	ldr	r0, [r7, #12]
3401c244:	f7ec fcd7 	bl	34008bf6 <HAL_DCMIPP_PIPE_DisableGammaConversion>
3401c248:	4603      	mov	r3, r0
3401c24a:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3401c24c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c24e:	2b00      	cmp	r3, #0
3401c250:	d002      	beq.n	3401c258 <CMW_CAMERA_SetPipe+0x1f4>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3401c252:	f06f 0304 	mvn.w	r3, #4
3401c256:	e05b      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
      }
    }
  }

  if (pipe == DCMIPP_PIPE2)
3401c258:	68bb      	ldr	r3, [r7, #8]
3401c25a:	2b02      	cmp	r3, #2
3401c25c:	d114      	bne.n	3401c288 <CMW_CAMERA_SetPipe+0x224>
  {
    if (!is_pipe1_2_shared)
3401c25e:	4b2f      	ldr	r3, [pc, #188]	@ (3401c31c <CMW_CAMERA_SetPipe+0x2b8>)
3401c260:	681b      	ldr	r3, [r3, #0]
3401c262:	2b00      	cmp	r3, #0
3401c264:	d110      	bne.n	3401c288 <CMW_CAMERA_SetPipe+0x224>
    {
      ret = HAL_DCMIPP_PIPE_CSI_EnableShare(hdcmipp, pipe);
3401c266:	68b9      	ldr	r1, [r7, #8]
3401c268:	68f8      	ldr	r0, [r7, #12]
3401c26a:	f7ed fbf3 	bl	34009a54 <HAL_DCMIPP_PIPE_CSI_EnableShare>
3401c26e:	4603      	mov	r3, r0
3401c270:	657b      	str	r3, [r7, #84]	@ 0x54
      if (ret != HAL_OK)
3401c272:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c274:	2b00      	cmp	r3, #0
3401c276:	d002      	beq.n	3401c27e <CMW_CAMERA_SetPipe+0x21a>
      {
        return CMW_ERROR_COMPONENT_FAILURE;
3401c278:	f06f 0304 	mvn.w	r3, #4
3401c27c:	e048      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
      }
      is_pipe1_2_shared++;
3401c27e:	4b27      	ldr	r3, [pc, #156]	@ (3401c31c <CMW_CAMERA_SetPipe+0x2b8>)
3401c280:	681b      	ldr	r3, [r3, #0]
3401c282:	3301      	adds	r3, #1
3401c284:	4a25      	ldr	r2, [pc, #148]	@ (3401c31c <CMW_CAMERA_SetPipe+0x2b8>)
3401c286:	6013      	str	r3, [r2, #0]
    }
  }

  pipe_conf.FrameRate = DCMIPP_FRAME_RATE_ALL;
3401c288:	2300      	movs	r3, #0
3401c28a:	643b      	str	r3, [r7, #64]	@ 0x40
  pipe_conf.PixelPipePitch = p_conf->output_width * p_conf->output_bpp;
3401c28c:	687b      	ldr	r3, [r7, #4]
3401c28e:	681b      	ldr	r3, [r3, #0]
3401c290:	687a      	ldr	r2, [r7, #4]
3401c292:	68d2      	ldr	r2, [r2, #12]
3401c294:	fb02 f303 	mul.w	r3, r2, r3
3401c298:	647b      	str	r3, [r7, #68]	@ 0x44
  /* Hardware constraint, pitch must be multiple of 16 */
  pipe_conf.PixelPipePitch = (pipe_conf.PixelPipePitch + 15) & (uint32_t) ~15;
3401c29a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401c29c:	330f      	adds	r3, #15
3401c29e:	f023 030f 	bic.w	r3, r3, #15
3401c2a2:	647b      	str	r3, [r7, #68]	@ 0x44
  pipe_conf.PixelPackerFormat = p_conf->output_format;
3401c2a4:	687b      	ldr	r3, [r7, #4]
3401c2a6:	689b      	ldr	r3, [r3, #8]
3401c2a8:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (hcamera_dcmipp.PipeState[pipe] == HAL_DCMIPP_PIPE_STATE_RESET)
3401c2aa:	4a1d      	ldr	r2, [pc, #116]	@ (3401c320 <CMW_CAMERA_SetPipe+0x2bc>)
3401c2ac:	68bb      	ldr	r3, [r7, #8]
3401c2ae:	4413      	add	r3, r2
3401c2b0:	3305      	adds	r3, #5
3401c2b2:	781b      	ldrb	r3, [r3, #0]
3401c2b4:	b2db      	uxtb	r3, r3
3401c2b6:	2b00      	cmp	r3, #0
3401c2b8:	d10e      	bne.n	3401c2d8 <CMW_CAMERA_SetPipe+0x274>
  {
    ret = HAL_DCMIPP_PIPE_SetConfig(hdcmipp, pipe, &pipe_conf);
3401c2ba:	f107 0340 	add.w	r3, r7, #64	@ 0x40
3401c2be:	461a      	mov	r2, r3
3401c2c0:	68b9      	ldr	r1, [r7, #8]
3401c2c2:	68f8      	ldr	r0, [r7, #12]
3401c2c4:	f7eb fa02 	bl	340076cc <HAL_DCMIPP_PIPE_SetConfig>
3401c2c8:	4603      	mov	r3, r0
3401c2ca:	657b      	str	r3, [r7, #84]	@ 0x54
    if (ret != HAL_OK)
3401c2cc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401c2ce:	2b00      	cmp	r3, #0
3401c2d0:	d01a      	beq.n	3401c308 <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c2d2:	f06f 0304 	mvn.w	r3, #4
3401c2d6:	e01b      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_SetPixelPackerFormat(hdcmipp, pipe, pipe_conf.PixelPackerFormat) != HAL_OK)
3401c2d8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3401c2da:	461a      	mov	r2, r3
3401c2dc:	68b9      	ldr	r1, [r7, #8]
3401c2de:	68f8      	ldr	r0, [r7, #12]
3401c2e0:	f7ed fac6 	bl	34009870 <HAL_DCMIPP_PIPE_SetPixelPackerFormat>
3401c2e4:	4603      	mov	r3, r0
3401c2e6:	2b00      	cmp	r3, #0
3401c2e8:	d002      	beq.n	3401c2f0 <CMW_CAMERA_SetPipe+0x28c>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c2ea:	f06f 0304 	mvn.w	r3, #4
3401c2ee:	e00f      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }

    if (HAL_DCMIPP_PIPE_SetPitch(hdcmipp, pipe, pipe_conf.PixelPipePitch) != HAL_OK)
3401c2f0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401c2f2:	461a      	mov	r2, r3
3401c2f4:	68b9      	ldr	r1, [r7, #8]
3401c2f6:	68f8      	ldr	r0, [r7, #12]
3401c2f8:	f7ed fa82 	bl	34009800 <HAL_DCMIPP_PIPE_SetPitch>
3401c2fc:	4603      	mov	r3, r0
3401c2fe:	2b00      	cmp	r3, #0
3401c300:	d002      	beq.n	3401c308 <CMW_CAMERA_SetPipe+0x2a4>
    {
      return CMW_ERROR_COMPONENT_FAILURE;
3401c302:	f06f 0304 	mvn.w	r3, #4
3401c306:	e003      	b.n	3401c310 <CMW_CAMERA_SetPipe+0x2ac>
    }
  }

  /* Update the pitch field so that application can use this information for
   * buffer alignement */
  *pitch = pipe_conf.PixelPipePitch;
3401c308:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401c30a:	683b      	ldr	r3, [r7, #0]
3401c30c:	601a      	str	r2, [r3, #0]

  return HAL_OK;
3401c30e:	2300      	movs	r3, #0
}
3401c310:	4618      	mov	r0, r3
3401c312:	3758      	adds	r7, #88	@ 0x58
3401c314:	46bd      	mov	sp, r7
3401c316:	bd80      	pop	{r7, pc}
3401c318:	3404a2b4 	.word	0x3404a2b4
3401c31c:	3404a488 	.word	0x3404a488
3401c320:	3404a310 	.word	0x3404a310

3401c324 <CMW_UTILS_GetPipeConfig>:
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down);

void CMW_UTILS_GetPipeConfig(uint32_t cam_width, uint32_t cam_height, CMW_DCMIPP_Conf_t *p_conf,
                             DCMIPP_CropConfTypeDef *crop, DCMIPP_DecimationConfTypeDef *dec,
                             DCMIPP_DownsizeTypeDef *down)
{
3401c324:	b580      	push	{r7, lr}
3401c326:	b088      	sub	sp, #32
3401c328:	af02      	add	r7, sp, #8
3401c32a:	60f8      	str	r0, [r7, #12]
3401c32c:	60b9      	str	r1, [r7, #8]
3401c32e:	607a      	str	r2, [r7, #4]
3401c330:	603b      	str	r3, [r7, #0]
  float ratio_height = 0;
3401c332:	f04f 0300 	mov.w	r3, #0
3401c336:	617b      	str	r3, [r7, #20]
  float ratio_width = 0;
3401c338:	f04f 0300 	mov.w	r3, #0
3401c33c:	613b      	str	r3, [r7, #16]

  if (p_conf->mode == CMW_Aspect_ratio_crop)
3401c33e:	687b      	ldr	r3, [r7, #4]
3401c340:	699b      	ldr	r3, [r3, #24]
3401c342:	2b00      	cmp	r3, #0
3401c344:	d12b      	bne.n	3401c39e <CMW_UTILS_GetPipeConfig+0x7a>
  {
    CMW_UTILS_get_crop_config(cam_width, cam_height, p_conf->output_width, p_conf->output_height, crop);
3401c346:	687b      	ldr	r3, [r7, #4]
3401c348:	681a      	ldr	r2, [r3, #0]
3401c34a:	687b      	ldr	r3, [r7, #4]
3401c34c:	6859      	ldr	r1, [r3, #4]
3401c34e:	683b      	ldr	r3, [r7, #0]
3401c350:	9300      	str	r3, [sp, #0]
3401c352:	460b      	mov	r3, r1
3401c354:	68b9      	ldr	r1, [r7, #8]
3401c356:	68f8      	ldr	r0, [r7, #12]
3401c358:	f000 f88e 	bl	3401c478 <CMW_UTILS_get_crop_config>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3401c35c:	683b      	ldr	r3, [r7, #0]
3401c35e:	68db      	ldr	r3, [r3, #12]
3401c360:	ee07 3a90 	vmov	s15, r3
3401c364:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c368:	687b      	ldr	r3, [r7, #4]
3401c36a:	681b      	ldr	r3, [r3, #0]
3401c36c:	ee07 3a90 	vmov	s15, r3
3401c370:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c374:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c378:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3401c37c:	683b      	ldr	r3, [r7, #0]
3401c37e:	689b      	ldr	r3, [r3, #8]
3401c380:	ee07 3a90 	vmov	s15, r3
3401c384:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c388:	687b      	ldr	r3, [r7, #4]
3401c38a:	685b      	ldr	r3, [r3, #4]
3401c38c:	ee07 3a90 	vmov	s15, r3
3401c390:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c394:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c398:	edc7 7a05 	vstr	s15, [r7, #20]
3401c39c:	e05e      	b.n	3401c45c <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fit)
3401c39e:	687b      	ldr	r3, [r7, #4]
3401c3a0:	699b      	ldr	r3, [r3, #24]
3401c3a2:	2b01      	cmp	r3, #1
3401c3a4:	d11e      	bne.n	3401c3e4 <CMW_UTILS_GetPipeConfig+0xc0>
  {
    ratio_width = (float)cam_width / p_conf->output_width;
3401c3a6:	68fb      	ldr	r3, [r7, #12]
3401c3a8:	ee07 3a90 	vmov	s15, r3
3401c3ac:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c3b0:	687b      	ldr	r3, [r7, #4]
3401c3b2:	681b      	ldr	r3, [r3, #0]
3401c3b4:	ee07 3a90 	vmov	s15, r3
3401c3b8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c3bc:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c3c0:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)cam_height / p_conf->output_height;
3401c3c4:	68bb      	ldr	r3, [r7, #8]
3401c3c6:	ee07 3a90 	vmov	s15, r3
3401c3ca:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c3ce:	687b      	ldr	r3, [r7, #4]
3401c3d0:	685b      	ldr	r3, [r3, #4]
3401c3d2:	ee07 3a90 	vmov	s15, r3
3401c3d6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c3da:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c3de:	edc7 7a05 	vstr	s15, [r7, #20]
3401c3e2:	e03b      	b.n	3401c45c <CMW_UTILS_GetPipeConfig+0x138>
  }
  else if (p_conf->mode == CMW_Aspect_ratio_fullscreen)
3401c3e4:	687b      	ldr	r3, [r7, #4]
3401c3e6:	699b      	ldr	r3, [r3, #24]
3401c3e8:	2b02      	cmp	r3, #2
3401c3ea:	d111      	bne.n	3401c410 <CMW_UTILS_GetPipeConfig+0xec>
  {
    ratio_height = (float) cam_height / p_conf->output_height;
3401c3ec:	68bb      	ldr	r3, [r7, #8]
3401c3ee:	ee07 3a90 	vmov	s15, r3
3401c3f2:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c3f6:	687b      	ldr	r3, [r7, #4]
3401c3f8:	685b      	ldr	r3, [r3, #4]
3401c3fa:	ee07 3a90 	vmov	s15, r3
3401c3fe:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c402:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c406:	edc7 7a05 	vstr	s15, [r7, #20]
    ratio_width = (float) ratio_height;
3401c40a:	697b      	ldr	r3, [r7, #20]
3401c40c:	613b      	str	r3, [r7, #16]
3401c40e:	e025      	b.n	3401c45c <CMW_UTILS_GetPipeConfig+0x138>
  }
  else
  {
    CMW_UTILS_get_crop_config_from_manual(&p_conf->manual_conf, crop);
3401c410:	687b      	ldr	r3, [r7, #4]
3401c412:	331c      	adds	r3, #28
3401c414:	6839      	ldr	r1, [r7, #0]
3401c416:	4618      	mov	r0, r3
3401c418:	f000 f8f0 	bl	3401c5fc <CMW_UTILS_get_crop_config_from_manual>
    ratio_width = (float)crop->HSize / p_conf->output_width;
3401c41c:	683b      	ldr	r3, [r7, #0]
3401c41e:	68db      	ldr	r3, [r3, #12]
3401c420:	ee07 3a90 	vmov	s15, r3
3401c424:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c428:	687b      	ldr	r3, [r7, #4]
3401c42a:	681b      	ldr	r3, [r3, #0]
3401c42c:	ee07 3a90 	vmov	s15, r3
3401c430:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c434:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c438:	edc7 7a04 	vstr	s15, [r7, #16]
    ratio_height = (float)crop->VSize / p_conf->output_height;
3401c43c:	683b      	ldr	r3, [r7, #0]
3401c43e:	689b      	ldr	r3, [r3, #8]
3401c440:	ee07 3a90 	vmov	s15, r3
3401c444:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c448:	687b      	ldr	r3, [r7, #4]
3401c44a:	685b      	ldr	r3, [r3, #4]
3401c44c:	ee07 3a90 	vmov	s15, r3
3401c450:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c454:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c458:	edc7 7a05 	vstr	s15, [r7, #20]
  }

  CMW_UTILS_get_scale_configs(p_conf, ratio_width, ratio_height, dec, down);
3401c45c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401c45e:	6a39      	ldr	r1, [r7, #32]
3401c460:	edd7 0a05 	vldr	s1, [r7, #20]
3401c464:	ed97 0a04 	vldr	s0, [r7, #16]
3401c468:	6878      	ldr	r0, [r7, #4]
3401c46a:	f000 f98f 	bl	3401c78c <CMW_UTILS_get_scale_configs>
}
3401c46e:	bf00      	nop
3401c470:	3718      	adds	r7, #24
3401c472:	46bd      	mov	sp, r7
3401c474:	bd80      	pop	{r7, pc}
	...

3401c478 <CMW_UTILS_get_crop_config>:

static void CMW_UTILS_get_crop_config(uint32_t cam_width, uint32_t cam_height, uint32_t pipe_width, uint32_t pipe_height, DCMIPP_CropConfTypeDef *crop)
{
3401c478:	b580      	push	{r7, lr}
3401c47a:	b088      	sub	sp, #32
3401c47c:	af00      	add	r7, sp, #0
3401c47e:	60f8      	str	r0, [r7, #12]
3401c480:	60b9      	str	r1, [r7, #8]
3401c482:	607a      	str	r2, [r7, #4]
3401c484:	603b      	str	r3, [r7, #0]
  const float ratio_width = (float)cam_width / pipe_width ;
3401c486:	68fb      	ldr	r3, [r7, #12]
3401c488:	ee07 3a90 	vmov	s15, r3
3401c48c:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c490:	687b      	ldr	r3, [r7, #4]
3401c492:	ee07 3a90 	vmov	s15, r3
3401c496:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c49a:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c49e:	edc7 7a07 	vstr	s15, [r7, #28]
  const float ratio_height = (float)cam_height / pipe_height;
3401c4a2:	68bb      	ldr	r3, [r7, #8]
3401c4a4:	ee07 3a90 	vmov	s15, r3
3401c4a8:	eef8 6a67 	vcvt.f32.u32	s13, s15
3401c4ac:	683b      	ldr	r3, [r7, #0]
3401c4ae:	ee07 3a90 	vmov	s15, r3
3401c4b2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c4b6:	eec6 7a87 	vdiv.f32	s15, s13, s14
3401c4ba:	edc7 7a06 	vstr	s15, [r7, #24]
  const float ratio = MIN(ratio_width, ratio_height);
3401c4be:	ed97 7a07 	vldr	s14, [r7, #28]
3401c4c2:	edd7 7a06 	vldr	s15, [r7, #24]
3401c4c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401c4ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c4ce:	d501      	bpl.n	3401c4d4 <CMW_UTILS_get_crop_config+0x5c>
3401c4d0:	69fb      	ldr	r3, [r7, #28]
3401c4d2:	e000      	b.n	3401c4d6 <CMW_UTILS_get_crop_config+0x5e>
3401c4d4:	69bb      	ldr	r3, [r7, #24]
3401c4d6:	617b      	str	r3, [r7, #20]

  assert(ratio >= 1);
3401c4d8:	edd7 7a05 	vldr	s15, [r7, #20]
3401c4dc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
3401c4e0:	eef4 7ac7 	vcmpe.f32	s15, s14
3401c4e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c4e8:	da05      	bge.n	3401c4f6 <CMW_UTILS_get_crop_config+0x7e>
3401c4ea:	4b3f      	ldr	r3, [pc, #252]	@ (3401c5e8 <CMW_UTILS_get_crop_config+0x170>)
3401c4ec:	4a3f      	ldr	r2, [pc, #252]	@ (3401c5ec <CMW_UTILS_get_crop_config+0x174>)
3401c4ee:	214f      	movs	r1, #79	@ 0x4f
3401c4f0:	483f      	ldr	r0, [pc, #252]	@ (3401c5f0 <CMW_UTILS_get_crop_config+0x178>)
3401c4f2:	f009 fc39 	bl	34025d68 <__assert_func>
  assert(ratio < 64);
3401c4f6:	edd7 7a05 	vldr	s15, [r7, #20]
3401c4fa:	ed9f 7a3e 	vldr	s14, [pc, #248]	@ 3401c5f4 <CMW_UTILS_get_crop_config+0x17c>
3401c4fe:	eef4 7ac7 	vcmpe.f32	s15, s14
3401c502:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c506:	d405      	bmi.n	3401c514 <CMW_UTILS_get_crop_config+0x9c>
3401c508:	4b3b      	ldr	r3, [pc, #236]	@ (3401c5f8 <CMW_UTILS_get_crop_config+0x180>)
3401c50a:	4a38      	ldr	r2, [pc, #224]	@ (3401c5ec <CMW_UTILS_get_crop_config+0x174>)
3401c50c:	2150      	movs	r1, #80	@ 0x50
3401c50e:	4838      	ldr	r0, [pc, #224]	@ (3401c5f0 <CMW_UTILS_get_crop_config+0x178>)
3401c510:	f009 fc2a 	bl	34025d68 <__assert_func>

  crop->HSize = (uint32_t) MIN(pipe_width * ratio, cam_width);
3401c514:	687b      	ldr	r3, [r7, #4]
3401c516:	ee07 3a90 	vmov	s15, r3
3401c51a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c51e:	edd7 7a05 	vldr	s15, [r7, #20]
3401c522:	ee27 7a27 	vmul.f32	s14, s14, s15
3401c526:	68fb      	ldr	r3, [r7, #12]
3401c528:	ee07 3a90 	vmov	s15, r3
3401c52c:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401c530:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401c534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c538:	d50b      	bpl.n	3401c552 <CMW_UTILS_get_crop_config+0xda>
3401c53a:	687b      	ldr	r3, [r7, #4]
3401c53c:	ee07 3a90 	vmov	s15, r3
3401c540:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c544:	edd7 7a05 	vldr	s15, [r7, #20]
3401c548:	ee67 7a27 	vmul.f32	s15, s14, s15
3401c54c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c550:	e006      	b.n	3401c560 <CMW_UTILS_get_crop_config+0xe8>
3401c552:	68fb      	ldr	r3, [r7, #12]
3401c554:	ee07 3a90 	vmov	s15, r3
3401c558:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401c55c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c560:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c562:	edc3 7a03 	vstr	s15, [r3, #12]
  crop->VSize = (uint32_t) MIN(pipe_height * ratio, cam_height);
3401c566:	683b      	ldr	r3, [r7, #0]
3401c568:	ee07 3a90 	vmov	s15, r3
3401c56c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c570:	edd7 7a05 	vldr	s15, [r7, #20]
3401c574:	ee27 7a27 	vmul.f32	s14, s14, s15
3401c578:	68bb      	ldr	r3, [r7, #8]
3401c57a:	ee07 3a90 	vmov	s15, r3
3401c57e:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401c582:	eeb4 7ae7 	vcmpe.f32	s14, s15
3401c586:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c58a:	d50b      	bpl.n	3401c5a4 <CMW_UTILS_get_crop_config+0x12c>
3401c58c:	683b      	ldr	r3, [r7, #0]
3401c58e:	ee07 3a90 	vmov	s15, r3
3401c592:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401c596:	edd7 7a05 	vldr	s15, [r7, #20]
3401c59a:	ee67 7a27 	vmul.f32	s15, s14, s15
3401c59e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c5a2:	e006      	b.n	3401c5b2 <CMW_UTILS_get_crop_config+0x13a>
3401c5a4:	68bb      	ldr	r3, [r7, #8]
3401c5a6:	ee07 3a90 	vmov	s15, r3
3401c5aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401c5ae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c5b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5b4:	edc3 7a02 	vstr	s15, [r3, #8]
  crop->HStart = (cam_width - crop->HSize + 1) / 2;
3401c5b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5ba:	68db      	ldr	r3, [r3, #12]
3401c5bc:	68fa      	ldr	r2, [r7, #12]
3401c5be:	1ad3      	subs	r3, r2, r3
3401c5c0:	3301      	adds	r3, #1
3401c5c2:	085a      	lsrs	r2, r3, #1
3401c5c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5c6:	605a      	str	r2, [r3, #4]
  crop->VStart = (cam_height - crop->VSize + 1) / 2;
3401c5c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5ca:	689b      	ldr	r3, [r3, #8]
3401c5cc:	68ba      	ldr	r2, [r7, #8]
3401c5ce:	1ad3      	subs	r3, r2, r3
3401c5d0:	3301      	adds	r3, #1
3401c5d2:	085a      	lsrs	r2, r3, #1
3401c5d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5d6:	601a      	str	r2, [r3, #0]
  crop->PipeArea = DCMIPP_POSITIVE_AREA;
3401c5d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401c5da:	2200      	movs	r2, #0
3401c5dc:	611a      	str	r2, [r3, #16]
}
3401c5de:	bf00      	nop
3401c5e0:	3720      	adds	r7, #32
3401c5e2:	46bd      	mov	sp, r7
3401c5e4:	bd80      	pop	{r7, pc}
3401c5e6:	bf00      	nop
3401c5e8:	3402b430 	.word	0x3402b430
3401c5ec:	3402c100 	.word	0x3402c100
3401c5f0:	3402b43c 	.word	0x3402b43c
3401c5f4:	42800000 	.word	0x42800000
3401c5f8:	3402b478 	.word	0x3402b478

3401c5fc <CMW_UTILS_get_crop_config_from_manual>:

static void CMW_UTILS_get_crop_config_from_manual(CMW_Manual_roi_area_t *roi, DCMIPP_CropConfTypeDef *crop)
{
3401c5fc:	b480      	push	{r7}
3401c5fe:	b083      	sub	sp, #12
3401c600:	af00      	add	r7, sp, #0
3401c602:	6078      	str	r0, [r7, #4]
3401c604:	6039      	str	r1, [r7, #0]
  crop->HSize = roi->width;
3401c606:	687b      	ldr	r3, [r7, #4]
3401c608:	681a      	ldr	r2, [r3, #0]
3401c60a:	683b      	ldr	r3, [r7, #0]
3401c60c:	60da      	str	r2, [r3, #12]
  crop->VSize = roi->height;
3401c60e:	687b      	ldr	r3, [r7, #4]
3401c610:	685a      	ldr	r2, [r3, #4]
3401c612:	683b      	ldr	r3, [r7, #0]
3401c614:	609a      	str	r2, [r3, #8]
  crop->HStart = roi->offset_x;
3401c616:	687b      	ldr	r3, [r7, #4]
3401c618:	689a      	ldr	r2, [r3, #8]
3401c61a:	683b      	ldr	r3, [r7, #0]
3401c61c:	605a      	str	r2, [r3, #4]
  crop->VStart = roi->offset_y;
3401c61e:	687b      	ldr	r3, [r7, #4]
3401c620:	68da      	ldr	r2, [r3, #12]
3401c622:	683b      	ldr	r3, [r7, #0]
3401c624:	601a      	str	r2, [r3, #0]
}
3401c626:	bf00      	nop
3401c628:	370c      	adds	r7, #12
3401c62a:	46bd      	mov	sp, r7
3401c62c:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c630:	4770      	bx	lr
	...

3401c634 <CMW_UTILS_get_down_config>:

static void CMW_UTILS_get_down_config(float ratio_width, float ratio_height, int width, int height, DCMIPP_DownsizeTypeDef *down)
{
3401c634:	b480      	push	{r7}
3401c636:	b087      	sub	sp, #28
3401c638:	af00      	add	r7, sp, #0
3401c63a:	ed87 0a05 	vstr	s0, [r7, #20]
3401c63e:	edc7 0a04 	vstr	s1, [r7, #16]
3401c642:	60f8      	str	r0, [r7, #12]
3401c644:	60b9      	str	r1, [r7, #8]
3401c646:	607a      	str	r2, [r7, #4]
  down->HRatio = (uint32_t) (8192 * ratio_width);
3401c648:	edd7 7a05 	vldr	s15, [r7, #20]
3401c64c:	ed9f 7a17 	vldr	s14, [pc, #92]	@ 3401c6ac <CMW_UTILS_get_down_config+0x78>
3401c650:	ee67 7a87 	vmul.f32	s15, s15, s14
3401c654:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c658:	ee17 2a90 	vmov	r2, s15
3401c65c:	687b      	ldr	r3, [r7, #4]
3401c65e:	60da      	str	r2, [r3, #12]
  down->VRatio = (uint32_t) (8192 * ratio_height);
3401c660:	edd7 7a04 	vldr	s15, [r7, #16]
3401c664:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 3401c6ac <CMW_UTILS_get_down_config+0x78>
3401c668:	ee67 7a87 	vmul.f32	s15, s15, s14
3401c66c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401c670:	ee17 2a90 	vmov	r2, s15
3401c674:	687b      	ldr	r3, [r7, #4]
3401c676:	609a      	str	r2, [r3, #8]
  down->HDivFactor = (1024 * 8192 - 1) / down->HRatio;
3401c678:	687b      	ldr	r3, [r7, #4]
3401c67a:	68db      	ldr	r3, [r3, #12]
3401c67c:	4a0c      	ldr	r2, [pc, #48]	@ (3401c6b0 <CMW_UTILS_get_down_config+0x7c>)
3401c67e:	fbb2 f2f3 	udiv	r2, r2, r3
3401c682:	687b      	ldr	r3, [r7, #4]
3401c684:	615a      	str	r2, [r3, #20]
  down->VDivFactor = (1024 * 8192 - 1) / down->VRatio;
3401c686:	687b      	ldr	r3, [r7, #4]
3401c688:	689b      	ldr	r3, [r3, #8]
3401c68a:	4a09      	ldr	r2, [pc, #36]	@ (3401c6b0 <CMW_UTILS_get_down_config+0x7c>)
3401c68c:	fbb2 f2f3 	udiv	r2, r2, r3
3401c690:	687b      	ldr	r3, [r7, #4]
3401c692:	611a      	str	r2, [r3, #16]
  down->HSize = width;
3401c694:	68fa      	ldr	r2, [r7, #12]
3401c696:	687b      	ldr	r3, [r7, #4]
3401c698:	605a      	str	r2, [r3, #4]
  down->VSize = height;
3401c69a:	68ba      	ldr	r2, [r7, #8]
3401c69c:	687b      	ldr	r3, [r7, #4]
3401c69e:	601a      	str	r2, [r3, #0]
}
3401c6a0:	bf00      	nop
3401c6a2:	371c      	adds	r7, #28
3401c6a4:	46bd      	mov	sp, r7
3401c6a6:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c6aa:	4770      	bx	lr
3401c6ac:	46000000 	.word	0x46000000
3401c6b0:	007fffff 	.word	0x007fffff

3401c6b4 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>:

static uint32_t CMW_UTILS_get_dec_ratio_from_decimal_ratio(int dec_ratio, int is_vertical)
{
3401c6b4:	b580      	push	{r7, lr}
3401c6b6:	b082      	sub	sp, #8
3401c6b8:	af00      	add	r7, sp, #0
3401c6ba:	6078      	str	r0, [r7, #4]
3401c6bc:	6039      	str	r1, [r7, #0]
  switch (dec_ratio) {
3401c6be:	687b      	ldr	r3, [r7, #4]
3401c6c0:	3b01      	subs	r3, #1
3401c6c2:	2b07      	cmp	r3, #7
3401c6c4:	d829      	bhi.n	3401c71a <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x66>
3401c6c6:	a201      	add	r2, pc, #4	@ (adr r2, 3401c6cc <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x18>)
3401c6c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401c6cc:	3401c6ed 	.word	0x3401c6ed
3401c6d0:	3401c6f1 	.word	0x3401c6f1
3401c6d4:	3401c71b 	.word	0x3401c71b
3401c6d8:	3401c6ff 	.word	0x3401c6ff
3401c6dc:	3401c71b 	.word	0x3401c71b
3401c6e0:	3401c71b 	.word	0x3401c71b
3401c6e4:	3401c71b 	.word	0x3401c71b
3401c6e8:	3401c70d 	.word	0x3401c70d
  case 1:
    return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
3401c6ec:	2300      	movs	r3, #0
3401c6ee:	e01a      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 2:
    return is_vertical ? DCMIPP_VDEC_1_OUT_2 : DCMIPP_HDEC_1_OUT_2;
3401c6f0:	683b      	ldr	r3, [r7, #0]
3401c6f2:	2b00      	cmp	r3, #0
3401c6f4:	d001      	beq.n	3401c6fa <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x46>
3401c6f6:	2308      	movs	r3, #8
3401c6f8:	e015      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3401c6fa:	2302      	movs	r3, #2
3401c6fc:	e013      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 4:
    return is_vertical ? DCMIPP_VDEC_1_OUT_4 : DCMIPP_HDEC_1_OUT_4;
3401c6fe:	683b      	ldr	r3, [r7, #0]
3401c700:	2b00      	cmp	r3, #0
3401c702:	d001      	beq.n	3401c708 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x54>
3401c704:	2310      	movs	r3, #16
3401c706:	e00e      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3401c708:	2304      	movs	r3, #4
3401c70a:	e00c      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  case 8:
    return is_vertical ? DCMIPP_VDEC_1_OUT_8 : DCMIPP_HDEC_1_OUT_8;
3401c70c:	683b      	ldr	r3, [r7, #0]
3401c70e:	2b00      	cmp	r3, #0
3401c710:	d001      	beq.n	3401c716 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x62>
3401c712:	2318      	movs	r3, #24
3401c714:	e007      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
3401c716:	2306      	movs	r3, #6
3401c718:	e005      	b.n	3401c726 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x72>
  default:
    assert(0);
3401c71a:	4b05      	ldr	r3, [pc, #20]	@ (3401c730 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x7c>)
3401c71c:	4a05      	ldr	r2, [pc, #20]	@ (3401c734 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x80>)
3401c71e:	2177      	movs	r1, #119	@ 0x77
3401c720:	4805      	ldr	r0, [pc, #20]	@ (3401c738 <CMW_UTILS_get_dec_ratio_from_decimal_ratio+0x84>)
3401c722:	f009 fb21 	bl	34025d68 <__assert_func>
  }

  return is_vertical ? DCMIPP_VDEC_ALL : DCMIPP_HDEC_ALL;
}
3401c726:	4618      	mov	r0, r3
3401c728:	3708      	adds	r7, #8
3401c72a:	46bd      	mov	sp, r7
3401c72c:	bd80      	pop	{r7, pc}
3401c72e:	bf00      	nop
3401c730:	3402b484 	.word	0x3402b484
3401c734:	3402c11c 	.word	0x3402c11c
3401c738:	3402b43c 	.word	0x3402b43c

3401c73c <CMW_UTILS_get_dec_ratio_and_update>:

static uint32_t CMW_UTILS_get_dec_ratio_and_update(float *ratio, int is_vertical)
{
3401c73c:	b580      	push	{r7, lr}
3401c73e:	b084      	sub	sp, #16
3401c740:	af00      	add	r7, sp, #0
3401c742:	6078      	str	r0, [r7, #4]
3401c744:	6039      	str	r1, [r7, #0]
  int dec_ratio = 1;
3401c746:	2301      	movs	r3, #1
3401c748:	60fb      	str	r3, [r7, #12]

  while (*ratio >= 8) {
3401c74a:	e00c      	b.n	3401c766 <CMW_UTILS_get_dec_ratio_and_update+0x2a>
    dec_ratio *= 2;
3401c74c:	68fb      	ldr	r3, [r7, #12]
3401c74e:	005b      	lsls	r3, r3, #1
3401c750:	60fb      	str	r3, [r7, #12]
    *ratio /= 2;
3401c752:	687b      	ldr	r3, [r7, #4]
3401c754:	ed93 7a00 	vldr	s14, [r3]
3401c758:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401c75c:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401c760:	687b      	ldr	r3, [r7, #4]
3401c762:	edc3 7a00 	vstr	s15, [r3]
  while (*ratio >= 8) {
3401c766:	687b      	ldr	r3, [r7, #4]
3401c768:	edd3 7a00 	vldr	s15, [r3]
3401c76c:	eeb2 7a00 	vmov.f32	s14, #32	@ 0x41000000  8.0
3401c770:	eef4 7ac7 	vcmpe.f32	s15, s14
3401c774:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401c778:	dae8      	bge.n	3401c74c <CMW_UTILS_get_dec_ratio_and_update+0x10>
  }

  return CMW_UTILS_get_dec_ratio_from_decimal_ratio(dec_ratio, is_vertical);
3401c77a:	6839      	ldr	r1, [r7, #0]
3401c77c:	68f8      	ldr	r0, [r7, #12]
3401c77e:	f7ff ff99 	bl	3401c6b4 <CMW_UTILS_get_dec_ratio_from_decimal_ratio>
3401c782:	4603      	mov	r3, r0
}
3401c784:	4618      	mov	r0, r3
3401c786:	3710      	adds	r7, #16
3401c788:	46bd      	mov	sp, r7
3401c78a:	bd80      	pop	{r7, pc}

3401c78c <CMW_UTILS_get_scale_configs>:

static void CMW_UTILS_get_scale_configs(CMW_DCMIPP_Conf_t *p_conf, float ratio_width, float ratio_height,
                                       DCMIPP_DecimationConfTypeDef *dec, DCMIPP_DownsizeTypeDef *down)
{
3401c78c:	b580      	push	{r7, lr}
3401c78e:	b086      	sub	sp, #24
3401c790:	af00      	add	r7, sp, #0
3401c792:	6178      	str	r0, [r7, #20]
3401c794:	ed87 0a04 	vstr	s0, [r7, #16]
3401c798:	edc7 0a03 	vstr	s1, [r7, #12]
3401c79c:	60b9      	str	r1, [r7, #8]
3401c79e:	607a      	str	r2, [r7, #4]
  dec->HRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_width, 0);
3401c7a0:	f107 0310 	add.w	r3, r7, #16
3401c7a4:	2100      	movs	r1, #0
3401c7a6:	4618      	mov	r0, r3
3401c7a8:	f7ff ffc8 	bl	3401c73c <CMW_UTILS_get_dec_ratio_and_update>
3401c7ac:	4602      	mov	r2, r0
3401c7ae:	68bb      	ldr	r3, [r7, #8]
3401c7b0:	605a      	str	r2, [r3, #4]
  dec->VRatio = CMW_UTILS_get_dec_ratio_and_update(&ratio_height, 1);
3401c7b2:	f107 030c 	add.w	r3, r7, #12
3401c7b6:	2101      	movs	r1, #1
3401c7b8:	4618      	mov	r0, r3
3401c7ba:	f7ff ffbf 	bl	3401c73c <CMW_UTILS_get_dec_ratio_and_update>
3401c7be:	4602      	mov	r2, r0
3401c7c0:	68bb      	ldr	r3, [r7, #8]
3401c7c2:	601a      	str	r2, [r3, #0]
  CMW_UTILS_get_down_config(ratio_width, ratio_height, p_conf->output_width, p_conf->output_height, down);
3401c7c4:	edd7 7a04 	vldr	s15, [r7, #16]
3401c7c8:	ed97 7a03 	vldr	s14, [r7, #12]
3401c7cc:	697b      	ldr	r3, [r7, #20]
3401c7ce:	681b      	ldr	r3, [r3, #0]
3401c7d0:	4618      	mov	r0, r3
3401c7d2:	697b      	ldr	r3, [r7, #20]
3401c7d4:	685b      	ldr	r3, [r3, #4]
3401c7d6:	687a      	ldr	r2, [r7, #4]
3401c7d8:	4619      	mov	r1, r3
3401c7da:	eef0 0a47 	vmov.f32	s1, s14
3401c7de:	eeb0 0a67 	vmov.f32	s0, s15
3401c7e2:	f7ff ff27 	bl	3401c634 <CMW_UTILS_get_down_config>
}
3401c7e6:	bf00      	nop
3401c7e8:	3718      	adds	r7, #24
3401c7ea:	46bd      	mov	sp, r7
3401c7ec:	bd80      	pop	{r7, pc}

3401c7ee <CMW_IMX335_GetResType>:
#include "isp_param_conf.h"
#endif


static int CMW_IMX335_GetResType(uint32_t width, uint32_t height, uint32_t*res)
{
3401c7ee:	b480      	push	{r7}
3401c7f0:	b085      	sub	sp, #20
3401c7f2:	af00      	add	r7, sp, #0
3401c7f4:	60f8      	str	r0, [r7, #12]
3401c7f6:	60b9      	str	r1, [r7, #8]
3401c7f8:	607a      	str	r2, [r7, #4]
  if (width == 2592 && height == 1944)
3401c7fa:	68fb      	ldr	r3, [r7, #12]
3401c7fc:	f5b3 6f22 	cmp.w	r3, #2592	@ 0xa20
3401c800:	d108      	bne.n	3401c814 <CMW_IMX335_GetResType+0x26>
3401c802:	68bb      	ldr	r3, [r7, #8]
3401c804:	f5b3 6ff3 	cmp.w	r3, #1944	@ 0x798
3401c808:	d104      	bne.n	3401c814 <CMW_IMX335_GetResType+0x26>
  {
    *res = IMX335_R2592_1944;
3401c80a:	687b      	ldr	r3, [r7, #4]
3401c80c:	2206      	movs	r2, #6
3401c80e:	601a      	str	r2, [r3, #0]
  }
  else
  {
    return CMW_ERROR_WRONG_PARAM;
  }
  return 0;
3401c810:	2300      	movs	r3, #0
3401c812:	e001      	b.n	3401c818 <CMW_IMX335_GetResType+0x2a>
    return CMW_ERROR_WRONG_PARAM;
3401c814:	f06f 0301 	mvn.w	r3, #1
}
3401c818:	4618      	mov	r0, r3
3401c81a:	3714      	adds	r7, #20
3401c81c:	46bd      	mov	sp, r7
3401c81e:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c822:	4770      	bx	lr

3401c824 <CMW_IMX335_getMirrorFlipConfig>:

static int32_t CMW_IMX335_getMirrorFlipConfig(uint32_t Config)
{
3401c824:	b480      	push	{r7}
3401c826:	b085      	sub	sp, #20
3401c828:	af00      	add	r7, sp, #0
3401c82a:	6078      	str	r0, [r7, #4]
  int32_t ret;

  switch (Config)
3401c82c:	687b      	ldr	r3, [r7, #4]
3401c82e:	2b02      	cmp	r3, #2
3401c830:	d00f      	beq.n	3401c852 <CMW_IMX335_getMirrorFlipConfig+0x2e>
3401c832:	687b      	ldr	r3, [r7, #4]
3401c834:	2b02      	cmp	r3, #2
3401c836:	d80f      	bhi.n	3401c858 <CMW_IMX335_getMirrorFlipConfig+0x34>
3401c838:	687b      	ldr	r3, [r7, #4]
3401c83a:	2b00      	cmp	r3, #0
3401c83c:	d003      	beq.n	3401c846 <CMW_IMX335_getMirrorFlipConfig+0x22>
3401c83e:	687b      	ldr	r3, [r7, #4]
3401c840:	2b01      	cmp	r3, #1
3401c842:	d003      	beq.n	3401c84c <CMW_IMX335_getMirrorFlipConfig+0x28>
3401c844:	e008      	b.n	3401c858 <CMW_IMX335_getMirrorFlipConfig+0x34>
  {
    case CMW_MIRRORFLIP_NONE:
      ret = IMX335_MIRROR_FLIP_NONE;
3401c846:	2300      	movs	r3, #0
3401c848:	60fb      	str	r3, [r7, #12]
      break;
3401c84a:	e008      	b.n	3401c85e <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP:
      ret = IMX335_FLIP;
3401c84c:	2301      	movs	r3, #1
3401c84e:	60fb      	str	r3, [r7, #12]
      break;
3401c850:	e005      	b.n	3401c85e <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_MIRROR:
      ret = IMX335_MIRROR;
3401c852:	2302      	movs	r3, #2
3401c854:	60fb      	str	r3, [r7, #12]
      break;
3401c856:	e002      	b.n	3401c85e <CMW_IMX335_getMirrorFlipConfig+0x3a>
    case CMW_MIRRORFLIP_FLIP_MIRROR:
    default:
      ret = IMX335_MIRROR_FLIP;
3401c858:	2303      	movs	r3, #3
3401c85a:	60fb      	str	r3, [r7, #12]
      break;
3401c85c:	bf00      	nop
  }

  return ret;
3401c85e:	68fb      	ldr	r3, [r7, #12]
}
3401c860:	4618      	mov	r0, r3
3401c862:	3714      	adds	r7, #20
3401c864:	46bd      	mov	sp, r7
3401c866:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c86a:	4770      	bx	lr

3401c86c <CMW_IMX335_DeInit>:

static int32_t CMW_IMX335_DeInit(void *io_ctx)
{
3401c86c:	b580      	push	{r7, lr}
3401c86e:	b084      	sub	sp, #16
3401c870:	af00      	add	r7, sp, #0
3401c872:	6078      	str	r0, [r7, #4]
  int ret = CMW_ERROR_NONE;
3401c874:	2300      	movs	r3, #0
3401c876:	60fb      	str	r3, [r7, #12]
  ret = ISP_DeInit(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401c878:	687b      	ldr	r3, [r7, #4]
3401c87a:	3330      	adds	r3, #48	@ 0x30
3401c87c:	4618      	mov	r0, r3
3401c87e:	f001 ff27 	bl	3401e6d0 <ISP_DeInit>
3401c882:	4603      	mov	r3, r0
3401c884:	60fb      	str	r3, [r7, #12]
  if (ret)
3401c886:	68fb      	ldr	r3, [r7, #12]
3401c888:	2b00      	cmp	r3, #0
3401c88a:	d002      	beq.n	3401c892 <CMW_IMX335_DeInit+0x26>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401c88c:	f06f 0304 	mvn.w	r3, #4
3401c890:	e00c      	b.n	3401c8ac <CMW_IMX335_DeInit+0x40>
  }

  ret = IMX335_DeInit(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3401c892:	687b      	ldr	r3, [r7, #4]
3401c894:	3308      	adds	r3, #8
3401c896:	4618      	mov	r0, r3
3401c898:	f000 fb72 	bl	3401cf80 <IMX335_DeInit>
3401c89c:	60f8      	str	r0, [r7, #12]
  if (ret)
3401c89e:	68fb      	ldr	r3, [r7, #12]
3401c8a0:	2b00      	cmp	r3, #0
3401c8a2:	d002      	beq.n	3401c8aa <CMW_IMX335_DeInit+0x3e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401c8a4:	f06f 0304 	mvn.w	r3, #4
3401c8a8:	e000      	b.n	3401c8ac <CMW_IMX335_DeInit+0x40>
  }
  return ret;
3401c8aa:	68fb      	ldr	r3, [r7, #12]
}
3401c8ac:	4618      	mov	r0, r3
3401c8ae:	3710      	adds	r7, #16
3401c8b0:	46bd      	mov	sp, r7
3401c8b2:	bd80      	pop	{r7, pc}

3401c8b4 <CMW_IMX335_ReadID>:

static int32_t CMW_IMX335_ReadID(void *io_ctx, uint32_t *Id)
{
3401c8b4:	b580      	push	{r7, lr}
3401c8b6:	b082      	sub	sp, #8
3401c8b8:	af00      	add	r7, sp, #0
3401c8ba:	6078      	str	r0, [r7, #4]
3401c8bc:	6039      	str	r1, [r7, #0]
  return IMX335_ReadID(&((CMW_IMX335_t *)io_ctx)->ctx_driver, Id);
3401c8be:	687b      	ldr	r3, [r7, #4]
3401c8c0:	3308      	adds	r3, #8
3401c8c2:	6839      	ldr	r1, [r7, #0]
3401c8c4:	4618      	mov	r0, r3
3401c8c6:	f000 fb6f 	bl	3401cfa8 <IMX335_ReadID>
3401c8ca:	4603      	mov	r3, r0
}
3401c8cc:	4618      	mov	r0, r3
3401c8ce:	3708      	adds	r7, #8
3401c8d0:	46bd      	mov	sp, r7
3401c8d2:	bd80      	pop	{r7, pc}

3401c8d4 <CMW_IMX335_SetGain>:

static int32_t CMW_IMX335_SetGain(void *io_ctx, int32_t gain)
{
3401c8d4:	b580      	push	{r7, lr}
3401c8d6:	b082      	sub	sp, #8
3401c8d8:	af00      	add	r7, sp, #0
3401c8da:	6078      	str	r0, [r7, #4]
3401c8dc:	6039      	str	r1, [r7, #0]
  return IMX335_SetGain(&((CMW_IMX335_t *)io_ctx)->ctx_driver, gain);
3401c8de:	687b      	ldr	r3, [r7, #4]
3401c8e0:	3308      	adds	r3, #8
3401c8e2:	6839      	ldr	r1, [r7, #0]
3401c8e4:	4618      	mov	r0, r3
3401c8e6:	f000 fb83 	bl	3401cff0 <IMX335_SetGain>
3401c8ea:	4603      	mov	r3, r0
}
3401c8ec:	4618      	mov	r0, r3
3401c8ee:	3708      	adds	r7, #8
3401c8f0:	46bd      	mov	sp, r7
3401c8f2:	bd80      	pop	{r7, pc}

3401c8f4 <CMW_IMX335_SetExposure>:

static int32_t CMW_IMX335_SetExposure(void *io_ctx, int32_t exposure)
{
3401c8f4:	b580      	push	{r7, lr}
3401c8f6:	b082      	sub	sp, #8
3401c8f8:	af00      	add	r7, sp, #0
3401c8fa:	6078      	str	r0, [r7, #4]
3401c8fc:	6039      	str	r1, [r7, #0]
  return IMX335_SetExposure(&((CMW_IMX335_t *)io_ctx)->ctx_driver, exposure);
3401c8fe:	687b      	ldr	r3, [r7, #4]
3401c900:	3308      	adds	r3, #8
3401c902:	6839      	ldr	r1, [r7, #0]
3401c904:	4618      	mov	r0, r3
3401c906:	f000 fbcb 	bl	3401d0a0 <IMX335_SetExposure>
3401c90a:	4603      	mov	r3, r0
}
3401c90c:	4618      	mov	r0, r3
3401c90e:	3708      	adds	r7, #8
3401c910:	46bd      	mov	sp, r7
3401c912:	bd80      	pop	{r7, pc}

3401c914 <CMW_IMX335_SetFrequency>:

static int32_t CMW_IMX335_SetFrequency(void *io_ctx, int32_t frequency)
{
3401c914:	b580      	push	{r7, lr}
3401c916:	b082      	sub	sp, #8
3401c918:	af00      	add	r7, sp, #0
3401c91a:	6078      	str	r0, [r7, #4]
3401c91c:	6039      	str	r1, [r7, #0]
  return IMX335_SetFrequency(&((CMW_IMX335_t *)io_ctx)->ctx_driver, frequency);
3401c91e:	687b      	ldr	r3, [r7, #4]
3401c920:	3308      	adds	r3, #8
3401c922:	6839      	ldr	r1, [r7, #0]
3401c924:	4618      	mov	r0, r3
3401c926:	f000 fc2d 	bl	3401d184 <IMX335_SetFrequency>
3401c92a:	4603      	mov	r3, r0
}
3401c92c:	4618      	mov	r0, r3
3401c92e:	3708      	adds	r7, #8
3401c930:	46bd      	mov	sp, r7
3401c932:	bd80      	pop	{r7, pc}

3401c934 <CMW_IMX335_SetFramerate>:

static int32_t CMW_IMX335_SetFramerate(void *io_ctx, int32_t framerate)
{
3401c934:	b580      	push	{r7, lr}
3401c936:	b082      	sub	sp, #8
3401c938:	af00      	add	r7, sp, #0
3401c93a:	6078      	str	r0, [r7, #4]
3401c93c:	6039      	str	r1, [r7, #0]
  return IMX335_SetFramerate(&((CMW_IMX335_t *)io_ctx)->ctx_driver, framerate);
3401c93e:	687b      	ldr	r3, [r7, #4]
3401c940:	3308      	adds	r3, #8
3401c942:	6839      	ldr	r1, [r7, #0]
3401c944:	4618      	mov	r0, r3
3401c946:	f000 fc99 	bl	3401d27c <IMX335_SetFramerate>
3401c94a:	4603      	mov	r3, r0
}
3401c94c:	4618      	mov	r0, r3
3401c94e:	3708      	adds	r7, #8
3401c950:	46bd      	mov	sp, r7
3401c952:	bd80      	pop	{r7, pc}

3401c954 <CMW_IMX335_SetMirrorFlip>:

static int32_t CMW_IMX335_SetMirrorFlip(void *io_ctx, uint32_t config)
{
3401c954:	b580      	push	{r7, lr}
3401c956:	b084      	sub	sp, #16
3401c958:	af00      	add	r7, sp, #0
3401c95a:	6078      	str	r0, [r7, #4]
3401c95c:	6039      	str	r1, [r7, #0]
  int32_t mirrorFlip = CMW_IMX335_getMirrorFlipConfig(config);
3401c95e:	6838      	ldr	r0, [r7, #0]
3401c960:	f7ff ff60 	bl	3401c824 <CMW_IMX335_getMirrorFlipConfig>
3401c964:	60f8      	str	r0, [r7, #12]
  return IMX335_MirrorFlipConfig(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mirrorFlip);
3401c966:	687b      	ldr	r3, [r7, #4]
3401c968:	3308      	adds	r3, #8
3401c96a:	68fa      	ldr	r2, [r7, #12]
3401c96c:	4611      	mov	r1, r2
3401c96e:	4618      	mov	r0, r3
3401c970:	f000 fd06 	bl	3401d380 <IMX335_MirrorFlipConfig>
3401c974:	4603      	mov	r3, r0
}
3401c976:	4618      	mov	r0, r3
3401c978:	3710      	adds	r7, #16
3401c97a:	46bd      	mov	sp, r7
3401c97c:	bd80      	pop	{r7, pc}
	...

3401c980 <CMW_IMX335_GetSensorInfo>:

static int32_t CMW_IMX335_GetSensorInfo(void *io_ctx, ISP_SensorInfoTypeDef *info)
{
3401c980:	b480      	push	{r7}
3401c982:	b083      	sub	sp, #12
3401c984:	af00      	add	r7, sp, #0
3401c986:	6078      	str	r0, [r7, #4]
3401c988:	6039      	str	r1, [r7, #0]
  if ((io_ctx ==  NULL) || (info == NULL))
3401c98a:	687b      	ldr	r3, [r7, #4]
3401c98c:	2b00      	cmp	r3, #0
3401c98e:	d002      	beq.n	3401c996 <CMW_IMX335_GetSensorInfo+0x16>
3401c990:	683b      	ldr	r3, [r7, #0]
3401c992:	2b00      	cmp	r3, #0
3401c994:	d102      	bne.n	3401c99c <CMW_IMX335_GetSensorInfo+0x1c>
  {
    return CMW_ERROR_WRONG_PARAM;
3401c996:	f06f 0301 	mvn.w	r3, #1
3401c99a:	e025      	b.n	3401c9e8 <CMW_IMX335_GetSensorInfo+0x68>
  }

  if (sizeof(info->name) >= strlen(IMX335_NAME) + 1)
  {
    strcpy(info->name, IMX335_NAME);
3401c99c:	683b      	ldr	r3, [r7, #0]
3401c99e:	4a15      	ldr	r2, [pc, #84]	@ (3401c9f4 <CMW_IMX335_GetSensorInfo+0x74>)
3401c9a0:	6810      	ldr	r0, [r2, #0]
3401c9a2:	6018      	str	r0, [r3, #0]
3401c9a4:	8891      	ldrh	r1, [r2, #4]
3401c9a6:	7992      	ldrb	r2, [r2, #6]
3401c9a8:	8099      	strh	r1, [r3, #4]
3401c9aa:	719a      	strb	r2, [r3, #6]
  else
  {
    return CMW_ERROR_COMPONENT_FAILURE;
  }

  info->bayer_pattern = IMX335_BAYER_PATTERN;
3401c9ac:	683b      	ldr	r3, [r7, #0]
3401c9ae:	2200      	movs	r2, #0
3401c9b0:	f883 2020 	strb.w	r2, [r3, #32]
  info->color_depth = IMX335_COLOR_DEPTH;
3401c9b4:	683b      	ldr	r3, [r7, #0]
3401c9b6:	220a      	movs	r2, #10
3401c9b8:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21
  info->width = IMX335_WIDTH;
3401c9bc:	683b      	ldr	r3, [r7, #0]
3401c9be:	f44f 6222 	mov.w	r2, #2592	@ 0xa20
3401c9c2:	625a      	str	r2, [r3, #36]	@ 0x24
  info->height = IMX335_HEIGHT;
3401c9c4:	683b      	ldr	r3, [r7, #0]
3401c9c6:	f44f 62f3 	mov.w	r2, #1944	@ 0x798
3401c9ca:	629a      	str	r2, [r3, #40]	@ 0x28
  info->gain_min = IMX335_GAIN_MIN;
3401c9cc:	683b      	ldr	r3, [r7, #0]
3401c9ce:	2200      	movs	r2, #0
3401c9d0:	62da      	str	r2, [r3, #44]	@ 0x2c
  info->gain_max = IMX335_GAIN_MAX;
3401c9d2:	683b      	ldr	r3, [r7, #0]
3401c9d4:	4a08      	ldr	r2, [pc, #32]	@ (3401c9f8 <CMW_IMX335_GetSensorInfo+0x78>)
3401c9d6:	631a      	str	r2, [r3, #48]	@ 0x30
  info->exposure_min = IMX335_EXPOSURE_MIN;
3401c9d8:	683b      	ldr	r3, [r7, #0]
3401c9da:	2200      	movs	r2, #0
3401c9dc:	635a      	str	r2, [r3, #52]	@ 0x34
  info->exposure_max = IMX335_EXPOSURE_MAX;
3401c9de:	683b      	ldr	r3, [r7, #0]
3401c9e0:	f248 12f2 	movw	r2, #33266	@ 0x81f2
3401c9e4:	639a      	str	r2, [r3, #56]	@ 0x38

  return CMW_ERROR_NONE;
3401c9e6:	2300      	movs	r3, #0
}
3401c9e8:	4618      	mov	r0, r3
3401c9ea:	370c      	adds	r7, #12
3401c9ec:	46bd      	mov	sp, r7
3401c9ee:	f85d 7b04 	ldr.w	r7, [sp], #4
3401c9f2:	4770      	bx	lr
3401c9f4:	3402b488 	.word	0x3402b488
3401c9f8:	00011940 	.word	0x00011940

3401c9fc <CMW_IMX335_SetTestPattern>:

static int32_t CMW_IMX335_SetTestPattern(void *io_ctx, int32_t mode)
{
3401c9fc:	b580      	push	{r7, lr}
3401c9fe:	b082      	sub	sp, #8
3401ca00:	af00      	add	r7, sp, #0
3401ca02:	6078      	str	r0, [r7, #4]
3401ca04:	6039      	str	r1, [r7, #0]
  return IMX335_SetTestPattern(&((CMW_IMX335_t *)io_ctx)->ctx_driver, mode);
3401ca06:	687b      	ldr	r3, [r7, #4]
3401ca08:	3308      	adds	r3, #8
3401ca0a:	6839      	ldr	r1, [r7, #0]
3401ca0c:	4618      	mov	r0, r3
3401ca0e:	f000 fcf5 	bl	3401d3fc <IMX335_SetTestPattern>
3401ca12:	4603      	mov	r3, r0
}
3401ca14:	4618      	mov	r0, r3
3401ca16:	3708      	adds	r7, #8
3401ca18:	46bd      	mov	sp, r7
3401ca1a:	bd80      	pop	{r7, pc}

3401ca1c <CMW_IMX335_Init>:

static int32_t CMW_IMX335_Init(void *io_ctx, CMW_Sensor_Init_t *initSensor)
{
3401ca1c:	b580      	push	{r7, lr}
3401ca1e:	b084      	sub	sp, #16
3401ca20:	af00      	add	r7, sp, #0
3401ca22:	6078      	str	r0, [r7, #4]
3401ca24:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3401ca26:	2300      	movs	r3, #0
3401ca28:	60fb      	str	r3, [r7, #12]
  uint32_t resolution;

  ret = CMW_IMX335_GetResType(initSensor->width, initSensor->height, &resolution);
3401ca2a:	683b      	ldr	r3, [r7, #0]
3401ca2c:	6818      	ldr	r0, [r3, #0]
3401ca2e:	683b      	ldr	r3, [r7, #0]
3401ca30:	685b      	ldr	r3, [r3, #4]
3401ca32:	f107 0208 	add.w	r2, r7, #8
3401ca36:	4619      	mov	r1, r3
3401ca38:	f7ff fed9 	bl	3401c7ee <CMW_IMX335_GetResType>
3401ca3c:	60f8      	str	r0, [r7, #12]
  if (ret)
3401ca3e:	68fb      	ldr	r3, [r7, #12]
3401ca40:	2b00      	cmp	r3, #0
3401ca42:	d002      	beq.n	3401ca4a <CMW_IMX335_Init+0x2e>
  {
    return CMW_ERROR_WRONG_PARAM;
3401ca44:	f06f 0301 	mvn.w	r3, #1
3401ca48:	e01d      	b.n	3401ca86 <CMW_IMX335_Init+0x6a>
  }

  ret = CMW_IMX335_SetMirrorFlip(io_ctx, initSensor->mirrorFlip);
3401ca4a:	683b      	ldr	r3, [r7, #0]
3401ca4c:	691b      	ldr	r3, [r3, #16]
3401ca4e:	4619      	mov	r1, r3
3401ca50:	6878      	ldr	r0, [r7, #4]
3401ca52:	f7ff ff7f 	bl	3401c954 <CMW_IMX335_SetMirrorFlip>
3401ca56:	60f8      	str	r0, [r7, #12]
  if (ret)
3401ca58:	68fb      	ldr	r3, [r7, #12]
3401ca5a:	2b00      	cmp	r3, #0
3401ca5c:	d002      	beq.n	3401ca64 <CMW_IMX335_Init+0x48>
  {
    return CMW_ERROR_WRONG_PARAM;
3401ca5e:	f06f 0301 	mvn.w	r3, #1
3401ca62:	e010      	b.n	3401ca86 <CMW_IMX335_Init+0x6a>
  }

  ret = IMX335_Init(&((CMW_IMX335_t *)io_ctx)->ctx_driver, resolution, initSensor->pixel_format);
3401ca64:	687b      	ldr	r3, [r7, #4]
3401ca66:	f103 0008 	add.w	r0, r3, #8
3401ca6a:	68b9      	ldr	r1, [r7, #8]
3401ca6c:	683b      	ldr	r3, [r7, #0]
3401ca6e:	68db      	ldr	r3, [r3, #12]
3401ca70:	461a      	mov	r2, r3
3401ca72:	f000 fa25 	bl	3401cec0 <IMX335_Init>
3401ca76:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3401ca78:	68fb      	ldr	r3, [r7, #12]
3401ca7a:	2b00      	cmp	r3, #0
3401ca7c:	d002      	beq.n	3401ca84 <CMW_IMX335_Init+0x68>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401ca7e:	f06f 0304 	mvn.w	r3, #4
3401ca82:	e000      	b.n	3401ca86 <CMW_IMX335_Init+0x6a>
  }

  return CMW_ERROR_NONE;
3401ca84:	2300      	movs	r3, #0
}
3401ca86:	4618      	mov	r0, r3
3401ca88:	3710      	adds	r7, #16
3401ca8a:	46bd      	mov	sp, r7
3401ca8c:	bd80      	pop	{r7, pc}
	...

3401ca90 <CMW_IMX335_Start>:

static int32_t CMW_IMX335_Start(void *io_ctx)
{
3401ca90:	b580      	push	{r7, lr}
3401ca92:	b08a      	sub	sp, #40	@ 0x28
3401ca94:	af02      	add	r7, sp, #8
3401ca96:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  /* Statistic area is provided with null value so that it force the ISP Library to get the statistic
   * area information from the tuning file.
   */
  ISP_StatAreaTypeDef isp_stat_area = {0};
3401ca98:	f107 030c 	add.w	r3, r7, #12
3401ca9c:	2200      	movs	r2, #0
3401ca9e:	601a      	str	r2, [r3, #0]
3401caa0:	605a      	str	r2, [r3, #4]
3401caa2:	609a      	str	r2, [r3, #8]
3401caa4:	60da      	str	r2, [r3, #12]
  (void) ISP_IQParamCacheInit; /* unused */
  ret = ISP_Init(&((CMW_IMX335_t *)io_ctx)->hIsp, ((CMW_IMX335_t *)io_ctx)->hdcmipp, 0, &((CMW_IMX335_t *)io_ctx)->appliHelpers, &isp_stat_area, &ISP_IQParamCacheInit_IMX335);
3401caa6:	687b      	ldr	r3, [r7, #4]
3401caa8:	f103 0030 	add.w	r0, r3, #48	@ 0x30
3401caac:	687b      	ldr	r3, [r7, #4]
3401caae:	f8d3 10dc 	ldr.w	r1, [r3, #220]	@ 0xdc
3401cab2:	687b      	ldr	r3, [r7, #4]
3401cab4:	f103 02b8 	add.w	r2, r3, #184	@ 0xb8
3401cab8:	4b13      	ldr	r3, [pc, #76]	@ (3401cb08 <CMW_IMX335_Start+0x78>)
3401caba:	9301      	str	r3, [sp, #4]
3401cabc:	f107 030c 	add.w	r3, r7, #12
3401cac0:	9300      	str	r3, [sp, #0]
3401cac2:	4613      	mov	r3, r2
3401cac4:	2200      	movs	r2, #0
3401cac6:	f001 fd31 	bl	3401e52c <ISP_Init>
3401caca:	4603      	mov	r3, r0
3401cacc:	61fb      	str	r3, [r7, #28]
  if (ret != ISP_OK)
3401cace:	69fb      	ldr	r3, [r7, #28]
3401cad0:	2b00      	cmp	r3, #0
3401cad2:	d002      	beq.n	3401cada <CMW_IMX335_Start+0x4a>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401cad4:	f06f 0304 	mvn.w	r3, #4
3401cad8:	e012      	b.n	3401cb00 <CMW_IMX335_Start+0x70>
  }

  ret = ISP_Start(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cada:	687b      	ldr	r3, [r7, #4]
3401cadc:	3330      	adds	r3, #48	@ 0x30
3401cade:	4618      	mov	r0, r3
3401cae0:	f001 fe16 	bl	3401e710 <ISP_Start>
3401cae4:	4603      	mov	r3, r0
3401cae6:	61fb      	str	r3, [r7, #28]
  if (ret != ISP_OK)
3401cae8:	69fb      	ldr	r3, [r7, #28]
3401caea:	2b00      	cmp	r3, #0
3401caec:	d002      	beq.n	3401caf4 <CMW_IMX335_Start+0x64>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3401caee:	f06f 0303 	mvn.w	r3, #3
3401caf2:	e005      	b.n	3401cb00 <CMW_IMX335_Start+0x70>
  }
#endif
  return IMX335_Start(&((CMW_IMX335_t *)io_ctx)->ctx_driver);
3401caf4:	687b      	ldr	r3, [r7, #4]
3401caf6:	3308      	adds	r3, #8
3401caf8:	4618      	mov	r0, r3
3401cafa:	f000 fa1f 	bl	3401cf3c <IMX335_Start>
3401cafe:	4603      	mov	r3, r0
}
3401cb00:	4618      	mov	r0, r3
3401cb02:	3720      	adds	r7, #32
3401cb04:	46bd      	mov	sp, r7
3401cb06:	bd80      	pop	{r7, pc}
3401cb08:	3402c148 	.word	0x3402c148

3401cb0c <CMW_IMX335_Run>:

static int32_t CMW_IMX335_Run(void *io_ctx)
{
3401cb0c:	b580      	push	{r7, lr}
3401cb0e:	b084      	sub	sp, #16
3401cb10:	af00      	add	r7, sp, #0
3401cb12:	6078      	str	r0, [r7, #4]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  int ret;
  ret = ISP_BackgroundProcess(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cb14:	687b      	ldr	r3, [r7, #4]
3401cb16:	3330      	adds	r3, #48	@ 0x30
3401cb18:	4618      	mov	r0, r3
3401cb1a:	f001 ff09 	bl	3401e930 <ISP_BackgroundProcess>
3401cb1e:	4603      	mov	r3, r0
3401cb20:	60fb      	str	r3, [r7, #12]
  if (ret != ISP_OK)
3401cb22:	68fb      	ldr	r3, [r7, #12]
3401cb24:	2b00      	cmp	r3, #0
3401cb26:	d002      	beq.n	3401cb2e <CMW_IMX335_Run+0x22>
  {
      return CMW_ERROR_PERIPH_FAILURE;
3401cb28:	f06f 0303 	mvn.w	r3, #3
3401cb2c:	e000      	b.n	3401cb30 <CMW_IMX335_Run+0x24>
  }
#endif
  return CMW_ERROR_NONE;
3401cb2e:	2300      	movs	r3, #0
}
3401cb30:	4618      	mov	r0, r3
3401cb32:	3710      	adds	r7, #16
3401cb34:	46bd      	mov	sp, r7
3401cb36:	bd80      	pop	{r7, pc}

3401cb38 <CMW_IMX335_PowerOn>:

static void CMW_IMX335_PowerOn(CMW_IMX335_t *io_ctx)
{
3401cb38:	b580      	push	{r7, lr}
3401cb3a:	b082      	sub	sp, #8
3401cb3c:	af00      	add	r7, sp, #0
3401cb3e:	6078      	str	r0, [r7, #4]
  io_ctx->ShutdownPin(0);  /* Disable MB1723 2V8 signal  */
3401cb40:	687b      	ldr	r3, [r7, #4]
3401cb42:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401cb46:	2000      	movs	r0, #0
3401cb48:	4798      	blx	r3
  io_ctx->Delay(100);
3401cb4a:	687b      	ldr	r3, [r7, #4]
3401cb4c:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401cb50:	2064      	movs	r0, #100	@ 0x64
3401cb52:	4798      	blx	r3
  io_ctx->EnablePin(0);  /* RESET low (reset active low) */
3401cb54:	687b      	ldr	r3, [r7, #4]
3401cb56:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401cb5a:	2000      	movs	r0, #0
3401cb5c:	4798      	blx	r3
  io_ctx->Delay(100);
3401cb5e:	687b      	ldr	r3, [r7, #4]
3401cb60:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401cb64:	2064      	movs	r0, #100	@ 0x64
3401cb66:	4798      	blx	r3
  io_ctx->ShutdownPin(1);  /* Disable MB1723 2V8 signal  */
3401cb68:	687b      	ldr	r3, [r7, #4]
3401cb6a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3401cb6e:	2001      	movs	r0, #1
3401cb70:	4798      	blx	r3
  io_ctx->Delay(100);
3401cb72:	687b      	ldr	r3, [r7, #4]
3401cb74:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401cb78:	2064      	movs	r0, #100	@ 0x64
3401cb7a:	4798      	blx	r3
  io_ctx->EnablePin(1);  /* RESET low (reset active low) */
3401cb7c:	687b      	ldr	r3, [r7, #4]
3401cb7e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3401cb82:	2001      	movs	r0, #1
3401cb84:	4798      	blx	r3
  io_ctx->Delay(100);
3401cb86:	687b      	ldr	r3, [r7, #4]
3401cb88:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3401cb8c:	2064      	movs	r0, #100	@ 0x64
3401cb8e:	4798      	blx	r3
}
3401cb90:	bf00      	nop
3401cb92:	3708      	adds	r7, #8
3401cb94:	46bd      	mov	sp, r7
3401cb96:	bd80      	pop	{r7, pc}

3401cb98 <CMW_IMX335_VsyncEventCallback>:

static void CMW_IMX335_VsyncEventCallback(void *io_ctx, uint32_t pipe)
{
3401cb98:	b580      	push	{r7, lr}
3401cb9a:	b082      	sub	sp, #8
3401cb9c:	af00      	add	r7, sp, #0
3401cb9e:	6078      	str	r0, [r7, #4]
3401cba0:	6039      	str	r1, [r7, #0]
#ifndef ISP_MW_TUNING_TOOL_SUPPORT
  /* Update the ISP frame counter and call its statistics handler */
  switch (pipe)
3401cba2:	683b      	ldr	r3, [r7, #0]
3401cba4:	2b02      	cmp	r3, #2
3401cba6:	d01a      	beq.n	3401cbde <CMW_IMX335_VsyncEventCallback+0x46>
3401cba8:	683b      	ldr	r3, [r7, #0]
3401cbaa:	2b02      	cmp	r3, #2
3401cbac:	d81d      	bhi.n	3401cbea <CMW_IMX335_VsyncEventCallback+0x52>
3401cbae:	683b      	ldr	r3, [r7, #0]
3401cbb0:	2b00      	cmp	r3, #0
3401cbb2:	d003      	beq.n	3401cbbc <CMW_IMX335_VsyncEventCallback+0x24>
3401cbb4:	683b      	ldr	r3, [r7, #0]
3401cbb6:	2b01      	cmp	r3, #1
3401cbb8:	d006      	beq.n	3401cbc8 <CMW_IMX335_VsyncEventCallback+0x30>
    case DCMIPP_PIPE2 :
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
      break;
  }
#endif
}
3401cbba:	e016      	b.n	3401cbea <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncDumpFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cbbc:	687b      	ldr	r3, [r7, #4]
3401cbbe:	3330      	adds	r3, #48	@ 0x30
3401cbc0:	4618      	mov	r0, r3
3401cbc2:	f001 fef8 	bl	3401e9b6 <ISP_IncDumpFrameId>
      break;
3401cbc6:	e010      	b.n	3401cbea <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncMainFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cbc8:	687b      	ldr	r3, [r7, #4]
3401cbca:	3330      	adds	r3, #48	@ 0x30
3401cbcc:	4618      	mov	r0, r3
3401cbce:	f001 fedc 	bl	3401e98a <ISP_IncMainFrameId>
      ISP_GatherStatistics(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cbd2:	687b      	ldr	r3, [r7, #4]
3401cbd4:	3330      	adds	r3, #48	@ 0x30
3401cbd6:	4618      	mov	r0, r3
3401cbd8:	f001 fecc 	bl	3401e974 <ISP_GatherStatistics>
      break;
3401cbdc:	e005      	b.n	3401cbea <CMW_IMX335_VsyncEventCallback+0x52>
      ISP_IncAncillaryFrameId(&((CMW_IMX335_t *)io_ctx)->hIsp);
3401cbde:	687b      	ldr	r3, [r7, #4]
3401cbe0:	3330      	adds	r3, #48	@ 0x30
3401cbe2:	4618      	mov	r0, r3
3401cbe4:	f001 fedc 	bl	3401e9a0 <ISP_IncAncillaryFrameId>
      break;
3401cbe8:	bf00      	nop
}
3401cbea:	bf00      	nop
3401cbec:	3708      	adds	r7, #8
3401cbee:	46bd      	mov	sp, r7
3401cbf0:	bd80      	pop	{r7, pc}

3401cbf2 <CMW_IMX335_FrameEventCallback>:

static void CMW_IMX335_FrameEventCallback(void *io_ctx, uint32_t pipe)
{
3401cbf2:	b480      	push	{r7}
3401cbf4:	b083      	sub	sp, #12
3401cbf6:	af00      	add	r7, sp, #0
3401cbf8:	6078      	str	r0, [r7, #4]
3401cbfa:	6039      	str	r1, [r7, #0]
}
3401cbfc:	bf00      	nop
3401cbfe:	370c      	adds	r7, #12
3401cc00:	46bd      	mov	sp, r7
3401cc02:	f85d 7b04 	ldr.w	r7, [sp], #4
3401cc06:	4770      	bx	lr

3401cc08 <CMW_IMX335_Probe>:

int CMW_IMX335_Probe(CMW_IMX335_t *io_ctx, CMW_Sensor_if_t *imx335_if)
{
3401cc08:	b580      	push	{r7, lr}
3401cc0a:	b084      	sub	sp, #16
3401cc0c:	af00      	add	r7, sp, #0
3401cc0e:	6078      	str	r0, [r7, #4]
3401cc10:	6039      	str	r1, [r7, #0]
  int ret = CMW_ERROR_NONE;
3401cc12:	2300      	movs	r3, #0
3401cc14:	60fb      	str	r3, [r7, #12]
  uint32_t id;
  io_ctx->ctx_driver.IO.Address = io_ctx->Address;
3401cc16:	687b      	ldr	r3, [r7, #4]
3401cc18:	881a      	ldrh	r2, [r3, #0]
3401cc1a:	687b      	ldr	r3, [r7, #4]
3401cc1c:	821a      	strh	r2, [r3, #16]
  io_ctx->ctx_driver.IO.Init = io_ctx->Init;
3401cc1e:	687b      	ldr	r3, [r7, #4]
3401cc20:	f8d3 20e4 	ldr.w	r2, [r3, #228]	@ 0xe4
3401cc24:	687b      	ldr	r3, [r7, #4]
3401cc26:	609a      	str	r2, [r3, #8]
  io_ctx->ctx_driver.IO.DeInit = io_ctx->DeInit;
3401cc28:	687b      	ldr	r3, [r7, #4]
3401cc2a:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3401cc2e:	687b      	ldr	r3, [r7, #4]
3401cc30:	60da      	str	r2, [r3, #12]
  io_ctx->ctx_driver.IO.GetTick = io_ctx->GetTick;
3401cc32:	687b      	ldr	r3, [r7, #4]
3401cc34:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3401cc38:	687b      	ldr	r3, [r7, #4]
3401cc3a:	61da      	str	r2, [r3, #28]
  io_ctx->ctx_driver.IO.ReadReg = io_ctx->ReadReg;
3401cc3c:	687b      	ldr	r3, [r7, #4]
3401cc3e:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3401cc42:	687b      	ldr	r3, [r7, #4]
3401cc44:	619a      	str	r2, [r3, #24]
  io_ctx->ctx_driver.IO.WriteReg = io_ctx->WriteReg;
3401cc46:	687b      	ldr	r3, [r7, #4]
3401cc48:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
3401cc4c:	687b      	ldr	r3, [r7, #4]
3401cc4e:	615a      	str	r2, [r3, #20]

  CMW_IMX335_PowerOn(io_ctx);
3401cc50:	6878      	ldr	r0, [r7, #4]
3401cc52:	f7ff ff71 	bl	3401cb38 <CMW_IMX335_PowerOn>

  ret = IMX335_RegisterBusIO(&io_ctx->ctx_driver, &io_ctx->ctx_driver.IO);
3401cc56:	687b      	ldr	r3, [r7, #4]
3401cc58:	f103 0208 	add.w	r2, r3, #8
3401cc5c:	687b      	ldr	r3, [r7, #4]
3401cc5e:	3308      	adds	r3, #8
3401cc60:	4619      	mov	r1, r3
3401cc62:	4610      	mov	r0, r2
3401cc64:	f000 f8ea 	bl	3401ce3c <IMX335_RegisterBusIO>
3401cc68:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3401cc6a:	68fb      	ldr	r3, [r7, #12]
3401cc6c:	2b00      	cmp	r3, #0
3401cc6e:	d002      	beq.n	3401cc76 <CMW_IMX335_Probe+0x6e>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401cc70:	f06f 0304 	mvn.w	r3, #4
3401cc74:	e044      	b.n	3401cd00 <CMW_IMX335_Probe+0xf8>
  }

  ret = IMX335_ReadID(&io_ctx->ctx_driver, &id);
3401cc76:	687b      	ldr	r3, [r7, #4]
3401cc78:	3308      	adds	r3, #8
3401cc7a:	f107 0208 	add.w	r2, r7, #8
3401cc7e:	4611      	mov	r1, r2
3401cc80:	4618      	mov	r0, r3
3401cc82:	f000 f991 	bl	3401cfa8 <IMX335_ReadID>
3401cc86:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3401cc88:	68fb      	ldr	r3, [r7, #12]
3401cc8a:	2b00      	cmp	r3, #0
3401cc8c:	d002      	beq.n	3401cc94 <CMW_IMX335_Probe+0x8c>
  {
    return CMW_ERROR_COMPONENT_FAILURE;
3401cc8e:	f06f 0304 	mvn.w	r3, #4
3401cc92:	e035      	b.n	3401cd00 <CMW_IMX335_Probe+0xf8>
  }
  if (id != IMX335_CHIP_ID)
3401cc94:	68bb      	ldr	r3, [r7, #8]
3401cc96:	2b00      	cmp	r3, #0
3401cc98:	d002      	beq.n	3401cca0 <CMW_IMX335_Probe+0x98>
  {
      ret = CMW_ERROR_UNKNOWN_COMPONENT;
3401cc9a:	f06f 0306 	mvn.w	r3, #6
3401cc9e:	60fb      	str	r3, [r7, #12]
  }

  memset(imx335_if, 0, sizeof(*imx335_if));
3401cca0:	2260      	movs	r2, #96	@ 0x60
3401cca2:	2100      	movs	r1, #0
3401cca4:	6838      	ldr	r0, [r7, #0]
3401cca6:	f00a fa75 	bl	34027194 <memset>
  imx335_if->Init = CMW_IMX335_Init;
3401ccaa:	683b      	ldr	r3, [r7, #0]
3401ccac:	4a16      	ldr	r2, [pc, #88]	@ (3401cd08 <CMW_IMX335_Probe+0x100>)
3401ccae:	601a      	str	r2, [r3, #0]
  imx335_if->Start = CMW_IMX335_Start;
3401ccb0:	683b      	ldr	r3, [r7, #0]
3401ccb2:	4a16      	ldr	r2, [pc, #88]	@ (3401cd0c <CMW_IMX335_Probe+0x104>)
3401ccb4:	609a      	str	r2, [r3, #8]
  imx335_if->DeInit = CMW_IMX335_DeInit;
3401ccb6:	683b      	ldr	r3, [r7, #0]
3401ccb8:	4a15      	ldr	r2, [pc, #84]	@ (3401cd10 <CMW_IMX335_Probe+0x108>)
3401ccba:	605a      	str	r2, [r3, #4]
  imx335_if->Run = CMW_IMX335_Run;
3401ccbc:	683b      	ldr	r3, [r7, #0]
3401ccbe:	4a15      	ldr	r2, [pc, #84]	@ (3401cd14 <CMW_IMX335_Probe+0x10c>)
3401ccc0:	60da      	str	r2, [r3, #12]
  imx335_if->VsyncEventCallback = CMW_IMX335_VsyncEventCallback;
3401ccc2:	683b      	ldr	r3, [r7, #0]
3401ccc4:	4a14      	ldr	r2, [pc, #80]	@ (3401cd18 <CMW_IMX335_Probe+0x110>)
3401ccc6:	611a      	str	r2, [r3, #16]
  imx335_if->FrameEventCallback = CMW_IMX335_FrameEventCallback;
3401ccc8:	683b      	ldr	r3, [r7, #0]
3401ccca:	4a14      	ldr	r2, [pc, #80]	@ (3401cd1c <CMW_IMX335_Probe+0x114>)
3401cccc:	615a      	str	r2, [r3, #20]
  imx335_if->ReadID = CMW_IMX335_ReadID;
3401ccce:	683b      	ldr	r3, [r7, #0]
3401ccd0:	4a13      	ldr	r2, [pc, #76]	@ (3401cd20 <CMW_IMX335_Probe+0x118>)
3401ccd2:	61da      	str	r2, [r3, #28]
  imx335_if->SetGain = CMW_IMX335_SetGain;
3401ccd4:	683b      	ldr	r3, [r7, #0]
3401ccd6:	4a13      	ldr	r2, [pc, #76]	@ (3401cd24 <CMW_IMX335_Probe+0x11c>)
3401ccd8:	649a      	str	r2, [r3, #72]	@ 0x48
  imx335_if->SetExposure = CMW_IMX335_SetExposure;
3401ccda:	683b      	ldr	r3, [r7, #0]
3401ccdc:	4a12      	ldr	r2, [pc, #72]	@ (3401cd28 <CMW_IMX335_Probe+0x120>)
3401ccde:	64da      	str	r2, [r3, #76]	@ 0x4c
  imx335_if->SetFrequency = CMW_IMX335_SetFrequency;
3401cce0:	683b      	ldr	r3, [r7, #0]
3401cce2:	4a12      	ldr	r2, [pc, #72]	@ (3401cd2c <CMW_IMX335_Probe+0x124>)
3401cce4:	641a      	str	r2, [r3, #64]	@ 0x40
  imx335_if->SetFramerate = CMW_IMX335_SetFramerate;
3401cce6:	683b      	ldr	r3, [r7, #0]
3401cce8:	4a11      	ldr	r2, [pc, #68]	@ (3401cd30 <CMW_IMX335_Probe+0x128>)
3401ccea:	645a      	str	r2, [r3, #68]	@ 0x44
  imx335_if->SetMirrorFlip = CMW_IMX335_SetMirrorFlip;
3401ccec:	683b      	ldr	r3, [r7, #0]
3401ccee:	4a11      	ldr	r2, [pc, #68]	@ (3401cd34 <CMW_IMX335_Probe+0x12c>)
3401ccf0:	62da      	str	r2, [r3, #44]	@ 0x2c
  imx335_if->GetSensorInfo = CMW_IMX335_GetSensorInfo;
3401ccf2:	683b      	ldr	r3, [r7, #0]
3401ccf4:	4a10      	ldr	r2, [pc, #64]	@ (3401cd38 <CMW_IMX335_Probe+0x130>)
3401ccf6:	659a      	str	r2, [r3, #88]	@ 0x58
  imx335_if->SetTestPattern = CMW_IMX335_SetTestPattern;
3401ccf8:	683b      	ldr	r3, [r7, #0]
3401ccfa:	4a10      	ldr	r2, [pc, #64]	@ (3401cd3c <CMW_IMX335_Probe+0x134>)
3401ccfc:	65da      	str	r2, [r3, #92]	@ 0x5c
  return ret;
3401ccfe:	68fb      	ldr	r3, [r7, #12]
}
3401cd00:	4618      	mov	r0, r3
3401cd02:	3710      	adds	r7, #16
3401cd04:	46bd      	mov	sp, r7
3401cd06:	bd80      	pop	{r7, pc}
3401cd08:	3401ca1d 	.word	0x3401ca1d
3401cd0c:	3401ca91 	.word	0x3401ca91
3401cd10:	3401c86d 	.word	0x3401c86d
3401cd14:	3401cb0d 	.word	0x3401cb0d
3401cd18:	3401cb99 	.word	0x3401cb99
3401cd1c:	3401cbf3 	.word	0x3401cbf3
3401cd20:	3401c8b5 	.word	0x3401c8b5
3401cd24:	3401c8d5 	.word	0x3401c8d5
3401cd28:	3401c8f5 	.word	0x3401c8f5
3401cd2c:	3401c915 	.word	0x3401c915
3401cd30:	3401c935 	.word	0x3401c935
3401cd34:	3401c955 	.word	0x3401c955
3401cd38:	3401c981 	.word	0x3401c981
3401cd3c:	3401c9fd 	.word	0x3401c9fd

3401cd40 <IMX335_WriteTable>:

/** @defgroup IMX335_Private_Functions Private Functions
  * @{
  */
static int32_t IMX335_WriteTable(IMX335_Object_t *pObj, const struct regval *regs, uint32_t size)
{
3401cd40:	b580      	push	{r7, lr}
3401cd42:	b086      	sub	sp, #24
3401cd44:	af00      	add	r7, sp, #0
3401cd46:	60f8      	str	r0, [r7, #12]
3401cd48:	60b9      	str	r1, [r7, #8]
3401cd4a:	607a      	str	r2, [r7, #4]
  uint32_t index;
  int32_t ret = IMX335_OK;
3401cd4c:	2300      	movs	r3, #0
3401cd4e:	613b      	str	r3, [r7, #16]

  /* Set registers */
  for(index=0; index<size ; index++)
3401cd50:	2300      	movs	r3, #0
3401cd52:	617b      	str	r3, [r7, #20]
3401cd54:	e01c      	b.n	3401cd90 <IMX335_WriteTable+0x50>
  {
    if(ret != IMX335_ERROR)
3401cd56:	693b      	ldr	r3, [r7, #16]
3401cd58:	f1b3 3fff 	cmp.w	r3, #4294967295
3401cd5c:	d015      	beq.n	3401cd8a <IMX335_WriteTable+0x4a>
    {
      if(imx335_write_reg(&pObj->Ctx, regs[index].addr, (uint8_t *)&(regs[index].val), 1) != IMX335_OK)
3401cd5e:	68fb      	ldr	r3, [r7, #12]
3401cd60:	f103 0018 	add.w	r0, r3, #24
3401cd64:	697b      	ldr	r3, [r7, #20]
3401cd66:	009b      	lsls	r3, r3, #2
3401cd68:	68ba      	ldr	r2, [r7, #8]
3401cd6a:	4413      	add	r3, r2
3401cd6c:	8819      	ldrh	r1, [r3, #0]
3401cd6e:	697b      	ldr	r3, [r7, #20]
3401cd70:	009b      	lsls	r3, r3, #2
3401cd72:	68ba      	ldr	r2, [r7, #8]
3401cd74:	4413      	add	r3, r2
3401cd76:	1c9a      	adds	r2, r3, #2
3401cd78:	2301      	movs	r3, #1
3401cd7a:	f000 fb92 	bl	3401d4a2 <imx335_write_reg>
3401cd7e:	4603      	mov	r3, r0
3401cd80:	2b00      	cmp	r3, #0
3401cd82:	d002      	beq.n	3401cd8a <IMX335_WriteTable+0x4a>
      {
        ret = IMX335_ERROR;
3401cd84:	f04f 33ff 	mov.w	r3, #4294967295
3401cd88:	613b      	str	r3, [r7, #16]
  for(index=0; index<size ; index++)
3401cd8a:	697b      	ldr	r3, [r7, #20]
3401cd8c:	3301      	adds	r3, #1
3401cd8e:	617b      	str	r3, [r7, #20]
3401cd90:	697a      	ldr	r2, [r7, #20]
3401cd92:	687b      	ldr	r3, [r7, #4]
3401cd94:	429a      	cmp	r2, r3
3401cd96:	d3de      	bcc.n	3401cd56 <IMX335_WriteTable+0x16>
      }
    }
  }
  return ret;
3401cd98:	693b      	ldr	r3, [r7, #16]
}
3401cd9a:	4618      	mov	r0, r3
3401cd9c:	3718      	adds	r7, #24
3401cd9e:	46bd      	mov	sp, r7
3401cda0:	bd80      	pop	{r7, pc}

3401cda2 <IMX335_Delay>:
  * @param pObj   pointer to component object
  * @param Delay  specifies the delay time length, in milliseconds
  * @retval IMX335_OK
  */
static int32_t IMX335_Delay(IMX335_Object_t *pObj, uint32_t Delay)
{
3401cda2:	b580      	push	{r7, lr}
3401cda4:	b084      	sub	sp, #16
3401cda6:	af00      	add	r7, sp, #0
3401cda8:	6078      	str	r0, [r7, #4]
3401cdaa:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  tickstart = pObj->IO.GetTick();
3401cdac:	687b      	ldr	r3, [r7, #4]
3401cdae:	695b      	ldr	r3, [r3, #20]
3401cdb0:	4798      	blx	r3
3401cdb2:	4603      	mov	r3, r0
3401cdb4:	60fb      	str	r3, [r7, #12]
  while((pObj->IO.GetTick() - tickstart) < Delay)
3401cdb6:	bf00      	nop
3401cdb8:	687b      	ldr	r3, [r7, #4]
3401cdba:	695b      	ldr	r3, [r3, #20]
3401cdbc:	4798      	blx	r3
3401cdbe:	4603      	mov	r3, r0
3401cdc0:	461a      	mov	r2, r3
3401cdc2:	68fb      	ldr	r3, [r7, #12]
3401cdc4:	1ad3      	subs	r3, r2, r3
3401cdc6:	683a      	ldr	r2, [r7, #0]
3401cdc8:	429a      	cmp	r2, r3
3401cdca:	d8f5      	bhi.n	3401cdb8 <IMX335_Delay+0x16>
  {
  }
  return IMX335_OK;
3401cdcc:	2300      	movs	r3, #0
}
3401cdce:	4618      	mov	r0, r3
3401cdd0:	3710      	adds	r7, #16
3401cdd2:	46bd      	mov	sp, r7
3401cdd4:	bd80      	pop	{r7, pc}

3401cdd6 <IMX335_ReadRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3401cdd6:	b590      	push	{r4, r7, lr}
3401cdd8:	b087      	sub	sp, #28
3401cdda:	af00      	add	r7, sp, #0
3401cddc:	60f8      	str	r0, [r7, #12]
3401cdde:	607a      	str	r2, [r7, #4]
3401cde0:	461a      	mov	r2, r3
3401cde2:	460b      	mov	r3, r1
3401cde4:	817b      	strh	r3, [r7, #10]
3401cde6:	4613      	mov	r3, r2
3401cde8:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3401cdea:	68fb      	ldr	r3, [r7, #12]
3401cdec:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
3401cdee:	697b      	ldr	r3, [r7, #20]
3401cdf0:	691c      	ldr	r4, [r3, #16]
3401cdf2:	697b      	ldr	r3, [r7, #20]
3401cdf4:	8918      	ldrh	r0, [r3, #8]
3401cdf6:	893b      	ldrh	r3, [r7, #8]
3401cdf8:	8979      	ldrh	r1, [r7, #10]
3401cdfa:	687a      	ldr	r2, [r7, #4]
3401cdfc:	47a0      	blx	r4
3401cdfe:	4603      	mov	r3, r0
}
3401ce00:	4618      	mov	r0, r3
3401ce02:	371c      	adds	r7, #28
3401ce04:	46bd      	mov	sp, r7
3401ce06:	bd90      	pop	{r4, r7, pc}

3401ce08 <IMX335_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t IMX335_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
3401ce08:	b590      	push	{r4, r7, lr}
3401ce0a:	b087      	sub	sp, #28
3401ce0c:	af00      	add	r7, sp, #0
3401ce0e:	60f8      	str	r0, [r7, #12]
3401ce10:	607a      	str	r2, [r7, #4]
3401ce12:	461a      	mov	r2, r3
3401ce14:	460b      	mov	r3, r1
3401ce16:	817b      	strh	r3, [r7, #10]
3401ce18:	4613      	mov	r3, r2
3401ce1a:	813b      	strh	r3, [r7, #8]
  IMX335_Object_t *pObj = (IMX335_Object_t *)handle;
3401ce1c:	68fb      	ldr	r3, [r7, #12]
3401ce1e:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
3401ce20:	697b      	ldr	r3, [r7, #20]
3401ce22:	68dc      	ldr	r4, [r3, #12]
3401ce24:	697b      	ldr	r3, [r7, #20]
3401ce26:	8918      	ldrh	r0, [r3, #8]
3401ce28:	893b      	ldrh	r3, [r7, #8]
3401ce2a:	8979      	ldrh	r1, [r7, #10]
3401ce2c:	687a      	ldr	r2, [r7, #4]
3401ce2e:	47a0      	blx	r4
3401ce30:	4603      	mov	r3, r0
}
3401ce32:	4618      	mov	r0, r3
3401ce34:	371c      	adds	r7, #28
3401ce36:	46bd      	mov	sp, r7
3401ce38:	bd90      	pop	{r4, r7, pc}
	...

3401ce3c <IMX335_RegisterBusIO>:
  * @brief  Register component IO bus
  * @param  Component object pointer
  * @retval Component status
  */
int32_t IMX335_RegisterBusIO(IMX335_Object_t *pObj, IMX335_IO_t *pIO)
{
3401ce3c:	b580      	push	{r7, lr}
3401ce3e:	b084      	sub	sp, #16
3401ce40:	af00      	add	r7, sp, #0
3401ce42:	6078      	str	r0, [r7, #4]
3401ce44:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
3401ce46:	687b      	ldr	r3, [r7, #4]
3401ce48:	2b00      	cmp	r3, #0
3401ce4a:	d103      	bne.n	3401ce54 <IMX335_RegisterBusIO+0x18>
  {
    ret = IMX335_ERROR;
3401ce4c:	f04f 33ff 	mov.w	r3, #4294967295
3401ce50:	60fb      	str	r3, [r7, #12]
3401ce52:	e02c      	b.n	3401ceae <IMX335_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
3401ce54:	683b      	ldr	r3, [r7, #0]
3401ce56:	681a      	ldr	r2, [r3, #0]
3401ce58:	687b      	ldr	r3, [r7, #4]
3401ce5a:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
3401ce5c:	683b      	ldr	r3, [r7, #0]
3401ce5e:	685a      	ldr	r2, [r3, #4]
3401ce60:	687b      	ldr	r3, [r7, #4]
3401ce62:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
3401ce64:	683b      	ldr	r3, [r7, #0]
3401ce66:	891a      	ldrh	r2, [r3, #8]
3401ce68:	687b      	ldr	r3, [r7, #4]
3401ce6a:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
3401ce6c:	683b      	ldr	r3, [r7, #0]
3401ce6e:	68da      	ldr	r2, [r3, #12]
3401ce70:	687b      	ldr	r3, [r7, #4]
3401ce72:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
3401ce74:	683b      	ldr	r3, [r7, #0]
3401ce76:	691a      	ldr	r2, [r3, #16]
3401ce78:	687b      	ldr	r3, [r7, #4]
3401ce7a:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
3401ce7c:	683b      	ldr	r3, [r7, #0]
3401ce7e:	695a      	ldr	r2, [r3, #20]
3401ce80:	687b      	ldr	r3, [r7, #4]
3401ce82:	615a      	str	r2, [r3, #20]

    pObj->Ctx.ReadReg  = IMX335_ReadRegWrap;
3401ce84:	687b      	ldr	r3, [r7, #4]
3401ce86:	4a0c      	ldr	r2, [pc, #48]	@ (3401ceb8 <IMX335_RegisterBusIO+0x7c>)
3401ce88:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = IMX335_WriteRegWrap;
3401ce8a:	687b      	ldr	r3, [r7, #4]
3401ce8c:	4a0b      	ldr	r2, [pc, #44]	@ (3401cebc <IMX335_RegisterBusIO+0x80>)
3401ce8e:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
3401ce90:	687b      	ldr	r3, [r7, #4]
3401ce92:	687a      	ldr	r2, [r7, #4]
3401ce94:	621a      	str	r2, [r3, #32]

    if(pObj->IO.Init != NULL)
3401ce96:	687b      	ldr	r3, [r7, #4]
3401ce98:	681b      	ldr	r3, [r3, #0]
3401ce9a:	2b00      	cmp	r3, #0
3401ce9c:	d004      	beq.n	3401cea8 <IMX335_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
3401ce9e:	687b      	ldr	r3, [r7, #4]
3401cea0:	681b      	ldr	r3, [r3, #0]
3401cea2:	4798      	blx	r3
3401cea4:	60f8      	str	r0, [r7, #12]
3401cea6:	e002      	b.n	3401ceae <IMX335_RegisterBusIO+0x72>
    }
    else
    {
      ret = IMX335_ERROR;
3401cea8:	f04f 33ff 	mov.w	r3, #4294967295
3401ceac:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
3401ceae:	68fb      	ldr	r3, [r7, #12]
}
3401ceb0:	4618      	mov	r0, r3
3401ceb2:	3710      	adds	r7, #16
3401ceb4:	46bd      	mov	sp, r7
3401ceb6:	bd80      	pop	{r7, pc}
3401ceb8:	3401cdd7 	.word	0x3401cdd7
3401cebc:	3401ce09 	.word	0x3401ce09

3401cec0 <IMX335_Init>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Init(IMX335_Object_t *pObj, uint32_t Resolution, uint32_t PixelFormat)
{
3401cec0:	b580      	push	{r7, lr}
3401cec2:	b086      	sub	sp, #24
3401cec4:	af00      	add	r7, sp, #0
3401cec6:	60f8      	str	r0, [r7, #12]
3401cec8:	60b9      	str	r1, [r7, #8]
3401ceca:	607a      	str	r2, [r7, #4]
  int32_t ret = IMX335_OK;
3401cecc:	2300      	movs	r3, #0
3401cece:	617b      	str	r3, [r7, #20]

  if(pObj->IsInitialized == 0U)
3401ced0:	68fb      	ldr	r3, [r7, #12]
3401ced2:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3401ced6:	2b00      	cmp	r3, #0
3401ced8:	d126      	bne.n	3401cf28 <IMX335_Init+0x68>
  {
    switch (Resolution)
3401ceda:	68bb      	ldr	r3, [r7, #8]
3401cedc:	2b06      	cmp	r3, #6
3401cede:	d10b      	bne.n	3401cef8 <IMX335_Init+0x38>
    {
      case IMX335_R2592_1944:
        if(IMX335_WriteTable(pObj, res_2592_1944_regs, ARRAY_SIZE(res_2592_1944_regs)) != IMX335_OK)
3401cee0:	2254      	movs	r2, #84	@ 0x54
3401cee2:	4914      	ldr	r1, [pc, #80]	@ (3401cf34 <IMX335_Init+0x74>)
3401cee4:	68f8      	ldr	r0, [r7, #12]
3401cee6:	f7ff ff2b 	bl	3401cd40 <IMX335_WriteTable>
3401ceea:	4603      	mov	r3, r0
3401ceec:	2b00      	cmp	r3, #0
3401ceee:	d007      	beq.n	3401cf00 <IMX335_Init+0x40>
        {
          ret = IMX335_ERROR;
3401cef0:	f04f 33ff 	mov.w	r3, #4294967295
3401cef4:	617b      	str	r3, [r7, #20]
        }
        break;
3401cef6:	e003      	b.n	3401cf00 <IMX335_Init+0x40>
      /* Add new resolution here */
      default:
        /* Resolution not supported */
        ret = IMX335_ERROR;
3401cef8:	f04f 33ff 	mov.w	r3, #4294967295
3401cefc:	617b      	str	r3, [r7, #20]
3401cefe:	e000      	b.n	3401cf02 <IMX335_Init+0x42>
        break;
3401cf00:	bf00      	nop
    }

    if(!ret)
3401cf02:	697b      	ldr	r3, [r7, #20]
3401cf04:	2b00      	cmp	r3, #0
3401cf06:	d10f      	bne.n	3401cf28 <IMX335_Init+0x68>
    {
      if(IMX335_WriteTable(pObj, mode_2l_10b_regs, ARRAY_SIZE(mode_2l_10b_regs)) != IMX335_OK)
3401cf08:	2205      	movs	r2, #5
3401cf0a:	490b      	ldr	r1, [pc, #44]	@ (3401cf38 <IMX335_Init+0x78>)
3401cf0c:	68f8      	ldr	r0, [r7, #12]
3401cf0e:	f7ff ff17 	bl	3401cd40 <IMX335_WriteTable>
3401cf12:	4603      	mov	r3, r0
3401cf14:	2b00      	cmp	r3, #0
3401cf16:	d003      	beq.n	3401cf20 <IMX335_Init+0x60>
      {
        ret = IMX335_ERROR;
3401cf18:	f04f 33ff 	mov.w	r3, #4294967295
3401cf1c:	617b      	str	r3, [r7, #20]
3401cf1e:	e003      	b.n	3401cf28 <IMX335_Init+0x68>
      }
      else
      {
        pObj->IsInitialized = 1U;
3401cf20:	68fb      	ldr	r3, [r7, #12]
3401cf22:	2201      	movs	r2, #1
3401cf24:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
      }
    }
  }

  return ret;
3401cf28:	697b      	ldr	r3, [r7, #20]
}
3401cf2a:	4618      	mov	r0, r3
3401cf2c:	3718      	adds	r7, #24
3401cf2e:	46bd      	mov	sp, r7
3401cf30:	bd80      	pop	{r7, pc}
3401cf32:	bf00      	nop
3401cf34:	3402c39c 	.word	0x3402c39c
3401cf38:	3402c4ec 	.word	0x3402c4ec

3401cf3c <IMX335_Start>:
  * @param  Resolution  Camera resolution
  * @param  PixelFormat pixel format to be configured
  * @retval Component status
  */
int32_t IMX335_Start(IMX335_Object_t *pObj)
{
3401cf3c:	b580      	push	{r7, lr}
3401cf3e:	b084      	sub	sp, #16
3401cf40:	af00      	add	r7, sp, #0
3401cf42:	6078      	str	r0, [r7, #4]
  uint8_t tmp;
  int32_t ret = IMX335_OK;
3401cf44:	2300      	movs	r3, #0
3401cf46:	60fb      	str	r3, [r7, #12]
  /* Start streaming */
  tmp = IMX335_MODE_STREAMING;
3401cf48:	2300      	movs	r3, #0
3401cf4a:	72fb      	strb	r3, [r7, #11]
  ret = imx335_write_reg(&pObj->Ctx, IMX335_REG_MODE_SELECT, &tmp, 1);
3401cf4c:	687b      	ldr	r3, [r7, #4]
3401cf4e:	f103 0018 	add.w	r0, r3, #24
3401cf52:	f107 020b 	add.w	r2, r7, #11
3401cf56:	2301      	movs	r3, #1
3401cf58:	f44f 5140 	mov.w	r1, #12288	@ 0x3000
3401cf5c:	f000 faa1 	bl	3401d4a2 <imx335_write_reg>
3401cf60:	60f8      	str	r0, [r7, #12]
  if (ret != IMX335_OK)
3401cf62:	68fb      	ldr	r3, [r7, #12]
3401cf64:	2b00      	cmp	r3, #0
3401cf66:	d002      	beq.n	3401cf6e <IMX335_Start+0x32>
  {
    return IMX335_ERROR;
3401cf68:	f04f 33ff 	mov.w	r3, #4294967295
3401cf6c:	e004      	b.n	3401cf78 <IMX335_Start+0x3c>
  }
  IMX335_Delay(pObj, 20);
3401cf6e:	2114      	movs	r1, #20
3401cf70:	6878      	ldr	r0, [r7, #4]
3401cf72:	f7ff ff16 	bl	3401cda2 <IMX335_Delay>
  return ret;
3401cf76:	68fb      	ldr	r3, [r7, #12]
}
3401cf78:	4618      	mov	r0, r3
3401cf7a:	3710      	adds	r7, #16
3401cf7c:	46bd      	mov	sp, r7
3401cf7e:	bd80      	pop	{r7, pc}

3401cf80 <IMX335_DeInit>:
  * @brief  De-initializes the camera sensor.
  * @param  pObj  pointer to component object
  * @retval Component status
  */
int32_t IMX335_DeInit(IMX335_Object_t *pObj)
{
3401cf80:	b480      	push	{r7}
3401cf82:	b083      	sub	sp, #12
3401cf84:	af00      	add	r7, sp, #0
3401cf86:	6078      	str	r0, [r7, #4]
  if(pObj->IsInitialized == 1U)
3401cf88:	687b      	ldr	r3, [r7, #4]
3401cf8a:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
3401cf8e:	2b01      	cmp	r3, #1
3401cf90:	d103      	bne.n	3401cf9a <IMX335_DeInit+0x1a>
  {
    /* De-initialize camera sensor interface */
    pObj->IsInitialized = 0U;
3401cf92:	687b      	ldr	r3, [r7, #4]
3401cf94:	2200      	movs	r2, #0
3401cf96:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
  }

  return IMX335_OK;
3401cf9a:	2300      	movs	r3, #0
}
3401cf9c:	4618      	mov	r0, r3
3401cf9e:	370c      	adds	r7, #12
3401cfa0:	46bd      	mov	sp, r7
3401cfa2:	f85d 7b04 	ldr.w	r7, [sp], #4
3401cfa6:	4770      	bx	lr

3401cfa8 <IMX335_ReadID>:
  * @param  pObj  pointer to component object
  * @param  Id    pointer to component ID
  * @retval Component status
  */
int32_t IMX335_ReadID(IMX335_Object_t *pObj, uint32_t *Id)
{
3401cfa8:	b580      	push	{r7, lr}
3401cfaa:	b084      	sub	sp, #16
3401cfac:	af00      	add	r7, sp, #0
3401cfae:	6078      	str	r0, [r7, #4]
3401cfb0:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint8_t tmp;

  /* Initialize I2C */
  pObj->IO.Init();
3401cfb2:	687b      	ldr	r3, [r7, #4]
3401cfb4:	681b      	ldr	r3, [r3, #0]
3401cfb6:	4798      	blx	r3

  if(imx335_read_reg(&pObj->Ctx, IMX335_REG_ID, &tmp, 1)!= IMX335_OK)
3401cfb8:	687b      	ldr	r3, [r7, #4]
3401cfba:	f103 0018 	add.w	r0, r3, #24
3401cfbe:	f107 020b 	add.w	r2, r7, #11
3401cfc2:	2301      	movs	r3, #1
3401cfc4:	f643 1112 	movw	r1, #14610	@ 0x3912
3401cfc8:	f000 fa54 	bl	3401d474 <imx335_read_reg>
3401cfcc:	4603      	mov	r3, r0
3401cfce:	2b00      	cmp	r3, #0
3401cfd0:	d003      	beq.n	3401cfda <IMX335_ReadID+0x32>
  {
    ret = IMX335_ERROR;
3401cfd2:	f04f 33ff 	mov.w	r3, #4294967295
3401cfd6:	60fb      	str	r3, [r7, #12]
3401cfd8:	e005      	b.n	3401cfe6 <IMX335_ReadID+0x3e>
  }
  else
  {
    *Id = tmp;
3401cfda:	7afb      	ldrb	r3, [r7, #11]
3401cfdc:	461a      	mov	r2, r3
3401cfde:	683b      	ldr	r3, [r7, #0]
3401cfe0:	601a      	str	r2, [r3, #0]
    ret = IMX335_OK;
3401cfe2:	2300      	movs	r3, #0
3401cfe4:	60fb      	str	r3, [r7, #12]
  }

  /* Component status */
  return ret;
3401cfe6:	68fb      	ldr	r3, [r7, #12]
}
3401cfe8:	4618      	mov	r0, r3
3401cfea:	3710      	adds	r7, #16
3401cfec:	46bd      	mov	sp, r7
3401cfee:	bd80      	pop	{r7, pc}

3401cff0 <IMX335_SetGain>:
  * @param  pObj  pointer to component object
  * @param  Gain Gain in mdB
  * @retval Component status
  */
int32_t IMX335_SetGain(IMX335_Object_t *pObj, int32_t gain)
{
3401cff0:	b580      	push	{r7, lr}
3401cff2:	b084      	sub	sp, #16
3401cff4:	af00      	add	r7, sp, #0
3401cff6:	6078      	str	r0, [r7, #4]
3401cff8:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3401cffa:	2300      	movs	r3, #0
3401cffc:	60fb      	str	r3, [r7, #12]
  uint8_t hold;

  if ((gain > IMX335_GAIN_MAX) || (gain < IMX335_GAIN_MIN))
3401cffe:	683b      	ldr	r3, [r7, #0]
3401d000:	4a25      	ldr	r2, [pc, #148]	@ (3401d098 <IMX335_SetGain+0xa8>)
3401d002:	4293      	cmp	r3, r2
3401d004:	dc02      	bgt.n	3401d00c <IMX335_SetGain+0x1c>
3401d006:	683b      	ldr	r3, [r7, #0]
3401d008:	2b00      	cmp	r3, #0
3401d00a:	da03      	bge.n	3401d014 <IMX335_SetGain+0x24>
  {
    ret = IMX335_ERROR;
3401d00c:	f04f 33ff 	mov.w	r3, #4294967295
3401d010:	60fb      	str	r3, [r7, #12]
3401d012:	e03c      	b.n	3401d08e <IMX335_SetGain+0x9e>
  }
  else
  {
    /* Convert to IMX335 gain unit (0.3 dB = 300 mdB) */
    gain /= IMX335_GAIN_UNIT_MDB;
3401d014:	683b      	ldr	r3, [r7, #0]
3401d016:	4a21      	ldr	r2, [pc, #132]	@ (3401d09c <IMX335_SetGain+0xac>)
3401d018:	fb82 1203 	smull	r1, r2, r2, r3
3401d01c:	1152      	asrs	r2, r2, #5
3401d01e:	17db      	asrs	r3, r3, #31
3401d020:	1ad3      	subs	r3, r2, r3
3401d022:	603b      	str	r3, [r7, #0]

    hold = 1;
3401d024:	2301      	movs	r3, #1
3401d026:	72fb      	strb	r3, [r7, #11]
    if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3401d028:	687b      	ldr	r3, [r7, #4]
3401d02a:	f103 0018 	add.w	r0, r3, #24
3401d02e:	f107 020b 	add.w	r2, r7, #11
3401d032:	2301      	movs	r3, #1
3401d034:	f243 0101 	movw	r1, #12289	@ 0x3001
3401d038:	f000 fa33 	bl	3401d4a2 <imx335_write_reg>
3401d03c:	4603      	mov	r3, r0
3401d03e:	2b00      	cmp	r3, #0
3401d040:	d003      	beq.n	3401d04a <IMX335_SetGain+0x5a>
    {
      ret = IMX335_ERROR;
3401d042:	f04f 33ff 	mov.w	r3, #4294967295
3401d046:	60fb      	str	r3, [r7, #12]
3401d048:	e021      	b.n	3401d08e <IMX335_SetGain+0x9e>
    }
    else
    {
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_GAIN, (uint8_t *)&gain, 2) != IMX335_OK)
3401d04a:	687b      	ldr	r3, [r7, #4]
3401d04c:	f103 0018 	add.w	r0, r3, #24
3401d050:	463a      	mov	r2, r7
3401d052:	2302      	movs	r3, #2
3401d054:	f243 01e8 	movw	r1, #12520	@ 0x30e8
3401d058:	f000 fa23 	bl	3401d4a2 <imx335_write_reg>
3401d05c:	4603      	mov	r3, r0
3401d05e:	2b00      	cmp	r3, #0
3401d060:	d003      	beq.n	3401d06a <IMX335_SetGain+0x7a>
      {
        ret = IMX335_ERROR;
3401d062:	f04f 33ff 	mov.w	r3, #4294967295
3401d066:	60fb      	str	r3, [r7, #12]
3401d068:	e011      	b.n	3401d08e <IMX335_SetGain+0x9e>
      }
      else
      {
        hold = 0;
3401d06a:	2300      	movs	r3, #0
3401d06c:	72fb      	strb	r3, [r7, #11]
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3401d06e:	687b      	ldr	r3, [r7, #4]
3401d070:	f103 0018 	add.w	r0, r3, #24
3401d074:	f107 020b 	add.w	r2, r7, #11
3401d078:	2301      	movs	r3, #1
3401d07a:	f243 0101 	movw	r1, #12289	@ 0x3001
3401d07e:	f000 fa10 	bl	3401d4a2 <imx335_write_reg>
3401d082:	4603      	mov	r3, r0
3401d084:	2b00      	cmp	r3, #0
3401d086:	d002      	beq.n	3401d08e <IMX335_SetGain+0x9e>
        {
          ret = IMX335_ERROR;
3401d088:	f04f 33ff 	mov.w	r3, #4294967295
3401d08c:	60fb      	str	r3, [r7, #12]
        }
      }
    }
  }

return ret;
3401d08e:	68fb      	ldr	r3, [r7, #12]
}
3401d090:	4618      	mov	r0, r3
3401d092:	3710      	adds	r7, #16
3401d094:	46bd      	mov	sp, r7
3401d096:	bd80      	pop	{r7, pc}
3401d098:	00011940 	.word	0x00011940
3401d09c:	1b4e81b5 	.word	0x1b4e81b5

3401d0a0 <IMX335_SetExposure>:
  * @param  pObj  pointer to component object
  * @param  Exposure Exposure in micro seconds
  * @retval Component status
  */
int32_t IMX335_SetExposure(IMX335_Object_t *pObj, int32_t exposure)
{
3401d0a0:	b580      	push	{r7, lr}
3401d0a2:	b086      	sub	sp, #24
3401d0a4:	af00      	add	r7, sp, #0
3401d0a6:	6078      	str	r0, [r7, #4]
3401d0a8:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3401d0aa:	2300      	movs	r3, #0
3401d0ac:	617b      	str	r3, [r7, #20]
  uint32_t vmax, shutter;
  uint8_t hold;


  if (imx335_read_reg(&pObj->Ctx, IMX335_REG_VMAX, (uint8_t *)&vmax, 4) != IMX335_OK)
3401d0ae:	687b      	ldr	r3, [r7, #4]
3401d0b0:	f103 0018 	add.w	r0, r3, #24
3401d0b4:	f107 0210 	add.w	r2, r7, #16
3401d0b8:	2304      	movs	r3, #4
3401d0ba:	f243 0130 	movw	r1, #12336	@ 0x3030
3401d0be:	f000 f9d9 	bl	3401d474 <imx335_read_reg>
3401d0c2:	4603      	mov	r3, r0
3401d0c4:	2b00      	cmp	r3, #0
3401d0c6:	d003      	beq.n	3401d0d0 <IMX335_SetExposure+0x30>
  {
    ret = IMX335_ERROR;
3401d0c8:	f04f 33ff 	mov.w	r3, #4294967295
3401d0cc:	617b      	str	r3, [r7, #20]
3401d0ce:	e051      	b.n	3401d174 <IMX335_SetExposure+0xd4>
  }
  else
  {
    shutter = (uint32_t) (vmax - (exposure / IMX335_1H_PERIOD_USEC));
3401d0d0:	693b      	ldr	r3, [r7, #16]
3401d0d2:	ee07 3a90 	vmov	s15, r3
3401d0d6:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401d0da:	683b      	ldr	r3, [r7, #0]
3401d0dc:	ee07 3a90 	vmov	s15, r3
3401d0e0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
3401d0e4:	ed9f 6a26 	vldr	s12, [pc, #152]	@ 3401d180 <IMX335_SetExposure+0xe0>
3401d0e8:	eec6 7a86 	vdiv.f32	s15, s13, s12
3401d0ec:	ee77 7a67 	vsub.f32	s15, s14, s15
3401d0f0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
3401d0f4:	ee17 3a90 	vmov	r3, s15
3401d0f8:	60fb      	str	r3, [r7, #12]

    if (shutter < IMX335_SHUTTER_MIN)
3401d0fa:	68fb      	ldr	r3, [r7, #12]
3401d0fc:	2b08      	cmp	r3, #8
3401d0fe:	d803      	bhi.n	3401d108 <IMX335_SetExposure+0x68>
    {
      ret = IMX335_ERROR;
3401d100:	f04f 33ff 	mov.w	r3, #4294967295
3401d104:	617b      	str	r3, [r7, #20]
3401d106:	e035      	b.n	3401d174 <IMX335_SetExposure+0xd4>
    }
    else
    {
      hold = 1;
3401d108:	2301      	movs	r3, #1
3401d10a:	72fb      	strb	r3, [r7, #11]
      if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3401d10c:	687b      	ldr	r3, [r7, #4]
3401d10e:	f103 0018 	add.w	r0, r3, #24
3401d112:	f107 020b 	add.w	r2, r7, #11
3401d116:	2301      	movs	r3, #1
3401d118:	f243 0101 	movw	r1, #12289	@ 0x3001
3401d11c:	f000 f9c1 	bl	3401d4a2 <imx335_write_reg>
3401d120:	4603      	mov	r3, r0
3401d122:	2b00      	cmp	r3, #0
3401d124:	d003      	beq.n	3401d12e <IMX335_SetExposure+0x8e>
      {
        ret = IMX335_ERROR;
3401d126:	f04f 33ff 	mov.w	r3, #4294967295
3401d12a:	617b      	str	r3, [r7, #20]
3401d12c:	e022      	b.n	3401d174 <IMX335_SetExposure+0xd4>
      }
      else
      {
        if(imx335_write_reg(&pObj->Ctx, IMX335_REG_SHUTTER, (uint8_t *)&shutter, 3) != IMX335_OK)
3401d12e:	687b      	ldr	r3, [r7, #4]
3401d130:	f103 0018 	add.w	r0, r3, #24
3401d134:	f107 020c 	add.w	r2, r7, #12
3401d138:	2303      	movs	r3, #3
3401d13a:	f243 0158 	movw	r1, #12376	@ 0x3058
3401d13e:	f000 f9b0 	bl	3401d4a2 <imx335_write_reg>
3401d142:	4603      	mov	r3, r0
3401d144:	2b00      	cmp	r3, #0
3401d146:	d003      	beq.n	3401d150 <IMX335_SetExposure+0xb0>
        {
          ret = IMX335_ERROR;
3401d148:	f04f 33ff 	mov.w	r3, #4294967295
3401d14c:	617b      	str	r3, [r7, #20]
3401d14e:	e011      	b.n	3401d174 <IMX335_SetExposure+0xd4>
        }
        else
        {
          hold = 0;
3401d150:	2300      	movs	r3, #0
3401d152:	72fb      	strb	r3, [r7, #11]
          if(imx335_write_reg(&pObj->Ctx, IMX335_REG_HOLD, &hold, 1) != IMX335_OK)
3401d154:	687b      	ldr	r3, [r7, #4]
3401d156:	f103 0018 	add.w	r0, r3, #24
3401d15a:	f107 020b 	add.w	r2, r7, #11
3401d15e:	2301      	movs	r3, #1
3401d160:	f243 0101 	movw	r1, #12289	@ 0x3001
3401d164:	f000 f99d 	bl	3401d4a2 <imx335_write_reg>
3401d168:	4603      	mov	r3, r0
3401d16a:	2b00      	cmp	r3, #0
3401d16c:	d002      	beq.n	3401d174 <IMX335_SetExposure+0xd4>
          {
            ret = IMX335_ERROR;
3401d16e:	f04f 33ff 	mov.w	r3, #4294967295
3401d172:	617b      	str	r3, [r7, #20]
        }
      }
    }
  }

  return ret;
3401d174:	697b      	ldr	r3, [r7, #20]
}
3401d176:	4618      	mov	r0, r3
3401d178:	3718      	adds	r7, #24
3401d17a:	46bd      	mov	sp, r7
3401d17c:	bd80      	pop	{r7, pc}
3401d17e:	bf00      	nop
3401d180:	40ed097c 	.word	0x40ed097c

3401d184 <IMX335_SetFrequency>:
  * @param  pObj  pointer to component object
  * @param  frequency in Mhz
  * @retval Component status
  */
int32_t IMX335_SetFrequency(IMX335_Object_t *pObj, int32_t frequency)
{
3401d184:	b580      	push	{r7, lr}
3401d186:	b084      	sub	sp, #16
3401d188:	af00      	add	r7, sp, #0
3401d18a:	6078      	str	r0, [r7, #4]
3401d18c:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3401d18e:	2300      	movs	r3, #0
3401d190:	60fb      	str	r3, [r7, #12]

  switch (frequency)
3401d192:	683b      	ldr	r3, [r7, #0]
3401d194:	3b01      	subs	r3, #1
3401d196:	2b04      	cmp	r3, #4
3401d198:	d848      	bhi.n	3401d22c <IMX335_SetFrequency+0xa8>
3401d19a:	a201      	add	r2, pc, #4	@ (adr r2, 3401d1a0 <IMX335_SetFrequency+0x1c>)
3401d19c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401d1a0:	3401d215 	.word	0x3401d215
3401d1a4:	3401d1fd 	.word	0x3401d1fd
3401d1a8:	3401d1e5 	.word	0x3401d1e5
3401d1ac:	3401d1b5 	.word	0x3401d1b5
3401d1b0:	3401d1cd 	.word	0x3401d1cd
  {
    case IMX335_INCK_74MHZ:
      if(IMX335_WriteTable(pObj, inck_74Mhz_regs, ARRAY_SIZE(inck_74Mhz_regs)) != IMX335_OK)
3401d1b4:	2207      	movs	r2, #7
3401d1b6:	492b      	ldr	r1, [pc, #172]	@ (3401d264 <IMX335_SetFrequency+0xe0>)
3401d1b8:	6878      	ldr	r0, [r7, #4]
3401d1ba:	f7ff fdc1 	bl	3401cd40 <IMX335_WriteTable>
3401d1be:	4603      	mov	r3, r0
3401d1c0:	2b00      	cmp	r3, #0
3401d1c2:	d03f      	beq.n	3401d244 <IMX335_SetFrequency+0xc0>
      {
        ret = IMX335_ERROR;
3401d1c4:	f04f 33ff 	mov.w	r3, #4294967295
3401d1c8:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d1ca:	e03b      	b.n	3401d244 <IMX335_SetFrequency+0xc0>
    case IMX335_INCK_37MHZ:
      if(IMX335_WriteTable(pObj, inck_37Mhz_regs, ARRAY_SIZE(inck_37Mhz_regs)) != IMX335_OK)
3401d1cc:	2207      	movs	r2, #7
3401d1ce:	4926      	ldr	r1, [pc, #152]	@ (3401d268 <IMX335_SetFrequency+0xe4>)
3401d1d0:	6878      	ldr	r0, [r7, #4]
3401d1d2:	f7ff fdb5 	bl	3401cd40 <IMX335_WriteTable>
3401d1d6:	4603      	mov	r3, r0
3401d1d8:	2b00      	cmp	r3, #0
3401d1da:	d035      	beq.n	3401d248 <IMX335_SetFrequency+0xc4>
      {
        ret = IMX335_ERROR;
3401d1dc:	f04f 33ff 	mov.w	r3, #4294967295
3401d1e0:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d1e2:	e031      	b.n	3401d248 <IMX335_SetFrequency+0xc4>
    case IMX335_INCK_27MHZ:
      if(IMX335_WriteTable(pObj, inck_27Mhz_regs, ARRAY_SIZE(inck_27Mhz_regs)) != IMX335_OK)
3401d1e4:	2207      	movs	r2, #7
3401d1e6:	4921      	ldr	r1, [pc, #132]	@ (3401d26c <IMX335_SetFrequency+0xe8>)
3401d1e8:	6878      	ldr	r0, [r7, #4]
3401d1ea:	f7ff fda9 	bl	3401cd40 <IMX335_WriteTable>
3401d1ee:	4603      	mov	r3, r0
3401d1f0:	2b00      	cmp	r3, #0
3401d1f2:	d02b      	beq.n	3401d24c <IMX335_SetFrequency+0xc8>
      {
        ret = IMX335_ERROR;
3401d1f4:	f04f 33ff 	mov.w	r3, #4294967295
3401d1f8:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d1fa:	e027      	b.n	3401d24c <IMX335_SetFrequency+0xc8>
    case IMX335_INCK_24MHZ:
      if(IMX335_WriteTable(pObj, inck_24Mhz_regs, ARRAY_SIZE(inck_24Mhz_regs)) != IMX335_OK)
3401d1fc:	2207      	movs	r2, #7
3401d1fe:	491c      	ldr	r1, [pc, #112]	@ (3401d270 <IMX335_SetFrequency+0xec>)
3401d200:	6878      	ldr	r0, [r7, #4]
3401d202:	f7ff fd9d 	bl	3401cd40 <IMX335_WriteTable>
3401d206:	4603      	mov	r3, r0
3401d208:	2b00      	cmp	r3, #0
3401d20a:	d021      	beq.n	3401d250 <IMX335_SetFrequency+0xcc>
      {
        ret = IMX335_ERROR;
3401d20c:	f04f 33ff 	mov.w	r3, #4294967295
3401d210:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d212:	e01d      	b.n	3401d250 <IMX335_SetFrequency+0xcc>
    case IMX335_INCK_18MHZ:
      if(IMX335_WriteTable(pObj, inck_18Mhz_regs, ARRAY_SIZE(inck_18Mhz_regs)) != IMX335_OK)
3401d214:	2207      	movs	r2, #7
3401d216:	4917      	ldr	r1, [pc, #92]	@ (3401d274 <IMX335_SetFrequency+0xf0>)
3401d218:	6878      	ldr	r0, [r7, #4]
3401d21a:	f7ff fd91 	bl	3401cd40 <IMX335_WriteTable>
3401d21e:	4603      	mov	r3, r0
3401d220:	2b00      	cmp	r3, #0
3401d222:	d017      	beq.n	3401d254 <IMX335_SetFrequency+0xd0>
      {
        ret = IMX335_ERROR;
3401d224:	f04f 33ff 	mov.w	r3, #4294967295
3401d228:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d22a:	e013      	b.n	3401d254 <IMX335_SetFrequency+0xd0>
    default:
      /* IMX335_INCK_6MHZ */
      if(IMX335_WriteTable(pObj, inck_6Mhz_regs, ARRAY_SIZE(inck_6Mhz_regs)) != IMX335_OK)
3401d22c:	2207      	movs	r2, #7
3401d22e:	4912      	ldr	r1, [pc, #72]	@ (3401d278 <IMX335_SetFrequency+0xf4>)
3401d230:	6878      	ldr	r0, [r7, #4]
3401d232:	f7ff fd85 	bl	3401cd40 <IMX335_WriteTable>
3401d236:	4603      	mov	r3, r0
3401d238:	2b00      	cmp	r3, #0
3401d23a:	d00d      	beq.n	3401d258 <IMX335_SetFrequency+0xd4>
      {
        ret = IMX335_ERROR;
3401d23c:	f04f 33ff 	mov.w	r3, #4294967295
3401d240:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d242:	e009      	b.n	3401d258 <IMX335_SetFrequency+0xd4>
      break;
3401d244:	bf00      	nop
3401d246:	e008      	b.n	3401d25a <IMX335_SetFrequency+0xd6>
      break;
3401d248:	bf00      	nop
3401d24a:	e006      	b.n	3401d25a <IMX335_SetFrequency+0xd6>
      break;
3401d24c:	bf00      	nop
3401d24e:	e004      	b.n	3401d25a <IMX335_SetFrequency+0xd6>
      break;
3401d250:	bf00      	nop
3401d252:	e002      	b.n	3401d25a <IMX335_SetFrequency+0xd6>
      break;
3401d254:	bf00      	nop
3401d256:	e000      	b.n	3401d25a <IMX335_SetFrequency+0xd6>
      break;
3401d258:	bf00      	nop
  };

  return ret;
3401d25a:	68fb      	ldr	r3, [r7, #12]
}
3401d25c:	4618      	mov	r0, r3
3401d25e:	3710      	adds	r7, #16
3401d260:	46bd      	mov	sp, r7
3401d262:	bd80      	pop	{r7, pc}
3401d264:	3402c500 	.word	0x3402c500
3401d268:	3402c51c 	.word	0x3402c51c
3401d26c:	3402c538 	.word	0x3402c538
3401d270:	3402c554 	.word	0x3402c554
3401d274:	3402c570 	.word	0x3402c570
3401d278:	3402c58c 	.word	0x3402c58c

3401d27c <IMX335_SetFramerate>:
  * @param  pObj  pointer to component object
  * @param  framerate 10, 15, 20, 25 or 30fps
  * @retval Component status
  */
int32_t IMX335_SetFramerate(IMX335_Object_t *pObj, int32_t framerate)
{
3401d27c:	b580      	push	{r7, lr}
3401d27e:	b084      	sub	sp, #16
3401d280:	af00      	add	r7, sp, #0
3401d282:	6078      	str	r0, [r7, #4]
3401d284:	6039      	str	r1, [r7, #0]
  uint32_t ret = IMX335_OK;
3401d286:	2300      	movs	r3, #0
3401d288:	60fb      	str	r3, [r7, #12]
  switch (framerate)
3401d28a:	683b      	ldr	r3, [r7, #0]
3401d28c:	3b0a      	subs	r3, #10
3401d28e:	2b0f      	cmp	r3, #15
3401d290:	d852      	bhi.n	3401d338 <IMX335_SetFramerate+0xbc>
3401d292:	a201      	add	r2, pc, #4	@ (adr r2, 3401d298 <IMX335_SetFramerate+0x1c>)
3401d294:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401d298:	3401d2d9 	.word	0x3401d2d9
3401d29c:	3401d339 	.word	0x3401d339
3401d2a0:	3401d339 	.word	0x3401d339
3401d2a4:	3401d339 	.word	0x3401d339
3401d2a8:	3401d339 	.word	0x3401d339
3401d2ac:	3401d2f1 	.word	0x3401d2f1
3401d2b0:	3401d339 	.word	0x3401d339
3401d2b4:	3401d339 	.word	0x3401d339
3401d2b8:	3401d339 	.word	0x3401d339
3401d2bc:	3401d339 	.word	0x3401d339
3401d2c0:	3401d309 	.word	0x3401d309
3401d2c4:	3401d339 	.word	0x3401d339
3401d2c8:	3401d339 	.word	0x3401d339
3401d2cc:	3401d339 	.word	0x3401d339
3401d2d0:	3401d339 	.word	0x3401d339
3401d2d4:	3401d321 	.word	0x3401d321
  {
    case 10:
      if(IMX335_WriteTable(pObj, framerate_10fps_regs, ARRAY_SIZE(framerate_10fps_regs)) != IMX335_OK)
3401d2d8:	2202      	movs	r2, #2
3401d2da:	4924      	ldr	r1, [pc, #144]	@ (3401d36c <IMX335_SetFramerate+0xf0>)
3401d2dc:	6878      	ldr	r0, [r7, #4]
3401d2de:	f7ff fd2f 	bl	3401cd40 <IMX335_WriteTable>
3401d2e2:	4603      	mov	r3, r0
3401d2e4:	2b00      	cmp	r3, #0
3401d2e6:	d033      	beq.n	3401d350 <IMX335_SetFramerate+0xd4>
      {
        ret = IMX335_ERROR;
3401d2e8:	f04f 33ff 	mov.w	r3, #4294967295
3401d2ec:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d2ee:	e02f      	b.n	3401d350 <IMX335_SetFramerate+0xd4>
    case 15:
      if(IMX335_WriteTable(pObj, framerate_15fps_regs, ARRAY_SIZE(framerate_15fps_regs)) != IMX335_OK)
3401d2f0:	2202      	movs	r2, #2
3401d2f2:	491f      	ldr	r1, [pc, #124]	@ (3401d370 <IMX335_SetFramerate+0xf4>)
3401d2f4:	6878      	ldr	r0, [r7, #4]
3401d2f6:	f7ff fd23 	bl	3401cd40 <IMX335_WriteTable>
3401d2fa:	4603      	mov	r3, r0
3401d2fc:	2b00      	cmp	r3, #0
3401d2fe:	d029      	beq.n	3401d354 <IMX335_SetFramerate+0xd8>
      {
        ret = IMX335_ERROR;
3401d300:	f04f 33ff 	mov.w	r3, #4294967295
3401d304:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d306:	e025      	b.n	3401d354 <IMX335_SetFramerate+0xd8>
    case 20:
      if(IMX335_WriteTable(pObj, framerate_20fps_regs, ARRAY_SIZE(framerate_20fps_regs)) != IMX335_OK)
3401d308:	2202      	movs	r2, #2
3401d30a:	491a      	ldr	r1, [pc, #104]	@ (3401d374 <IMX335_SetFramerate+0xf8>)
3401d30c:	6878      	ldr	r0, [r7, #4]
3401d30e:	f7ff fd17 	bl	3401cd40 <IMX335_WriteTable>
3401d312:	4603      	mov	r3, r0
3401d314:	2b00      	cmp	r3, #0
3401d316:	d01f      	beq.n	3401d358 <IMX335_SetFramerate+0xdc>
      {
       ret = IMX335_ERROR;
3401d318:	f04f 33ff 	mov.w	r3, #4294967295
3401d31c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d31e:	e01b      	b.n	3401d358 <IMX335_SetFramerate+0xdc>
    case 25:
      if(IMX335_WriteTable(pObj, framerate_25fps_regs, ARRAY_SIZE(framerate_25fps_regs)) != IMX335_OK)
3401d320:	2202      	movs	r2, #2
3401d322:	4915      	ldr	r1, [pc, #84]	@ (3401d378 <IMX335_SetFramerate+0xfc>)
3401d324:	6878      	ldr	r0, [r7, #4]
3401d326:	f7ff fd0b 	bl	3401cd40 <IMX335_WriteTable>
3401d32a:	4603      	mov	r3, r0
3401d32c:	2b00      	cmp	r3, #0
3401d32e:	d015      	beq.n	3401d35c <IMX335_SetFramerate+0xe0>
      {
        ret = IMX335_ERROR;
3401d330:	f04f 33ff 	mov.w	r3, #4294967295
3401d334:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d336:	e011      	b.n	3401d35c <IMX335_SetFramerate+0xe0>
    default:
      /* 30fps */
      if(IMX335_WriteTable(pObj, framerate_30fps_regs, ARRAY_SIZE(framerate_30fps_regs)) != IMX335_OK)
3401d338:	2202      	movs	r2, #2
3401d33a:	4910      	ldr	r1, [pc, #64]	@ (3401d37c <IMX335_SetFramerate+0x100>)
3401d33c:	6878      	ldr	r0, [r7, #4]
3401d33e:	f7ff fcff 	bl	3401cd40 <IMX335_WriteTable>
3401d342:	4603      	mov	r3, r0
3401d344:	2b00      	cmp	r3, #0
3401d346:	d00b      	beq.n	3401d360 <IMX335_SetFramerate+0xe4>
      {
        ret = IMX335_ERROR;
3401d348:	f04f 33ff 	mov.w	r3, #4294967295
3401d34c:	60fb      	str	r3, [r7, #12]
      }
      break;
3401d34e:	e007      	b.n	3401d360 <IMX335_SetFramerate+0xe4>
      break;
3401d350:	bf00      	nop
3401d352:	e006      	b.n	3401d362 <IMX335_SetFramerate+0xe6>
      break;
3401d354:	bf00      	nop
3401d356:	e004      	b.n	3401d362 <IMX335_SetFramerate+0xe6>
      break;
3401d358:	bf00      	nop
3401d35a:	e002      	b.n	3401d362 <IMX335_SetFramerate+0xe6>
      break;
3401d35c:	bf00      	nop
3401d35e:	e000      	b.n	3401d362 <IMX335_SetFramerate+0xe6>
      break;
3401d360:	bf00      	nop
  };

  return ret;
3401d362:	68fb      	ldr	r3, [r7, #12]
}
3401d364:	4618      	mov	r0, r3
3401d366:	3710      	adds	r7, #16
3401d368:	46bd      	mov	sp, r7
3401d36a:	bd80      	pop	{r7, pc}
3401d36c:	3402c5a8 	.word	0x3402c5a8
3401d370:	3402c5b0 	.word	0x3402c5b0
3401d374:	3402c5b8 	.word	0x3402c5b8
3401d378:	3402c5c0 	.word	0x3402c5c0
3401d37c:	3402c5c8 	.word	0x3402c5c8

3401d380 <IMX335_MirrorFlipConfig>:
  * @param  pObj  pointer to component object
  * @param  Config To configure mirror, flip, both or none
  * @retval Component status
  */
int32_t IMX335_MirrorFlipConfig(IMX335_Object_t *pObj, uint32_t Config)
{
3401d380:	b580      	push	{r7, lr}
3401d382:	b084      	sub	sp, #16
3401d384:	af00      	add	r7, sp, #0
3401d386:	6078      	str	r0, [r7, #4]
3401d388:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3401d38a:	2300      	movs	r3, #0
3401d38c:	60fb      	str	r3, [r7, #12]

  switch (Config)
3401d38e:	683b      	ldr	r3, [r7, #0]
3401d390:	2b03      	cmp	r3, #3
3401d392:	d017      	beq.n	3401d3c4 <IMX335_MirrorFlipConfig+0x44>
3401d394:	683b      	ldr	r3, [r7, #0]
3401d396:	2b03      	cmp	r3, #3
3401d398:	d81b      	bhi.n	3401d3d2 <IMX335_MirrorFlipConfig+0x52>
3401d39a:	683b      	ldr	r3, [r7, #0]
3401d39c:	2b01      	cmp	r3, #1
3401d39e:	d003      	beq.n	3401d3a8 <IMX335_MirrorFlipConfig+0x28>
3401d3a0:	683b      	ldr	r3, [r7, #0]
3401d3a2:	2b02      	cmp	r3, #2
3401d3a4:	d007      	beq.n	3401d3b6 <IMX335_MirrorFlipConfig+0x36>
3401d3a6:	e014      	b.n	3401d3d2 <IMX335_MirrorFlipConfig+0x52>
  {
    case IMX335_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[1], ARRAY_SIZE(mirrorflip_mode_regs[1]));
3401d3a8:	220a      	movs	r2, #10
3401d3aa:	4910      	ldr	r1, [pc, #64]	@ (3401d3ec <IMX335_MirrorFlipConfig+0x6c>)
3401d3ac:	6878      	ldr	r0, [r7, #4]
3401d3ae:	f7ff fcc7 	bl	3401cd40 <IMX335_WriteTable>
3401d3b2:	60f8      	str	r0, [r7, #12]
      break;
3401d3b4:	e014      	b.n	3401d3e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[2], ARRAY_SIZE(mirrorflip_mode_regs[2]));
3401d3b6:	220a      	movs	r2, #10
3401d3b8:	490d      	ldr	r1, [pc, #52]	@ (3401d3f0 <IMX335_MirrorFlipConfig+0x70>)
3401d3ba:	6878      	ldr	r0, [r7, #4]
3401d3bc:	f7ff fcc0 	bl	3401cd40 <IMX335_WriteTable>
3401d3c0:	60f8      	str	r0, [r7, #12]
      break;
3401d3c2:	e00d      	b.n	3401d3e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[3], ARRAY_SIZE(mirrorflip_mode_regs[3]));
3401d3c4:	220a      	movs	r2, #10
3401d3c6:	490b      	ldr	r1, [pc, #44]	@ (3401d3f4 <IMX335_MirrorFlipConfig+0x74>)
3401d3c8:	6878      	ldr	r0, [r7, #4]
3401d3ca:	f7ff fcb9 	bl	3401cd40 <IMX335_WriteTable>
3401d3ce:	60f8      	str	r0, [r7, #12]
      break;
3401d3d0:	e006      	b.n	3401d3e0 <IMX335_MirrorFlipConfig+0x60>
    case IMX335_MIRROR_FLIP_NONE:
    default:
      ret = IMX335_WriteTable(pObj, mirrorflip_mode_regs[0], ARRAY_SIZE(mirrorflip_mode_regs[0]));
3401d3d2:	220a      	movs	r2, #10
3401d3d4:	4908      	ldr	r1, [pc, #32]	@ (3401d3f8 <IMX335_MirrorFlipConfig+0x78>)
3401d3d6:	6878      	ldr	r0, [r7, #4]
3401d3d8:	f7ff fcb2 	bl	3401cd40 <IMX335_WriteTable>
3401d3dc:	60f8      	str	r0, [r7, #12]
      break;
3401d3de:	bf00      	nop
  }
  return ret;
3401d3e0:	68fb      	ldr	r3, [r7, #12]
}
3401d3e2:	4618      	mov	r0, r3
3401d3e4:	3710      	adds	r7, #16
3401d3e6:	46bd      	mov	sp, r7
3401d3e8:	bd80      	pop	{r7, pc}
3401d3ea:	bf00      	nop
3401d3ec:	3402c5f8 	.word	0x3402c5f8
3401d3f0:	3402c620 	.word	0x3402c620
3401d3f4:	3402c648 	.word	0x3402c648
3401d3f8:	3402c5d0 	.word	0x3402c5d0

3401d3fc <IMX335_SetTestPattern>:
  *               10: Horizontal color bars
  *               11: Vertical color bars
  * @retval Component status
  */
int32_t IMX335_SetTestPattern(IMX335_Object_t *pObj, int32_t mode)
{
3401d3fc:	b580      	push	{r7, lr}
3401d3fe:	b084      	sub	sp, #16
3401d400:	af00      	add	r7, sp, #0
3401d402:	6078      	str	r0, [r7, #4]
3401d404:	6039      	str	r1, [r7, #0]
  int32_t ret = IMX335_OK;
3401d406:	2300      	movs	r3, #0
3401d408:	60fb      	str	r3, [r7, #12]
  uint8_t val;

  if (mode >= 0)
3401d40a:	683b      	ldr	r3, [r7, #0]
3401d40c:	2b00      	cmp	r3, #0
3401d40e:	db1d      	blt.n	3401d44c <IMX335_SetTestPattern+0x50>
  {
    /* Enable Test Pattern #mode */
    val = mode;
3401d410:	683b      	ldr	r3, [r7, #0]
3401d412:	b2db      	uxtb	r3, r3
3401d414:	72fb      	strb	r3, [r7, #11]
    if (imx335_write_reg(&pObj->Ctx, IMX335_REG_TPG, &val, 1) != IMX335_OK)
3401d416:	687b      	ldr	r3, [r7, #4]
3401d418:	f103 0018 	add.w	r0, r3, #24
3401d41c:	f107 020b 	add.w	r2, r7, #11
3401d420:	2301      	movs	r3, #1
3401d422:	f243 219e 	movw	r1, #12958	@ 0x329e
3401d426:	f000 f83c 	bl	3401d4a2 <imx335_write_reg>
3401d42a:	4603      	mov	r3, r0
3401d42c:	2b00      	cmp	r3, #0
3401d42e:	d002      	beq.n	3401d436 <IMX335_SetTestPattern+0x3a>
    {
      return IMX335_ERROR;
3401d430:	f04f 33ff 	mov.w	r3, #4294967295
3401d434:	e016      	b.n	3401d464 <IMX335_SetTestPattern+0x68>
    }
    if (IMX335_WriteTable(pObj, test_pattern_enable_regs, ARRAY_SIZE(test_pattern_enable_regs)) != IMX335_OK)
3401d436:	2207      	movs	r2, #7
3401d438:	490c      	ldr	r1, [pc, #48]	@ (3401d46c <IMX335_SetTestPattern+0x70>)
3401d43a:	6878      	ldr	r0, [r7, #4]
3401d43c:	f7ff fc80 	bl	3401cd40 <IMX335_WriteTable>
3401d440:	4603      	mov	r3, r0
3401d442:	2b00      	cmp	r3, #0
3401d444:	d00d      	beq.n	3401d462 <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3401d446:	f04f 33ff 	mov.w	r3, #4294967295
3401d44a:	e00b      	b.n	3401d464 <IMX335_SetTestPattern+0x68>
    }
  }
  else
  {
    /* Disable Test Pattern */
    if (IMX335_WriteTable(pObj, test_pattern_disable_regs, ARRAY_SIZE(test_pattern_disable_regs)) != IMX335_OK)
3401d44c:	2207      	movs	r2, #7
3401d44e:	4908      	ldr	r1, [pc, #32]	@ (3401d470 <IMX335_SetTestPattern+0x74>)
3401d450:	6878      	ldr	r0, [r7, #4]
3401d452:	f7ff fc75 	bl	3401cd40 <IMX335_WriteTable>
3401d456:	4603      	mov	r3, r0
3401d458:	2b00      	cmp	r3, #0
3401d45a:	d002      	beq.n	3401d462 <IMX335_SetTestPattern+0x66>
    {
      return IMX335_ERROR;
3401d45c:	f04f 33ff 	mov.w	r3, #4294967295
3401d460:	e000      	b.n	3401d464 <IMX335_SetTestPattern+0x68>
    }
  }

  return ret;
3401d462:	68fb      	ldr	r3, [r7, #12]
}
3401d464:	4618      	mov	r0, r3
3401d466:	3710      	adds	r7, #16
3401d468:	46bd      	mov	sp, r7
3401d46a:	bd80      	pop	{r7, pc}
3401d46c:	3402c670 	.word	0x3402c670
3401d470:	3402c68c 	.word	0x3402c68c

3401d474 <imx335_read_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to read
  * @retval Component status
  */
int32_t imx335_read_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *pdata, uint16_t length)
{
3401d474:	b590      	push	{r4, r7, lr}
3401d476:	b085      	sub	sp, #20
3401d478:	af00      	add	r7, sp, #0
3401d47a:	60f8      	str	r0, [r7, #12]
3401d47c:	607a      	str	r2, [r7, #4]
3401d47e:	461a      	mov	r2, r3
3401d480:	460b      	mov	r3, r1
3401d482:	817b      	strh	r3, [r7, #10]
3401d484:	4613      	mov	r3, r2
3401d486:	813b      	strh	r3, [r7, #8]
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
3401d488:	68fb      	ldr	r3, [r7, #12]
3401d48a:	685c      	ldr	r4, [r3, #4]
3401d48c:	68fb      	ldr	r3, [r7, #12]
3401d48e:	6898      	ldr	r0, [r3, #8]
3401d490:	893b      	ldrh	r3, [r7, #8]
3401d492:	8979      	ldrh	r1, [r7, #10]
3401d494:	687a      	ldr	r2, [r7, #4]
3401d496:	47a0      	blx	r4
3401d498:	4603      	mov	r3, r0
}
3401d49a:	4618      	mov	r0, r3
3401d49c:	3714      	adds	r7, #20
3401d49e:	46bd      	mov	sp, r7
3401d4a0:	bd90      	pop	{r4, r7, pc}

3401d4a2 <imx335_write_reg>:
  * @param  pdata Pointer to data buffer
  * @param  length Number of data to write
  * @retval Component status
  */
int32_t imx335_write_reg(imx335_ctx_t *ctx, uint16_t reg, uint8_t *data, uint16_t length)
{
3401d4a2:	b590      	push	{r4, r7, lr}
3401d4a4:	b085      	sub	sp, #20
3401d4a6:	af00      	add	r7, sp, #0
3401d4a8:	60f8      	str	r0, [r7, #12]
3401d4aa:	607a      	str	r2, [r7, #4]
3401d4ac:	461a      	mov	r2, r3
3401d4ae:	460b      	mov	r3, r1
3401d4b0:	817b      	strh	r3, [r7, #10]
3401d4b2:	4613      	mov	r3, r2
3401d4b4:	813b      	strh	r3, [r7, #8]
  return ctx->WriteReg(ctx->handle, reg, data, length);
3401d4b6:	68fb      	ldr	r3, [r7, #12]
3401d4b8:	681c      	ldr	r4, [r3, #0]
3401d4ba:	68fb      	ldr	r3, [r7, #12]
3401d4bc:	6898      	ldr	r0, [r3, #8]
3401d4be:	893b      	ldrh	r3, [r7, #8]
3401d4c0:	8979      	ldrh	r1, [r7, #10]
3401d4c2:	687a      	ldr	r2, [r7, #4]
3401d4c4:	47a0      	blx	r4
3401d4c6:	4603      	mov	r3, r0
}
3401d4c8:	4618      	mov	r0, r3
3401d4ca:	3714      	adds	r7, #20
3401d4cc:	46bd      	mov	sp, r7
3401d4ce:	bd90      	pop	{r4, r7, pc}

3401d4d0 <ISP_Algo_BadPixel_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Init(void *hIsp, void *pAlgo)
{
3401d4d0:	b480      	push	{r7}
3401d4d2:	b083      	sub	sp, #12
3401d4d4:	af00      	add	r7, sp, #0
3401d4d6:	6078      	str	r0, [r7, #4]
3401d4d8:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ((ISP_AlgoTypeDef *)pAlgo)->state = ISP_ALGO_STATE_INIT;
3401d4da:	683b      	ldr	r3, [r7, #0]
3401d4dc:	2200      	movs	r2, #0
3401d4de:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
3401d4e0:	2300      	movs	r3, #0
}
3401d4e2:	4618      	mov	r0, r3
3401d4e4:	370c      	adds	r7, #12
3401d4e6:	46bd      	mov	sp, r7
3401d4e8:	f85d 7b04 	ldr.w	r7, [sp], #4
3401d4ec:	4770      	bx	lr

3401d4ee <ISP_Algo_BadPixel_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_DeInit(void *hIsp, void *pAlgo)
{
3401d4ee:	b480      	push	{r7}
3401d4f0:	b083      	sub	sp, #12
3401d4f2:	af00      	add	r7, sp, #0
3401d4f4:	6078      	str	r0, [r7, #4]
3401d4f6:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  return ISP_OK;
3401d4f8:	2300      	movs	r3, #0
}
3401d4fa:	4618      	mov	r0, r3
3401d4fc:	370c      	adds	r7, #12
3401d4fe:	46bd      	mov	sp, r7
3401d500:	f85d 7b04 	ldr.w	r7, [sp], #4
3401d504:	4770      	bx	lr
	...

3401d508 <ISP_Algo_BadPixel_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_BadPixel_Process(void *hIsp, void *pAlgo)
{
3401d508:	b580      	push	{r7, lr}
3401d50a:	b088      	sub	sp, #32
3401d50c:	af00      	add	r7, sp, #0
3401d50e:	6078      	str	r0, [r7, #4]
3401d510:	6039      	str	r1, [r7, #0]
  uint32_t CurrentFrameId;
  ISP_BadPixelTypeDef BadPixelConfig;
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401d512:	6878      	ldr	r0, [r7, #4]
3401d514:	f002 fb42 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401d518:	61f8      	str	r0, [r7, #28]

  if (IQParamConfig->badPixelAlgo.enable == false)
3401d51a:	69fb      	ldr	r3, [r7, #28]
3401d51c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
3401d520:	2b00      	cmp	r3, #0
3401d522:	d101      	bne.n	3401d528 <ISP_Algo_BadPixel_Process+0x20>
  {
    return ISP_OK;
3401d524:	2300      	movs	r3, #0
3401d526:	e069      	b.n	3401d5fc <ISP_Algo_BadPixel_Process+0xf4>
  }

  /* Wait for a new frame */
  CurrentFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
3401d528:	6878      	ldr	r0, [r7, #4]
3401d52a:	f002 fa82 	bl	3401fa32 <ISP_SVC_Misc_GetMainFrameId>
3401d52e:	61b8      	str	r0, [r7, #24]
  if (CurrentFrameId == LastFrameId)
3401d530:	4b34      	ldr	r3, [pc, #208]	@ (3401d604 <ISP_Algo_BadPixel_Process+0xfc>)
3401d532:	681b      	ldr	r3, [r3, #0]
3401d534:	69ba      	ldr	r2, [r7, #24]
3401d536:	429a      	cmp	r2, r3
3401d538:	d101      	bne.n	3401d53e <ISP_Algo_BadPixel_Process+0x36>
  {
    return ISP_OK;
3401d53a:	2300      	movs	r3, #0
3401d53c:	e05e      	b.n	3401d5fc <ISP_Algo_BadPixel_Process+0xf4>
  }
  LastFrameId = CurrentFrameId;
3401d53e:	4a31      	ldr	r2, [pc, #196]	@ (3401d604 <ISP_Algo_BadPixel_Process+0xfc>)
3401d540:	69bb      	ldr	r3, [r7, #24]
3401d542:	6013      	str	r3, [r2, #0]

  if (Step++ >= 0)
3401d544:	4b30      	ldr	r3, [pc, #192]	@ (3401d608 <ISP_Algo_BadPixel_Process+0x100>)
3401d546:	f993 3000 	ldrsb.w	r3, [r3]
3401d54a:	b2da      	uxtb	r2, r3
3401d54c:	3201      	adds	r2, #1
3401d54e:	b2d2      	uxtb	r2, r2
3401d550:	b251      	sxtb	r1, r2
3401d552:	4a2d      	ldr	r2, [pc, #180]	@ (3401d608 <ISP_Algo_BadPixel_Process+0x100>)
3401d554:	7011      	strb	r1, [r2, #0]
3401d556:	2b00      	cmp	r3, #0
3401d558:	db12      	blt.n	3401d580 <ISP_Algo_BadPixel_Process+0x78>
  {
    /* Measure the number of bad pixels */
    ret  = ISP_SVC_ISP_GetBadPixel(hIsp, &BadPixelConfig);
3401d55a:	f107 030c 	add.w	r3, r7, #12
3401d55e:	4619      	mov	r1, r3
3401d560:	6878      	ldr	r0, [r7, #4]
3401d562:	f001 ff90 	bl	3401f486 <ISP_SVC_ISP_GetBadPixel>
3401d566:	4603      	mov	r3, r0
3401d568:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
3401d56a:	7dfb      	ldrb	r3, [r7, #23]
3401d56c:	2b00      	cmp	r3, #0
3401d56e:	d001      	beq.n	3401d574 <ISP_Algo_BadPixel_Process+0x6c>
    {
      return ret;
3401d570:	7dfb      	ldrb	r3, [r7, #23]
3401d572:	e043      	b.n	3401d5fc <ISP_Algo_BadPixel_Process+0xf4>
    }
    BadPixelCount += BadPixelConfig.count;
3401d574:	693a      	ldr	r2, [r7, #16]
3401d576:	4b25      	ldr	r3, [pc, #148]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d578:	681b      	ldr	r3, [r3, #0]
3401d57a:	4413      	add	r3, r2
3401d57c:	4a23      	ldr	r2, [pc, #140]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d57e:	6013      	str	r3, [r2, #0]
  }

  if (Step == 10)
3401d580:	4b21      	ldr	r3, [pc, #132]	@ (3401d608 <ISP_Algo_BadPixel_Process+0x100>)
3401d582:	f993 3000 	ldrsb.w	r3, [r3]
3401d586:	2b0a      	cmp	r3, #10
3401d588:	d137      	bne.n	3401d5fa <ISP_Algo_BadPixel_Process+0xf2>
  {
    /* All measures done : make an average and compare with threshold */
    BadPixelCount /= 10;
3401d58a:	4b20      	ldr	r3, [pc, #128]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d58c:	681b      	ldr	r3, [r3, #0]
3401d58e:	4a20      	ldr	r2, [pc, #128]	@ (3401d610 <ISP_Algo_BadPixel_Process+0x108>)
3401d590:	fba2 2303 	umull	r2, r3, r2, r3
3401d594:	08db      	lsrs	r3, r3, #3
3401d596:	4a1d      	ldr	r2, [pc, #116]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d598:	6013      	str	r3, [r2, #0]

    if ((BadPixelCount > IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength > 0))
3401d59a:	69fb      	ldr	r3, [r7, #28]
3401d59c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
3401d59e:	4b1b      	ldr	r3, [pc, #108]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d5a0:	681b      	ldr	r3, [r3, #0]
3401d5a2:	429a      	cmp	r2, r3
3401d5a4:	d207      	bcs.n	3401d5b6 <ISP_Algo_BadPixel_Process+0xae>
3401d5a6:	7b7b      	ldrb	r3, [r7, #13]
3401d5a8:	2b00      	cmp	r3, #0
3401d5aa:	d004      	beq.n	3401d5b6 <ISP_Algo_BadPixel_Process+0xae>
    {
      /* Bad pixel is above target : decrease strength */
      BadPixelConfig.strength--;
3401d5ac:	7b7b      	ldrb	r3, [r7, #13]
3401d5ae:	3b01      	subs	r3, #1
3401d5b0:	b2db      	uxtb	r3, r3
3401d5b2:	737b      	strb	r3, [r7, #13]
3401d5b4:	e00c      	b.n	3401d5d0 <ISP_Algo_BadPixel_Process+0xc8>
    }
    else if ((BadPixelCount < IQParamConfig->badPixelAlgo.threshold) && (BadPixelConfig.strength < ISP_BADPIXEL_STRENGTH_MAX - 1))
3401d5b6:	69fb      	ldr	r3, [r7, #28]
3401d5b8:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
3401d5ba:	4b14      	ldr	r3, [pc, #80]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d5bc:	681b      	ldr	r3, [r3, #0]
3401d5be:	429a      	cmp	r2, r3
3401d5c0:	d906      	bls.n	3401d5d0 <ISP_Algo_BadPixel_Process+0xc8>
3401d5c2:	7b7b      	ldrb	r3, [r7, #13]
3401d5c4:	2b05      	cmp	r3, #5
3401d5c6:	d803      	bhi.n	3401d5d0 <ISP_Algo_BadPixel_Process+0xc8>
    {
      /* Bad pixel is below target : increase strength. (exclude ISP_BADPIXEL_STRENGTH_MAX which gives weird results) */
      BadPixelConfig.strength++;
3401d5c8:	7b7b      	ldrb	r3, [r7, #13]
3401d5ca:	3301      	adds	r3, #1
3401d5cc:	b2db      	uxtb	r3, r3
3401d5ce:	737b      	strb	r3, [r7, #13]
    }

    /* Set updated Strength */
    BadPixelConfig.enable = 1;
3401d5d0:	2301      	movs	r3, #1
3401d5d2:	733b      	strb	r3, [r7, #12]
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &BadPixelConfig);
3401d5d4:	f107 030c 	add.w	r3, r7, #12
3401d5d8:	4619      	mov	r1, r3
3401d5da:	6878      	ldr	r0, [r7, #4]
3401d5dc:	f001 ff14 	bl	3401f408 <ISP_SVC_ISP_SetBadPixel>
3401d5e0:	4603      	mov	r3, r0
3401d5e2:	75fb      	strb	r3, [r7, #23]
    if (ret != ISP_OK)
3401d5e4:	7dfb      	ldrb	r3, [r7, #23]
3401d5e6:	2b00      	cmp	r3, #0
3401d5e8:	d001      	beq.n	3401d5ee <ISP_Algo_BadPixel_Process+0xe6>
    {
      return ret;
3401d5ea:	7dfb      	ldrb	r3, [r7, #23]
3401d5ec:	e006      	b.n	3401d5fc <ISP_Algo_BadPixel_Process+0xf4>
    }

    /* Set Step to -1 to wait for an extra frame before a new measurement (the ISP HW needs one frame to update after reconfig) */
    Step = -1;
3401d5ee:	4b06      	ldr	r3, [pc, #24]	@ (3401d608 <ISP_Algo_BadPixel_Process+0x100>)
3401d5f0:	22ff      	movs	r2, #255	@ 0xff
3401d5f2:	701a      	strb	r2, [r3, #0]
    BadPixelCount = 0;
3401d5f4:	4b05      	ldr	r3, [pc, #20]	@ (3401d60c <ISP_Algo_BadPixel_Process+0x104>)
3401d5f6:	2200      	movs	r2, #0
3401d5f8:	601a      	str	r2, [r3, #0]
  }

  return ISP_OK;
3401d5fa:	2300      	movs	r3, #0
}
3401d5fc:	4618      	mov	r0, r3
3401d5fe:	3720      	adds	r7, #32
3401d600:	46bd      	mov	sp, r7
3401d602:	bd80      	pop	{r7, pc}
3401d604:	3404a498 	.word	0x3404a498
3401d608:	3404a49c 	.word	0x3404a49c
3401d60c:	3404a4a0 	.word	0x3404a4a0
3401d610:	cccccccd 	.word	0xcccccccd

3401d614 <log_cb>:

#if defined(ISP_MW_SW_AEC_ALGO_SUPPORT) || defined(ISP_MW_SW_AWB_ALGO_SUPPORT)
static void log_cb(const char *const msg)
{
3401d614:	b580      	push	{r7, lr}
3401d616:	b082      	sub	sp, #8
3401d618:	af00      	add	r7, sp, #0
3401d61a:	6078      	str	r0, [r7, #4]
  printf(msg);
3401d61c:	6878      	ldr	r0, [r7, #4]
3401d61e:	f009 fb31 	bl	34026c84 <iprintf>
  printf("\r\n");
3401d622:	4803      	ldr	r0, [pc, #12]	@ (3401d630 <log_cb+0x1c>)
3401d624:	f009 fb96 	bl	34026d54 <puts>
}
3401d628:	bf00      	nop
3401d62a:	3708      	adds	r7, #8
3401d62c:	46bd      	mov	sp, r7
3401d62e:	bd80      	pop	{r7, pc}
3401d630:	3402b490 	.word	0x3402b490

3401d634 <ISP_Algo_AEC_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Init(void *hIsp, void *pAlgo)
{
3401d634:	b580      	push	{r7, lr}
3401d636:	b086      	sub	sp, #24
3401d638:	af00      	add	r7, sp, #0
3401d63a:	6078      	str	r0, [r7, #4]
3401d63c:	6039      	str	r1, [r7, #0]
  ISP_HandleTypeDef *pIsp_handle = (ISP_HandleTypeDef*) hIsp;
3401d63e:	687b      	ldr	r3, [r7, #4]
3401d640:	617b      	str	r3, [r7, #20]
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
3401d642:	683b      	ldr	r3, [r7, #0]
3401d644:	613b      	str	r3, [r7, #16]
  ISP_IQParamTypeDef *IQParamConfig;
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401d646:	6878      	ldr	r0, [r7, #4]
3401d648:	f002 faa8 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401d64c:	60f8      	str	r0, [r7, #12]

  /* Create st_ae_process instance */
  pIspAEprocess = evision_api_st_ae_new(log_cb);
3401d64e:	4820      	ldr	r0, [pc, #128]	@ (3401d6d0 <ISP_Algo_AEC_Init+0x9c>)
3401d650:	f7e3 ff4a 	bl	340014e8 <evision_api_st_ae_new>
3401d654:	4603      	mov	r3, r0
3401d656:	4a1f      	ldr	r2, [pc, #124]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d658:	6013      	str	r3, [r2, #0]
  if (pIspAEprocess == NULL)
3401d65a:	4b1e      	ldr	r3, [pc, #120]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d65c:	681b      	ldr	r3, [r3, #0]
3401d65e:	2b00      	cmp	r3, #0
3401d660:	d101      	bne.n	3401d666 <ISP_Algo_AEC_Init+0x32>
  {
    return ISP_ERR_ALGO;
3401d662:	23be      	movs	r3, #190	@ 0xbe
3401d664:	e030      	b.n	3401d6c8 <ISP_Algo_AEC_Init+0x94>
  }

  /* Initialize st_ae_process instance */
  e_ret = evision_api_st_ae_init(pIspAEprocess);
3401d666:	4b1b      	ldr	r3, [pc, #108]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d668:	681b      	ldr	r3, [r3, #0]
3401d66a:	4618      	mov	r0, r3
3401d66c:	f7e3 ff90 	bl	34001590 <evision_api_st_ae_init>
3401d670:	4603      	mov	r3, r0
3401d672:	72fb      	strb	r3, [r7, #11]
  if (e_ret != EVISION_RET_SUCCESS)
3401d674:	f997 300b 	ldrsb.w	r3, [r7, #11]
3401d678:	2b01      	cmp	r3, #1
3401d67a:	d006      	beq.n	3401d68a <ISP_Algo_AEC_Init+0x56>
  {
    evision_api_st_ae_delete(pIspAEprocess);
3401d67c:	4b15      	ldr	r3, [pc, #84]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d67e:	681b      	ldr	r3, [r3, #0]
3401d680:	4618      	mov	r0, r3
3401d682:	f7e3 ff4b 	bl	3400151c <evision_api_st_ae_delete>
    return ISP_ERR_ALGO;
3401d686:	23be      	movs	r3, #190	@ 0xbe
3401d688:	e01e      	b.n	3401d6c8 <ISP_Algo_AEC_Init+0x94>
  }

  /* Configure algo (AEC target) */
  pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3401d68a:	4b12      	ldr	r3, [pc, #72]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d68c:	681b      	ldr	r3, [r3, #0]
3401d68e:	68fa      	ldr	r2, [r7, #12]
3401d690:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
3401d692:	611a      	str	r2, [r3, #16]

  /* Configure algo (sensor config) */
  pIspAEprocess->hyper_params.exposure_min = pIsp_handle->sensorInfo.exposure_min;
3401d694:	4b0f      	ldr	r3, [pc, #60]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d696:	681b      	ldr	r3, [r3, #0]
3401d698:	697a      	ldr	r2, [r7, #20]
3401d69a:	f8d2 2080 	ldr.w	r2, [r2, #128]	@ 0x80
3401d69e:	641a      	str	r2, [r3, #64]	@ 0x40
  pIspAEprocess->hyper_params.exposure_max = pIsp_handle->sensorInfo.exposure_max;
3401d6a0:	4b0c      	ldr	r3, [pc, #48]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d6a2:	681b      	ldr	r3, [r3, #0]
3401d6a4:	697a      	ldr	r2, [r7, #20]
3401d6a6:	f8d2 2084 	ldr.w	r2, [r2, #132]	@ 0x84
3401d6aa:	645a      	str	r2, [r3, #68]	@ 0x44
  pIspAEprocess->hyper_params.gain_min = pIsp_handle->sensorInfo.gain_min;
3401d6ac:	4b09      	ldr	r3, [pc, #36]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d6ae:	681b      	ldr	r3, [r3, #0]
3401d6b0:	697a      	ldr	r2, [r7, #20]
3401d6b2:	6f92      	ldr	r2, [r2, #120]	@ 0x78
3401d6b4:	649a      	str	r2, [r3, #72]	@ 0x48
  pIspAEprocess->hyper_params.gain_max = pIsp_handle->sensorInfo.gain_max;
3401d6b6:	4b07      	ldr	r3, [pc, #28]	@ (3401d6d4 <ISP_Algo_AEC_Init+0xa0>)
3401d6b8:	681b      	ldr	r3, [r3, #0]
3401d6ba:	697a      	ldr	r2, [r7, #20]
3401d6bc:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
3401d6be:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Update State */
  algo->state = ISP_ALGO_STATE_INIT;
3401d6c0:	693b      	ldr	r3, [r7, #16]
3401d6c2:	2200      	movs	r2, #0
3401d6c4:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
3401d6c6:	2300      	movs	r3, #0
}
3401d6c8:	4618      	mov	r0, r3
3401d6ca:	3718      	adds	r7, #24
3401d6cc:	46bd      	mov	sp, r7
3401d6ce:	bd80      	pop	{r7, pc}
3401d6d0:	3401d615 	.word	0x3401d615
3401d6d4:	3404a48c 	.word	0x3404a48c

3401d6d8 <ISP_Algo_AEC_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_DeInit(void *hIsp, void *pAlgo)
{
3401d6d8:	b580      	push	{r7, lr}
3401d6da:	b082      	sub	sp, #8
3401d6dc:	af00      	add	r7, sp, #0
3401d6de:	6078      	str	r0, [r7, #4]
3401d6e0:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAEprocess != NULL)
3401d6e2:	4b07      	ldr	r3, [pc, #28]	@ (3401d700 <ISP_Algo_AEC_DeInit+0x28>)
3401d6e4:	681b      	ldr	r3, [r3, #0]
3401d6e6:	2b00      	cmp	r3, #0
3401d6e8:	d004      	beq.n	3401d6f4 <ISP_Algo_AEC_DeInit+0x1c>
  {
    evision_api_st_ae_delete(pIspAEprocess);
3401d6ea:	4b05      	ldr	r3, [pc, #20]	@ (3401d700 <ISP_Algo_AEC_DeInit+0x28>)
3401d6ec:	681b      	ldr	r3, [r3, #0]
3401d6ee:	4618      	mov	r0, r3
3401d6f0:	f7e3 ff14 	bl	3400151c <evision_api_st_ae_delete>
  }
  return ISP_OK;
3401d6f4:	2300      	movs	r3, #0
}
3401d6f6:	4618      	mov	r0, r3
3401d6f8:	3708      	adds	r7, #8
3401d6fa:	46bd      	mov	sp, r7
3401d6fc:	bd80      	pop	{r7, pc}
3401d6fe:	bf00      	nop
3401d700:	3404a48c 	.word	0x3404a48c

3401d704 <ISP_Algo_AEC_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_StatCb(ISP_AlgoTypeDef *pAlgo)
{
3401d704:	b480      	push	{r7}
3401d706:	b083      	sub	sp, #12
3401d708:	af00      	add	r7, sp, #0
3401d70a:	6078      	str	r0, [r7, #4]
  /* Update State */
  pAlgo->state = ISP_ALGO_STATE_STAT_READY;
3401d70c:	687b      	ldr	r3, [r7, #4]
3401d70e:	2203      	movs	r2, #3
3401d710:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
3401d712:	2300      	movs	r3, #0
}
3401d714:	4618      	mov	r0, r3
3401d716:	370c      	adds	r7, #12
3401d718:	46bd      	mov	sp, r7
3401d71a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401d71e:	4770      	bx	lr

3401d720 <ISP_Algo_AEC_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AEC_Process(void *hIsp, void *pAlgo)
{
3401d720:	b580      	push	{r7, lr}
3401d722:	b08e      	sub	sp, #56	@ 0x38
3401d724:	af04      	add	r7, sp, #16
3401d726:	6078      	str	r0, [r7, #4]
3401d728:	6039      	str	r1, [r7, #0]
  static ISP_SVC_StatStateTypeDef stats;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
3401d72a:	683b      	ldr	r3, [r7, #0]
3401d72c:	623b      	str	r3, [r7, #32]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret = ISP_OK;
3401d72e:	2300      	movs	r3, #0
3401d730:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
#ifdef ALGO_AEC_DBG_LOGS
  static uint32_t currentL;
#endif
  evision_return_t e_ret;

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401d734:	6878      	ldr	r0, [r7, #4]
3401d736:	f002 fa31 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401d73a:	61f8      	str	r0, [r7, #28]
  if (IQParamConfig->AECAlgo.enable == false)
3401d73c:	69fb      	ldr	r3, [r7, #28]
3401d73e:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
3401d742:	2b00      	cmp	r3, #0
3401d744:	d101      	bne.n	3401d74a <ISP_Algo_AEC_Process+0x2a>
  {
    return ISP_OK;
3401d746:	2300      	movs	r3, #0
3401d748:	e0a7      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
  }

  switch(algo->state)
3401d74a:	6a3b      	ldr	r3, [r7, #32]
3401d74c:	785b      	ldrb	r3, [r3, #1]
3401d74e:	2b03      	cmp	r3, #3
3401d750:	d023      	beq.n	3401d79a <ISP_Algo_AEC_Process+0x7a>
3401d752:	2b03      	cmp	r3, #3
3401d754:	f300 809f 	bgt.w	3401d896 <ISP_Algo_AEC_Process+0x176>
3401d758:	2b01      	cmp	r3, #1
3401d75a:	dc02      	bgt.n	3401d762 <ISP_Algo_AEC_Process+0x42>
3401d75c:	2b00      	cmp	r3, #0
3401d75e:	da02      	bge.n	3401d766 <ISP_Algo_AEC_Process+0x46>
3401d760:	e099      	b.n	3401d896 <ISP_Algo_AEC_Process+0x176>
3401d762:	2b02      	cmp	r3, #2
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
    break;

  case ISP_ALGO_STATE_WAITING_STAT:
    /* Do nothing */
    break;
3401d764:	e097      	b.n	3401d896 <ISP_Algo_AEC_Process+0x176>
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN, ISP_STAT_TYPE_AVG, ALGO_SENSOR_LATENCY);
3401d766:	2304      	movs	r3, #4
3401d768:	9302      	str	r3, [sp, #8]
3401d76a:	2301      	movs	r3, #1
3401d76c:	9301      	str	r3, [sp, #4]
3401d76e:	2302      	movs	r3, #2
3401d770:	9300      	str	r3, [sp, #0]
3401d772:	4b4c      	ldr	r3, [pc, #304]	@ (3401d8a4 <ISP_Algo_AEC_Process+0x184>)
3401d774:	683a      	ldr	r2, [r7, #0]
3401d776:	494c      	ldr	r1, [pc, #304]	@ (3401d8a8 <ISP_Algo_AEC_Process+0x188>)
3401d778:	6878      	ldr	r0, [r7, #4]
3401d77a:	f002 fd5f 	bl	3402023c <ISP_SVC_Stats_GetNext>
3401d77e:	4603      	mov	r3, r0
3401d780:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
3401d784:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d788:	2b00      	cmp	r3, #0
3401d78a:	d002      	beq.n	3401d792 <ISP_Algo_AEC_Process+0x72>
      return ret;
3401d78c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d790:	e083      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401d792:	6a3b      	ldr	r3, [r7, #32]
3401d794:	2202      	movs	r2, #2
3401d796:	705a      	strb	r2, [r3, #1]
    break;
3401d798:	e07d      	b.n	3401d896 <ISP_Algo_AEC_Process+0x176>

  case ISP_ALGO_STATE_STAT_READY:
    /* Align on the target update (may have been updated with ISP_SetExposureTarget()) */
    pIspAEprocess->hyper_params.target = IQParamConfig->AECAlgo.exposureTarget;
3401d79a:	4b44      	ldr	r3, [pc, #272]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d79c:	681b      	ldr	r3, [r3, #0]
3401d79e:	69fa      	ldr	r2, [r7, #28]
3401d7a0:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
3401d7a2:	611a      	str	r2, [r3, #16]
    avgL = stats.down.averageL;
3401d7a4:	4b3f      	ldr	r3, [pc, #252]	@ (3401d8a4 <ISP_Algo_AEC_Process+0x184>)
3401d7a6:	f893 3037 	ldrb.w	r3, [r3, #55]	@ 0x37
3401d7aa:	61bb      	str	r3, [r7, #24]
      printf("L = %ld\r\n", avgL);
      currentL = avgL;
    }
#endif
    /* Read the current sensor gain */
    ret = ISP_SVC_Sensor_GetGain(hIsp, &gainConfig);
3401d7ac:	f107 0310 	add.w	r3, r7, #16
3401d7b0:	4619      	mov	r1, r3
3401d7b2:	6878      	ldr	r0, [r7, #4]
3401d7b4:	f002 f8af 	bl	3401f916 <ISP_SVC_Sensor_GetGain>
3401d7b8:	4603      	mov	r3, r0
3401d7ba:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
3401d7be:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d7c2:	2b00      	cmp	r3, #0
3401d7c4:	d002      	beq.n	3401d7cc <ISP_Algo_AEC_Process+0xac>
    {
      return ret;
3401d7c6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d7ca:	e066      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
    }

    ret = ISP_SVC_Sensor_GetExposure(hIsp, &exposureConfig);
3401d7cc:	f107 030c 	add.w	r3, r7, #12
3401d7d0:	4619      	mov	r1, r3
3401d7d2:	6878      	ldr	r0, [r7, #4]
3401d7d4:	f002 f8e4 	bl	3401f9a0 <ISP_SVC_Sensor_GetExposure>
3401d7d8:	4603      	mov	r3, r0
3401d7da:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if (ret != ISP_OK)
3401d7de:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d7e2:	2b00      	cmp	r3, #0
3401d7e4:	d002      	beq.n	3401d7ec <ISP_Algo_AEC_Process+0xcc>
    {
      return ret;
3401d7e6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d7ea:	e056      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
    }

    /* Run algo to calculate new gain and exposure */
    e_ret = evision_api_st_ae_process(pIspAEprocess, gainConfig.gain, exposureConfig.exposure, avgL);
3401d7ec:	4b2f      	ldr	r3, [pc, #188]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d7ee:	6818      	ldr	r0, [r3, #0]
3401d7f0:	6939      	ldr	r1, [r7, #16]
3401d7f2:	68fa      	ldr	r2, [r7, #12]
3401d7f4:	69bb      	ldr	r3, [r7, #24]
3401d7f6:	b2db      	uxtb	r3, r3
3401d7f8:	f7e3 fed5 	bl	340015a6 <evision_api_st_ae_process>
3401d7fc:	4603      	mov	r3, r0
3401d7fe:	75fb      	strb	r3, [r7, #23]
    if (e_ret == EVISION_RET_SUCCESS)
3401d800:	f997 3017 	ldrsb.w	r3, [r7, #23]
3401d804:	2b01      	cmp	r3, #1
3401d806:	d133      	bne.n	3401d870 <ISP_Algo_AEC_Process+0x150>
    {
      if (gainConfig.gain != pIspAEprocess->new_gain)
3401d808:	693a      	ldr	r2, [r7, #16]
3401d80a:	4b28      	ldr	r3, [pc, #160]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d80c:	681b      	ldr	r3, [r3, #0]
3401d80e:	689b      	ldr	r3, [r3, #8]
3401d810:	429a      	cmp	r2, r3
3401d812:	d013      	beq.n	3401d83c <ISP_Algo_AEC_Process+0x11c>
      {
        /* Set new gain */
        gainConfig.gain = pIspAEprocess->new_gain;
3401d814:	4b25      	ldr	r3, [pc, #148]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d816:	681b      	ldr	r3, [r3, #0]
3401d818:	689b      	ldr	r3, [r3, #8]
3401d81a:	613b      	str	r3, [r7, #16]

        ret = ISP_SVC_Sensor_SetGain(hIsp, &gainConfig);
3401d81c:	f107 0310 	add.w	r3, r7, #16
3401d820:	4619      	mov	r1, r3
3401d822:	6878      	ldr	r0, [r7, #4]
3401d824:	f002 f854 	bl	3401f8d0 <ISP_SVC_Sensor_SetGain>
3401d828:	4603      	mov	r3, r0
3401d82a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
3401d82e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d832:	2b00      	cmp	r3, #0
3401d834:	d002      	beq.n	3401d83c <ISP_Algo_AEC_Process+0x11c>
        {
          return ret;
3401d836:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d83a:	e02e      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
#ifdef ALGO_AEC_DBG_LOGS
        printf("New gain = %ld\r\n", gainConfig.gain);
#endif
      }

      if (exposureConfig.exposure != pIspAEprocess->new_exposure)
3401d83c:	68fa      	ldr	r2, [r7, #12]
3401d83e:	4b1b      	ldr	r3, [pc, #108]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d840:	681b      	ldr	r3, [r3, #0]
3401d842:	685b      	ldr	r3, [r3, #4]
3401d844:	429a      	cmp	r2, r3
3401d846:	d013      	beq.n	3401d870 <ISP_Algo_AEC_Process+0x150>
      {
        /* Set new exposure */
        exposureConfig.exposure = pIspAEprocess->new_exposure;
3401d848:	4b18      	ldr	r3, [pc, #96]	@ (3401d8ac <ISP_Algo_AEC_Process+0x18c>)
3401d84a:	681b      	ldr	r3, [r3, #0]
3401d84c:	685b      	ldr	r3, [r3, #4]
3401d84e:	60fb      	str	r3, [r7, #12]

        ret = ISP_SVC_Sensor_SetExposure(hIsp, &exposureConfig);
3401d850:	f107 030c 	add.w	r3, r7, #12
3401d854:	4619      	mov	r1, r3
3401d856:	6878      	ldr	r0, [r7, #4]
3401d858:	f002 f87f 	bl	3401f95a <ISP_SVC_Sensor_SetExposure>
3401d85c:	4603      	mov	r3, r0
3401d85e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (ret != ISP_OK)
3401d862:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d866:	2b00      	cmp	r3, #0
3401d868:	d002      	beq.n	3401d870 <ISP_Algo_AEC_Process+0x150>
        {
          return ret;
3401d86a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3401d86e:	e014      	b.n	3401d89a <ISP_Algo_AEC_Process+0x17a>
#endif
      }
    }

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AEC_StatCb, pAlgo, &stats,
3401d870:	2304      	movs	r3, #4
3401d872:	9302      	str	r3, [sp, #8]
3401d874:	2301      	movs	r3, #1
3401d876:	9301      	str	r3, [sp, #4]
3401d878:	2302      	movs	r3, #2
3401d87a:	9300      	str	r3, [sp, #0]
3401d87c:	4b09      	ldr	r3, [pc, #36]	@ (3401d8a4 <ISP_Algo_AEC_Process+0x184>)
3401d87e:	683a      	ldr	r2, [r7, #0]
3401d880:	4909      	ldr	r1, [pc, #36]	@ (3401d8a8 <ISP_Algo_AEC_Process+0x188>)
3401d882:	6878      	ldr	r0, [r7, #4]
3401d884:	f002 fcda 	bl	3402023c <ISP_SVC_Stats_GetNext>
3401d888:	4603      	mov	r3, r0
3401d88a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
                                ISP_STAT_LOC_DOWN, ISP_STAT_TYPE_AVG, ALGO_SENSOR_LATENCY);

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401d88e:	6a3b      	ldr	r3, [r7, #32]
3401d890:	2202      	movs	r2, #2
3401d892:	705a      	strb	r2, [r3, #1]
    break;
3401d894:	bf00      	nop
  }

  return ret;
3401d896:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
3401d89a:	4618      	mov	r0, r3
3401d89c:	3728      	adds	r7, #40	@ 0x28
3401d89e:	46bd      	mov	sp, r7
3401d8a0:	bd80      	pop	{r7, pc}
3401d8a2:	bf00      	nop
3401d8a4:	3404a4a4 	.word	0x3404a4a4
3401d8a8:	3401d705 	.word	0x3401d705
3401d8ac:	3404a48c 	.word	0x3404a48c

3401d8b0 <ISP_Algo_ApplyGammaInverse>:
  * @param  hIsp:  ISP device handle.
  * @param  comp: component value
  * @retval gamma corrected value
  */
double ISP_Algo_ApplyGammaInverse(ISP_HandleTypeDef *hIsp, uint32_t comp)
{
3401d8b0:	b580      	push	{r7, lr}
3401d8b2:	b084      	sub	sp, #16
3401d8b4:	af00      	add	r7, sp, #0
3401d8b6:	6078      	str	r0, [r7, #4]
3401d8b8:	6039      	str	r1, [r7, #0]
  double out;

  /* Check if gamma is enabled */
  if (ISP_SVC_Misc_IsGammaEnabled(hIsp, 1 /*main pipe*/) != 0) {
3401d8ba:	2101      	movs	r1, #1
3401d8bc:	6878      	ldr	r0, [r7, #4]
3401d8be:	f002 f8e2 	bl	3401fa86 <ISP_SVC_Misc_IsGammaEnabled>
3401d8c2:	4603      	mov	r3, r0
3401d8c4:	2b00      	cmp	r3, #0
3401d8c6:	d019      	beq.n	3401d8fc <ISP_Algo_ApplyGammaInverse+0x4c>
    out = 255 * pow((float)comp / 255, 1.0 / 2.2);
3401d8c8:	683b      	ldr	r3, [r7, #0]
3401d8ca:	ee07 3a90 	vmov	s15, r3
3401d8ce:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401d8d2:	eddf 6a17 	vldr	s13, [pc, #92]	@ 3401d930 <ISP_Algo_ApplyGammaInverse+0x80>
3401d8d6:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401d8da:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3401d8de:	ed9f 1b10 	vldr	d1, [pc, #64]	@ 3401d920 <ISP_Algo_ApplyGammaInverse+0x70>
3401d8e2:	eeb0 0b47 	vmov.f64	d0, d7
3401d8e6:	f00b fefb 	bl	340296e0 <pow>
3401d8ea:	eeb0 7b40 	vmov.f64	d7, d0
3401d8ee:	ed9f 6b0e 	vldr	d6, [pc, #56]	@ 3401d928 <ISP_Algo_ApplyGammaInverse+0x78>
3401d8f2:	ee27 7b06 	vmul.f64	d7, d7, d6
3401d8f6:	ed87 7b02 	vstr	d7, [r7, #8]
3401d8fa:	e006      	b.n	3401d90a <ISP_Algo_ApplyGammaInverse+0x5a>
  }
  else
  {
    out = (double) comp;
3401d8fc:	683b      	ldr	r3, [r7, #0]
3401d8fe:	ee07 3a90 	vmov	s15, r3
3401d902:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401d906:	ed87 7b02 	vstr	d7, [r7, #8]
  }
  return out;
3401d90a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
3401d90e:	ec43 2b17 	vmov	d7, r2, r3
}
3401d912:	eeb0 0b47 	vmov.f64	d0, d7
3401d916:	3710      	adds	r7, #16
3401d918:	46bd      	mov	sp, r7
3401d91a:	bd80      	pop	{r7, pc}
3401d91c:	f3af 8000 	nop.w
3401d920:	d1745d17 	.word	0xd1745d17
3401d924:	3fdd1745 	.word	0x3fdd1745
3401d928:	00000000 	.word	0x00000000
3401d92c:	406fe000 	.word	0x406fe000
3401d930:	437f0000 	.word	0x437f0000
3401d934:	00000000 	.word	0x00000000

3401d938 <ISP_Algo_ApplyCConv>:
  * @param  outG: pointer to Green component value after color conversion
  * @param  outB: pointer to Blue component value after color conversion
  * @retval None
  */
void ISP_Algo_ApplyCConv(ISP_HandleTypeDef *hIsp, uint32_t inR, uint32_t inG, uint32_t inB, uint32_t *outR, uint32_t *outG, uint32_t *outB)
{
3401d938:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3401d93c:	b0d0      	sub	sp, #320	@ 0x140
3401d93e:	af00      	add	r7, sp, #0
3401d940:	f8c7 00fc 	str.w	r0, [r7, #252]	@ 0xfc
3401d944:	f8c7 10f8 	str.w	r1, [r7, #248]	@ 0xf8
3401d948:	f8c7 20f4 	str.w	r2, [r7, #244]	@ 0xf4
3401d94c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
  ISP_ColorConvTypeDef colorConv;
  int64_t ccR, ccG, ccB;

  if ((ISP_SVC_ISP_GetColorConv(hIsp, &colorConv) == ISP_OK) && (colorConv.enable == 1))
3401d950:	f507 7380 	add.w	r3, r7, #256	@ 0x100
3401d954:	4619      	mov	r1, r3
3401d956:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
3401d95a:	f001 ff2b 	bl	3401f7b4 <ISP_SVC_ISP_GetColorConv>
3401d95e:	4603      	mov	r3, r0
3401d960:	2b00      	cmp	r3, #0
3401d962:	f040 8216 	bne.w	3401dd92 <ISP_Algo_ApplyCConv+0x45a>
3401d966:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
3401d96a:	2b01      	cmp	r3, #1
3401d96c:	f040 8211 	bne.w	3401dd92 <ISP_Algo_ApplyCConv+0x45a>
  {
    /* Apply ColorConversion matrix to the input components */
    ccR = (int64_t) inR * colorConv.coeff[0][0] + (int64_t) inG * colorConv.coeff[0][1] + (int64_t) inB * colorConv.coeff[0][2];
3401d970:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
3401d974:	2200      	movs	r2, #0
3401d976:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
3401d97a:	f8c7 20ac 	str.w	r2, [r7, #172]	@ 0xac
3401d97e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
3401d982:	17da      	asrs	r2, r3, #31
3401d984:	461c      	mov	r4, r3
3401d986:	4615      	mov	r5, r2
3401d988:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
3401d98c:	460b      	mov	r3, r1
3401d98e:	fb04 f203 	mul.w	r2, r4, r3
3401d992:	4603      	mov	r3, r0
3401d994:	fb03 f305 	mul.w	r3, r3, r5
3401d998:	4413      	add	r3, r2
3401d99a:	4602      	mov	r2, r0
3401d99c:	fba2 ab04 	umull	sl, fp, r2, r4
3401d9a0:	445b      	add	r3, fp
3401d9a2:	469b      	mov	fp, r3
3401d9a4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
3401d9a8:	2200      	movs	r2, #0
3401d9aa:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
3401d9ae:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
3401d9b2:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
3401d9b6:	17da      	asrs	r2, r3, #31
3401d9b8:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
3401d9bc:	f8c7 20ec 	str.w	r2, [r7, #236]	@ 0xec
3401d9c0:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
3401d9c4:	460b      	mov	r3, r1
3401d9c6:	e9d7 453a 	ldrd	r4, r5, [r7, #232]	@ 0xe8
3401d9ca:	4622      	mov	r2, r4
3401d9cc:	fb02 f203 	mul.w	r2, r2, r3
3401d9d0:	e9c7 453a 	strd	r4, r5, [r7, #232]	@ 0xe8
3401d9d4:	462b      	mov	r3, r5
3401d9d6:	4604      	mov	r4, r0
3401d9d8:	460d      	mov	r5, r1
3401d9da:	4621      	mov	r1, r4
3401d9dc:	fb01 f303 	mul.w	r3, r1, r3
3401d9e0:	4413      	add	r3, r2
3401d9e2:	4622      	mov	r2, r4
3401d9e4:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
3401d9e8:	fba2 8901 	umull	r8, r9, r2, r1
3401d9ec:	444b      	add	r3, r9
3401d9ee:	4699      	mov	r9, r3
3401d9f0:	eb1a 0308 	adds.w	r3, sl, r8
3401d9f4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
3401d9f8:	eb4b 0309 	adc.w	r3, fp, r9
3401d9fc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
3401da00:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
3401da04:	2200      	movs	r2, #0
3401da06:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
3401da0a:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
3401da0e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
3401da12:	17da      	asrs	r2, r3, #31
3401da14:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
3401da18:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
3401da1c:	e9d7 4524 	ldrd	r4, r5, [r7, #144]	@ 0x90
3401da20:	462b      	mov	r3, r5
3401da22:	e9d7 8922 	ldrd	r8, r9, [r7, #136]	@ 0x88
3401da26:	4642      	mov	r2, r8
3401da28:	fb02 f203 	mul.w	r2, r2, r3
3401da2c:	464b      	mov	r3, r9
3401da2e:	4621      	mov	r1, r4
3401da30:	fb01 f303 	mul.w	r3, r1, r3
3401da34:	4413      	add	r3, r2
3401da36:	4622      	mov	r2, r4
3401da38:	4641      	mov	r1, r8
3401da3a:	fba2 1201 	umull	r1, r2, r2, r1
3401da3e:	f8c7 20e4 	str.w	r2, [r7, #228]	@ 0xe4
3401da42:	460a      	mov	r2, r1
3401da44:	f8c7 20e0 	str.w	r2, [r7, #224]	@ 0xe0
3401da48:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
3401da4c:	4413      	add	r3, r2
3401da4e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3401da52:	e9d7 4526 	ldrd	r4, r5, [r7, #152]	@ 0x98
3401da56:	4623      	mov	r3, r4
3401da58:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3401da5c:	4602      	mov	r2, r0
3401da5e:	189b      	adds	r3, r3, r2
3401da60:	613b      	str	r3, [r7, #16]
3401da62:	460b      	mov	r3, r1
3401da64:	462a      	mov	r2, r5
3401da66:	eb42 0303 	adc.w	r3, r2, r3
3401da6a:	617b      	str	r3, [r7, #20]
3401da6c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
3401da70:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (int64_t) inR * colorConv.coeff[1][0] + (int64_t) inG * colorConv.coeff[1][1] + (int64_t) inB * colorConv.coeff[1][2];
3401da74:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
3401da78:	2200      	movs	r2, #0
3401da7a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
3401da7e:	f8c7 2084 	str.w	r2, [r7, #132]	@ 0x84
3401da82:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
3401da86:	17da      	asrs	r2, r3, #31
3401da88:	67bb      	str	r3, [r7, #120]	@ 0x78
3401da8a:	67fa      	str	r2, [r7, #124]	@ 0x7c
3401da8c:	e9d7 4520 	ldrd	r4, r5, [r7, #128]	@ 0x80
3401da90:	462b      	mov	r3, r5
3401da92:	e9d7 891e 	ldrd	r8, r9, [r7, #120]	@ 0x78
3401da96:	4642      	mov	r2, r8
3401da98:	fb02 f203 	mul.w	r2, r2, r3
3401da9c:	464b      	mov	r3, r9
3401da9e:	4621      	mov	r1, r4
3401daa0:	fb01 f303 	mul.w	r3, r1, r3
3401daa4:	4413      	add	r3, r2
3401daa6:	4622      	mov	r2, r4
3401daa8:	4641      	mov	r1, r8
3401daaa:	fba2 1201 	umull	r1, r2, r2, r1
3401daae:	f8c7 20dc 	str.w	r2, [r7, #220]	@ 0xdc
3401dab2:	460a      	mov	r2, r1
3401dab4:	f8c7 20d8 	str.w	r2, [r7, #216]	@ 0xd8
3401dab8:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
3401dabc:	4413      	add	r3, r2
3401dabe:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
3401dac2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
3401dac6:	2200      	movs	r2, #0
3401dac8:	673b      	str	r3, [r7, #112]	@ 0x70
3401daca:	677a      	str	r2, [r7, #116]	@ 0x74
3401dacc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
3401dad0:	17da      	asrs	r2, r3, #31
3401dad2:	66bb      	str	r3, [r7, #104]	@ 0x68
3401dad4:	66fa      	str	r2, [r7, #108]	@ 0x6c
3401dad6:	e9d7 451c 	ldrd	r4, r5, [r7, #112]	@ 0x70
3401dada:	462b      	mov	r3, r5
3401dadc:	e9d7 891a 	ldrd	r8, r9, [r7, #104]	@ 0x68
3401dae0:	4642      	mov	r2, r8
3401dae2:	fb02 f203 	mul.w	r2, r2, r3
3401dae6:	464b      	mov	r3, r9
3401dae8:	4621      	mov	r1, r4
3401daea:	fb01 f303 	mul.w	r3, r1, r3
3401daee:	4413      	add	r3, r2
3401daf0:	4622      	mov	r2, r4
3401daf2:	4641      	mov	r1, r8
3401daf4:	fba2 1201 	umull	r1, r2, r2, r1
3401daf8:	f8c7 20d4 	str.w	r2, [r7, #212]	@ 0xd4
3401dafc:	460a      	mov	r2, r1
3401dafe:	f8c7 20d0 	str.w	r2, [r7, #208]	@ 0xd0
3401db02:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
3401db06:	4413      	add	r3, r2
3401db08:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
3401db0c:	e9d7 4536 	ldrd	r4, r5, [r7, #216]	@ 0xd8
3401db10:	4623      	mov	r3, r4
3401db12:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
3401db16:	4602      	mov	r2, r0
3401db18:	189b      	adds	r3, r3, r2
3401db1a:	663b      	str	r3, [r7, #96]	@ 0x60
3401db1c:	460b      	mov	r3, r1
3401db1e:	462a      	mov	r2, r5
3401db20:	eb42 0303 	adc.w	r3, r2, r3
3401db24:	667b      	str	r3, [r7, #100]	@ 0x64
3401db26:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
3401db2a:	2200      	movs	r2, #0
3401db2c:	65bb      	str	r3, [r7, #88]	@ 0x58
3401db2e:	65fa      	str	r2, [r7, #92]	@ 0x5c
3401db30:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
3401db34:	17da      	asrs	r2, r3, #31
3401db36:	653b      	str	r3, [r7, #80]	@ 0x50
3401db38:	657a      	str	r2, [r7, #84]	@ 0x54
3401db3a:	e9d7 4516 	ldrd	r4, r5, [r7, #88]	@ 0x58
3401db3e:	462b      	mov	r3, r5
3401db40:	e9d7 8914 	ldrd	r8, r9, [r7, #80]	@ 0x50
3401db44:	4642      	mov	r2, r8
3401db46:	fb02 f203 	mul.w	r2, r2, r3
3401db4a:	464b      	mov	r3, r9
3401db4c:	4621      	mov	r1, r4
3401db4e:	fb01 f303 	mul.w	r3, r1, r3
3401db52:	4413      	add	r3, r2
3401db54:	4622      	mov	r2, r4
3401db56:	4641      	mov	r1, r8
3401db58:	fba2 1201 	umull	r1, r2, r2, r1
3401db5c:	f8c7 20cc 	str.w	r2, [r7, #204]	@ 0xcc
3401db60:	460a      	mov	r2, r1
3401db62:	f8c7 20c8 	str.w	r2, [r7, #200]	@ 0xc8
3401db66:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
3401db6a:	4413      	add	r3, r2
3401db6c:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
3401db70:	e9d7 4518 	ldrd	r4, r5, [r7, #96]	@ 0x60
3401db74:	4623      	mov	r3, r4
3401db76:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
3401db7a:	4602      	mov	r2, r0
3401db7c:	189b      	adds	r3, r3, r2
3401db7e:	60bb      	str	r3, [r7, #8]
3401db80:	460b      	mov	r3, r1
3401db82:	462a      	mov	r2, r5
3401db84:	eb42 0303 	adc.w	r3, r2, r3
3401db88:	60fb      	str	r3, [r7, #12]
3401db8a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
3401db8e:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (int64_t) inR * colorConv.coeff[2][0] + (int64_t) inG * colorConv.coeff[2][1] + (int64_t) inB * colorConv.coeff[2][2];
3401db92:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
3401db96:	2200      	movs	r2, #0
3401db98:	64bb      	str	r3, [r7, #72]	@ 0x48
3401db9a:	64fa      	str	r2, [r7, #76]	@ 0x4c
3401db9c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
3401dba0:	17da      	asrs	r2, r3, #31
3401dba2:	643b      	str	r3, [r7, #64]	@ 0x40
3401dba4:	647a      	str	r2, [r7, #68]	@ 0x44
3401dba6:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	@ 0x48
3401dbaa:	462b      	mov	r3, r5
3401dbac:	e9d7 8910 	ldrd	r8, r9, [r7, #64]	@ 0x40
3401dbb0:	4642      	mov	r2, r8
3401dbb2:	fb02 f203 	mul.w	r2, r2, r3
3401dbb6:	464b      	mov	r3, r9
3401dbb8:	4621      	mov	r1, r4
3401dbba:	fb01 f303 	mul.w	r3, r1, r3
3401dbbe:	4413      	add	r3, r2
3401dbc0:	4622      	mov	r2, r4
3401dbc2:	4641      	mov	r1, r8
3401dbc4:	fba2 1201 	umull	r1, r2, r2, r1
3401dbc8:	f8c7 20c4 	str.w	r2, [r7, #196]	@ 0xc4
3401dbcc:	460a      	mov	r2, r1
3401dbce:	f8c7 20c0 	str.w	r2, [r7, #192]	@ 0xc0
3401dbd2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
3401dbd6:	4413      	add	r3, r2
3401dbd8:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
3401dbdc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
3401dbe0:	2200      	movs	r2, #0
3401dbe2:	63bb      	str	r3, [r7, #56]	@ 0x38
3401dbe4:	63fa      	str	r2, [r7, #60]	@ 0x3c
3401dbe6:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
3401dbea:	17da      	asrs	r2, r3, #31
3401dbec:	633b      	str	r3, [r7, #48]	@ 0x30
3401dbee:	637a      	str	r2, [r7, #52]	@ 0x34
3401dbf0:	e9d7 450e 	ldrd	r4, r5, [r7, #56]	@ 0x38
3401dbf4:	462b      	mov	r3, r5
3401dbf6:	e9d7 890c 	ldrd	r8, r9, [r7, #48]	@ 0x30
3401dbfa:	4642      	mov	r2, r8
3401dbfc:	fb02 f203 	mul.w	r2, r2, r3
3401dc00:	464b      	mov	r3, r9
3401dc02:	4621      	mov	r1, r4
3401dc04:	fb01 f303 	mul.w	r3, r1, r3
3401dc08:	4413      	add	r3, r2
3401dc0a:	4622      	mov	r2, r4
3401dc0c:	4641      	mov	r1, r8
3401dc0e:	fba2 1201 	umull	r1, r2, r2, r1
3401dc12:	f8c7 20bc 	str.w	r2, [r7, #188]	@ 0xbc
3401dc16:	460a      	mov	r2, r1
3401dc18:	f8c7 20b8 	str.w	r2, [r7, #184]	@ 0xb8
3401dc1c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
3401dc20:	4413      	add	r3, r2
3401dc22:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3401dc26:	e9d7 4530 	ldrd	r4, r5, [r7, #192]	@ 0xc0
3401dc2a:	4623      	mov	r3, r4
3401dc2c:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
3401dc30:	4602      	mov	r2, r0
3401dc32:	189b      	adds	r3, r3, r2
3401dc34:	62bb      	str	r3, [r7, #40]	@ 0x28
3401dc36:	460b      	mov	r3, r1
3401dc38:	462a      	mov	r2, r5
3401dc3a:	eb42 0303 	adc.w	r3, r2, r3
3401dc3e:	62fb      	str	r3, [r7, #44]	@ 0x2c
3401dc40:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
3401dc44:	2200      	movs	r2, #0
3401dc46:	623b      	str	r3, [r7, #32]
3401dc48:	627a      	str	r2, [r7, #36]	@ 0x24
3401dc4a:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
3401dc4e:	17da      	asrs	r2, r3, #31
3401dc50:	61bb      	str	r3, [r7, #24]
3401dc52:	61fa      	str	r2, [r7, #28]
3401dc54:	e9d7 4508 	ldrd	r4, r5, [r7, #32]
3401dc58:	462b      	mov	r3, r5
3401dc5a:	e9d7 8906 	ldrd	r8, r9, [r7, #24]
3401dc5e:	4642      	mov	r2, r8
3401dc60:	fb02 f203 	mul.w	r2, r2, r3
3401dc64:	464b      	mov	r3, r9
3401dc66:	4621      	mov	r1, r4
3401dc68:	fb01 f303 	mul.w	r3, r1, r3
3401dc6c:	4413      	add	r3, r2
3401dc6e:	4622      	mov	r2, r4
3401dc70:	4641      	mov	r1, r8
3401dc72:	fba2 1201 	umull	r1, r2, r2, r1
3401dc76:	f8c7 20b4 	str.w	r2, [r7, #180]	@ 0xb4
3401dc7a:	460a      	mov	r2, r1
3401dc7c:	f8c7 20b0 	str.w	r2, [r7, #176]	@ 0xb0
3401dc80:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
3401dc84:	4413      	add	r3, r2
3401dc86:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
3401dc8a:	e9d7 450a 	ldrd	r4, r5, [r7, #40]	@ 0x28
3401dc8e:	4623      	mov	r3, r4
3401dc90:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
3401dc94:	4602      	mov	r2, r0
3401dc96:	189b      	adds	r3, r3, r2
3401dc98:	603b      	str	r3, [r7, #0]
3401dc9a:	460b      	mov	r3, r1
3401dc9c:	462a      	mov	r2, r5
3401dc9e:	eb42 0303 	adc.w	r3, r2, r3
3401dca2:	607b      	str	r3, [r7, #4]
3401dca4:	e9d7 2300 	ldrd	r2, r3, [r7]
3401dca8:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    ccR /= ISP_CCM_PRECISION_FACTOR;
3401dcac:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
3401dcb0:	a343      	add	r3, pc, #268	@ (adr r3, 3401ddc0 <ISP_Algo_ApplyCConv+0x488>)
3401dcb2:	e9d3 2300 	ldrd	r2, r3, [r3]
3401dcb6:	f7e3 ff2d 	bl	34001b14 <__aeabi_ldivmod>
3401dcba:	4602      	mov	r2, r0
3401dcbc:	460b      	mov	r3, r1
3401dcbe:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG /= ISP_CCM_PRECISION_FACTOR;
3401dcc2:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
3401dcc6:	a33e      	add	r3, pc, #248	@ (adr r3, 3401ddc0 <ISP_Algo_ApplyCConv+0x488>)
3401dcc8:	e9d3 2300 	ldrd	r2, r3, [r3]
3401dccc:	f7e3 ff22 	bl	34001b14 <__aeabi_ldivmod>
3401dcd0:	4602      	mov	r2, r0
3401dcd2:	460b      	mov	r3, r1
3401dcd4:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB /= ISP_CCM_PRECISION_FACTOR;
3401dcd8:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
3401dcdc:	a338      	add	r3, pc, #224	@ (adr r3, 3401ddc0 <ISP_Algo_ApplyCConv+0x488>)
3401dcde:	e9d3 2300 	ldrd	r2, r3, [r3]
3401dce2:	f7e3 ff17 	bl	34001b14 <__aeabi_ldivmod>
3401dce6:	4602      	mov	r2, r0
3401dce8:	460b      	mov	r3, r1
3401dcea:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    /* Clamp values to 0-255 */
    ccR = (ccR < 0) ? 0 : (ccR > 255) ? 255 : ccR;
3401dcee:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
3401dcf2:	2b00      	cmp	r3, #0
3401dcf4:	db0b      	blt.n	3401dd0e <ISP_Algo_ApplyCConv+0x3d6>
3401dcf6:	e9d7 234e 	ldrd	r2, r3, [r7, #312]	@ 0x138
3401dcfa:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3401dcfe:	f173 0100 	sbcs.w	r1, r3, #0
3401dd02:	db08      	blt.n	3401dd16 <ISP_Algo_ApplyCConv+0x3de>
3401dd04:	f04f 02ff 	mov.w	r2, #255	@ 0xff
3401dd08:	f04f 0300 	mov.w	r3, #0
3401dd0c:	e003      	b.n	3401dd16 <ISP_Algo_ApplyCConv+0x3de>
3401dd0e:	f04f 0200 	mov.w	r2, #0
3401dd12:	f04f 0300 	mov.w	r3, #0
3401dd16:	e9c7 234e 	strd	r2, r3, [r7, #312]	@ 0x138
    ccG = (ccG < 0) ? 0 : (ccG > 255) ? 255 : ccG;
3401dd1a:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
3401dd1e:	2b00      	cmp	r3, #0
3401dd20:	db0b      	blt.n	3401dd3a <ISP_Algo_ApplyCConv+0x402>
3401dd22:	e9d7 234c 	ldrd	r2, r3, [r7, #304]	@ 0x130
3401dd26:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3401dd2a:	f173 0100 	sbcs.w	r1, r3, #0
3401dd2e:	db08      	blt.n	3401dd42 <ISP_Algo_ApplyCConv+0x40a>
3401dd30:	f04f 02ff 	mov.w	r2, #255	@ 0xff
3401dd34:	f04f 0300 	mov.w	r3, #0
3401dd38:	e003      	b.n	3401dd42 <ISP_Algo_ApplyCConv+0x40a>
3401dd3a:	f04f 0200 	mov.w	r2, #0
3401dd3e:	f04f 0300 	mov.w	r3, #0
3401dd42:	e9c7 234c 	strd	r2, r3, [r7, #304]	@ 0x130
    ccB = (ccB < 0) ? 0 : (ccB > 255) ? 255 : ccB;
3401dd46:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
3401dd4a:	2b00      	cmp	r3, #0
3401dd4c:	db0b      	blt.n	3401dd66 <ISP_Algo_ApplyCConv+0x42e>
3401dd4e:	e9d7 234a 	ldrd	r2, r3, [r7, #296]	@ 0x128
3401dd52:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3401dd56:	f173 0100 	sbcs.w	r1, r3, #0
3401dd5a:	db08      	blt.n	3401dd6e <ISP_Algo_ApplyCConv+0x436>
3401dd5c:	f04f 02ff 	mov.w	r2, #255	@ 0xff
3401dd60:	f04f 0300 	mov.w	r3, #0
3401dd64:	e003      	b.n	3401dd6e <ISP_Algo_ApplyCConv+0x436>
3401dd66:	f04f 0200 	mov.w	r2, #0
3401dd6a:	f04f 0300 	mov.w	r3, #0
3401dd6e:	e9c7 234a 	strd	r2, r3, [r7, #296]	@ 0x128

    *outR = (uint32_t) ccR;
3401dd72:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
3401dd76:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
3401dd7a:	601a      	str	r2, [r3, #0]
    *outG = (uint32_t) ccG;
3401dd7c:	f8d7 2130 	ldr.w	r2, [r7, #304]	@ 0x130
3401dd80:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
3401dd84:	601a      	str	r2, [r3, #0]
    *outB = (uint32_t) ccB;
3401dd86:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
3401dd8a:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
3401dd8e:	601a      	str	r2, [r3, #0]
3401dd90:	e00f      	b.n	3401ddb2 <ISP_Algo_ApplyCConv+0x47a>
  }
  else
  {
    *outR = inR;
3401dd92:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
3401dd96:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
3401dd9a:	601a      	str	r2, [r3, #0]
    *outG = inG;
3401dd9c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
3401dda0:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
3401dda4:	601a      	str	r2, [r3, #0]
    *outB = inB;
3401dda6:	f8d7 3168 	ldr.w	r3, [r7, #360]	@ 0x168
3401ddaa:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
3401ddae:	601a      	str	r2, [r3, #0]
  }
}
3401ddb0:	bf00      	nop
3401ddb2:	bf00      	nop
3401ddb4:	f507 77a0 	add.w	r7, r7, #320	@ 0x140
3401ddb8:	46bd      	mov	sp, r7
3401ddba:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3401ddbe:	bf00      	nop
3401ddc0:	05f5e100 	.word	0x05f5e100
3401ddc4:	00000000 	.word	0x00000000

3401ddc8 <ISP_Algo_AWB_Init>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Init(void *hIsp, void *pAlgo)
{
3401ddc8:	b580      	push	{r7, lr}
3401ddca:	b084      	sub	sp, #16
3401ddcc:	af00      	add	r7, sp, #0
3401ddce:	6078      	str	r0, [r7, #4]
3401ddd0:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
3401ddd2:	683b      	ldr	r3, [r7, #0]
3401ddd4:	60fb      	str	r3, [r7, #12]

  /* Create estimator */
  pIspAWBestimator = evision_api_awb_new(log_cb);
3401ddd6:	480a      	ldr	r0, [pc, #40]	@ (3401de00 <ISP_Algo_AWB_Init+0x38>)
3401ddd8:	f7e3 f879 	bl	34000ece <evision_api_awb_new>
3401dddc:	4603      	mov	r3, r0
3401ddde:	4a09      	ldr	r2, [pc, #36]	@ (3401de04 <ISP_Algo_AWB_Init+0x3c>)
3401dde0:	6013      	str	r3, [r2, #0]
  if (pIspAWBestimator == NULL)
3401dde2:	4b08      	ldr	r3, [pc, #32]	@ (3401de04 <ISP_Algo_AWB_Init+0x3c>)
3401dde4:	681b      	ldr	r3, [r3, #0]
3401dde6:	2b00      	cmp	r3, #0
3401dde8:	d101      	bne.n	3401ddee <ISP_Algo_AWB_Init+0x26>
  {
    return ISP_ERR_ALGO;
3401ddea:	23be      	movs	r3, #190	@ 0xbe
3401ddec:	e003      	b.n	3401ddf6 <ISP_Algo_AWB_Init+0x2e>
  }

  /* Continue the initialization in ISP_Algo_AWB_Process() function when state is ISP_ALGO_STATE_INIT.
   * This allows to read the IQ params after an algo stop/start cycle */
  algo->state = ISP_ALGO_STATE_INIT;
3401ddee:	68fb      	ldr	r3, [r7, #12]
3401ddf0:	2200      	movs	r2, #0
3401ddf2:	705a      	strb	r2, [r3, #1]

  return ISP_OK;
3401ddf4:	2300      	movs	r3, #0
}
3401ddf6:	4618      	mov	r0, r3
3401ddf8:	3710      	adds	r7, #16
3401ddfa:	46bd      	mov	sp, r7
3401ddfc:	bd80      	pop	{r7, pc}
3401ddfe:	bf00      	nop
3401de00:	3401d615 	.word	0x3401d615
3401de04:	3404a490 	.word	0x3404a490

3401de08 <ISP_Algo_AWB_DeInit>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_DeInit(void *hIsp, void *pAlgo)
{
3401de08:	b580      	push	{r7, lr}
3401de0a:	b082      	sub	sp, #8
3401de0c:	af00      	add	r7, sp, #0
3401de0e:	6078      	str	r0, [r7, #4]
3401de10:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */
  (void)pAlgo; /* unused */

  if (pIspAWBestimator != NULL)
3401de12:	4b07      	ldr	r3, [pc, #28]	@ (3401de30 <ISP_Algo_AWB_DeInit+0x28>)
3401de14:	681b      	ldr	r3, [r3, #0]
3401de16:	2b00      	cmp	r3, #0
3401de18:	d004      	beq.n	3401de24 <ISP_Algo_AWB_DeInit+0x1c>
  {
    evision_api_awb_delete(pIspAWBestimator);
3401de1a:	4b05      	ldr	r3, [pc, #20]	@ (3401de30 <ISP_Algo_AWB_DeInit+0x28>)
3401de1c:	681b      	ldr	r3, [r3, #0]
3401de1e:	4618      	mov	r0, r3
3401de20:	f7e3 f872 	bl	34000f08 <evision_api_awb_delete>
  }

  return ISP_OK;
3401de24:	2300      	movs	r3, #0
}
3401de26:	4618      	mov	r0, r3
3401de28:	3708      	adds	r7, #8
3401de2a:	46bd      	mov	sp, r7
3401de2c:	bd80      	pop	{r7, pc}
3401de2e:	bf00      	nop
3401de30:	3404a490 	.word	0x3404a490

3401de34 <ISP_Algo_AWB_StatCb>:
  *         Callback informing that statistics are available
  * @param  pAlgo: ISP algorithm handle.
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_StatCb(ISP_AlgoTypeDef *pAlgo)
{
3401de34:	b480      	push	{r7}
3401de36:	b083      	sub	sp, #12
3401de38:	af00      	add	r7, sp, #0
3401de3a:	6078      	str	r0, [r7, #4]
  /* Update State */
  if (pAlgo->state != ISP_ALGO_STATE_INIT)
3401de3c:	687b      	ldr	r3, [r7, #4]
3401de3e:	785b      	ldrb	r3, [r3, #1]
3401de40:	2b00      	cmp	r3, #0
3401de42:	d002      	beq.n	3401de4a <ISP_Algo_AWB_StatCb+0x16>
  {
    pAlgo->state = ISP_ALGO_STATE_STAT_READY;
3401de44:	687b      	ldr	r3, [r7, #4]
3401de46:	2203      	movs	r2, #3
3401de48:	705a      	strb	r2, [r3, #1]
  }

  return ISP_OK;
3401de4a:	2300      	movs	r3, #0
}
3401de4c:	4618      	mov	r0, r3
3401de4e:	370c      	adds	r7, #12
3401de50:	46bd      	mov	sp, r7
3401de52:	f85d 7b04 	ldr.w	r7, [sp], #4
3401de56:	4770      	bx	lr

3401de58 <ISP_Algo_AWB_Process>:
  * @param  hIsp:  ISP device handle. To cast in (ISP_HandleTypeDef *).
  * @param  pAlgo: ISP algorithm handle. To cast in (ISP_AlgoTypeDef *).
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_AWB_Process(void *hIsp, void *pAlgo)
{
3401de58:	b580      	push	{r7, lr}
3401de5a:	b0b6      	sub	sp, #216	@ 0xd8
3401de5c:	af04      	add	r7, sp, #16
3401de5e:	6078      	str	r0, [r7, #4]
3401de60:	6039      	str	r1, [r7, #0]
  static evision_awb_profile_t awbProfiles[ISP_AWB_COLORTEMP_REF];
  static float colorTempThresholds[ISP_AWB_COLORTEMP_REF - 1];
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_ColorConvTypeDef ColorConvConfig;
  ISP_ISPGainTypeDef ISPGainConfig;
  ISP_AlgoTypeDef *algo = (ISP_AlgoTypeDef *)pAlgo;
3401de62:	683b      	ldr	r3, [r7, #0]
3401de64:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
  ISP_StatusTypeDef ret_stat, ret = ISP_OK;
3401de68:	2300      	movs	r3, #0
3401de6a:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
  evision_return_t e_ret;
  uint32_t ccAvgR, ccAvgG, ccAvgB, colorTemp, i, j, profId, profNb;
  float cfaGains[4], ccmCoeffs[3][3], ccmOffsets[3] = { 0 };
3401de6e:	f107 0320 	add.w	r3, r7, #32
3401de72:	2200      	movs	r2, #0
3401de74:	601a      	str	r2, [r3, #0]
3401de76:	605a      	str	r2, [r3, #4]
3401de78:	609a      	str	r2, [r3, #8]
  double meas[3];

  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401de7a:	6878      	ldr	r0, [r7, #4]
3401de7c:	f001 fe8e 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401de80:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac

  if (IQParamConfig->AWBAlgo.enable == false)
3401de84:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401de88:	f893 3070 	ldrb.w	r3, [r3, #112]	@ 0x70
3401de8c:	2b00      	cmp	r3, #0
3401de8e:	d104      	bne.n	3401de9a <ISP_Algo_AWB_Process+0x42>
  {
    enableCurrent = false;
3401de90:	4bcd      	ldr	r3, [pc, #820]	@ (3401e1c8 <ISP_Algo_AWB_Process+0x370>)
3401de92:	2200      	movs	r2, #0
3401de94:	701a      	strb	r2, [r3, #0]
    return ISP_OK;
3401de96:	2300      	movs	r3, #0
3401de98:	e2ae      	b.n	3401e3f8 <ISP_Algo_AWB_Process+0x5a0>
  }
  else if ((enableCurrent == false) || (IQParamConfig->AWBAlgo.enable == ISP_AWB_ENABLE_RECONFIGURE))
3401de9a:	4bcb      	ldr	r3, [pc, #812]	@ (3401e1c8 <ISP_Algo_AWB_Process+0x370>)
3401de9c:	781b      	ldrb	r3, [r3, #0]
3401de9e:	2b00      	cmp	r3, #0
3401dea0:	d005      	beq.n	3401deae <ISP_Algo_AWB_Process+0x56>
3401dea2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401dea6:	f893 3070 	ldrb.w	r3, [r3, #112]	@ 0x70
3401deaa:	2bff      	cmp	r3, #255	@ 0xff
3401deac:	d10e      	bne.n	3401decc <ISP_Algo_AWB_Process+0x74>
  {
    /* Start or resume algo : set state to INIT in order to read the IQ params */
    algo->state = ISP_ALGO_STATE_INIT;
3401deae:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3401deb2:	2200      	movs	r2, #0
3401deb4:	705a      	strb	r2, [r3, #1]
    IQParamConfig->AWBAlgo.enable = true;
3401deb6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401deba:	2201      	movs	r2, #1
3401debc:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
    reconfigureRequest = true;
3401dec0:	4bc2      	ldr	r3, [pc, #776]	@ (3401e1cc <ISP_Algo_AWB_Process+0x374>)
3401dec2:	2201      	movs	r2, #1
3401dec4:	701a      	strb	r2, [r3, #0]
    enableCurrent = true;
3401dec6:	4bc0      	ldr	r3, [pc, #768]	@ (3401e1c8 <ISP_Algo_AWB_Process+0x370>)
3401dec8:	2201      	movs	r2, #1
3401deca:	701a      	strb	r2, [r3, #0]
  }

  switch(algo->state)
3401decc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3401ded0:	785b      	ldrb	r3, [r3, #1]
3401ded2:	2b03      	cmp	r3, #3
3401ded4:	f200 828e 	bhi.w	3401e3f4 <ISP_Algo_AWB_Process+0x59c>
3401ded8:	a201      	add	r2, pc, #4	@ (adr r2, 3401dee0 <ISP_Algo_AWB_Process+0x88>)
3401deda:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401dede:	bf00      	nop
3401dee0:	3401def1 	.word	0x3401def1
3401dee4:	3401e17f 	.word	0x3401e17f
3401dee8:	3401e3f5 	.word	0x3401e3f5
3401deec:	3401e1ed 	.word	0x3401e1ed
  {
  case ISP_ALGO_STATE_INIT:
    /* Set profiles (color temperature, gains, color conv matrix) */
    profNb = 0;
3401def0:	2300      	movs	r3, #0
3401def2:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401def6:	2300      	movs	r3, #0
3401def8:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401defc:	e0ca      	b.n	3401e094 <ISP_Algo_AWB_Process+0x23c>
    {
      colorTemp = IQParamConfig->AWBAlgo.referenceColorTemp[profId];
3401defe:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401df02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401df06:	3344      	adds	r3, #68	@ 0x44
3401df08:	009b      	lsls	r3, r3, #2
3401df0a:	4413      	add	r3, r2
3401df0c:	685b      	ldr	r3, [r3, #4]
3401df0e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
      if (colorTemp == 0)
3401df12:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
3401df16:	2b00      	cmp	r3, #0
3401df18:	f000 80c2 	beq.w	3401e0a0 <ISP_Algo_AWB_Process+0x248>
        break;

      if (profNb > 0)
3401df1c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401df20:	2b00      	cmp	r3, #0
3401df22:	d01b      	beq.n	3401df5c <ISP_Algo_AWB_Process+0x104>
      {
        /* Profile decision threshold = lowest ref. temperature + 1/4 of the distance between two reference temperatures */
        colorTempThresholds[profNb - 1] = (float) ((colorTemp + 3 * IQParamConfig->AWBAlgo.referenceColorTemp[profId - 1]) /4 );
3401df24:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401df28:	3b01      	subs	r3, #1
3401df2a:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401df2e:	3344      	adds	r3, #68	@ 0x44
3401df30:	009b      	lsls	r3, r3, #2
3401df32:	4413      	add	r3, r2
3401df34:	685a      	ldr	r2, [r3, #4]
3401df36:	4613      	mov	r3, r2
3401df38:	005b      	lsls	r3, r3, #1
3401df3a:	441a      	add	r2, r3
3401df3c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
3401df40:	4413      	add	r3, r2
3401df42:	089a      	lsrs	r2, r3, #2
3401df44:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401df48:	3b01      	subs	r3, #1
3401df4a:	ee07 2a90 	vmov	s15, r2
3401df4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401df52:	4a9f      	ldr	r2, [pc, #636]	@ (3401e1d0 <ISP_Algo_AWB_Process+0x378>)
3401df54:	009b      	lsls	r3, r3, #2
3401df56:	4413      	add	r3, r2
3401df58:	edc3 7a00 	vstr	s15, [r3]
      }

      /* Set cfa gains (RGGB) */
      cfaGains[0] = (float) IQParamConfig->AWBAlgo.ispGainR[profId] / ISP_GAIN_PRECISION_FACTOR;
3401df5c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401df60:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401df64:	324a      	adds	r2, #74	@ 0x4a
3401df66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3401df6a:	ee07 3a90 	vmov	s15, r3
3401df6e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401df72:	eddf 6a98 	vldr	s13, [pc, #608]	@ 3401e1d4 <ISP_Algo_AWB_Process+0x37c>
3401df76:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401df7a:	edc7 7a14 	vstr	s15, [r7, #80]	@ 0x50
      cfaGains[1] = (float) IQParamConfig->AWBAlgo.ispGainG[profId] / ISP_GAIN_PRECISION_FACTOR;
3401df7e:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401df82:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401df86:	334e      	adds	r3, #78	@ 0x4e
3401df88:	009b      	lsls	r3, r3, #2
3401df8a:	4413      	add	r3, r2
3401df8c:	685b      	ldr	r3, [r3, #4]
3401df8e:	ee07 3a90 	vmov	s15, r3
3401df92:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401df96:	eddf 6a8f 	vldr	s13, [pc, #572]	@ 3401e1d4 <ISP_Algo_AWB_Process+0x37c>
3401df9a:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401df9e:	edc7 7a15 	vstr	s15, [r7, #84]	@ 0x54
      cfaGains[2] = cfaGains[1];
3401dfa2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3401dfa4:	65bb      	str	r3, [r7, #88]	@ 0x58
      cfaGains[3] = (float) IQParamConfig->AWBAlgo.ispGainB[profId] / ISP_GAIN_PRECISION_FACTOR;
3401dfa6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401dfaa:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401dfae:	3254      	adds	r2, #84	@ 0x54
3401dfb0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3401dfb4:	ee07 3a90 	vmov	s15, r3
3401dfb8:	eeb8 7a67 	vcvt.f32.u32	s14, s15
3401dfbc:	eddf 6a85 	vldr	s13, [pc, #532]	@ 3401e1d4 <ISP_Algo_AWB_Process+0x37c>
3401dfc0:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401dfc4:	edc7 7a17 	vstr	s15, [r7, #92]	@ 0x5c

      /* Set CCM Coeff */
      for (i = 0; i < 3; i++)
3401dfc8:	2300      	movs	r3, #0
3401dfca:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3401dfce:	e03b      	b.n	3401e048 <ISP_Algo_AWB_Process+0x1f0>
      {
        for (j = 0; j < 3; j++)
3401dfd0:	2300      	movs	r3, #0
3401dfd2:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3401dfd6:	e02e      	b.n	3401e036 <ISP_Algo_AWB_Process+0x1de>
        {
          ccmCoeffs[i][j] = (float) IQParamConfig->AWBAlgo.coeff[profId][i][j] / ISP_CCM_PRECISION_FACTOR;
3401dfd8:	f8d7 00ac 	ldr.w	r0, [r7, #172]	@ 0xac
3401dfdc:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3401dfe0:	f8d7 10b8 	ldr.w	r1, [r7, #184]	@ 0xb8
3401dfe4:	461a      	mov	r2, r3
3401dfe6:	0052      	lsls	r2, r2, #1
3401dfe8:	441a      	add	r2, r3
3401dfea:	460b      	mov	r3, r1
3401dfec:	00db      	lsls	r3, r3, #3
3401dfee:	440b      	add	r3, r1
3401dff0:	441a      	add	r2, r3
3401dff2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
3401dff6:	4413      	add	r3, r2
3401dff8:	3358      	adds	r3, #88	@ 0x58
3401dffa:	009b      	lsls	r3, r3, #2
3401dffc:	4403      	add	r3, r0
3401dffe:	685b      	ldr	r3, [r3, #4]
3401e000:	ee07 3a90 	vmov	s15, r3
3401e004:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3401e008:	eddf 6a72 	vldr	s13, [pc, #456]	@ 3401e1d4 <ISP_Algo_AWB_Process+0x37c>
3401e00c:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401e010:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
3401e014:	4613      	mov	r3, r2
3401e016:	005b      	lsls	r3, r3, #1
3401e018:	4413      	add	r3, r2
3401e01a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
3401e01e:	4413      	add	r3, r2
3401e020:	009b      	lsls	r3, r3, #2
3401e022:	33c8      	adds	r3, #200	@ 0xc8
3401e024:	443b      	add	r3, r7
3401e026:	3b9c      	subs	r3, #156	@ 0x9c
3401e028:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < 3; j++)
3401e02c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
3401e030:	3301      	adds	r3, #1
3401e032:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
3401e036:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
3401e03a:	2b02      	cmp	r3, #2
3401e03c:	d9cc      	bls.n	3401dfd8 <ISP_Algo_AWB_Process+0x180>
      for (i = 0; i < 3; i++)
3401e03e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3401e042:	3301      	adds	r3, #1
3401e044:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
3401e048:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
3401e04c:	2b02      	cmp	r3, #2
3401e04e:	d9bf      	bls.n	3401dfd0 <ISP_Algo_AWB_Process+0x178>
        }
      }

      /* Set profile */
      evision_api_awb_set_profile(&awbProfiles[profId], (float) colorTemp, cfaGains, ccmCoeffs, ccmOffsets);
3401e050:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401e054:	4613      	mov	r3, r2
3401e056:	011b      	lsls	r3, r3, #4
3401e058:	4413      	add	r3, r2
3401e05a:	009b      	lsls	r3, r3, #2
3401e05c:	4a5e      	ldr	r2, [pc, #376]	@ (3401e1d8 <ISP_Algo_AWB_Process+0x380>)
3401e05e:	1898      	adds	r0, r3, r2
3401e060:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
3401e064:	ee07 3a90 	vmov	s15, r3
3401e068:	eef8 7a67 	vcvt.f32.u32	s15, s15
3401e06c:	f107 0320 	add.w	r3, r7, #32
3401e070:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
3401e074:	f107 0150 	add.w	r1, r7, #80	@ 0x50
3401e078:	eeb0 0a67 	vmov.f32	s0, s15
3401e07c:	f7e2 ff4a 	bl	34000f14 <evision_api_awb_set_profile>
      profNb++;
3401e080:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401e084:	3301      	adds	r3, #1
3401e086:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401e08a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e08e:	3301      	adds	r3, #1
3401e090:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401e094:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e098:	2b04      	cmp	r3, #4
3401e09a:	f67f af30 	bls.w	3401defe <ISP_Algo_AWB_Process+0xa6>
3401e09e:	e000      	b.n	3401e0a2 <ISP_Algo_AWB_Process+0x24a>
        break;
3401e0a0:	bf00      	nop
    }

    if (profNb == 0)
3401e0a2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401e0a6:	2b00      	cmp	r3, #0
3401e0a8:	d101      	bne.n	3401e0ae <ISP_Algo_AWB_Process+0x256>
    {
      return ISP_ERR_WB_COLORTEMP;
3401e0aa:	2396      	movs	r3, #150	@ 0x96
3401e0ac:	e1a4      	b.n	3401e3f8 <ISP_Algo_AWB_Process+0x5a0>
    }

    /* Register profiles */
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
3401e0ae:	4b4b      	ldr	r3, [pc, #300]	@ (3401e1dc <ISP_Algo_AWB_Process+0x384>)
3401e0b0:	6818      	ldr	r0, [r3, #0]
3401e0b2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401e0b6:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
3401e0ba:	ee07 3a90 	vmov	s15, r3
3401e0be:	eeb8 7b67 	vcvt.f64.u32	d7, s15
                                          (double) IQParamConfig->AWBAlgo.referenceColorTemp[profNb - 1], profNb,
3401e0c2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401e0c6:	3b01      	subs	r3, #1
3401e0c8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401e0cc:	3344      	adds	r3, #68	@ 0x44
3401e0ce:	009b      	lsls	r3, r3, #2
3401e0d0:	4413      	add	r3, r2
3401e0d2:	685b      	ldr	r3, [r3, #4]
    e_ret = evision_api_awb_init_profiles(pIspAWBestimator, (double) IQParamConfig->AWBAlgo.referenceColorTemp[0],
3401e0d4:	ee06 3a90 	vmov	s13, r3
3401e0d8:	eeb8 6b66 	vcvt.f64.u32	d6, s13
3401e0dc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401e0e0:	b299      	uxth	r1, r3
3401e0e2:	4b3d      	ldr	r3, [pc, #244]	@ (3401e1d8 <ISP_Algo_AWB_Process+0x380>)
3401e0e4:	4a3a      	ldr	r2, [pc, #232]	@ (3401e1d0 <ISP_Algo_AWB_Process+0x378>)
3401e0e6:	eeb0 1b46 	vmov.f64	d1, d6
3401e0ea:	eeb0 0b47 	vmov.f64	d0, d7
3401e0ee:	f7e2 ff31 	bl	34000f54 <evision_api_awb_init_profiles>
3401e0f2:	4603      	mov	r3, r0
3401e0f4:	f887 30ab 	strb.w	r3, [r7, #171]	@ 0xab
                                          colorTempThresholds, awbProfiles);
    if (e_ret != EVISION_RET_SUCCESS)
3401e0f8:	f997 30ab 	ldrsb.w	r3, [r7, #171]	@ 0xab
3401e0fc:	2b01      	cmp	r3, #1
3401e0fe:	d001      	beq.n	3401e104 <ISP_Algo_AWB_Process+0x2ac>
    {
      return ISP_ERR_ALGO;
3401e100:	23be      	movs	r3, #190	@ 0xbe
3401e102:	e179      	b.n	3401e3f8 <ISP_Algo_AWB_Process+0x5a0>
    }

    /* Configure algo */
    pIspAWBestimator->hyper_params.speed_p_min = 1.35;
3401e104:	4b35      	ldr	r3, [pc, #212]	@ (3401e1dc <ISP_Algo_AWB_Process+0x384>)
3401e106:	6819      	ldr	r1, [r3, #0]
3401e108:	a32b      	add	r3, pc, #172	@ (adr r3, 3401e1b8 <ISP_Algo_AWB_Process+0x360>)
3401e10a:	e9d3 2300 	ldrd	r2, r3, [r3]
3401e10e:	e9c1 23a6 	strd	r2, r3, [r1, #664]	@ 0x298
    pIspAWBestimator->hyper_params.speed_p_max = (profNb < 4)? 1.8 : 2.0;
3401e112:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
3401e116:	2b03      	cmp	r3, #3
3401e118:	d803      	bhi.n	3401e122 <ISP_Algo_AWB_Process+0x2ca>
3401e11a:	a329      	add	r3, pc, #164	@ (adr r3, 3401e1c0 <ISP_Algo_AWB_Process+0x368>)
3401e11c:	e9d3 2300 	ldrd	r2, r3, [r3]
3401e120:	e003      	b.n	3401e12a <ISP_Algo_AWB_Process+0x2d2>
3401e122:	f04f 0200 	mov.w	r2, #0
3401e126:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
3401e12a:	492c      	ldr	r1, [pc, #176]	@ (3401e1dc <ISP_Algo_AWB_Process+0x384>)
3401e12c:	6809      	ldr	r1, [r1, #0]
3401e12e:	e9c1 23a8 	strd	r2, r3, [r1, #672]	@ 0x2a0
    pIspAWBestimator->hyper_params.gm_tolerance = 1;
3401e132:	4b2a      	ldr	r3, [pc, #168]	@ (3401e1dc <ISP_Algo_AWB_Process+0x384>)
3401e134:	681b      	ldr	r3, [r3, #0]
3401e136:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
3401e13a:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
    pIspAWBestimator->hyper_params.conv_criterion = 3;
3401e13e:	4b27      	ldr	r3, [pc, #156]	@ (3401e1dc <ISP_Algo_AWB_Process+0x384>)
3401e140:	681b      	ldr	r3, [r3, #0]
3401e142:	4a27      	ldr	r2, [pc, #156]	@ (3401e1e0 <ISP_Algo_AWB_Process+0x388>)
3401e144:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4

    /* Ask for stats */
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3401e148:	2305      	movs	r3, #5
3401e14a:	9302      	str	r3, [sp, #8]
3401e14c:	2301      	movs	r3, #1
3401e14e:	9301      	str	r3, [sp, #4]
3401e150:	2302      	movs	r3, #2
3401e152:	9300      	str	r3, [sp, #0]
3401e154:	4b23      	ldr	r3, [pc, #140]	@ (3401e1e4 <ISP_Algo_AWB_Process+0x38c>)
3401e156:	683a      	ldr	r2, [r7, #0]
3401e158:	4923      	ldr	r1, [pc, #140]	@ (3401e1e8 <ISP_Algo_AWB_Process+0x390>)
3401e15a:	6878      	ldr	r0, [r7, #4]
3401e15c:	f002 f86e 	bl	3402023c <ISP_SVC_Stats_GetNext>
3401e160:	4603      	mov	r3, r0
3401e162:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
3401e166:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e16a:	2b00      	cmp	r3, #0
3401e16c:	d002      	beq.n	3401e174 <ISP_Algo_AWB_Process+0x31c>
    {
      return ret;
3401e16e:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e172:	e141      	b.n	3401e3f8 <ISP_Algo_AWB_Process+0x5a0>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401e174:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3401e178:	2202      	movs	r2, #2
3401e17a:	705a      	strb	r2, [r3, #1]
    break;
3401e17c:	e13a      	b.n	3401e3f4 <ISP_Algo_AWB_Process+0x59c>

  case ISP_ALGO_STATE_NEED_STAT:
    ret = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3401e17e:	2305      	movs	r3, #5
3401e180:	9302      	str	r3, [sp, #8]
3401e182:	2301      	movs	r3, #1
3401e184:	9301      	str	r3, [sp, #4]
3401e186:	2302      	movs	r3, #2
3401e188:	9300      	str	r3, [sp, #0]
3401e18a:	4b16      	ldr	r3, [pc, #88]	@ (3401e1e4 <ISP_Algo_AWB_Process+0x38c>)
3401e18c:	683a      	ldr	r2, [r7, #0]
3401e18e:	4916      	ldr	r1, [pc, #88]	@ (3401e1e8 <ISP_Algo_AWB_Process+0x390>)
3401e190:	6878      	ldr	r0, [r7, #4]
3401e192:	f002 f853 	bl	3402023c <ISP_SVC_Stats_GetNext>
3401e196:	4603      	mov	r3, r0
3401e198:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
                                ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    if (ret != ISP_OK)
3401e19c:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e1a0:	2b00      	cmp	r3, #0
3401e1a2:	d002      	beq.n	3401e1aa <ISP_Algo_AWB_Process+0x352>
    {
      return ret;
3401e1a4:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e1a8:	e126      	b.n	3401e3f8 <ISP_Algo_AWB_Process+0x5a0>
    }

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401e1aa:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3401e1ae:	2202      	movs	r2, #2
3401e1b0:	705a      	strb	r2, [r3, #1]
    break;
3401e1b2:	e11f      	b.n	3401e3f4 <ISP_Algo_AWB_Process+0x59c>
3401e1b4:	f3af 8000 	nop.w
3401e1b8:	9999999a 	.word	0x9999999a
3401e1bc:	3ff59999 	.word	0x3ff59999
3401e1c0:	cccccccd 	.word	0xcccccccd
3401e1c4:	3ffccccc 	.word	0x3ffccccc
3401e1c8:	3404a51c 	.word	0x3404a51c
3401e1cc:	3404a51d 	.word	0x3404a51d
3401e1d0:	3404a520 	.word	0x3404a520
3401e1d4:	4cbebc20 	.word	0x4cbebc20
3401e1d8:	3404a530 	.word	0x3404a530
3401e1dc:	3404a490 	.word	0x3404a490
3401e1e0:	40400000 	.word	0x40400000
3401e1e4:	3404a684 	.word	0x3404a684
3401e1e8:	3401de35 	.word	0x3401de35
    /* Do nothing */
    break;

  case ISP_ALGO_STATE_STAT_READY:
    /* Get stats after color conversion */
    ISP_Algo_ApplyCConv(hIsp, stats.down.averageR, stats.down.averageG, stats.down.averageB, &ccAvgR, &ccAvgG, &ccAvgB);
3401e1ec:	4b84      	ldr	r3, [pc, #528]	@ (3401e400 <ISP_Algo_AWB_Process+0x5a8>)
3401e1ee:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
3401e1f2:	4619      	mov	r1, r3
3401e1f4:	4b82      	ldr	r3, [pc, #520]	@ (3401e400 <ISP_Algo_AWB_Process+0x5a8>)
3401e1f6:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
3401e1fa:	461a      	mov	r2, r3
3401e1fc:	4b80      	ldr	r3, [pc, #512]	@ (3401e400 <ISP_Algo_AWB_Process+0x5a8>)
3401e1fe:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3401e202:	4618      	mov	r0, r3
3401e204:	f107 0360 	add.w	r3, r7, #96	@ 0x60
3401e208:	9302      	str	r3, [sp, #8]
3401e20a:	f107 0364 	add.w	r3, r7, #100	@ 0x64
3401e20e:	9301      	str	r3, [sp, #4]
3401e210:	f107 0368 	add.w	r3, r7, #104	@ 0x68
3401e214:	9300      	str	r3, [sp, #0]
3401e216:	4603      	mov	r3, r0
3401e218:	6878      	ldr	r0, [r7, #4]
3401e21a:	f7ff fb8d 	bl	3401d938 <ISP_Algo_ApplyCConv>

    /* Apply gamma */
    meas[0] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgR);
3401e21e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
3401e220:	4619      	mov	r1, r3
3401e222:	6878      	ldr	r0, [r7, #4]
3401e224:	f7ff fb44 	bl	3401d8b0 <ISP_Algo_ApplyGammaInverse>
3401e228:	eeb0 7b40 	vmov.f64	d7, d0
3401e22c:	ed87 7b02 	vstr	d7, [r7, #8]
    meas[1] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgG);
3401e230:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
3401e232:	4619      	mov	r1, r3
3401e234:	6878      	ldr	r0, [r7, #4]
3401e236:	f7ff fb3b 	bl	3401d8b0 <ISP_Algo_ApplyGammaInverse>
3401e23a:	eeb0 7b40 	vmov.f64	d7, d0
3401e23e:	ed87 7b04 	vstr	d7, [r7, #16]
    meas[2] = ISP_Algo_ApplyGammaInverse(hIsp, ccAvgB);
3401e242:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
3401e244:	4619      	mov	r1, r3
3401e246:	6878      	ldr	r0, [r7, #4]
3401e248:	f7ff fb32 	bl	3401d8b0 <ISP_Algo_ApplyGammaInverse>
3401e24c:	eeb0 7b40 	vmov.f64	d7, d0
3401e250:	ed87 7b06 	vstr	d7, [r7, #24]

    /* Run algo to estimate gain and color conversion to apply */
    e_ret = evision_api_awb_run_average(pIspAWBestimator, NULL, 1, meas);
3401e254:	4b6b      	ldr	r3, [pc, #428]	@ (3401e404 <ISP_Algo_AWB_Process+0x5ac>)
3401e256:	6818      	ldr	r0, [r3, #0]
3401e258:	f107 0308 	add.w	r3, r7, #8
3401e25c:	2201      	movs	r2, #1
3401e25e:	2100      	movs	r1, #0
3401e260:	f7e3 f84c 	bl	340012fc <evision_api_awb_run_average>
3401e264:	4603      	mov	r3, r0
3401e266:	f887 30ab 	strb.w	r3, [r7, #171]	@ 0xab
    if (e_ret == EVISION_RET_SUCCESS)
3401e26a:	f997 30ab 	ldrsb.w	r3, [r7, #171]	@ 0xab
3401e26e:	2b01      	cmp	r3, #1
3401e270:	f040 809e 	bne.w	3401e3b0 <ISP_Algo_AWB_Process+0x558>
        for (int i = 0; i < ISP_AWB_COLORTEMP_REF; i++) {
          nb_colortemp_change[i] = 0;
        }
      }
#endif
      if (pIspAWBestimator->out_temp != currentColorTemp || reconfigureRequest == true)
3401e274:	4b63      	ldr	r3, [pc, #396]	@ (3401e404 <ISP_Algo_AWB_Process+0x5ac>)
3401e276:	681b      	ldr	r3, [r3, #0]
3401e278:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3401e27c:	4b62      	ldr	r3, [pc, #392]	@ (3401e408 <ISP_Algo_AWB_Process+0x5b0>)
3401e27e:	681b      	ldr	r3, [r3, #0]
3401e280:	ee07 3a90 	vmov	s15, r3
3401e284:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401e288:	eeb4 6b47 	vcmp.f64	d6, d7
3401e28c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401e290:	d104      	bne.n	3401e29c <ISP_Algo_AWB_Process+0x444>
3401e292:	4b5e      	ldr	r3, [pc, #376]	@ (3401e40c <ISP_Algo_AWB_Process+0x5b4>)
3401e294:	781b      	ldrb	r3, [r3, #0]
3401e296:	2b01      	cmp	r3, #1
3401e298:	f040 808d 	bne.w	3401e3b6 <ISP_Algo_AWB_Process+0x55e>
      {
        /* Force to apply a WB profile when reconfigureRequest is true */
        reconfigureRequest = false;
3401e29c:	4b5b      	ldr	r3, [pc, #364]	@ (3401e40c <ISP_Algo_AWB_Process+0x5b4>)
3401e29e:	2200      	movs	r2, #0
3401e2a0:	701a      	strb	r2, [r3, #0]

#ifdef ALGO_AWB_DBG_LOGS
        printf("Color temperature = %ld\r\n", (uint32_t) pIspAWBestimator->out_temp);
#endif
        /* Find the index profile for this referenceColorTemp */
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401e2a2:	2300      	movs	r3, #0
3401e2a4:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401e2a8:	e019      	b.n	3401e2de <ISP_Algo_AWB_Process+0x486>
        {
          if (pIspAWBestimator->out_temp == IQParamConfig->AWBAlgo.referenceColorTemp[profId])
3401e2aa:	4b56      	ldr	r3, [pc, #344]	@ (3401e404 <ISP_Algo_AWB_Process+0x5ac>)
3401e2ac:	681b      	ldr	r3, [r3, #0]
3401e2ae:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
3401e2b2:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401e2b6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e2ba:	3344      	adds	r3, #68	@ 0x44
3401e2bc:	009b      	lsls	r3, r3, #2
3401e2be:	4413      	add	r3, r2
3401e2c0:	685b      	ldr	r3, [r3, #4]
3401e2c2:	ee07 3a90 	vmov	s15, r3
3401e2c6:	eeb8 7b67 	vcvt.f64.u32	d7, s15
3401e2ca:	eeb4 6b47 	vcmp.f64	d6, d7
3401e2ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3401e2d2:	d009      	beq.n	3401e2e8 <ISP_Algo_AWB_Process+0x490>
        for (profId = 0; profId < ISP_AWB_COLORTEMP_REF; profId++)
3401e2d4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e2d8:	3301      	adds	r3, #1
3401e2da:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
3401e2de:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e2e2:	2b04      	cmp	r3, #4
3401e2e4:	d9e1      	bls.n	3401e2aa <ISP_Algo_AWB_Process+0x452>
3401e2e6:	e000      	b.n	3401e2ea <ISP_Algo_AWB_Process+0x492>
            break;
3401e2e8:	bf00      	nop
        }

        if (profId == ISP_AWB_COLORTEMP_REF)
3401e2ea:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e2ee:	2b05      	cmp	r3, #5
3401e2f0:	d103      	bne.n	3401e2fa <ISP_Algo_AWB_Process+0x4a2>
        {
          /* Unknown profile */
          ret  = ISP_ERR_WB_COLORTEMP;
3401e2f2:	2396      	movs	r3, #150	@ 0x96
3401e2f4:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
3401e2f8:	e05d      	b.n	3401e3b6 <ISP_Algo_AWB_Process+0x55e>
        }
        else
        {
          /* Apply Color Conversion */
          ColorConvConfig.enable = 1;
3401e2fa:	2301      	movs	r3, #1
3401e2fc:	f887 307c 	strb.w	r3, [r7, #124]	@ 0x7c
          memcpy(ColorConvConfig.coeff, IQParamConfig->AWBAlgo.coeff[profId], sizeof(ColorConvConfig.coeff));
3401e300:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401e304:	4613      	mov	r3, r2
3401e306:	00db      	lsls	r3, r3, #3
3401e308:	4413      	add	r3, r2
3401e30a:	009b      	lsls	r3, r3, #2
3401e30c:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
3401e310:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401e314:	4413      	add	r3, r2
3401e316:	1d19      	adds	r1, r3, #4
3401e318:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
3401e31c:	3304      	adds	r3, #4
3401e31e:	2224      	movs	r2, #36	@ 0x24
3401e320:	4618      	mov	r0, r3
3401e322:	f009 f9c6 	bl	340276b2 <memcpy>
          ret = ISP_SVC_ISP_SetColorConv(hIsp, &ColorConvConfig);
3401e326:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
3401e32a:	4619      	mov	r1, r3
3401e32c:	6878      	ldr	r0, [r7, #4]
3401e32e:	f001 f98b 	bl	3401f648 <ISP_SVC_ISP_SetColorConv>
3401e332:	4603      	mov	r3, r0
3401e334:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7

          /* Apply gain */
          if (ret == ISP_OK)
3401e338:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e33c:	2b00      	cmp	r3, #0
3401e33e:	d13a      	bne.n	3401e3b6 <ISP_Algo_AWB_Process+0x55e>
          {
            ISPGainConfig.enable = 1;
3401e340:	2301      	movs	r3, #1
3401e342:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
            ISPGainConfig.ispGainR = IQParamConfig->AWBAlgo.ispGainR[profId];
3401e346:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401e34a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401e34e:	324a      	adds	r2, #74	@ 0x4a
3401e350:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3401e354:	673b      	str	r3, [r7, #112]	@ 0x70
            ISPGainConfig.ispGainG = IQParamConfig->AWBAlgo.ispGainG[profId];
3401e356:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
3401e35a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e35e:	334e      	adds	r3, #78	@ 0x4e
3401e360:	009b      	lsls	r3, r3, #2
3401e362:	4413      	add	r3, r2
3401e364:	685b      	ldr	r3, [r3, #4]
3401e366:	677b      	str	r3, [r7, #116]	@ 0x74
            ISPGainConfig.ispGainB = IQParamConfig->AWBAlgo.ispGainB[profId];
3401e368:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
3401e36c:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
3401e370:	3254      	adds	r2, #84	@ 0x54
3401e372:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
3401e376:	67bb      	str	r3, [r7, #120]	@ 0x78
            ret = ISP_SVC_ISP_SetGain(hIsp, &ISPGainConfig);
3401e378:	f107 036c 	add.w	r3, r7, #108	@ 0x6c
3401e37c:	4619      	mov	r1, r3
3401e37e:	6878      	ldr	r0, [r7, #4]
3401e380:	f001 f8f8 	bl	3401f574 <ISP_SVC_ISP_SetGain>
3401e384:	4603      	mov	r3, r0
3401e386:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
            if (ret == ISP_OK)
3401e38a:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e38e:	2b00      	cmp	r3, #0
3401e390:	d111      	bne.n	3401e3b6 <ISP_Algo_AWB_Process+0x55e>
            {
              currentColorTemp = (uint32_t) pIspAWBestimator->out_temp ;
3401e392:	4b1c      	ldr	r3, [pc, #112]	@ (3401e404 <ISP_Algo_AWB_Process+0x5ac>)
3401e394:	681b      	ldr	r3, [r3, #0]
3401e396:	ed93 7b12 	vldr	d7, [r3, #72]	@ 0x48
3401e39a:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3401e39e:	ee17 2a90 	vmov	r2, s15
3401e3a2:	4b19      	ldr	r3, [pc, #100]	@ (3401e408 <ISP_Algo_AWB_Process+0x5b0>)
3401e3a4:	601a      	str	r2, [r3, #0]
              current_awb_profId = profId;
3401e3a6:	4a1a      	ldr	r2, [pc, #104]	@ (3401e410 <ISP_Algo_AWB_Process+0x5b8>)
3401e3a8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
3401e3ac:	6013      	str	r3, [r2, #0]
3401e3ae:	e002      	b.n	3401e3b6 <ISP_Algo_AWB_Process+0x55e>
        }
      }
    }
    else
    {
      ret = ISP_ERR_ALGO;
3401e3b0:	23be      	movs	r3, #190	@ 0xbe
3401e3b2:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
    }

    /* Ask for stats */
    ret_stat = ISP_SVC_Stats_GetNext(hIsp, &ISP_Algo_AWB_StatCb, pAlgo, &stats, ISP_STAT_LOC_DOWN,
3401e3b6:	2305      	movs	r3, #5
3401e3b8:	9302      	str	r3, [sp, #8]
3401e3ba:	2301      	movs	r3, #1
3401e3bc:	9301      	str	r3, [sp, #4]
3401e3be:	2302      	movs	r3, #2
3401e3c0:	9300      	str	r3, [sp, #0]
3401e3c2:	4b0f      	ldr	r3, [pc, #60]	@ (3401e400 <ISP_Algo_AWB_Process+0x5a8>)
3401e3c4:	683a      	ldr	r2, [r7, #0]
3401e3c6:	4913      	ldr	r1, [pc, #76]	@ (3401e414 <ISP_Algo_AWB_Process+0x5bc>)
3401e3c8:	6878      	ldr	r0, [r7, #4]
3401e3ca:	f001 ff37 	bl	3402023c <ISP_SVC_Stats_GetNext>
3401e3ce:	4603      	mov	r3, r0
3401e3d0:	f887 30aa 	strb.w	r3, [r7, #170]	@ 0xaa
                                     ISP_STAT_TYPE_AVG, ALGO_ISP_LATENCY + ALGO_AWB_ADDITIONAL_LATENCY);
    ret = (ret != ISP_OK) ? ret : ret_stat;
3401e3d4:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e3d8:	2b00      	cmp	r3, #0
3401e3da:	d002      	beq.n	3401e3e2 <ISP_Algo_AWB_Process+0x58a>
3401e3dc:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
3401e3e0:	e001      	b.n	3401e3e6 <ISP_Algo_AWB_Process+0x58e>
3401e3e2:	f897 30aa 	ldrb.w	r3, [r7, #170]	@ 0xaa
3401e3e6:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7

    /* Wait for stats to be ready */
    algo->state = ISP_ALGO_STATE_WAITING_STAT;
3401e3ea:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
3401e3ee:	2202      	movs	r2, #2
3401e3f0:	705a      	strb	r2, [r3, #1]
    break;
3401e3f2:	bf00      	nop
  }

  return ret;
3401e3f4:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
}
3401e3f8:	4618      	mov	r0, r3
3401e3fa:	37c8      	adds	r7, #200	@ 0xc8
3401e3fc:	46bd      	mov	sp, r7
3401e3fe:	bd80      	pop	{r7, pc}
3401e400:	3404a684 	.word	0x3404a684
3401e404:	3404a490 	.word	0x3404a490
3401e408:	3404a6fc 	.word	0x3404a6fc
3401e40c:	3404a51d 	.word	0x3404a51d
3401e410:	3404a494 	.word	0x3404a494
3401e414:	3401de35 	.word	0x3401de35

3401e418 <ISP_Algo_Init>:
  *         Register and initialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Init(ISP_HandleTypeDef *hIsp)
{
3401e418:	b580      	push	{r7, lr}
3401e41a:	b086      	sub	sp, #24
3401e41c:	af00      	add	r7, sp, #0
3401e41e:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  hIsp->algorithm = ISP_Algo_List;
3401e420:	687b      	ldr	r3, [r7, #4]
3401e422:	4a15      	ldr	r2, [pc, #84]	@ (3401e478 <ISP_Algo_Init+0x60>)
3401e424:	619a      	str	r2, [r3, #24]

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e426:	2300      	movs	r3, #0
3401e428:	75fb      	strb	r3, [r7, #23]
3401e42a:	e01c      	b.n	3401e466 <ISP_Algo_Init+0x4e>
  {
    algo = hIsp->algorithm[i];
3401e42c:	687b      	ldr	r3, [r7, #4]
3401e42e:	699a      	ldr	r2, [r3, #24]
3401e430:	7dfb      	ldrb	r3, [r7, #23]
3401e432:	009b      	lsls	r3, r3, #2
3401e434:	4413      	add	r3, r2
3401e436:	681b      	ldr	r3, [r3, #0]
3401e438:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Init != NULL))
3401e43a:	693b      	ldr	r3, [r7, #16]
3401e43c:	2b00      	cmp	r3, #0
3401e43e:	d00f      	beq.n	3401e460 <ISP_Algo_Init+0x48>
3401e440:	693b      	ldr	r3, [r7, #16]
3401e442:	685b      	ldr	r3, [r3, #4]
3401e444:	2b00      	cmp	r3, #0
3401e446:	d00b      	beq.n	3401e460 <ISP_Algo_Init+0x48>
    {
      ret = algo->Init((void*)hIsp, (void*)algo);
3401e448:	693b      	ldr	r3, [r7, #16]
3401e44a:	685b      	ldr	r3, [r3, #4]
3401e44c:	6939      	ldr	r1, [r7, #16]
3401e44e:	6878      	ldr	r0, [r7, #4]
3401e450:	4798      	blx	r3
3401e452:	4603      	mov	r3, r0
3401e454:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
3401e456:	7bfb      	ldrb	r3, [r7, #15]
3401e458:	2b00      	cmp	r3, #0
3401e45a:	d001      	beq.n	3401e460 <ISP_Algo_Init+0x48>
      {
        return ret;
3401e45c:	7bfb      	ldrb	r3, [r7, #15]
3401e45e:	e006      	b.n	3401e46e <ISP_Algo_Init+0x56>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e460:	7dfb      	ldrb	r3, [r7, #23]
3401e462:	3301      	adds	r3, #1
3401e464:	75fb      	strb	r3, [r7, #23]
3401e466:	7dfb      	ldrb	r3, [r7, #23]
3401e468:	2b02      	cmp	r3, #2
3401e46a:	d9df      	bls.n	3401e42c <ISP_Algo_Init+0x14>
      }
    }
  }

  return ISP_OK;
3401e46c:	2300      	movs	r3, #0
}
3401e46e:	4618      	mov	r0, r3
3401e470:	3718      	adds	r7, #24
3401e472:	46bd      	mov	sp, r7
3401e474:	bd80      	pop	{r7, pc}
3401e476:	bf00      	nop
3401e478:	3404147c 	.word	0x3404147c

3401e47c <ISP_Algo_DeInit>:
  *         Deinitialize all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_DeInit(ISP_HandleTypeDef *hIsp)
{
3401e47c:	b580      	push	{r7, lr}
3401e47e:	b086      	sub	sp, #24
3401e480:	af00      	add	r7, sp, #0
3401e482:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e484:	2300      	movs	r3, #0
3401e486:	75fb      	strb	r3, [r7, #23]
3401e488:	e01c      	b.n	3401e4c4 <ISP_Algo_DeInit+0x48>
  {
    algo = hIsp->algorithm[i];
3401e48a:	687b      	ldr	r3, [r7, #4]
3401e48c:	699a      	ldr	r2, [r3, #24]
3401e48e:	7dfb      	ldrb	r3, [r7, #23]
3401e490:	009b      	lsls	r3, r3, #2
3401e492:	4413      	add	r3, r2
3401e494:	681b      	ldr	r3, [r3, #0]
3401e496:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->DeInit != NULL))
3401e498:	693b      	ldr	r3, [r7, #16]
3401e49a:	2b00      	cmp	r3, #0
3401e49c:	d00f      	beq.n	3401e4be <ISP_Algo_DeInit+0x42>
3401e49e:	693b      	ldr	r3, [r7, #16]
3401e4a0:	689b      	ldr	r3, [r3, #8]
3401e4a2:	2b00      	cmp	r3, #0
3401e4a4:	d00b      	beq.n	3401e4be <ISP_Algo_DeInit+0x42>
    {
      ret = algo->DeInit((void*)hIsp, (void*)algo);
3401e4a6:	693b      	ldr	r3, [r7, #16]
3401e4a8:	689b      	ldr	r3, [r3, #8]
3401e4aa:	6939      	ldr	r1, [r7, #16]
3401e4ac:	6878      	ldr	r0, [r7, #4]
3401e4ae:	4798      	blx	r3
3401e4b0:	4603      	mov	r3, r0
3401e4b2:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
3401e4b4:	7bfb      	ldrb	r3, [r7, #15]
3401e4b6:	2b00      	cmp	r3, #0
3401e4b8:	d001      	beq.n	3401e4be <ISP_Algo_DeInit+0x42>
      {
        return ret;
3401e4ba:	7bfb      	ldrb	r3, [r7, #15]
3401e4bc:	e006      	b.n	3401e4cc <ISP_Algo_DeInit+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e4be:	7dfb      	ldrb	r3, [r7, #23]
3401e4c0:	3301      	adds	r3, #1
3401e4c2:	75fb      	strb	r3, [r7, #23]
3401e4c4:	7dfb      	ldrb	r3, [r7, #23]
3401e4c6:	2b02      	cmp	r3, #2
3401e4c8:	d9df      	bls.n	3401e48a <ISP_Algo_DeInit+0xe>
      }
    }
  }

  return ISP_OK;
3401e4ca:	2300      	movs	r3, #0
}
3401e4cc:	4618      	mov	r0, r3
3401e4ce:	3718      	adds	r7, #24
3401e4d0:	46bd      	mov	sp, r7
3401e4d2:	bd80      	pop	{r7, pc}

3401e4d4 <ISP_Algo_Process>:
  *         Process all the algorithms
  * @param  hIsp: ISP device handle
  * @retval operation result
  */
ISP_StatusTypeDef ISP_Algo_Process(ISP_HandleTypeDef *hIsp)
{
3401e4d4:	b580      	push	{r7, lr}
3401e4d6:	b086      	sub	sp, #24
3401e4d8:	af00      	add	r7, sp, #0
3401e4da:	6078      	str	r0, [r7, #4]
  ISP_AlgoTypeDef *algo;
  ISP_StatusTypeDef ret;
  uint8_t i;

  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e4dc:	2300      	movs	r3, #0
3401e4de:	75fb      	strb	r3, [r7, #23]
3401e4e0:	e01c      	b.n	3401e51c <ISP_Algo_Process+0x48>
  {
    algo = hIsp->algorithm[i];
3401e4e2:	687b      	ldr	r3, [r7, #4]
3401e4e4:	699a      	ldr	r2, [r3, #24]
3401e4e6:	7dfb      	ldrb	r3, [r7, #23]
3401e4e8:	009b      	lsls	r3, r3, #2
3401e4ea:	4413      	add	r3, r2
3401e4ec:	681b      	ldr	r3, [r3, #0]
3401e4ee:	613b      	str	r3, [r7, #16]
    if ((algo != NULL) && (algo->Process != NULL))
3401e4f0:	693b      	ldr	r3, [r7, #16]
3401e4f2:	2b00      	cmp	r3, #0
3401e4f4:	d00f      	beq.n	3401e516 <ISP_Algo_Process+0x42>
3401e4f6:	693b      	ldr	r3, [r7, #16]
3401e4f8:	68db      	ldr	r3, [r3, #12]
3401e4fa:	2b00      	cmp	r3, #0
3401e4fc:	d00b      	beq.n	3401e516 <ISP_Algo_Process+0x42>
    {
#ifdef ALGO_PERF_DBG_LOGS
      uint32_t tickstart = HAL_GetTick();
#endif
      ret = algo->Process((void*)hIsp, (void*)algo);
3401e4fe:	693b      	ldr	r3, [r7, #16]
3401e500:	68db      	ldr	r3, [r3, #12]
3401e502:	6939      	ldr	r1, [r7, #16]
3401e504:	6878      	ldr	r0, [r7, #4]
3401e506:	4798      	blx	r3
3401e508:	4603      	mov	r3, r0
3401e50a:	73fb      	strb	r3, [r7, #15]
      if (ret != ISP_OK)
3401e50c:	7bfb      	ldrb	r3, [r7, #15]
3401e50e:	2b00      	cmp	r3, #0
3401e510:	d001      	beq.n	3401e516 <ISP_Algo_Process+0x42>
      {
        return ret;
3401e512:	7bfb      	ldrb	r3, [r7, #15]
3401e514:	e006      	b.n	3401e524 <ISP_Algo_Process+0x50>
  for (i = 0; i < sizeof(ISP_Algo_List) / sizeof(*ISP_Algo_List); i++)
3401e516:	7dfb      	ldrb	r3, [r7, #23]
3401e518:	3301      	adds	r3, #1
3401e51a:	75fb      	strb	r3, [r7, #23]
3401e51c:	7dfb      	ldrb	r3, [r7, #23]
3401e51e:	2b02      	cmp	r3, #2
3401e520:	d9df      	bls.n	3401e4e2 <ISP_Algo_Process+0xe>
      }
#endif
    }
  }

  return ISP_OK;
3401e522:	2300      	movs	r3, #0
}
3401e524:	4618      	mov	r0, r3
3401e526:	3718      	adds	r7, #24
3401e528:	46bd      	mov	sp, r7
3401e52a:	bd80      	pop	{r7, pc}

3401e52c <ISP_Init>:
                           void *hDcmipp,
                           uint32_t CameraInstance,
                           ISP_AppliHelpersTypeDef *pAppliHelpers,
                           ISP_StatAreaTypeDef *pStatArea,
                           const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
3401e52c:	b5b0      	push	{r4, r5, r7, lr}
3401e52e:	b086      	sub	sp, #24
3401e530:	af00      	add	r7, sp, #0
3401e532:	60f8      	str	r0, [r7, #12]
3401e534:	60b9      	str	r1, [r7, #8]
3401e536:	607a      	str	r2, [r7, #4]
3401e538:	603b      	str	r3, [r7, #0]
  ISP_StatusTypeDef ret;

  if ((hIsp == NULL) || (hDcmipp == NULL) || (pAppliHelpers == NULL))
3401e53a:	68fb      	ldr	r3, [r7, #12]
3401e53c:	2b00      	cmp	r3, #0
3401e53e:	d005      	beq.n	3401e54c <ISP_Init+0x20>
3401e540:	68bb      	ldr	r3, [r7, #8]
3401e542:	2b00      	cmp	r3, #0
3401e544:	d002      	beq.n	3401e54c <ISP_Init+0x20>
3401e546:	683b      	ldr	r3, [r7, #0]
3401e548:	2b00      	cmp	r3, #0
3401e54a:	d101      	bne.n	3401e550 <ISP_Init+0x24>
  {
    return ISP_ERR_EINVAL;
3401e54c:	2301      	movs	r3, #1
3401e54e:	e0ae      	b.n	3401e6ae <ISP_Init+0x182>
  }

  memset(hIsp, 0, sizeof(*hIsp));
3401e550:	2288      	movs	r2, #136	@ 0x88
3401e552:	2100      	movs	r1, #0
3401e554:	68f8      	ldr	r0, [r7, #12]
3401e556:	f008 fe1d 	bl	34027194 <memset>

#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_ToolCom_Init();
#endif

  hIsp->hDcmipp = hDcmipp;
3401e55a:	68fb      	ldr	r3, [r7, #12]
3401e55c:	68ba      	ldr	r2, [r7, #8]
3401e55e:	601a      	str	r2, [r3, #0]
  hIsp->cameraInstance = CameraInstance;
3401e560:	68fb      	ldr	r3, [r7, #12]
3401e562:	687a      	ldr	r2, [r7, #4]
3401e564:	605a      	str	r2, [r3, #4]
  hIsp->MainPipe_FrameCount = 0;
3401e566:	68fb      	ldr	r3, [r7, #12]
3401e568:	2200      	movs	r2, #0
3401e56a:	641a      	str	r2, [r3, #64]	@ 0x40
  hIsp->AncillaryPipe_FrameCount = 0;
3401e56c:	68fb      	ldr	r3, [r7, #12]
3401e56e:	2200      	movs	r2, #0
3401e570:	645a      	str	r2, [r3, #68]	@ 0x44
  hIsp->DumpPipe_FrameCount = 0;
3401e572:	68fb      	ldr	r3, [r7, #12]
3401e574:	2200      	movs	r2, #0
3401e576:	649a      	str	r2, [r3, #72]	@ 0x48

  hIsp->appliHelpers = *pAppliHelpers;
3401e578:	68fb      	ldr	r3, [r7, #12]
3401e57a:	683a      	ldr	r2, [r7, #0]
3401e57c:	f103 041c 	add.w	r4, r3, #28
3401e580:	4615      	mov	r5, r2
3401e582:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3401e584:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3401e586:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3401e588:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3401e58a:	682b      	ldr	r3, [r5, #0]
3401e58c:	6023      	str	r3, [r4, #0]
  /* Appli CB is mandatory for the sensor get/set exp/gain function */
  if (hIsp->appliHelpers.GetSensorInfo == NULL)
3401e58e:	68fb      	ldr	r3, [r7, #12]
3401e590:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401e592:	2b00      	cmp	r3, #0
3401e594:	d104      	bne.n	3401e5a0 <ISP_Init+0x74>
  {
     printf("INFO: GetSensorInfo helper function is not implemented\r\n");
3401e596:	4848      	ldr	r0, [pc, #288]	@ (3401e6b8 <ISP_Init+0x18c>)
3401e598:	f008 fbdc 	bl	34026d54 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
3401e59c:	23b4      	movs	r3, #180	@ 0xb4
3401e59e:	e086      	b.n	3401e6ae <ISP_Init+0x182>
   }
  if (hIsp->appliHelpers.SetSensorGain == NULL)
3401e5a0:	68fb      	ldr	r3, [r7, #12]
3401e5a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401e5a4:	2b00      	cmp	r3, #0
3401e5a6:	d104      	bne.n	3401e5b2 <ISP_Init+0x86>
  {
      printf("INFO: SetSensorGain helper function is not implemented\r\n");
3401e5a8:	4844      	ldr	r0, [pc, #272]	@ (3401e6bc <ISP_Init+0x190>)
3401e5aa:	f008 fbd3 	bl	34026d54 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
3401e5ae:	23b4      	movs	r3, #180	@ 0xb4
3401e5b0:	e07d      	b.n	3401e6ae <ISP_Init+0x182>
  }
  if (hIsp->appliHelpers.GetSensorGain == NULL)
3401e5b2:	68fb      	ldr	r3, [r7, #12]
3401e5b4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401e5b6:	2b00      	cmp	r3, #0
3401e5b8:	d104      	bne.n	3401e5c4 <ISP_Init+0x98>
  {
     printf("INFO: GetSensorGain helper function is not implemented\r\n");
3401e5ba:	4841      	ldr	r0, [pc, #260]	@ (3401e6c0 <ISP_Init+0x194>)
3401e5bc:	f008 fbca 	bl	34026d54 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
3401e5c0:	23b4      	movs	r3, #180	@ 0xb4
3401e5c2:	e074      	b.n	3401e6ae <ISP_Init+0x182>
   }
  if (hIsp->appliHelpers.SetSensorExposure == NULL)
3401e5c4:	68fb      	ldr	r3, [r7, #12]
3401e5c6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401e5c8:	2b00      	cmp	r3, #0
3401e5ca:	d104      	bne.n	3401e5d6 <ISP_Init+0xaa>
  {
      printf("INFO: SetSensorExposure helper function is not implemented\r\n");
3401e5cc:	483d      	ldr	r0, [pc, #244]	@ (3401e6c4 <ISP_Init+0x198>)
3401e5ce:	f008 fbc1 	bl	34026d54 <puts>
      return ISP_ERR_APP_HELPER_UNDEFINED;
3401e5d2:	23b4      	movs	r3, #180	@ 0xb4
3401e5d4:	e06b      	b.n	3401e6ae <ISP_Init+0x182>
  }
  if (hIsp->appliHelpers.GetSensorExposure == NULL)
3401e5d6:	68fb      	ldr	r3, [r7, #12]
3401e5d8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401e5da:	2b00      	cmp	r3, #0
3401e5dc:	d104      	bne.n	3401e5e8 <ISP_Init+0xbc>
  {
     printf("INFO: GetSensorExposure helper function is not implemented\r\n");
3401e5de:	483a      	ldr	r0, [pc, #232]	@ (3401e6c8 <ISP_Init+0x19c>)
3401e5e0:	f008 fbb8 	bl	34026d54 <puts>
     return ISP_ERR_APP_HELPER_UNDEFINED;
3401e5e4:	23b4      	movs	r3, #180	@ 0xb4
3401e5e6:	e062      	b.n	3401e6ae <ISP_Init+0x182>
   }

  if (pStatArea != NULL)
3401e5e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401e5ea:	2b00      	cmp	r3, #0
3401e5ec:	d007      	beq.n	3401e5fe <ISP_Init+0xd2>
  {
    hIsp->statArea = *pStatArea;
3401e5ee:	68fb      	ldr	r3, [r7, #12]
3401e5f0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3401e5f2:	f103 0408 	add.w	r4, r3, #8
3401e5f6:	4613      	mov	r3, r2
3401e5f8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
3401e5fa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  }

  /* Initialize IQ param (read from non volatile memory) */
  ret = ISP_SVC_IQParam_Init(hIsp, ISP_IQParamCacheInit);
3401e5fe:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
3401e600:	68f8      	ldr	r0, [r7, #12]
3401e602:	f001 fab5 	bl	3401fb70 <ISP_SVC_IQParam_Init>
3401e606:	4603      	mov	r3, r0
3401e608:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3401e60a:	7dfb      	ldrb	r3, [r7, #23]
3401e60c:	2b00      	cmp	r3, #0
3401e60e:	d001      	beq.n	3401e614 <ISP_Init+0xe8>
  {
    return ret;
3401e610:	7dfb      	ldrb	r3, [r7, #23]
3401e612:	e04c      	b.n	3401e6ae <ISP_Init+0x182>
  }

  /* Set decimation configuration */
  /* Get Sensor Info */
  ret = ISP_SVC_Sensor_GetInfo(hIsp, &hIsp->sensorInfo);
3401e614:	68fb      	ldr	r3, [r7, #12]
3401e616:	334c      	adds	r3, #76	@ 0x4c
3401e618:	4619      	mov	r1, r3
3401e61a:	68f8      	ldr	r0, [r7, #12]
3401e61c:	f001 f936 	bl	3401f88c <ISP_SVC_Sensor_GetInfo>
3401e620:	4603      	mov	r3, r0
3401e622:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3401e624:	7dfb      	ldrb	r3, [r7, #23]
3401e626:	2b00      	cmp	r3, #0
3401e628:	d001      	beq.n	3401e62e <ISP_Init+0x102>
  {
    return ret;
3401e62a:	7dfb      	ldrb	r3, [r7, #23]
3401e62c:	e03f      	b.n	3401e6ae <ISP_Init+0x182>
  }
  /* Compute the ISP decimation value according to the sensor resolution and the maximum ISP resolution */
  /* It is mandatory to ensure that RAW frame size does not exceed 2688 width prior to demosaicing */
  ISP_DecimationTypeDef decimation;
  if ((hIsp->sensorInfo.width / ISP_DECIM_FACTOR_1) < ISP_RAW_MAX_WIDTH)
3401e62e:	68fb      	ldr	r3, [r7, #12]
3401e630:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3401e632:	f5b3 6f28 	cmp.w	r3, #2688	@ 0xa80
3401e636:	d202      	bcs.n	3401e63e <ISP_Init+0x112>
  {
    decimation.factor = ISP_DECIM_FACTOR_1;
3401e638:	2301      	movs	r3, #1
3401e63a:	753b      	strb	r3, [r7, #20]
3401e63c:	e01c      	b.n	3401e678 <ISP_Init+0x14c>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_2) < ISP_RAW_MAX_WIDTH)
3401e63e:	68fb      	ldr	r3, [r7, #12]
3401e640:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3401e642:	f5b3 5fa8 	cmp.w	r3, #5376	@ 0x1500
3401e646:	d202      	bcs.n	3401e64e <ISP_Init+0x122>
  {
    decimation.factor = ISP_DECIM_FACTOR_2;
3401e648:	2302      	movs	r3, #2
3401e64a:	753b      	strb	r3, [r7, #20]
3401e64c:	e014      	b.n	3401e678 <ISP_Init+0x14c>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_4) < ISP_RAW_MAX_WIDTH)
3401e64e:	68fb      	ldr	r3, [r7, #12]
3401e650:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3401e652:	f5b3 5f28 	cmp.w	r3, #10752	@ 0x2a00
3401e656:	d202      	bcs.n	3401e65e <ISP_Init+0x132>
  {
    decimation.factor = ISP_DECIM_FACTOR_4;
3401e658:	2304      	movs	r3, #4
3401e65a:	753b      	strb	r3, [r7, #20]
3401e65c:	e00c      	b.n	3401e678 <ISP_Init+0x14c>
  }
  else if ((hIsp->sensorInfo.width  / ISP_DECIM_FACTOR_8) < ISP_RAW_MAX_WIDTH)
3401e65e:	68fb      	ldr	r3, [r7, #12]
3401e660:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3401e662:	f5b3 4fa8 	cmp.w	r3, #21504	@ 0x5400
3401e666:	d202      	bcs.n	3401e66e <ISP_Init+0x142>
  {
    decimation.factor = ISP_DECIM_FACTOR_8;
3401e668:	2308      	movs	r3, #8
3401e66a:	753b      	strb	r3, [r7, #20]
3401e66c:	e004      	b.n	3401e678 <ISP_Init+0x14c>
  }
  else
  {
    printf("ERROR: No possible decimation factor to target ISP RAW width constraint\r\n");
3401e66e:	4817      	ldr	r0, [pc, #92]	@ (3401e6cc <ISP_Init+0x1a0>)
3401e670:	f008 fb70 	bl	34026d54 <puts>
    return ISP_ERR_DECIMATION_EINVAL;
3401e674:	231e      	movs	r3, #30
3401e676:	e01a      	b.n	3401e6ae <ISP_Init+0x182>
  }
  ret = ISP_SVC_ISP_SetDecimation(hIsp, &decimation);
3401e678:	f107 0314 	add.w	r3, r7, #20
3401e67c:	4619      	mov	r1, r3
3401e67e:	68f8      	ldr	r0, [r7, #12]
3401e680:	f000 fd28 	bl	3401f0d4 <ISP_SVC_ISP_SetDecimation>
3401e684:	4603      	mov	r3, r0
3401e686:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3401e688:	7dfb      	ldrb	r3, [r7, #23]
3401e68a:	2b00      	cmp	r3, #0
3401e68c:	d001      	beq.n	3401e692 <ISP_Init+0x166>
  {
    return ret;
3401e68e:	7dfb      	ldrb	r3, [r7, #23]
3401e690:	e00d      	b.n	3401e6ae <ISP_Init+0x182>
  }

  /* Initialize algorithms */
  ret = ISP_Algo_Init(hIsp);
3401e692:	68f8      	ldr	r0, [r7, #12]
3401e694:	f7ff fec0 	bl	3401e418 <ISP_Algo_Init>
3401e698:	4603      	mov	r3, r0
3401e69a:	75fb      	strb	r3, [r7, #23]
  if (ret != ISP_OK)
3401e69c:	7dfb      	ldrb	r3, [r7, #23]
3401e69e:	2b00      	cmp	r3, #0
3401e6a0:	d001      	beq.n	3401e6a6 <ISP_Init+0x17a>
  {
    return ret;
3401e6a2:	7dfb      	ldrb	r3, [r7, #23]
3401e6a4:	e003      	b.n	3401e6ae <ISP_Init+0x182>
  }

  /* Initialize the statistic engine */
  ISP_SVC_Stats_Init(hIsp);
3401e6a6:	68f8      	ldr	r0, [r7, #12]
3401e6a8:	f001 fa86 	bl	3401fbb8 <ISP_SVC_Stats_Init>

  return ISP_OK;
3401e6ac:	2300      	movs	r3, #0
}
3401e6ae:	4618      	mov	r0, r3
3401e6b0:	3718      	adds	r7, #24
3401e6b2:	46bd      	mov	sp, r7
3401e6b4:	bdb0      	pop	{r4, r5, r7, pc}
3401e6b6:	bf00      	nop
3401e6b8:	3402b494 	.word	0x3402b494
3401e6bc:	3402b4cc 	.word	0x3402b4cc
3401e6c0:	3402b504 	.word	0x3402b504
3401e6c4:	3402b53c 	.word	0x3402b53c
3401e6c8:	3402b578 	.word	0x3402b578
3401e6cc:	3402b5b4 	.word	0x3402b5b4

3401e6d0 <ISP_DeInit>:
  *         Deinitializes the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_DeInit(ISP_HandleTypeDef *hIsp)
{
3401e6d0:	b580      	push	{r7, lr}
3401e6d2:	b084      	sub	sp, #16
3401e6d4:	af00      	add	r7, sp, #0
3401e6d6:	6078      	str	r0, [r7, #4]
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
3401e6d8:	687b      	ldr	r3, [r7, #4]
3401e6da:	2b00      	cmp	r3, #0
3401e6dc:	d101      	bne.n	3401e6e2 <ISP_DeInit+0x12>
  {
    return ISP_ERR_EINVAL;
3401e6de:	2301      	movs	r3, #1
3401e6e0:	e00f      	b.n	3401e702 <ISP_DeInit+0x32>
  }

  /* DeInitialize algorithms */
  ret = ISP_Algo_DeInit(hIsp);
3401e6e2:	6878      	ldr	r0, [r7, #4]
3401e6e4:	f7ff feca 	bl	3401e47c <ISP_Algo_DeInit>
3401e6e8:	4603      	mov	r3, r0
3401e6ea:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e6ec:	7bfb      	ldrb	r3, [r7, #15]
3401e6ee:	2b00      	cmp	r3, #0
3401e6f0:	d001      	beq.n	3401e6f6 <ISP_DeInit+0x26>
  {
    return ret;
3401e6f2:	7bfb      	ldrb	r3, [r7, #15]
3401e6f4:	e005      	b.n	3401e702 <ISP_DeInit+0x32>
  }

  /* Re-initialized the hIsp structure */
  memset(hIsp, 0, sizeof(*hIsp));
3401e6f6:	2288      	movs	r2, #136	@ 0x88
3401e6f8:	2100      	movs	r1, #0
3401e6fa:	6878      	ldr	r0, [r7, #4]
3401e6fc:	f008 fd4a 	bl	34027194 <memset>

  return ISP_OK;
3401e700:	2300      	movs	r3, #0
}
3401e702:	4618      	mov	r0, r3
3401e704:	3710      	adds	r7, #16
3401e706:	46bd      	mov	sp, r7
3401e708:	bd80      	pop	{r7, pc}
3401e70a:	0000      	movs	r0, r0
3401e70c:	0000      	movs	r0, r0
	...

3401e710 <ISP_Start>:
  *         Configures the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_Start(ISP_HandleTypeDef *hIsp)
{
3401e710:	b590      	push	{r4, r7, lr}
3401e712:	b085      	sub	sp, #20
3401e714:	af00      	add	r7, sp, #0
3401e716:	6078      	str	r0, [r7, #4]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_StatusTypeDef ret;

  if (hIsp == NULL)
3401e718:	687b      	ldr	r3, [r7, #4]
3401e71a:	2b00      	cmp	r3, #0
3401e71c:	d101      	bne.n	3401e722 <ISP_Start+0x12>
  {
    return ISP_ERR_EINVAL;
3401e71e:	2301      	movs	r3, #1
3401e720:	e0fe      	b.n	3401e920 <ISP_Start+0x210>
  }

  ret = ISP_SVC_Misc_IsDCMIPPReady(hIsp);
3401e722:	6878      	ldr	r0, [r7, #4]
3401e724:	f001 f95e 	bl	3401f9e4 <ISP_SVC_Misc_IsDCMIPPReady>
3401e728:	4603      	mov	r3, r0
3401e72a:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e72c:	7bfb      	ldrb	r3, [r7, #15]
3401e72e:	2b00      	cmp	r3, #0
3401e730:	d001      	beq.n	3401e736 <ISP_Start+0x26>
  {
    return ret;
3401e732:	7bfb      	ldrb	r3, [r7, #15]
3401e734:	e0f4      	b.n	3401e920 <ISP_Start+0x210>
  }

  /* Get IQ Param config */
  IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401e736:	6878      	ldr	r0, [r7, #4]
3401e738:	f001 fa30 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401e73c:	60b8      	str	r0, [r7, #8]

  /* Set static configurations */
  ret = ISP_SVC_ISP_SetDemosaicing(hIsp, &IQParamConfig->demosaicing);
3401e73e:	68bb      	ldr	r3, [r7, #8]
3401e740:	330c      	adds	r3, #12
3401e742:	4619      	mov	r1, r3
3401e744:	6878      	ldr	r0, [r7, #4]
3401e746:	f000 fc09 	bl	3401ef5c <ISP_SVC_ISP_SetDemosaicing>
3401e74a:	4603      	mov	r3, r0
3401e74c:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e74e:	7bfb      	ldrb	r3, [r7, #15]
3401e750:	2b00      	cmp	r3, #0
3401e752:	d001      	beq.n	3401e758 <ISP_Start+0x48>
  {
    return ret;
3401e754:	7bfb      	ldrb	r3, [r7, #15]
3401e756:	e0e3      	b.n	3401e920 <ISP_Start+0x210>
  }

  ret = ISP_SVC_ISP_SetStatRemoval(hIsp, &IQParamConfig->statRemoval);
3401e758:	68bb      	ldr	r3, [r7, #8]
3401e75a:	4619      	mov	r1, r3
3401e75c:	6878      	ldr	r0, [r7, #4]
3401e75e:	f000 fc75 	bl	3401f04c <ISP_SVC_ISP_SetStatRemoval>
3401e762:	4603      	mov	r3, r0
3401e764:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e766:	7bfb      	ldrb	r3, [r7, #15]
3401e768:	2b00      	cmp	r3, #0
3401e76a:	d001      	beq.n	3401e770 <ISP_Start+0x60>
  {
    return ret;
3401e76c:	7bfb      	ldrb	r3, [r7, #15]
3401e76e:	e0d7      	b.n	3401e920 <ISP_Start+0x210>
  }

  ret = ISP_SVC_ISP_SetContrast(hIsp, &IQParamConfig->contrast);
3401e770:	68bb      	ldr	r3, [r7, #8]
3401e772:	3314      	adds	r3, #20
3401e774:	4619      	mov	r1, r3
3401e776:	6878      	ldr	r0, [r7, #4]
3401e778:	f000 fd0e 	bl	3401f198 <ISP_SVC_ISP_SetContrast>
3401e77c:	4603      	mov	r3, r0
3401e77e:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e780:	7bfb      	ldrb	r3, [r7, #15]
3401e782:	2b00      	cmp	r3, #0
3401e784:	d001      	beq.n	3401e78a <ISP_Start+0x7a>
  {
    return ret;
3401e786:	7bfb      	ldrb	r3, [r7, #15]
3401e788:	e0ca      	b.n	3401e920 <ISP_Start+0x210>
  }

  /* Set optional static configurations */
  if ((IQParamConfig->sensorGainStatic.gain != 0) && (!IQParamConfig->AECAlgo.enable))
3401e78a:	68bb      	ldr	r3, [r7, #8]
3401e78c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3401e78e:	2b00      	cmp	r3, #0
3401e790:	d011      	beq.n	3401e7b6 <ISP_Start+0xa6>
3401e792:	68bb      	ldr	r3, [r7, #8]
3401e794:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
3401e798:	2b00      	cmp	r3, #0
3401e79a:	d10c      	bne.n	3401e7b6 <ISP_Start+0xa6>
  {
    ret = ISP_SVC_Sensor_SetGain(hIsp, &IQParamConfig->sensorGainStatic);
3401e79c:	68bb      	ldr	r3, [r7, #8]
3401e79e:	334c      	adds	r3, #76	@ 0x4c
3401e7a0:	4619      	mov	r1, r3
3401e7a2:	6878      	ldr	r0, [r7, #4]
3401e7a4:	f001 f894 	bl	3401f8d0 <ISP_SVC_Sensor_SetGain>
3401e7a8:	4603      	mov	r3, r0
3401e7aa:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e7ac:	7bfb      	ldrb	r3, [r7, #15]
3401e7ae:	2b00      	cmp	r3, #0
3401e7b0:	d001      	beq.n	3401e7b6 <ISP_Start+0xa6>
    {
      return ret;
3401e7b2:	7bfb      	ldrb	r3, [r7, #15]
3401e7b4:	e0b4      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  if ((IQParamConfig->sensorExposureStatic.exposure != 0) && (!IQParamConfig->AECAlgo.enable))
3401e7b6:	68bb      	ldr	r3, [r7, #8]
3401e7b8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
3401e7ba:	2b00      	cmp	r3, #0
3401e7bc:	d011      	beq.n	3401e7e2 <ISP_Start+0xd2>
3401e7be:	68bb      	ldr	r3, [r7, #8]
3401e7c0:	f893 3068 	ldrb.w	r3, [r3, #104]	@ 0x68
3401e7c4:	2b00      	cmp	r3, #0
3401e7c6:	d10c      	bne.n	3401e7e2 <ISP_Start+0xd2>
  {
    ret = ISP_SVC_Sensor_SetExposure(hIsp, &IQParamConfig->sensorExposureStatic);
3401e7c8:	68bb      	ldr	r3, [r7, #8]
3401e7ca:	3350      	adds	r3, #80	@ 0x50
3401e7cc:	4619      	mov	r1, r3
3401e7ce:	6878      	ldr	r0, [r7, #4]
3401e7d0:	f001 f8c3 	bl	3401f95a <ISP_SVC_Sensor_SetExposure>
3401e7d4:	4603      	mov	r3, r0
3401e7d6:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e7d8:	7bfb      	ldrb	r3, [r7, #15]
3401e7da:	2b00      	cmp	r3, #0
3401e7dc:	d001      	beq.n	3401e7e2 <ISP_Start+0xd2>
    {
      return ret;
3401e7de:	7bfb      	ldrb	r3, [r7, #15]
3401e7e0:	e09e      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  if (IQParamConfig->badPixelStatic.enable != 0)
3401e7e2:	68bb      	ldr	r3, [r7, #8]
3401e7e4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
3401e7e8:	2b00      	cmp	r3, #0
3401e7ea:	d00c      	beq.n	3401e806 <ISP_Start+0xf6>
  {
    ret = ISP_SVC_ISP_SetBadPixel(hIsp, &IQParamConfig->badPixelStatic);
3401e7ec:	68bb      	ldr	r3, [r7, #8]
3401e7ee:	335c      	adds	r3, #92	@ 0x5c
3401e7f0:	4619      	mov	r1, r3
3401e7f2:	6878      	ldr	r0, [r7, #4]
3401e7f4:	f000 fe08 	bl	3401f408 <ISP_SVC_ISP_SetBadPixel>
3401e7f8:	4603      	mov	r3, r0
3401e7fa:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e7fc:	7bfb      	ldrb	r3, [r7, #15]
3401e7fe:	2b00      	cmp	r3, #0
3401e800:	d001      	beq.n	3401e806 <ISP_Start+0xf6>
    {
      return ret;
3401e802:	7bfb      	ldrb	r3, [r7, #15]
3401e804:	e08c      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  if (IQParamConfig->blackLevelStatic.enable != 0)
3401e806:	68bb      	ldr	r3, [r7, #8]
3401e808:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
3401e80c:	2b00      	cmp	r3, #0
3401e80e:	d00c      	beq.n	3401e82a <ISP_Start+0x11a>
  {
    ret = ISP_SVC_ISP_SetBlackLevel(hIsp, &IQParamConfig->blackLevelStatic);
3401e810:	68bb      	ldr	r3, [r7, #8]
3401e812:	3364      	adds	r3, #100	@ 0x64
3401e814:	4619      	mov	r1, r3
3401e816:	6878      	ldr	r0, [r7, #4]
3401e818:	f000 fe6a 	bl	3401f4f0 <ISP_SVC_ISP_SetBlackLevel>
3401e81c:	4603      	mov	r3, r0
3401e81e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e820:	7bfb      	ldrb	r3, [r7, #15]
3401e822:	2b00      	cmp	r3, #0
3401e824:	d001      	beq.n	3401e82a <ISP_Start+0x11a>
    {
      return ret;
3401e826:	7bfb      	ldrb	r3, [r7, #15]
3401e828:	e07a      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  if ((IQParamConfig->ispGainStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401e82a:	68bb      	ldr	r3, [r7, #8]
3401e82c:	f893 3218 	ldrb.w	r3, [r3, #536]	@ 0x218
3401e830:	2b00      	cmp	r3, #0
3401e832:	d012      	beq.n	3401e85a <ISP_Start+0x14a>
3401e834:	68bb      	ldr	r3, [r7, #8]
3401e836:	f893 3070 	ldrb.w	r3, [r3, #112]	@ 0x70
3401e83a:	2b00      	cmp	r3, #0
3401e83c:	d10d      	bne.n	3401e85a <ISP_Start+0x14a>
  {
    ret = ISP_SVC_ISP_SetGain(hIsp, &IQParamConfig->ispGainStatic);
3401e83e:	68bb      	ldr	r3, [r7, #8]
3401e840:	f503 7306 	add.w	r3, r3, #536	@ 0x218
3401e844:	4619      	mov	r1, r3
3401e846:	6878      	ldr	r0, [r7, #4]
3401e848:	f000 fe94 	bl	3401f574 <ISP_SVC_ISP_SetGain>
3401e84c:	4603      	mov	r3, r0
3401e84e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e850:	7bfb      	ldrb	r3, [r7, #15]
3401e852:	2b00      	cmp	r3, #0
3401e854:	d001      	beq.n	3401e85a <ISP_Start+0x14a>
    {
      return ret;
3401e856:	7bfb      	ldrb	r3, [r7, #15]
3401e858:	e062      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  if ((IQParamConfig->colorConvStatic.enable != 0) && (!IQParamConfig->AWBAlgo.enable))
3401e85a:	68bb      	ldr	r3, [r7, #8]
3401e85c:	f893 3228 	ldrb.w	r3, [r3, #552]	@ 0x228
3401e860:	2b00      	cmp	r3, #0
3401e862:	d012      	beq.n	3401e88a <ISP_Start+0x17a>
3401e864:	68bb      	ldr	r3, [r7, #8]
3401e866:	f893 3070 	ldrb.w	r3, [r3, #112]	@ 0x70
3401e86a:	2b00      	cmp	r3, #0
3401e86c:	d10d      	bne.n	3401e88a <ISP_Start+0x17a>
  {
    ret = ISP_SVC_ISP_SetColorConv(hIsp, &IQParamConfig->colorConvStatic);
3401e86e:	68bb      	ldr	r3, [r7, #8]
3401e870:	f503 730a 	add.w	r3, r3, #552	@ 0x228
3401e874:	4619      	mov	r1, r3
3401e876:	6878      	ldr	r0, [r7, #4]
3401e878:	f000 fee6 	bl	3401f648 <ISP_SVC_ISP_SetColorConv>
3401e87c:	4603      	mov	r3, r0
3401e87e:	73fb      	strb	r3, [r7, #15]
    if (ret != ISP_OK)
3401e880:	7bfb      	ldrb	r3, [r7, #15]
3401e882:	2b00      	cmp	r3, #0
3401e884:	d001      	beq.n	3401e88a <ISP_Start+0x17a>
    {
      return ret;
3401e886:	7bfb      	ldrb	r3, [r7, #15]
3401e888:	e04a      	b.n	3401e920 <ISP_Start+0x210>
    }
  }

  /* Configure statistic area (defined by the application or by an optional static configuration) */
  /* Get its config from IQ params if it was not provided by the application at ISP_Init() */
  if ((hIsp->statArea.XSize == 0) || (hIsp->statArea.YSize == 0))
3401e88a:	687b      	ldr	r3, [r7, #4]
3401e88c:	691b      	ldr	r3, [r3, #16]
3401e88e:	2b00      	cmp	r3, #0
3401e890:	d003      	beq.n	3401e89a <ISP_Start+0x18a>
3401e892:	687b      	ldr	r3, [r7, #4]
3401e894:	695b      	ldr	r3, [r3, #20]
3401e896:	2b00      	cmp	r3, #0
3401e898:	d107      	bne.n	3401e8aa <ISP_Start+0x19a>
  {
    hIsp->statArea = IQParamConfig->statAreaStatic;
3401e89a:	687a      	ldr	r2, [r7, #4]
3401e89c:	68bb      	ldr	r3, [r7, #8]
3401e89e:	f102 0408 	add.w	r4, r2, #8
3401e8a2:	333c      	adds	r3, #60	@ 0x3c
3401e8a4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
3401e8a6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  }
  ret = ISP_SVC_ISP_SetStatArea(hIsp, &hIsp->statArea);
3401e8aa:	687b      	ldr	r3, [r7, #4]
3401e8ac:	3308      	adds	r3, #8
3401e8ae:	4619      	mov	r1, r3
3401e8b0:	6878      	ldr	r0, [r7, #4]
3401e8b2:	f000 fd2b 	bl	3401f30c <ISP_SVC_ISP_SetStatArea>
3401e8b6:	4603      	mov	r3, r0
3401e8b8:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e8ba:	7bfb      	ldrb	r3, [r7, #15]
3401e8bc:	2b00      	cmp	r3, #0
3401e8be:	d001      	beq.n	3401e8c4 <ISP_Start+0x1b4>
  {
    return ret;
3401e8c0:	7bfb      	ldrb	r3, [r7, #15]
3401e8c2:	e02d      	b.n	3401e920 <ISP_Start+0x210>
  }

  ret = ISP_SVC_ISP_SetGamma(hIsp, &IQParamConfig->gamma);
3401e8c4:	68bb      	ldr	r3, [r7, #8]
3401e8c6:	f503 7314 	add.w	r3, r3, #592	@ 0x250
3401e8ca:	4619      	mov	r1, r3
3401e8cc:	6878      	ldr	r0, [r7, #4]
3401e8ce:	f001 f909 	bl	3401fae4 <ISP_SVC_ISP_SetGamma>
3401e8d2:	4603      	mov	r3, r0
3401e8d4:	73fb      	strb	r3, [r7, #15]
  if (ret != ISP_OK)
3401e8d6:	7bfb      	ldrb	r3, [r7, #15]
3401e8d8:	2b00      	cmp	r3, #0
3401e8da:	d001      	beq.n	3401e8e0 <ISP_Start+0x1d0>
  {
    return ret;
3401e8dc:	7bfb      	ldrb	r3, [r7, #15]
3401e8de:	e01f      	b.n	3401e920 <ISP_Start+0x210>
  }

  /* Initialize the exposure target based on the selected exposure compensation */
  IQParamConfig->AECAlgo.exposureTarget = (uint32_t) (ISP_IDEAL_TARGET_EXPOSURE * pow(2, (float)IQParamConfig->AECAlgo.exposureCompensation / 2));
3401e8e0:	68bb      	ldr	r3, [r7, #8]
3401e8e2:	f993 3069 	ldrsb.w	r3, [r3, #105]	@ 0x69
3401e8e6:	ee07 3a90 	vmov	s15, r3
3401e8ea:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
3401e8ee:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
3401e8f2:	eec7 7a26 	vdiv.f32	s15, s14, s13
3401e8f6:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
3401e8fa:	eeb0 1b47 	vmov.f64	d1, d7
3401e8fe:	eeb0 0b00 	vmov.f64	d0, #0	@ 0x40000000  2.0
3401e902:	f00a feed 	bl	340296e0 <pow>
3401e906:	eeb0 7b40 	vmov.f64	d7, d0
3401e90a:	ed9f 6b07 	vldr	d6, [pc, #28]	@ 3401e928 <ISP_Start+0x218>
3401e90e:	ee27 7b06 	vmul.f64	d7, d7, d6
3401e912:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3401e916:	ee17 2a90 	vmov	r2, s15
3401e91a:	68bb      	ldr	r3, [r7, #8]
3401e91c:	66da      	str	r2, [r3, #108]	@ 0x6c

  return ISP_OK;
3401e91e:	2300      	movs	r3, #0
}
3401e920:	4618      	mov	r0, r3
3401e922:	3714      	adds	r7, #20
3401e924:	46bd      	mov	sp, r7
3401e926:	bd90      	pop	{r4, r7, pc}
3401e928:	00000000 	.word	0x00000000
3401e92c:	404c0000 	.word	0x404c0000

3401e930 <ISP_BackgroundProcess>:
  *         Run the background process of the ISP device
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_BackgroundProcess(ISP_HandleTypeDef *hIsp)
{
3401e930:	b580      	push	{r7, lr}
3401e932:	b084      	sub	sp, #16
3401e934:	af00      	add	r7, sp, #0
3401e936:	6078      	str	r0, [r7, #4]
#ifdef ISP_MW_TUNING_TOOL_SUPPORT
  ISP_StatusTypeDef retCmdParser = ISP_OK;
  uint8_t *cmd;
#endif

  if (hIsp == NULL)
3401e938:	687b      	ldr	r3, [r7, #4]
3401e93a:	2b00      	cmp	r3, #0
3401e93c:	d101      	bne.n	3401e942 <ISP_BackgroundProcess+0x12>
  {
    return ISP_ERR_EINVAL;
3401e93e:	2301      	movs	r3, #1
3401e940:	e014      	b.n	3401e96c <ISP_BackgroundProcess+0x3c>
    retCmdParser = ISP_CmdParser_ProcessCommand(hIsp, cmd);
  }
#endif

  /* Check if a statistics gathering cycle has been completed to call the statistic callbacks */
  retStats = ISP_SVC_Stats_ProcessCallbacks(hIsp);
3401e942:	6878      	ldr	r0, [r7, #4]
3401e944:	f001 fc12 	bl	3402016c <ISP_SVC_Stats_ProcessCallbacks>
3401e948:	4603      	mov	r3, r0
3401e94a:	73fb      	strb	r3, [r7, #15]

  /* Process the algorithms */
  retAlgo = ISP_Algo_Process(hIsp);
3401e94c:	6878      	ldr	r0, [r7, #4]
3401e94e:	f7ff fdc1 	bl	3401e4d4 <ISP_Algo_Process>
3401e952:	4603      	mov	r3, r0
3401e954:	73bb      	strb	r3, [r7, #14]
  if (retCmdParser != ISP_OK)
  {
    return retCmdParser;
  }
#endif
  if (retStats != ISP_OK)
3401e956:	7bfb      	ldrb	r3, [r7, #15]
3401e958:	2b00      	cmp	r3, #0
3401e95a:	d001      	beq.n	3401e960 <ISP_BackgroundProcess+0x30>
  {
    return retStats;
3401e95c:	7bfb      	ldrb	r3, [r7, #15]
3401e95e:	e005      	b.n	3401e96c <ISP_BackgroundProcess+0x3c>
  }
  else if (retAlgo != ISP_OK)
3401e960:	7bbb      	ldrb	r3, [r7, #14]
3401e962:	2b00      	cmp	r3, #0
3401e964:	d001      	beq.n	3401e96a <ISP_BackgroundProcess+0x3a>
  {
    return retAlgo;
3401e966:	7bbb      	ldrb	r3, [r7, #14]
3401e968:	e000      	b.n	3401e96c <ISP_BackgroundProcess+0x3c>
  }

  return ISP_OK;
3401e96a:	2300      	movs	r3, #0
}
3401e96c:	4618      	mov	r0, r3
3401e96e:	3710      	adds	r7, #16
3401e970:	46bd      	mov	sp, r7
3401e972:	bd80      	pop	{r7, pc}

3401e974 <ISP_GatherStatistics>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_GatherStatistics(ISP_HandleTypeDef *hIsp)
{
3401e974:	b580      	push	{r7, lr}
3401e976:	b082      	sub	sp, #8
3401e978:	af00      	add	r7, sp, #0
3401e97a:	6078      	str	r0, [r7, #4]
  ISP_SVC_Stats_Gather(hIsp);
3401e97c:	6878      	ldr	r0, [r7, #4]
3401e97e:	f001 f92b 	bl	3401fbd8 <ISP_SVC_Stats_Gather>
}
3401e982:	bf00      	nop
3401e984:	3708      	adds	r7, #8
3401e986:	46bd      	mov	sp, r7
3401e988:	bd80      	pop	{r7, pc}

3401e98a <ISP_IncMainFrameId>:
  *         Increment the frame ID of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
3401e98a:	b580      	push	{r7, lr}
3401e98c:	b082      	sub	sp, #8
3401e98e:	af00      	add	r7, sp, #0
3401e990:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncMainFrameId(hIsp);
3401e992:	6878      	ldr	r0, [r7, #4]
3401e994:	f001 f83e 	bl	3401fa14 <ISP_SVC_Misc_IncMainFrameId>
}
3401e998:	bf00      	nop
3401e99a:	3708      	adds	r7, #8
3401e99c:	46bd      	mov	sp, r7
3401e99e:	bd80      	pop	{r7, pc}

3401e9a0 <ISP_IncAncillaryFrameId>:
  *         Increment the frame ID of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
3401e9a0:	b580      	push	{r7, lr}
3401e9a2:	b082      	sub	sp, #8
3401e9a4:	af00      	add	r7, sp, #0
3401e9a6:	6078      	str	r0, [r7, #4]
	ISP_SVC_Misc_IncAncillaryFrameId(hIsp);
3401e9a8:	6878      	ldr	r0, [r7, #4]
3401e9aa:	f001 f84e 	bl	3401fa4a <ISP_SVC_Misc_IncAncillaryFrameId>
}
3401e9ae:	bf00      	nop
3401e9b0:	3708      	adds	r7, #8
3401e9b2:	46bd      	mov	sp, r7
3401e9b4:	bd80      	pop	{r7, pc}

3401e9b6 <ISP_IncDumpFrameId>:
  *         Increment the frame ID of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
3401e9b6:	b580      	push	{r7, lr}
3401e9b8:	b082      	sub	sp, #8
3401e9ba:	af00      	add	r7, sp, #0
3401e9bc:	6078      	str	r0, [r7, #4]
  ISP_SVC_Misc_IncDumpFrameId(hIsp);
3401e9be:	6878      	ldr	r0, [r7, #4]
3401e9c0:	f001 f852 	bl	3401fa68 <ISP_SVC_Misc_IncDumpFrameId>
}
3401e9c4:	bf00      	nop
3401e9c6:	3708      	adds	r7, #8
3401e9c8:	46bd      	mov	sp, r7
3401e9ca:	bd80      	pop	{r7, pc}
3401e9cc:	0000      	movs	r0, r0
	...

3401e9d0 <To_Shift_Multiplier>:

/* Exported variables --------------------------------------------------------*/

/* Private functions ---------------------------------------------------------*/
static void To_Shift_Multiplier(uint32_t Factor, uint8_t *pShift, uint8_t *pMultiplier)
{
3401e9d0:	b5b0      	push	{r4, r5, r7, lr}
3401e9d2:	b086      	sub	sp, #24
3401e9d4:	af00      	add	r7, sp, #0
3401e9d6:	60f8      	str	r0, [r7, #12]
3401e9d8:	60b9      	str	r1, [r7, #8]
3401e9da:	607a      	str	r2, [r7, #4]
  /* Convert Factor (Unit = 100000000 for "x1.0") to Multiplier (where 128 means "x1.0") */
  uint64_t Val = Factor;
3401e9dc:	68fb      	ldr	r3, [r7, #12]
3401e9de:	2200      	movs	r2, #0
3401e9e0:	461c      	mov	r4, r3
3401e9e2:	4615      	mov	r5, r2
3401e9e4:	e9c7 4504 	strd	r4, r5, [r7, #16]
  Val = (Val * 128) / ISP_GAIN_PRECISION_FACTOR;
3401e9e8:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
3401e9ec:	4610      	mov	r0, r2
3401e9ee:	4619      	mov	r1, r3
3401e9f0:	ea50 11cf 	orrs.w	r1, r0, pc, lsl #7
3401e9f4:	a314      	add	r3, pc, #80	@ (adr r3, 3401ea48 <To_Shift_Multiplier+0x78>)
3401e9f6:	e9d3 2300 	ldrd	r2, r3, [r3]
3401e9fa:	f7e3 f8db 	bl	34001bb4 <__aeabi_uldivmod>
3401e9fe:	4602      	mov	r2, r0
3401ea00:	460b      	mov	r3, r1
3401ea02:	e9c7 2304 	strd	r2, r3, [r7, #16]

  /* Get Shift + Multiplier where Multiplier < 256 */
  *pShift = 0;
3401ea06:	68bb      	ldr	r3, [r7, #8]
3401ea08:	2200      	movs	r2, #0
3401ea0a:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
3401ea0c:	e00b      	b.n	3401ea26 <To_Shift_Multiplier+0x56>
  {
    Val /= 2;
3401ea0e:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
3401ea12:	ea52 035f 	orrs.w	r3, r2, pc, lsr #1
3401ea16:	e9c7 2304 	strd	r2, r3, [r7, #16]
    (*pShift)++;
3401ea1a:	68bb      	ldr	r3, [r7, #8]
3401ea1c:	781b      	ldrb	r3, [r3, #0]
3401ea1e:	3301      	adds	r3, #1
3401ea20:	b2da      	uxtb	r2, r3
3401ea22:	68bb      	ldr	r3, [r7, #8]
3401ea24:	701a      	strb	r2, [r3, #0]
  while (Val >= 256)
3401ea26:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
3401ea2a:	f5b2 7f80 	cmp.w	r2, #256	@ 0x100
3401ea2e:	f173 0300 	sbcs.w	r3, r3, #0
3401ea32:	d2ec      	bcs.n	3401ea0e <To_Shift_Multiplier+0x3e>
  }

  *pMultiplier = Val;
3401ea34:	7c3a      	ldrb	r2, [r7, #16]
3401ea36:	687b      	ldr	r3, [r7, #4]
3401ea38:	701a      	strb	r2, [r3, #0]
}
3401ea3a:	bf00      	nop
3401ea3c:	3718      	adds	r7, #24
3401ea3e:	46bd      	mov	sp, r7
3401ea40:	bdb0      	pop	{r4, r5, r7, pc}
3401ea42:	bf00      	nop
3401ea44:	f3af 8000 	nop.w
3401ea48:	05f5e100 	.word	0x05f5e100
3401ea4c:	00000000 	.word	0x00000000

3401ea50 <To_CConv_Reg>:
  Val = (Val * Multiplier * ISP_GAIN_PRECISION_FACTOR) / 128;
  return (uint32_t) Val;
}

static int16_t To_CConv_Reg(int32_t Coeff)
{
3401ea50:	b580      	push	{r7, lr}
3401ea52:	b084      	sub	sp, #16
3401ea54:	af00      	add	r7, sp, #0
3401ea56:	6078      	str	r0, [r7, #4]
  /* Convert Coefficient (Unit = 100000000 for "x1.0") to register format */
  int64_t Val = Coeff;
3401ea58:	6879      	ldr	r1, [r7, #4]
3401ea5a:	17c8      	asrs	r0, r1, #31
3401ea5c:	460a      	mov	r2, r1
3401ea5e:	4603      	mov	r3, r0
3401ea60:	e9c7 2302 	strd	r2, r3, [r7, #8]

  Val = (Val * 256) / ISP_CCM_PRECISION_FACTOR;
3401ea64:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3401ea68:	4a07      	ldr	r2, [pc, #28]	@ (3401ea88 <To_CConv_Reg+0x38>)
3401ea6a:	f04f 0300 	mov.w	r3, #0
3401ea6e:	f7e3 f851 	bl	34001b14 <__aeabi_ldivmod>
3401ea72:	4602      	mov	r2, r0
3401ea74:	460b      	mov	r3, r1
3401ea76:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int16_t) Val;
3401ea7a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
}
3401ea7e:	4618      	mov	r0, r3
3401ea80:	3710      	adds	r7, #16
3401ea82:	46bd      	mov	sp, r7
3401ea84:	bd80      	pop	{r7, pc}
3401ea86:	bf00      	nop
3401ea88:	0005f5e1 	.word	0x0005f5e1

3401ea8c <From_CConv_Reg>:

static int32_t From_CConv_Reg(int16_t Reg)
{
3401ea8c:	b4b0      	push	{r4, r5, r7}
3401ea8e:	b085      	sub	sp, #20
3401ea90:	af00      	add	r7, sp, #0
3401ea92:	4601      	mov	r1, r0
3401ea94:	80f9      	strh	r1, [r7, #6]
  /* Convert from register format to Coefficient (Unit = 100000000 for "x1.0") */
  int64_t Val = Reg;
3401ea96:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
3401ea9a:	17c8      	asrs	r0, r1, #31
3401ea9c:	460c      	mov	r4, r1
3401ea9e:	4605      	mov	r5, r0
3401eaa0:	e9c7 4502 	strd	r4, r5, [r7, #8]

  Val = (Val * ISP_CCM_PRECISION_FACTOR) / 256;
3401eaa4:	68f9      	ldr	r1, [r7, #12]
3401eaa6:	480c      	ldr	r0, [pc, #48]	@ (3401ead8 <From_CConv_Reg+0x4c>)
3401eaa8:	fb01 f000 	mul.w	r0, r1, r0
3401eaac:	68b9      	ldr	r1, [r7, #8]
3401eaae:	2400      	movs	r4, #0
3401eab0:	fb04 f101 	mul.w	r1, r4, r1
3401eab4:	4401      	add	r1, r0
3401eab6:	68b8      	ldr	r0, [r7, #8]
3401eab8:	4c07      	ldr	r4, [pc, #28]	@ (3401ead8 <From_CConv_Reg+0x4c>)
3401eaba:	fba0 2304 	umull	r2, r3, r0, r4
3401eabe:	4419      	add	r1, r3
3401eac0:	460b      	mov	r3, r1
3401eac2:	e9c7 2302 	strd	r2, r3, [r7, #8]
3401eac6:	e9c7 2302 	strd	r2, r3, [r7, #8]

  return (int32_t) Val;
3401eaca:	68bb      	ldr	r3, [r7, #8]
}
3401eacc:	4618      	mov	r0, r3
3401eace:	3714      	adds	r7, #20
3401ead0:	46bd      	mov	sp, r7
3401ead2:	bcb0      	pop	{r4, r5, r7}
3401ead4:	4770      	bx	lr
3401ead6:	bf00      	nop
3401ead8:	0005f5e1 	.word	0x0005f5e1

3401eadc <GetAvgStats>:

static uint8_t GetAvgStats(ISP_HandleTypeDef *hIsp, ISP_SVC_StatLocation location, ISP_SVC_Component component, uint32_t accu)
{
3401eadc:	b480      	push	{r7}
3401eade:	b087      	sub	sp, #28
3401eae0:	af00      	add	r7, sp, #0
3401eae2:	60f8      	str	r0, [r7, #12]
3401eae4:	607b      	str	r3, [r7, #4]
3401eae6:	460b      	mov	r3, r1
3401eae8:	72fb      	strb	r3, [r7, #11]
3401eaea:	4613      	mov	r3, r2
3401eaec:	72bb      	strb	r3, [r7, #10]
  uint32_t nb_comp_pix, comp_divider;

  /* Number of pixels computed from Stat Area and considering decimation */
  nb_comp_pix = hIsp->statArea.XSize * hIsp->statArea.YSize;
3401eaee:	68fb      	ldr	r3, [r7, #12]
3401eaf0:	691b      	ldr	r3, [r3, #16]
3401eaf2:	68fa      	ldr	r2, [r7, #12]
3401eaf4:	6952      	ldr	r2, [r2, #20]
3401eaf6:	fb02 f303 	mul.w	r3, r2, r3
3401eafa:	613b      	str	r3, [r7, #16]
  nb_comp_pix /= ISP_DecimationValue.factor * ISP_DecimationValue.factor;
3401eafc:	4b18      	ldr	r3, [pc, #96]	@ (3401eb60 <GetAvgStats+0x84>)
3401eafe:	781b      	ldrb	r3, [r3, #0]
3401eb00:	461a      	mov	r2, r3
3401eb02:	4b17      	ldr	r3, [pc, #92]	@ (3401eb60 <GetAvgStats+0x84>)
3401eb04:	781b      	ldrb	r3, [r3, #0]
3401eb06:	fb02 f303 	mul.w	r3, r2, r3
3401eb0a:	461a      	mov	r2, r3
3401eb0c:	693b      	ldr	r3, [r7, #16]
3401eb0e:	fbb3 f3f2 	udiv	r3, r3, r2
3401eb12:	613b      	str	r3, [r7, #16]

  if (location == ISP_STAT_LOC_DOWN)
3401eb14:	7afb      	ldrb	r3, [r7, #11]
3401eb16:	2b02      	cmp	r3, #2
3401eb18:	d102      	bne.n	3401eb20 <GetAvgStats+0x44>
  {
    /* RGB format after demosaicing : 1 component per pixel */
    comp_divider = 1;
3401eb1a:	2301      	movs	r3, #1
3401eb1c:	617b      	str	r3, [r7, #20]
3401eb1e:	e006      	b.n	3401eb2e <GetAvgStats+0x52>
  }
  else
  {
    /* Only raw bayer sensor expected */
    /* raw bayer: RGB component not present for all pixels */
    comp_divider = (component == ISP_GREEN) ? 2 : 4;
3401eb20:	7abb      	ldrb	r3, [r7, #10]
3401eb22:	2b01      	cmp	r3, #1
3401eb24:	d101      	bne.n	3401eb2a <GetAvgStats+0x4e>
3401eb26:	2302      	movs	r3, #2
3401eb28:	e000      	b.n	3401eb2c <GetAvgStats+0x50>
3401eb2a:	2304      	movs	r3, #4
3401eb2c:	617b      	str	r3, [r7, #20]
  }

  /* Number of pixels per component */
  nb_comp_pix /= comp_divider;
3401eb2e:	693a      	ldr	r2, [r7, #16]
3401eb30:	697b      	ldr	r3, [r7, #20]
3401eb32:	fbb2 f3f3 	udiv	r3, r2, r3
3401eb36:	613b      	str	r3, [r7, #16]

  /* Compute average (rounding to closest integer) */
  if (nb_comp_pix == 0)
3401eb38:	693b      	ldr	r3, [r7, #16]
3401eb3a:	2b00      	cmp	r3, #0
3401eb3c:	d101      	bne.n	3401eb42 <GetAvgStats+0x66>
  {
    return 0;
3401eb3e:	2300      	movs	r3, #0
3401eb40:	e008      	b.n	3401eb54 <GetAvgStats+0x78>
  }

  return ((accu * 256) + (nb_comp_pix / 2)) / nb_comp_pix;
3401eb42:	687b      	ldr	r3, [r7, #4]
3401eb44:	021a      	lsls	r2, r3, #8
3401eb46:	693b      	ldr	r3, [r7, #16]
3401eb48:	085b      	lsrs	r3, r3, #1
3401eb4a:	441a      	add	r2, r3
3401eb4c:	693b      	ldr	r3, [r7, #16]
3401eb4e:	fbb2 f3f3 	udiv	r3, r2, r3
3401eb52:	b2db      	uxtb	r3, r3
}
3401eb54:	4618      	mov	r0, r3
3401eb56:	371c      	adds	r7, #28
3401eb58:	46bd      	mov	sp, r7
3401eb5a:	f85d 7b04 	ldr.w	r7, [sp], #4
3401eb5e:	4770      	bx	lr
3401eb60:	34041488 	.word	0x34041488

3401eb64 <ReadStatHistogram>:

static void ReadStatHistogram(ISP_HandleTypeDef *hIsp, uint32_t *histogram)
{
3401eb64:	b580      	push	{r7, lr}
3401eb66:	b084      	sub	sp, #16
3401eb68:	af00      	add	r7, sp, #0
3401eb6a:	6078      	str	r0, [r7, #4]
3401eb6c:	6039      	str	r1, [r7, #0]
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401eb6e:	2301      	movs	r3, #1
3401eb70:	60fb      	str	r3, [r7, #12]
3401eb72:	e011      	b.n	3401eb98 <ReadStatHistogram+0x34>
  {
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, i, &(histogram[i - DCMIPP_STATEXT_MODULE1]));
3401eb74:	687b      	ldr	r3, [r7, #4]
3401eb76:	6818      	ldr	r0, [r3, #0]
3401eb78:	68fb      	ldr	r3, [r7, #12]
3401eb7a:	b2d9      	uxtb	r1, r3
3401eb7c:	68fb      	ldr	r3, [r7, #12]
3401eb7e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
3401eb82:	3b01      	subs	r3, #1
3401eb84:	009b      	lsls	r3, r3, #2
3401eb86:	683a      	ldr	r2, [r7, #0]
3401eb88:	4413      	add	r3, r2
3401eb8a:	460a      	mov	r2, r1
3401eb8c:	2101      	movs	r1, #1
3401eb8e:	f7ea ff8e 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
  for (uint32_t i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401eb92:	68fb      	ldr	r3, [r7, #12]
3401eb94:	3301      	adds	r3, #1
3401eb96:	60fb      	str	r3, [r7, #12]
3401eb98:	68fb      	ldr	r3, [r7, #12]
3401eb9a:	2b03      	cmp	r3, #3
3401eb9c:	d9ea      	bls.n	3401eb74 <ReadStatHistogram+0x10>
  }
}
3401eb9e:	bf00      	nop
3401eba0:	bf00      	nop
3401eba2:	3710      	adds	r7, #16
3401eba4:	46bd      	mov	sp, r7
3401eba6:	bd80      	pop	{r7, pc}

3401eba8 <SetStatConfig>:

static void SetStatConfig(DCMIPP_StatisticExtractionConfTypeDef *statConf, const DCMIPP_StatisticExtractionConfTypeDef *refConfig)
{
3401eba8:	b480      	push	{r7}
3401ebaa:	b085      	sub	sp, #20
3401ebac:	af00      	add	r7, sp, #0
3401ebae:	6078      	str	r0, [r7, #4]
3401ebb0:	6039      	str	r1, [r7, #0]
  for (int i = 0; i < 3; i++)
3401ebb2:	2300      	movs	r3, #0
3401ebb4:	60fb      	str	r3, [r7, #12]
3401ebb6:	e00e      	b.n	3401ebd6 <SetStatConfig+0x2e>
  {
    statConf[i] = *refConfig;
3401ebb8:	68fa      	ldr	r2, [r7, #12]
3401ebba:	4613      	mov	r3, r2
3401ebbc:	005b      	lsls	r3, r3, #1
3401ebbe:	4413      	add	r3, r2
3401ebc0:	009b      	lsls	r3, r3, #2
3401ebc2:	461a      	mov	r2, r3
3401ebc4:	687b      	ldr	r3, [r7, #4]
3401ebc6:	4413      	add	r3, r2
3401ebc8:	683a      	ldr	r2, [r7, #0]
3401ebca:	ca07      	ldmia	r2, {r0, r1, r2}
3401ebcc:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  for (int i = 0; i < 3; i++)
3401ebd0:	68fb      	ldr	r3, [r7, #12]
3401ebd2:	3301      	adds	r3, #1
3401ebd4:	60fb      	str	r3, [r7, #12]
3401ebd6:	68fb      	ldr	r3, [r7, #12]
3401ebd8:	2b02      	cmp	r3, #2
3401ebda:	dded      	ble.n	3401ebb8 <SetStatConfig+0x10>
  }
}
3401ebdc:	bf00      	nop
3401ebde:	bf00      	nop
3401ebe0:	3714      	adds	r7, #20
3401ebe2:	46bd      	mov	sp, r7
3401ebe4:	f85d 7b04 	ldr.w	r7, [sp], #4
3401ebe8:	4770      	bx	lr
	...

3401ebec <GetNextStatStage>:

static ISP_SVC_StatEngineStage GetNextStatStage(ISP_SVC_StatEngineStage current)
{
3401ebec:	b480      	push	{r7}
3401ebee:	b085      	sub	sp, #20
3401ebf0:	af00      	add	r7, sp, #0
3401ebf2:	4603      	mov	r3, r0
3401ebf4:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage next = ISP_STAT_CFG_LAST;
3401ebf6:	2309      	movs	r3, #9
3401ebf8:	73fb      	strb	r3, [r7, #15]

  /* Special mode for IQ tuning tool asking for all stats : go the the next step, no skip */
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3401ebfa:	4b73      	ldr	r3, [pc, #460]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ebfc:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ec00:	f003 0304 	and.w	r3, r3, #4
3401ec04:	2b00      	cmp	r3, #0
3401ec06:	d106      	bne.n	3401ec16 <GetNextStatStage+0x2a>
      (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
3401ec08:	4b6f      	ldr	r3, [pc, #444]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ec0a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ec0e:	f003 0304 	and.w	r3, r3, #4
  if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
3401ec12:	2b00      	cmp	r3, #0
3401ec14:	d00a      	beq.n	3401ec2c <GetNextStatStage+0x40>
  {
    next = (ISP_SVC_StatEngineStage) ((current < ISP_STAT_CFG_LAST) ? current + 1 : ISP_STAT_CFG_UP_AVG);
3401ec16:	79fb      	ldrb	r3, [r7, #7]
3401ec18:	2b08      	cmp	r3, #8
3401ec1a:	d803      	bhi.n	3401ec24 <GetNextStatStage+0x38>
3401ec1c:	79fb      	ldrb	r3, [r7, #7]
3401ec1e:	3301      	adds	r3, #1
3401ec20:	b2db      	uxtb	r3, r3
3401ec22:	e000      	b.n	3401ec26 <GetNextStatStage+0x3a>
3401ec24:	2300      	movs	r3, #0
3401ec26:	73fb      	strb	r3, [r7, #15]
    return next;
3401ec28:	7bfb      	ldrb	r3, [r7, #15]
3401ec2a:	e0c7      	b.n	3401edbc <GetNextStatStage+0x1d0>
   * - ISP_STAT_CFG_UP_AVG
   * - ISP_STAT_CFG_UP_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
   * - ISP_STAT_CFG_DOWN_AVG
   * - ISP_STAT_CFG_DOWN_BINS_0_2 + BINS_3_5 + BINS_6_8 + BINS_9_11
  */
  switch (current)
3401ec2c:	79fb      	ldrb	r3, [r7, #7]
3401ec2e:	2b09      	cmp	r3, #9
3401ec30:	f200 80b8 	bhi.w	3401eda4 <GetNextStatStage+0x1b8>
3401ec34:	a201      	add	r2, pc, #4	@ (adr r2, 3401ec3c <GetNextStatStage+0x50>)
3401ec36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401ec3a:	bf00      	nop
3401ec3c:	3401ec65 	.word	0x3401ec65
3401ec40:	3401eda5 	.word	0x3401eda5
3401ec44:	3401eda5 	.word	0x3401eda5
3401ec48:	3401eda5 	.word	0x3401eda5
3401ec4c:	3401ecb5 	.word	0x3401ecb5
3401ec50:	3401ed05 	.word	0x3401ed05
3401ec54:	3401eda5 	.word	0x3401eda5
3401ec58:	3401eda5 	.word	0x3401eda5
3401ec5c:	3401eda5 	.word	0x3401eda5
3401ec60:	3401ed55 	.word	0x3401ed55
  {
  case ISP_STAT_CFG_UP_AVG:
    /* Try Up Bins */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401ec64:	4b58      	ldr	r3, [pc, #352]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ec66:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ec6a:	f003 0302 	and.w	r3, r3, #2
3401ec6e:	2b00      	cmp	r3, #0
3401ec70:	d002      	beq.n	3401ec78 <GetNextStatStage+0x8c>
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
3401ec72:	2301      	movs	r3, #1
3401ec74:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Bins : try Up Avg */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_UP_AVG;
    }
    break;
3401ec76:	e099      	b.n	3401edac <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest &  ISP_STAT_TYPE_AVG)
3401ec78:	4b53      	ldr	r3, [pc, #332]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ec7a:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ec7e:	f003 0301 	and.w	r3, r3, #1
3401ec82:	2b00      	cmp	r3, #0
3401ec84:	d002      	beq.n	3401ec8c <GetNextStatStage+0xa0>
      next = ISP_STAT_CFG_DOWN_AVG;
3401ec86:	2305      	movs	r3, #5
3401ec88:	73fb      	strb	r3, [r7, #15]
    break;
3401ec8a:	e08f      	b.n	3401edac <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401ec8c:	4b4e      	ldr	r3, [pc, #312]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ec8e:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ec92:	f003 0302 	and.w	r3, r3, #2
3401ec96:	2b00      	cmp	r3, #0
3401ec98:	d002      	beq.n	3401eca0 <GetNextStatStage+0xb4>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3401ec9a:	2306      	movs	r3, #6
3401ec9c:	73fb      	strb	r3, [r7, #15]
    break;
3401ec9e:	e085      	b.n	3401edac <GetNextStatStage+0x1c0>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3401eca0:	4b49      	ldr	r3, [pc, #292]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401eca2:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401eca6:	f003 0301 	and.w	r3, r3, #1
3401ecaa:	2b00      	cmp	r3, #0
3401ecac:	d07e      	beq.n	3401edac <GetNextStatStage+0x1c0>
      next = ISP_STAT_CFG_UP_AVG;
3401ecae:	2300      	movs	r3, #0
3401ecb0:	73fb      	strb	r3, [r7, #15]
    break;
3401ecb2:	e07b      	b.n	3401edac <GetNextStatStage+0x1c0>

  case ISP_STAT_CFG_UP_BINS_9_11:
    /* Try Down Avg */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3401ecb4:	4b44      	ldr	r3, [pc, #272]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ecb6:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ecba:	f003 0301 	and.w	r3, r3, #1
3401ecbe:	2b00      	cmp	r3, #0
3401ecc0:	d002      	beq.n	3401ecc8 <GetNextStatStage+0xdc>
    {
      next = ISP_STAT_CFG_DOWN_AVG;
3401ecc2:	2305      	movs	r3, #5
3401ecc4:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Avg : try on Up Bins */
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_UP_BINS_0_2;
    }
    break;
3401ecc6:	e073      	b.n	3401edb0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401ecc8:	4b3f      	ldr	r3, [pc, #252]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ecca:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ecce:	f003 0302 	and.w	r3, r3, #2
3401ecd2:	2b00      	cmp	r3, #0
3401ecd4:	d002      	beq.n	3401ecdc <GetNextStatStage+0xf0>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3401ecd6:	2306      	movs	r3, #6
3401ecd8:	73fb      	strb	r3, [r7, #15]
    break;
3401ecda:	e069      	b.n	3401edb0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3401ecdc:	4b3a      	ldr	r3, [pc, #232]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ecde:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ece2:	f003 0301 	and.w	r3, r3, #1
3401ece6:	2b00      	cmp	r3, #0
3401ece8:	d002      	beq.n	3401ecf0 <GetNextStatStage+0x104>
      next = ISP_STAT_CFG_UP_AVG;
3401ecea:	2300      	movs	r3, #0
3401ecec:	73fb      	strb	r3, [r7, #15]
    break;
3401ecee:	e05f      	b.n	3401edb0 <GetNextStatStage+0x1c4>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401ecf0:	4b35      	ldr	r3, [pc, #212]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ecf2:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ecf6:	f003 0302 	and.w	r3, r3, #2
3401ecfa:	2b00      	cmp	r3, #0
3401ecfc:	d058      	beq.n	3401edb0 <GetNextStatStage+0x1c4>
      next = ISP_STAT_CFG_UP_BINS_0_2;
3401ecfe:	2301      	movs	r3, #1
3401ed00:	73fb      	strb	r3, [r7, #15]
    break;
3401ed02:	e055      	b.n	3401edb0 <GetNextStatStage+0x1c4>

  case ISP_STAT_CFG_DOWN_AVG:
    /* Try Down Bins */
    if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401ed04:	4b30      	ldr	r3, [pc, #192]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed06:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ed0a:	f003 0302 	and.w	r3, r3, #2
3401ed0e:	2b00      	cmp	r3, #0
3401ed10:	d002      	beq.n	3401ed18 <GetNextStatStage+0x12c>
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3401ed12:	2306      	movs	r3, #6
3401ed14:	73fb      	strb	r3, [r7, #15]
    /* Skip Up Bins : try Down Avg */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
    {
      next = ISP_STAT_CFG_DOWN_AVG;
    }
    break;
3401ed16:	e04d      	b.n	3401edb4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3401ed18:	4b2b      	ldr	r3, [pc, #172]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed1a:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ed1e:	f003 0301 	and.w	r3, r3, #1
3401ed22:	2b00      	cmp	r3, #0
3401ed24:	d002      	beq.n	3401ed2c <GetNextStatStage+0x140>
      next = ISP_STAT_CFG_UP_AVG;
3401ed26:	2300      	movs	r3, #0
3401ed28:	73fb      	strb	r3, [r7, #15]
    break;
3401ed2a:	e043      	b.n	3401edb4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401ed2c:	4b26      	ldr	r3, [pc, #152]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed2e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ed32:	f003 0302 	and.w	r3, r3, #2
3401ed36:	2b00      	cmp	r3, #0
3401ed38:	d002      	beq.n	3401ed40 <GetNextStatStage+0x154>
      next = ISP_STAT_CFG_UP_BINS_0_2;
3401ed3a:	2301      	movs	r3, #1
3401ed3c:	73fb      	strb	r3, [r7, #15]
    break;
3401ed3e:	e039      	b.n	3401edb4 <GetNextStatStage+0x1c8>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3401ed40:	4b21      	ldr	r3, [pc, #132]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed42:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ed46:	f003 0301 	and.w	r3, r3, #1
3401ed4a:	2b00      	cmp	r3, #0
3401ed4c:	d032      	beq.n	3401edb4 <GetNextStatStage+0x1c8>
      next = ISP_STAT_CFG_DOWN_AVG;
3401ed4e:	2305      	movs	r3, #5
3401ed50:	73fb      	strb	r3, [r7, #15]
    break;
3401ed52:	e02f      	b.n	3401edb4 <GetNextStatStage+0x1c8>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    /* Try Up Avg */
    if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG)
3401ed54:	4b1c      	ldr	r3, [pc, #112]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed56:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ed5a:	f003 0301 	and.w	r3, r3, #1
3401ed5e:	2b00      	cmp	r3, #0
3401ed60:	d002      	beq.n	3401ed68 <GetNextStatStage+0x17c>
    {
      next = ISP_STAT_CFG_UP_AVG;
3401ed62:	2300      	movs	r3, #0
3401ed64:	73fb      	strb	r3, [r7, #15]
    /* Skip Down Avg : try Down Bins */
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
    {
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
    }
    break;
3401ed66:	e027      	b.n	3401edb8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS)
3401ed68:	4b17      	ldr	r3, [pc, #92]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed6a:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ed6e:	f003 0302 	and.w	r3, r3, #2
3401ed72:	2b00      	cmp	r3, #0
3401ed74:	d002      	beq.n	3401ed7c <GetNextStatStage+0x190>
      next = ISP_STAT_CFG_UP_BINS_0_2;
3401ed76:	2301      	movs	r3, #1
3401ed78:	73fb      	strb	r3, [r7, #15]
    break;
3401ed7a:	e01d      	b.n	3401edb8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG)
3401ed7c:	4b12      	ldr	r3, [pc, #72]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed7e:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ed82:	f003 0301 	and.w	r3, r3, #1
3401ed86:	2b00      	cmp	r3, #0
3401ed88:	d002      	beq.n	3401ed90 <GetNextStatStage+0x1a4>
      next = ISP_STAT_CFG_DOWN_AVG;
3401ed8a:	2305      	movs	r3, #5
3401ed8c:	73fb      	strb	r3, [r7, #15]
    break;
3401ed8e:	e013      	b.n	3401edb8 <GetNextStatStage+0x1cc>
    else if (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS)
3401ed90:	4b0d      	ldr	r3, [pc, #52]	@ (3401edc8 <GetNextStatStage+0x1dc>)
3401ed92:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ed96:	f003 0302 	and.w	r3, r3, #2
3401ed9a:	2b00      	cmp	r3, #0
3401ed9c:	d00c      	beq.n	3401edb8 <GetNextStatStage+0x1cc>
      next = ISP_STAT_CFG_DOWN_BINS_0_2;
3401ed9e:	2306      	movs	r3, #6
3401eda0:	73fb      	strb	r3, [r7, #15]
    break;
3401eda2:	e009      	b.n	3401edb8 <GetNextStatStage+0x1cc>

  default:
    /* In the middle of the bins measurement: continue with the next bins part */
    next = (ISP_SVC_StatEngineStage) (current + 1);
3401eda4:	79fb      	ldrb	r3, [r7, #7]
3401eda6:	3301      	adds	r3, #1
3401eda8:	73fb      	strb	r3, [r7, #15]
    break;
3401edaa:	e006      	b.n	3401edba <GetNextStatStage+0x1ce>
    break;
3401edac:	bf00      	nop
3401edae:	e004      	b.n	3401edba <GetNextStatStage+0x1ce>
    break;
3401edb0:	bf00      	nop
3401edb2:	e002      	b.n	3401edba <GetNextStatStage+0x1ce>
    break;
3401edb4:	bf00      	nop
3401edb6:	e000      	b.n	3401edba <GetNextStatStage+0x1ce>
    break;
3401edb8:	bf00      	nop
  }

  return next;
3401edba:	7bfb      	ldrb	r3, [r7, #15]
}
3401edbc:	4618      	mov	r0, r3
3401edbe:	3714      	adds	r7, #20
3401edc0:	46bd      	mov	sp, r7
3401edc2:	f85d 7b04 	ldr.w	r7, [sp], #4
3401edc6:	4770      	bx	lr
3401edc8:	3404a954 	.word	0x3404a954

3401edcc <GetStatCycleStart>:

static ISP_SVC_StatEngineStage GetStatCycleStart(ISP_SVC_StatLocation location)
{
3401edcc:	b480      	push	{r7}
3401edce:	b085      	sub	sp, #20
3401edd0:	af00      	add	r7, sp, #0
3401edd2:	4603      	mov	r3, r0
3401edd4:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
3401edd6:	79fb      	ldrb	r3, [r7, #7]
3401edd8:	2b01      	cmp	r3, #1
3401edda:	d113      	bne.n	3401ee04 <GetStatCycleStart+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
3401eddc:	4b16      	ldr	r3, [pc, #88]	@ (3401ee38 <GetStatCycleStart+0x6c>)
3401edde:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ede2:	f003 0301 	and.w	r3, r3, #1
3401ede6:	2b00      	cmp	r3, #0
3401ede8:	d106      	bne.n	3401edf8 <GetStatCycleStart+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
3401edea:	4b13      	ldr	r3, [pc, #76]	@ (3401ee38 <GetStatCycleStart+0x6c>)
3401edec:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401edf0:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_AVG) ||
3401edf4:	2b00      	cmp	r3, #0
3401edf6:	d002      	beq.n	3401edfe <GetStatCycleStart+0x32>
    {
      /* Stat up cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
3401edf8:	2300      	movs	r3, #0
3401edfa:	73fb      	strb	r3, [r7, #15]
3401edfc:	e015      	b.n	3401ee2a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat up cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_UP_BINS_0_2;
3401edfe:	2301      	movs	r3, #1
3401ee00:	73fb      	strb	r3, [r7, #15]
3401ee02:	e012      	b.n	3401ee2a <GetStatCycleStart+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
3401ee04:	4b0c      	ldr	r3, [pc, #48]	@ (3401ee38 <GetStatCycleStart+0x6c>)
3401ee06:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ee0a:	f003 0301 	and.w	r3, r3, #1
3401ee0e:	2b00      	cmp	r3, #0
3401ee10:	d106      	bne.n	3401ee20 <GetStatCycleStart+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
3401ee12:	4b09      	ldr	r3, [pc, #36]	@ (3401ee38 <GetStatCycleStart+0x6c>)
3401ee14:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ee18:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_AVG) ||
3401ee1c:	2b00      	cmp	r3, #0
3401ee1e:	d002      	beq.n	3401ee26 <GetStatCycleStart+0x5a>
    {
      /* Stat down cycle starts with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
3401ee20:	2305      	movs	r3, #5
3401ee22:	73fb      	strb	r3, [r7, #15]
3401ee24:	e001      	b.n	3401ee2a <GetStatCycleStart+0x5e>
    }
    else
    {
      /* Stat down cycle starts with 1st BIN measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_0_2;
3401ee26:	2306      	movs	r3, #6
3401ee28:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
3401ee2a:	7bfb      	ldrb	r3, [r7, #15]
}
3401ee2c:	4618      	mov	r0, r3
3401ee2e:	3714      	adds	r7, #20
3401ee30:	46bd      	mov	sp, r7
3401ee32:	f85d 7b04 	ldr.w	r7, [sp], #4
3401ee36:	4770      	bx	lr
3401ee38:	3404a954 	.word	0x3404a954

3401ee3c <GetStatCycleEnd>:

static ISP_SVC_StatEngineStage GetStatCycleEnd(ISP_SVC_StatLocation location)
{
3401ee3c:	b480      	push	{r7}
3401ee3e:	b085      	sub	sp, #20
3401ee40:	af00      	add	r7, sp, #0
3401ee42:	4603      	mov	r3, r0
3401ee44:	71fb      	strb	r3, [r7, #7]
  ISP_SVC_StatEngineStage stage;

  if (location == ISP_STAT_LOC_UP)
3401ee46:	79fb      	ldrb	r3, [r7, #7]
3401ee48:	2b01      	cmp	r3, #1
3401ee4a:	d113      	bne.n	3401ee74 <GetStatCycleEnd+0x38>
  {
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
3401ee4c:	4b16      	ldr	r3, [pc, #88]	@ (3401eea8 <GetStatCycleEnd+0x6c>)
3401ee4e:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ee52:	f003 0302 	and.w	r3, r3, #2
3401ee56:	2b00      	cmp	r3, #0
3401ee58:	d106      	bne.n	3401ee68 <GetStatCycleEnd+0x2c>
        (ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP))
3401ee5a:	4b13      	ldr	r3, [pc, #76]	@ (3401eea8 <GetStatCycleEnd+0x6c>)
3401ee5c:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
3401ee60:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_BINS) ||
3401ee64:	2b00      	cmp	r3, #0
3401ee66:	d002      	beq.n	3401ee6e <GetStatCycleEnd+0x32>
    {
      /* Stat up cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_UP_BINS_9_11;
3401ee68:	2304      	movs	r3, #4
3401ee6a:	73fb      	strb	r3, [r7, #15]
3401ee6c:	e015      	b.n	3401ee9a <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat up cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_UP_AVG;
3401ee6e:	2300      	movs	r3, #0
3401ee70:	73fb      	strb	r3, [r7, #15]
3401ee72:	e012      	b.n	3401ee9a <GetStatCycleEnd+0x5e>
    }
  }
  else
  {
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
3401ee74:	4b0c      	ldr	r3, [pc, #48]	@ (3401eea8 <GetStatCycleEnd+0x6c>)
3401ee76:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ee7a:	f003 0302 	and.w	r3, r3, #2
3401ee7e:	2b00      	cmp	r3, #0
3401ee80:	d106      	bne.n	3401ee90 <GetStatCycleEnd+0x54>
        (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP))
3401ee82:	4b09      	ldr	r3, [pc, #36]	@ (3401eea8 <GetStatCycleEnd+0x6c>)
3401ee84:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3401ee88:	f003 0304 	and.w	r3, r3, #4
    if ((ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_BINS) ||
3401ee8c:	2b00      	cmp	r3, #0
3401ee8e:	d002      	beq.n	3401ee96 <GetStatCycleEnd+0x5a>
    {
      /* Stat down cycle ends with last BINS measurement */
      stage = ISP_STAT_CFG_DOWN_BINS_9_11;
3401ee90:	2309      	movs	r3, #9
3401ee92:	73fb      	strb	r3, [r7, #15]
3401ee94:	e001      	b.n	3401ee9a <GetStatCycleEnd+0x5e>
    }
    else
    {
      /* Stat down cycle ends with AVG measurement */
      stage = ISP_STAT_CFG_DOWN_AVG;
3401ee96:	2305      	movs	r3, #5
3401ee98:	73fb      	strb	r3, [r7, #15]
    }
  }
  return stage;
3401ee9a:	7bfb      	ldrb	r3, [r7, #15]
}
3401ee9c:	4618      	mov	r0, r3
3401ee9e:	3714      	adds	r7, #20
3401eea0:	46bd      	mov	sp, r7
3401eea2:	f85d 7b04 	ldr.w	r7, [sp], #4
3401eea6:	4770      	bx	lr
3401eea8:	3404a954 	.word	0x3404a954
3401eeac:	00000000 	.word	0x00000000

3401eeb0 <LuminanceFromRGB>:

uint8_t LuminanceFromRGB(uint8_t r, uint8_t g, uint8_t b)
{
3401eeb0:	b480      	push	{r7}
3401eeb2:	b083      	sub	sp, #12
3401eeb4:	af00      	add	r7, sp, #0
3401eeb6:	4603      	mov	r3, r0
3401eeb8:	71fb      	strb	r3, [r7, #7]
3401eeba:	460b      	mov	r3, r1
3401eebc:	71bb      	strb	r3, [r7, #6]
3401eebe:	4613      	mov	r3, r2
3401eec0:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components (BT.601) */
  return (uint8_t) (r * 0.299 + g * 0.587 + b * 0.114);
3401eec2:	79fb      	ldrb	r3, [r7, #7]
3401eec4:	ee07 3a90 	vmov	s15, r3
3401eec8:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401eecc:	ed9f 6b12 	vldr	d6, [pc, #72]	@ 3401ef18 <LuminanceFromRGB+0x68>
3401eed0:	ee27 6b06 	vmul.f64	d6, d7, d6
3401eed4:	79bb      	ldrb	r3, [r7, #6]
3401eed6:	ee07 3a90 	vmov	s15, r3
3401eeda:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401eede:	ed9f 5b10 	vldr	d5, [pc, #64]	@ 3401ef20 <LuminanceFromRGB+0x70>
3401eee2:	ee27 7b05 	vmul.f64	d7, d7, d5
3401eee6:	ee36 6b07 	vadd.f64	d6, d6, d7
3401eeea:	797b      	ldrb	r3, [r7, #5]
3401eeec:	ee07 3a90 	vmov	s15, r3
3401eef0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
3401eef4:	ed9f 5b0c 	vldr	d5, [pc, #48]	@ 3401ef28 <LuminanceFromRGB+0x78>
3401eef8:	ee27 7b05 	vmul.f64	d7, d7, d5
3401eefc:	ee36 7b07 	vadd.f64	d7, d6, d7
3401ef00:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3401ef04:	edc7 7a00 	vstr	s15, [r7]
3401ef08:	783b      	ldrb	r3, [r7, #0]
3401ef0a:	b2db      	uxtb	r3, r3
}
3401ef0c:	4618      	mov	r0, r3
3401ef0e:	370c      	adds	r7, #12
3401ef10:	46bd      	mov	sp, r7
3401ef12:	f85d 7b04 	ldr.w	r7, [sp], #4
3401ef16:	4770      	bx	lr
3401ef18:	e5604189 	.word	0xe5604189
3401ef1c:	3fd322d0 	.word	0x3fd322d0
3401ef20:	39581062 	.word	0x39581062
3401ef24:	3fe2c8b4 	.word	0x3fe2c8b4
3401ef28:	9fbe76c9 	.word	0x9fbe76c9
3401ef2c:	3fbd2f1a 	.word	0x3fbd2f1a

3401ef30 <LuminanceFromRGBMono>:

uint8_t LuminanceFromRGBMono(uint8_t r, uint8_t g, uint8_t b)
{
3401ef30:	b480      	push	{r7}
3401ef32:	b083      	sub	sp, #12
3401ef34:	af00      	add	r7, sp, #0
3401ef36:	4603      	mov	r3, r0
3401ef38:	71fb      	strb	r3, [r7, #7]
3401ef3a:	460b      	mov	r3, r1
3401ef3c:	71bb      	strb	r3, [r7, #6]
3401ef3e:	4613      	mov	r3, r2
3401ef40:	717b      	strb	r3, [r7, #5]
  /* Compute luminance from RGB components
   * by adding together R, G, B components for monochrome sensor */
  return r + g + b;
3401ef42:	79fa      	ldrb	r2, [r7, #7]
3401ef44:	79bb      	ldrb	r3, [r7, #6]
3401ef46:	4413      	add	r3, r2
3401ef48:	b2da      	uxtb	r2, r3
3401ef4a:	797b      	ldrb	r3, [r7, #5]
3401ef4c:	4413      	add	r3, r2
3401ef4e:	b2db      	uxtb	r3, r3
}
3401ef50:	4618      	mov	r0, r3
3401ef52:	370c      	adds	r7, #12
3401ef54:	46bd      	mov	sp, r7
3401ef56:	f85d 7b04 	ldr.w	r7, [sp], #4
3401ef5a:	4770      	bx	lr

3401ef5c <ISP_SVC_ISP_SetDemosaicing>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the demosaicing configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDemosaicing(ISP_HandleTypeDef *hIsp, ISP_DemosaicingTypeDef *pConfig)
{
3401ef5c:	b580      	push	{r7, lr}
3401ef5e:	b088      	sub	sp, #32
3401ef60:	af00      	add	r7, sp, #0
3401ef62:	6078      	str	r0, [r7, #4]
3401ef64:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_RawBayer2RGBConfTypeDef rawBayerCfg;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401ef66:	687b      	ldr	r3, [r7, #4]
3401ef68:	2b00      	cmp	r3, #0
3401ef6a:	d012      	beq.n	3401ef92 <ISP_SVC_ISP_SetDemosaicing+0x36>
3401ef6c:	683b      	ldr	r3, [r7, #0]
3401ef6e:	2b00      	cmp	r3, #0
3401ef70:	d00f      	beq.n	3401ef92 <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401ef72:	683b      	ldr	r3, [r7, #0]
3401ef74:	789b      	ldrb	r3, [r3, #2]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401ef76:	2b07      	cmp	r3, #7
3401ef78:	d80b      	bhi.n	3401ef92 <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401ef7a:	683b      	ldr	r3, [r7, #0]
3401ef7c:	78db      	ldrb	r3, [r3, #3]
3401ef7e:	2b07      	cmp	r3, #7
3401ef80:	d807      	bhi.n	3401ef92 <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
3401ef82:	683b      	ldr	r3, [r7, #0]
3401ef84:	791b      	ldrb	r3, [r3, #4]
      (pConfig->peak > ISP_DEMOS_STRENGTH_MAX) || (pConfig->lineV > ISP_DEMOS_STRENGTH_MAX) ||
3401ef86:	2b07      	cmp	r3, #7
3401ef88:	d803      	bhi.n	3401ef92 <ISP_SVC_ISP_SetDemosaicing+0x36>
      (pConfig->lineH > ISP_DEMOS_STRENGTH_MAX) || (pConfig->edge > ISP_DEMOS_STRENGTH_MAX))
3401ef8a:	683b      	ldr	r3, [r7, #0]
3401ef8c:	795b      	ldrb	r3, [r3, #5]
3401ef8e:	2b07      	cmp	r3, #7
3401ef90:	d901      	bls.n	3401ef96 <ISP_SVC_ISP_SetDemosaicing+0x3a>
  {
    return ISP_ERR_DEMOSAICING_EINVAL;
3401ef92:	230a      	movs	r3, #10
3401ef94:	e056      	b.n	3401f044 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  /* Do not enable demosaicing if the camera sensor is a monochrome sensor */
  if ((pConfig->enable == 0) || (pConfig->type == ISP_DEMOS_TYPE_MONO))
3401ef96:	683b      	ldr	r3, [r7, #0]
3401ef98:	781b      	ldrb	r3, [r3, #0]
3401ef9a:	2b00      	cmp	r3, #0
3401ef9c:	d003      	beq.n	3401efa6 <ISP_SVC_ISP_SetDemosaicing+0x4a>
3401ef9e:	683b      	ldr	r3, [r7, #0]
3401efa0:	785b      	ldrb	r3, [r3, #1]
3401efa2:	2b04      	cmp	r3, #4
3401efa4:	d108      	bne.n	3401efb8 <ISP_SVC_ISP_SetDemosaicing+0x5c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
3401efa6:	687b      	ldr	r3, [r7, #4]
3401efa8:	681b      	ldr	r3, [r3, #0]
3401efaa:	2101      	movs	r1, #1
3401efac:	4618      	mov	r0, r3
3401efae:	f7e9 fed7 	bl	34008d60 <HAL_DCMIPP_PIPE_DisableISPRawBayer2RGB>
3401efb2:	4603      	mov	r3, r0
3401efb4:	77fb      	strb	r3, [r7, #31]
3401efb6:	e03f      	b.n	3401f038 <ISP_SVC_ISP_SetDemosaicing+0xdc>
  }
  else
  {
    switch(pConfig->type)
3401efb8:	683b      	ldr	r3, [r7, #0]
3401efba:	785b      	ldrb	r3, [r3, #1]
3401efbc:	2b03      	cmp	r3, #3
3401efbe:	d817      	bhi.n	3401eff0 <ISP_SVC_ISP_SetDemosaicing+0x94>
3401efc0:	a201      	add	r2, pc, #4	@ (adr r2, 3401efc8 <ISP_SVC_ISP_SetDemosaicing+0x6c>)
3401efc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401efc6:	bf00      	nop
3401efc8:	3401efd9 	.word	0x3401efd9
3401efcc:	3401efdf 	.word	0x3401efdf
3401efd0:	3401efe5 	.word	0x3401efe5
3401efd4:	3401efeb 	.word	0x3401efeb
    {
      case ISP_DEMOS_TYPE_RGGB:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
3401efd8:	2300      	movs	r3, #0
3401efda:	613b      	str	r3, [r7, #16]
        break;
3401efdc:	e00b      	b.n	3401eff6 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GRBG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GRBG;
3401efde:	2302      	movs	r3, #2
3401efe0:	613b      	str	r3, [r7, #16]
        break;
3401efe2:	e008      	b.n	3401eff6 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_GBRG:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_GBRG;
3401efe4:	2304      	movs	r3, #4
3401efe6:	613b      	str	r3, [r7, #16]
        break;
3401efe8:	e005      	b.n	3401eff6 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      case ISP_DEMOS_TYPE_BGGR:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_BGGR;
3401efea:	2306      	movs	r3, #6
3401efec:	613b      	str	r3, [r7, #16]
        break;
3401efee:	e002      	b.n	3401eff6 <ISP_SVC_ISP_SetDemosaicing+0x9a>
      default:
        rawBayerCfg.RawBayerType = DCMIPP_RAWBAYER_RGGB;
3401eff0:	2300      	movs	r3, #0
3401eff2:	613b      	str	r3, [r7, #16]
        break;
3401eff4:	bf00      	nop
    }

    rawBayerCfg.PeakStrength = (uint32_t) pConfig->peak;
3401eff6:	683b      	ldr	r3, [r7, #0]
3401eff8:	789b      	ldrb	r3, [r3, #2]
3401effa:	617b      	str	r3, [r7, #20]
    rawBayerCfg.VLineStrength = (uint32_t) pConfig->lineV;
3401effc:	683b      	ldr	r3, [r7, #0]
3401effe:	78db      	ldrb	r3, [r3, #3]
3401f000:	60bb      	str	r3, [r7, #8]
    rawBayerCfg.HLineStrength = (uint32_t) pConfig->lineH;
3401f002:	683b      	ldr	r3, [r7, #0]
3401f004:	791b      	ldrb	r3, [r3, #4]
3401f006:	60fb      	str	r3, [r7, #12]
    rawBayerCfg.EdgeStrength = (uint32_t) pConfig->edge;
3401f008:	683b      	ldr	r3, [r7, #0]
3401f00a:	795b      	ldrb	r3, [r3, #5]
3401f00c:	61bb      	str	r3, [r7, #24]
    halStatus = HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &rawBayerCfg);
3401f00e:	687b      	ldr	r3, [r7, #4]
3401f010:	681b      	ldr	r3, [r3, #0]
3401f012:	f107 0208 	add.w	r2, r7, #8
3401f016:	2101      	movs	r1, #1
3401f018:	4618      	mov	r0, r3
3401f01a:	f7e9 fe45 	bl	34008ca8 <HAL_DCMIPP_PIPE_SetISPRawBayer2RGBConfig>
3401f01e:	4603      	mov	r3, r0
3401f020:	77fb      	strb	r3, [r7, #31]

    if (halStatus == HAL_OK)
3401f022:	7ffb      	ldrb	r3, [r7, #31]
3401f024:	2b00      	cmp	r3, #0
3401f026:	d107      	bne.n	3401f038 <ISP_SVC_ISP_SetDemosaicing+0xdc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f028:	687b      	ldr	r3, [r7, #4]
3401f02a:	681b      	ldr	r3, [r3, #0]
3401f02c:	2101      	movs	r1, #1
3401f02e:	4618      	mov	r0, r3
3401f030:	f7e9 fe76 	bl	34008d20 <HAL_DCMIPP_PIPE_EnableISPRawBayer2RGB>
3401f034:	4603      	mov	r3, r0
3401f036:	77fb      	strb	r3, [r7, #31]
    }
  }

  if (halStatus != HAL_OK)
3401f038:	7ffb      	ldrb	r3, [r7, #31]
3401f03a:	2b00      	cmp	r3, #0
3401f03c:	d001      	beq.n	3401f042 <ISP_SVC_ISP_SetDemosaicing+0xe6>
  {
    return ISP_ERR_DEMOSAICING_HAL;
3401f03e:	230b      	movs	r3, #11
3401f040:	e000      	b.n	3401f044 <ISP_SVC_ISP_SetDemosaicing+0xe8>
  }

  return ISP_OK;
3401f042:	2300      	movs	r3, #0
}
3401f044:	4618      	mov	r0, r3
3401f046:	3720      	adds	r7, #32
3401f048:	46bd      	mov	sp, r7
3401f04a:	bd80      	pop	{r7, pc}

3401f04c <ISP_SVC_ISP_SetStatRemoval>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Stat Removal configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatRemoval(ISP_HandleTypeDef *hIsp, ISP_StatRemovalTypeDef *pConfig)
{
3401f04c:	b580      	push	{r7, lr}
3401f04e:	b084      	sub	sp, #16
3401f050:	af00      	add	r7, sp, #0
3401f052:	6078      	str	r0, [r7, #4]
3401f054:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f056:	687b      	ldr	r3, [r7, #4]
3401f058:	2b00      	cmp	r3, #0
3401f05a:	d00c      	beq.n	3401f076 <ISP_SVC_ISP_SetStatRemoval+0x2a>
3401f05c:	683b      	ldr	r3, [r7, #0]
3401f05e:	2b00      	cmp	r3, #0
3401f060:	d009      	beq.n	3401f076 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3401f062:	683b      	ldr	r3, [r7, #0]
3401f064:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f066:	2b07      	cmp	r3, #7
3401f068:	d805      	bhi.n	3401f076 <ISP_SVC_ISP_SetStatRemoval+0x2a>
      (pConfig->nbHeadLines > ISP_STATREMOVAL_HEADLINES_MAX) || (pConfig->nbValidLines > ISP_STATREMOVAL_VALIDLINES_MAX))
3401f06a:	683b      	ldr	r3, [r7, #0]
3401f06c:	689b      	ldr	r3, [r3, #8]
3401f06e:	f640 72fe 	movw	r2, #4094	@ 0xffe
3401f072:	4293      	cmp	r3, r2
3401f074:	d901      	bls.n	3401f07a <ISP_SVC_ISP_SetStatRemoval+0x2e>
  {
    return ISP_ERR_STATREMOVAL_EINVAL;
3401f076:	2314      	movs	r3, #20
3401f078:	e028      	b.n	3401f0cc <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  if (pConfig->enable == 0)
3401f07a:	683b      	ldr	r3, [r7, #0]
3401f07c:	781b      	ldrb	r3, [r3, #0]
3401f07e:	2b00      	cmp	r3, #0
3401f080:	d108      	bne.n	3401f094 <ISP_SVC_ISP_SetStatRemoval+0x48>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f082:	687b      	ldr	r3, [r7, #4]
3401f084:	681b      	ldr	r3, [r3, #0]
3401f086:	2101      	movs	r1, #1
3401f088:	4618      	mov	r0, r3
3401f08a:	f7e9 fed4 	bl	34008e36 <HAL_DCMIPP_PIPE_DisableISPRemovalStatistic>
3401f08e:	4603      	mov	r3, r0
3401f090:	73fb      	strb	r3, [r7, #15]
3401f092:	e015      	b.n	3401f0c0 <ISP_SVC_ISP_SetStatRemoval+0x74>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->nbHeadLines, pConfig->nbValidLines);
3401f094:	687b      	ldr	r3, [r7, #4]
3401f096:	6818      	ldr	r0, [r3, #0]
3401f098:	683b      	ldr	r3, [r7, #0]
3401f09a:	685a      	ldr	r2, [r3, #4]
3401f09c:	683b      	ldr	r3, [r7, #0]
3401f09e:	689b      	ldr	r3, [r3, #8]
3401f0a0:	2101      	movs	r1, #1
3401f0a2:	f7e9 fe7d 	bl	34008da0 <HAL_DCMIPP_PIPE_SetISPRemovalStatisticConfig>
3401f0a6:	4603      	mov	r3, r0
3401f0a8:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3401f0aa:	7bfb      	ldrb	r3, [r7, #15]
3401f0ac:	2b00      	cmp	r3, #0
3401f0ae:	d107      	bne.n	3401f0c0 <ISP_SVC_ISP_SetStatRemoval+0x74>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPRemovalStatistic(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f0b0:	687b      	ldr	r3, [r7, #4]
3401f0b2:	681b      	ldr	r3, [r3, #0]
3401f0b4:	2101      	movs	r1, #1
3401f0b6:	4618      	mov	r0, r3
3401f0b8:	f7e9 fe9d 	bl	34008df6 <HAL_DCMIPP_PIPE_EnableISPRemovalStatistic>
3401f0bc:	4603      	mov	r3, r0
3401f0be:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3401f0c0:	7bfb      	ldrb	r3, [r7, #15]
3401f0c2:	2b00      	cmp	r3, #0
3401f0c4:	d001      	beq.n	3401f0ca <ISP_SVC_ISP_SetStatRemoval+0x7e>
  {
    return ISP_ERR_STATREMOVAL_HAL;
3401f0c6:	2315      	movs	r3, #21
3401f0c8:	e000      	b.n	3401f0cc <ISP_SVC_ISP_SetStatRemoval+0x80>
  }

  return ISP_OK;
3401f0ca:	2300      	movs	r3, #0
}
3401f0cc:	4618      	mov	r0, r3
3401f0ce:	3710      	adds	r7, #16
3401f0d0:	46bd      	mov	sp, r7
3401f0d2:	bd80      	pop	{r7, pc}

3401f0d4 <ISP_SVC_ISP_SetDecimation>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the decimation configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetDecimation(ISP_HandleTypeDef *hIsp, ISP_DecimationTypeDef *pConfig)
{
3401f0d4:	b580      	push	{r7, lr}
3401f0d6:	b086      	sub	sp, #24
3401f0d8:	af00      	add	r7, sp, #0
3401f0da:	6078      	str	r0, [r7, #4]
3401f0dc:	6039      	str	r1, [r7, #0]
  DCMIPP_DecimationConfTypeDef decimationCfg;
  ISP_StatusTypeDef ret = ISP_OK;
3401f0de:	2300      	movs	r3, #0
3401f0e0:	75fb      	strb	r3, [r7, #23]

  /* Check handles validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f0e2:	687b      	ldr	r3, [r7, #4]
3401f0e4:	2b00      	cmp	r3, #0
3401f0e6:	d002      	beq.n	3401f0ee <ISP_SVC_ISP_SetDecimation+0x1a>
3401f0e8:	683b      	ldr	r3, [r7, #0]
3401f0ea:	2b00      	cmp	r3, #0
3401f0ec:	d101      	bne.n	3401f0f2 <ISP_SVC_ISP_SetDecimation+0x1e>
  {
    return ISP_ERR_DECIMATION_EINVAL;
3401f0ee:	231e      	movs	r3, #30
3401f0f0:	e04b      	b.n	3401f18a <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  switch (pConfig->factor)
3401f0f2:	683b      	ldr	r3, [r7, #0]
3401f0f4:	781b      	ldrb	r3, [r3, #0]
3401f0f6:	3b01      	subs	r3, #1
3401f0f8:	2b07      	cmp	r3, #7
3401f0fa:	d827      	bhi.n	3401f14c <ISP_SVC_ISP_SetDecimation+0x78>
3401f0fc:	a201      	add	r2, pc, #4	@ (adr r2, 3401f104 <ISP_SVC_ISP_SetDecimation+0x30>)
3401f0fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401f102:	bf00      	nop
3401f104:	3401f125 	.word	0x3401f125
3401f108:	3401f12f 	.word	0x3401f12f
3401f10c:	3401f14d 	.word	0x3401f14d
3401f110:	3401f139 	.word	0x3401f139
3401f114:	3401f14d 	.word	0x3401f14d
3401f118:	3401f14d 	.word	0x3401f14d
3401f11c:	3401f14d 	.word	0x3401f14d
3401f120:	3401f143 	.word	0x3401f143
  {
  case ISP_DECIM_FACTOR_1:
    decimationCfg.VRatio = DCMIPP_VDEC_ALL;
3401f124:	2300      	movs	r3, #0
3401f126:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_ALL;
3401f128:	2300      	movs	r3, #0
3401f12a:	613b      	str	r3, [r7, #16]
    break;
3401f12c:	e010      	b.n	3401f150 <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_2:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_2;
3401f12e:	2308      	movs	r3, #8
3401f130:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_2;
3401f132:	2302      	movs	r3, #2
3401f134:	613b      	str	r3, [r7, #16]
    break;
3401f136:	e00b      	b.n	3401f150 <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_4:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_4;
3401f138:	2310      	movs	r3, #16
3401f13a:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_4;
3401f13c:	2304      	movs	r3, #4
3401f13e:	613b      	str	r3, [r7, #16]
    break;
3401f140:	e006      	b.n	3401f150 <ISP_SVC_ISP_SetDecimation+0x7c>

  case ISP_DECIM_FACTOR_8:
    decimationCfg.VRatio = DCMIPP_VDEC_1_OUT_8;
3401f142:	2318      	movs	r3, #24
3401f144:	60fb      	str	r3, [r7, #12]
    decimationCfg.HRatio = DCMIPP_HDEC_1_OUT_8;
3401f146:	2306      	movs	r3, #6
3401f148:	613b      	str	r3, [r7, #16]
    break;
3401f14a:	e001      	b.n	3401f150 <ISP_SVC_ISP_SetDecimation+0x7c>

  default:
    return ISP_ERR_DECIMATION_EINVAL;
3401f14c:	231e      	movs	r3, #30
3401f14e:	e01c      	b.n	3401f18a <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_SetISPDecimationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &decimationCfg) != HAL_OK)
3401f150:	687b      	ldr	r3, [r7, #4]
3401f152:	681b      	ldr	r3, [r3, #0]
3401f154:	f107 020c 	add.w	r2, r7, #12
3401f158:	2101      	movs	r1, #1
3401f15a:	4618      	mov	r0, r3
3401f15c:	f7e9 fb7d 	bl	3400885a <HAL_DCMIPP_PIPE_SetISPDecimationConfig>
3401f160:	4603      	mov	r3, r0
3401f162:	2b00      	cmp	r3, #0
3401f164:	d001      	beq.n	3401f16a <ISP_SVC_ISP_SetDecimation+0x96>
  {
    return ISP_ERR_DECIMATION_HAL;
3401f166:	231f      	movs	r3, #31
3401f168:	e00f      	b.n	3401f18a <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  if (HAL_DCMIPP_PIPE_EnableISPDecimation(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3401f16a:	687b      	ldr	r3, [r7, #4]
3401f16c:	681b      	ldr	r3, [r3, #0]
3401f16e:	2101      	movs	r1, #1
3401f170:	4618      	mov	r0, r3
3401f172:	f7e9 fba3 	bl	340088bc <HAL_DCMIPP_PIPE_EnableISPDecimation>
3401f176:	4603      	mov	r3, r0
3401f178:	2b00      	cmp	r3, #0
3401f17a:	d001      	beq.n	3401f180 <ISP_SVC_ISP_SetDecimation+0xac>
  {
    return ISP_ERR_DECIMATION_HAL;
3401f17c:	231f      	movs	r3, #31
3401f17e:	e004      	b.n	3401f18a <ISP_SVC_ISP_SetDecimation+0xb6>
  }

  /* Save decimation value */
  ISP_DecimationValue.factor = pConfig->factor;
3401f180:	683b      	ldr	r3, [r7, #0]
3401f182:	781a      	ldrb	r2, [r3, #0]
3401f184:	4b03      	ldr	r3, [pc, #12]	@ (3401f194 <ISP_SVC_ISP_SetDecimation+0xc0>)
3401f186:	701a      	strb	r2, [r3, #0]

  return ret;
3401f188:	7dfb      	ldrb	r3, [r7, #23]
}
3401f18a:	4618      	mov	r0, r3
3401f18c:	3718      	adds	r7, #24
3401f18e:	46bd      	mov	sp, r7
3401f190:	bd80      	pop	{r7, pc}
3401f192:	bf00      	nop
3401f194:	34041488 	.word	0x34041488

3401f198 <ISP_SVC_ISP_SetContrast>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the contrast configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetContrast(ISP_HandleTypeDef *hIsp, ISP_ContrastTypeDef *pConfig)
{
3401f198:	b580      	push	{r7, lr}
3401f19a:	b086      	sub	sp, #24
3401f19c:	af00      	add	r7, sp, #0
3401f19e:	6078      	str	r0, [r7, #4]
3401f1a0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ContrastConfTypeDef contrast;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f1a2:	687b      	ldr	r3, [r7, #4]
3401f1a4:	2b00      	cmp	r3, #0
3401f1a6:	d02f      	beq.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
3401f1a8:	683b      	ldr	r3, [r7, #0]
3401f1aa:	2b00      	cmp	r3, #0
3401f1ac:	d02c      	beq.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1ae:	683b      	ldr	r3, [r7, #0]
3401f1b0:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f1b2:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1b6:	d827      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1b8:	683b      	ldr	r3, [r7, #0]
3401f1ba:	689b      	ldr	r3, [r3, #8]
3401f1bc:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1c0:	d822      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1c2:	683b      	ldr	r3, [r7, #0]
3401f1c4:	68db      	ldr	r3, [r3, #12]
      (pConfig->coeff.LUM_0 > ISP_CONTAST_LUMCOEFF_MAX) ||  (pConfig->coeff.LUM_32 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1c6:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1ca:	d81d      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1cc:	683b      	ldr	r3, [r7, #0]
3401f1ce:	691b      	ldr	r3, [r3, #16]
3401f1d0:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1d4:	d818      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1d6:	683b      	ldr	r3, [r7, #0]
3401f1d8:	695b      	ldr	r3, [r3, #20]
      (pConfig->coeff.LUM_64 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_96 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1da:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1de:	d813      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1e0:	683b      	ldr	r3, [r7, #0]
3401f1e2:	699b      	ldr	r3, [r3, #24]
3401f1e4:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1e8:	d80e      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1ea:	683b      	ldr	r3, [r7, #0]
3401f1ec:	69db      	ldr	r3, [r3, #28]
      (pConfig->coeff.LUM_128 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_160 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1ee:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1f2:	d809      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f1f4:	683b      	ldr	r3, [r7, #0]
3401f1f6:	6a1b      	ldr	r3, [r3, #32]
3401f1f8:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f1fc:	d804      	bhi.n	3401f208 <ISP_SVC_ISP_SetContrast+0x70>
      (pConfig->coeff.LUM_256 > ISP_CONTAST_LUMCOEFF_MAX))
3401f1fe:	683b      	ldr	r3, [r7, #0]
3401f200:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
      (pConfig->coeff.LUM_192 > ISP_CONTAST_LUMCOEFF_MAX) || (pConfig->coeff.LUM_224 > ISP_CONTAST_LUMCOEFF_MAX) ||
3401f202:	f5b3 7fc5 	cmp.w	r3, #394	@ 0x18a
3401f206:	d901      	bls.n	3401f20c <ISP_SVC_ISP_SetContrast+0x74>
  {
    return ISP_ERR_CONTRAST_EINVAL;
3401f208:	2328      	movs	r3, #40	@ 0x28
3401f20a:	e078      	b.n	3401f2fe <ISP_SVC_ISP_SetContrast+0x166>
  }

  if (pConfig->enable == 0)
3401f20c:	683b      	ldr	r3, [r7, #0]
3401f20e:	781b      	ldrb	r3, [r3, #0]
3401f210:	2b00      	cmp	r3, #0
3401f212:	d108      	bne.n	3401f226 <ISP_SVC_ISP_SetContrast+0x8e>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f214:	687b      	ldr	r3, [r7, #4]
3401f216:	681b      	ldr	r3, [r3, #0]
3401f218:	2101      	movs	r1, #1
3401f21a:	4618      	mov	r0, r3
3401f21c:	f7ea fad0 	bl	340097c0 <HAL_DCMIPP_PIPE_DisableISPCtrlContrast>
3401f220:	4603      	mov	r3, r0
3401f222:	75fb      	strb	r3, [r7, #23]
3401f224:	e065      	b.n	3401f2f2 <ISP_SVC_ISP_SetContrast+0x15a>
  }
  else
  {
    /* Concert coefficient unit from "percentage" to "6 bit" */
    contrast.LUM_0 = (pConfig->coeff.LUM_0 * 16) / 100;
3401f226:	683b      	ldr	r3, [r7, #0]
3401f228:	685b      	ldr	r3, [r3, #4]
3401f22a:	011b      	lsls	r3, r3, #4
3401f22c:	4a36      	ldr	r2, [pc, #216]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f22e:	fba2 2303 	umull	r2, r3, r2, r3
3401f232:	095b      	lsrs	r3, r3, #5
3401f234:	b2db      	uxtb	r3, r3
3401f236:	733b      	strb	r3, [r7, #12]
    contrast.LUM_32 = (pConfig->coeff.LUM_32 * 16) / 100;
3401f238:	683b      	ldr	r3, [r7, #0]
3401f23a:	689b      	ldr	r3, [r3, #8]
3401f23c:	011b      	lsls	r3, r3, #4
3401f23e:	4a32      	ldr	r2, [pc, #200]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f240:	fba2 2303 	umull	r2, r3, r2, r3
3401f244:	095b      	lsrs	r3, r3, #5
3401f246:	b2db      	uxtb	r3, r3
3401f248:	737b      	strb	r3, [r7, #13]
    contrast.LUM_64 = (pConfig->coeff.LUM_64 * 16) / 100;
3401f24a:	683b      	ldr	r3, [r7, #0]
3401f24c:	68db      	ldr	r3, [r3, #12]
3401f24e:	011b      	lsls	r3, r3, #4
3401f250:	4a2d      	ldr	r2, [pc, #180]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f252:	fba2 2303 	umull	r2, r3, r2, r3
3401f256:	095b      	lsrs	r3, r3, #5
3401f258:	b2db      	uxtb	r3, r3
3401f25a:	73bb      	strb	r3, [r7, #14]
    contrast.LUM_96 = (pConfig->coeff.LUM_96 * 16) / 100;
3401f25c:	683b      	ldr	r3, [r7, #0]
3401f25e:	691b      	ldr	r3, [r3, #16]
3401f260:	011b      	lsls	r3, r3, #4
3401f262:	4a29      	ldr	r2, [pc, #164]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f264:	fba2 2303 	umull	r2, r3, r2, r3
3401f268:	095b      	lsrs	r3, r3, #5
3401f26a:	b2db      	uxtb	r3, r3
3401f26c:	73fb      	strb	r3, [r7, #15]
    contrast.LUM_128 = (pConfig->coeff.LUM_128 * 16) / 100;
3401f26e:	683b      	ldr	r3, [r7, #0]
3401f270:	695b      	ldr	r3, [r3, #20]
3401f272:	011b      	lsls	r3, r3, #4
3401f274:	4a24      	ldr	r2, [pc, #144]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f276:	fba2 2303 	umull	r2, r3, r2, r3
3401f27a:	095b      	lsrs	r3, r3, #5
3401f27c:	b2db      	uxtb	r3, r3
3401f27e:	743b      	strb	r3, [r7, #16]
    contrast.LUM_160 = (pConfig->coeff.LUM_160 * 16) / 100;
3401f280:	683b      	ldr	r3, [r7, #0]
3401f282:	699b      	ldr	r3, [r3, #24]
3401f284:	011b      	lsls	r3, r3, #4
3401f286:	4a20      	ldr	r2, [pc, #128]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f288:	fba2 2303 	umull	r2, r3, r2, r3
3401f28c:	095b      	lsrs	r3, r3, #5
3401f28e:	b2db      	uxtb	r3, r3
3401f290:	747b      	strb	r3, [r7, #17]
    contrast.LUM_192 = (pConfig->coeff.LUM_192 * 16) / 100;
3401f292:	683b      	ldr	r3, [r7, #0]
3401f294:	69db      	ldr	r3, [r3, #28]
3401f296:	011b      	lsls	r3, r3, #4
3401f298:	4a1b      	ldr	r2, [pc, #108]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f29a:	fba2 2303 	umull	r2, r3, r2, r3
3401f29e:	095b      	lsrs	r3, r3, #5
3401f2a0:	b2db      	uxtb	r3, r3
3401f2a2:	74bb      	strb	r3, [r7, #18]
    contrast.LUM_224 = (pConfig->coeff.LUM_224 * 16) / 100;
3401f2a4:	683b      	ldr	r3, [r7, #0]
3401f2a6:	6a1b      	ldr	r3, [r3, #32]
3401f2a8:	011b      	lsls	r3, r3, #4
3401f2aa:	4a17      	ldr	r2, [pc, #92]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f2ac:	fba2 2303 	umull	r2, r3, r2, r3
3401f2b0:	095b      	lsrs	r3, r3, #5
3401f2b2:	b2db      	uxtb	r3, r3
3401f2b4:	74fb      	strb	r3, [r7, #19]
    contrast.LUM_256 = (pConfig->coeff.LUM_256 * 16) / 100;
3401f2b6:	683b      	ldr	r3, [r7, #0]
3401f2b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401f2ba:	011b      	lsls	r3, r3, #4
3401f2bc:	4a12      	ldr	r2, [pc, #72]	@ (3401f308 <ISP_SVC_ISP_SetContrast+0x170>)
3401f2be:	fba2 2303 	umull	r2, r3, r2, r3
3401f2c2:	095b      	lsrs	r3, r3, #5
3401f2c4:	b2db      	uxtb	r3, r3
3401f2c6:	753b      	strb	r3, [r7, #20]
    halStatus = HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &contrast);
3401f2c8:	687b      	ldr	r3, [r7, #4]
3401f2ca:	681b      	ldr	r3, [r3, #0]
3401f2cc:	f107 020c 	add.w	r2, r7, #12
3401f2d0:	2101      	movs	r1, #1
3401f2d2:	4618      	mov	r0, r3
3401f2d4:	f7ea fa04 	bl	340096e0 <HAL_DCMIPP_PIPE_SetISPCtrlContrastConfig>
3401f2d8:	4603      	mov	r3, r0
3401f2da:	75fb      	strb	r3, [r7, #23]

    if (halStatus == HAL_OK)
3401f2dc:	7dfb      	ldrb	r3, [r7, #23]
3401f2de:	2b00      	cmp	r3, #0
3401f2e0:	d107      	bne.n	3401f2f2 <ISP_SVC_ISP_SetContrast+0x15a>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPCtrlContrast(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f2e2:	687b      	ldr	r3, [r7, #4]
3401f2e4:	681b      	ldr	r3, [r3, #0]
3401f2e6:	2101      	movs	r1, #1
3401f2e8:	4618      	mov	r0, r3
3401f2ea:	f7ea fa49 	bl	34009780 <HAL_DCMIPP_PIPE_EnableISPCtrlContrast>
3401f2ee:	4603      	mov	r3, r0
3401f2f0:	75fb      	strb	r3, [r7, #23]
    }
  }

  if (halStatus != HAL_OK)
3401f2f2:	7dfb      	ldrb	r3, [r7, #23]
3401f2f4:	2b00      	cmp	r3, #0
3401f2f6:	d001      	beq.n	3401f2fc <ISP_SVC_ISP_SetContrast+0x164>
  {
    return ISP_ERR_CONTRAST_HAL;
3401f2f8:	2329      	movs	r3, #41	@ 0x29
3401f2fa:	e000      	b.n	3401f2fe <ISP_SVC_ISP_SetContrast+0x166>
  }

  return ISP_OK;
3401f2fc:	2300      	movs	r3, #0
}
3401f2fe:	4618      	mov	r0, r3
3401f300:	3718      	adds	r7, #24
3401f302:	46bd      	mov	sp, r7
3401f304:	bd80      	pop	{r7, pc}
3401f306:	bf00      	nop
3401f308:	51eb851f 	.word	0x51eb851f

3401f30c <ISP_SVC_ISP_SetStatArea>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to statistic area used by the IQ algorithms
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetStatArea(ISP_HandleTypeDef *hIsp, ISP_StatAreaTypeDef *pConfig)
{
3401f30c:	b580      	push	{r7, lr}
3401f30e:	b088      	sub	sp, #32
3401f310:	af00      	add	r7, sp, #0
3401f312:	6078      	str	r0, [r7, #4]
3401f314:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_StatisticExtractionAreaConfTypeDef currentStatAreaCfg;
  ISP_StatusTypeDef ret = ISP_OK;
3401f316:	2300      	movs	r3, #0
3401f318:	77fb      	strb	r3, [r7, #31]

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f31a:	687b      	ldr	r3, [r7, #4]
3401f31c:	2b00      	cmp	r3, #0
3401f31e:	d034      	beq.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
3401f320:	683b      	ldr	r3, [r7, #0]
3401f322:	2b00      	cmp	r3, #0
3401f324:	d031      	beq.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3401f326:	683b      	ldr	r3, [r7, #0]
3401f328:	681b      	ldr	r3, [r3, #0]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f32a:	f640 72fe 	movw	r2, #4094	@ 0xffe
3401f32e:	4293      	cmp	r3, r2
3401f330:	d82b      	bhi.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3401f332:	683b      	ldr	r3, [r7, #0]
3401f334:	685b      	ldr	r3, [r3, #4]
      (pConfig->X0 > ISP_STATWINDOW_MAX) ||
3401f336:	f640 72fe 	movw	r2, #4094	@ 0xffe
3401f33a:	4293      	cmp	r3, r2
3401f33c:	d825      	bhi.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3401f33e:	683b      	ldr	r3, [r7, #0]
3401f340:	689b      	ldr	r3, [r3, #8]
      (pConfig->Y0 > ISP_STATWINDOW_MAX) ||
3401f342:	f640 72fe 	movw	r2, #4094	@ 0xffe
3401f346:	4293      	cmp	r3, r2
3401f348:	d81f      	bhi.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3401f34a:	683b      	ldr	r3, [r7, #0]
3401f34c:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize > ISP_STATWINDOW_MAX) ||
3401f34e:	f640 72fe 	movw	r2, #4094	@ 0xffe
3401f352:	4293      	cmp	r3, r2
3401f354:	d819      	bhi.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
3401f356:	683b      	ldr	r3, [r7, #0]
3401f358:	689b      	ldr	r3, [r3, #8]
      (pConfig->YSize > ISP_STATWINDOW_MAX) ||
3401f35a:	2b03      	cmp	r3, #3
3401f35c:	d915      	bls.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3401f35e:	683b      	ldr	r3, [r7, #0]
3401f360:	68db      	ldr	r3, [r3, #12]
      (pConfig->XSize < ISP_STATWINDOW_MIN) ||
3401f362:	2b03      	cmp	r3, #3
3401f364:	d911      	bls.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3401f366:	683b      	ldr	r3, [r7, #0]
3401f368:	681a      	ldr	r2, [r3, #0]
3401f36a:	683b      	ldr	r3, [r7, #0]
3401f36c:	689b      	ldr	r3, [r3, #8]
3401f36e:	441a      	add	r2, r3
3401f370:	687b      	ldr	r3, [r7, #4]
3401f372:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
      (pConfig->YSize < ISP_STATWINDOW_MIN) ||
3401f374:	429a      	cmp	r2, r3
3401f376:	d808      	bhi.n	3401f38a <ISP_SVC_ISP_SetStatArea+0x7e>
      (pConfig->Y0 + pConfig->YSize > hIsp->sensorInfo.height))
3401f378:	683b      	ldr	r3, [r7, #0]
3401f37a:	685a      	ldr	r2, [r3, #4]
3401f37c:	683b      	ldr	r3, [r7, #0]
3401f37e:	68db      	ldr	r3, [r3, #12]
3401f380:	441a      	add	r2, r3
3401f382:	687b      	ldr	r3, [r7, #4]
3401f384:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
      (pConfig->X0 + pConfig->XSize > hIsp->sensorInfo.width) ||
3401f386:	429a      	cmp	r2, r3
3401f388:	d901      	bls.n	3401f38e <ISP_SVC_ISP_SetStatArea+0x82>
  {
    return ISP_ERR_STATAREA_EINVAL;
3401f38a:	2332      	movs	r3, #50	@ 0x32
3401f38c:	e036      	b.n	3401f3fc <ISP_SVC_ISP_SetStatArea+0xf0>
  }

  /* Set coordinates in the 'decimated' referential */
  currentStatAreaCfg.HStart = pConfig->X0 / ISP_DecimationValue.factor;
3401f38e:	683b      	ldr	r3, [r7, #0]
3401f390:	681b      	ldr	r3, [r3, #0]
3401f392:	4a1c      	ldr	r2, [pc, #112]	@ (3401f404 <ISP_SVC_ISP_SetStatArea+0xf8>)
3401f394:	7812      	ldrb	r2, [r2, #0]
3401f396:	fbb3 f3f2 	udiv	r3, r3, r2
3401f39a:	613b      	str	r3, [r7, #16]
  currentStatAreaCfg.VStart = pConfig->Y0 / ISP_DecimationValue.factor;
3401f39c:	683b      	ldr	r3, [r7, #0]
3401f39e:	685b      	ldr	r3, [r3, #4]
3401f3a0:	4a18      	ldr	r2, [pc, #96]	@ (3401f404 <ISP_SVC_ISP_SetStatArea+0xf8>)
3401f3a2:	7812      	ldrb	r2, [r2, #0]
3401f3a4:	fbb3 f3f2 	udiv	r3, r3, r2
3401f3a8:	60fb      	str	r3, [r7, #12]
  currentStatAreaCfg.HSize = pConfig->XSize / ISP_DecimationValue.factor;
3401f3aa:	683b      	ldr	r3, [r7, #0]
3401f3ac:	689b      	ldr	r3, [r3, #8]
3401f3ae:	4a15      	ldr	r2, [pc, #84]	@ (3401f404 <ISP_SVC_ISP_SetStatArea+0xf8>)
3401f3b0:	7812      	ldrb	r2, [r2, #0]
3401f3b2:	fbb3 f3f2 	udiv	r3, r3, r2
3401f3b6:	61bb      	str	r3, [r7, #24]
  currentStatAreaCfg.VSize = pConfig->YSize / ISP_DecimationValue.factor;
3401f3b8:	683b      	ldr	r3, [r7, #0]
3401f3ba:	68db      	ldr	r3, [r3, #12]
3401f3bc:	4a11      	ldr	r2, [pc, #68]	@ (3401f404 <ISP_SVC_ISP_SetStatArea+0xf8>)
3401f3be:	7812      	ldrb	r2, [r2, #0]
3401f3c0:	fbb3 f3f2 	udiv	r3, r3, r2
3401f3c4:	617b      	str	r3, [r7, #20]

  if (HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1,
3401f3c6:	687b      	ldr	r3, [r7, #4]
3401f3c8:	681b      	ldr	r3, [r3, #0]
3401f3ca:	f107 020c 	add.w	r2, r7, #12
3401f3ce:	2101      	movs	r1, #1
3401f3d0:	4618      	mov	r0, r3
3401f3d2:	f7ea f868 	bl	340094a6 <HAL_DCMIPP_PIPE_SetISPAreaStatisticExtractionConfig>
3401f3d6:	4603      	mov	r3, r0
3401f3d8:	2b00      	cmp	r3, #0
3401f3da:	d001      	beq.n	3401f3e0 <ISP_SVC_ISP_SetStatArea+0xd4>
                                                          &currentStatAreaCfg) != HAL_OK)
  {
    return ISP_ERR_STATAREA_HAL;
3401f3dc:	2333      	movs	r3, #51	@ 0x33
3401f3de:	e00d      	b.n	3401f3fc <ISP_SVC_ISP_SetStatArea+0xf0>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f3e0:	687b      	ldr	r3, [r7, #4]
3401f3e2:	681b      	ldr	r3, [r3, #0]
3401f3e4:	2101      	movs	r1, #1
3401f3e6:	4618      	mov	r0, r3
3401f3e8:	f7ea f8d8 	bl	3400959c <HAL_DCMIPP_PIPE_EnableISPAreaStatisticExtraction>
3401f3ec:	4603      	mov	r3, r0
3401f3ee:	77bb      	strb	r3, [r7, #30]
  }

  if (halStatus != HAL_OK)
3401f3f0:	7fbb      	ldrb	r3, [r7, #30]
3401f3f2:	2b00      	cmp	r3, #0
3401f3f4:	d001      	beq.n	3401f3fa <ISP_SVC_ISP_SetStatArea+0xee>
  {
    return ISP_ERR_STATAREA_HAL;
3401f3f6:	2333      	movs	r3, #51	@ 0x33
3401f3f8:	e000      	b.n	3401f3fc <ISP_SVC_ISP_SetStatArea+0xf0>
  }

  return ret;
3401f3fa:	7ffb      	ldrb	r3, [r7, #31]
}
3401f3fc:	4618      	mov	r0, r3
3401f3fe:	3720      	adds	r7, #32
3401f400:	46bd      	mov	sp, r7
3401f402:	bd80      	pop	{r7, pc}
3401f404:	34041488 	.word	0x34041488

3401f408 <ISP_SVC_ISP_SetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3401f408:	b580      	push	{r7, lr}
3401f40a:	b084      	sub	sp, #16
3401f40c:	af00      	add	r7, sp, #0
3401f40e:	6078      	str	r0, [r7, #4]
3401f410:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  if ((hIsp == NULL) || (pConfig == NULL) || (pConfig->strength > ISP_BADPIXEL_STRENGTH_MAX))
3401f412:	687b      	ldr	r3, [r7, #4]
3401f414:	2b00      	cmp	r3, #0
3401f416:	d006      	beq.n	3401f426 <ISP_SVC_ISP_SetBadPixel+0x1e>
3401f418:	683b      	ldr	r3, [r7, #0]
3401f41a:	2b00      	cmp	r3, #0
3401f41c:	d003      	beq.n	3401f426 <ISP_SVC_ISP_SetBadPixel+0x1e>
3401f41e:	683b      	ldr	r3, [r7, #0]
3401f420:	785b      	ldrb	r3, [r3, #1]
3401f422:	2b07      	cmp	r3, #7
3401f424:	d901      	bls.n	3401f42a <ISP_SVC_ISP_SetBadPixel+0x22>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
3401f426:	233c      	movs	r3, #60	@ 0x3c
3401f428:	e029      	b.n	3401f47e <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  if (pConfig->enable == 0)
3401f42a:	683b      	ldr	r3, [r7, #0]
3401f42c:	781b      	ldrb	r3, [r3, #0]
3401f42e:	2b00      	cmp	r3, #0
3401f430:	d108      	bne.n	3401f444 <ISP_SVC_ISP_SetBadPixel+0x3c>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f432:	687b      	ldr	r3, [r7, #4]
3401f434:	681b      	ldr	r3, [r3, #0]
3401f436:	2101      	movs	r1, #1
3401f438:	4618      	mov	r0, r3
3401f43a:	f7e9 fd60 	bl	34008efe <HAL_DCMIPP_PIPE_DisableISPBadPixelRemoval>
3401f43e:	4603      	mov	r3, r0
3401f440:	73fb      	strb	r3, [r7, #15]
3401f442:	e016      	b.n	3401f472 <ISP_SVC_ISP_SetBadPixel+0x6a>
  }
  else
  {
    halStatus = HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1, pConfig->strength);
3401f444:	687b      	ldr	r3, [r7, #4]
3401f446:	6818      	ldr	r0, [r3, #0]
3401f448:	683b      	ldr	r3, [r7, #0]
3401f44a:	785b      	ldrb	r3, [r3, #1]
3401f44c:	461a      	mov	r2, r3
3401f44e:	2101      	movs	r1, #1
3401f450:	f7e9 fd11 	bl	34008e76 <HAL_DCMIPP_PIPE_SetISPBadPixelRemovalConfig>
3401f454:	4603      	mov	r3, r0
3401f456:	73fb      	strb	r3, [r7, #15]

    if (halStatus != HAL_OK)
3401f458:	7bfb      	ldrb	r3, [r7, #15]
3401f45a:	2b00      	cmp	r3, #0
3401f45c:	d001      	beq.n	3401f462 <ISP_SVC_ISP_SetBadPixel+0x5a>
    {
      return ISP_ERR_BADPIXEL_HAL;
3401f45e:	233d      	movs	r3, #61	@ 0x3d
3401f460:	e00d      	b.n	3401f47e <ISP_SVC_ISP_SetBadPixel+0x76>
    }

    halStatus = HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f462:	687b      	ldr	r3, [r7, #4]
3401f464:	681b      	ldr	r3, [r3, #0]
3401f466:	2101      	movs	r1, #1
3401f468:	4618      	mov	r0, r3
3401f46a:	f7e9 fd28 	bl	34008ebe <HAL_DCMIPP_PIPE_EnableISPBadPixelRemoval>
3401f46e:	4603      	mov	r3, r0
3401f470:	73fb      	strb	r3, [r7, #15]
  }

  if (halStatus != HAL_OK)
3401f472:	7bfb      	ldrb	r3, [r7, #15]
3401f474:	2b00      	cmp	r3, #0
3401f476:	d001      	beq.n	3401f47c <ISP_SVC_ISP_SetBadPixel+0x74>
  {
    return ISP_ERR_BADPIXEL_HAL;
3401f478:	233d      	movs	r3, #61	@ 0x3d
3401f47a:	e000      	b.n	3401f47e <ISP_SVC_ISP_SetBadPixel+0x76>
  }

  return ISP_OK;
3401f47c:	2300      	movs	r3, #0
}
3401f47e:	4618      	mov	r0, r3
3401f480:	3710      	adds	r7, #16
3401f482:	46bd      	mov	sp, r7
3401f484:	bd80      	pop	{r7, pc}

3401f486 <ISP_SVC_ISP_GetBadPixel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the bad pixel configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetBadPixel(ISP_HandleTypeDef *hIsp, ISP_BadPixelTypeDef *pConfig)
{
3401f486:	b580      	push	{r7, lr}
3401f488:	b084      	sub	sp, #16
3401f48a:	af00      	add	r7, sp, #0
3401f48c:	6078      	str	r0, [r7, #4]
3401f48e:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f490:	687b      	ldr	r3, [r7, #4]
3401f492:	2b00      	cmp	r3, #0
3401f494:	d002      	beq.n	3401f49c <ISP_SVC_ISP_GetBadPixel+0x16>
3401f496:	683b      	ldr	r3, [r7, #0]
3401f498:	2b00      	cmp	r3, #0
3401f49a:	d101      	bne.n	3401f4a0 <ISP_SVC_ISP_GetBadPixel+0x1a>
  {
    return ISP_ERR_BADPIXEL_EINVAL;
3401f49c:	233c      	movs	r3, #60	@ 0x3c
3401f49e:	e023      	b.n	3401f4e8 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f4a0:	687b      	ldr	r3, [r7, #4]
3401f4a2:	681b      	ldr	r3, [r3, #0]
3401f4a4:	2101      	movs	r1, #1
3401f4a6:	4618      	mov	r0, r3
3401f4a8:	f7e9 fd5b 	bl	34008f62 <HAL_DCMIPP_PIPE_IsEnabledISPBadPixelRemoval>
3401f4ac:	4603      	mov	r3, r0
3401f4ae:	b2da      	uxtb	r2, r3
3401f4b0:	683b      	ldr	r3, [r7, #0]
3401f4b2:	701a      	strb	r2, [r3, #0]
  pConfig->strength = (uint8_t) HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f4b4:	687b      	ldr	r3, [r7, #4]
3401f4b6:	681b      	ldr	r3, [r3, #0]
3401f4b8:	2101      	movs	r1, #1
3401f4ba:	4618      	mov	r0, r3
3401f4bc:	f7e9 fd3f 	bl	34008f3e <HAL_DCMIPP_PIPE_GetISPBadPixelRemovalConfig>
3401f4c0:	4603      	mov	r3, r0
3401f4c2:	b2da      	uxtb	r2, r3
3401f4c4:	683b      	ldr	r3, [r7, #0]
3401f4c6:	705a      	strb	r2, [r3, #1]

  halStatus = HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter(hIsp->hDcmipp, DCMIPP_PIPE1, &pConfig->count);
3401f4c8:	687b      	ldr	r3, [r7, #4]
3401f4ca:	6818      	ldr	r0, [r3, #0]
3401f4cc:	683b      	ldr	r3, [r7, #0]
3401f4ce:	3304      	adds	r3, #4
3401f4d0:	461a      	mov	r2, r3
3401f4d2:	2101      	movs	r1, #1
3401f4d4:	f7e9 fd60 	bl	34008f98 <HAL_DCMIPP_PIPE_GetISPRemovedBadPixelCounter>
3401f4d8:	4603      	mov	r3, r0
3401f4da:	73fb      	strb	r3, [r7, #15]

  if (halStatus != HAL_OK)
3401f4dc:	7bfb      	ldrb	r3, [r7, #15]
3401f4de:	2b00      	cmp	r3, #0
3401f4e0:	d001      	beq.n	3401f4e6 <ISP_SVC_ISP_GetBadPixel+0x60>
  {
    return ISP_ERR_BADPIXEL_HAL;
3401f4e2:	233d      	movs	r3, #61	@ 0x3d
3401f4e4:	e000      	b.n	3401f4e8 <ISP_SVC_ISP_GetBadPixel+0x62>
  }

  return ISP_OK;
3401f4e6:	2300      	movs	r3, #0
}
3401f4e8:	4618      	mov	r0, r3
3401f4ea:	3710      	adds	r7, #16
3401f4ec:	46bd      	mov	sp, r7
3401f4ee:	bd80      	pop	{r7, pc}

3401f4f0 <ISP_SVC_ISP_SetBlackLevel>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the black level configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetBlackLevel(ISP_HandleTypeDef *hIsp, ISP_BlackLevelTypeDef *pConfig)
{
3401f4f0:	b580      	push	{r7, lr}
3401f4f2:	b084      	sub	sp, #16
3401f4f4:	af00      	add	r7, sp, #0
3401f4f6:	6078      	str	r0, [r7, #4]
3401f4f8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_BlackLevelConfTypeDef blackLevelConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f4fa:	687b      	ldr	r3, [r7, #4]
3401f4fc:	2b00      	cmp	r3, #0
3401f4fe:	d002      	beq.n	3401f506 <ISP_SVC_ISP_SetBlackLevel+0x16>
3401f500:	683b      	ldr	r3, [r7, #0]
3401f502:	2b00      	cmp	r3, #0
3401f504:	d101      	bne.n	3401f50a <ISP_SVC_ISP_SetBlackLevel+0x1a>
  {
    return ISP_ERR_BLACKLEVEL_EINVAL;
3401f506:	2346      	movs	r3, #70	@ 0x46
3401f508:	e030      	b.n	3401f56c <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  if (pConfig->enable == 0)
3401f50a:	683b      	ldr	r3, [r7, #0]
3401f50c:	781b      	ldrb	r3, [r3, #0]
3401f50e:	2b00      	cmp	r3, #0
3401f510:	d108      	bne.n	3401f524 <ISP_SVC_ISP_SetBlackLevel+0x34>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f512:	687b      	ldr	r3, [r7, #4]
3401f514:	681b      	ldr	r3, [r3, #0]
3401f516:	2101      	movs	r1, #1
3401f518:	4618      	mov	r0, r3
3401f51a:	f7e9 ff52 	bl	340093c2 <HAL_DCMIPP_PIPE_DisableISPBlackLevelCalibration>
3401f51e:	4603      	mov	r3, r0
3401f520:	73fb      	strb	r3, [r7, #15]
3401f522:	e01d      	b.n	3401f560 <ISP_SVC_ISP_SetBlackLevel+0x70>
  }
  else
  {
    blackLevelConfig.RedCompBlackLevel = pConfig->BLCR;
3401f524:	683b      	ldr	r3, [r7, #0]
3401f526:	785b      	ldrb	r3, [r3, #1]
3401f528:	733b      	strb	r3, [r7, #12]
    blackLevelConfig.GreenCompBlackLevel = pConfig->BLCG;
3401f52a:	683b      	ldr	r3, [r7, #0]
3401f52c:	789b      	ldrb	r3, [r3, #2]
3401f52e:	737b      	strb	r3, [r7, #13]
    blackLevelConfig.BlueCompBlackLevel = pConfig->BLCB;
3401f530:	683b      	ldr	r3, [r7, #0]
3401f532:	78db      	ldrb	r3, [r3, #3]
3401f534:	73bb      	strb	r3, [r7, #14]
    halStatus = HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &blackLevelConfig);
3401f536:	687b      	ldr	r3, [r7, #4]
3401f538:	681b      	ldr	r3, [r3, #0]
3401f53a:	f107 020c 	add.w	r2, r7, #12
3401f53e:	2101      	movs	r1, #1
3401f540:	4618      	mov	r0, r3
3401f542:	f7e9 feef 	bl	34009324 <HAL_DCMIPP_PIPE_SetISPBlackLevelCalibrationConfig>
3401f546:	4603      	mov	r3, r0
3401f548:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3401f54a:	7bfb      	ldrb	r3, [r7, #15]
3401f54c:	2b00      	cmp	r3, #0
3401f54e:	d107      	bne.n	3401f560 <ISP_SVC_ISP_SetBlackLevel+0x70>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f550:	687b      	ldr	r3, [r7, #4]
3401f552:	681b      	ldr	r3, [r3, #0]
3401f554:	2101      	movs	r1, #1
3401f556:	4618      	mov	r0, r3
3401f558:	f7e9 ff13 	bl	34009382 <HAL_DCMIPP_PIPE_EnableISPBlackLevelCalibration>
3401f55c:	4603      	mov	r3, r0
3401f55e:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3401f560:	7bfb      	ldrb	r3, [r7, #15]
3401f562:	2b00      	cmp	r3, #0
3401f564:	d001      	beq.n	3401f56a <ISP_SVC_ISP_SetBlackLevel+0x7a>
  {
    return ISP_ERR_BLACKLEVEL_HAL;
3401f566:	2347      	movs	r3, #71	@ 0x47
3401f568:	e000      	b.n	3401f56c <ISP_SVC_ISP_SetBlackLevel+0x7c>
  }

  return ISP_OK;
3401f56a:	2300      	movs	r3, #0
}
3401f56c:	4618      	mov	r0, r3
3401f56e:	3710      	adds	r7, #16
3401f570:	46bd      	mov	sp, r7
3401f572:	bd80      	pop	{r7, pc}

3401f574 <ISP_SVC_ISP_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGain(ISP_HandleTypeDef *hIsp, ISP_ISPGainTypeDef *pConfig)
{
3401f574:	b580      	push	{r7, lr}
3401f576:	b084      	sub	sp, #16
3401f578:	af00      	add	r7, sp, #0
3401f57a:	6078      	str	r0, [r7, #4]
3401f57c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ExposureConfTypeDef exposureConfig;

  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f57e:	687b      	ldr	r3, [r7, #4]
3401f580:	2b00      	cmp	r3, #0
3401f582:	d011      	beq.n	3401f5a8 <ISP_SVC_ISP_SetGain+0x34>
3401f584:	683b      	ldr	r3, [r7, #0]
3401f586:	2b00      	cmp	r3, #0
3401f588:	d00e      	beq.n	3401f5a8 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3401f58a:	683b      	ldr	r3, [r7, #0]
3401f58c:	685b      	ldr	r3, [r3, #4]
  if ((hIsp == NULL) || (pConfig == NULL) ||
3401f58e:	4a2d      	ldr	r2, [pc, #180]	@ (3401f644 <ISP_SVC_ISP_SetGain+0xd0>)
3401f590:	4293      	cmp	r3, r2
3401f592:	d809      	bhi.n	3401f5a8 <ISP_SVC_ISP_SetGain+0x34>
      (pConfig->ispGainR > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainG > ISP_EXPOSURE_GAIN_MAX) || (pConfig->ispGainB > ISP_EXPOSURE_GAIN_MAX))
3401f594:	683b      	ldr	r3, [r7, #0]
3401f596:	689b      	ldr	r3, [r3, #8]
3401f598:	4a2a      	ldr	r2, [pc, #168]	@ (3401f644 <ISP_SVC_ISP_SetGain+0xd0>)
3401f59a:	4293      	cmp	r3, r2
3401f59c:	d804      	bhi.n	3401f5a8 <ISP_SVC_ISP_SetGain+0x34>
3401f59e:	683b      	ldr	r3, [r7, #0]
3401f5a0:	68db      	ldr	r3, [r3, #12]
3401f5a2:	4a28      	ldr	r2, [pc, #160]	@ (3401f644 <ISP_SVC_ISP_SetGain+0xd0>)
3401f5a4:	4293      	cmp	r3, r2
3401f5a6:	d901      	bls.n	3401f5ac <ISP_SVC_ISP_SetGain+0x38>
  {
    return ISP_ERR_ISPGAIN_EINVAL;
3401f5a8:	2350      	movs	r3, #80	@ 0x50
3401f5aa:	e047      	b.n	3401f63c <ISP_SVC_ISP_SetGain+0xc8>
  }

  if (pConfig->enable == 0)
3401f5ac:	683b      	ldr	r3, [r7, #0]
3401f5ae:	781b      	ldrb	r3, [r3, #0]
3401f5b0:	2b00      	cmp	r3, #0
3401f5b2:	d108      	bne.n	3401f5c6 <ISP_SVC_ISP_SetGain+0x52>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f5b4:	687b      	ldr	r3, [r7, #4]
3401f5b6:	681b      	ldr	r3, [r3, #0]
3401f5b8:	2101      	movs	r1, #1
3401f5ba:	4618      	mov	r0, r3
3401f5bc:	f7ea f870 	bl	340096a0 <HAL_DCMIPP_PIPE_DisableISPExposure>
3401f5c0:	4603      	mov	r3, r0
3401f5c2:	73fb      	strb	r3, [r7, #15]
3401f5c4:	e034      	b.n	3401f630 <ISP_SVC_ISP_SetGain+0xbc>
  }
  else
  {
    To_Shift_Multiplier(pConfig->ispGainR, &exposureConfig.ShiftRed, &exposureConfig.MultiplierRed);
3401f5c6:	683b      	ldr	r3, [r7, #0]
3401f5c8:	6858      	ldr	r0, [r3, #4]
3401f5ca:	f107 0308 	add.w	r3, r7, #8
3401f5ce:	1c5a      	adds	r2, r3, #1
3401f5d0:	f107 0308 	add.w	r3, r7, #8
3401f5d4:	4619      	mov	r1, r3
3401f5d6:	f7ff f9fb 	bl	3401e9d0 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainG, &exposureConfig.ShiftGreen, &exposureConfig.MultiplierGreen);
3401f5da:	683b      	ldr	r3, [r7, #0]
3401f5dc:	6898      	ldr	r0, [r3, #8]
3401f5de:	f107 0308 	add.w	r3, r7, #8
3401f5e2:	1cda      	adds	r2, r3, #3
3401f5e4:	f107 0308 	add.w	r3, r7, #8
3401f5e8:	3302      	adds	r3, #2
3401f5ea:	4619      	mov	r1, r3
3401f5ec:	f7ff f9f0 	bl	3401e9d0 <To_Shift_Multiplier>
    To_Shift_Multiplier(pConfig->ispGainB, &exposureConfig.ShiftBlue, &exposureConfig.MultiplierBlue);
3401f5f0:	683b      	ldr	r3, [r7, #0]
3401f5f2:	68d8      	ldr	r0, [r3, #12]
3401f5f4:	f107 0308 	add.w	r3, r7, #8
3401f5f8:	1d5a      	adds	r2, r3, #5
3401f5fa:	f107 0308 	add.w	r3, r7, #8
3401f5fe:	3304      	adds	r3, #4
3401f600:	4619      	mov	r1, r3
3401f602:	f7ff f9e5 	bl	3401e9d0 <To_Shift_Multiplier>
    halStatus = HAL_DCMIPP_PIPE_SetISPExposureConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &exposureConfig);
3401f606:	687b      	ldr	r3, [r7, #4]
3401f608:	681b      	ldr	r3, [r3, #0]
3401f60a:	f107 0208 	add.w	r2, r7, #8
3401f60e:	2101      	movs	r1, #1
3401f610:	4618      	mov	r0, r3
3401f612:	f7e9 ffe3 	bl	340095dc <HAL_DCMIPP_PIPE_SetISPExposureConfig>
3401f616:	4603      	mov	r3, r0
3401f618:	73fb      	strb	r3, [r7, #15]

    if (halStatus == HAL_OK)
3401f61a:	7bfb      	ldrb	r3, [r7, #15]
3401f61c:	2b00      	cmp	r3, #0
3401f61e:	d107      	bne.n	3401f630 <ISP_SVC_ISP_SetGain+0xbc>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPExposure(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f620:	687b      	ldr	r3, [r7, #4]
3401f622:	681b      	ldr	r3, [r3, #0]
3401f624:	2101      	movs	r1, #1
3401f626:	4618      	mov	r0, r3
3401f628:	f7ea f81a 	bl	34009660 <HAL_DCMIPP_PIPE_EnableISPExposure>
3401f62c:	4603      	mov	r3, r0
3401f62e:	73fb      	strb	r3, [r7, #15]
    }
  }

  if (halStatus != HAL_OK)
3401f630:	7bfb      	ldrb	r3, [r7, #15]
3401f632:	2b00      	cmp	r3, #0
3401f634:	d001      	beq.n	3401f63a <ISP_SVC_ISP_SetGain+0xc6>
  {
    return ISP_ERR_ISPGAIN_HAL;
3401f636:	2351      	movs	r3, #81	@ 0x51
3401f638:	e000      	b.n	3401f63c <ISP_SVC_ISP_SetGain+0xc8>
  }

  return ISP_OK;
3401f63a:	2300      	movs	r3, #0
}
3401f63c:	4618      	mov	r0, r3
3401f63e:	3710      	adds	r7, #16
3401f640:	46bd      	mov	sp, r7
3401f642:	bd80      	pop	{r7, pc}
3401f644:	5f5e1000 	.word	0x5f5e1000

3401f648 <ISP_SVC_ISP_SetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3401f648:	b580      	push	{r7, lr}
3401f64a:	b08c      	sub	sp, #48	@ 0x30
3401f64c:	af00      	add	r7, sp, #0
3401f64e:	6078      	str	r0, [r7, #4]
3401f650:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halStatus;
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;
  uint32_t i, j;

  memset(&colorConvConfig, 0, sizeof(colorConvConfig));
3401f652:	f107 0308 	add.w	r3, r7, #8
3401f656:	221a      	movs	r2, #26
3401f658:	2100      	movs	r1, #0
3401f65a:	4618      	mov	r0, r3
3401f65c:	f007 fd9a 	bl	34027194 <memset>

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f660:	687b      	ldr	r3, [r7, #4]
3401f662:	2b00      	cmp	r3, #0
3401f664:	d002      	beq.n	3401f66c <ISP_SVC_ISP_SetColorConv+0x24>
3401f666:	683b      	ldr	r3, [r7, #0]
3401f668:	2b00      	cmp	r3, #0
3401f66a:	d101      	bne.n	3401f670 <ISP_SVC_ISP_SetColorConv+0x28>
  {
    return ISP_ERR_COLORCONV_EINVAL;
3401f66c:	235a      	movs	r3, #90	@ 0x5a
3401f66e:	e099      	b.n	3401f7a4 <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  for (i = 0; i < 3; i++)
3401f670:	2300      	movs	r3, #0
3401f672:	62bb      	str	r3, [r7, #40]	@ 0x28
3401f674:	e027      	b.n	3401f6c6 <ISP_SVC_ISP_SetColorConv+0x7e>
  {
    for (j = 0; j < 3; j++)
3401f676:	2300      	movs	r3, #0
3401f678:	627b      	str	r3, [r7, #36]	@ 0x24
3401f67a:	e01e      	b.n	3401f6ba <ISP_SVC_ISP_SetColorConv+0x72>
    {
      if ((pConfig->coeff[i][j] > ISP_COLORCONV_MAX) || (pConfig->coeff[i][j] < -ISP_COLORCONV_MAX))
3401f67c:	6839      	ldr	r1, [r7, #0]
3401f67e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3401f680:	4613      	mov	r3, r2
3401f682:	005b      	lsls	r3, r3, #1
3401f684:	4413      	add	r3, r2
3401f686:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401f688:	4413      	add	r3, r2
3401f68a:	009b      	lsls	r3, r3, #2
3401f68c:	440b      	add	r3, r1
3401f68e:	685b      	ldr	r3, [r3, #4]
3401f690:	4a46      	ldr	r2, [pc, #280]	@ (3401f7ac <ISP_SVC_ISP_SetColorConv+0x164>)
3401f692:	4293      	cmp	r3, r2
3401f694:	dc0c      	bgt.n	3401f6b0 <ISP_SVC_ISP_SetColorConv+0x68>
3401f696:	6839      	ldr	r1, [r7, #0]
3401f698:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3401f69a:	4613      	mov	r3, r2
3401f69c:	005b      	lsls	r3, r3, #1
3401f69e:	4413      	add	r3, r2
3401f6a0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3401f6a2:	4413      	add	r3, r2
3401f6a4:	009b      	lsls	r3, r3, #2
3401f6a6:	440b      	add	r3, r1
3401f6a8:	685b      	ldr	r3, [r3, #4]
3401f6aa:	4a41      	ldr	r2, [pc, #260]	@ (3401f7b0 <ISP_SVC_ISP_SetColorConv+0x168>)
3401f6ac:	4293      	cmp	r3, r2
3401f6ae:	da01      	bge.n	3401f6b4 <ISP_SVC_ISP_SetColorConv+0x6c>
      {
        return ISP_ERR_COLORCONV_EINVAL;
3401f6b0:	235a      	movs	r3, #90	@ 0x5a
3401f6b2:	e077      	b.n	3401f7a4 <ISP_SVC_ISP_SetColorConv+0x15c>
    for (j = 0; j < 3; j++)
3401f6b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401f6b6:	3301      	adds	r3, #1
3401f6b8:	627b      	str	r3, [r7, #36]	@ 0x24
3401f6ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3401f6bc:	2b02      	cmp	r3, #2
3401f6be:	d9dd      	bls.n	3401f67c <ISP_SVC_ISP_SetColorConv+0x34>
  for (i = 0; i < 3; i++)
3401f6c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401f6c2:	3301      	adds	r3, #1
3401f6c4:	62bb      	str	r3, [r7, #40]	@ 0x28
3401f6c6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3401f6c8:	2b02      	cmp	r3, #2
3401f6ca:	d9d4      	bls.n	3401f676 <ISP_SVC_ISP_SetColorConv+0x2e>
      }
    }
  }

  if (pConfig->enable == 0)
3401f6cc:	683b      	ldr	r3, [r7, #0]
3401f6ce:	781b      	ldrb	r3, [r3, #0]
3401f6d0:	2b00      	cmp	r3, #0
3401f6d2:	d109      	bne.n	3401f6e8 <ISP_SVC_ISP_SetColorConv+0xa0>
  {
    halStatus = HAL_DCMIPP_PIPE_DisableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f6d4:	687b      	ldr	r3, [r7, #4]
3401f6d6:	681b      	ldr	r3, [r3, #0]
3401f6d8:	2101      	movs	r1, #1
3401f6da:	4618      	mov	r0, r3
3401f6dc:	f7e9 fe02 	bl	340092e4 <HAL_DCMIPP_PIPE_DisableISPColorConversion>
3401f6e0:	4603      	mov	r3, r0
3401f6e2:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
3401f6e6:	e056      	b.n	3401f796 <ISP_SVC_ISP_SetColorConv+0x14e>
  }
  else
  {
    colorConvConfig.RR = To_CConv_Reg(pConfig->coeff[0][0]);
3401f6e8:	683b      	ldr	r3, [r7, #0]
3401f6ea:	685b      	ldr	r3, [r3, #4]
3401f6ec:	4618      	mov	r0, r3
3401f6ee:	f7ff f9af 	bl	3401ea50 <To_CConv_Reg>
3401f6f2:	4603      	mov	r3, r0
3401f6f4:	817b      	strh	r3, [r7, #10]
    colorConvConfig.RG = To_CConv_Reg(pConfig->coeff[0][1]);
3401f6f6:	683b      	ldr	r3, [r7, #0]
3401f6f8:	689b      	ldr	r3, [r3, #8]
3401f6fa:	4618      	mov	r0, r3
3401f6fc:	f7ff f9a8 	bl	3401ea50 <To_CConv_Reg>
3401f700:	4603      	mov	r3, r0
3401f702:	81bb      	strh	r3, [r7, #12]
    colorConvConfig.RB = To_CConv_Reg(pConfig->coeff[0][2]);
3401f704:	683b      	ldr	r3, [r7, #0]
3401f706:	68db      	ldr	r3, [r3, #12]
3401f708:	4618      	mov	r0, r3
3401f70a:	f7ff f9a1 	bl	3401ea50 <To_CConv_Reg>
3401f70e:	4603      	mov	r3, r0
3401f710:	81fb      	strh	r3, [r7, #14]
    colorConvConfig.GR = To_CConv_Reg(pConfig->coeff[1][0]);
3401f712:	683b      	ldr	r3, [r7, #0]
3401f714:	691b      	ldr	r3, [r3, #16]
3401f716:	4618      	mov	r0, r3
3401f718:	f7ff f99a 	bl	3401ea50 <To_CConv_Reg>
3401f71c:	4603      	mov	r3, r0
3401f71e:	827b      	strh	r3, [r7, #18]
    colorConvConfig.GG = To_CConv_Reg(pConfig->coeff[1][1]);
3401f720:	683b      	ldr	r3, [r7, #0]
3401f722:	695b      	ldr	r3, [r3, #20]
3401f724:	4618      	mov	r0, r3
3401f726:	f7ff f993 	bl	3401ea50 <To_CConv_Reg>
3401f72a:	4603      	mov	r3, r0
3401f72c:	82bb      	strh	r3, [r7, #20]
    colorConvConfig.GB = To_CConv_Reg(pConfig->coeff[1][2]);
3401f72e:	683b      	ldr	r3, [r7, #0]
3401f730:	699b      	ldr	r3, [r3, #24]
3401f732:	4618      	mov	r0, r3
3401f734:	f7ff f98c 	bl	3401ea50 <To_CConv_Reg>
3401f738:	4603      	mov	r3, r0
3401f73a:	82fb      	strh	r3, [r7, #22]
    colorConvConfig.BR = To_CConv_Reg(pConfig->coeff[2][0]);
3401f73c:	683b      	ldr	r3, [r7, #0]
3401f73e:	69db      	ldr	r3, [r3, #28]
3401f740:	4618      	mov	r0, r3
3401f742:	f7ff f985 	bl	3401ea50 <To_CConv_Reg>
3401f746:	4603      	mov	r3, r0
3401f748:	837b      	strh	r3, [r7, #26]
    colorConvConfig.BG = To_CConv_Reg(pConfig->coeff[2][1]);
3401f74a:	683b      	ldr	r3, [r7, #0]
3401f74c:	6a1b      	ldr	r3, [r3, #32]
3401f74e:	4618      	mov	r0, r3
3401f750:	f7ff f97e 	bl	3401ea50 <To_CConv_Reg>
3401f754:	4603      	mov	r3, r0
3401f756:	83bb      	strh	r3, [r7, #28]
    colorConvConfig.BB = To_CConv_Reg(pConfig->coeff[2][2]);
3401f758:	683b      	ldr	r3, [r7, #0]
3401f75a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3401f75c:	4618      	mov	r0, r3
3401f75e:	f7ff f977 	bl	3401ea50 <To_CConv_Reg>
3401f762:	4603      	mov	r3, r0
3401f764:	83fb      	strh	r3, [r7, #30]
    halStatus = HAL_DCMIPP_PIPE_SetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3401f766:	687b      	ldr	r3, [r7, #4]
3401f768:	681b      	ldr	r3, [r3, #0]
3401f76a:	f107 0208 	add.w	r2, r7, #8
3401f76e:	2101      	movs	r1, #1
3401f770:	4618      	mov	r0, r3
3401f772:	f7e9 fc35 	bl	34008fe0 <HAL_DCMIPP_PIPE_SetISPColorConversionConfig>
3401f776:	4603      	mov	r3, r0
3401f778:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    if (halStatus == HAL_OK)
3401f77c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
3401f780:	2b00      	cmp	r3, #0
3401f782:	d108      	bne.n	3401f796 <ISP_SVC_ISP_SetColorConv+0x14e>
    {
      halStatus = HAL_DCMIPP_PIPE_EnableISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f784:	687b      	ldr	r3, [r7, #4]
3401f786:	681b      	ldr	r3, [r3, #0]
3401f788:	2101      	movs	r1, #1
3401f78a:	4618      	mov	r0, r3
3401f78c:	f7e9 fd8a 	bl	340092a4 <HAL_DCMIPP_PIPE_EnableISPColorConversion>
3401f790:	4603      	mov	r3, r0
3401f792:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }
  }

  if (halStatus != HAL_OK)
3401f796:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
3401f79a:	2b00      	cmp	r3, #0
3401f79c:	d001      	beq.n	3401f7a2 <ISP_SVC_ISP_SetColorConv+0x15a>
  {
    return ISP_ERR_COLORCONV_HAL;
3401f79e:	235b      	movs	r3, #91	@ 0x5b
3401f7a0:	e000      	b.n	3401f7a4 <ISP_SVC_ISP_SetColorConv+0x15c>
  }

  return ISP_OK;
3401f7a2:	2300      	movs	r3, #0
}
3401f7a4:	4618      	mov	r0, r3
3401f7a6:	3730      	adds	r7, #48	@ 0x30
3401f7a8:	46bd      	mov	sp, r7
3401f7aa:	bd80      	pop	{r7, pc}
3401f7ac:	17c841c0 	.word	0x17c841c0
3401f7b0:	e837be40 	.word	0xe837be40

3401f7b4 <ISP_SVC_ISP_GetColorConv>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the Color Conversion configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_GetColorConv(ISP_HandleTypeDef *hIsp, ISP_ColorConvTypeDef *pConfig)
{
3401f7b4:	b580      	push	{r7, lr}
3401f7b6:	b08a      	sub	sp, #40	@ 0x28
3401f7b8:	af00      	add	r7, sp, #0
3401f7ba:	6078      	str	r0, [r7, #4]
3401f7bc:	6039      	str	r1, [r7, #0]
  DCMIPP_ColorConversionConfTypeDef colorConvConfig;

  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f7be:	687b      	ldr	r3, [r7, #4]
3401f7c0:	2b00      	cmp	r3, #0
3401f7c2:	d002      	beq.n	3401f7ca <ISP_SVC_ISP_GetColorConv+0x16>
3401f7c4:	683b      	ldr	r3, [r7, #0]
3401f7c6:	2b00      	cmp	r3, #0
3401f7c8:	d101      	bne.n	3401f7ce <ISP_SVC_ISP_GetColorConv+0x1a>
  {
    return ISP_ERR_COLORCONV_EINVAL;
3401f7ca:	235a      	movs	r3, #90	@ 0x5a
3401f7cc:	e05a      	b.n	3401f884 <ISP_SVC_ISP_GetColorConv+0xd0>
  }

  pConfig->enable = HAL_DCMIPP_PIPE_IsEnabledISPColorConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3401f7ce:	687b      	ldr	r3, [r7, #4]
3401f7d0:	681b      	ldr	r3, [r3, #0]
3401f7d2:	2101      	movs	r1, #1
3401f7d4:	4618      	mov	r0, r3
3401f7d6:	f7ea fb02 	bl	34009dde <HAL_DCMIPP_PIPE_IsEnabledISPColorConversion>
3401f7da:	4603      	mov	r3, r0
3401f7dc:	b2da      	uxtb	r2, r3
3401f7de:	683b      	ldr	r3, [r7, #0]
3401f7e0:	701a      	strb	r2, [r3, #0]

  HAL_DCMIPP_PIPE_GetISPColorConversionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, &colorConvConfig);
3401f7e2:	687b      	ldr	r3, [r7, #4]
3401f7e4:	681b      	ldr	r3, [r3, #0]
3401f7e6:	f107 020c 	add.w	r2, r7, #12
3401f7ea:	2101      	movs	r1, #1
3401f7ec:	4618      	mov	r0, r3
3401f7ee:	f7ea f9a0 	bl	34009b32 <HAL_DCMIPP_PIPE_GetISPColorConversionConfig>

  pConfig->coeff[0][0] = From_CConv_Reg(colorConvConfig.RR);
3401f7f2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3401f7f6:	4618      	mov	r0, r3
3401f7f8:	f7ff f948 	bl	3401ea8c <From_CConv_Reg>
3401f7fc:	4602      	mov	r2, r0
3401f7fe:	683b      	ldr	r3, [r7, #0]
3401f800:	605a      	str	r2, [r3, #4]
  pConfig->coeff[0][1] = From_CConv_Reg(colorConvConfig.RG);
3401f802:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
3401f806:	4618      	mov	r0, r3
3401f808:	f7ff f940 	bl	3401ea8c <From_CConv_Reg>
3401f80c:	4602      	mov	r2, r0
3401f80e:	683b      	ldr	r3, [r7, #0]
3401f810:	609a      	str	r2, [r3, #8]
  pConfig->coeff[0][2] = From_CConv_Reg(colorConvConfig.RB);
3401f812:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
3401f816:	4618      	mov	r0, r3
3401f818:	f7ff f938 	bl	3401ea8c <From_CConv_Reg>
3401f81c:	4602      	mov	r2, r0
3401f81e:	683b      	ldr	r3, [r7, #0]
3401f820:	60da      	str	r2, [r3, #12]
  pConfig->coeff[1][0] = From_CConv_Reg(colorConvConfig.GR);
3401f822:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
3401f826:	4618      	mov	r0, r3
3401f828:	f7ff f930 	bl	3401ea8c <From_CConv_Reg>
3401f82c:	4602      	mov	r2, r0
3401f82e:	683b      	ldr	r3, [r7, #0]
3401f830:	611a      	str	r2, [r3, #16]
  pConfig->coeff[1][1] = From_CConv_Reg(colorConvConfig.GG);
3401f832:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
3401f836:	4618      	mov	r0, r3
3401f838:	f7ff f928 	bl	3401ea8c <From_CConv_Reg>
3401f83c:	4602      	mov	r2, r0
3401f83e:	683b      	ldr	r3, [r7, #0]
3401f840:	615a      	str	r2, [r3, #20]
  pConfig->coeff[1][2] = From_CConv_Reg(colorConvConfig.GB);
3401f842:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
3401f846:	4618      	mov	r0, r3
3401f848:	f7ff f920 	bl	3401ea8c <From_CConv_Reg>
3401f84c:	4602      	mov	r2, r0
3401f84e:	683b      	ldr	r3, [r7, #0]
3401f850:	619a      	str	r2, [r3, #24]
  pConfig->coeff[2][0] = From_CConv_Reg(colorConvConfig.BR);
3401f852:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
3401f856:	4618      	mov	r0, r3
3401f858:	f7ff f918 	bl	3401ea8c <From_CConv_Reg>
3401f85c:	4602      	mov	r2, r0
3401f85e:	683b      	ldr	r3, [r7, #0]
3401f860:	61da      	str	r2, [r3, #28]
  pConfig->coeff[2][1] = From_CConv_Reg(colorConvConfig.BG);
3401f862:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
3401f866:	4618      	mov	r0, r3
3401f868:	f7ff f910 	bl	3401ea8c <From_CConv_Reg>
3401f86c:	4602      	mov	r2, r0
3401f86e:	683b      	ldr	r3, [r7, #0]
3401f870:	621a      	str	r2, [r3, #32]
  pConfig->coeff[2][2] = From_CConv_Reg(colorConvConfig.BB);
3401f872:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
3401f876:	4618      	mov	r0, r3
3401f878:	f7ff f908 	bl	3401ea8c <From_CConv_Reg>
3401f87c:	4602      	mov	r2, r0
3401f87e:	683b      	ldr	r3, [r7, #0]
3401f880:	625a      	str	r2, [r3, #36]	@ 0x24

  return ISP_OK;
3401f882:	2300      	movs	r3, #0
}
3401f884:	4618      	mov	r0, r3
3401f886:	3728      	adds	r7, #40	@ 0x28
3401f888:	46bd      	mov	sp, r7
3401f88a:	bd80      	pop	{r7, pc}

3401f88c <ISP_SVC_Sensor_GetInfo>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor info
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetInfo(ISP_HandleTypeDef *hIsp, ISP_SensorInfoTypeDef *pConfig)
{
3401f88c:	b580      	push	{r7, lr}
3401f88e:	b082      	sub	sp, #8
3401f890:	af00      	add	r7, sp, #0
3401f892:	6078      	str	r0, [r7, #4]
3401f894:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f896:	687b      	ldr	r3, [r7, #4]
3401f898:	2b00      	cmp	r3, #0
3401f89a:	d002      	beq.n	3401f8a2 <ISP_SVC_Sensor_GetInfo+0x16>
3401f89c:	683b      	ldr	r3, [r7, #0]
3401f89e:	2b00      	cmp	r3, #0
3401f8a0:	d101      	bne.n	3401f8a6 <ISP_SVC_Sensor_GetInfo+0x1a>
  {
    return ISP_ERR_SENSORINFO_EINVAL;
3401f8a2:	236e      	movs	r3, #110	@ 0x6e
3401f8a4:	e010      	b.n	3401f8c8 <ISP_SVC_Sensor_GetInfo+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorInfo != NULL)
3401f8a6:	687b      	ldr	r3, [r7, #4]
3401f8a8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401f8aa:	2b00      	cmp	r3, #0
3401f8ac:	d00b      	beq.n	3401f8c6 <ISP_SVC_Sensor_GetInfo+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorInfo(hIsp->cameraInstance, pConfig) != 0)
3401f8ae:	687b      	ldr	r3, [r7, #4]
3401f8b0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
3401f8b2:	687a      	ldr	r2, [r7, #4]
3401f8b4:	6852      	ldr	r2, [r2, #4]
3401f8b6:	6839      	ldr	r1, [r7, #0]
3401f8b8:	4610      	mov	r0, r2
3401f8ba:	4798      	blx	r3
3401f8bc:	4603      	mov	r3, r0
3401f8be:	2b00      	cmp	r3, #0
3401f8c0:	d001      	beq.n	3401f8c6 <ISP_SVC_Sensor_GetInfo+0x3a>
    {
      return ISP_ERR_SENSORINFO;
3401f8c2:	236f      	movs	r3, #111	@ 0x6f
3401f8c4:	e000      	b.n	3401f8c8 <ISP_SVC_Sensor_GetInfo+0x3c>
    }
  }

  return ISP_OK;
3401f8c6:	2300      	movs	r3, #0
}
3401f8c8:	4618      	mov	r0, r3
3401f8ca:	3708      	adds	r7, #8
3401f8cc:	46bd      	mov	sp, r7
3401f8ce:	bd80      	pop	{r7, pc}

3401f8d0 <ISP_SVC_Sensor_SetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3401f8d0:	b580      	push	{r7, lr}
3401f8d2:	b082      	sub	sp, #8
3401f8d4:	af00      	add	r7, sp, #0
3401f8d6:	6078      	str	r0, [r7, #4]
3401f8d8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f8da:	687b      	ldr	r3, [r7, #4]
3401f8dc:	2b00      	cmp	r3, #0
3401f8de:	d002      	beq.n	3401f8e6 <ISP_SVC_Sensor_SetGain+0x16>
3401f8e0:	683b      	ldr	r3, [r7, #0]
3401f8e2:	2b00      	cmp	r3, #0
3401f8e4:	d101      	bne.n	3401f8ea <ISP_SVC_Sensor_SetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
3401f8e6:	2378      	movs	r3, #120	@ 0x78
3401f8e8:	e011      	b.n	3401f90e <ISP_SVC_Sensor_SetGain+0x3e>
  }

  if (hIsp->appliHelpers.SetSensorGain != NULL)
3401f8ea:	687b      	ldr	r3, [r7, #4]
3401f8ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401f8ee:	2b00      	cmp	r3, #0
3401f8f0:	d00c      	beq.n	3401f90c <ISP_SVC_Sensor_SetGain+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorGain(hIsp->cameraInstance, pConfig->gain) != 0)
3401f8f2:	687b      	ldr	r3, [r7, #4]
3401f8f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3401f8f6:	687a      	ldr	r2, [r7, #4]
3401f8f8:	6850      	ldr	r0, [r2, #4]
3401f8fa:	683a      	ldr	r2, [r7, #0]
3401f8fc:	6812      	ldr	r2, [r2, #0]
3401f8fe:	4611      	mov	r1, r2
3401f900:	4798      	blx	r3
3401f902:	4603      	mov	r3, r0
3401f904:	2b00      	cmp	r3, #0
3401f906:	d001      	beq.n	3401f90c <ISP_SVC_Sensor_SetGain+0x3c>
    {
      return ISP_ERR_SENSORGAIN;
3401f908:	2379      	movs	r3, #121	@ 0x79
3401f90a:	e000      	b.n	3401f90e <ISP_SVC_Sensor_SetGain+0x3e>
    }
  }

  return ISP_OK;
3401f90c:	2300      	movs	r3, #0
}
3401f90e:	4618      	mov	r0, r3
3401f910:	3708      	adds	r7, #8
3401f912:	46bd      	mov	sp, r7
3401f914:	bd80      	pop	{r7, pc}

3401f916 <ISP_SVC_Sensor_GetGain>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor gain configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetGain(ISP_HandleTypeDef *hIsp, ISP_SensorGainTypeDef *pConfig)
{
3401f916:	b580      	push	{r7, lr}
3401f918:	b082      	sub	sp, #8
3401f91a:	af00      	add	r7, sp, #0
3401f91c:	6078      	str	r0, [r7, #4]
3401f91e:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f920:	687b      	ldr	r3, [r7, #4]
3401f922:	2b00      	cmp	r3, #0
3401f924:	d002      	beq.n	3401f92c <ISP_SVC_Sensor_GetGain+0x16>
3401f926:	683b      	ldr	r3, [r7, #0]
3401f928:	2b00      	cmp	r3, #0
3401f92a:	d101      	bne.n	3401f930 <ISP_SVC_Sensor_GetGain+0x1a>
  {
    return ISP_ERR_SENSORGAIN_EINVAL;
3401f92c:	2378      	movs	r3, #120	@ 0x78
3401f92e:	e010      	b.n	3401f952 <ISP_SVC_Sensor_GetGain+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorGain != NULL)
3401f930:	687b      	ldr	r3, [r7, #4]
3401f932:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401f934:	2b00      	cmp	r3, #0
3401f936:	d00b      	beq.n	3401f950 <ISP_SVC_Sensor_GetGain+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorGain(hIsp->cameraInstance, (int32_t *)&pConfig->gain) != 0)
3401f938:	687b      	ldr	r3, [r7, #4]
3401f93a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3401f93c:	687a      	ldr	r2, [r7, #4]
3401f93e:	6852      	ldr	r2, [r2, #4]
3401f940:	6839      	ldr	r1, [r7, #0]
3401f942:	4610      	mov	r0, r2
3401f944:	4798      	blx	r3
3401f946:	4603      	mov	r3, r0
3401f948:	2b00      	cmp	r3, #0
3401f94a:	d001      	beq.n	3401f950 <ISP_SVC_Sensor_GetGain+0x3a>
    {
      return ISP_ERR_SENSORGAIN;
3401f94c:	2379      	movs	r3, #121	@ 0x79
3401f94e:	e000      	b.n	3401f952 <ISP_SVC_Sensor_GetGain+0x3c>
    }
  }

  return ISP_OK;
3401f950:	2300      	movs	r3, #0
}
3401f952:	4618      	mov	r0, r3
3401f954:	3708      	adds	r7, #8
3401f956:	46bd      	mov	sp, r7
3401f958:	bd80      	pop	{r7, pc}

3401f95a <ISP_SVC_Sensor_SetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_SetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3401f95a:	b580      	push	{r7, lr}
3401f95c:	b082      	sub	sp, #8
3401f95e:	af00      	add	r7, sp, #0
3401f960:	6078      	str	r0, [r7, #4]
3401f962:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f964:	687b      	ldr	r3, [r7, #4]
3401f966:	2b00      	cmp	r3, #0
3401f968:	d002      	beq.n	3401f970 <ISP_SVC_Sensor_SetExposure+0x16>
3401f96a:	683b      	ldr	r3, [r7, #0]
3401f96c:	2b00      	cmp	r3, #0
3401f96e:	d101      	bne.n	3401f974 <ISP_SVC_Sensor_SetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3401f970:	2382      	movs	r3, #130	@ 0x82
3401f972:	e011      	b.n	3401f998 <ISP_SVC_Sensor_SetExposure+0x3e>
  }

  if (hIsp->appliHelpers.SetSensorExposure != NULL)
3401f974:	687b      	ldr	r3, [r7, #4]
3401f976:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401f978:	2b00      	cmp	r3, #0
3401f97a:	d00c      	beq.n	3401f996 <ISP_SVC_Sensor_SetExposure+0x3c>
  {
    if (hIsp->appliHelpers.SetSensorExposure(hIsp->cameraInstance, pConfig->exposure) != 0)
3401f97c:	687b      	ldr	r3, [r7, #4]
3401f97e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3401f980:	687a      	ldr	r2, [r7, #4]
3401f982:	6850      	ldr	r0, [r2, #4]
3401f984:	683a      	ldr	r2, [r7, #0]
3401f986:	6812      	ldr	r2, [r2, #0]
3401f988:	4611      	mov	r1, r2
3401f98a:	4798      	blx	r3
3401f98c:	4603      	mov	r3, r0
3401f98e:	2b00      	cmp	r3, #0
3401f990:	d001      	beq.n	3401f996 <ISP_SVC_Sensor_SetExposure+0x3c>
    {
      return ISP_ERR_SENSOREXPOSURE;
3401f992:	2383      	movs	r3, #131	@ 0x83
3401f994:	e000      	b.n	3401f998 <ISP_SVC_Sensor_SetExposure+0x3e>
    }
  }

  return ISP_OK;
3401f996:	2300      	movs	r3, #0
}
3401f998:	4618      	mov	r0, r3
3401f99a:	3708      	adds	r7, #8
3401f99c:	46bd      	mov	sp, r7
3401f99e:	bd80      	pop	{r7, pc}

3401f9a0 <ISP_SVC_Sensor_GetExposure>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the sensor exposure configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_Sensor_GetExposure(ISP_HandleTypeDef *hIsp, ISP_SensorExposureTypeDef *pConfig)
{
3401f9a0:	b580      	push	{r7, lr}
3401f9a2:	b082      	sub	sp, #8
3401f9a4:	af00      	add	r7, sp, #0
3401f9a6:	6078      	str	r0, [r7, #4]
3401f9a8:	6039      	str	r1, [r7, #0]
  /* Check handle validity */
  if ((hIsp == NULL) || (pConfig == NULL))
3401f9aa:	687b      	ldr	r3, [r7, #4]
3401f9ac:	2b00      	cmp	r3, #0
3401f9ae:	d002      	beq.n	3401f9b6 <ISP_SVC_Sensor_GetExposure+0x16>
3401f9b0:	683b      	ldr	r3, [r7, #0]
3401f9b2:	2b00      	cmp	r3, #0
3401f9b4:	d101      	bne.n	3401f9ba <ISP_SVC_Sensor_GetExposure+0x1a>
  {
    return ISP_ERR_SENSOREXPOSURE_EINVAL;
3401f9b6:	2382      	movs	r3, #130	@ 0x82
3401f9b8:	e010      	b.n	3401f9dc <ISP_SVC_Sensor_GetExposure+0x3c>
  }

  if (hIsp->appliHelpers.GetSensorExposure != NULL)
3401f9ba:	687b      	ldr	r3, [r7, #4]
3401f9bc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401f9be:	2b00      	cmp	r3, #0
3401f9c0:	d00b      	beq.n	3401f9da <ISP_SVC_Sensor_GetExposure+0x3a>
  {
    if (hIsp->appliHelpers.GetSensorExposure(hIsp->cameraInstance, (int32_t *)&pConfig->exposure) != 0)
3401f9c2:	687b      	ldr	r3, [r7, #4]
3401f9c4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3401f9c6:	687a      	ldr	r2, [r7, #4]
3401f9c8:	6852      	ldr	r2, [r2, #4]
3401f9ca:	6839      	ldr	r1, [r7, #0]
3401f9cc:	4610      	mov	r0, r2
3401f9ce:	4798      	blx	r3
3401f9d0:	4603      	mov	r3, r0
3401f9d2:	2b00      	cmp	r3, #0
3401f9d4:	d001      	beq.n	3401f9da <ISP_SVC_Sensor_GetExposure+0x3a>
    {
      return ISP_ERR_SENSOREXPOSURE;
3401f9d6:	2383      	movs	r3, #131	@ 0x83
3401f9d8:	e000      	b.n	3401f9dc <ISP_SVC_Sensor_GetExposure+0x3c>
    }
  }

  return ISP_OK;
3401f9da:	2300      	movs	r3, #0
}
3401f9dc:	4618      	mov	r0, r3
3401f9de:	3708      	adds	r7, #8
3401f9e0:	46bd      	mov	sp, r7
3401f9e2:	bd80      	pop	{r7, pc}

3401f9e4 <ISP_SVC_Misc_IsDCMIPPReady>:
  *         Check that the DCMIPP device is ready
  * @param  hIsp: ISP device handle
  * @retval ISP_OK if DCMIPP is running, ISP_FAIL otherwise
  */
ISP_StatusTypeDef ISP_SVC_Misc_IsDCMIPPReady(ISP_HandleTypeDef *hIsp)
{
3401f9e4:	b580      	push	{r7, lr}
3401f9e6:	b082      	sub	sp, #8
3401f9e8:	af00      	add	r7, sp, #0
3401f9ea:	6078      	str	r0, [r7, #4]
  /* Check handle validity */
  if (hIsp == NULL)
3401f9ec:	687b      	ldr	r3, [r7, #4]
3401f9ee:	2b00      	cmp	r3, #0
3401f9f0:	d101      	bne.n	3401f9f6 <ISP_SVC_Misc_IsDCMIPPReady+0x12>
  {
    return ISP_ERR_EINVAL;
3401f9f2:	2301      	movs	r3, #1
3401f9f4:	e00a      	b.n	3401fa0c <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  if (HAL_DCMIPP_GetState(hIsp->hDcmipp) != HAL_DCMIPP_STATE_READY)
3401f9f6:	687b      	ldr	r3, [r7, #4]
3401f9f8:	681b      	ldr	r3, [r3, #0]
3401f9fa:	4618      	mov	r0, r3
3401f9fc:	f7ea fa0a 	bl	34009e14 <HAL_DCMIPP_GetState>
3401fa00:	4603      	mov	r3, r0
3401fa02:	2b02      	cmp	r3, #2
3401fa04:	d001      	beq.n	3401fa0a <ISP_SVC_Misc_IsDCMIPPReady+0x26>
  {
    return ISP_ERR_DCMIPP_STATE;
3401fa06:	238c      	movs	r3, #140	@ 0x8c
3401fa08:	e000      	b.n	3401fa0c <ISP_SVC_Misc_IsDCMIPPReady+0x28>
  }

  return ISP_OK;
3401fa0a:	2300      	movs	r3, #0
}
3401fa0c:	4618      	mov	r0, r3
3401fa0e:	3708      	adds	r7, #8
3401fa10:	46bd      	mov	sp, r7
3401fa12:	bd80      	pop	{r7, pc}

3401fa14 <ISP_SVC_Misc_IncMainFrameId>:
  *         Increment the id of the frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncMainFrameId(ISP_HandleTypeDef *hIsp)
{
3401fa14:	b480      	push	{r7}
3401fa16:	b083      	sub	sp, #12
3401fa18:	af00      	add	r7, sp, #0
3401fa1a:	6078      	str	r0, [r7, #4]
  hIsp->MainPipe_FrameCount++;
3401fa1c:	687b      	ldr	r3, [r7, #4]
3401fa1e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3401fa20:	1c5a      	adds	r2, r3, #1
3401fa22:	687b      	ldr	r3, [r7, #4]
3401fa24:	641a      	str	r2, [r3, #64]	@ 0x40
}
3401fa26:	bf00      	nop
3401fa28:	370c      	adds	r7, #12
3401fa2a:	46bd      	mov	sp, r7
3401fa2c:	f85d 7b04 	ldr.w	r7, [sp], #4
3401fa30:	4770      	bx	lr

3401fa32 <ISP_SVC_Misc_GetMainFrameId>:
  *         Return the id of the last frame output on the main pipe
  * @param  hIsp: ISP device handle
  * @retval Id of the last frame output on the main pipe
  */
uint32_t ISP_SVC_Misc_GetMainFrameId(ISP_HandleTypeDef *hIsp)
{
3401fa32:	b480      	push	{r7}
3401fa34:	b083      	sub	sp, #12
3401fa36:	af00      	add	r7, sp, #0
3401fa38:	6078      	str	r0, [r7, #4]
  return hIsp->MainPipe_FrameCount;
3401fa3a:	687b      	ldr	r3, [r7, #4]
3401fa3c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
3401fa3e:	4618      	mov	r0, r3
3401fa40:	370c      	adds	r7, #12
3401fa42:	46bd      	mov	sp, r7
3401fa44:	f85d 7b04 	ldr.w	r7, [sp], #4
3401fa48:	4770      	bx	lr

3401fa4a <ISP_SVC_Misc_IncAncillaryFrameId>:
  *         Increment the id of the frame output on the ancillary pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncAncillaryFrameId(ISP_HandleTypeDef *hIsp)
{
3401fa4a:	b480      	push	{r7}
3401fa4c:	b083      	sub	sp, #12
3401fa4e:	af00      	add	r7, sp, #0
3401fa50:	6078      	str	r0, [r7, #4]
  hIsp->AncillaryPipe_FrameCount++;
3401fa52:	687b      	ldr	r3, [r7, #4]
3401fa54:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3401fa56:	1c5a      	adds	r2, r3, #1
3401fa58:	687b      	ldr	r3, [r7, #4]
3401fa5a:	645a      	str	r2, [r3, #68]	@ 0x44
}
3401fa5c:	bf00      	nop
3401fa5e:	370c      	adds	r7, #12
3401fa60:	46bd      	mov	sp, r7
3401fa62:	f85d 7b04 	ldr.w	r7, [sp], #4
3401fa66:	4770      	bx	lr

3401fa68 <ISP_SVC_Misc_IncDumpFrameId>:
  *         Increment the id of the frame output on the dump pipe
  * @param  hIsp: ISP device handle
  * @retval none
  */
void ISP_SVC_Misc_IncDumpFrameId(ISP_HandleTypeDef *hIsp)
{
3401fa68:	b480      	push	{r7}
3401fa6a:	b083      	sub	sp, #12
3401fa6c:	af00      	add	r7, sp, #0
3401fa6e:	6078      	str	r0, [r7, #4]
  hIsp->DumpPipe_FrameCount++;
3401fa70:	687b      	ldr	r3, [r7, #4]
3401fa72:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3401fa74:	1c5a      	adds	r2, r3, #1
3401fa76:	687b      	ldr	r3, [r7, #4]
3401fa78:	649a      	str	r2, [r3, #72]	@ 0x48
}
3401fa7a:	bf00      	nop
3401fa7c:	370c      	adds	r7, #12
3401fa7e:	46bd      	mov	sp, r7
3401fa80:	f85d 7b04 	ldr.w	r7, [sp], #4
3401fa84:	4770      	bx	lr

3401fa86 <ISP_SVC_Misc_IsGammaEnabled>:
  * @param  hIsp: ISP device handle
  * @param  Pipe: DCMIPP pipe line
  * @retval 1 if enabled 0 otherwise
  */
bool ISP_SVC_Misc_IsGammaEnabled(ISP_HandleTypeDef *hIsp, uint32_t Pipe)
{
3401fa86:	b580      	push	{r7, lr}
3401fa88:	b084      	sub	sp, #16
3401fa8a:	af00      	add	r7, sp, #0
3401fa8c:	6078      	str	r0, [r7, #4]
3401fa8e:	6039      	str	r1, [r7, #0]
  uint8_t ret;

  /* Check handle validity */
  if (hIsp == NULL)
3401fa90:	687b      	ldr	r3, [r7, #4]
3401fa92:	2b00      	cmp	r3, #0
3401fa94:	d101      	bne.n	3401fa9a <ISP_SVC_Misc_IsGammaEnabled+0x14>
  {
    return ISP_ERR_EINVAL;
3401fa96:	2301      	movs	r3, #1
3401fa98:	e020      	b.n	3401fadc <ISP_SVC_Misc_IsGammaEnabled+0x56>
  }

  switch(Pipe)
3401fa9a:	683b      	ldr	r3, [r7, #0]
3401fa9c:	2b01      	cmp	r3, #1
3401fa9e:	d003      	beq.n	3401faa8 <ISP_SVC_Misc_IsGammaEnabled+0x22>
3401faa0:	683b      	ldr	r3, [r7, #0]
3401faa2:	2b02      	cmp	r3, #2
3401faa4:	d009      	beq.n	3401faba <ISP_SVC_Misc_IsGammaEnabled+0x34>
3401faa6:	e011      	b.n	3401facc <ISP_SVC_Misc_IsGammaEnabled+0x46>
  {
  case 1:
    ret = HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1);
3401faa8:	687b      	ldr	r3, [r7, #4]
3401faaa:	681b      	ldr	r3, [r3, #0]
3401faac:	2101      	movs	r1, #1
3401faae:	4618      	mov	r0, r3
3401fab0:	f7e9 f8d0 	bl	34008c54 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3401fab4:	4603      	mov	r3, r0
3401fab6:	73fb      	strb	r3, [r7, #15]
    break;
3401fab8:	e00a      	b.n	3401fad0 <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  case 2:
    ret = HAL_DCMIPP_PIPE_IsEnabledGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2);
3401faba:	687b      	ldr	r3, [r7, #4]
3401fabc:	681b      	ldr	r3, [r3, #0]
3401fabe:	2102      	movs	r1, #2
3401fac0:	4618      	mov	r0, r3
3401fac2:	f7e9 f8c7 	bl	34008c54 <HAL_DCMIPP_PIPE_IsEnabledGammaConversion>
3401fac6:	4603      	mov	r3, r0
3401fac8:	73fb      	strb	r3, [r7, #15]
    break;
3401faca:	e001      	b.n	3401fad0 <ISP_SVC_Misc_IsGammaEnabled+0x4a>
  default:
    ret = 0; /*  No gamma on pipe 0 */
3401facc:	2300      	movs	r3, #0
3401face:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
3401fad0:	7bfb      	ldrb	r3, [r7, #15]
3401fad2:	2b00      	cmp	r3, #0
3401fad4:	bf14      	ite	ne
3401fad6:	2301      	movne	r3, #1
3401fad8:	2300      	moveq	r3, #0
3401fada:	b2db      	uxtb	r3, r3
}
3401fadc:	4618      	mov	r0, r3
3401fade:	3710      	adds	r7, #16
3401fae0:	46bd      	mov	sp, r7
3401fae2:	bd80      	pop	{r7, pc}

3401fae4 <ISP_SVC_ISP_SetGamma>:
  * @param  hIsp: ISP device handle
  * @param  pConfig: Pointer to the ISP gamma configuration
  * @retval operation result
  */
ISP_StatusTypeDef ISP_SVC_ISP_SetGamma(ISP_HandleTypeDef *hIsp, ISP_GammaTypeDef *pConfig)
{
3401fae4:	b580      	push	{r7, lr}
3401fae6:	b082      	sub	sp, #8
3401fae8:	af00      	add	r7, sp, #0
3401faea:	6078      	str	r0, [r7, #4]
3401faec:	6039      	str	r1, [r7, #0]
  if ((hIsp == NULL) || (pConfig == NULL))
3401faee:	687b      	ldr	r3, [r7, #4]
3401faf0:	2b00      	cmp	r3, #0
3401faf2:	d002      	beq.n	3401fafa <ISP_SVC_ISP_SetGamma+0x16>
3401faf4:	683b      	ldr	r3, [r7, #0]
3401faf6:	2b00      	cmp	r3, #0
3401faf8:	d101      	bne.n	3401fafe <ISP_SVC_ISP_SetGamma+0x1a>
  {
    return ISP_ERR_DCMIPP_GAMMA;
3401fafa:	2395      	movs	r3, #149	@ 0x95
3401fafc:	e034      	b.n	3401fb68 <ISP_SVC_ISP_SetGamma+0x84>
  }

  if (pConfig->enablePipe1 == 0)
3401fafe:	683b      	ldr	r3, [r7, #0]
3401fb00:	781b      	ldrb	r3, [r3, #0]
3401fb02:	2b00      	cmp	r3, #0
3401fb04:	d10a      	bne.n	3401fb1c <ISP_SVC_ISP_SetGamma+0x38>
  {
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3401fb06:	687b      	ldr	r3, [r7, #4]
3401fb08:	681b      	ldr	r3, [r3, #0]
3401fb0a:	2101      	movs	r1, #1
3401fb0c:	4618      	mov	r0, r3
3401fb0e:	f7e9 f872 	bl	34008bf6 <HAL_DCMIPP_PIPE_DisableGammaConversion>
3401fb12:	4603      	mov	r3, r0
3401fb14:	2b00      	cmp	r3, #0
3401fb16:	d00c      	beq.n	3401fb32 <ISP_SVC_ISP_SetGamma+0x4e>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3401fb18:	2395      	movs	r3, #149	@ 0x95
3401fb1a:	e025      	b.n	3401fb68 <ISP_SVC_ISP_SetGamma+0x84>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE1) != HAL_OK)
3401fb1c:	687b      	ldr	r3, [r7, #4]
3401fb1e:	681b      	ldr	r3, [r3, #0]
3401fb20:	2101      	movs	r1, #1
3401fb22:	4618      	mov	r0, r3
3401fb24:	f7e9 f838 	bl	34008b98 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3401fb28:	4603      	mov	r3, r0
3401fb2a:	2b00      	cmp	r3, #0
3401fb2c:	d001      	beq.n	3401fb32 <ISP_SVC_ISP_SetGamma+0x4e>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3401fb2e:	2395      	movs	r3, #149	@ 0x95
3401fb30:	e01a      	b.n	3401fb68 <ISP_SVC_ISP_SetGamma+0x84>
    }
  }

  if (pConfig->enablePipe2 == 0)
3401fb32:	683b      	ldr	r3, [r7, #0]
3401fb34:	785b      	ldrb	r3, [r3, #1]
3401fb36:	2b00      	cmp	r3, #0
3401fb38:	d10a      	bne.n	3401fb50 <ISP_SVC_ISP_SetGamma+0x6c>
  {
    if (HAL_DCMIPP_PIPE_DisableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3401fb3a:	687b      	ldr	r3, [r7, #4]
3401fb3c:	681b      	ldr	r3, [r3, #0]
3401fb3e:	2102      	movs	r1, #2
3401fb40:	4618      	mov	r0, r3
3401fb42:	f7e9 f858 	bl	34008bf6 <HAL_DCMIPP_PIPE_DisableGammaConversion>
3401fb46:	4603      	mov	r3, r0
3401fb48:	2b00      	cmp	r3, #0
3401fb4a:	d00c      	beq.n	3401fb66 <ISP_SVC_ISP_SetGamma+0x82>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3401fb4c:	2395      	movs	r3, #149	@ 0x95
3401fb4e:	e00b      	b.n	3401fb68 <ISP_SVC_ISP_SetGamma+0x84>
    }
  }
  else
  {
    if (HAL_DCMIPP_PIPE_EnableGammaConversion(hIsp->hDcmipp, DCMIPP_PIPE2) != HAL_OK)
3401fb50:	687b      	ldr	r3, [r7, #4]
3401fb52:	681b      	ldr	r3, [r3, #0]
3401fb54:	2102      	movs	r1, #2
3401fb56:	4618      	mov	r0, r3
3401fb58:	f7e9 f81e 	bl	34008b98 <HAL_DCMIPP_PIPE_EnableGammaConversion>
3401fb5c:	4603      	mov	r3, r0
3401fb5e:	2b00      	cmp	r3, #0
3401fb60:	d001      	beq.n	3401fb66 <ISP_SVC_ISP_SetGamma+0x82>
    {
      return ISP_ERR_DCMIPP_GAMMA;
3401fb62:	2395      	movs	r3, #149	@ 0x95
3401fb64:	e000      	b.n	3401fb68 <ISP_SVC_ISP_SetGamma+0x84>
    }
  }

  return ISP_OK;
3401fb66:	2300      	movs	r3, #0
}
3401fb68:	4618      	mov	r0, r3
3401fb6a:	3708      	adds	r7, #8
3401fb6c:	46bd      	mov	sp, r7
3401fb6e:	bd80      	pop	{r7, pc}

3401fb70 <ISP_SVC_IQParam_Init>:
  *         Initialize the IQ parameters cache with values from non volatile memory
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_IQParam_Init(ISP_HandleTypeDef *hIsp, const ISP_IQParamTypeDef *ISP_IQParamCacheInit)
{
3401fb70:	b580      	push	{r7, lr}
3401fb72:	b082      	sub	sp, #8
3401fb74:	af00      	add	r7, sp, #0
3401fb76:	6078      	str	r0, [r7, #4]
3401fb78:	6039      	str	r1, [r7, #0]
  (void)hIsp; /* unused */

  ISP_IQParamCache = *ISP_IQParamCacheInit;
3401fb7a:	4a07      	ldr	r2, [pc, #28]	@ (3401fb98 <ISP_SVC_IQParam_Init+0x28>)
3401fb7c:	683b      	ldr	r3, [r7, #0]
3401fb7e:	4610      	mov	r0, r2
3401fb80:	4619      	mov	r1, r3
3401fb82:	f44f 7315 	mov.w	r3, #596	@ 0x254
3401fb86:	461a      	mov	r2, r3
3401fb88:	f007 fd93 	bl	340276b2 <memcpy>
  return ISP_OK;
3401fb8c:	2300      	movs	r3, #0
}
3401fb8e:	4618      	mov	r0, r3
3401fb90:	3708      	adds	r7, #8
3401fb92:	46bd      	mov	sp, r7
3401fb94:	bd80      	pop	{r7, pc}
3401fb96:	bf00      	nop
3401fb98:	3404a700 	.word	0x3404a700

3401fb9c <ISP_SVC_IQParam_Get>:
  *         Get the pointer to the IQ parameters cache
  * @param  hIsp: ISP device handle
  * @retval Pointer to the IQ Param config
  */
ISP_IQParamTypeDef *ISP_SVC_IQParam_Get(ISP_HandleTypeDef *hIsp)
{
3401fb9c:	b480      	push	{r7}
3401fb9e:	b083      	sub	sp, #12
3401fba0:	af00      	add	r7, sp, #0
3401fba2:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */

  return &ISP_IQParamCache;
3401fba4:	4b03      	ldr	r3, [pc, #12]	@ (3401fbb4 <ISP_SVC_IQParam_Get+0x18>)
}
3401fba6:	4618      	mov	r0, r3
3401fba8:	370c      	adds	r7, #12
3401fbaa:	46bd      	mov	sp, r7
3401fbac:	f85d 7b04 	ldr.w	r7, [sp], #4
3401fbb0:	4770      	bx	lr
3401fbb2:	bf00      	nop
3401fbb4:	3404a700 	.word	0x3404a700

3401fbb8 <ISP_SVC_Stats_Init>:
  *         Initialize the statistic engine
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Init(ISP_HandleTypeDef *hIsp)
{
3401fbb8:	b580      	push	{r7, lr}
3401fbba:	b082      	sub	sp, #8
3401fbbc:	af00      	add	r7, sp, #0
3401fbbe:	6078      	str	r0, [r7, #4]
  memset(&ISP_SVC_StatEngine, 0, sizeof(ISP_SVC_StatEngineTypeDef));
3401fbc0:	f44f 72b0 	mov.w	r2, #352	@ 0x160
3401fbc4:	2100      	movs	r1, #0
3401fbc6:	4803      	ldr	r0, [pc, #12]	@ (3401fbd4 <ISP_SVC_Stats_Init+0x1c>)
3401fbc8:	f007 fae4 	bl	34027194 <memset>
}
3401fbcc:	bf00      	nop
3401fbce:	3708      	adds	r7, #8
3401fbd0:	46bd      	mov	sp, r7
3401fbd2:	bd80      	pop	{r7, pc}
3401fbd4:	3404a954 	.word	0x3404a954

3401fbd8 <ISP_SVC_Stats_Gather>:
  *         Gather statistics
  * @param  hIsp: ISP device handle
  * @retval None
  */
void ISP_SVC_Stats_Gather(ISP_HandleTypeDef *hIsp)
{
3401fbd8:	b5b0      	push	{r4, r5, r7, lr}
3401fbda:	b092      	sub	sp, #72	@ 0x48
3401fbdc:	af00      	add	r7, sp, #0
3401fbde:	6078      	str	r0, [r7, #4]
  ISP_IQParamTypeDef *IQParamConfig;
  ISP_SVC_StatStateTypeDef *ongoing;
  uint32_t i, avgR, avgG, avgB, frameId;

  /* Check handle validity */
  if (hIsp == NULL)
3401fbe0:	687b      	ldr	r3, [r7, #4]
3401fbe2:	2b00      	cmp	r3, #0
3401fbe4:	d103      	bne.n	3401fbee <ISP_SVC_Stats_Gather+0x16>
  {
    printf("ERROR: ISP handle is NULL\r\n");
3401fbe6:	48ba      	ldr	r0, [pc, #744]	@ (3401fed0 <ISP_SVC_Stats_Gather+0x2f8>)
3401fbe8:	f007 f8b4 	bl	34026d54 <puts>
    return;
3401fbec:	e2a7      	b.n	3402013e <ISP_SVC_Stats_Gather+0x566>
  }

  if (hIsp->hDcmipp == NULL)
3401fbee:	687b      	ldr	r3, [r7, #4]
3401fbf0:	681b      	ldr	r3, [r3, #0]
3401fbf2:	2b00      	cmp	r3, #0
3401fbf4:	f000 82a2 	beq.w	3402013c <ISP_SVC_Stats_Gather+0x564>
  }

  /* Read the stats according to the configuration applied 2 VSYNC (shadow register + stat computation)
   * stages earlier.
   */
  ongoing = &ISP_SVC_StatEngine.ongoing;
3401fbf8:	4bb6      	ldr	r3, [pc, #728]	@ (3401fed4 <ISP_SVC_Stats_Gather+0x2fc>)
3401fbfa:	643b      	str	r3, [r7, #64]	@ 0x40
  switch(stagePrevious2)
3401fbfc:	4bb6      	ldr	r3, [pc, #728]	@ (3401fed8 <ISP_SVC_Stats_Gather+0x300>)
3401fbfe:	781b      	ldrb	r3, [r3, #0]
3401fc00:	2b09      	cmp	r3, #9
3401fc02:	f200 80fd 	bhi.w	3401fe00 <ISP_SVC_Stats_Gather+0x228>
3401fc06:	a201      	add	r2, pc, #4	@ (adr r2, 3401fc0c <ISP_SVC_Stats_Gather+0x34>)
3401fc08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401fc0c:	3401fc35 	.word	0x3401fc35
3401fc10:	3401fcbd 	.word	0x3401fcbd
3401fc14:	3401fccb 	.word	0x3401fccb
3401fc18:	3401fcd9 	.word	0x3401fcd9
3401fc1c:	3401fce7 	.word	0x3401fce7
3401fc20:	3401fcf5 	.word	0x3401fcf5
3401fc24:	3401fdc9 	.word	0x3401fdc9
3401fc28:	3401fdd7 	.word	0x3401fdd7
3401fc2c:	3401fde5 	.word	0x3401fde5
3401fc30:	3401fdf3 	.word	0x3401fdf3
  {
  case ISP_STAT_CFG_UP_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3401fc34:	687b      	ldr	r3, [r7, #4]
3401fc36:	6818      	ldr	r0, [r3, #0]
3401fc38:	f107 0310 	add.w	r3, r7, #16
3401fc3c:	2201      	movs	r2, #1
3401fc3e:	2101      	movs	r1, #1
3401fc40:	f7e9 ff35 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3401fc44:	687b      	ldr	r3, [r7, #4]
3401fc46:	6818      	ldr	r0, [r3, #0]
3401fc48:	f107 030c 	add.w	r3, r7, #12
3401fc4c:	2202      	movs	r2, #2
3401fc4e:	2101      	movs	r1, #1
3401fc50:	f7e9 ff2d 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3401fc54:	687b      	ldr	r3, [r7, #4]
3401fc56:	6818      	ldr	r0, [r3, #0]
3401fc58:	f107 0308 	add.w	r3, r7, #8
3401fc5c:	2203      	movs	r2, #3
3401fc5e:	2101      	movs	r1, #1
3401fc60:	f7e9 ff25 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->up.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_RED, avgR);
3401fc64:	693b      	ldr	r3, [r7, #16]
3401fc66:	2200      	movs	r2, #0
3401fc68:	2101      	movs	r1, #1
3401fc6a:	6878      	ldr	r0, [r7, #4]
3401fc6c:	f7fe ff36 	bl	3401eadc <GetAvgStats>
3401fc70:	4603      	mov	r3, r0
3401fc72:	461a      	mov	r2, r3
3401fc74:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fc76:	701a      	strb	r2, [r3, #0]
    ongoing->up.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_GREEN, avgG);
3401fc78:	68fb      	ldr	r3, [r7, #12]
3401fc7a:	2201      	movs	r2, #1
3401fc7c:	2101      	movs	r1, #1
3401fc7e:	6878      	ldr	r0, [r7, #4]
3401fc80:	f7fe ff2c 	bl	3401eadc <GetAvgStats>
3401fc84:	4603      	mov	r3, r0
3401fc86:	461a      	mov	r2, r3
3401fc88:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fc8a:	705a      	strb	r2, [r3, #1]
    ongoing->up.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_UP, ISP_BLUE, avgB);
3401fc8c:	68bb      	ldr	r3, [r7, #8]
3401fc8e:	2202      	movs	r2, #2
3401fc90:	2101      	movs	r1, #1
3401fc92:	6878      	ldr	r0, [r7, #4]
3401fc94:	f7fe ff22 	bl	3401eadc <GetAvgStats>
3401fc98:	4603      	mov	r3, r0
3401fc9a:	461a      	mov	r2, r3
3401fc9c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fc9e:	709a      	strb	r2, [r3, #2]
    ongoing->up.averageL = LuminanceFromRGB(ongoing->up.averageR, ongoing->up.averageG, ongoing->up.averageB);
3401fca0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fca2:	7818      	ldrb	r0, [r3, #0]
3401fca4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fca6:	7859      	ldrb	r1, [r3, #1]
3401fca8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fcaa:	789b      	ldrb	r3, [r3, #2]
3401fcac:	461a      	mov	r2, r3
3401fcae:	f7ff f8ff 	bl	3401eeb0 <LuminanceFromRGB>
3401fcb2:	4603      	mov	r3, r0
3401fcb4:	461a      	mov	r2, r3
3401fcb6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fcb8:	70da      	strb	r2, [r3, #3]
    break;
3401fcba:	e0a2      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[0]);
3401fcbc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fcbe:	3304      	adds	r3, #4
3401fcc0:	4619      	mov	r1, r3
3401fcc2:	6878      	ldr	r0, [r7, #4]
3401fcc4:	f7fe ff4e 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fcc8:	e09b      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[3]);
3401fcca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fccc:	3310      	adds	r3, #16
3401fcce:	4619      	mov	r1, r3
3401fcd0:	6878      	ldr	r0, [r7, #4]
3401fcd2:	f7fe ff47 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fcd6:	e094      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[6]);
3401fcd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fcda:	331c      	adds	r3, #28
3401fcdc:	4619      	mov	r1, r3
3401fcde:	6878      	ldr	r0, [r7, #4]
3401fce0:	f7fe ff40 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fce4:	e08d      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_UP_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->up.histogram[9]);
3401fce6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fce8:	3328      	adds	r3, #40	@ 0x28
3401fcea:	4619      	mov	r1, r3
3401fcec:	6878      	ldr	r0, [r7, #4]
3401fcee:	f7fe ff39 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fcf2:	e086      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_AVG:
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE1, &avgR);
3401fcf4:	687b      	ldr	r3, [r7, #4]
3401fcf6:	6818      	ldr	r0, [r3, #0]
3401fcf8:	f107 0310 	add.w	r3, r7, #16
3401fcfc:	2201      	movs	r2, #1
3401fcfe:	2101      	movs	r1, #1
3401fd00:	f7e9 fed5 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE2, &avgG);
3401fd04:	687b      	ldr	r3, [r7, #4]
3401fd06:	6818      	ldr	r0, [r3, #0]
3401fd08:	f107 030c 	add.w	r3, r7, #12
3401fd0c:	2202      	movs	r2, #2
3401fd0e:	2101      	movs	r1, #1
3401fd10:	f7e9 fecd 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>
    HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter(hIsp->hDcmipp, DCMIPP_PIPE1, DCMIPP_STATEXT_MODULE3, &avgB);
3401fd14:	687b      	ldr	r3, [r7, #4]
3401fd16:	6818      	ldr	r0, [r3, #0]
3401fd18:	f107 0308 	add.w	r3, r7, #8
3401fd1c:	2203      	movs	r2, #3
3401fd1e:	2101      	movs	r1, #1
3401fd20:	f7e9 fec5 	bl	34009aae <HAL_DCMIPP_PIPE_GetISPAccumulatedStatisticsCounter>

    ongoing->down.averageR = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_RED, avgR);
3401fd24:	693b      	ldr	r3, [r7, #16]
3401fd26:	2200      	movs	r2, #0
3401fd28:	2102      	movs	r1, #2
3401fd2a:	6878      	ldr	r0, [r7, #4]
3401fd2c:	f7fe fed6 	bl	3401eadc <GetAvgStats>
3401fd30:	4603      	mov	r3, r0
3401fd32:	461a      	mov	r2, r3
3401fd34:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd36:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    ongoing->down.averageG = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_GREEN, avgG);
3401fd3a:	68fb      	ldr	r3, [r7, #12]
3401fd3c:	2201      	movs	r2, #1
3401fd3e:	2102      	movs	r1, #2
3401fd40:	6878      	ldr	r0, [r7, #4]
3401fd42:	f7fe fecb 	bl	3401eadc <GetAvgStats>
3401fd46:	4603      	mov	r3, r0
3401fd48:	461a      	mov	r2, r3
3401fd4a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd4c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    ongoing->down.averageB = GetAvgStats(hIsp, ISP_STAT_LOC_DOWN, ISP_BLUE, avgB);
3401fd50:	68bb      	ldr	r3, [r7, #8]
3401fd52:	2202      	movs	r2, #2
3401fd54:	2102      	movs	r1, #2
3401fd56:	6878      	ldr	r0, [r7, #4]
3401fd58:	f7fe fec0 	bl	3401eadc <GetAvgStats>
3401fd5c:	4603      	mov	r3, r0
3401fd5e:	461a      	mov	r2, r3
3401fd60:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd62:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36
    IQParamConfig = ISP_SVC_IQParam_Get(hIsp);
3401fd66:	6878      	ldr	r0, [r7, #4]
3401fd68:	f7ff ff18 	bl	3401fb9c <ISP_SVC_IQParam_Get>
3401fd6c:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if ((hIsp->sensorInfo.bayer_pattern == ISP_DEMOS_TYPE_MONO) || (!IQParamConfig->demosaicing.enable))
3401fd6e:	687b      	ldr	r3, [r7, #4]
3401fd70:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
3401fd74:	2b04      	cmp	r3, #4
3401fd76:	d003      	beq.n	3401fd80 <ISP_SVC_Stats_Gather+0x1a8>
3401fd78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3401fd7a:	7b1b      	ldrb	r3, [r3, #12]
3401fd7c:	2b00      	cmp	r3, #0
3401fd7e:	d111      	bne.n	3401fda4 <ISP_SVC_Stats_Gather+0x1cc>
    {
      ongoing->down.averageL = LuminanceFromRGBMono(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3401fd80:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd82:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
3401fd86:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd88:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
3401fd8c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd8e:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3401fd92:	461a      	mov	r2, r3
3401fd94:	f7ff f8cc 	bl	3401ef30 <LuminanceFromRGBMono>
3401fd98:	4603      	mov	r3, r0
3401fd9a:	461a      	mov	r2, r3
3401fd9c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fd9e:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    }
    else
    {
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
    }
    break;
3401fda2:	e02e      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>
      ongoing->down.averageL = LuminanceFromRGB(ongoing->down.averageR, ongoing->down.averageG, ongoing->down.averageB);
3401fda4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fda6:	f893 0034 	ldrb.w	r0, [r3, #52]	@ 0x34
3401fdaa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdac:	f893 1035 	ldrb.w	r1, [r3, #53]	@ 0x35
3401fdb0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdb2:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
3401fdb6:	461a      	mov	r2, r3
3401fdb8:	f7ff f87a 	bl	3401eeb0 <LuminanceFromRGB>
3401fdbc:	4603      	mov	r3, r0
3401fdbe:	461a      	mov	r2, r3
3401fdc0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdc2:	f883 2037 	strb.w	r2, [r3, #55]	@ 0x37
    break;
3401fdc6:	e01c      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[0]);
3401fdc8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdca:	3338      	adds	r3, #56	@ 0x38
3401fdcc:	4619      	mov	r1, r3
3401fdce:	6878      	ldr	r0, [r7, #4]
3401fdd0:	f7fe fec8 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fdd4:	e015      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[3]);
3401fdd6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdd8:	3344      	adds	r3, #68	@ 0x44
3401fdda:	4619      	mov	r1, r3
3401fddc:	6878      	ldr	r0, [r7, #4]
3401fdde:	f7fe fec1 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fde2:	e00e      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[6]);
3401fde4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fde6:	3350      	adds	r3, #80	@ 0x50
3401fde8:	4619      	mov	r1, r3
3401fdea:	6878      	ldr	r0, [r7, #4]
3401fdec:	f7fe feba 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fdf0:	e007      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    ReadStatHistogram(hIsp, &ongoing->down.histogram[9]);
3401fdf2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fdf4:	335c      	adds	r3, #92	@ 0x5c
3401fdf6:	4619      	mov	r1, r3
3401fdf8:	6878      	ldr	r0, [r7, #4]
3401fdfa:	f7fe feb3 	bl	3401eb64 <ReadStatHistogram>
    break;
3401fdfe:	e000      	b.n	3401fe02 <ISP_SVC_Stats_Gather+0x22a>

  default:
    /* No Read */
    break;
3401fe00:	bf00      	nop
  }

  /* Configure stat for a new stage */
  switch(ISP_SVC_StatEngine.stage)
3401fe02:	4b36      	ldr	r3, [pc, #216]	@ (3401fedc <ISP_SVC_Stats_Gather+0x304>)
3401fe04:	781b      	ldrb	r3, [r3, #0]
3401fe06:	2b09      	cmp	r3, #9
3401fe08:	f200 80b8 	bhi.w	3401ff7c <ISP_SVC_Stats_Gather+0x3a4>
3401fe0c:	a201      	add	r2, pc, #4	@ (adr r2, 3401fe14 <ISP_SVC_Stats_Gather+0x23c>)
3401fe0e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3401fe12:	bf00      	nop
3401fe14:	3401fe3d 	.word	0x3401fe3d
3401fe18:	3401fe93 	.word	0x3401fe93
3401fe1c:	3401fea1 	.word	0x3401fea1
3401fe20:	3401feaf 	.word	0x3401feaf
3401fe24:	3401febd 	.word	0x3401febd
3401fe28:	3401fecb 	.word	0x3401fecb
3401fe2c:	3401ff45 	.word	0x3401ff45
3401fe30:	3401ff53 	.word	0x3401ff53
3401fe34:	3401ff61 	.word	0x3401ff61
3401fe38:	3401ff6f 	.word	0x3401ff6f
  {
  case ISP_STAT_CFG_UP_AVG:
    for (i = 0; i < 3; i++)
3401fe3c:	2300      	movs	r3, #0
3401fe3e:	647b      	str	r3, [r7, #68]	@ 0x44
3401fe40:	e023      	b.n	3401fe8a <ISP_SVC_Stats_Gather+0x2b2>
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3401fe42:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401fe44:	4613      	mov	r3, r2
3401fe46:	005b      	lsls	r3, r3, #1
3401fe48:	4413      	add	r3, r2
3401fe4a:	009b      	lsls	r3, r3, #2
3401fe4c:	3348      	adds	r3, #72	@ 0x48
3401fe4e:	443b      	add	r3, r7
3401fe50:	3b34      	subs	r3, #52	@ 0x34
3401fe52:	2200      	movs	r2, #0
3401fe54:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBUp[i];
3401fe56:	4a22      	ldr	r2, [pc, #136]	@ (3401fee0 <ISP_SVC_Stats_Gather+0x308>)
3401fe58:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401fe5a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
3401fe5e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401fe60:	4613      	mov	r3, r2
3401fe62:	005b      	lsls	r3, r3, #1
3401fe64:	4413      	add	r3, r2
3401fe66:	009b      	lsls	r3, r3, #2
3401fe68:	3348      	adds	r3, #72	@ 0x48
3401fe6a:	443b      	add	r3, r7
3401fe6c:	3b30      	subs	r3, #48	@ 0x30
3401fe6e:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3401fe70:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401fe72:	4613      	mov	r3, r2
3401fe74:	005b      	lsls	r3, r3, #1
3401fe76:	4413      	add	r3, r2
3401fe78:	009b      	lsls	r3, r3, #2
3401fe7a:	3348      	adds	r3, #72	@ 0x48
3401fe7c:	443b      	add	r3, r7
3401fe7e:	3b2c      	subs	r3, #44	@ 0x2c
3401fe80:	2200      	movs	r2, #0
3401fe82:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
3401fe84:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401fe86:	3301      	adds	r3, #1
3401fe88:	647b      	str	r3, [r7, #68]	@ 0x44
3401fe8a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401fe8c:	2b02      	cmp	r3, #2
3401fe8e:	d9d8      	bls.n	3401fe42 <ISP_SVC_Stats_Gather+0x26a>
    }
    break;
3401fe90:	e075      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_UP_BINS_0_2:
    SetStatConfig(statConf, &statConfUpBins_0_2);
3401fe92:	f107 0314 	add.w	r3, r7, #20
3401fe96:	4913      	ldr	r1, [pc, #76]	@ (3401fee4 <ISP_SVC_Stats_Gather+0x30c>)
3401fe98:	4618      	mov	r0, r3
3401fe9a:	f7fe fe85 	bl	3401eba8 <SetStatConfig>
    break;
3401fe9e:	e06e      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_UP_BINS_3_5:
    SetStatConfig(statConf, &statConfUpBins_3_5);
3401fea0:	f107 0314 	add.w	r3, r7, #20
3401fea4:	4910      	ldr	r1, [pc, #64]	@ (3401fee8 <ISP_SVC_Stats_Gather+0x310>)
3401fea6:	4618      	mov	r0, r3
3401fea8:	f7fe fe7e 	bl	3401eba8 <SetStatConfig>
    break;
3401feac:	e067      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_UP_BINS_6_8:
    SetStatConfig(statConf, &statConfUpBins_6_8);
3401feae:	f107 0314 	add.w	r3, r7, #20
3401feb2:	490e      	ldr	r1, [pc, #56]	@ (3401feec <ISP_SVC_Stats_Gather+0x314>)
3401feb4:	4618      	mov	r0, r3
3401feb6:	f7fe fe77 	bl	3401eba8 <SetStatConfig>
    break;
3401feba:	e060      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_UP_BINS_9_11:
    SetStatConfig(statConf, &statConfUpBins_9_11);
3401febc:	f107 0314 	add.w	r3, r7, #20
3401fec0:	490b      	ldr	r1, [pc, #44]	@ (3401fef0 <ISP_SVC_Stats_Gather+0x318>)
3401fec2:	4618      	mov	r0, r3
3401fec4:	f7fe fe70 	bl	3401eba8 <SetStatConfig>
    break;
3401fec8:	e059      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_DOWN_AVG:
    for (i = 0; i < 3; i++)
3401feca:	2300      	movs	r3, #0
3401fecc:	647b      	str	r3, [r7, #68]	@ 0x44
3401fece:	e035      	b.n	3401ff3c <ISP_SVC_Stats_Gather+0x364>
3401fed0:	3402b600 	.word	0x3402b600
3401fed4:	3404a9d0 	.word	0x3404a9d0
3401fed8:	34041489 	.word	0x34041489
3401fedc:	3404a954 	.word	0x3404a954
3401fee0:	3402c6a8 	.word	0x3402c6a8
3401fee4:	3402c6c0 	.word	0x3402c6c0
3401fee8:	3402c6cc 	.word	0x3402c6cc
3401feec:	3402c6d8 	.word	0x3402c6d8
3401fef0:	3402c6e4 	.word	0x3402c6e4
    {
      statConf[i].Mode = DCMIPP_STAT_EXT_MODE_AVERAGE;
3401fef4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401fef6:	4613      	mov	r3, r2
3401fef8:	005b      	lsls	r3, r3, #1
3401fefa:	4413      	add	r3, r2
3401fefc:	009b      	lsls	r3, r3, #2
3401fefe:	3348      	adds	r3, #72	@ 0x48
3401ff00:	443b      	add	r3, r7
3401ff02:	3b34      	subs	r3, #52	@ 0x34
3401ff04:	2200      	movs	r2, #0
3401ff06:	601a      	str	r2, [r3, #0]
      statConf[i].Source = avgRGBDown[i];
3401ff08:	4a8e      	ldr	r2, [pc, #568]	@ (34020144 <ISP_SVC_Stats_Gather+0x56c>)
3401ff0a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ff0c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
3401ff10:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401ff12:	4613      	mov	r3, r2
3401ff14:	005b      	lsls	r3, r3, #1
3401ff16:	4413      	add	r3, r2
3401ff18:	009b      	lsls	r3, r3, #2
3401ff1a:	3348      	adds	r3, #72	@ 0x48
3401ff1c:	443b      	add	r3, r7
3401ff1e:	3b30      	subs	r3, #48	@ 0x30
3401ff20:	6019      	str	r1, [r3, #0]
      statConf[i].Bins = DCMIPP_STAT_EXT_AVER_MODE_ALL_PIXELS;
3401ff22:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401ff24:	4613      	mov	r3, r2
3401ff26:	005b      	lsls	r3, r3, #1
3401ff28:	4413      	add	r3, r2
3401ff2a:	009b      	lsls	r3, r3, #2
3401ff2c:	3348      	adds	r3, #72	@ 0x48
3401ff2e:	443b      	add	r3, r7
3401ff30:	3b2c      	subs	r3, #44	@ 0x2c
3401ff32:	2200      	movs	r2, #0
3401ff34:	601a      	str	r2, [r3, #0]
    for (i = 0; i < 3; i++)
3401ff36:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ff38:	3301      	adds	r3, #1
3401ff3a:	647b      	str	r3, [r7, #68]	@ 0x44
3401ff3c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ff3e:	2b02      	cmp	r3, #2
3401ff40:	d9d8      	bls.n	3401fef4 <ISP_SVC_Stats_Gather+0x31c>
    }
    break;
3401ff42:	e01c      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_DOWN_BINS_0_2:
    SetStatConfig(statConf, &statConfDownBins_0_2);
3401ff44:	f107 0314 	add.w	r3, r7, #20
3401ff48:	497f      	ldr	r1, [pc, #508]	@ (34020148 <ISP_SVC_Stats_Gather+0x570>)
3401ff4a:	4618      	mov	r0, r3
3401ff4c:	f7fe fe2c 	bl	3401eba8 <SetStatConfig>
    break;
3401ff50:	e015      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_DOWN_BINS_3_5:
    SetStatConfig(statConf, &statConfDownBins_3_5);
3401ff52:	f107 0314 	add.w	r3, r7, #20
3401ff56:	497d      	ldr	r1, [pc, #500]	@ (3402014c <ISP_SVC_Stats_Gather+0x574>)
3401ff58:	4618      	mov	r0, r3
3401ff5a:	f7fe fe25 	bl	3401eba8 <SetStatConfig>
    break;
3401ff5e:	e00e      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_DOWN_BINS_6_8:
    SetStatConfig(statConf, &statConfDownBins_6_8);
3401ff60:	f107 0314 	add.w	r3, r7, #20
3401ff64:	497a      	ldr	r1, [pc, #488]	@ (34020150 <ISP_SVC_Stats_Gather+0x578>)
3401ff66:	4618      	mov	r0, r3
3401ff68:	f7fe fe1e 	bl	3401eba8 <SetStatConfig>
    break;
3401ff6c:	e007      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  case ISP_STAT_CFG_DOWN_BINS_9_11:
    SetStatConfig(statConf, &statConfDownBins_9_11);
3401ff6e:	f107 0314 	add.w	r3, r7, #20
3401ff72:	4978      	ldr	r1, [pc, #480]	@ (34020154 <ISP_SVC_Stats_Gather+0x57c>)
3401ff74:	4618      	mov	r0, r3
3401ff76:	f7fe fe17 	bl	3401eba8 <SetStatConfig>
    break;
3401ff7a:	e000      	b.n	3401ff7e <ISP_SVC_Stats_Gather+0x3a6>

  default:
    /* Configure Unchanged */
    break;
3401ff7c:	bf00      	nop
  }

  /* Apply configuration (for an output result available 2 VSYNC later) */
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401ff7e:	2301      	movs	r3, #1
3401ff80:	647b      	str	r3, [r7, #68]	@ 0x44
3401ff82:	e029      	b.n	3401ffd8 <ISP_SVC_Stats_Gather+0x400>
  {
    if (HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig(hIsp->hDcmipp, DCMIPP_PIPE1, i, &statConf[i - DCMIPP_STATEXT_MODULE1]) != HAL_OK)
3401ff84:	687b      	ldr	r3, [r7, #4]
3401ff86:	6818      	ldr	r0, [r3, #0]
3401ff88:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ff8a:	b2dc      	uxtb	r4, r3
3401ff8c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ff8e:	1e5a      	subs	r2, r3, #1
3401ff90:	f107 0114 	add.w	r1, r7, #20
3401ff94:	4613      	mov	r3, r2
3401ff96:	005b      	lsls	r3, r3, #1
3401ff98:	4413      	add	r3, r2
3401ff9a:	009b      	lsls	r3, r3, #2
3401ff9c:	440b      	add	r3, r1
3401ff9e:	4622      	mov	r2, r4
3401ffa0:	2101      	movs	r1, #1
3401ffa2:	f7e9 fa2e 	bl	34009402 <HAL_DCMIPP_PIPE_SetISPStatisticExtractionConfig>
3401ffa6:	4603      	mov	r3, r0
3401ffa8:	2b00      	cmp	r3, #0
3401ffaa:	d003      	beq.n	3401ffb4 <ISP_SVC_Stats_Gather+0x3dc>
    {
      printf("ERROR: can't set Statistic Extraction config\r\n");
3401ffac:	486a      	ldr	r0, [pc, #424]	@ (34020158 <ISP_SVC_Stats_Gather+0x580>)
3401ffae:	f006 fed1 	bl	34026d54 <puts>
      return;
3401ffb2:	e0c4      	b.n	3402013e <ISP_SVC_Stats_Gather+0x566>
    }

    if (HAL_DCMIPP_PIPE_EnableISPStatisticExtraction(hIsp->hDcmipp, DCMIPP_PIPE1, i) != HAL_OK)
3401ffb4:	687b      	ldr	r3, [r7, #4]
3401ffb6:	681b      	ldr	r3, [r3, #0]
3401ffb8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3401ffba:	b2d2      	uxtb	r2, r2
3401ffbc:	2101      	movs	r1, #1
3401ffbe:	4618      	mov	r0, r3
3401ffc0:	f7e9 faad 	bl	3400951e <HAL_DCMIPP_PIPE_EnableISPStatisticExtraction>
3401ffc4:	4603      	mov	r3, r0
3401ffc6:	2b00      	cmp	r3, #0
3401ffc8:	d003      	beq.n	3401ffd2 <ISP_SVC_Stats_Gather+0x3fa>
    {
      printf("ERROR: can't enable Statistic Extraction config\r\n");
3401ffca:	4864      	ldr	r0, [pc, #400]	@ (3402015c <ISP_SVC_Stats_Gather+0x584>)
3401ffcc:	f006 fec2 	bl	34026d54 <puts>
      return;
3401ffd0:	e0b5      	b.n	3402013e <ISP_SVC_Stats_Gather+0x566>
  for (i = DCMIPP_STATEXT_MODULE1; i <= DCMIPP_STATEXT_MODULE3; i++)
3401ffd2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ffd4:	3301      	adds	r3, #1
3401ffd6:	647b      	str	r3, [r7, #68]	@ 0x44
3401ffd8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3401ffda:	2b03      	cmp	r3, #3
3401ffdc:	d9d2      	bls.n	3401ff84 <ISP_SVC_Stats_Gather+0x3ac>
    }
  }

  /* Cycle start / end */
  frameId = ISP_SVC_Misc_GetMainFrameId(hIsp);
3401ffde:	6878      	ldr	r0, [r7, #4]
3401ffe0:	f7ff fd27 	bl	3401fa32 <ISP_SVC_Misc_GetMainFrameId>
3401ffe4:	63b8      	str	r0, [r7, #56]	@ 0x38

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_UP))
3401ffe6:	2001      	movs	r0, #1
3401ffe8:	f7fe fef0 	bl	3401edcc <GetStatCycleStart>
3401ffec:	4603      	mov	r3, r0
3401ffee:	461a      	mov	r2, r3
3401fff0:	4b5b      	ldr	r3, [pc, #364]	@ (34020160 <ISP_SVC_Stats_Gather+0x588>)
3401fff2:	781b      	ldrb	r3, [r3, #0]
3401fff4:	429a      	cmp	r2, r3
3401fff6:	d102      	bne.n	3401fffe <ISP_SVC_Stats_Gather+0x426>
  {
    ongoing->upFrameIdStart = frameId;
3401fff8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3401fffa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
3401fffc:	669a      	str	r2, [r3, #104]	@ 0x68
  }

  if (stagePrevious2 == GetStatCycleStart(ISP_STAT_LOC_DOWN))
3401fffe:	2002      	movs	r0, #2
34020000:	f7fe fee4 	bl	3401edcc <GetStatCycleStart>
34020004:	4603      	mov	r3, r0
34020006:	461a      	mov	r2, r3
34020008:	4b55      	ldr	r3, [pc, #340]	@ (34020160 <ISP_SVC_Stats_Gather+0x588>)
3402000a:	781b      	ldrb	r3, [r3, #0]
3402000c:	429a      	cmp	r2, r3
3402000e:	d102      	bne.n	34020016 <ISP_SVC_Stats_Gather+0x43e>
  {
    ongoing->downFrameIdStart = frameId;
34020010:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020012:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34020014:	671a      	str	r2, [r3, #112]	@ 0x70
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_UP)) && (ongoing->upFrameIdStart != 0))
34020016:	2001      	movs	r0, #1
34020018:	f7fe ff10 	bl	3401ee3c <GetStatCycleEnd>
3402001c:	4603      	mov	r3, r0
3402001e:	461a      	mov	r2, r3
34020020:	4b4f      	ldr	r3, [pc, #316]	@ (34020160 <ISP_SVC_Stats_Gather+0x588>)
34020022:	781b      	ldrb	r3, [r3, #0]
34020024:	429a      	cmp	r2, r3
34020026:	d122      	bne.n	3402006e <ISP_SVC_Stats_Gather+0x496>
34020028:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402002a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3402002c:	2b00      	cmp	r3, #0
3402002e:	d01e      	beq.n	3402006e <ISP_SVC_Stats_Gather+0x496>
  {
    /* Last measure of the up cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.up = ongoing->up;
34020030:	4b4c      	ldr	r3, [pc, #304]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020032:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34020034:	1d1c      	adds	r4, r3, #4
34020036:	4615      	mov	r5, r2
34020038:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3402003a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3402003c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3402003e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34020040:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34020042:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34020044:	682b      	ldr	r3, [r5, #0]
34020046:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.upFrameIdEnd = frameId;
34020048:	4a46      	ldr	r2, [pc, #280]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
3402004a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402004c:	6713      	str	r3, [r2, #112]	@ 0x70
    ISP_SVC_StatEngine.last.upFrameIdStart = ongoing->upFrameIdStart;
3402004e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020050:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34020052:	4a44      	ldr	r2, [pc, #272]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020054:	66d3      	str	r3, [r2, #108]	@ 0x6c

    memset(&ongoing->up, 0, sizeof(ongoing->up));
34020056:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020058:	2234      	movs	r2, #52	@ 0x34
3402005a:	2100      	movs	r1, #0
3402005c:	4618      	mov	r0, r3
3402005e:	f007 f899 	bl	34027194 <memset>
    ongoing->upFrameIdStart = 0;
34020062:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020064:	2200      	movs	r2, #0
34020066:	669a      	str	r2, [r3, #104]	@ 0x68
    ongoing->upFrameIdEnd = 0;
34020068:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402006a:	2200      	movs	r2, #0
3402006c:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  if ((stagePrevious2 == GetStatCycleEnd(ISP_STAT_LOC_DOWN)) && (ongoing->downFrameIdStart != 0))
3402006e:	2002      	movs	r0, #2
34020070:	f7fe fee4 	bl	3401ee3c <GetStatCycleEnd>
34020074:	4603      	mov	r3, r0
34020076:	461a      	mov	r2, r3
34020078:	4b39      	ldr	r3, [pc, #228]	@ (34020160 <ISP_SVC_Stats_Gather+0x588>)
3402007a:	781b      	ldrb	r3, [r3, #0]
3402007c:	429a      	cmp	r2, r3
3402007e:	d125      	bne.n	340200cc <ISP_SVC_Stats_Gather+0x4f4>
34020080:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020082:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34020084:	2b00      	cmp	r3, #0
34020086:	d021      	beq.n	340200cc <ISP_SVC_Stats_Gather+0x4f4>
  {
    /* Last measure of the down cycle : update the 'last' struct */
    ISP_SVC_StatEngine.last.down = ongoing->down;
34020088:	4a36      	ldr	r2, [pc, #216]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
3402008a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402008c:	f102 0438 	add.w	r4, r2, #56	@ 0x38
34020090:	f103 0534 	add.w	r5, r3, #52	@ 0x34
34020094:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34020096:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34020098:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3402009a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3402009c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3402009e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
340200a0:	682b      	ldr	r3, [r5, #0]
340200a2:	6023      	str	r3, [r4, #0]
    ISP_SVC_StatEngine.last.downFrameIdEnd = frameId;
340200a4:	4a2f      	ldr	r2, [pc, #188]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340200a8:	6793      	str	r3, [r2, #120]	@ 0x78
    ISP_SVC_StatEngine.last.downFrameIdStart = ongoing->downFrameIdStart;
340200aa:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340200ac:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340200ae:	4a2d      	ldr	r2, [pc, #180]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200b0:	6753      	str	r3, [r2, #116]	@ 0x74

    memset(&ongoing->down, 0, sizeof(ongoing->down));
340200b2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340200b4:	3334      	adds	r3, #52	@ 0x34
340200b6:	2234      	movs	r2, #52	@ 0x34
340200b8:	2100      	movs	r1, #0
340200ba:	4618      	mov	r0, r3
340200bc:	f007 f86a 	bl	34027194 <memset>
    ongoing->downFrameIdStart = 0;
340200c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340200c2:	2200      	movs	r2, #0
340200c4:	671a      	str	r2, [r3, #112]	@ 0x70
    ongoing->downFrameIdEnd = 0;
340200c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340200c8:	2200      	movs	r2, #0
340200ca:	675a      	str	r2, [r3, #116]	@ 0x74
  }

  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340200cc:	4b25      	ldr	r3, [pc, #148]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200ce:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
340200d2:	f003 0304 	and.w	r3, r3, #4
340200d6:	2b00      	cmp	r3, #0
340200d8:	d106      	bne.n	340200e8 <ISP_SVC_Stats_Gather+0x510>
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
340200da:	4b22      	ldr	r3, [pc, #136]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200dc:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
340200e0:	f003 0304 	and.w	r3, r3, #4
  if (((ISP_SVC_StatEngine.upRequest & ISP_STAT_TYPE_ALL_TMP) ||
340200e4:	2b00      	cmp	r3, #0
340200e6:	d017      	beq.n	34020118 <ISP_SVC_Stats_Gather+0x540>
      (frameId > ISP_SVC_StatEngine.requestAllCounter))
340200e8:	4b1e      	ldr	r3, [pc, #120]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200ea:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
       (ISP_SVC_StatEngine.downRequest & ISP_STAT_TYPE_ALL_TMP)) &&
340200ee:	6bba      	ldr	r2, [r7, #56]	@ 0x38
340200f0:	429a      	cmp	r2, r3
340200f2:	d911      	bls.n	34020118 <ISP_SVC_Stats_Gather+0x540>
  {
    /* Stop the special temporary mode "request all stats" when its delay expires */
    ISP_SVC_StatEngine.upRequest &= ~ISP_STAT_TYPE_ALL_TMP;
340200f4:	4b1b      	ldr	r3, [pc, #108]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
340200f6:	f893 3158 	ldrb.w	r3, [r3, #344]	@ 0x158
340200fa:	f023 0304 	bic.w	r3, r3, #4
340200fe:	b2da      	uxtb	r2, r3
34020100:	4b18      	ldr	r3, [pc, #96]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020102:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
    ISP_SVC_StatEngine.downRequest &= ~ISP_STAT_TYPE_ALL_TMP;
34020106:	4b17      	ldr	r3, [pc, #92]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020108:	f893 3159 	ldrb.w	r3, [r3, #345]	@ 0x159
3402010c:	f023 0304 	bic.w	r3, r3, #4
34020110:	b2da      	uxtb	r2, r3
34020112:	4b14      	ldr	r3, [pc, #80]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020114:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  /* Save the two last processed stages and go to next stage */
  stagePrevious2 = stagePrevious1;
34020118:	4b13      	ldr	r3, [pc, #76]	@ (34020168 <ISP_SVC_Stats_Gather+0x590>)
3402011a:	781a      	ldrb	r2, [r3, #0]
3402011c:	4b10      	ldr	r3, [pc, #64]	@ (34020160 <ISP_SVC_Stats_Gather+0x588>)
3402011e:	701a      	strb	r2, [r3, #0]
  stagePrevious1 = ISP_SVC_StatEngine.stage;
34020120:	4b10      	ldr	r3, [pc, #64]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020122:	781a      	ldrb	r2, [r3, #0]
34020124:	4b10      	ldr	r3, [pc, #64]	@ (34020168 <ISP_SVC_Stats_Gather+0x590>)
34020126:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.stage = GetNextStatStage(ISP_SVC_StatEngine.stage);
34020128:	4b0e      	ldr	r3, [pc, #56]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
3402012a:	781b      	ldrb	r3, [r3, #0]
3402012c:	4618      	mov	r0, r3
3402012e:	f7fe fd5d 	bl	3401ebec <GetNextStatStage>
34020132:	4603      	mov	r3, r0
34020134:	461a      	mov	r2, r3
34020136:	4b0b      	ldr	r3, [pc, #44]	@ (34020164 <ISP_SVC_Stats_Gather+0x58c>)
34020138:	701a      	strb	r2, [r3, #0]
3402013a:	e000      	b.n	3402013e <ISP_SVC_Stats_Gather+0x566>
    return;
3402013c:	bf00      	nop
}
3402013e:	3748      	adds	r7, #72	@ 0x48
34020140:	46bd      	mov	sp, r7
34020142:	bdb0      	pop	{r4, r5, r7, pc}
34020144:	3402c6b4 	.word	0x3402c6b4
34020148:	3402c6f0 	.word	0x3402c6f0
3402014c:	3402c6fc 	.word	0x3402c6fc
34020150:	3402c708 	.word	0x3402c708
34020154:	3402c714 	.word	0x3402c714
34020158:	3402b61c 	.word	0x3402b61c
3402015c:	3402b64c 	.word	0x3402b64c
34020160:	34041489 	.word	0x34041489
34020164:	3404a954 	.word	0x3404a954
34020168:	3404148a 	.word	0x3404148a

3402016c <ISP_SVC_Stats_ProcessCallbacks>:
  *         If the conditions are met, call the client registered callbacks
  * @param  hIsp: ISP device handle
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_ProcessCallbacks(ISP_HandleTypeDef *hIsp)
{
3402016c:	b580      	push	{r7, lr}
3402016e:	b088      	sub	sp, #32
34020170:	af00      	add	r7, sp, #0
34020172:	6078      	str	r0, [r7, #4]
  (void)hIsp; /* unused */
  ISP_SVC_StatStateTypeDef *pLastStat;
  ISP_SVC_StatRegisteredClient *client;
  ISP_StatusTypeDef retcb, ret = ISP_OK;
34020174:	2300      	movs	r3, #0
34020176:	77fb      	strb	r3, [r7, #31]

  pLastStat = &ISP_SVC_StatEngine.last;
34020178:	4b2e      	ldr	r3, [pc, #184]	@ (34020234 <ISP_SVC_Stats_ProcessCallbacks+0xc8>)
3402017a:	617b      	str	r3, [r7, #20]

  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3402017c:	2300      	movs	r3, #0
3402017e:	61bb      	str	r3, [r7, #24]
34020180:	e04f      	b.n	34020222 <ISP_SVC_Stats_ProcessCallbacks+0xb6>
  {
    client = &ISP_SVC_StatEngine.client[i];
34020182:	69ba      	ldr	r2, [r7, #24]
34020184:	4613      	mov	r3, r2
34020186:	009b      	lsls	r3, r3, #2
34020188:	4413      	add	r3, r2
3402018a:	009b      	lsls	r3, r3, #2
3402018c:	33f0      	adds	r3, #240	@ 0xf0
3402018e:	4a2a      	ldr	r2, [pc, #168]	@ (34020238 <ISP_SVC_Stats_ProcessCallbacks+0xcc>)
34020190:	4413      	add	r3, r2
34020192:	3304      	adds	r3, #4
34020194:	613b      	str	r3, [r7, #16]

    if (client->callback == NULL)
34020196:	693b      	ldr	r3, [r7, #16]
34020198:	681b      	ldr	r3, [r3, #0]
3402019a:	2b00      	cmp	r3, #0
3402019c:	d03d      	beq.n	3402021a <ISP_SVC_Stats_ProcessCallbacks+0xae>
      continue;

    /* Check if stats are available for a client, comparing the location and the specified frameId */
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
3402019e:	693b      	ldr	r3, [r7, #16]
340201a0:	7c1b      	ldrb	r3, [r3, #16]
340201a2:	2b02      	cmp	r3, #2
340201a4:	d105      	bne.n	340201b2 <ISP_SVC_Stats_ProcessCallbacks+0x46>
340201a6:	693b      	ldr	r3, [r7, #16]
340201a8:	68da      	ldr	r2, [r3, #12]
340201aa:	697b      	ldr	r3, [r7, #20]
340201ac:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340201ae:	429a      	cmp	r2, r3
340201b0:	d919      	bls.n	340201e6 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
340201b2:	693b      	ldr	r3, [r7, #16]
340201b4:	7c1b      	ldrb	r3, [r3, #16]
    if (((client->location == ISP_STAT_LOC_DOWN) && (client->refFrameId <= pLastStat->downFrameIdStart)) ||
340201b6:	2b01      	cmp	r3, #1
340201b8:	d105      	bne.n	340201c6 <ISP_SVC_Stats_ProcessCallbacks+0x5a>
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
340201ba:	693b      	ldr	r3, [r7, #16]
340201bc:	68da      	ldr	r2, [r3, #12]
340201be:	697b      	ldr	r3, [r7, #20]
340201c0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
340201c2:	429a      	cmp	r2, r3
340201c4:	d90f      	bls.n	340201e6 <ISP_SVC_Stats_ProcessCallbacks+0x7a>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
340201c6:	693b      	ldr	r3, [r7, #16]
340201c8:	7c1b      	ldrb	r3, [r3, #16]
        ((client->location == ISP_STAT_LOC_UP) && (client->refFrameId <= pLastStat->upFrameIdStart)) ||
340201ca:	2b03      	cmp	r3, #3
340201cc:	d126      	bne.n	3402021c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
        ((client->location == ISP_STAT_LOC_UP_AND_DOWN) && (client->refFrameId <= pLastStat->upFrameIdStart) && (client->refFrameId <= pLastStat->downFrameIdStart)))
340201ce:	693b      	ldr	r3, [r7, #16]
340201d0:	68da      	ldr	r2, [r3, #12]
340201d2:	697b      	ldr	r3, [r7, #20]
340201d4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
340201d6:	429a      	cmp	r2, r3
340201d8:	d820      	bhi.n	3402021c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
340201da:	693b      	ldr	r3, [r7, #16]
340201dc:	68da      	ldr	r2, [r3, #12]
340201de:	697b      	ldr	r3, [r7, #20]
340201e0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340201e2:	429a      	cmp	r2, r3
340201e4:	d81a      	bhi.n	3402021c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
    {
      /* Copy the stats into the client buffer */
      *(client->pStats) = *pLastStat;
340201e6:	693b      	ldr	r3, [r7, #16]
340201e8:	689a      	ldr	r2, [r3, #8]
340201ea:	697b      	ldr	r3, [r7, #20]
340201ec:	4610      	mov	r0, r2
340201ee:	4619      	mov	r1, r3
340201f0:	2378      	movs	r3, #120	@ 0x78
340201f2:	461a      	mov	r2, r3
340201f4:	f007 fa5d 	bl	340276b2 <memcpy>

      /* Call its callback */
      retcb = client->callback(client->pAlgo);
340201f8:	693b      	ldr	r3, [r7, #16]
340201fa:	681b      	ldr	r3, [r3, #0]
340201fc:	693a      	ldr	r2, [r7, #16]
340201fe:	6852      	ldr	r2, [r2, #4]
34020200:	4610      	mov	r0, r2
34020202:	4798      	blx	r3
34020204:	4603      	mov	r3, r0
34020206:	73fb      	strb	r3, [r7, #15]
      if (retcb != ISP_OK)
34020208:	7bfb      	ldrb	r3, [r7, #15]
3402020a:	2b00      	cmp	r3, #0
3402020c:	d001      	beq.n	34020212 <ISP_SVC_Stats_ProcessCallbacks+0xa6>
      {
        ret = retcb;
3402020e:	7bfb      	ldrb	r3, [r7, #15]
34020210:	77fb      	strb	r3, [r7, #31]
      }

      /* Remove the client from the registered list */
      client->callback = NULL;
34020212:	693b      	ldr	r3, [r7, #16]
34020214:	2200      	movs	r2, #0
34020216:	601a      	str	r2, [r3, #0]
34020218:	e000      	b.n	3402021c <ISP_SVC_Stats_ProcessCallbacks+0xb0>
      continue;
3402021a:	bf00      	nop
  for (uint32_t i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
3402021c:	69bb      	ldr	r3, [r7, #24]
3402021e:	3301      	adds	r3, #1
34020220:	61bb      	str	r3, [r7, #24]
34020222:	69bb      	ldr	r3, [r7, #24]
34020224:	2b04      	cmp	r3, #4
34020226:	d9ac      	bls.n	34020182 <ISP_SVC_Stats_ProcessCallbacks+0x16>
    }
  }

  return ret;
34020228:	7ffb      	ldrb	r3, [r7, #31]
}
3402022a:	4618      	mov	r0, r3
3402022c:	3720      	adds	r7, #32
3402022e:	46bd      	mov	sp, r7
34020230:	bd80      	pop	{r7, pc}
34020232:	bf00      	nop
34020234:	3404a958 	.word	0x3404a958
34020238:	3404a954 	.word	0x3404a954

3402023c <ISP_SVC_Stats_GetNext>:
  * @param  frameDelay: number of frames to wait before considering the stats as valid
  * @retval ISP status
  */
ISP_StatusTypeDef ISP_SVC_Stats_GetNext(ISP_HandleTypeDef *hIsp, ISP_stat_ready_cb callback, ISP_AlgoTypeDef *pAlgo, ISP_SVC_StatStateTypeDef *pStats,
                                        ISP_SVC_StatLocation location, ISP_SVC_StatType type, uint32_t frameDelay)
{
3402023c:	b580      	push	{r7, lr}
3402023e:	b086      	sub	sp, #24
34020240:	af00      	add	r7, sp, #0
34020242:	60f8      	str	r0, [r7, #12]
34020244:	60b9      	str	r1, [r7, #8]
34020246:	607a      	str	r2, [r7, #4]
34020248:	603b      	str	r3, [r7, #0]
  uint32_t i, refFrameId;

  /* Check handle validity */
  if ((hIsp == NULL) || (pStats == NULL))
3402024a:	68fb      	ldr	r3, [r7, #12]
3402024c:	2b00      	cmp	r3, #0
3402024e:	d002      	beq.n	34020256 <ISP_SVC_Stats_GetNext+0x1a>
34020250:	683b      	ldr	r3, [r7, #0]
34020252:	2b00      	cmp	r3, #0
34020254:	d101      	bne.n	3402025a <ISP_SVC_Stats_GetNext+0x1e>
  {
    return ISP_ERR_EINVAL;
34020256:	2301      	movs	r3, #1
34020258:	e08f      	b.n	3402037a <ISP_SVC_Stats_GetNext+0x13e>
  }

  refFrameId = ISP_SVC_Misc_GetMainFrameId(hIsp) + frameDelay;
3402025a:	68f8      	ldr	r0, [r7, #12]
3402025c:	f7ff fbe9 	bl	3401fa32 <ISP_SVC_Misc_GetMainFrameId>
34020260:	4602      	mov	r2, r0
34020262:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34020264:	4413      	add	r3, r2
34020266:	613b      	str	r3, [r7, #16]

  /* Register the callback */
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34020268:	2300      	movs	r3, #0
3402026a:	617b      	str	r3, [r7, #20]
3402026c:	e00d      	b.n	3402028a <ISP_SVC_Stats_GetNext+0x4e>
  {
    if (ISP_SVC_StatEngine.client[i].callback == NULL)
3402026e:	4945      	ldr	r1, [pc, #276]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
34020270:	697a      	ldr	r2, [r7, #20]
34020272:	4613      	mov	r3, r2
34020274:	009b      	lsls	r3, r3, #2
34020276:	4413      	add	r3, r2
34020278:	009b      	lsls	r3, r3, #2
3402027a:	440b      	add	r3, r1
3402027c:	33f4      	adds	r3, #244	@ 0xf4
3402027e:	681b      	ldr	r3, [r3, #0]
34020280:	2b00      	cmp	r3, #0
34020282:	d006      	beq.n	34020292 <ISP_SVC_Stats_GetNext+0x56>
  for (i = 0; i < ISP_SVC_STAT_MAX_CB; i++)
34020284:	697b      	ldr	r3, [r7, #20]
34020286:	3301      	adds	r3, #1
34020288:	617b      	str	r3, [r7, #20]
3402028a:	697b      	ldr	r3, [r7, #20]
3402028c:	2b04      	cmp	r3, #4
3402028e:	d9ee      	bls.n	3402026e <ISP_SVC_Stats_GetNext+0x32>
34020290:	e000      	b.n	34020294 <ISP_SVC_Stats_GetNext+0x58>
      break;
34020292:	bf00      	nop
  }

  if (i == ISP_SVC_STAT_MAX_CB)
34020294:	697b      	ldr	r3, [r7, #20]
34020296:	2b05      	cmp	r3, #5
34020298:	d101      	bne.n	3402029e <ISP_SVC_Stats_GetNext+0x62>
  {
    /* Too much callback registered */
    return ISP_ERR_STAT_MAXCLIENTS;
3402029a:	23ac      	movs	r3, #172	@ 0xac
3402029c:	e06d      	b.n	3402037a <ISP_SVC_Stats_GetNext+0x13e>
  }

  /* Add this requested stat to the list of requested stats */
  if (location & ISP_STAT_LOC_UP)
3402029e:	f897 3020 	ldrb.w	r3, [r7, #32]
340202a2:	f003 0301 	and.w	r3, r3, #1
340202a6:	2b00      	cmp	r3, #0
340202a8:	d009      	beq.n	340202be <ISP_SVC_Stats_GetNext+0x82>
  {
    ISP_SVC_StatEngine.upRequest |= type;
340202aa:	4b36      	ldr	r3, [pc, #216]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202ac:	f893 2158 	ldrb.w	r2, [r3, #344]	@ 0x158
340202b0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
340202b4:	4313      	orrs	r3, r2
340202b6:	b2da      	uxtb	r2, r3
340202b8:	4b32      	ldr	r3, [pc, #200]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202ba:	f883 2158 	strb.w	r2, [r3, #344]	@ 0x158
  }
  if (location & ISP_STAT_LOC_DOWN)
340202be:	f897 3020 	ldrb.w	r3, [r7, #32]
340202c2:	f003 0302 	and.w	r3, r3, #2
340202c6:	2b00      	cmp	r3, #0
340202c8:	d009      	beq.n	340202de <ISP_SVC_Stats_GetNext+0xa2>
  {
    ISP_SVC_StatEngine.downRequest |= type;
340202ca:	4b2e      	ldr	r3, [pc, #184]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202cc:	f893 2159 	ldrb.w	r2, [r3, #345]	@ 0x159
340202d0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
340202d4:	4313      	orrs	r3, r2
340202d6:	b2da      	uxtb	r2, r3
340202d8:	4b2a      	ldr	r3, [pc, #168]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202da:	f883 2159 	strb.w	r2, [r3, #345]	@ 0x159
  }

  if (type == ISP_STAT_TYPE_ALL_TMP)
340202de:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
340202e2:	2b04      	cmp	r3, #4
340202e4:	d107      	bne.n	340202f6 <ISP_SVC_Stats_GetNext+0xba>
  {
    /* Special case: request all stats for a short time (3 cycle) */
    ISP_SVC_StatEngine.requestAllCounter = ISP_SVC_Misc_GetMainFrameId(hIsp) + 3 * ISP_STAT_CFG_CYCLE_SIZE;
340202e6:	68f8      	ldr	r0, [r7, #12]
340202e8:	f7ff fba3 	bl	3401fa32 <ISP_SVC_Misc_GetMainFrameId>
340202ec:	4603      	mov	r3, r0
340202ee:	331e      	adds	r3, #30
340202f0:	4a24      	ldr	r2, [pc, #144]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202f2:	f8c2 315c 	str.w	r3, [r2, #348]	@ 0x15c
  }

  /* Register client */
  ISP_SVC_StatEngine.client[i].callback = callback;
340202f6:	4923      	ldr	r1, [pc, #140]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
340202f8:	697a      	ldr	r2, [r7, #20]
340202fa:	4613      	mov	r3, r2
340202fc:	009b      	lsls	r3, r3, #2
340202fe:	4413      	add	r3, r2
34020300:	009b      	lsls	r3, r3, #2
34020302:	440b      	add	r3, r1
34020304:	33f4      	adds	r3, #244	@ 0xf4
34020306:	68ba      	ldr	r2, [r7, #8]
34020308:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pAlgo = pAlgo;
3402030a:	491e      	ldr	r1, [pc, #120]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
3402030c:	697a      	ldr	r2, [r7, #20]
3402030e:	4613      	mov	r3, r2
34020310:	009b      	lsls	r3, r3, #2
34020312:	4413      	add	r3, r2
34020314:	009b      	lsls	r3, r3, #2
34020316:	440b      	add	r3, r1
34020318:	33f8      	adds	r3, #248	@ 0xf8
3402031a:	687a      	ldr	r2, [r7, #4]
3402031c:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].pStats = pStats;
3402031e:	4919      	ldr	r1, [pc, #100]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
34020320:	697a      	ldr	r2, [r7, #20]
34020322:	4613      	mov	r3, r2
34020324:	009b      	lsls	r3, r3, #2
34020326:	4413      	add	r3, r2
34020328:	009b      	lsls	r3, r3, #2
3402032a:	440b      	add	r3, r1
3402032c:	33fc      	adds	r3, #252	@ 0xfc
3402032e:	683a      	ldr	r2, [r7, #0]
34020330:	601a      	str	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].location = location;
34020332:	4914      	ldr	r1, [pc, #80]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
34020334:	697a      	ldr	r2, [r7, #20]
34020336:	4613      	mov	r3, r2
34020338:	009b      	lsls	r3, r3, #2
3402033a:	4413      	add	r3, r2
3402033c:	009b      	lsls	r3, r3, #2
3402033e:	440b      	add	r3, r1
34020340:	f503 7382 	add.w	r3, r3, #260	@ 0x104
34020344:	f897 2020 	ldrb.w	r2, [r7, #32]
34020348:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].type = type;
3402034a:	490e      	ldr	r1, [pc, #56]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
3402034c:	697a      	ldr	r2, [r7, #20]
3402034e:	4613      	mov	r3, r2
34020350:	009b      	lsls	r3, r3, #2
34020352:	4413      	add	r3, r2
34020354:	009b      	lsls	r3, r3, #2
34020356:	440b      	add	r3, r1
34020358:	f203 1305 	addw	r3, r3, #261	@ 0x105
3402035c:	f897 2024 	ldrb.w	r2, [r7, #36]	@ 0x24
34020360:	701a      	strb	r2, [r3, #0]
  ISP_SVC_StatEngine.client[i].refFrameId = refFrameId;
34020362:	4908      	ldr	r1, [pc, #32]	@ (34020384 <ISP_SVC_Stats_GetNext+0x148>)
34020364:	697a      	ldr	r2, [r7, #20]
34020366:	4613      	mov	r3, r2
34020368:	009b      	lsls	r3, r3, #2
3402036a:	4413      	add	r3, r2
3402036c:	009b      	lsls	r3, r3, #2
3402036e:	440b      	add	r3, r1
34020370:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34020374:	693a      	ldr	r2, [r7, #16]
34020376:	601a      	str	r2, [r3, #0]

  return ISP_OK;
34020378:	2300      	movs	r3, #0
}
3402037a:	4618      	mov	r0, r3
3402037c:	3718      	adds	r7, #24
3402037e:	46bd      	mov	sp, r7
34020380:	bd80      	pop	{r7, pc}
34020382:	bf00      	nop
34020384:	3404a954 	.word	0x3404a954

34020388 <yolov2_nms_comparator>:
/* Can't be removed if qsort is not re-written... */
static int32_t AI_YOLOV2_PP_SORT_CLASS;


int32_t yolov2_nms_comparator(const void *pa, const void *pb)
{
34020388:	b480      	push	{r7}
3402038a:	b087      	sub	sp, #28
3402038c:	af00      	add	r7, sp, #0
3402038e:	6078      	str	r0, [r7, #4]
34020390:	6039      	str	r1, [r7, #0]
    float32_t a = *((float32_t *)pa + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
34020392:	4b1a      	ldr	r3, [pc, #104]	@ (340203fc <yolov2_nms_comparator+0x74>)
34020394:	681b      	ldr	r3, [r3, #0]
34020396:	3305      	adds	r3, #5
34020398:	009b      	lsls	r3, r3, #2
3402039a:	687a      	ldr	r2, [r7, #4]
3402039c:	4413      	add	r3, r2
3402039e:	681b      	ldr	r3, [r3, #0]
340203a0:	617b      	str	r3, [r7, #20]
    float32_t b = *((float32_t *)pb + AI_YOLOV2_PP_CLASSPROB + AI_YOLOV2_PP_SORT_CLASS);
340203a2:	4b16      	ldr	r3, [pc, #88]	@ (340203fc <yolov2_nms_comparator+0x74>)
340203a4:	681b      	ldr	r3, [r3, #0]
340203a6:	3305      	adds	r3, #5
340203a8:	009b      	lsls	r3, r3, #2
340203aa:	683a      	ldr	r2, [r7, #0]
340203ac:	4413      	add	r3, r2
340203ae:	681b      	ldr	r3, [r3, #0]
340203b0:	613b      	str	r3, [r7, #16]
    float32_t diff = 0;
340203b2:	f04f 0300 	mov.w	r3, #0
340203b6:	60fb      	str	r3, [r7, #12]

    diff = a - b;
340203b8:	ed97 7a05 	vldr	s14, [r7, #20]
340203bc:	edd7 7a04 	vldr	s15, [r7, #16]
340203c0:	ee77 7a67 	vsub.f32	s15, s14, s15
340203c4:	edc7 7a03 	vstr	s15, [r7, #12]

    if (diff < 0) return 1;
340203c8:	edd7 7a03 	vldr	s15, [r7, #12]
340203cc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340203d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340203d4:	d501      	bpl.n	340203da <yolov2_nms_comparator+0x52>
340203d6:	2301      	movs	r3, #1
340203d8:	e00a      	b.n	340203f0 <yolov2_nms_comparator+0x68>
    else if (diff > 0) return -1;
340203da:	edd7 7a03 	vldr	s15, [r7, #12]
340203de:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340203e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340203e6:	dd02      	ble.n	340203ee <yolov2_nms_comparator+0x66>
340203e8:	f04f 33ff 	mov.w	r3, #4294967295
340203ec:	e000      	b.n	340203f0 <yolov2_nms_comparator+0x68>
    return 0;
340203ee:	2300      	movs	r3, #0
}
340203f0:	4618      	mov	r0, r3
340203f2:	371c      	adds	r7, #28
340203f4:	46bd      	mov	sp, r7
340203f6:	f85d 7b04 	ldr.w	r7, [sp], #4
340203fa:	4770      	bx	lr
340203fc:	3404aab4 	.word	0x3404aab4

34020400 <yolov2_pp_nmsFiltering_centroid>:


int32_t yolov2_pp_nmsFiltering_centroid(yolov2_pp_in_t  *pInput,
                                        yolov2_pp_static_param_t *pInput_static_param)
{
34020400:	b580      	push	{r7, lr}
34020402:	b08c      	sub	sp, #48	@ 0x30
34020404:	af00      	add	r7, sp, #0
34020406:	6078      	str	r0, [r7, #4]
34020408:	6039      	str	r1, [r7, #0]
    int32_t i, j, k, limit_counter;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
3402040a:	683b      	ldr	r3, [r7, #0]
3402040c:	681b      	ldr	r3, [r3, #0]
3402040e:	3305      	adds	r3, #5
34020410:	61bb      	str	r3, [r7, #24]
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
34020412:	687b      	ldr	r3, [r7, #4]
34020414:	681b      	ldr	r3, [r3, #0]
34020416:	617b      	str	r3, [r7, #20]

    for (k = 0; k < pInput_static_param->nb_classes; ++k)
34020418:	2300      	movs	r3, #0
3402041a:	627b      	str	r3, [r7, #36]	@ 0x24
3402041c:	e092      	b.n	34020544 <yolov2_pp_nmsFiltering_centroid+0x144>
    {
        limit_counter = 0;
3402041e:	2300      	movs	r3, #0
34020420:	623b      	str	r3, [r7, #32]
        AI_YOLOV2_PP_SORT_CLASS = k;
34020422:	4a4e      	ldr	r2, [pc, #312]	@ (3402055c <yolov2_pp_nmsFiltering_centroid+0x15c>)
34020424:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34020426:	6013      	str	r3, [r2, #0]

        qsort(pInbuff,
              pInput_static_param->nb_detect,
34020428:	683b      	ldr	r3, [r7, #0]
3402042a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
        qsort(pInbuff,
3402042c:	4619      	mov	r1, r3
3402042e:	69bb      	ldr	r3, [r7, #24]
              anch_stride * sizeof(float32_t),
34020430:	009a      	lsls	r2, r3, #2
        qsort(pInbuff,
34020432:	4b4b      	ldr	r3, [pc, #300]	@ (34020560 <yolov2_pp_nmsFiltering_centroid+0x160>)
34020434:	6978      	ldr	r0, [r7, #20]
34020436:	f005 fdd2 	bl	34025fde <qsort>
              (_Cmpfun *)yolov2_nms_comparator);
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
3402043a:	2300      	movs	r3, #0
3402043c:	62fb      	str	r3, [r7, #44]	@ 0x2c
3402043e:	e046      	b.n	340204ce <yolov2_pp_nmsFiltering_centroid+0xce>
        {
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
34020440:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34020442:	1d5a      	adds	r2, r3, #5
34020444:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34020446:	4413      	add	r3, r2
34020448:	009b      	lsls	r3, r3, #2
3402044a:	697a      	ldr	r2, [r7, #20]
3402044c:	4413      	add	r3, r2
3402044e:	edd3 7a00 	vldr	s15, [r3]
34020452:	eef5 7a40 	vcmp.f32	s15, #0.0
34020456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402045a:	d033      	beq.n	340204c4 <yolov2_pp_nmsFiltering_centroid+0xc4>
            float32_t *a = &(pInbuff[i + AI_YOLOV2_PP_XCENTER]);
3402045c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402045e:	009b      	lsls	r3, r3, #2
34020460:	697a      	ldr	r2, [r7, #20]
34020462:	4413      	add	r3, r2
34020464:	613b      	str	r3, [r7, #16]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
34020466:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34020468:	69bb      	ldr	r3, [r7, #24]
3402046a:	4413      	add	r3, r2
3402046c:	62bb      	str	r3, [r7, #40]	@ 0x28
3402046e:	e020      	b.n	340204b2 <yolov2_pp_nmsFiltering_centroid+0xb2>
            {
                float32_t *b = &(pInbuff[j + AI_YOLOV2_PP_XCENTER]);
34020470:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34020472:	009b      	lsls	r3, r3, #2
34020474:	697a      	ldr	r2, [r7, #20]
34020476:	4413      	add	r3, r2
34020478:	60fb      	str	r3, [r7, #12]
                if (vision_models_box_iou(a, b) > pInput_static_param->iou_threshold)
3402047a:	68f9      	ldr	r1, [r7, #12]
3402047c:	6938      	ldr	r0, [r7, #16]
3402047e:	f000 fe09 	bl	34021094 <vision_models_box_iou>
34020482:	eeb0 7a40 	vmov.f32	s14, s0
34020486:	683b      	ldr	r3, [r7, #0]
34020488:	edd3 7a07 	vldr	s15, [r3, #28]
3402048c:	eeb4 7ae7 	vcmpe.f32	s14, s15
34020490:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020494:	dd09      	ble.n	340204aa <yolov2_pp_nmsFiltering_centroid+0xaa>
                {
                    pInbuff[j + AI_YOLOV2_PP_CLASSPROB + k] = 0;
34020496:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34020498:	1d5a      	adds	r2, r3, #5
3402049a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402049c:	4413      	add	r3, r2
3402049e:	009b      	lsls	r3, r3, #2
340204a0:	697a      	ldr	r2, [r7, #20]
340204a2:	4413      	add	r3, r2
340204a4:	f04f 0200 	mov.w	r2, #0
340204a8:	601a      	str	r2, [r3, #0]
            for (j = i + anch_stride; j < (pInput_static_param->nb_detect * anch_stride); j += anch_stride)
340204aa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340204ac:	69bb      	ldr	r3, [r7, #24]
340204ae:	4413      	add	r3, r2
340204b0:	62bb      	str	r3, [r7, #40]	@ 0x28
340204b2:	683b      	ldr	r3, [r7, #0]
340204b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340204b6:	69ba      	ldr	r2, [r7, #24]
340204b8:	fb02 f303 	mul.w	r3, r2, r3
340204bc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340204be:	429a      	cmp	r2, r3
340204c0:	dbd6      	blt.n	34020470 <yolov2_pp_nmsFiltering_centroid+0x70>
340204c2:	e000      	b.n	340204c6 <yolov2_pp_nmsFiltering_centroid+0xc6>
            if (pInbuff[i + AI_YOLOV2_PP_CLASSPROB + k] == 0) continue;
340204c4:	bf00      	nop
        for (i = 0; i < (pInput_static_param->nb_detect * anch_stride) ; i += anch_stride)
340204c6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340204c8:	69bb      	ldr	r3, [r7, #24]
340204ca:	4413      	add	r3, r2
340204cc:	62fb      	str	r3, [r7, #44]	@ 0x2c
340204ce:	683b      	ldr	r3, [r7, #0]
340204d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340204d2:	69ba      	ldr	r2, [r7, #24]
340204d4:	fb02 f303 	mul.w	r3, r2, r3
340204d8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340204da:	429a      	cmp	r2, r3
340204dc:	dbb0      	blt.n	34020440 <yolov2_pp_nmsFiltering_centroid+0x40>
                }
            }
        }
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
340204de:	2300      	movs	r3, #0
340204e0:	61fb      	str	r3, [r7, #28]
340204e2:	e024      	b.n	3402052e <yolov2_pp_nmsFiltering_centroid+0x12e>
        {
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
340204e4:	683b      	ldr	r3, [r7, #0]
340204e6:	695b      	ldr	r3, [r3, #20]
340204e8:	6a3a      	ldr	r2, [r7, #32]
340204ea:	429a      	cmp	r2, r3
340204ec:	da11      	bge.n	34020512 <yolov2_pp_nmsFiltering_centroid+0x112>
                (pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] != 0))
340204ee:	69fb      	ldr	r3, [r7, #28]
340204f0:	1d5a      	adds	r2, r3, #5
340204f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340204f4:	4413      	add	r3, r2
340204f6:	009b      	lsls	r3, r3, #2
340204f8:	697a      	ldr	r2, [r7, #20]
340204fa:	4413      	add	r3, r2
340204fc:	edd3 7a00 	vldr	s15, [r3]
            if ((limit_counter < pInput_static_param->max_boxes_limit) &&
34020500:	eef5 7a40 	vcmp.f32	s15, #0.0
34020504:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020508:	d003      	beq.n	34020512 <yolov2_pp_nmsFiltering_centroid+0x112>
            {
                limit_counter++;
3402050a:	6a3b      	ldr	r3, [r7, #32]
3402050c:	3301      	adds	r3, #1
3402050e:	623b      	str	r3, [r7, #32]
34020510:	e009      	b.n	34020526 <yolov2_pp_nmsFiltering_centroid+0x126>
            }
            else
            {
                pInbuff[y + AI_YOLOV2_PP_CLASSPROB + k] = 0;
34020512:	69fb      	ldr	r3, [r7, #28]
34020514:	1d5a      	adds	r2, r3, #5
34020516:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34020518:	4413      	add	r3, r2
3402051a:	009b      	lsls	r3, r3, #2
3402051c:	697a      	ldr	r2, [r7, #20]
3402051e:	4413      	add	r3, r2
34020520:	f04f 0200 	mov.w	r2, #0
34020524:	601a      	str	r2, [r3, #0]
        for (int32_t y = 0; y <= (pInput_static_param->nb_detect * anch_stride); y += anch_stride)
34020526:	69fa      	ldr	r2, [r7, #28]
34020528:	69bb      	ldr	r3, [r7, #24]
3402052a:	4413      	add	r3, r2
3402052c:	61fb      	str	r3, [r7, #28]
3402052e:	683b      	ldr	r3, [r7, #0]
34020530:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34020532:	69ba      	ldr	r2, [r7, #24]
34020534:	fb02 f303 	mul.w	r3, r2, r3
34020538:	69fa      	ldr	r2, [r7, #28]
3402053a:	429a      	cmp	r2, r3
3402053c:	ddd2      	ble.n	340204e4 <yolov2_pp_nmsFiltering_centroid+0xe4>
    for (k = 0; k < pInput_static_param->nb_classes; ++k)
3402053e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34020540:	3301      	adds	r3, #1
34020542:	627b      	str	r3, [r7, #36]	@ 0x24
34020544:	683b      	ldr	r3, [r7, #0]
34020546:	681b      	ldr	r3, [r3, #0]
34020548:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3402054a:	429a      	cmp	r2, r3
3402054c:	f6ff af67 	blt.w	3402041e <yolov2_pp_nmsFiltering_centroid+0x1e>
            }
        }
    }

    return (AI_OD_POSTPROCESS_ERROR_NO);
34020550:	2300      	movs	r3, #0
}
34020552:	4618      	mov	r0, r3
34020554:	3730      	adds	r7, #48	@ 0x30
34020556:	46bd      	mov	sp, r7
34020558:	bd80      	pop	{r7, pc}
3402055a:	bf00      	nop
3402055c:	3404aab4 	.word	0x3404aab4
34020560:	34020389 	.word	0x34020389

34020564 <yolov2_pp_scoreFiltering_centroid>:


int32_t yolov2_pp_scoreFiltering_centroid(yolov2_pp_in_t *pInput,
                                          od_pp_out_t *pOutput,
                                          yolov2_pp_static_param_t *pInput_static_param)
{
34020564:	b580      	push	{r7, lr}
34020566:	b08a      	sub	sp, #40	@ 0x28
34020568:	af00      	add	r7, sp, #0
3402056a:	60f8      	str	r0, [r7, #12]
3402056c:	60b9      	str	r1, [r7, #8]
3402056e:	607a      	str	r2, [r7, #4]
    float32_t best_score;
    uint32_t class_index;
    int32_t det_count = 0;
34020570:	2300      	movs	r3, #0
34020572:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
34020574:	687b      	ldr	r3, [r7, #4]
34020576:	681b      	ldr	r3, [r3, #0]
34020578:	3305      	adds	r3, #5
3402057a:	61fb      	str	r3, [r7, #28]

    if (pOutput->pOutBuff == NULL)
3402057c:	68bb      	ldr	r3, [r7, #8]
3402057e:	681b      	ldr	r3, [r3, #0]
34020580:	2b00      	cmp	r3, #0
34020582:	d103      	bne.n	3402058c <yolov2_pp_scoreFiltering_centroid+0x28>
    {
      pOutput->pOutBuff = (od_pp_outBuffer_t *)pInput->pRaw_detections;
34020584:	68fb      	ldr	r3, [r7, #12]
34020586:	681a      	ldr	r2, [r3, #0]
34020588:	68bb      	ldr	r3, [r7, #8]
3402058a:	601a      	str	r2, [r3, #0]
    }
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
3402058c:	68fb      	ldr	r3, [r7, #12]
3402058e:	681b      	ldr	r3, [r3, #0]
34020590:	61bb      	str	r3, [r7, #24]

    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
34020592:	2300      	movs	r3, #0
34020594:	623b      	str	r3, [r7, #32]
34020596:	e06e      	b.n	34020676 <yolov2_pp_scoreFiltering_centroid+0x112>
    {
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
34020598:	6a3b      	ldr	r3, [r7, #32]
3402059a:	3305      	adds	r3, #5
3402059c:	009b      	lsls	r3, r3, #2
3402059e:	69ba      	ldr	r2, [r7, #24]
340205a0:	18d0      	adds	r0, r2, r3
             pInput_static_param->nb_classes,
340205a2:	687b      	ldr	r3, [r7, #4]
340205a4:	681b      	ldr	r3, [r3, #0]
        vision_models_maxi_if32ou32(&pInbuff[i + AI_YOLOV2_PP_CLASSPROB],
340205a6:	4619      	mov	r1, r3
340205a8:	f107 0310 	add.w	r3, r7, #16
340205ac:	f107 0214 	add.w	r2, r7, #20
340205b0:	f000 fa39 	bl	34020a26 <vision_models_maxi_if32ou32>
             &best_score,
             &class_index);

        if (best_score >= pInput_static_param->conf_threshold)
340205b4:	687b      	ldr	r3, [r7, #4]
340205b6:	ed93 7a06 	vldr	s14, [r3, #24]
340205ba:	edd7 7a05 	vldr	s15, [r7, #20]
340205be:	eeb4 7ae7 	vcmpe.f32	s14, s15
340205c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340205c6:	d852      	bhi.n	3402066e <yolov2_pp_scoreFiltering_centroid+0x10a>
        {
            pOutput->pOutBuff[det_count].x_center = pInbuff[i + AI_YOLOV2_PP_XCENTER];
340205c8:	6a3b      	ldr	r3, [r7, #32]
340205ca:	009b      	lsls	r3, r3, #2
340205cc:	69ba      	ldr	r2, [r7, #24]
340205ce:	18d1      	adds	r1, r2, r3
340205d0:	68bb      	ldr	r3, [r7, #8]
340205d2:	6818      	ldr	r0, [r3, #0]
340205d4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340205d6:	4613      	mov	r3, r2
340205d8:	005b      	lsls	r3, r3, #1
340205da:	4413      	add	r3, r2
340205dc:	00db      	lsls	r3, r3, #3
340205de:	4403      	add	r3, r0
340205e0:	680a      	ldr	r2, [r1, #0]
340205e2:	601a      	str	r2, [r3, #0]
            pOutput->pOutBuff[det_count].y_center = pInbuff[i + AI_YOLOV2_PP_YCENTER];
340205e4:	6a3b      	ldr	r3, [r7, #32]
340205e6:	3301      	adds	r3, #1
340205e8:	009b      	lsls	r3, r3, #2
340205ea:	69ba      	ldr	r2, [r7, #24]
340205ec:	18d1      	adds	r1, r2, r3
340205ee:	68bb      	ldr	r3, [r7, #8]
340205f0:	6818      	ldr	r0, [r3, #0]
340205f2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340205f4:	4613      	mov	r3, r2
340205f6:	005b      	lsls	r3, r3, #1
340205f8:	4413      	add	r3, r2
340205fa:	00db      	lsls	r3, r3, #3
340205fc:	4403      	add	r3, r0
340205fe:	680a      	ldr	r2, [r1, #0]
34020600:	605a      	str	r2, [r3, #4]
            pOutput->pOutBuff[det_count].width = pInbuff[i + AI_YOLOV2_PP_WIDTHREL];
34020602:	6a3b      	ldr	r3, [r7, #32]
34020604:	3302      	adds	r3, #2
34020606:	009b      	lsls	r3, r3, #2
34020608:	69ba      	ldr	r2, [r7, #24]
3402060a:	18d1      	adds	r1, r2, r3
3402060c:	68bb      	ldr	r3, [r7, #8]
3402060e:	6818      	ldr	r0, [r3, #0]
34020610:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34020612:	4613      	mov	r3, r2
34020614:	005b      	lsls	r3, r3, #1
34020616:	4413      	add	r3, r2
34020618:	00db      	lsls	r3, r3, #3
3402061a:	4403      	add	r3, r0
3402061c:	680a      	ldr	r2, [r1, #0]
3402061e:	609a      	str	r2, [r3, #8]
            pOutput->pOutBuff[det_count].height = pInbuff[i + AI_YOLOV2_PP_HEIGHTREL];
34020620:	6a3b      	ldr	r3, [r7, #32]
34020622:	3303      	adds	r3, #3
34020624:	009b      	lsls	r3, r3, #2
34020626:	69ba      	ldr	r2, [r7, #24]
34020628:	18d1      	adds	r1, r2, r3
3402062a:	68bb      	ldr	r3, [r7, #8]
3402062c:	6818      	ldr	r0, [r3, #0]
3402062e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34020630:	4613      	mov	r3, r2
34020632:	005b      	lsls	r3, r3, #1
34020634:	4413      	add	r3, r2
34020636:	00db      	lsls	r3, r3, #3
34020638:	4403      	add	r3, r0
3402063a:	680a      	ldr	r2, [r1, #0]
3402063c:	60da      	str	r2, [r3, #12]
            pOutput->pOutBuff[det_count].class_index = class_index;
3402063e:	6938      	ldr	r0, [r7, #16]
34020640:	68bb      	ldr	r3, [r7, #8]
34020642:	6819      	ldr	r1, [r3, #0]
34020644:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34020646:	4613      	mov	r3, r2
34020648:	005b      	lsls	r3, r3, #1
3402064a:	4413      	add	r3, r2
3402064c:	00db      	lsls	r3, r3, #3
3402064e:	440b      	add	r3, r1
34020650:	4602      	mov	r2, r0
34020652:	615a      	str	r2, [r3, #20]
            pOutput->pOutBuff[det_count].conf = best_score;
34020654:	68bb      	ldr	r3, [r7, #8]
34020656:	6819      	ldr	r1, [r3, #0]
34020658:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3402065a:	4613      	mov	r3, r2
3402065c:	005b      	lsls	r3, r3, #1
3402065e:	4413      	add	r3, r2
34020660:	00db      	lsls	r3, r3, #3
34020662:	440b      	add	r3, r1
34020664:	697a      	ldr	r2, [r7, #20]
34020666:	611a      	str	r2, [r3, #16]
            det_count++;
34020668:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402066a:	3301      	adds	r3, #1
3402066c:	627b      	str	r3, [r7, #36]	@ 0x24
    for (int32_t i = 0; i < (pInput_static_param->nb_detect * anch_stride); i += anch_stride)
3402066e:	6a3a      	ldr	r2, [r7, #32]
34020670:	69fb      	ldr	r3, [r7, #28]
34020672:	4413      	add	r3, r2
34020674:	623b      	str	r3, [r7, #32]
34020676:	687b      	ldr	r3, [r7, #4]
34020678:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3402067a:	69fa      	ldr	r2, [r7, #28]
3402067c:	fb02 f303 	mul.w	r3, r2, r3
34020680:	6a3a      	ldr	r2, [r7, #32]
34020682:	429a      	cmp	r2, r3
34020684:	db88      	blt.n	34020598 <yolov2_pp_scoreFiltering_centroid+0x34>
        }
    }
    pOutput->nb_detect = det_count;
34020686:	68bb      	ldr	r3, [r7, #8]
34020688:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3402068a:	605a      	str	r2, [r3, #4]

    return (AI_OD_POSTPROCESS_ERROR_NO);
3402068c:	2300      	movs	r3, #0
}
3402068e:	4618      	mov	r0, r3
34020690:	3728      	adds	r7, #40	@ 0x28
34020692:	46bd      	mov	sp, r7
34020694:	bd80      	pop	{r7, pc}

34020696 <yolov2_pp_getNNBoxes_centroid>:


int32_t yolov2_pp_getNNBoxes_centroid(yolov2_pp_in_t *pInput,
                                      yolov2_pp_static_param_t *pInput_static_param)
{
34020696:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
3402069a:	ed2d 8b02 	vpush	{d8}
3402069e:	b096      	sub	sp, #88	@ 0x58
340206a0:	af00      	add	r7, sp, #0
340206a2:	6078      	str	r0, [r7, #4]
340206a4:	6039      	str	r1, [r7, #0]
340206a6:	466b      	mov	r3, sp
340206a8:	461d      	mov	r5, r3
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;
340206aa:	2300      	movs	r3, #0
340206ac:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t count = 0;
340206ae:	2300      	movs	r3, #0
340206b0:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t count_detect = 0;
340206b2:	2300      	movs	r3, #0
340206b4:	653b      	str	r3, [r7, #80]	@ 0x50
    float32_t best_score=0;
340206b6:	f04f 0300 	mov.w	r3, #0
340206ba:	613b      	str	r3, [r7, #16]
    uint32_t class_index;
    int32_t anch_stride = (pInput_static_param->nb_classes + AI_YOLOV2_PP_CLASSPROB);
340206bc:	683b      	ldr	r3, [r7, #0]
340206be:	681b      	ldr	r3, [r3, #0]
340206c0:	3305      	adds	r3, #5
340206c2:	633b      	str	r3, [r7, #48]	@ 0x30

    yolov2_pp_in_t *pOutput = pInput;
340206c4:	687b      	ldr	r3, [r7, #4]
340206c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    float32_t grid_width_inv = 1.0f / pInput_static_param->grid_width;
340206c8:	683b      	ldr	r3, [r7, #0]
340206ca:	689b      	ldr	r3, [r3, #8]
340206cc:	ee07 3a90 	vmov	s15, r3
340206d0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
340206d4:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
340206d8:	eec6 7a87 	vdiv.f32	s15, s13, s14
340206dc:	edc7 7a0a 	vstr	s15, [r7, #40]	@ 0x28
    float32_t grid_height_inv = 1.0f / pInput_static_param->grid_height;
340206e0:	683b      	ldr	r3, [r7, #0]
340206e2:	68db      	ldr	r3, [r3, #12]
340206e4:	ee07 3a90 	vmov	s15, r3
340206e8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
340206ec:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
340206f0:	eec6 7a87 	vdiv.f32	s15, s13, s14
340206f4:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
    float32_t tmp_a[pInput_static_param->nb_classes];
340206f8:	683b      	ldr	r3, [r7, #0]
340206fa:	681b      	ldr	r3, [r3, #0]
340206fc:	1e5a      	subs	r2, r3, #1
340206fe:	623a      	str	r2, [r7, #32]
34020700:	4619      	mov	r1, r3
34020702:	2200      	movs	r2, #0
34020704:	468a      	mov	sl, r1
34020706:	4693      	mov	fp, r2
34020708:	4619      	mov	r1, r3
3402070a:	2200      	movs	r2, #0
3402070c:	4688      	mov	r8, r1
3402070e:	4691      	mov	r9, r2
34020710:	009b      	lsls	r3, r3, #2
34020712:	3307      	adds	r3, #7
34020714:	08db      	lsrs	r3, r3, #3
34020716:	00db      	lsls	r3, r3, #3
34020718:	ebad 0d03 	sub.w	sp, sp, r3
3402071c:	466b      	mov	r3, sp
3402071e:	3303      	adds	r3, #3
34020720:	089b      	lsrs	r3, r3, #2
34020722:	009b      	lsls	r3, r3, #2
34020724:	61fb      	str	r3, [r7, #28]
    int32_t el_offset = 0;
34020726:	2300      	movs	r3, #0
34020728:	64fb      	str	r3, [r7, #76]	@ 0x4c
    float32_t *pInbuff = (float32_t *)pInput->pRaw_detections;
3402072a:	687b      	ldr	r3, [r7, #4]
3402072c:	681b      	ldr	r3, [r3, #0]
3402072e:	61bb      	str	r3, [r7, #24]
    float32_t *pOutbuff = (float32_t *)pOutput->pRaw_detections;
34020730:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34020732:	681b      	ldr	r3, [r3, #0]
34020734:	617b      	str	r3, [r7, #20]
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34020736:	2300      	movs	r3, #0
34020738:	64bb      	str	r3, [r7, #72]	@ 0x48
3402073a:	e12d      	b.n	34020998 <yolov2_pp_getNNBoxes_centroid+0x302>
    {
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
3402073c:	2300      	movs	r3, #0
3402073e:	647b      	str	r3, [r7, #68]	@ 0x44
34020740:	e121      	b.n	34020986 <yolov2_pp_getNNBoxes_centroid+0x2f0>
        {
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
34020742:	2300      	movs	r3, #0
34020744:	643b      	str	r3, [r7, #64]	@ 0x40
34020746:	e115      	b.n	34020974 <yolov2_pp_getNNBoxes_centroid+0x2de>
            {
                /* read and activate objectness */
                pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] = vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS]);
34020748:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402074a:	3304      	adds	r3, #4
3402074c:	009b      	lsls	r3, r3, #2
3402074e:	69ba      	ldr	r2, [r7, #24]
34020750:	4413      	add	r3, r2
34020752:	edd3 7a00 	vldr	s15, [r3]
34020756:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34020758:	3304      	adds	r3, #4
3402075a:	009b      	lsls	r3, r3, #2
3402075c:	697a      	ldr	r2, [r7, #20]
3402075e:	18d4      	adds	r4, r2, r3
34020760:	eeb0 0a67 	vmov.f32	s0, s15
34020764:	f000 fb2b 	bl	34020dbe <vision_models_sigmoid_f>
34020768:	eef0 7a40 	vmov.f32	s15, s0
3402076c:	edc4 7a00 	vstr	s15, [r4]

                /* activate array of classes pred */
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34020770:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34020772:	3305      	adds	r3, #5
34020774:	009b      	lsls	r3, r3, #2
34020776:	69ba      	ldr	r2, [r7, #24]
34020778:	18d0      	adds	r0, r2, r3
                        &pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
3402077a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402077c:	3305      	adds	r3, #5
3402077e:	009b      	lsls	r3, r3, #2
                vision_models_softmax_f(&pInbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
34020780:	697a      	ldr	r2, [r7, #20]
34020782:	18d1      	adds	r1, r2, r3
34020784:	683b      	ldr	r3, [r7, #0]
34020786:	681a      	ldr	r2, [r3, #0]
34020788:	69fb      	ldr	r3, [r7, #28]
3402078a:	f000 fb36 	bl	34020dfa <vision_models_softmax_f>
                        pInput_static_param->nb_classes,
                        tmp_a);
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
3402078e:	2300      	movs	r3, #0
34020790:	63fb      	str	r3, [r7, #60]	@ 0x3c
34020792:	e01d      	b.n	340207d0 <yolov2_pp_getNNBoxes_centroid+0x13a>
                {
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
34020794:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34020796:	3304      	adds	r3, #4
34020798:	009b      	lsls	r3, r3, #2
3402079a:	697a      	ldr	r2, [r7, #20]
3402079c:	4413      	add	r3, r2
3402079e:	ed93 7a00 	vldr	s14, [r3]
                                                                       pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
340207a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340207a4:	1d5a      	adds	r2, r3, #5
340207a6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340207a8:	4413      	add	r3, r2
340207aa:	009b      	lsls	r3, r3, #2
340207ac:	697a      	ldr	r2, [r7, #20]
340207ae:	4413      	add	r3, r2
340207b0:	edd3 7a00 	vldr	s15, [r3]
                    pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS] *
340207b4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340207b6:	1d5a      	adds	r2, r3, #5
340207b8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340207ba:	4413      	add	r3, r2
340207bc:	009b      	lsls	r3, r3, #2
340207be:	697a      	ldr	r2, [r7, #20]
340207c0:	4413      	add	r3, r2
340207c2:	ee67 7a27 	vmul.f32	s15, s14, s15
340207c6:	edc3 7a00 	vstr	s15, [r3]
                for (int32_t k = 0; k < pInput_static_param->nb_classes; k++)
340207ca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340207cc:	3301      	adds	r3, #1
340207ce:	63fb      	str	r3, [r7, #60]	@ 0x3c
340207d0:	683b      	ldr	r3, [r7, #0]
340207d2:	681b      	ldr	r3, [r3, #0]
340207d4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340207d6:	429a      	cmp	r2, r3
340207d8:	dbdc      	blt.n	34020794 <yolov2_pp_getNNBoxes_centroid+0xfe>
                }

                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
340207da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340207dc:	3305      	adds	r3, #5
340207de:	009b      	lsls	r3, r3, #2
340207e0:	697a      	ldr	r2, [r7, #20]
340207e2:	18d0      	adds	r0, r2, r3
                     pInput_static_param->nb_classes,
340207e4:	683b      	ldr	r3, [r7, #0]
340207e6:	681b      	ldr	r3, [r3, #0]
                vision_models_maxi_if32ou32(&pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB],
340207e8:	4619      	mov	r1, r3
340207ea:	f107 030c 	add.w	r3, r7, #12
340207ee:	f107 0210 	add.w	r2, r7, #16
340207f2:	f000 f918 	bl	34020a26 <vision_models_maxi_if32ou32>
                     &best_score,
                     &class_index);

                if (best_score >= pInput_static_param->conf_threshold)
340207f6:	683b      	ldr	r3, [r7, #0]
340207f8:	ed93 7a06 	vldr	s14, [r3, #24]
340207fc:	edd7 7a04 	vldr	s15, [r7, #16]
34020800:	eeb4 7ae7 	vcmpe.f32	s14, s15
34020804:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020808:	f200 80ad 	bhi.w	34020966 <yolov2_pp_getNNBoxes_centroid+0x2d0>
                {
                    pOutbuff[count + AI_YOLOV2_PP_OBJECTNESS] = pOutbuff[el_offset + AI_YOLOV2_PP_OBJECTNESS];
3402080c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402080e:	3304      	adds	r3, #4
34020810:	009b      	lsls	r3, r3, #2
34020812:	697a      	ldr	r2, [r7, #20]
34020814:	441a      	add	r2, r3
34020816:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34020818:	3304      	adds	r3, #4
3402081a:	009b      	lsls	r3, r3, #2
3402081c:	6979      	ldr	r1, [r7, #20]
3402081e:	440b      	add	r3, r1
34020820:	6812      	ldr	r2, [r2, #0]
34020822:	601a      	str	r2, [r3, #0]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
34020824:	2300      	movs	r3, #0
34020826:	63bb      	str	r3, [r7, #56]	@ 0x38
34020828:	e012      	b.n	34020850 <yolov2_pp_getNNBoxes_centroid+0x1ba>
                    {
                        pOutbuff[count + AI_YOLOV2_PP_CLASSPROB + k] = pOutbuff[el_offset + AI_YOLOV2_PP_CLASSPROB + k];
3402082a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402082c:	1d5a      	adds	r2, r3, #5
3402082e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34020830:	4413      	add	r3, r2
34020832:	009b      	lsls	r3, r3, #2
34020834:	697a      	ldr	r2, [r7, #20]
34020836:	441a      	add	r2, r3
34020838:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3402083a:	1d59      	adds	r1, r3, #5
3402083c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402083e:	440b      	add	r3, r1
34020840:	009b      	lsls	r3, r3, #2
34020842:	6979      	ldr	r1, [r7, #20]
34020844:	440b      	add	r3, r1
34020846:	6812      	ldr	r2, [r2, #0]
34020848:	601a      	str	r2, [r3, #0]
                    for (int32_t k = 0; k < pInput_static_param->nb_classes; ++k)
3402084a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402084c:	3301      	adds	r3, #1
3402084e:	63bb      	str	r3, [r7, #56]	@ 0x38
34020850:	683b      	ldr	r3, [r7, #0]
34020852:	681b      	ldr	r3, [r3, #0]
34020854:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34020856:	429a      	cmp	r2, r3
34020858:	dbe7      	blt.n	3402082a <yolov2_pp_getNNBoxes_centroid+0x194>
                    }

                    pOutbuff[count + AI_YOLOV2_PP_XCENTER] = (col + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_XCENTER])) * grid_width_inv;
3402085a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402085c:	ee07 3a90 	vmov	s15, r3
34020860:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
34020864:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34020866:	009b      	lsls	r3, r3, #2
34020868:	69ba      	ldr	r2, [r7, #24]
3402086a:	4413      	add	r3, r2
3402086c:	edd3 7a00 	vldr	s15, [r3]
34020870:	eeb0 0a67 	vmov.f32	s0, s15
34020874:	f000 faa3 	bl	34020dbe <vision_models_sigmoid_f>
34020878:	eef0 7a40 	vmov.f32	s15, s0
3402087c:	ee38 7a27 	vadd.f32	s14, s16, s15
34020880:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34020882:	009b      	lsls	r3, r3, #2
34020884:	697a      	ldr	r2, [r7, #20]
34020886:	4413      	add	r3, r2
34020888:	edd7 7a0a 	vldr	s15, [r7, #40]	@ 0x28
3402088c:	ee67 7a27 	vmul.f32	s15, s14, s15
34020890:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_YCENTER] = (row + vision_models_sigmoid_f(pInbuff[el_offset + AI_YOLOV2_PP_YCENTER])) * grid_height_inv;
34020894:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34020896:	ee07 3a90 	vmov	s15, r3
3402089a:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
3402089e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340208a0:	3301      	adds	r3, #1
340208a2:	009b      	lsls	r3, r3, #2
340208a4:	69ba      	ldr	r2, [r7, #24]
340208a6:	4413      	add	r3, r2
340208a8:	edd3 7a00 	vldr	s15, [r3]
340208ac:	eeb0 0a67 	vmov.f32	s0, s15
340208b0:	f000 fa85 	bl	34020dbe <vision_models_sigmoid_f>
340208b4:	eef0 7a40 	vmov.f32	s15, s0
340208b8:	ee38 7a27 	vadd.f32	s14, s16, s15
340208bc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340208be:	3301      	adds	r3, #1
340208c0:	009b      	lsls	r3, r3, #2
340208c2:	697a      	ldr	r2, [r7, #20]
340208c4:	4413      	add	r3, r2
340208c6:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
340208ca:	ee67 7a27 	vmul.f32	s15, s14, s15
340208ce:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_WIDTHREL] = (pInput_static_param->pAnchors[2 * anch] * expf(pInbuff[el_offset + AI_YOLOV2_PP_WIDTHREL])) * grid_width_inv;
340208d2:	683b      	ldr	r3, [r7, #0]
340208d4:	6a1a      	ldr	r2, [r3, #32]
340208d6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340208d8:	00db      	lsls	r3, r3, #3
340208da:	4413      	add	r3, r2
340208dc:	ed93 8a00 	vldr	s16, [r3]
340208e0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340208e2:	3302      	adds	r3, #2
340208e4:	009b      	lsls	r3, r3, #2
340208e6:	69ba      	ldr	r2, [r7, #24]
340208e8:	4413      	add	r3, r2
340208ea:	edd3 7a00 	vldr	s15, [r3]
340208ee:	eeb0 0a67 	vmov.f32	s0, s15
340208f2:	f009 f945 	bl	34029b80 <expf>
340208f6:	eef0 7a40 	vmov.f32	s15, s0
340208fa:	ee28 7a27 	vmul.f32	s14, s16, s15
340208fe:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34020900:	3302      	adds	r3, #2
34020902:	009b      	lsls	r3, r3, #2
34020904:	697a      	ldr	r2, [r7, #20]
34020906:	4413      	add	r3, r2
34020908:	edd7 7a0a 	vldr	s15, [r7, #40]	@ 0x28
3402090c:	ee67 7a27 	vmul.f32	s15, s14, s15
34020910:	edc3 7a00 	vstr	s15, [r3]
                    pOutbuff[count + AI_YOLOV2_PP_HEIGHTREL] = (pInput_static_param->pAnchors[2 * anch + 1] * expf(pInbuff[el_offset + AI_YOLOV2_PP_HEIGHTREL])) * grid_height_inv;
34020914:	683b      	ldr	r3, [r7, #0]
34020916:	6a1a      	ldr	r2, [r3, #32]
34020918:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402091a:	00db      	lsls	r3, r3, #3
3402091c:	3304      	adds	r3, #4
3402091e:	4413      	add	r3, r2
34020920:	ed93 8a00 	vldr	s16, [r3]
34020924:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34020926:	3303      	adds	r3, #3
34020928:	009b      	lsls	r3, r3, #2
3402092a:	69ba      	ldr	r2, [r7, #24]
3402092c:	4413      	add	r3, r2
3402092e:	edd3 7a00 	vldr	s15, [r3]
34020932:	eeb0 0a67 	vmov.f32	s0, s15
34020936:	f009 f923 	bl	34029b80 <expf>
3402093a:	eef0 7a40 	vmov.f32	s15, s0
3402093e:	ee28 7a27 	vmul.f32	s14, s16, s15
34020942:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34020944:	3303      	adds	r3, #3
34020946:	009b      	lsls	r3, r3, #2
34020948:	697a      	ldr	r2, [r7, #20]
3402094a:	4413      	add	r3, r2
3402094c:	edd7 7a09 	vldr	s15, [r7, #36]	@ 0x24
34020950:	ee67 7a27 	vmul.f32	s15, s14, s15
34020954:	edc3 7a00 	vstr	s15, [r3]

                    count += anch_stride;
34020958:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
3402095a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402095c:	4413      	add	r3, r2
3402095e:	657b      	str	r3, [r7, #84]	@ 0x54
                    count_detect++;
34020960:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34020962:	3301      	adds	r3, #1
34020964:	653b      	str	r3, [r7, #80]	@ 0x50
                }

                el_offset += anch_stride;
34020966:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34020968:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402096a:	4413      	add	r3, r2
3402096c:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for (int32_t anch = 0; anch < pInput_static_param->nb_anchors; ++anch)
3402096e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34020970:	3301      	adds	r3, #1
34020972:	643b      	str	r3, [r7, #64]	@ 0x40
34020974:	683b      	ldr	r3, [r7, #0]
34020976:	685b      	ldr	r3, [r3, #4]
34020978:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3402097a:	429a      	cmp	r2, r3
3402097c:	f6ff aee4 	blt.w	34020748 <yolov2_pp_getNNBoxes_centroid+0xb2>
        for (int32_t col = 0; col < pInput_static_param->grid_height; ++col)
34020980:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34020982:	3301      	adds	r3, #1
34020984:	647b      	str	r3, [r7, #68]	@ 0x44
34020986:	683b      	ldr	r3, [r7, #0]
34020988:	68db      	ldr	r3, [r3, #12]
3402098a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3402098c:	429a      	cmp	r2, r3
3402098e:	f6ff aed8 	blt.w	34020742 <yolov2_pp_getNNBoxes_centroid+0xac>
    for (int32_t row = 0; row < pInput_static_param->grid_width; ++row)
34020992:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34020994:	3301      	adds	r3, #1
34020996:	64bb      	str	r3, [r7, #72]	@ 0x48
34020998:	683b      	ldr	r3, [r7, #0]
3402099a:	689b      	ldr	r3, [r3, #8]
3402099c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3402099e:	429a      	cmp	r2, r3
340209a0:	f6ff aecc 	blt.w	3402073c <yolov2_pp_getNNBoxes_centroid+0xa6>
            }
        }
    }

    pInput_static_param->nb_detect = count_detect;
340209a4:	683b      	ldr	r3, [r7, #0]
340209a6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
340209a8:	625a      	str	r2, [r3, #36]	@ 0x24
    return (error);
340209aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340209ac:	46ad      	mov	sp, r5
}
340209ae:	4618      	mov	r0, r3
340209b0:	3758      	adds	r7, #88	@ 0x58
340209b2:	46bd      	mov	sp, r7
340209b4:	ecbd 8b02 	vpop	{d8}
340209b8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

340209bc <od_yolov2_pp_reset>:


/* ----------------------       Exported routines      ---------------------- */

int32_t od_yolov2_pp_reset(yolov2_pp_static_param_t *pInput_static_param)
{
340209bc:	b480      	push	{r7}
340209be:	b083      	sub	sp, #12
340209c0:	af00      	add	r7, sp, #0
340209c2:	6078      	str	r0, [r7, #4]
    /* Initializations */
    pInput_static_param->nb_detect = 0;
340209c4:	687b      	ldr	r3, [r7, #4]
340209c6:	2200      	movs	r2, #0
340209c8:	625a      	str	r2, [r3, #36]	@ 0x24

	return (AI_OD_POSTPROCESS_ERROR_NO);
340209ca:	2300      	movs	r3, #0
}
340209cc:	4618      	mov	r0, r3
340209ce:	370c      	adds	r7, #12
340209d0:	46bd      	mov	sp, r7
340209d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340209d6:	4770      	bx	lr

340209d8 <od_yolov2_pp_process>:


int32_t od_yolov2_pp_process(yolov2_pp_in_t *pInput,
                                    od_pp_out_t *pOutput,
                                    yolov2_pp_static_param_t *pInput_static_param)
{
340209d8:	b580      	push	{r7, lr}
340209da:	b086      	sub	sp, #24
340209dc:	af00      	add	r7, sp, #0
340209de:	60f8      	str	r0, [r7, #12]
340209e0:	60b9      	str	r1, [r7, #8]
340209e2:	607a      	str	r2, [r7, #4]
    int32_t error   = AI_OD_POSTPROCESS_ERROR_NO;
340209e4:	2300      	movs	r3, #0
340209e6:	617b      	str	r3, [r7, #20]

    /* Call Get NN boxes first */
    error = yolov2_pp_getNNBoxes_centroid(pInput,
340209e8:	6879      	ldr	r1, [r7, #4]
340209ea:	68f8      	ldr	r0, [r7, #12]
340209ec:	f7ff fe53 	bl	34020696 <yolov2_pp_getNNBoxes_centroid>
340209f0:	6178      	str	r0, [r7, #20]
                                          pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
340209f2:	697b      	ldr	r3, [r7, #20]
340209f4:	2b00      	cmp	r3, #0
340209f6:	d001      	beq.n	340209fc <od_yolov2_pp_process+0x24>
340209f8:	697b      	ldr	r3, [r7, #20]
340209fa:	e010      	b.n	34020a1e <od_yolov2_pp_process+0x46>

    /* Then NMS */
    error = yolov2_pp_nmsFiltering_centroid(pInput,
340209fc:	6879      	ldr	r1, [r7, #4]
340209fe:	68f8      	ldr	r0, [r7, #12]
34020a00:	f7ff fcfe 	bl	34020400 <yolov2_pp_nmsFiltering_centroid>
34020a04:	6178      	str	r0, [r7, #20]
                                            pInput_static_param);
    if (error != AI_OD_POSTPROCESS_ERROR_NO) return (error);
34020a06:	697b      	ldr	r3, [r7, #20]
34020a08:	2b00      	cmp	r3, #0
34020a0a:	d001      	beq.n	34020a10 <od_yolov2_pp_process+0x38>
34020a0c:	697b      	ldr	r3, [r7, #20]
34020a0e:	e006      	b.n	34020a1e <od_yolov2_pp_process+0x46>

    /* And score re-filtering */
    error = yolov2_pp_scoreFiltering_centroid(pInput,
34020a10:	687a      	ldr	r2, [r7, #4]
34020a12:	68b9      	ldr	r1, [r7, #8]
34020a14:	68f8      	ldr	r0, [r7, #12]
34020a16:	f7ff fda5 	bl	34020564 <yolov2_pp_scoreFiltering_centroid>
34020a1a:	6178      	str	r0, [r7, #20]
                                              pOutput,
                                              pInput_static_param);

    return (error);
34020a1c:	697b      	ldr	r3, [r7, #20]
}
34020a1e:	4618      	mov	r0, r3
34020a20:	3718      	adds	r7, #24
34020a22:	46bd      	mov	sp, r7
34020a24:	bd80      	pop	{r7, pc}

34020a26 <vision_models_maxi_if32ou32>:
#include "stdio.h"

/* return max value and it's index from an array */
#if defined(AI_OD_YOLOV5_PP_MVEF_OPTIM) || defined(AI_SPE_MOVENET_PP_MVEF_OPTIM)
void vision_models_maxi_if32ou32(float32_t *arr, uint32_t len_arr, float32_t *maxim, uint32_t *index)
{
34020a26:	b490      	push	{r4, r7}
34020a28:	b0dc      	sub	sp, #368	@ 0x170
34020a2a:	af00      	add	r7, sp, #0
34020a2c:	f507 74b8 	add.w	r4, r7, #368	@ 0x170
34020a30:	f5a4 74b2 	sub.w	r4, r4, #356	@ 0x164
34020a34:	6020      	str	r0, [r4, #0]
34020a36:	f507 70b8 	add.w	r0, r7, #368	@ 0x170
34020a3a:	f5a0 70b4 	sub.w	r0, r0, #360	@ 0x168
34020a3e:	6001      	str	r1, [r0, #0]
34020a40:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
34020a44:	f5a1 71b6 	sub.w	r1, r1, #364	@ 0x16c
34020a48:	600a      	str	r2, [r1, #0]
34020a4a:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020a4e:	f5a2 72b8 	sub.w	r2, r2, #368	@ 0x170
34020a52:	6013      	str	r3, [r2, #0]
34020a54:	f46f 0300 	mvn.w	r3, #8388608	@ 0x800000
34020a58:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vdupq_n_f32 (float32_t __a)
{
  return __builtin_mve_vdupq_n_fv4sf (__a);
34020a5c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
34020a60:	eea6 3b10 	vdup.32	q3, r3

  float32x4_t    f32x4_max_val = vdupq_n_f32(F32_MIN);
34020a64:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020a68:	3b10      	subs	r3, #16
34020a6a:	ed83 7f00 	stc	15, cr7, [r3]
34020a6e:	2300      	movs	r3, #0
34020a70:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
  return __builtin_mve_vdupq_n_uv4si (__a);
34020a74:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
34020a78:	eea6 3b10 	vdup.32	q3, r3
  uint32x4_t     u32x4_max_idx = vdupq_n_u32(0);
34020a7c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020a80:	3b20      	subs	r3, #32
34020a82:	ed83 7f00 	stc	15, cr7, [r3]
34020a86:	2300      	movs	r3, #0
34020a88:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
  return __builtin_mve_vidupq_n_uv4si (__a, __imm);
34020a8c:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
34020a90:	461a      	mov	r2, r3
34020a92:	ee23 6f6e 	cdp	15, 2, cr6, cr3, cr14, {3}


  uint32x4_t u32x4_idx = vidupq_n_u32(0,1);
34020a96:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020a9a:	3b30      	subs	r3, #48	@ 0x30
34020a9c:	ed83 7f00 	stc	15, cr7, [r3]
  float32_t *pSrc = arr;
34020aa0:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020aa4:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
34020aa8:	681b      	ldr	r3, [r3, #0]
34020aaa:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
  int32_t iter = len_arr;
34020aae:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020ab2:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
34020ab6:	681b      	ldr	r3, [r3, #0]
34020ab8:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
  while(iter > 0)
34020abc:	e0c2      	b.n	34020c44 <vision_models_maxi_if32ou32+0x21e>
  {
    mve_pred16_t p = vctp32q(iter);
34020abe:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
34020ac2:	67bb      	str	r3, [r7, #120]	@ 0x78
  return __builtin_mve_vctp32qv4bi (__a);
34020ac4:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34020ac6:	f023 e801 	bfcsel	0, 3401facc <ISP_SVC_Misc_IsGammaEnabled+0x46>, 4, hi
34020aca:	eefd 3a10 	vmrs	r3, <impl def 0xd>
34020ace:	b29b      	uxth	r3, r3
34020ad0:	f8a7 311e 	strh.w	r3, [r7, #286]	@ 0x11e
34020ad4:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34020ad8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
34020adc:	f8b7 311e 	ldrh.w	r3, [r7, #286]	@ 0x11e
34020ae0:	f8a7 307e 	strh.w	r3, [r7, #126]	@ 0x7e

__extension__ extern __inline float32x4_t
__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
__arm_vldrwq_z_f32 (float32_t const * __base, mve_pred16_t __p)
{
  return __builtin_mve_vldrwq_z_fv4sf((__builtin_neon_si *) __base, __p);
34020ae4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34020ae8:	f8b7 207e 	ldrh.w	r2, [r7, #126]	@ 0x7e
34020aec:	eeed 2a10 	vmsr	<impl def 0xd>, r2
34020af0:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34020af4:	ed93 7f00 	ldc	15, cr7, [r3]
    // load up to 4 float32_t
    float32x4_t f32x4_val = vldrwq_z_f32(pSrc, p);
34020af8:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020afc:	3b68      	subs	r3, #104	@ 0x68
34020afe:	ed83 7f00 	stc	15, cr7, [r3]
    pSrc+=4;
34020b02:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
34020b06:	3310      	adds	r3, #16
34020b08:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
34020b0c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b10:	3bd8      	subs	r3, #216	@ 0xd8
34020b12:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020b16:	3a68      	subs	r2, #104	@ 0x68
34020b18:	ed92 7f00 	ldc	15, cr7, [r2]
34020b1c:	ed83 7f00 	stc	15, cr7, [r3]
34020b20:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b24:	3be8      	subs	r3, #232	@ 0xe8
34020b26:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020b2a:	3a10      	subs	r2, #16
34020b2c:	ed92 7f00 	ldc	15, cr7, [r2]
34020b30:	ed83 7f00 	stc	15, cr7, [r3]
34020b34:	f8b7 311e 	ldrh.w	r3, [r7, #286]	@ 0x11e
34020b38:	f8a7 3086 	strh.w	r3, [r7, #134]	@ 0x86
  return __builtin_mve_vcmpgtq_m_fv4sf (__a, __b, __p);
34020b3c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b40:	3bd8      	subs	r3, #216	@ 0xd8
34020b42:	ed93 7f00 	ldc	15, cr7, [r3]
34020b46:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b4a:	3be8      	subs	r3, #232	@ 0xe8
34020b4c:	ed93 5f00 	ldc	15, cr5, [r3]
34020b50:	f8b7 3086 	ldrh.w	r3, [r7, #134]	@ 0x86
34020b54:	eeed 3a10 	vmsr	<impl def 0xd>, r3
34020b58:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34020b5c:	ee37 1f05 	cdp	15, 3, cr1, cr7, cr5, {0}
34020b60:	eefd 3a10 	vmrs	r3, <impl def 0xd>
34020b64:	b29b      	uxth	r3, r3
    // Compare according to p to create p0
    mve_pred16_t p0 = vcmpgtq_m_f32(f32x4_val, f32x4_max_val, p);
34020b66:	f8a7 3106 	strh.w	r3, [r7, #262]	@ 0x106
34020b6a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b6e:	3bb0      	subs	r3, #176	@ 0xb0
34020b70:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020b74:	3a68      	subs	r2, #104	@ 0x68
34020b76:	ed92 7f00 	ldc	15, cr7, [r2]
34020b7a:	ed83 7f00 	stc	15, cr7, [r3]
34020b7e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b82:	3bc0      	subs	r3, #192	@ 0xc0
34020b84:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020b88:	3a10      	subs	r2, #16
34020b8a:	ed92 7f00 	ldc	15, cr7, [r2]
34020b8e:	ed83 7f00 	stc	15, cr7, [r3]
34020b92:	f8b7 3106 	ldrh.w	r3, [r7, #262]	@ 0x106
34020b96:	f8a7 30ae 	strh.w	r3, [r7, #174]	@ 0xae
  return __builtin_mve_vpselq_fv4sf (__a, __b, __p);
34020b9a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020b9e:	3bb0      	subs	r3, #176	@ 0xb0
34020ba0:	ed93 7f00 	ldc	15, cr7, [r3]
34020ba4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020ba8:	3bc0      	subs	r3, #192	@ 0xc0
34020baa:	ed93 5f00 	ldc	15, cr5, [r3]
34020bae:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	@ 0xae
34020bb2:	eeed 3a10 	vmsr	<impl def 0xd>, r3
34020bb6:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}

    // according to p0: update with s8x16_val or keep s8x16_blk_minmax_val
    f32x4_max_val = vpselq_f32(f32x4_val, f32x4_max_val, p0);
34020bba:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020bbe:	3b10      	subs	r3, #16
34020bc0:	ed83 7f00 	stc	15, cr7, [r3]
34020bc4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020bc8:	3b88      	subs	r3, #136	@ 0x88
34020bca:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020bce:	3a30      	subs	r2, #48	@ 0x30
34020bd0:	ed92 7f00 	ldc	15, cr7, [r2]
34020bd4:	ed83 7f00 	stc	15, cr7, [r3]
34020bd8:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020bdc:	3b98      	subs	r3, #152	@ 0x98
34020bde:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020be2:	3a20      	subs	r2, #32
34020be4:	ed92 7f00 	ldc	15, cr7, [r2]
34020be8:	ed83 7f00 	stc	15, cr7, [r3]
34020bec:	f8b7 3106 	ldrh.w	r3, [r7, #262]	@ 0x106
34020bf0:	f8a7 30d6 	strh.w	r3, [r7, #214]	@ 0xd6
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34020bf4:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020bf8:	3b88      	subs	r3, #136	@ 0x88
34020bfa:	ed93 7f00 	ldc	15, cr7, [r3]
34020bfe:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c02:	3b98      	subs	r3, #152	@ 0x98
34020c04:	ed93 5f00 	ldc	15, cr5, [r3]
34020c08:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	@ 0xd6
34020c0c:	eeed 3a10 	vmsr	<impl def 0xd>, r3
34020c10:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
    /* according to p0: store per-lane extrema indexes*/
    u32x4_max_idx = vpselq_u32(u32x4_idx, u32x4_max_idx, p0);
34020c14:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c18:	3b20      	subs	r3, #32
34020c1a:	ed83 7f00 	stc	15, cr7, [r3]
    u32x4_idx+=4;
34020c1e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c22:	3b30      	subs	r3, #48	@ 0x30
34020c24:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020c28:	3a30      	subs	r2, #48	@ 0x30
34020c2a:	ed92 5f00 	ldc	15, cr5, [r2]
34020c2e:	ef80 6054 	vmov.i32	q3, #4	@ 0x00000004
34020c32:	ef24 6846 	vadd.i32	q3, q2, q3
34020c36:	ed83 7f00 	stc	15, cr7, [r3]
    iter-=4;
34020c3a:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
34020c3e:	3b04      	subs	r3, #4
34020c40:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
  while(iter > 0)
34020c44:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
34020c48:	2b00      	cmp	r3, #0
34020c4a:	f73f af38 	bgt.w	34020abe <vision_models_maxi_if32ou32+0x98>
34020c4e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c52:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
34020c56:	f46f 0200 	mvn.w	r2, #8388608	@ 0x800000
34020c5a:	601a      	str	r2, [r3, #0]
34020c5c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c60:	f5a3 73b0 	sub.w	r3, r3, #352	@ 0x160
34020c64:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020c68:	3a10      	subs	r2, #16
34020c6a:	ed92 7f00 	ldc	15, cr7, [r2]
34020c6e:	ed83 7f00 	stc	15, cr7, [r3]
  return __builtin_mve_vmaxnmvq_fv4sf (__a, __b);
34020c72:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c76:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
34020c7a:	681b      	ldr	r3, [r3, #0]
34020c7c:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020c80:	f5a2 72b0 	sub.w	r2, r2, #352	@ 0x160
34020c84:	ed92 7f00 	ldc	15, cr7, [r2]
34020c88:	eeee 3f06 	cdp	15, 14, cr3, cr14, cr6, {0}
34020c8c:	461a      	mov	r2, r3

  }
  /*
   * Get max value across the vector
   */
  *maxim = vmaxnmvq_f32(F32_MIN, f32x4_max_val);
34020c8e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c92:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
34020c96:	681b      	ldr	r3, [r3, #0]
34020c98:	601a      	str	r2, [r3, #0]
  /*
   * set index for lower values to max possible index
   */
  mve_pred16_t p0 = vcmpgeq_n_f32(f32x4_max_val, *maxim);
34020c9a:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020c9e:	f5a3 73b6 	sub.w	r3, r3, #364	@ 0x16c
34020ca2:	681b      	ldr	r3, [r3, #0]
34020ca4:	681a      	ldr	r2, [r3, #0]
34020ca6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020caa:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
34020cae:	f507 71b8 	add.w	r1, r7, #368	@ 0x170
34020cb2:	3910      	subs	r1, #16
34020cb4:	ed91 7f00 	ldc	15, cr7, [r1]
34020cb8:	ed83 7f00 	stc	15, cr7, [r3]
34020cbc:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020cc0:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
34020cc4:	601a      	str	r2, [r3, #0]
  return __builtin_mve_vcmpgeq_n_fv4sf (__a, __b);
34020cc6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020cca:	f5a3 73a4 	sub.w	r3, r3, #328	@ 0x148
34020cce:	ed93 7f00 	ldc	15, cr7, [r3]
34020cd2:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020cd6:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
34020cda:	681b      	ldr	r3, [r3, #0]
34020cdc:	ee37 1f43 	cdp	15, 3, cr1, cr7, cr3, {2}
34020ce0:	eefd 3a10 	vmrs	r3, <impl def 0xd>
34020ce4:	b29b      	uxth	r3, r3
34020ce6:	f8a7 3136 	strh.w	r3, [r7, #310]	@ 0x136
34020cea:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020cee:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
34020cf2:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020cf6:	f5a2 72b4 	sub.w	r2, r2, #360	@ 0x168
34020cfa:	6812      	ldr	r2, [r2, #0]
34020cfc:	601a      	str	r2, [r3, #0]
  return __builtin_mve_vdupq_n_uv4si (__a);
34020cfe:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d02:	f5a3 739c 	sub.w	r3, r3, #312	@ 0x138
34020d06:	681b      	ldr	r3, [r3, #0]
34020d08:	eea6 3b10 	vdup.32	q3, r3
34020d0c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d10:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
34020d14:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020d18:	3a20      	subs	r2, #32
34020d1a:	ed92 5f00 	ldc	15, cr5, [r2]
34020d1e:	ed83 5f00 	stc	15, cr5, [r3]
34020d22:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d26:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34020d2a:	ed83 7f00 	stc	15, cr7, [r3]
34020d2e:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d32:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
34020d36:	f8b7 2136 	ldrh.w	r2, [r7, #310]	@ 0x136
34020d3a:	801a      	strh	r2, [r3, #0]
  return __builtin_mve_vpselq_uv4si (__a, __b, __p);
34020d3c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d40:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
34020d44:	ed93 7f00 	ldc	15, cr7, [r3]
34020d48:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d4c:	f5a3 7398 	sub.w	r3, r3, #304	@ 0x130
34020d50:	ed93 5f00 	ldc	15, cr5, [r3]
34020d54:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d58:	f5a3 7399 	sub.w	r3, r3, #306	@ 0x132
34020d5c:	881b      	ldrh	r3, [r3, #0]
34020d5e:	eeed 3a10 	vmsr	<impl def 0xd>, r3
34020d62:	fe37 6f05 	cdp2	15, 3, cr6, cr7, cr5, {0}
  uint32x4_t indexVec = vpselq_u32(u32x4_max_idx, vdupq_n_u32(len_arr), p0);
34020d66:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d6a:	3b50      	subs	r3, #80	@ 0x50
34020d6c:	ed83 7f00 	stc	15, cr7, [r3]
34020d70:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d74:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
34020d78:	681b      	ldr	r3, [r3, #0]
34020d7a:	677b      	str	r3, [r7, #116]	@ 0x74
34020d7c:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020d80:	f5a3 7388 	sub.w	r3, r3, #272	@ 0x110
34020d84:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020d88:	3a50      	subs	r2, #80	@ 0x50
34020d8a:	ed92 7f00 	ldc	15, cr7, [r2]
34020d8e:	ed83 7f00 	stc	15, cr7, [r3]
  return __builtin_mve_vminvq_uv4si (__a, __b);
34020d92:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34020d94:	f507 72b8 	add.w	r2, r7, #368	@ 0x170
34020d98:	f5a2 7288 	sub.w	r2, r2, #272	@ 0x110
34020d9c:	ed92 7f00 	ldc	15, cr7, [r2]
34020da0:	feea 3f86 	cdp2	15, 14, cr3, cr10, cr6, {4}
34020da4:	461a      	mov	r2, r3
  /*
   * Get min index which is thus for a max value
   */
  *index = (int32_t)vminvq_u32(len_arr, indexVec);
34020da6:	f507 73b8 	add.w	r3, r7, #368	@ 0x170
34020daa:	f5a3 73b8 	sub.w	r3, r3, #368	@ 0x170
34020dae:	681b      	ldr	r3, [r3, #0]
34020db0:	601a      	str	r2, [r3, #0]

}
34020db2:	bf00      	nop
34020db4:	f507 77b8 	add.w	r7, r7, #368	@ 0x170
34020db8:	46bd      	mov	sp, r7
34020dba:	bc90      	pop	{r4, r7}
34020dbc:	4770      	bx	lr

34020dbe <vision_models_sigmoid_f>:
    }
  }
}

float32_t vision_models_sigmoid_f(float32_t x)
{
34020dbe:	b580      	push	{r7, lr}
34020dc0:	b082      	sub	sp, #8
34020dc2:	af00      	add	r7, sp, #0
34020dc4:	ed87 0a01 	vstr	s0, [r7, #4]
  return (1.0f / (1.0f + expf(-x)));
34020dc8:	edd7 7a01 	vldr	s15, [r7, #4]
34020dcc:	eef1 7a67 	vneg.f32	s15, s15
34020dd0:	eeb0 0a67 	vmov.f32	s0, s15
34020dd4:	f008 fed4 	bl	34029b80 <expf>
34020dd8:	eef0 7a40 	vmov.f32	s15, s0
34020ddc:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
34020de0:	ee77 7a87 	vadd.f32	s15, s15, s14
34020de4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
34020de8:	eec7 6a27 	vdiv.f32	s13, s14, s15
34020dec:	eef0 7a66 	vmov.f32	s15, s13
}
34020df0:	eeb0 0a67 	vmov.f32	s0, s15
34020df4:	3708      	adds	r7, #8
34020df6:	46bd      	mov	sp, r7
34020df8:	bd80      	pop	{r7, pc}

34020dfa <vision_models_softmax_f>:


void vision_models_softmax_f(float32_t *input_x, float32_t *output_x, int32_t len_x, float32_t *tmp_x)
{
34020dfa:	b590      	push	{r4, r7, lr}
34020dfc:	b089      	sub	sp, #36	@ 0x24
34020dfe:	af00      	add	r7, sp, #0
34020e00:	60f8      	str	r0, [r7, #12]
34020e02:	60b9      	str	r1, [r7, #8]
34020e04:	607a      	str	r2, [r7, #4]
34020e06:	603b      	str	r3, [r7, #0]
  float32_t sum = 0;
34020e08:	f04f 0300 	mov.w	r3, #0
34020e0c:	61fb      	str	r3, [r7, #28]

  for (int32_t i = 0; i < len_x; ++i)
34020e0e:	2300      	movs	r3, #0
34020e10:	61bb      	str	r3, [r7, #24]
34020e12:	e020      	b.n	34020e56 <vision_models_softmax_f+0x5c>
  {
    tmp_x[i] = expf(input_x[i]);
34020e14:	69bb      	ldr	r3, [r7, #24]
34020e16:	009b      	lsls	r3, r3, #2
34020e18:	68fa      	ldr	r2, [r7, #12]
34020e1a:	4413      	add	r3, r2
34020e1c:	edd3 7a00 	vldr	s15, [r3]
34020e20:	69bb      	ldr	r3, [r7, #24]
34020e22:	009b      	lsls	r3, r3, #2
34020e24:	683a      	ldr	r2, [r7, #0]
34020e26:	18d4      	adds	r4, r2, r3
34020e28:	eeb0 0a67 	vmov.f32	s0, s15
34020e2c:	f008 fea8 	bl	34029b80 <expf>
34020e30:	eef0 7a40 	vmov.f32	s15, s0
34020e34:	edc4 7a00 	vstr	s15, [r4]
    sum = sum + tmp_x[i];
34020e38:	69bb      	ldr	r3, [r7, #24]
34020e3a:	009b      	lsls	r3, r3, #2
34020e3c:	683a      	ldr	r2, [r7, #0]
34020e3e:	4413      	add	r3, r2
34020e40:	edd3 7a00 	vldr	s15, [r3]
34020e44:	ed97 7a07 	vldr	s14, [r7, #28]
34020e48:	ee77 7a27 	vadd.f32	s15, s14, s15
34020e4c:	edc7 7a07 	vstr	s15, [r7, #28]
  for (int32_t i = 0; i < len_x; ++i)
34020e50:	69bb      	ldr	r3, [r7, #24]
34020e52:	3301      	adds	r3, #1
34020e54:	61bb      	str	r3, [r7, #24]
34020e56:	69ba      	ldr	r2, [r7, #24]
34020e58:	687b      	ldr	r3, [r7, #4]
34020e5a:	429a      	cmp	r2, r3
34020e5c:	dbda      	blt.n	34020e14 <vision_models_softmax_f+0x1a>
  }
  sum = 1.0f / sum;
34020e5e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
34020e62:	ed97 7a07 	vldr	s14, [r7, #28]
34020e66:	eec6 7a87 	vdiv.f32	s15, s13, s14
34020e6a:	edc7 7a07 	vstr	s15, [r7, #28]
  for (int32_t i = 0; i < len_x; ++i)
34020e6e:	2300      	movs	r3, #0
34020e70:	617b      	str	r3, [r7, #20]
34020e72:	e012      	b.n	34020e9a <vision_models_softmax_f+0xa0>
  {
    tmp_x[i] *= sum;
34020e74:	697b      	ldr	r3, [r7, #20]
34020e76:	009b      	lsls	r3, r3, #2
34020e78:	683a      	ldr	r2, [r7, #0]
34020e7a:	4413      	add	r3, r2
34020e7c:	ed93 7a00 	vldr	s14, [r3]
34020e80:	697b      	ldr	r3, [r7, #20]
34020e82:	009b      	lsls	r3, r3, #2
34020e84:	683a      	ldr	r2, [r7, #0]
34020e86:	4413      	add	r3, r2
34020e88:	edd7 7a07 	vldr	s15, [r7, #28]
34020e8c:	ee67 7a27 	vmul.f32	s15, s14, s15
34020e90:	edc3 7a00 	vstr	s15, [r3]
  for (int32_t i = 0; i < len_x; ++i)
34020e94:	697b      	ldr	r3, [r7, #20]
34020e96:	3301      	adds	r3, #1
34020e98:	617b      	str	r3, [r7, #20]
34020e9a:	697a      	ldr	r2, [r7, #20]
34020e9c:	687b      	ldr	r3, [r7, #4]
34020e9e:	429a      	cmp	r2, r3
34020ea0:	dbe8      	blt.n	34020e74 <vision_models_softmax_f+0x7a>
  }
  memcpy(output_x, tmp_x, len_x * sizeof(float32_t));
34020ea2:	687b      	ldr	r3, [r7, #4]
34020ea4:	009b      	lsls	r3, r3, #2
34020ea6:	461a      	mov	r2, r3
34020ea8:	6839      	ldr	r1, [r7, #0]
34020eaa:	68b8      	ldr	r0, [r7, #8]
34020eac:	f006 fc01 	bl	340276b2 <memcpy>
}
34020eb0:	bf00      	nop
34020eb2:	3724      	adds	r7, #36	@ 0x24
34020eb4:	46bd      	mov	sp, r7
34020eb6:	bd90      	pop	{r4, r7, pc}

34020eb8 <overlap>:


//***************iou ********
//inline
float32_t overlap(float32_t x1, float32_t w1, float32_t x2, float32_t w2)
{
34020eb8:	b480      	push	{r7}
34020eba:	b08b      	sub	sp, #44	@ 0x2c
34020ebc:	af00      	add	r7, sp, #0
34020ebe:	ed87 0a03 	vstr	s0, [r7, #12]
34020ec2:	edc7 0a02 	vstr	s1, [r7, #8]
34020ec6:	ed87 1a01 	vstr	s2, [r7, #4]
34020eca:	edc7 1a00 	vstr	s3, [r7]
  float32_t l1 = x1 - w1 / 2;
34020ece:	ed97 7a02 	vldr	s14, [r7, #8]
34020ed2:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
34020ed6:	eec7 7a26 	vdiv.f32	s15, s14, s13
34020eda:	ed97 7a03 	vldr	s14, [r7, #12]
34020ede:	ee77 7a67 	vsub.f32	s15, s14, s15
34020ee2:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
  float32_t l2 = x2 - w2 / 2;
34020ee6:	ed97 7a00 	vldr	s14, [r7]
34020eea:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
34020eee:	eec7 7a26 	vdiv.f32	s15, s14, s13
34020ef2:	ed97 7a01 	vldr	s14, [r7, #4]
34020ef6:	ee77 7a67 	vsub.f32	s15, s14, s15
34020efa:	edc7 7a08 	vstr	s15, [r7, #32]
  float32_t left = l1 > l2 ? l1 : l2;
34020efe:	ed97 7a09 	vldr	s14, [r7, #36]	@ 0x24
34020f02:	edd7 7a08 	vldr	s15, [r7, #32]
34020f06:	eeb4 7ae7 	vcmpe.f32	s14, s15
34020f0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020f0e:	dd01      	ble.n	34020f14 <overlap+0x5c>
34020f10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34020f12:	e000      	b.n	34020f16 <overlap+0x5e>
34020f14:	6a3b      	ldr	r3, [r7, #32]
34020f16:	61fb      	str	r3, [r7, #28]
  float32_t r1 = x1 + w1 / 2;
34020f18:	ed97 7a02 	vldr	s14, [r7, #8]
34020f1c:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
34020f20:	eec7 7a26 	vdiv.f32	s15, s14, s13
34020f24:	ed97 7a03 	vldr	s14, [r7, #12]
34020f28:	ee77 7a27 	vadd.f32	s15, s14, s15
34020f2c:	edc7 7a06 	vstr	s15, [r7, #24]
  float32_t r2 = x2 + w2 / 2;
34020f30:	ed97 7a00 	vldr	s14, [r7]
34020f34:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
34020f38:	eec7 7a26 	vdiv.f32	s15, s14, s13
34020f3c:	ed97 7a01 	vldr	s14, [r7, #4]
34020f40:	ee77 7a27 	vadd.f32	s15, s14, s15
34020f44:	edc7 7a05 	vstr	s15, [r7, #20]
  float32_t right = r1 < r2 ? r1 : r2;
34020f48:	ed97 7a06 	vldr	s14, [r7, #24]
34020f4c:	edd7 7a05 	vldr	s15, [r7, #20]
34020f50:	eeb4 7ae7 	vcmpe.f32	s14, s15
34020f54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020f58:	d501      	bpl.n	34020f5e <overlap+0xa6>
34020f5a:	69bb      	ldr	r3, [r7, #24]
34020f5c:	e000      	b.n	34020f60 <overlap+0xa8>
34020f5e:	697b      	ldr	r3, [r7, #20]
34020f60:	613b      	str	r3, [r7, #16]
  return (right - left);
34020f62:	ed97 7a04 	vldr	s14, [r7, #16]
34020f66:	edd7 7a07 	vldr	s15, [r7, #28]
34020f6a:	ee77 7a67 	vsub.f32	s15, s14, s15
}
34020f6e:	eeb0 0a67 	vmov.f32	s0, s15
34020f72:	372c      	adds	r7, #44	@ 0x2c
34020f74:	46bd      	mov	sp, r7
34020f76:	f85d 7b04 	ldr.w	r7, [sp], #4
34020f7a:	4770      	bx	lr

34020f7c <box_intersection>:

//inline
float32_t box_intersection(float32_t *a, float32_t *b)
{
34020f7c:	b580      	push	{r7, lr}
34020f7e:	b086      	sub	sp, #24
34020f80:	af00      	add	r7, sp, #0
34020f82:	6078      	str	r0, [r7, #4]
34020f84:	6039      	str	r1, [r7, #0]
  float32_t w = overlap(a[0], a[2], b[0], b[2]);
34020f86:	687b      	ldr	r3, [r7, #4]
34020f88:	edd3 7a00 	vldr	s15, [r3]
34020f8c:	687b      	ldr	r3, [r7, #4]
34020f8e:	3308      	adds	r3, #8
34020f90:	ed93 7a00 	vldr	s14, [r3]
34020f94:	683b      	ldr	r3, [r7, #0]
34020f96:	edd3 6a00 	vldr	s13, [r3]
34020f9a:	683b      	ldr	r3, [r7, #0]
34020f9c:	3308      	adds	r3, #8
34020f9e:	ed93 6a00 	vldr	s12, [r3]
34020fa2:	eef0 1a46 	vmov.f32	s3, s12
34020fa6:	eeb0 1a66 	vmov.f32	s2, s13
34020faa:	eef0 0a47 	vmov.f32	s1, s14
34020fae:	eeb0 0a67 	vmov.f32	s0, s15
34020fb2:	f7ff ff81 	bl	34020eb8 <overlap>
34020fb6:	ed87 0a05 	vstr	s0, [r7, #20]
  float32_t h = overlap(a[1], a[3], b[1], b[3]);
34020fba:	687b      	ldr	r3, [r7, #4]
34020fbc:	3304      	adds	r3, #4
34020fbe:	edd3 7a00 	vldr	s15, [r3]
34020fc2:	687b      	ldr	r3, [r7, #4]
34020fc4:	330c      	adds	r3, #12
34020fc6:	ed93 7a00 	vldr	s14, [r3]
34020fca:	683b      	ldr	r3, [r7, #0]
34020fcc:	3304      	adds	r3, #4
34020fce:	edd3 6a00 	vldr	s13, [r3]
34020fd2:	683b      	ldr	r3, [r7, #0]
34020fd4:	330c      	adds	r3, #12
34020fd6:	ed93 6a00 	vldr	s12, [r3]
34020fda:	eef0 1a46 	vmov.f32	s3, s12
34020fde:	eeb0 1a66 	vmov.f32	s2, s13
34020fe2:	eef0 0a47 	vmov.f32	s1, s14
34020fe6:	eeb0 0a67 	vmov.f32	s0, s15
34020fea:	f7ff ff65 	bl	34020eb8 <overlap>
34020fee:	ed87 0a04 	vstr	s0, [r7, #16]
  if (w < 0 || h < 0) return 0;
34020ff2:	edd7 7a05 	vldr	s15, [r7, #20]
34020ff6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34020ffa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34020ffe:	d406      	bmi.n	3402100e <box_intersection+0x92>
34021000:	edd7 7a04 	vldr	s15, [r7, #16]
34021004:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34021008:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402100c:	d502      	bpl.n	34021014 <box_intersection+0x98>
3402100e:	f04f 0300 	mov.w	r3, #0
34021012:	e008      	b.n	34021026 <box_intersection+0xaa>
  float32_t area = w * h;
34021014:	ed97 7a05 	vldr	s14, [r7, #20]
34021018:	edd7 7a04 	vldr	s15, [r7, #16]
3402101c:	ee67 7a27 	vmul.f32	s15, s14, s15
34021020:	edc7 7a03 	vstr	s15, [r7, #12]
  return (area);
34021024:	68fb      	ldr	r3, [r7, #12]
}
34021026:	ee07 3a90 	vmov	s15, r3
3402102a:	eeb0 0a67 	vmov.f32	s0, s15
3402102e:	3718      	adds	r7, #24
34021030:	46bd      	mov	sp, r7
34021032:	bd80      	pop	{r7, pc}

34021034 <box_union>:

//inline
float32_t box_union(float32_t *a, float32_t *b)
{
34021034:	b580      	push	{r7, lr}
34021036:	b084      	sub	sp, #16
34021038:	af00      	add	r7, sp, #0
3402103a:	6078      	str	r0, [r7, #4]
3402103c:	6039      	str	r1, [r7, #0]
  float32_t i = box_intersection(a, b);
3402103e:	6839      	ldr	r1, [r7, #0]
34021040:	6878      	ldr	r0, [r7, #4]
34021042:	f7ff ff9b 	bl	34020f7c <box_intersection>
34021046:	ed87 0a03 	vstr	s0, [r7, #12]
  float32_t u = a[2] * a[3] + b[2] * b[3] - i;
3402104a:	687b      	ldr	r3, [r7, #4]
3402104c:	3308      	adds	r3, #8
3402104e:	ed93 7a00 	vldr	s14, [r3]
34021052:	687b      	ldr	r3, [r7, #4]
34021054:	330c      	adds	r3, #12
34021056:	edd3 7a00 	vldr	s15, [r3]
3402105a:	ee27 7a27 	vmul.f32	s14, s14, s15
3402105e:	683b      	ldr	r3, [r7, #0]
34021060:	3308      	adds	r3, #8
34021062:	edd3 6a00 	vldr	s13, [r3]
34021066:	683b      	ldr	r3, [r7, #0]
34021068:	330c      	adds	r3, #12
3402106a:	edd3 7a00 	vldr	s15, [r3]
3402106e:	ee66 7aa7 	vmul.f32	s15, s13, s15
34021072:	ee37 7a27 	vadd.f32	s14, s14, s15
34021076:	edd7 7a03 	vldr	s15, [r7, #12]
3402107a:	ee77 7a67 	vsub.f32	s15, s14, s15
3402107e:	edc7 7a02 	vstr	s15, [r7, #8]
  return (u);
34021082:	68bb      	ldr	r3, [r7, #8]
34021084:	ee07 3a90 	vmov	s15, r3
}
34021088:	eeb0 0a67 	vmov.f32	s0, s15
3402108c:	3710      	adds	r7, #16
3402108e:	46bd      	mov	sp, r7
34021090:	bd80      	pop	{r7, pc}
	...

34021094 <vision_models_box_iou>:


float32_t vision_models_box_iou(float32_t *a, float32_t *b)
{
34021094:	b580      	push	{r7, lr}
34021096:	b084      	sub	sp, #16
34021098:	af00      	add	r7, sp, #0
3402109a:	6078      	str	r0, [r7, #4]
3402109c:	6039      	str	r1, [r7, #0]

  float32_t I = box_intersection(a, b);
3402109e:	6839      	ldr	r1, [r7, #0]
340210a0:	6878      	ldr	r0, [r7, #4]
340210a2:	f7ff ff6b 	bl	34020f7c <box_intersection>
340210a6:	ed87 0a03 	vstr	s0, [r7, #12]
  float32_t U = box_union(a, b);
340210aa:	6839      	ldr	r1, [r7, #0]
340210ac:	6878      	ldr	r0, [r7, #4]
340210ae:	f7ff ffc1 	bl	34021034 <box_union>
340210b2:	ed87 0a02 	vstr	s0, [r7, #8]
 if (I == 0 || U == 0)
340210b6:	edd7 7a03 	vldr	s15, [r7, #12]
340210ba:	eef5 7a40 	vcmp.f32	s15, #0.0
340210be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340210c2:	d006      	beq.n	340210d2 <vision_models_box_iou+0x3e>
340210c4:	edd7 7a02 	vldr	s15, [r7, #8]
340210c8:	eef5 7a40 	vcmp.f32	s15, #0.0
340210cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340210d0:	d102      	bne.n	340210d8 <vision_models_box_iou+0x44>
  {
    return 0;
340210d2:	eddf 6a08 	vldr	s13, [pc, #32]	@ 340210f4 <vision_models_box_iou+0x60>
340210d6:	e005      	b.n	340210e4 <vision_models_box_iou+0x50>
  }
  return (I / U);
340210d8:	ed97 7a03 	vldr	s14, [r7, #12]
340210dc:	edd7 7a02 	vldr	s15, [r7, #8]
340210e0:	eec7 6a27 	vdiv.f32	s13, s14, s15
}
340210e4:	eef0 7a66 	vmov.f32	s15, s13
340210e8:	eeb0 0a67 	vmov.f32	s0, s15
340210ec:	3710      	adds	r7, #16
340210ee:	46bd      	mov	sp, r7
340210f0:	bd80      	pop	{r7, pc}
340210f2:	bf00      	nop
340210f4:	00000000 	.word	0x00000000

340210f8 <_tx_initialize_high_level>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID    _tx_initialize_high_level(VOID)
{
340210f8:	b580      	push	{r7, lr}
340210fa:	af00      	add	r7, sp, #0

    /* Initialize the event log, if enabled.  */
    TX_EL_INITIALIZE

    /* Call the thread control initialization function.  */
    _tx_thread_initialize();
340210fc:	f001 faba 	bl	34022674 <_tx_thread_initialize>

#ifndef TX_NO_TIMER

    /* Call the timer control initialization function.  */
    _tx_timer_initialize();
34021100:	f001 ff96 	bl	34023030 <_tx_timer_initialize>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Call the semaphore initialization function.  */
    _tx_semaphore_initialize();
34021104:	4b12      	ldr	r3, [pc, #72]	@ (34021150 <_tx_initialize_high_level+0x58>)
34021106:	2200      	movs	r2, #0
34021108:	601a      	str	r2, [r3, #0]
3402110a:	4b12      	ldr	r3, [pc, #72]	@ (34021154 <_tx_initialize_high_level+0x5c>)
3402110c:	2200      	movs	r2, #0
3402110e:	601a      	str	r2, [r3, #0]

    /* Call the queue initialization function.  */
    _tx_queue_initialize();
34021110:	4b11      	ldr	r3, [pc, #68]	@ (34021158 <_tx_initialize_high_level+0x60>)
34021112:	2200      	movs	r2, #0
34021114:	601a      	str	r2, [r3, #0]
34021116:	4b11      	ldr	r3, [pc, #68]	@ (3402115c <_tx_initialize_high_level+0x64>)
34021118:	2200      	movs	r2, #0
3402111a:	601a      	str	r2, [r3, #0]

    /* Call the event flag initialization function.  */
    _tx_event_flags_initialize();
3402111c:	4b10      	ldr	r3, [pc, #64]	@ (34021160 <_tx_initialize_high_level+0x68>)
3402111e:	2200      	movs	r2, #0
34021120:	601a      	str	r2, [r3, #0]
34021122:	4b10      	ldr	r3, [pc, #64]	@ (34021164 <_tx_initialize_high_level+0x6c>)
34021124:	2200      	movs	r2, #0
34021126:	601a      	str	r2, [r3, #0]

    /* Call the block pool initialization function.  */
    _tx_block_pool_initialize();
34021128:	4b0f      	ldr	r3, [pc, #60]	@ (34021168 <_tx_initialize_high_level+0x70>)
3402112a:	2200      	movs	r2, #0
3402112c:	601a      	str	r2, [r3, #0]
3402112e:	4b0f      	ldr	r3, [pc, #60]	@ (3402116c <_tx_initialize_high_level+0x74>)
34021130:	2200      	movs	r2, #0
34021132:	601a      	str	r2, [r3, #0]

    /* Call the byte pool initialization function.  */
    _tx_byte_pool_initialize();
34021134:	4b0e      	ldr	r3, [pc, #56]	@ (34021170 <_tx_initialize_high_level+0x78>)
34021136:	2200      	movs	r2, #0
34021138:	601a      	str	r2, [r3, #0]
3402113a:	4b0e      	ldr	r3, [pc, #56]	@ (34021174 <_tx_initialize_high_level+0x7c>)
3402113c:	2200      	movs	r2, #0
3402113e:	601a      	str	r2, [r3, #0]

    /* Call the mutex initialization function.  */
    _tx_mutex_initialize();
34021140:	4b0d      	ldr	r3, [pc, #52]	@ (34021178 <_tx_initialize_high_level+0x80>)
34021142:	2200      	movs	r2, #0
34021144:	601a      	str	r2, [r3, #0]
34021146:	4b0d      	ldr	r3, [pc, #52]	@ (3402117c <_tx_initialize_high_level+0x84>)
34021148:	2200      	movs	r2, #0
3402114a:	601a      	str	r2, [r3, #0]
#endif
}
3402114c:	bf00      	nop
3402114e:	bd80      	pop	{r7, pc}
34021150:	3404aab8 	.word	0x3404aab8
34021154:	3404aabc 	.word	0x3404aabc
34021158:	3404aac0 	.word	0x3404aac0
3402115c:	3404aac4 	.word	0x3404aac4
34021160:	3404aac8 	.word	0x3404aac8
34021164:	3404aacc 	.word	0x3404aacc
34021168:	3404aad8 	.word	0x3404aad8
3402116c:	3404aadc 	.word	0x3404aadc
34021170:	3404aae0 	.word	0x3404aae0
34021174:	3404aae4 	.word	0x3404aae4
34021178:	3404aad0 	.word	0x3404aad0
3402117c:	3404aad4 	.word	0x3404aad4

34021180 <_tx_initialize_kernel_enter>:
/*                                            initialization,             */
/*                                            resulting in version 6.3.0  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_enter(VOID)
{
34021180:	b580      	push	{r7, lr}
34021182:	af00      	add	r7, sp, #0

    /* Determine if the compiler has pre-initialized ThreadX.  */
    if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
34021184:	4b11      	ldr	r3, [pc, #68]	@ (340211cc <_tx_initialize_kernel_enter+0x4c>)
34021186:	681b      	ldr	r3, [r3, #0]
34021188:	f113 3f0f 	cmn.w	r3, #252645135	@ 0xf0f0f0f
3402118c:	d00c      	beq.n	340211a8 <_tx_initialize_kernel_enter+0x28>
        /* No, the initialization still needs to take place.  */

        /* Ensure that the system state variable is set to indicate
           initialization is in progress.  Note that this variable is
           later used to represent interrupt nesting.  */
        _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
3402118e:	4b0f      	ldr	r3, [pc, #60]	@ (340211cc <_tx_initialize_kernel_enter+0x4c>)
34021190:	f04f 32f0 	mov.w	r2, #4042322160	@ 0xf0f0f0f0
34021194:	601a      	str	r2, [r3, #0]
        /* Call any port specific preprocessing.  */
        TX_PORT_SPECIFIC_PRE_INITIALIZATION

        /* Invoke the low-level initialization to handle all processor specific
           initialization issues.  */
        _tx_initialize_low_level();
34021196:	f7df fafb 	bl	34000790 <_tx_initialize_low_level>

        /* Invoke the high-level initialization to exercise all of the
           ThreadX components and the application's initialization
           function.  */
        _tx_initialize_high_level();
3402119a:	f7ff ffad 	bl	340210f8 <_tx_initialize_high_level>

        /* Call any port specific post-processing.  */
        TX_PORT_SPECIFIC_POST_INITIALIZATION
3402119e:	4b0c      	ldr	r3, [pc, #48]	@ (340211d0 <_tx_initialize_kernel_enter+0x50>)
340211a0:	681b      	ldr	r3, [r3, #0]
340211a2:	3301      	adds	r3, #1
340211a4:	4a0a      	ldr	r2, [pc, #40]	@ (340211d0 <_tx_initialize_kernel_enter+0x50>)
340211a6:	6013      	str	r3, [r2, #0]
    TX_INITIALIZE_KERNEL_ENTER_EXTENSION

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
340211a8:	4b08      	ldr	r3, [pc, #32]	@ (340211cc <_tx_initialize_kernel_enter+0x4c>)
340211aa:	f04f 32f0 	mov.w	r2, #4042322160	@ 0xf0f0f0f0
340211ae:	601a      	str	r2, [r3, #0]
    /* Optional random number generator initialization.  */
    TX_INITIALIZE_RANDOM_GENERATOR_INITIALIZATION

    /* Call the application provided initialization function.  Pass the
       first available memory address to it.  */
    tx_application_define(_tx_initialize_unused_memory);
340211b0:	4b08      	ldr	r3, [pc, #32]	@ (340211d4 <_tx_initialize_kernel_enter+0x54>)
340211b2:	681b      	ldr	r3, [r3, #0]
340211b4:	4618      	mov	r0, r3
340211b6:	f7e2 ff13 	bl	34003fe0 <tx_application_define>

    /* Set the system state in preparation for entering the thread
       scheduler.  */
    _tx_thread_system_state =  TX_INITIALIZE_IS_FINISHED;
340211ba:	4b04      	ldr	r3, [pc, #16]	@ (340211cc <_tx_initialize_kernel_enter+0x4c>)
340211bc:	2200      	movs	r2, #0
340211be:	601a      	str	r2, [r3, #0]
    /* Call any port specific pre-scheduler processing.  */
    TX_PORT_SPECIFIC_PRE_SCHEDULER_INITIALIZATION

#if defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE)
    /* Initialize Execution Profile Kit.  */
    _tx_execution_initialize();
340211c0:	f002 fd06 	bl	34023bd0 <_tx_execution_initialize>
#endif

    /* Enter the scheduling loop to start executing threads!  */
    _tx_thread_schedule();
340211c4:	f7df fb28 	bl	34000818 <_tx_thread_schedule>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
340211c8:	bf00      	nop
340211ca:	bd80      	pop	{r7, pc}
340211cc:	3404148c 	.word	0x3404148c
340211d0:	3404ab8c 	.word	0x3404ab8c
340211d4:	3404aae8 	.word	0x3404aae8

340211d8 <_tx_initialize_kernel_setup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_initialize_kernel_setup(VOID)
{
340211d8:	b580      	push	{r7, lr}
340211da:	af00      	add	r7, sp, #0

    /* Ensure that the system state variable is set to indicate
       initialization is in progress.  Note that this variable is
       later used to represent interrupt nesting.  */
    _tx_thread_system_state =  TX_INITIALIZE_IN_PROGRESS;
340211dc:	4b08      	ldr	r3, [pc, #32]	@ (34021200 <_tx_initialize_kernel_setup+0x28>)
340211de:	f04f 32f0 	mov.w	r2, #4042322160	@ 0xf0f0f0f0
340211e2:	601a      	str	r2, [r3, #0]
    /* Call any port specific preprocessing.  */
    TX_PORT_SPECIFIC_PRE_INITIALIZATION

    /* Invoke the low-level initialization to handle all processor specific
       initialization issues.  */
    _tx_initialize_low_level();
340211e4:	f7df fad4 	bl	34000790 <_tx_initialize_low_level>

    /* Invoke the high-level initialization to exercise all of the
       ThreadX components and the application's initialization
       function.  */
    _tx_initialize_high_level();
340211e8:	f7ff ff86 	bl	340210f8 <_tx_initialize_high_level>

    /* Call any port specific post-processing.  */
    TX_PORT_SPECIFIC_POST_INITIALIZATION
340211ec:	4b05      	ldr	r3, [pc, #20]	@ (34021204 <_tx_initialize_kernel_setup+0x2c>)
340211ee:	681b      	ldr	r3, [r3, #0]
340211f0:	3301      	adds	r3, #1
340211f2:	4a04      	ldr	r2, [pc, #16]	@ (34021204 <_tx_initialize_kernel_setup+0x2c>)
340211f4:	6013      	str	r3, [r2, #0]

    /* Set the system state to indicate initialization is almost done.  */
    _tx_thread_system_state =  TX_INITIALIZE_ALMOST_DONE;
340211f6:	4b02      	ldr	r3, [pc, #8]	@ (34021200 <_tx_initialize_kernel_setup+0x28>)
340211f8:	4a03      	ldr	r2, [pc, #12]	@ (34021208 <_tx_initialize_kernel_setup+0x30>)
340211fa:	601a      	str	r2, [r3, #0]
}
340211fc:	bf00      	nop
340211fe:	bd80      	pop	{r7, pc}
34021200:	3404148c 	.word	0x3404148c
34021204:	3404ab8c 	.word	0x3404ab8c
34021208:	f0f0f0f1 	.word	0xf0f0f0f1

3402120c <_tx_mutex_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
3402120c:	b580      	push	{r7, lr}
3402120e:	b08e      	sub	sp, #56	@ 0x38
34021210:	af00      	add	r7, sp, #0
34021212:	6078      	str	r0, [r7, #4]
34021214:	6039      	str	r1, [r7, #0]
{
UINT posture;
#ifdef TX_PORT_USE_BASEPRI
    __asm__ volatile ("MRS  %0, BASEPRI ": "=r" (posture));
#else
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021216:	f3ef 8310 	mrs	r3, PRIMASK
3402121a:	623b      	str	r3, [r7, #32]
#endif
    return(posture);
3402121c:	6a3b      	ldr	r3, [r7, #32]

__attribute__( ( always_inline ) ) static inline UINT __disable_interrupts(void)
{
UINT int_posture;

    int_posture = __get_interrupt_posture();
3402121e:	61fb      	str	r3, [r7, #28]

#ifdef TX_PORT_USE_BASEPRI
    __set_basepri_value(TX_PORT_BASEPRI);
#else
    __asm__ volatile ("CPSID i" : : : "memory");
34021220:	b672      	cpsid	i
#endif
    return(int_posture);
34021222:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE
34021224:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
34021226:	687b      	ldr	r3, [r7, #4]
34021228:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
3402122a:	4a33      	ldr	r2, [pc, #204]	@ (340212f8 <_tx_mutex_cleanup+0xec>)
3402122c:	4293      	cmp	r3, r2
3402122e:	d158      	bne.n	340212e2 <_tx_mutex_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
34021230:	687b      	ldr	r3, [r7, #4]
34021232:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34021236:	683a      	ldr	r2, [r7, #0]
34021238:	429a      	cmp	r2, r3
3402123a:	d152      	bne.n	340212e2 <_tx_mutex_cleanup+0xd6>
        {

            /* Setup pointer to mutex control block.  */
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
3402123c:	687b      	ldr	r3, [r7, #4]
3402123e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
34021240:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for NULL mutex pointer.  */
            if (mutex_ptr != TX_NULL)
34021242:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021244:	2b00      	cmp	r3, #0
34021246:	d04c      	beq.n	340212e2 <_tx_mutex_cleanup+0xd6>
            {

                /* Determine if the mutex ID is valid.  */
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
34021248:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402124a:	681b      	ldr	r3, [r3, #0]
3402124c:	4a2b      	ldr	r2, [pc, #172]	@ (340212fc <_tx_mutex_cleanup+0xf0>)
3402124e:	4293      	cmp	r3, r2
34021250:	d147      	bne.n	340212e2 <_tx_mutex_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
34021252:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021254:	69db      	ldr	r3, [r3, #28]
34021256:	2b00      	cmp	r3, #0
34021258:	d043      	beq.n	340212e2 <_tx_mutex_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
3402125a:	687b      	ldr	r3, [r7, #4]
3402125c:	2200      	movs	r2, #0
3402125e:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspension count.  */
                        mutex_ptr -> tx_mutex_suspended_count--;
34021260:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021262:	69db      	ldr	r3, [r3, #28]
34021264:	1e5a      	subs	r2, r3, #1
34021266:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021268:	61da      	str	r2, [r3, #28]

                        /* Pickup the suspended count.  */
                        suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
3402126a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402126c:	69db      	ldr	r3, [r3, #28]
3402126e:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
34021270:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34021272:	2b00      	cmp	r3, #0
34021274:	d103      	bne.n	3402127e <_tx_mutex_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
34021276:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021278:	2200      	movs	r2, #0
3402127a:	619a      	str	r2, [r3, #24]
3402127c:	e013      	b.n	340212a6 <_tx_mutex_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
3402127e:	687b      	ldr	r3, [r7, #4]
34021280:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34021282:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34021284:	687b      	ldr	r3, [r7, #4]
34021286:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34021288:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
3402128a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3402128c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3402128e:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
34021290:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34021292:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34021294:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
34021296:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021298:	699b      	ldr	r3, [r3, #24]
3402129a:	687a      	ldr	r2, [r7, #4]
3402129c:	429a      	cmp	r2, r3
3402129e:	d102      	bne.n	340212a6 <_tx_mutex_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
340212a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340212a2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340212a4:	619a      	str	r2, [r3, #24]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
340212a6:	687b      	ldr	r3, [r7, #4]
340212a8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340212aa:	2b0d      	cmp	r3, #13
340212ac:	d119      	bne.n	340212e2 <_tx_mutex_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            mutex_ptr -> tx_mutex_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
340212ae:	687b      	ldr	r3, [r7, #4]
340212b0:	221d      	movs	r2, #29
340212b2:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
340212b6:	4b12      	ldr	r3, [pc, #72]	@ (34021300 <_tx_mutex_cleanup+0xf4>)
340212b8:	681b      	ldr	r3, [r3, #0]
340212ba:	3301      	adds	r3, #1
340212bc:	4a10      	ldr	r2, [pc, #64]	@ (34021300 <_tx_mutex_cleanup+0xf4>)
340212be:	6013      	str	r3, [r2, #0]
340212c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340212c2:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340212c4:	693b      	ldr	r3, [r7, #16]
340212c6:	f383 8810 	msr	PRIMASK, r3
}
340212ca:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
340212cc:	6878      	ldr	r0, [r7, #4]
340212ce:	f001 fb3d 	bl	3402294c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340212d2:	f3ef 8310 	mrs	r3, PRIMASK
340212d6:	61bb      	str	r3, [r7, #24]
    return(posture);
340212d8:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
340212da:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
340212dc:	b672      	cpsid	i
    return(int_posture);
340212de:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
340212e0:	637b      	str	r3, [r7, #52]	@ 0x34
340212e2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340212e4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340212e6:	68fb      	ldr	r3, [r7, #12]
340212e8:	f383 8810 	msr	PRIMASK, r3
}
340212ec:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
340212ee:	bf00      	nop
340212f0:	3738      	adds	r7, #56	@ 0x38
340212f2:	46bd      	mov	sp, r7
340212f4:	bd80      	pop	{r7, pc}
340212f6:	bf00      	nop
340212f8:	3402120d 	.word	0x3402120d
340212fc:	4d555445 	.word	0x4d555445
34021300:	3404ab8c 	.word	0x3404ab8c

34021304 <_tx_mutex_thread_release>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
34021304:	b580      	push	{r7, lr}
34021306:	b08a      	sub	sp, #40	@ 0x28
34021308:	af00      	add	r7, sp, #0
3402130a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402130c:	f3ef 8310 	mrs	r3, PRIMASK
34021310:	61fb      	str	r3, [r7, #28]
    return(posture);
34021312:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34021314:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34021316:	b672      	cpsid	i
    return(int_posture);
34021318:	69bb      	ldr	r3, [r7, #24]
UINT        status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
3402131a:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
3402131c:	4b1a      	ldr	r3, [pc, #104]	@ (34021388 <_tx_mutex_thread_release+0x84>)
3402131e:	681b      	ldr	r3, [r3, #0]
34021320:	3301      	adds	r3, #1
34021322:	4a19      	ldr	r2, [pc, #100]	@ (34021388 <_tx_mutex_thread_release+0x84>)
34021324:	6013      	str	r3, [r2, #0]
    /* Loop to look at all the mutexes.  */
    do
    {

        /* Pickup the mutex head pointer.  */
        mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
34021326:	687b      	ldr	r3, [r7, #4]
34021328:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
3402132c:	623b      	str	r3, [r7, #32]

        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
3402132e:	6a3b      	ldr	r3, [r7, #32]
34021330:	2b00      	cmp	r3, #0
34021332:	d017      	beq.n	34021364 <_tx_mutex_thread_release+0x60>
        {

            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
34021334:	6a3b      	ldr	r3, [r7, #32]
34021336:	2201      	movs	r2, #1
34021338:	609a      	str	r2, [r3, #8]
3402133a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402133c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402133e:	68fb      	ldr	r3, [r7, #12]
34021340:	f383 8810 	msr	PRIMASK, r3
}
34021344:	bf00      	nop
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
34021346:	6a38      	ldr	r0, [r7, #32]
34021348:	f000 fbaa 	bl	34021aa0 <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402134c:	f3ef 8310 	mrs	r3, PRIMASK
34021350:	617b      	str	r3, [r7, #20]
    return(posture);
34021352:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34021354:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34021356:	b672      	cpsid	i
    return(int_posture);
34021358:	693b      	ldr	r3, [r7, #16]
#endif

            /* Disable interrupts.  */
            TX_DISABLE
3402135a:	627b      	str	r3, [r7, #36]	@ 0x24

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
3402135c:	687b      	ldr	r3, [r7, #4]
3402135e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34021362:	623b      	str	r3, [r7, #32]
        }
    } while (mutex_ptr != TX_NULL);
34021364:	6a3b      	ldr	r3, [r7, #32]
34021366:	2b00      	cmp	r3, #0
34021368:	d1dd      	bne.n	34021326 <_tx_mutex_thread_release+0x22>

    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
3402136a:	4b07      	ldr	r3, [pc, #28]	@ (34021388 <_tx_mutex_thread_release+0x84>)
3402136c:	681b      	ldr	r3, [r3, #0]
3402136e:	3b01      	subs	r3, #1
34021370:	4a05      	ldr	r2, [pc, #20]	@ (34021388 <_tx_mutex_thread_release+0x84>)
34021372:	6013      	str	r3, [r2, #0]
34021374:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34021376:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021378:	68bb      	ldr	r3, [r7, #8]
3402137a:	f383 8810 	msr	PRIMASK, r3
}
3402137e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE
}
34021380:	bf00      	nop
34021382:	3728      	adds	r7, #40	@ 0x28
34021384:	46bd      	mov	sp, r7
34021386:	bd80      	pop	{r7, pc}
34021388:	3404ab8c 	.word	0x3404ab8c

3402138c <_tx_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
3402138c:	b580      	push	{r7, lr}
3402138e:	b08a      	sub	sp, #40	@ 0x28
34021390:	af00      	add	r7, sp, #0
34021392:	60f8      	str	r0, [r7, #12]
34021394:	60b9      	str	r1, [r7, #8]
34021396:	607a      	str	r2, [r7, #4]
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
34021398:	2234      	movs	r2, #52	@ 0x34
3402139a:	2100      	movs	r1, #0
3402139c:	68f8      	ldr	r0, [r7, #12]
3402139e:	f005 fef9 	bl	34027194 <memset>

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
340213a2:	68fb      	ldr	r3, [r7, #12]
340213a4:	68ba      	ldr	r2, [r7, #8]
340213a6:	605a      	str	r2, [r3, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
340213a8:	68fb      	ldr	r3, [r7, #12]
340213aa:	687a      	ldr	r2, [r7, #4]
340213ac:	611a      	str	r2, [r3, #16]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340213ae:	f3ef 8310 	mrs	r3, PRIMASK
340213b2:	61bb      	str	r3, [r7, #24]
    return(posture);
340213b4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
340213b6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
340213b8:	b672      	cpsid	i
    return(int_posture);
340213ba:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the mutex on the created list.  */
    TX_DISABLE
340213bc:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the mutex ID to make it valid.  */
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
340213be:	68fb      	ldr	r3, [r7, #12]
340213c0:	4a1a      	ldr	r2, [pc, #104]	@ (3402142c <_tx_mutex_create+0xa0>)
340213c2:	601a      	str	r2, [r3, #0]

    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
340213c4:	4b1a      	ldr	r3, [pc, #104]	@ (34021430 <_tx_mutex_create+0xa4>)
340213c6:	4a1b      	ldr	r2, [pc, #108]	@ (34021434 <_tx_mutex_create+0xa8>)
340213c8:	601a      	str	r2, [r3, #0]

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
340213ca:	4b1b      	ldr	r3, [pc, #108]	@ (34021438 <_tx_mutex_create+0xac>)
340213cc:	681b      	ldr	r3, [r3, #0]
340213ce:	2b00      	cmp	r3, #0
340213d0:	d109      	bne.n	340213e6 <_tx_mutex_create+0x5a>
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
340213d2:	4a1a      	ldr	r2, [pc, #104]	@ (3402143c <_tx_mutex_create+0xb0>)
340213d4:	68fb      	ldr	r3, [r7, #12]
340213d6:	6013      	str	r3, [r2, #0]
        mutex_ptr -> tx_mutex_created_next =      mutex_ptr;
340213d8:	68fb      	ldr	r3, [r7, #12]
340213da:	68fa      	ldr	r2, [r7, #12]
340213dc:	621a      	str	r2, [r3, #32]
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
340213de:	68fb      	ldr	r3, [r7, #12]
340213e0:	68fa      	ldr	r2, [r7, #12]
340213e2:	625a      	str	r2, [r3, #36]	@ 0x24
340213e4:	e011      	b.n	3402140a <_tx_mutex_create+0x7e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
340213e6:	4b15      	ldr	r3, [pc, #84]	@ (3402143c <_tx_mutex_create+0xb0>)
340213e8:	681b      	ldr	r3, [r3, #0]
340213ea:	623b      	str	r3, [r7, #32]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
340213ec:	6a3b      	ldr	r3, [r7, #32]
340213ee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340213f0:	61fb      	str	r3, [r7, #28]

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
340213f2:	6a3b      	ldr	r3, [r7, #32]
340213f4:	68fa      	ldr	r2, [r7, #12]
340213f6:	625a      	str	r2, [r3, #36]	@ 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
340213f8:	69fb      	ldr	r3, [r7, #28]
340213fa:	68fa      	ldr	r2, [r7, #12]
340213fc:	621a      	str	r2, [r3, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
340213fe:	68fb      	ldr	r3, [r7, #12]
34021400:	69fa      	ldr	r2, [r7, #28]
34021402:	625a      	str	r2, [r3, #36]	@ 0x24
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
34021404:	68fb      	ldr	r3, [r7, #12]
34021406:	6a3a      	ldr	r2, [r7, #32]
34021408:	621a      	str	r2, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
3402140a:	4b0b      	ldr	r3, [pc, #44]	@ (34021438 <_tx_mutex_create+0xac>)
3402140c:	681b      	ldr	r3, [r3, #0]
3402140e:	3301      	adds	r3, #1
34021410:	4a09      	ldr	r2, [pc, #36]	@ (34021438 <_tx_mutex_create+0xac>)
34021412:	6013      	str	r3, [r2, #0]
34021414:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34021416:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021418:	693b      	ldr	r3, [r7, #16]
3402141a:	f383 8810 	msr	PRIMASK, r3
}
3402141e:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
34021420:	2300      	movs	r3, #0
}
34021422:	4618      	mov	r0, r3
34021424:	3728      	adds	r7, #40	@ 0x28
34021426:	46bd      	mov	sp, r7
34021428:	bd80      	pop	{r7, pc}
3402142a:	bf00      	nop
3402142c:	4d555445 	.word	0x4d555445
34021430:	3404ab90 	.word	0x3404ab90
34021434:	34021305 	.word	0x34021305
34021438:	3404aad4 	.word	0x3404aad4
3402143c:	3404aad0 	.word	0x3404aad0

34021440 <_tx_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_delete(TX_MUTEX *mutex_ptr)
{
34021440:	b580      	push	{r7, lr}
34021442:	b096      	sub	sp, #88	@ 0x58
34021444:	af00      	add	r7, sp, #0
34021446:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021448:	f3ef 8310 	mrs	r3, PRIMASK
3402144c:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
3402144e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
34021450:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
34021452:	b672      	cpsid	i
    return(int_posture);
34021454:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
#ifdef TX_MISRA_ENABLE
UINT            status;
#endif

    /* Disable interrupts to remove the mutex from the created list.  */
    TX_DISABLE
34021456:	657b      	str	r3, [r7, #84]	@ 0x54

    /* Log this kernel call.  */
    TX_EL_MUTEX_DELETE_INSERT

    /* Clear the mutex ID to make it invalid.  */
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
34021458:	687b      	ldr	r3, [r7, #4]
3402145a:	2200      	movs	r2, #0
3402145c:	601a      	str	r2, [r3, #0]

    /* Decrement the created count.  */
    _tx_mutex_created_count--;
3402145e:	4b4a      	ldr	r3, [pc, #296]	@ (34021588 <_tx_mutex_delete+0x148>)
34021460:	681b      	ldr	r3, [r3, #0]
34021462:	3b01      	subs	r3, #1
34021464:	4a48      	ldr	r2, [pc, #288]	@ (34021588 <_tx_mutex_delete+0x148>)
34021466:	6013      	str	r3, [r2, #0]

    /* See if the mutex is the only one on the list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
34021468:	4b47      	ldr	r3, [pc, #284]	@ (34021588 <_tx_mutex_delete+0x148>)
3402146a:	681b      	ldr	r3, [r3, #0]
3402146c:	2b00      	cmp	r3, #0
3402146e:	d103      	bne.n	34021478 <_tx_mutex_delete+0x38>
    {

        /* Only created mutex, just set the created list to NULL.  */
        _tx_mutex_created_ptr =  TX_NULL;
34021470:	4b46      	ldr	r3, [pc, #280]	@ (3402158c <_tx_mutex_delete+0x14c>)
34021472:	2200      	movs	r2, #0
34021474:	601a      	str	r2, [r3, #0]
34021476:	e013      	b.n	340214a0 <_tx_mutex_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_mutex =                               mutex_ptr -> tx_mutex_created_next;
34021478:	687b      	ldr	r3, [r7, #4]
3402147a:	6a1b      	ldr	r3, [r3, #32]
3402147c:	64bb      	str	r3, [r7, #72]	@ 0x48
        previous_mutex =                           mutex_ptr -> tx_mutex_created_previous;
3402147e:	687b      	ldr	r3, [r7, #4]
34021480:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34021482:	647b      	str	r3, [r7, #68]	@ 0x44
        next_mutex -> tx_mutex_created_previous =  previous_mutex;
34021484:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34021486:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34021488:	625a      	str	r2, [r3, #36]	@ 0x24
        previous_mutex -> tx_mutex_created_next =  next_mutex;
3402148a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402148c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3402148e:	621a      	str	r2, [r3, #32]

        /* See if we have to update the created list head pointer.  */
        if (_tx_mutex_created_ptr == mutex_ptr)
34021490:	4b3e      	ldr	r3, [pc, #248]	@ (3402158c <_tx_mutex_delete+0x14c>)
34021492:	681b      	ldr	r3, [r3, #0]
34021494:	687a      	ldr	r2, [r7, #4]
34021496:	429a      	cmp	r2, r3
34021498:	d102      	bne.n	340214a0 <_tx_mutex_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_mutex_created_ptr =  next_mutex;
3402149a:	4a3c      	ldr	r2, [pc, #240]	@ (3402158c <_tx_mutex_delete+0x14c>)
3402149c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3402149e:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
340214a0:	4b3b      	ldr	r3, [pc, #236]	@ (34021590 <_tx_mutex_delete+0x150>)
340214a2:	681b      	ldr	r3, [r3, #0]
340214a4:	3301      	adds	r3, #1
340214a6:	4a3a      	ldr	r2, [pc, #232]	@ (34021590 <_tx_mutex_delete+0x150>)
340214a8:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
340214aa:	687b      	ldr	r3, [r7, #4]
340214ac:	699b      	ldr	r3, [r3, #24]
340214ae:	653b      	str	r3, [r7, #80]	@ 0x50
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
340214b0:	687b      	ldr	r3, [r7, #4]
340214b2:	2200      	movs	r2, #0
340214b4:	619a      	str	r2, [r3, #24]
    suspended_count =                        mutex_ptr -> tx_mutex_suspended_count;
340214b6:	687b      	ldr	r3, [r7, #4]
340214b8:	69db      	ldr	r3, [r3, #28]
340214ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
    mutex_ptr -> tx_mutex_suspended_count =  TX_NO_SUSPENSIONS;
340214bc:	687b      	ldr	r3, [r7, #4]
340214be:	2200      	movs	r2, #0
340214c0:	61da      	str	r2, [r3, #28]


    /* Determine if the mutex is currently on a thread's ownership list.  */

    /* Setup pointer to owner of mutex.  */
    owner_thread =  mutex_ptr -> tx_mutex_owner;
340214c2:	687b      	ldr	r3, [r7, #4]
340214c4:	68db      	ldr	r3, [r3, #12]
340214c6:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Determine if there is a valid thread pointer.  */
    if (owner_thread != TX_NULL)
340214c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340214ca:	2b00      	cmp	r3, #0
340214cc:	d013      	beq.n	340214f6 <_tx_mutex_delete+0xb6>
    {

        /* Yes, remove this mutex from the owned list.  */

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
340214ce:	687b      	ldr	r3, [r7, #4]
340214d0:	2201      	movs	r2, #1
340214d2:	609a      	str	r2, [r3, #8]
340214d4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340214d6:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340214d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340214da:	f383 8810 	msr	PRIMASK, r3
}
340214de:	bf00      	nop
        do
        {
            status =  _tx_mutex_put(mutex_ptr);
        } while (status != TX_SUCCESS);
#else
        _tx_mutex_put(mutex_ptr);
340214e0:	6878      	ldr	r0, [r7, #4]
340214e2:	f000 fadd 	bl	34021aa0 <_tx_mutex_put>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340214e6:	f3ef 8310 	mrs	r3, PRIMASK
340214ea:	633b      	str	r3, [r7, #48]	@ 0x30
    return(posture);
340214ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    int_posture = __get_interrupt_posture();
340214ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
340214f0:	b672      	cpsid	i
    return(int_posture);
340214f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
#endif

        /* Disable interrupts.  */
        TX_DISABLE
340214f4:	657b      	str	r3, [r7, #84]	@ 0x54
340214f6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
340214f8:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340214fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340214fc:	f383 8810 	msr	PRIMASK, r3
}
34021500:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the mutex list to resume any and all threads suspended
       on this mutex.  */
    while (suspended_count != ((ULONG) 0))
34021502:	e024      	b.n	3402154e <_tx_mutex_delete+0x10e>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
34021504:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34021506:	3b01      	subs	r3, #1
34021508:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402150a:	f3ef 8310 	mrs	r3, PRIMASK
3402150e:	61fb      	str	r3, [r7, #28]
    return(posture);
34021510:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34021512:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34021514:	b672      	cpsid	i
    return(int_posture);
34021516:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
34021518:	657b      	str	r3, [r7, #84]	@ 0x54

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
3402151a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3402151c:	2200      	movs	r2, #0
3402151e:	669a      	str	r2, [r3, #104]	@ 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
34021520:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34021522:	2201      	movs	r2, #1
34021524:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
34021528:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
3402152a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3402152c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
3402152e:	4b18      	ldr	r3, [pc, #96]	@ (34021590 <_tx_mutex_delete+0x150>)
34021530:	681b      	ldr	r3, [r3, #0]
34021532:	3301      	adds	r3, #1
34021534:	4a16      	ldr	r2, [pc, #88]	@ (34021590 <_tx_mutex_delete+0x150>)
34021536:	6013      	str	r3, [r2, #0]
34021538:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3402153a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402153c:	6a3b      	ldr	r3, [r7, #32]
3402153e:	f383 8810 	msr	PRIMASK, r3
}
34021542:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
34021544:	6d38      	ldr	r0, [r7, #80]	@ 0x50
34021546:	f001 fa01 	bl	3402294c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
3402154a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402154c:	653b      	str	r3, [r7, #80]	@ 0x50
    while (suspended_count != ((ULONG) 0))
3402154e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34021550:	2b00      	cmp	r3, #0
34021552:	d1d7      	bne.n	34021504 <_tx_mutex_delete+0xc4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021554:	f3ef 8310 	mrs	r3, PRIMASK
34021558:	613b      	str	r3, [r7, #16]
    return(posture);
3402155a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
3402155c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
3402155e:	b672      	cpsid	i
    return(int_posture);
34021560:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_MUTEX_DELETE_PORT_COMPLETION(mutex_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
34021562:	657b      	str	r3, [r7, #84]	@ 0x54

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
34021564:	4b0a      	ldr	r3, [pc, #40]	@ (34021590 <_tx_mutex_delete+0x150>)
34021566:	681b      	ldr	r3, [r3, #0]
34021568:	3b01      	subs	r3, #1
3402156a:	4a09      	ldr	r2, [pc, #36]	@ (34021590 <_tx_mutex_delete+0x150>)
3402156c:	6013      	str	r3, [r2, #0]
3402156e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34021570:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021572:	697b      	ldr	r3, [r7, #20]
34021574:	f383 8810 	msr	PRIMASK, r3
}
34021578:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
3402157a:	f001 f9ad 	bl	340228d8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
3402157e:	2300      	movs	r3, #0
}
34021580:	4618      	mov	r0, r3
34021582:	3758      	adds	r7, #88	@ 0x58
34021584:	46bd      	mov	sp, r7
34021586:	bd80      	pop	{r7, pc}
34021588:	3404aad4 	.word	0x3404aad4
3402158c:	3404aad0 	.word	0x3404aad0
34021590:	3404ab8c 	.word	0x3404ab8c

34021594 <_tx_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
34021594:	b580      	push	{r7, lr}
34021596:	b092      	sub	sp, #72	@ 0x48
34021598:	af00      	add	r7, sp, #0
3402159a:	6078      	str	r0, [r7, #4]
3402159c:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402159e:	f3ef 8310 	mrs	r3, PRIMASK
340215a2:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
340215a4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
340215a6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
340215a8:	b672      	cpsid	i
    return(int_posture);
340215aa:	6a3b      	ldr	r3, [r7, #32]
TX_THREAD       *previous_thread;
UINT            status;


    /* Disable interrupts to get an instance from the mutex.  */
    TX_DISABLE
340215ac:	643b      	str	r3, [r7, #64]	@ 0x40

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
340215ae:	4b7a      	ldr	r3, [pc, #488]	@ (34021798 <_tx_mutex_get+0x204>)
340215b0:	681b      	ldr	r3, [r3, #0]
340215b2:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
340215b4:	687b      	ldr	r3, [r7, #4]
340215b6:	689b      	ldr	r3, [r3, #8]
340215b8:	2b00      	cmp	r3, #0
340215ba:	d144      	bne.n	34021646 <_tx_mutex_get+0xb2>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
340215bc:	687b      	ldr	r3, [r7, #4]
340215be:	2201      	movs	r2, #1
340215c0:	609a      	str	r2, [r3, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;
340215c2:	687b      	ldr	r3, [r7, #4]
340215c4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340215c6:	60da      	str	r2, [r3, #12]

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
340215c8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340215ca:	2b00      	cmp	r3, #0
340215cc:	d032      	beq.n	34021634 <_tx_mutex_get+0xa0>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
340215ce:	687b      	ldr	r3, [r7, #4]
340215d0:	691b      	ldr	r3, [r3, #16]
340215d2:	2b01      	cmp	r3, #1
340215d4:	d106      	bne.n	340215e4 <_tx_mutex_get+0x50>
            {

                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
340215d6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340215d8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340215da:	687b      	ldr	r3, [r7, #4]
340215dc:	615a      	str	r2, [r3, #20]

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
340215de:	687b      	ldr	r3, [r7, #4]
340215e0:	2220      	movs	r2, #32
340215e2:	629a      	str	r2, [r3, #40]	@ 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
340215e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340215e6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
340215ea:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
340215ec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340215ee:	2b00      	cmp	r3, #0
340215f0:	d00f      	beq.n	34021612 <_tx_mutex_get+0x7e>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
340215f2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340215f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340215f6:	62bb      	str	r3, [r7, #40]	@ 0x28

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
340215f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340215fa:	687a      	ldr	r2, [r7, #4]
340215fc:	631a      	str	r2, [r3, #48]	@ 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
340215fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021600:	687a      	ldr	r2, [r7, #4]
34021602:	62da      	str	r2, [r3, #44]	@ 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
34021604:	687b      	ldr	r3, [r7, #4]
34021606:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34021608:	631a      	str	r2, [r3, #48]	@ 0x30
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
3402160a:	687b      	ldr	r3, [r7, #4]
3402160c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3402160e:	62da      	str	r2, [r3, #44]	@ 0x2c
34021610:	e009      	b.n	34021626 <_tx_mutex_get+0x92>
            }
            else
            {

                /* The owned mutex list is empty.  Add mutex to empty list.  */
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
34021612:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021614:	687a      	ldr	r2, [r7, #4]
34021616:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
3402161a:	687b      	ldr	r3, [r7, #4]
3402161c:	687a      	ldr	r2, [r7, #4]
3402161e:	62da      	str	r2, [r3, #44]	@ 0x2c
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
34021620:	687b      	ldr	r3, [r7, #4]
34021622:	687a      	ldr	r2, [r7, #4]
34021624:	631a      	str	r2, [r3, #48]	@ 0x30
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
34021626:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021628:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3402162c:	1c5a      	adds	r2, r3, #1
3402162e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021630:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
34021634:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021636:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021638:	69fb      	ldr	r3, [r7, #28]
3402163a:	f383 8810 	msr	PRIMASK, r3
}
3402163e:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
34021640:	2300      	movs	r3, #0
34021642:	647b      	str	r3, [r7, #68]	@ 0x44
34021644:	e0a2      	b.n	3402178c <_tx_mutex_get+0x1f8>
    }

    /* Otherwise, see if the owning thread is trying to obtain the same mutex.  */
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
34021646:	687b      	ldr	r3, [r7, #4]
34021648:	68db      	ldr	r3, [r3, #12]
3402164a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
3402164c:	429a      	cmp	r2, r3
3402164e:	d10d      	bne.n	3402166c <_tx_mutex_get+0xd8>
    {

        /* The owning thread is requesting the mutex again, just
           increment the ownership count.  */
        mutex_ptr -> tx_mutex_ownership_count++;
34021650:	687b      	ldr	r3, [r7, #4]
34021652:	689b      	ldr	r3, [r3, #8]
34021654:	1c5a      	adds	r2, r3, #1
34021656:	687b      	ldr	r3, [r7, #4]
34021658:	609a      	str	r2, [r3, #8]
3402165a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402165c:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402165e:	69bb      	ldr	r3, [r7, #24]
34021660:	f383 8810 	msr	PRIMASK, r3
}
34021664:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
34021666:	2300      	movs	r3, #0
34021668:	647b      	str	r3, [r7, #68]	@ 0x44
3402166a:	e08f      	b.n	3402178c <_tx_mutex_get+0x1f8>
    }
    else
    {

        /* Determine if the request specifies suspension.  */
        if (wait_option != TX_NO_WAIT)
3402166c:	683b      	ldr	r3, [r7, #0]
3402166e:	2b00      	cmp	r3, #0
34021670:	f000 8084 	beq.w	3402177c <_tx_mutex_get+0x1e8>
        {

            /* Determine if the preempt disable flag is non-zero.  */
            if (_tx_thread_preempt_disable != ((UINT) 0))
34021674:	4b49      	ldr	r3, [pc, #292]	@ (3402179c <_tx_mutex_get+0x208>)
34021676:	681b      	ldr	r3, [r3, #0]
34021678:	2b00      	cmp	r3, #0
3402167a:	d008      	beq.n	3402168e <_tx_mutex_get+0xfa>
3402167c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402167e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021680:	697b      	ldr	r3, [r7, #20]
34021682:	f383 8810 	msr	PRIMASK, r3
}
34021686:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
                status =  TX_NOT_AVAILABLE;
34021688:	231d      	movs	r3, #29
3402168a:	647b      	str	r3, [r7, #68]	@ 0x44
3402168c:	e07e      	b.n	3402178c <_tx_mutex_get+0x1f8>
            {

                /* Prepare for suspension of this thread.  */

                /* Pickup the mutex owner.  */
                mutex_owner =  mutex_ptr -> tx_mutex_owner;
3402168e:	687b      	ldr	r3, [r7, #4]
34021690:	68db      	ldr	r3, [r3, #12]
34021692:	63bb      	str	r3, [r7, #56]	@ 0x38
#endif
                }
#endif

                /* Setup cleanup routine pointer.  */
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
34021694:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021696:	4a42      	ldr	r2, [pc, #264]	@ (340217a0 <_tx_mutex_get+0x20c>)
34021698:	669a      	str	r2, [r3, #104]	@ 0x68

                /* Setup cleanup information, i.e. this mutex control
                   block.  */
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
3402169a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402169c:	687a      	ldr	r2, [r7, #4]
3402169e:	66da      	str	r2, [r3, #108]	@ 0x6c

#ifndef TX_NOT_INTERRUPTABLE

                /* Increment the suspension sequence number, which is used to identify
                   this suspension event.  */
                thread_ptr -> tx_thread_suspension_sequence++;
340216a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216a2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
340216a6:	1c5a      	adds	r2, r3, #1
340216a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216aa:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
#endif

                /* Setup suspension list.  */
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
340216ae:	687b      	ldr	r3, [r7, #4]
340216b0:	69db      	ldr	r3, [r3, #28]
340216b2:	2b00      	cmp	r3, #0
340216b4:	d109      	bne.n	340216ca <_tx_mutex_get+0x136>
                {

                    /* No other threads are suspended.  Setup the head pointer and
                       just setup this threads pointers to itself.  */
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
340216b6:	687b      	ldr	r3, [r7, #4]
340216b8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340216ba:	619a      	str	r2, [r3, #24]
                    thread_ptr -> tx_thread_suspended_next =        thread_ptr;
340216bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216be:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340216c0:	671a      	str	r2, [r3, #112]	@ 0x70
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
340216c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216c4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340216c6:	675a      	str	r2, [r3, #116]	@ 0x74
340216c8:	e011      	b.n	340216ee <_tx_mutex_get+0x15a>
                }
                else
                {

                    /* This list is not NULL, add current thread to the end. */
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
340216ca:	687b      	ldr	r3, [r7, #4]
340216cc:	699b      	ldr	r3, [r3, #24]
340216ce:	637b      	str	r3, [r7, #52]	@ 0x34
                    thread_ptr -> tx_thread_suspended_next =        next_thread;
340216d0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216d2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
340216d4:	671a      	str	r2, [r3, #112]	@ 0x70
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
340216d6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340216d8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340216da:	633b      	str	r3, [r7, #48]	@ 0x30
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
340216dc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216de:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
340216e0:	675a      	str	r2, [r3, #116]	@ 0x74
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
340216e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340216e4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340216e6:	671a      	str	r2, [r3, #112]	@ 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
340216e8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340216ea:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340216ec:	675a      	str	r2, [r3, #116]	@ 0x74
                }

                /* Increment the suspension count.  */
                mutex_ptr -> tx_mutex_suspended_count++;
340216ee:	687b      	ldr	r3, [r7, #4]
340216f0:	69db      	ldr	r3, [r3, #28]
340216f2:	1c5a      	adds	r2, r3, #1
340216f4:	687b      	ldr	r3, [r7, #4]
340216f6:	61da      	str	r2, [r3, #28]

                /* Set the state to suspended.  */
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
340216f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340216fa:	220d      	movs	r2, #13
340216fc:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag.  */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
340216fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021700:	2201      	movs	r2, #1
34021702:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Setup the timeout period.  */
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34021704:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021706:	683a      	ldr	r2, [r7, #0]
34021708:	64da      	str	r2, [r3, #76]	@ 0x4c

                /* Temporarily disable preemption.  */
                _tx_thread_preempt_disable++;
3402170a:	4b24      	ldr	r3, [pc, #144]	@ (3402179c <_tx_mutex_get+0x208>)
3402170c:	681b      	ldr	r3, [r3, #0]
3402170e:	3301      	adds	r3, #1
34021710:	4a22      	ldr	r2, [pc, #136]	@ (3402179c <_tx_mutex_get+0x208>)
34021712:	6013      	str	r3, [r2, #0]
34021714:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021716:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021718:	693b      	ldr	r3, [r7, #16]
3402171a:	f383 8810 	msr	PRIMASK, r3
}
3402171e:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if we need to raise the priority of the thread
                   owning the mutex.  */
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34021720:	687b      	ldr	r3, [r7, #4]
34021722:	691b      	ldr	r3, [r3, #16]
34021724:	2b01      	cmp	r3, #1
34021726:	d121      	bne.n	3402176c <_tx_mutex_get+0x1d8>
                {

                    /* Determine if this is the highest priority to raise for this mutex.  */
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
34021728:	687b      	ldr	r3, [r7, #4]
3402172a:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3402172c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402172e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021730:	429a      	cmp	r2, r3
34021732:	d903      	bls.n	3402173c <_tx_mutex_get+0x1a8>
                    {

                        /* Remember this priority.  */
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
34021734:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021736:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021738:	687b      	ldr	r3, [r7, #4]
3402173a:	629a      	str	r2, [r3, #40]	@ 0x28
                    }

                    /* Determine if we have to update inherit priority level of the mutex owner.  */
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
3402173c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402173e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021740:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021742:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34021746:	429a      	cmp	r2, r3
34021748:	d204      	bcs.n	34021754 <_tx_mutex_get+0x1c0>
                    {

                        /* Remember the new priority inheritance priority.  */
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
3402174a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402174c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
3402174e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021750:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c
                    }

                    /* Priority inheritance is requested, check to see if the thread that owns the mutex is lower priority.  */
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
34021754:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021756:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021758:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402175a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3402175c:	429a      	cmp	r2, r3
3402175e:	d905      	bls.n	3402176c <_tx_mutex_get+0x1d8>
                    {

                        /* Yes, raise the suspended, owning thread's priority to that
                           of the current thread.  */
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
34021760:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021762:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021764:	4619      	mov	r1, r3
34021766:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
34021768:	f000 f8ce 	bl	34021908 <_tx_mutex_priority_change>
#endif
                    }
                }

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
3402176c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
3402176e:	f001 fa01 	bl	34022b74 <_tx_thread_system_suspend>
#endif
                /* Return the completion status.  */
                status =  thread_ptr -> tx_thread_suspend_status;
34021772:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021774:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34021778:	647b      	str	r3, [r7, #68]	@ 0x44
3402177a:	e007      	b.n	3402178c <_tx_mutex_get+0x1f8>
3402177c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3402177e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021780:	68fb      	ldr	r3, [r7, #12]
34021782:	f383 8810 	msr	PRIMASK, r3
}
34021786:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Immediate return, return error completion.  */
            status =  TX_NOT_AVAILABLE;
34021788:	231d      	movs	r3, #29
3402178a:	647b      	str	r3, [r7, #68]	@ 0x44
        }
    }

    /* Return completion status.  */
    return(status);
3402178c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
3402178e:	4618      	mov	r0, r3
34021790:	3748      	adds	r7, #72	@ 0x48
34021792:	46bd      	mov	sp, r7
34021794:	bd80      	pop	{r7, pc}
34021796:	bf00      	nop
34021798:	3404aaf0 	.word	0x3404aaf0
3402179c:	3404ab8c 	.word	0x3404ab8c
340217a0:	3402120d 	.word	0x3402120d

340217a4 <_tx_mutex_prioritize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
340217a4:	b580      	push	{r7, lr}
340217a6:	b092      	sub	sp, #72	@ 0x48
340217a8:	af00      	add	r7, sp, #0
340217aa:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340217ac:	f3ef 8310 	mrs	r3, PRIMASK
340217b0:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
340217b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
340217b4:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
340217b6:	b672      	cpsid	i
    return(int_posture);
340217b8:	6a3b      	ldr	r3, [r7, #32]
UINT            status;
#endif


    /* Disable interrupts.  */
    TX_DISABLE
340217ba:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
340217bc:	687b      	ldr	r3, [r7, #4]
340217be:	69db      	ldr	r3, [r3, #28]
340217c0:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
340217c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340217c4:	2b01      	cmp	r3, #1
340217c6:	d805      	bhi.n	340217d4 <_tx_mutex_prioritize+0x30>
340217c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340217ca:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340217cc:	69fb      	ldr	r3, [r7, #28]
340217ce:	f383 8810 	msr	PRIMASK, r3
}
340217d2:	e092      	b.n	340218fa <_tx_mutex_prioritize+0x156>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
340217d4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340217d6:	2b02      	cmp	r3, #2
340217d8:	d114      	bne.n	34021804 <_tx_mutex_prioritize+0x60>
    {

        /* Pickup the head pointer and the next pointer.  */
        head_ptr =  mutex_ptr -> tx_mutex_suspension_list;
340217da:	687b      	ldr	r3, [r7, #4]
340217dc:	699b      	ldr	r3, [r3, #24]
340217de:	63bb      	str	r3, [r7, #56]	@ 0x38
        next_thread =  head_ptr -> tx_thread_suspended_next;
340217e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340217e2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340217e4:	62fb      	str	r3, [r7, #44]	@ 0x2c

        /* Determine if the next suspended thread has a higher priority.  */
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
340217e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340217e8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340217ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340217ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340217ee:	429a      	cmp	r2, r3
340217f0:	d202      	bcs.n	340217f8 <_tx_mutex_prioritize+0x54>
        {

            /* Yes, move the list head to the next thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
340217f2:	687b      	ldr	r3, [r7, #4]
340217f4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340217f6:	619a      	str	r2, [r3, #24]
340217f8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340217fa:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340217fc:	69bb      	ldr	r3, [r7, #24]
340217fe:	f383 8810 	msr	PRIMASK, r3
}
34021802:	e07a      	b.n	340218fa <_tx_mutex_prioritize+0x156>
    }
    else
    {

        /* Remember the suspension count and head pointer.  */
        head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
34021804:	687b      	ldr	r3, [r7, #4]
34021806:	699b      	ldr	r3, [r3, #24]
34021808:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Default the highest priority thread to the thread at the front of the list.  */
        priority_thread_ptr =  head_ptr;
3402180a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402180c:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
3402180e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021810:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34021812:	643b      	str	r3, [r7, #64]	@ 0x40

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
34021814:	4b3b      	ldr	r3, [pc, #236]	@ (34021904 <_tx_mutex_prioritize+0x160>)
34021816:	681b      	ldr	r3, [r3, #0]
34021818:	3301      	adds	r3, #1
3402181a:	4a3a      	ldr	r2, [pc, #232]	@ (34021904 <_tx_mutex_prioritize+0x160>)
3402181c:	6013      	str	r3, [r2, #0]

        /* Set the list changed flag to false.  */
        list_changed =  TX_FALSE;
3402181e:	2300      	movs	r3, #0
34021820:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Search through the list to find the highest priority thread.  */
        do
        {

            /* Is the current thread higher priority?  */
            if (thread_ptr -> tx_thread_priority < priority_thread_ptr -> tx_thread_priority)
34021822:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021824:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021826:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34021828:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3402182a:	429a      	cmp	r2, r3
3402182c:	d201      	bcs.n	34021832 <_tx_mutex_prioritize+0x8e>
            {

                /* Yes, remember that this thread is the highest priority.  */
                priority_thread_ptr =  thread_ptr;
3402182e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021830:	63fb      	str	r3, [r7, #60]	@ 0x3c
34021832:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34021834:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021836:	68fb      	ldr	r3, [r7, #12]
34021838:	f383 8810 	msr	PRIMASK, r3
}
3402183c:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402183e:	f3ef 8310 	mrs	r3, PRIMASK
34021842:	617b      	str	r3, [r7, #20]
    return(posture);
34021844:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34021846:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34021848:	b672      	cpsid	i
    return(int_posture);
3402184a:	693b      	ldr	r3, [r7, #16]

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
3402184c:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Determine if any changes to the list have occurred while
               interrupts were enabled.  */

            /* Is the list head the same?  */
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
3402184e:	687b      	ldr	r3, [r7, #4]
34021850:	699b      	ldr	r3, [r3, #24]
34021852:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34021854:	429a      	cmp	r2, r3
34021856:	d002      	beq.n	3402185e <_tx_mutex_prioritize+0xba>
            {

                /* The list head has changed, set the list changed flag.  */
                list_changed =  TX_TRUE;
34021858:	2301      	movs	r3, #1
3402185a:	633b      	str	r3, [r7, #48]	@ 0x30
3402185c:	e006      	b.n	3402186c <_tx_mutex_prioritize+0xc8>
            }
            else
            {

                /* Is the suspended count the same?  */
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
3402185e:	687b      	ldr	r3, [r7, #4]
34021860:	69db      	ldr	r3, [r3, #28]
34021862:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34021864:	429a      	cmp	r2, r3
34021866:	d001      	beq.n	3402186c <_tx_mutex_prioritize+0xc8>
                {

                    /* The list head has changed, set the list changed flag.  */
                    list_changed =  TX_TRUE;
34021868:	2301      	movs	r3, #1
3402186a:	633b      	str	r3, [r7, #48]	@ 0x30
                }
            }

            /* Determine if the list has changed.  */
            if (list_changed == TX_FALSE)
3402186c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402186e:	2b00      	cmp	r3, #0
34021870:	d103      	bne.n	3402187a <_tx_mutex_prioritize+0xd6>
            {

                /* Move the thread pointer to the next thread.  */
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
34021872:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021874:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34021876:	643b      	str	r3, [r7, #64]	@ 0x40
34021878:	e00c      	b.n	34021894 <_tx_mutex_prioritize+0xf0>
            }
            else
            {

                /* Remember the suspension count and head pointer.  */
                head_ptr =   mutex_ptr -> tx_mutex_suspension_list;
3402187a:	687b      	ldr	r3, [r7, #4]
3402187c:	699b      	ldr	r3, [r3, #24]
3402187e:	63bb      	str	r3, [r7, #56]	@ 0x38
                suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
34021880:	687b      	ldr	r3, [r7, #4]
34021882:	69db      	ldr	r3, [r3, #28]
34021884:	637b      	str	r3, [r7, #52]	@ 0x34

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;
34021886:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021888:	63fb      	str	r3, [r7, #60]	@ 0x3c

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
3402188a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402188c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3402188e:	643b      	str	r3, [r7, #64]	@ 0x40

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
34021890:	2300      	movs	r3, #0
34021892:	633b      	str	r3, [r7, #48]	@ 0x30
            }

        } while (thread_ptr != head_ptr);
34021894:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34021896:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021898:	429a      	cmp	r2, r3
3402189a:	d1c2      	bne.n	34021822 <_tx_mutex_prioritize+0x7e>

        /* Release preemption.  */
        _tx_thread_preempt_disable--;
3402189c:	4b19      	ldr	r3, [pc, #100]	@ (34021904 <_tx_mutex_prioritize+0x160>)
3402189e:	681b      	ldr	r3, [r3, #0]
340218a0:	3b01      	subs	r3, #1
340218a2:	4a18      	ldr	r2, [pc, #96]	@ (34021904 <_tx_mutex_prioritize+0x160>)
340218a4:	6013      	str	r3, [r2, #0]

        /* Now determine if the highest priority thread is at the front
           of the list.  */
        if (priority_thread_ptr != head_ptr)
340218a6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340218a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340218aa:	429a      	cmp	r2, r3
340218ac:	d01d      	beq.n	340218ea <_tx_mutex_prioritize+0x146>
            /* No, we need to move the highest priority suspended thread to the
               front of the list.  */

            /* First, remove the highest priority thread by updating the
               adjacent suspended threads.  */
            next_thread =                                  priority_thread_ptr -> tx_thread_suspended_next;
340218ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340218b0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
340218b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
340218b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340218b6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340218b8:	62bb      	str	r3, [r7, #40]	@ 0x28
            next_thread -> tx_thread_suspended_previous =  previous_thread;
340218ba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340218bc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340218be:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
340218c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340218c2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340218c4:	671a      	str	r2, [r3, #112]	@ 0x70

            /* Now, link the highest priority thread at the front of the list.  */
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
340218c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340218c8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
340218ca:	62bb      	str	r3, [r7, #40]	@ 0x28
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
340218cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340218ce:	6bba      	ldr	r2, [r7, #56]	@ 0x38
340218d0:	671a      	str	r2, [r3, #112]	@ 0x70
            priority_thread_ptr -> tx_thread_suspended_previous =  previous_thread;
340218d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340218d4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340218d6:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
340218d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340218da:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340218dc:	671a      	str	r2, [r3, #112]	@ 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
340218de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340218e0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340218e2:	675a      	str	r2, [r3, #116]	@ 0x74

            /* Move the list head pointer to the highest priority suspended thread.  */
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
340218e4:	687b      	ldr	r3, [r7, #4]
340218e6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
340218e8:	619a      	str	r2, [r3, #24]
340218ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340218ec:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340218ee:	68bb      	ldr	r3, [r7, #8]
340218f0:	f383 8810 	msr	PRIMASK, r3
}
340218f4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
340218f6:	f000 ffef 	bl	340228d8 <_tx_thread_system_preempt_check>
    /* Return completion status.  */
    return(status);
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
340218fa:	2300      	movs	r3, #0
#endif
}
340218fc:	4618      	mov	r0, r3
340218fe:	3748      	adds	r7, #72	@ 0x48
34021900:	46bd      	mov	sp, r7
34021902:	bd80      	pop	{r7, pc}
34021904:	3404ab8c 	.word	0x3404ab8c

34021908 <_tx_mutex_priority_change>:
/*                                            priority rather than next,  */
/*                                            resulting in version 6.1.6  */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
34021908:	b580      	push	{r7, lr}
3402190a:	b092      	sub	sp, #72	@ 0x48
3402190c:	af00      	add	r7, sp, #0
3402190e:	6078      	str	r0, [r7, #4]
34021910:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021912:	f3ef 8310 	mrs	r3, PRIMASK
34021916:	633b      	str	r3, [r7, #48]	@ 0x30
    return(posture);
34021918:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    int_posture = __get_interrupt_posture();
3402191a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("CPSID i" : : : "memory");
3402191c:	b672      	cpsid	i
    return(int_posture);
3402191e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c


#ifndef TX_NOT_INTERRUPTABLE

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
34021920:	647b      	str	r3, [r7, #68]	@ 0x44
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
34021922:	687b      	ldr	r3, [r7, #4]
34021924:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34021926:	2b00      	cmp	r3, #0
34021928:	d017      	beq.n	3402195a <_tx_mutex_priority_change+0x52>
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
3402192a:	687b      	ldr	r3, [r7, #4]
3402192c:	683a      	ldr	r2, [r7, #0]
3402192e:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
34021930:	687b      	ldr	r3, [r7, #4]
34021932:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
34021936:	683a      	ldr	r2, [r7, #0]
34021938:	429a      	cmp	r2, r3
3402193a:	d905      	bls.n	34021948 <_tx_mutex_priority_change+0x40>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
3402193c:	687b      	ldr	r3, [r7, #4]
3402193e:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34021942:	687b      	ldr	r3, [r7, #4]
34021944:	63da      	str	r2, [r3, #60]	@ 0x3c
34021946:	e002      	b.n	3402194e <_tx_mutex_priority_change+0x46>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
34021948:	687b      	ldr	r3, [r7, #4]
3402194a:	683a      	ldr	r2, [r7, #0]
3402194c:	63da      	str	r2, [r3, #60]	@ 0x3c
3402194e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34021950:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021952:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021954:	f383 8810 	msr	PRIMASK, r3
}
34021958:	e096      	b.n	34021a88 <_tx_mutex_priority_change+0x180>
    }
    else
    {

        /* Pickup the next thread to execute.  */
        execute_ptr =  _tx_thread_execute_ptr;
3402195a:	4b4d      	ldr	r3, [pc, #308]	@ (34021a90 <_tx_mutex_priority_change+0x188>)
3402195c:	681b      	ldr	r3, [r3, #0]
3402195e:	643b      	str	r3, [r7, #64]	@ 0x40

        /* Save the original priority.  */
        original_priority =  thread_ptr -> tx_thread_priority;
34021960:	687b      	ldr	r3, [r7, #4]
34021962:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021964:	63fb      	str	r3, [r7, #60]	@ 0x3c
        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
#else

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
34021966:	4b4b      	ldr	r3, [pc, #300]	@ (34021a94 <_tx_mutex_priority_change+0x18c>)
34021968:	681b      	ldr	r3, [r3, #0]
3402196a:	3302      	adds	r3, #2
3402196c:	4a49      	ldr	r2, [pc, #292]	@ (34021a94 <_tx_mutex_priority_change+0x18c>)
3402196e:	6013      	str	r3, [r2, #0]

        /* Set the state to priority change.  */
        thread_ptr -> tx_thread_state =    TX_PRIORITY_CHANGE;
34021970:	687b      	ldr	r3, [r7, #4]
34021972:	220e      	movs	r2, #14
34021974:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Set the suspending flag. */
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
34021976:	687b      	ldr	r3, [r7, #4]
34021978:	2201      	movs	r2, #1
3402197a:	639a      	str	r2, [r3, #56]	@ 0x38

        /* Setup the timeout period.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
3402197c:	687b      	ldr	r3, [r7, #4]
3402197e:	2200      	movs	r2, #0
34021980:	64da      	str	r2, [r3, #76]	@ 0x4c
34021982:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34021984:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021986:	69fb      	ldr	r3, [r7, #28]
34021988:	f383 8810 	msr	PRIMASK, r3
}
3402198c:	bf00      	nop
        /* Restore interrupts.  */
        TX_RESTORE

        /* The thread is ready and must first be removed from the list.  Call the
           system suspend function to accomplish this.  */
        _tx_thread_system_suspend(thread_ptr);
3402198e:	6878      	ldr	r0, [r7, #4]
34021990:	f001 f8f0 	bl	34022b74 <_tx_thread_system_suspend>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021994:	f3ef 8310 	mrs	r3, PRIMASK
34021998:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
3402199a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
3402199c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
3402199e:	b672      	cpsid	i
    return(int_posture);
340219a0:	6a3b      	ldr	r3, [r7, #32]

        /* Disable interrupts.  */
        TX_DISABLE
340219a2:	647b      	str	r3, [r7, #68]	@ 0x44

        /* At this point, the preempt disable flag is still set, so we still have
           protection against all preemption.  */

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
340219a4:	687b      	ldr	r3, [r7, #4]
340219a6:	683a      	ldr	r2, [r7, #0]
340219a8:	62da      	str	r2, [r3, #44]	@ 0x2c

        /* Determine how to setup the thread's preemption-threshold.  */
        if (thread_ptr -> tx_thread_user_preempt_threshold < new_priority)
340219aa:	687b      	ldr	r3, [r7, #4]
340219ac:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
340219b0:	683a      	ldr	r2, [r7, #0]
340219b2:	429a      	cmp	r2, r3
340219b4:	d905      	bls.n	340219c2 <_tx_mutex_priority_change+0xba>
        {

            /* Change thread preemption-threshold to the user's preemption-threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
340219b6:	687b      	ldr	r3, [r7, #4]
340219b8:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
340219bc:	687b      	ldr	r3, [r7, #4]
340219be:	63da      	str	r2, [r3, #60]	@ 0x3c
340219c0:	e002      	b.n	340219c8 <_tx_mutex_priority_change+0xc0>
        }
        else
        {

            /* Change the thread preemption-threshold to the new threshold.  */
            thread_ptr -> tx_thread_preempt_threshold =  new_priority;
340219c2:	687b      	ldr	r3, [r7, #4]
340219c4:	683a      	ldr	r2, [r7, #0]
340219c6:	63da      	str	r2, [r3, #60]	@ 0x3c
340219c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340219ca:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340219cc:	693b      	ldr	r3, [r7, #16]
340219ce:	f383 8810 	msr	PRIMASK, r3
}
340219d2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread with the new priority.  */
        _tx_thread_system_resume(thread_ptr);
340219d4:	6878      	ldr	r0, [r7, #4]
340219d6:	f000 ffb9 	bl	3402294c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340219da:	f3ef 8310 	mrs	r3, PRIMASK
340219de:	61bb      	str	r3, [r7, #24]
    return(posture);
340219e0:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
340219e2:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
340219e4:	b672      	cpsid	i
    return(int_posture);
340219e6:	697b      	ldr	r3, [r7, #20]
        TX_MUTEX_PRIORITY_CHANGE_EXTENSION

#ifndef TX_NOT_INTERRUPTABLE

        /* Disable interrupts.  */
        TX_DISABLE
340219e8:	647b      	str	r3, [r7, #68]	@ 0x44
#endif

        /* Pickup the next thread to execute.  */
        next_execute_ptr =  _tx_thread_execute_ptr;
340219ea:	4b29      	ldr	r3, [pc, #164]	@ (34021a90 <_tx_mutex_priority_change+0x188>)
340219ec:	681b      	ldr	r3, [r3, #0]
340219ee:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Determine if this thread is not the next thread to execute.  */
        if (thread_ptr != next_execute_ptr)
340219f0:	687a      	ldr	r2, [r7, #4]
340219f2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340219f4:	429a      	cmp	r2, r3
340219f6:	d041      	beq.n	34021a7c <_tx_mutex_priority_change+0x174>
        {

            /* Make sure the thread is still ready.  */
            if (thread_ptr -> tx_thread_state == TX_READY)
340219f8:	687b      	ldr	r3, [r7, #4]
340219fa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340219fc:	2b00      	cmp	r3, #0
340219fe:	d13d      	bne.n	34021a7c <_tx_mutex_priority_change+0x174>
            {

                /* Now check and see if this thread has an equal or higher priority.  */
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
34021a00:	687b      	ldr	r3, [r7, #4]
34021a02:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021a04:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021a06:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a08:	429a      	cmp	r2, r3
34021a0a:	d811      	bhi.n	34021a30 <_tx_mutex_priority_change+0x128>
                {

                    /* Now determine if this thread was the previously executing thread.  */
                    if (thread_ptr == execute_ptr)
34021a0c:	687a      	ldr	r2, [r7, #4]
34021a0e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34021a10:	429a      	cmp	r2, r3
34021a12:	d133      	bne.n	34021a7c <_tx_mutex_priority_change+0x174>

                        /* Yes, this thread was previously executing before we temporarily suspended and resumed
                           it in order to change the priority. A lower or same priority thread cannot be the next thread
                           to execute in this case since this thread really didn't suspend.  Simply reset the execute
                           pointer to this thread.  */
                        _tx_thread_execute_ptr =  thread_ptr;
34021a14:	4a1e      	ldr	r2, [pc, #120]	@ (34021a90 <_tx_mutex_priority_change+0x188>)
34021a16:	687b      	ldr	r3, [r7, #4]
34021a18:	6013      	str	r3, [r2, #0]

                        /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                        if (original_priority < new_priority)
34021a1a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34021a1c:	683b      	ldr	r3, [r7, #0]
34021a1e:	429a      	cmp	r2, r3
34021a20:	d22c      	bcs.n	34021a7c <_tx_mutex_priority_change+0x174>
                        {

                            /* Ensure that this thread is placed at the front of the priority list.  */
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
34021a22:	687b      	ldr	r3, [r7, #4]
34021a24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a26:	491c      	ldr	r1, [pc, #112]	@ (34021a98 <_tx_mutex_priority_change+0x190>)
34021a28:	687a      	ldr	r2, [r7, #4]
34021a2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
34021a2e:	e025      	b.n	34021a7c <_tx_mutex_priority_change+0x174>
                }
                else
                {

                    /* Now determine if this thread's preemption-threshold needs to be enforced.  */
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
34021a30:	687b      	ldr	r3, [r7, #4]
34021a32:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34021a34:	687b      	ldr	r3, [r7, #4]
34021a36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a38:	429a      	cmp	r2, r3
34021a3a:	d21f      	bcs.n	34021a7c <_tx_mutex_priority_change+0x174>
                    {

                        /* Yes, preemption-threshold is in force for this thread. */

                        /* Compare the next thread to execute thread's priority against the thread's preemption-threshold.  */
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
34021a3c:	687b      	ldr	r3, [r7, #4]
34021a3e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34021a40:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34021a42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a44:	429a      	cmp	r2, r3
34021a46:	d80d      	bhi.n	34021a64 <_tx_mutex_priority_change+0x15c>
                        {

                            /* We must swap execute pointers to enforce the preemption-threshold of a thread coming out of
                               priority inheritance.  */
                            _tx_thread_execute_ptr =  thread_ptr;
34021a48:	4a11      	ldr	r2, [pc, #68]	@ (34021a90 <_tx_mutex_priority_change+0x188>)
34021a4a:	687b      	ldr	r3, [r7, #4]
34021a4c:	6013      	str	r3, [r2, #0]

                            /* Determine if we moved to a lower priority. If so, move the thread to the front of its priority list.  */
                            if (original_priority < new_priority)
34021a4e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34021a50:	683b      	ldr	r3, [r7, #0]
34021a52:	429a      	cmp	r2, r3
34021a54:	d212      	bcs.n	34021a7c <_tx_mutex_priority_change+0x174>
                            {

                                /* Ensure that this thread is placed at the front of the priority list.  */
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
34021a56:	687b      	ldr	r3, [r7, #4]
34021a58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a5a:	490f      	ldr	r1, [pc, #60]	@ (34021a98 <_tx_mutex_priority_change+0x190>)
34021a5c:	687a      	ldr	r2, [r7, #4]
34021a5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
34021a62:	e00b      	b.n	34021a7c <_tx_mutex_priority_change+0x174>
                            TX_DIV32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
                            _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                            /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                            TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
34021a64:	687b      	ldr	r3, [r7, #4]
34021a66:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021a68:	2201      	movs	r2, #1
34021a6a:	fa02 f303 	lsl.w	r3, r2, r3
34021a6e:	637b      	str	r3, [r7, #52]	@ 0x34
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
34021a70:	4b0a      	ldr	r3, [pc, #40]	@ (34021a9c <_tx_mutex_priority_change+0x194>)
34021a72:	681a      	ldr	r2, [r3, #0]
34021a74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34021a76:	4313      	orrs	r3, r2
34021a78:	4a08      	ldr	r2, [pc, #32]	@ (34021a9c <_tx_mutex_priority_change+0x194>)
34021a7a:	6013      	str	r3, [r2, #0]
34021a7c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34021a7e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021a80:	68fb      	ldr	r3, [r7, #12]
34021a82:	f383 8810 	msr	PRIMASK, r3
}
34021a86:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
34021a88:	bf00      	nop
34021a8a:	3748      	adds	r7, #72	@ 0x48
34021a8c:	46bd      	mov	sp, r7
34021a8e:	bd80      	pop	{r7, pc}
34021a90:	3404aaf4 	.word	0x3404aaf4
34021a94:	3404ab8c 	.word	0x3404ab8c
34021a98:	3404ab0c 	.word	0x3404ab0c
34021a9c:	3404ab04 	.word	0x3404ab04

34021aa0 <_tx_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
34021aa0:	b580      	push	{r7, lr}
34021aa2:	b0a6      	sub	sp, #152	@ 0x98
34021aa4:	af00      	add	r7, sp, #0
34021aa6:	6078      	str	r0, [r7, #4]
TX_THREAD       *suspended_thread;
UINT            inheritance_priority;


    /* Setup status to indicate the processing is not complete.  */
    status =  TX_NOT_DONE;
34021aa8:	2320      	movs	r3, #32
34021aaa:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021aae:	f3ef 8310 	mrs	r3, PRIMASK
34021ab2:	65fb      	str	r3, [r7, #92]	@ 0x5c
    return(posture);
34021ab4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
    int_posture = __get_interrupt_posture();
34021ab6:	65bb      	str	r3, [r7, #88]	@ 0x58
    __asm__ volatile ("CPSID i" : : : "memory");
34021ab8:	b672      	cpsid	i
    return(int_posture);
34021aba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58

    /* Disable interrupts to put an instance back to the mutex.  */
    TX_DISABLE
34021abc:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
34021ac0:	687b      	ldr	r3, [r7, #4]
34021ac2:	689b      	ldr	r3, [r3, #8]
34021ac4:	2b00      	cmp	r3, #0
34021ac6:	f000 81ff 	beq.w	34021ec8 <_tx_mutex_put+0x428>
    {

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
34021aca:	687b      	ldr	r3, [r7, #4]
34021acc:	68db      	ldr	r3, [r3, #12]
34021ace:	67fb      	str	r3, [r7, #124]	@ 0x7c

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
34021ad0:	4ba3      	ldr	r3, [pc, #652]	@ (34021d60 <_tx_mutex_put+0x2c0>)
34021ad2:	681b      	ldr	r3, [r3, #0]
34021ad4:	67bb      	str	r3, [r7, #120]	@ 0x78

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
34021ad6:	687b      	ldr	r3, [r7, #4]
34021ad8:	68db      	ldr	r3, [r3, #12]
34021ada:	6fba      	ldr	r2, [r7, #120]	@ 0x78
34021adc:	429a      	cmp	r2, r3
34021ade:	d00d      	beq.n	34021afc <_tx_mutex_put+0x5c>
        {

            /* Determine if the preempt disable flag is set, indicating that
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
34021ae0:	4ba0      	ldr	r3, [pc, #640]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021ae2:	681b      	ldr	r3, [r3, #0]
34021ae4:	2b00      	cmp	r3, #0
34021ae6:	d109      	bne.n	34021afc <_tx_mutex_put+0x5c>
34021ae8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021aec:	657b      	str	r3, [r7, #84]	@ 0x54
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021aee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34021af0:	f383 8810 	msr	PRIMASK, r3
}
34021af4:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Caller does not own the mutex.  */
                status =  TX_NOT_OWNED;
34021af6:	231e      	movs	r3, #30
34021af8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            }
        }

        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
34021afc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34021b00:	2b20      	cmp	r3, #32
34021b02:	f040 81eb 	bne.w	34021edc <_tx_mutex_put+0x43c>
        {

            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
34021b06:	687b      	ldr	r3, [r7, #4]
34021b08:	689b      	ldr	r3, [r3, #8]
34021b0a:	1e5a      	subs	r2, r3, #1
34021b0c:	687b      	ldr	r3, [r7, #4]
34021b0e:	609a      	str	r2, [r3, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
34021b10:	687b      	ldr	r3, [r7, #4]
34021b12:	689b      	ldr	r3, [r3, #8]
34021b14:	2b00      	cmp	r3, #0
34021b16:	d00a      	beq.n	34021b2e <_tx_mutex_put+0x8e>
34021b18:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021b1c:	653b      	str	r3, [r7, #80]	@ 0x50
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021b1e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34021b20:	f383 8810 	msr	PRIMASK, r3
}
34021b24:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Mutex is still owned, just return successful status.  */
                status =  TX_SUCCESS;
34021b26:	2300      	movs	r3, #0
34021b28:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34021b2c:	e1d6      	b.n	34021edc <_tx_mutex_put+0x43c>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
34021b2e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b30:	2b00      	cmp	r3, #0
34021b32:	d10a      	bne.n	34021b4a <_tx_mutex_put+0xaa>
34021b34:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021b38:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021b3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34021b3c:	f383 8810 	msr	PRIMASK, r3
}
34021b40:	bf00      	nop

                    /* Restore interrupts.  */
                    TX_RESTORE

                    /* Mutex is now available, return successful status.  */
                    status =  TX_SUCCESS;
34021b42:	2300      	movs	r3, #0
34021b44:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34021b48:	e1c8      	b.n	34021edc <_tx_mutex_put+0x43c>
                    /* The mutex is now available.   */

                    /* Remove this mutex from the owned mutex list.  */

                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
34021b4a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b4c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34021b50:	1e5a      	subs	r2, r3, #1
34021b52:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b54:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
34021b58:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b5a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34021b5e:	2b00      	cmp	r3, #0
34021b60:	d104      	bne.n	34021b6c <_tx_mutex_put+0xcc>
                    {

                        /* Yes, the list is empty.  Simply set the head pointer to NULL.  */
                        thread_ptr -> tx_thread_owned_mutex_list =  TX_NULL;
34021b62:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b64:	2200      	movs	r2, #0
34021b66:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
34021b6a:	e019      	b.n	34021ba0 <_tx_mutex_put+0x100>
                    {

                        /* No, there are more mutexes on the list.  */

                        /* Link-up the neighbors.  */
                        next_mutex =                             mutex_ptr -> tx_mutex_owned_next;
34021b6c:	687b      	ldr	r3, [r7, #4]
34021b6e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021b70:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
34021b74:	687b      	ldr	r3, [r7, #4]
34021b76:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34021b78:	677b      	str	r3, [r7, #116]	@ 0x74
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
34021b7a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021b7e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34021b80:	631a      	str	r2, [r3, #48]	@ 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
34021b82:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34021b84:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34021b88:	62da      	str	r2, [r3, #44]	@ 0x2c

                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
34021b8a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b8c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34021b90:	687a      	ldr	r2, [r7, #4]
34021b92:	429a      	cmp	r2, r3
34021b94:	d104      	bne.n	34021ba0 <_tx_mutex_put+0x100>
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
34021b96:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021b98:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34021b9c:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
34021ba0:	687b      	ldr	r3, [r7, #4]
34021ba2:	699b      	ldr	r3, [r3, #24]
34021ba4:	2b00      	cmp	r3, #0
34021ba6:	d110      	bne.n	34021bca <_tx_mutex_put+0x12a>
                    {

                        /* Is this a priority inheritance mutex?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
34021ba8:	687b      	ldr	r3, [r7, #4]
34021baa:	691b      	ldr	r3, [r3, #16]
34021bac:	2b00      	cmp	r3, #0
34021bae:	d10c      	bne.n	34021bca <_tx_mutex_put+0x12a>
                        {

                            /* Yes, we are done - set the mutex owner to NULL.   */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
34021bb0:	687b      	ldr	r3, [r7, #4]
34021bb2:	2200      	movs	r2, #0
34021bb4:	60da      	str	r2, [r3, #12]
34021bb6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021bba:	64bb      	str	r3, [r7, #72]	@ 0x48
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021bbc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34021bbe:	f383 8810 	msr	PRIMASK, r3
}
34021bc2:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Mutex is now available, return successful status.  */
                            status =  TX_SUCCESS;
34021bc4:	2300      	movs	r3, #0
34021bc6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                        }
                    }

                    /* Determine if the processing is complete.  */
                    if (status == TX_NOT_DONE)
34021bca:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
34021bce:	2b20      	cmp	r3, #32
34021bd0:	f040 8184 	bne.w	34021edc <_tx_mutex_put+0x43c>
                    {

                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
34021bd4:	2300      	movs	r3, #0
34021bd6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
                        old_priority =   thread_ptr -> tx_thread_user_priority;
34021bda:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021bdc:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34021be0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34021be4:	687b      	ldr	r3, [r7, #4]
34021be6:	691b      	ldr	r3, [r3, #16]
34021be8:	2b01      	cmp	r3, #1
34021bea:	d155      	bne.n	34021c98 <_tx_mutex_put+0x1f8>
                        {

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34021bec:	4b5d      	ldr	r3, [pc, #372]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021bee:	681b      	ldr	r3, [r3, #0]
34021bf0:	3301      	adds	r3, #1
34021bf2:	4a5c      	ldr	r2, [pc, #368]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021bf4:	6013      	str	r3, [r2, #0]
34021bf6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021bfa:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021bfc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34021bfe:	f383 8810 	msr	PRIMASK, r3
}
34021c02:	bf00      	nop
                            /* Restore interrupts.  */
                            TX_RESTORE
#endif

                            /* Default the inheritance priority to disabled.  */
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
34021c04:	2320      	movs	r3, #32
34021c06:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

                            /* Search the owned mutexes for this thread to determine the highest priority for this
                               former mutex owner to return to.  */
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
34021c0a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021c0c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34021c10:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            while (next_mutex != TX_NULL)
34021c14:	e01f      	b.n	34021c56 <_tx_mutex_put+0x1b6>
                            {

                                /* Does this mutex support priority inheritance?  */
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
34021c16:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021c1a:	691b      	ldr	r3, [r3, #16]
34021c1c:	2b01      	cmp	r3, #1
34021c1e:	d10b      	bne.n	34021c38 <_tx_mutex_put+0x198>
                                {

                                    /* Determine if highest priority field of the mutex is higher than the priority to
                                       restore.  */
                                    if (next_mutex -> tx_mutex_highest_priority_waiting < inheritance_priority)
34021c20:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021c24:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34021c26:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
34021c2a:	429a      	cmp	r2, r3
34021c2c:	d904      	bls.n	34021c38 <_tx_mutex_put+0x198>
                                    {

                                        /* Use this priority to return releasing thread to.  */
                                        inheritance_priority =   next_mutex -> tx_mutex_highest_priority_waiting;
34021c2e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021c32:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34021c34:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
                                    }
                                }

                                /* Move mutex pointer to the next mutex in the list.  */
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
34021c38:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021c3c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021c3e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

                                /* Are we at the end of the list?  */
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
34021c42:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021c44:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34021c48:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34021c4c:	429a      	cmp	r2, r3
34021c4e:	d102      	bne.n	34021c56 <_tx_mutex_put+0x1b6>
                                {

                                    /* Yes, set the next mutex to NULL.  */
                                    next_mutex =  TX_NULL;
34021c50:	2300      	movs	r3, #0
34021c52:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                            while (next_mutex != TX_NULL)
34021c56:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021c5a:	2b00      	cmp	r3, #0
34021c5c:	d1db      	bne.n	34021c16 <_tx_mutex_put+0x176>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021c5e:	f3ef 8310 	mrs	r3, PRIMASK
34021c62:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
34021c64:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
34021c66:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
34021c68:	b672      	cpsid	i
    return(int_posture);
34021c6a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts.  */
                            TX_DISABLE
34021c6c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                            /* Undo the temporarily preemption disable.  */
                            _tx_thread_preempt_disable--;
34021c70:	4b3c      	ldr	r3, [pc, #240]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021c72:	681b      	ldr	r3, [r3, #0]
34021c74:	3b01      	subs	r3, #1
34021c76:	4a3b      	ldr	r2, [pc, #236]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021c78:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the inherit priority to that of the highest priority thread waiting on the mutex.  */
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
34021c7a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021c7c:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
34021c80:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c

                            /* Determine if the inheritance priority is less than the default old priority.  */
                            if (inheritance_priority < old_priority)
34021c84:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
34021c88:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34021c8c:	429a      	cmp	r2, r3
34021c8e:	d203      	bcs.n	34021c98 <_tx_mutex_put+0x1f8>
                            {

                                /* Yes, update the old priority.  */
                                old_priority =  inheritance_priority;
34021c90:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
34021c94:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
34021c98:	687b      	ldr	r3, [r7, #4]
34021c9a:	69db      	ldr	r3, [r3, #28]
34021c9c:	2b01      	cmp	r3, #1
34021c9e:	d920      	bls.n	34021ce2 <_tx_mutex_put+0x242>
                        {

                            /* Is priority inheritance in effect?  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34021ca0:	687b      	ldr	r3, [r7, #4]
34021ca2:	691b      	ldr	r3, [r3, #16]
34021ca4:	2b01      	cmp	r3, #1
34021ca6:	d11c      	bne.n	34021ce2 <_tx_mutex_put+0x242>
                                   at the front of the suspension list.  */

#ifndef TX_NOT_INTERRUPTABLE

                                /* Temporarily disable preemption.  */
                                _tx_thread_preempt_disable++;
34021ca8:	4b2e      	ldr	r3, [pc, #184]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021caa:	681b      	ldr	r3, [r3, #0]
34021cac:	3301      	adds	r3, #1
34021cae:	4a2d      	ldr	r2, [pc, #180]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021cb0:	6013      	str	r3, [r2, #0]
34021cb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021cb6:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021cb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021cba:	f383 8810 	msr	PRIMASK, r3
}
34021cbe:	bf00      	nop
                                do
                                {
                                    status =  _tx_mutex_prioritize(mutex_ptr);
                                } while (status != TX_SUCCESS);
#else
                                _tx_mutex_prioritize(mutex_ptr);
34021cc0:	6878      	ldr	r0, [r7, #4]
34021cc2:	f7ff fd6f 	bl	340217a4 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021cc6:	f3ef 8310 	mrs	r3, PRIMASK
34021cca:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
34021ccc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
34021cce:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
34021cd0:	b672      	cpsid	i
    return(int_posture);
34021cd2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
                                TX_MUTEX_PUT_EXTENSION_1

#ifndef TX_NOT_INTERRUPTABLE

                                /* Disable interrupts.  */
                                TX_DISABLE
34021cd4:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                                /* Back off the preemption disable.  */
                                _tx_thread_preempt_disable--;
34021cd8:	4b22      	ldr	r3, [pc, #136]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021cda:	681b      	ldr	r3, [r3, #0]
34021cdc:	3b01      	subs	r3, #1
34021cde:	4a21      	ldr	r2, [pc, #132]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021ce0:	6013      	str	r3, [r2, #0]
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
34021ce2:	687b      	ldr	r3, [r7, #4]
34021ce4:	699b      	ldr	r3, [r3, #24]
34021ce6:	2b00      	cmp	r3, #0
34021ce8:	d13e      	bne.n	34021d68 <_tx_mutex_put+0x2c8>
                            /* No, there are no longer any threads waiting on the mutex.  */

#ifndef TX_NOT_INTERRUPTABLE

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34021cea:	4b1e      	ldr	r3, [pc, #120]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021cec:	681b      	ldr	r3, [r3, #0]
34021cee:	3301      	adds	r3, #1
34021cf0:	4a1c      	ldr	r2, [pc, #112]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021cf2:	6013      	str	r3, [r2, #0]
34021cf4:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021cf8:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021cfa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34021cfc:	f383 8810 	msr	PRIMASK, r3
}
34021d00:	bf00      	nop
                            /* Mutex is not owned, but it is possible that a thread that
                               caused a priority inheritance to occur is no longer waiting
                               on the mutex.  */

                            /* Setup the highest priority waiting thread.  */
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
34021d02:	687b      	ldr	r3, [r7, #4]
34021d04:	2220      	movs	r2, #32
34021d06:	629a      	str	r2, [r3, #40]	@ 0x28

                            /* Determine if we need to restore priority.  */
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
34021d08:	687b      	ldr	r3, [r7, #4]
34021d0a:	68db      	ldr	r3, [r3, #12]
34021d0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021d0e:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
34021d12:	429a      	cmp	r2, r3
34021d14:	d006      	beq.n	34021d24 <_tx_mutex_put+0x284>
                            {

                                /* Yes, restore the priority of thread.  */
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
34021d16:	687b      	ldr	r3, [r7, #4]
34021d18:	68db      	ldr	r3, [r3, #12]
34021d1a:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
34021d1e:	4618      	mov	r0, r3
34021d20:	f7ff fdf2 	bl	34021908 <_tx_mutex_priority_change>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021d24:	f3ef 8310 	mrs	r3, PRIMASK
34021d28:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34021d2a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    int_posture = __get_interrupt_posture();
34021d2c:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSID i" : : : "memory");
34021d2e:	b672      	cpsid	i
    return(int_posture);
34021d30:	6a3b      	ldr	r3, [r7, #32]
                            }

#ifndef TX_NOT_INTERRUPTABLE

                            /* Disable interrupts again.  */
                            TX_DISABLE
34021d32:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                            /* Back off the preemption disable.  */
                            _tx_thread_preempt_disable--;
34021d36:	4b0b      	ldr	r3, [pc, #44]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021d38:	681b      	ldr	r3, [r3, #0]
34021d3a:	3b01      	subs	r3, #1
34021d3c:	4a09      	ldr	r2, [pc, #36]	@ (34021d64 <_tx_mutex_put+0x2c4>)
34021d3e:	6013      	str	r3, [r2, #0]
#endif

                            /* Set the mutex owner to NULL.  */
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
34021d40:	687b      	ldr	r3, [r7, #4]
34021d42:	2200      	movs	r2, #0
34021d44:	60da      	str	r2, [r3, #12]
34021d46:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021d4a:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021d4c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021d4e:	f383 8810 	msr	PRIMASK, r3
}
34021d52:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Check for preemption.  */
                            _tx_thread_system_preempt_check();
34021d54:	f000 fdc0 	bl	340228d8 <_tx_thread_system_preempt_check>

                            /* Set status to success.  */
                            status =  TX_SUCCESS;
34021d58:	2300      	movs	r3, #0
34021d5a:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34021d5e:	e0bd      	b.n	34021edc <_tx_mutex_put+0x43c>
34021d60:	3404aaf0 	.word	0x3404aaf0
34021d64:	3404ab8c 	.word	0x3404ab8c
                        }
                        else
                        {

                            /* Pickup the thread at the front of the suspension list.  */
                            thread_ptr =  mutex_ptr -> tx_mutex_suspension_list;
34021d68:	687b      	ldr	r3, [r7, #4]
34021d6a:	699b      	ldr	r3, [r3, #24]
34021d6c:	67fb      	str	r3, [r7, #124]	@ 0x7c

                            /* Save the previous ownership information, if inheritance is
                               in effect.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34021d6e:	687b      	ldr	r3, [r7, #4]
34021d70:	691b      	ldr	r3, [r3, #16]
34021d72:	2b01      	cmp	r3, #1
34021d74:	d10a      	bne.n	34021d8c <_tx_mutex_put+0x2ec>
                            {

                                /* Remember the old mutex owner.  */
                                old_owner =  mutex_ptr -> tx_mutex_owner;
34021d76:	687b      	ldr	r3, [r7, #4]
34021d78:	68db      	ldr	r3, [r3, #12]
34021d7a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90

                                /* Setup owner thread priority information.  */
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
34021d7e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021d80:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021d82:	687b      	ldr	r3, [r7, #4]
34021d84:	615a      	str	r2, [r3, #20]

                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
34021d86:	687b      	ldr	r3, [r7, #4]
34021d88:	2220      	movs	r2, #32
34021d8a:	629a      	str	r2, [r3, #40]	@ 0x28
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
34021d8c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021d8e:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
34021d92:	673b      	str	r3, [r7, #112]	@ 0x70

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
34021d94:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34021d96:	2b00      	cmp	r3, #0
34021d98:	d10a      	bne.n	34021db0 <_tx_mutex_put+0x310>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
34021d9a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021d9c:	687a      	ldr	r2, [r7, #4]
34021d9e:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
34021da2:	687b      	ldr	r3, [r7, #4]
34021da4:	687a      	ldr	r2, [r7, #4]
34021da6:	62da      	str	r2, [r3, #44]	@ 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
34021da8:	687b      	ldr	r3, [r7, #4]
34021daa:	687a      	ldr	r2, [r7, #4]
34021dac:	631a      	str	r2, [r3, #48]	@ 0x30
34021dae:	e016      	b.n	34021dde <_tx_mutex_put+0x33e>
                            {

                                /* Non-empty list. Link up the mutex.  */

                                /* Pickup tail pointer.  */
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
34021db0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021db2:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34021db6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
34021dba:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021dbe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34021dc0:	677b      	str	r3, [r7, #116]	@ 0x74

                                /* Place the owned mutex in the list.  */
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
34021dc2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34021dc6:	687a      	ldr	r2, [r7, #4]
34021dc8:	631a      	str	r2, [r3, #48]	@ 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
34021dca:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34021dcc:	687a      	ldr	r2, [r7, #4]
34021dce:	62da      	str	r2, [r3, #44]	@ 0x2c

                                /* Setup this mutex's next and previous created links.  */
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
34021dd0:	687b      	ldr	r3, [r7, #4]
34021dd2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
34021dd4:	631a      	str	r2, [r3, #48]	@ 0x30
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
34021dd6:	687b      	ldr	r3, [r7, #4]
34021dd8:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34021ddc:	62da      	str	r2, [r3, #44]	@ 0x2c
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
34021dde:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34021de0:	1c5a      	adds	r2, r3, #1
34021de2:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021de4:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0

                            /* Mark the Mutex as owned and fill in the corresponding information.  */
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
34021de8:	687b      	ldr	r3, [r7, #4]
34021dea:	2201      	movs	r2, #1
34021dec:	609a      	str	r2, [r3, #8]
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;
34021dee:	687b      	ldr	r3, [r7, #4]
34021df0:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
34021df2:	60da      	str	r2, [r3, #12]

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
34021df4:	687b      	ldr	r3, [r7, #4]
34021df6:	69db      	ldr	r3, [r3, #28]
34021df8:	1e5a      	subs	r2, r3, #1
34021dfa:	687b      	ldr	r3, [r7, #4]
34021dfc:	61da      	str	r2, [r3, #28]

                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
34021dfe:	687b      	ldr	r3, [r7, #4]
34021e00:	69db      	ldr	r3, [r3, #28]
34021e02:	66fb      	str	r3, [r7, #108]	@ 0x6c

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
34021e04:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34021e06:	2b00      	cmp	r3, #0
34021e08:	d103      	bne.n	34021e12 <_tx_mutex_put+0x372>
                            {

                                /* Yes, the only suspended thread.  */

                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
34021e0a:	687b      	ldr	r3, [r7, #4]
34021e0c:	2200      	movs	r2, #0
34021e0e:	619a      	str	r2, [r3, #24]
34021e10:	e00e      	b.n	34021e30 <_tx_mutex_put+0x390>
                            {

                                /* At least one more thread is on the same expiration list.  */

                                /* Update the list head pointer.  */
                                next_thread =                                  thread_ptr -> tx_thread_suspended_next;
34021e12:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021e14:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34021e16:	66bb      	str	r3, [r7, #104]	@ 0x68
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
34021e18:	687b      	ldr	r3, [r7, #4]
34021e1a:	6eba      	ldr	r2, [r7, #104]	@ 0x68
34021e1c:	619a      	str	r2, [r3, #24]

                                /* Update the links of the adjacent threads.  */
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
34021e1e:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021e20:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34021e22:	667b      	str	r3, [r7, #100]	@ 0x64
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
34021e24:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34021e26:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34021e28:	675a      	str	r2, [r3, #116]	@ 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
34021e2a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34021e2c:	6eba      	ldr	r2, [r7, #104]	@ 0x68
34021e2e:	671a      	str	r2, [r3, #112]	@ 0x70
                            }

                            /* Prepare for resumption of the first thread.  */

                            /* Clear cleanup routine to avoid timeout.  */
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34021e30:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021e32:	2200      	movs	r2, #0
34021e34:	669a      	str	r2, [r3, #104]	@ 0x68

                            /* Put return status into the thread control block.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34021e36:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34021e38:	2200      	movs	r2, #0
34021e3a:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34021e3e:	4b2a      	ldr	r3, [pc, #168]	@ (34021ee8 <_tx_mutex_put+0x448>)
34021e40:	681b      	ldr	r3, [r3, #0]
34021e42:	3301      	adds	r3, #1
34021e44:	4a28      	ldr	r2, [pc, #160]	@ (34021ee8 <_tx_mutex_put+0x448>)
34021e46:	6013      	str	r3, [r2, #0]
34021e48:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021e4c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021e4e:	69fb      	ldr	r3, [r7, #28]
34021e50:	f383 8810 	msr	PRIMASK, r3
}
34021e54:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
34021e56:	687b      	ldr	r3, [r7, #4]
34021e58:	691b      	ldr	r3, [r3, #16]
34021e5a:	2b01      	cmp	r3, #1
34021e5c:	d12d      	bne.n	34021eba <_tx_mutex_put+0x41a>
                            {

                                /* Yes, priority inheritance is requested.  */

                                /* Determine if there are any more threads still suspended on the mutex.  */
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
34021e5e:	687b      	ldr	r3, [r7, #4]
34021e60:	69db      	ldr	r3, [r3, #28]
34021e62:	2b00      	cmp	r3, #0
34021e64:	d01c      	beq.n	34021ea0 <_tx_mutex_put+0x400>
                                    do
                                    {
                                        status =  _tx_mutex_prioritize(mutex_ptr);
                                    } while (status != TX_SUCCESS);
#else
                                    _tx_mutex_prioritize(mutex_ptr);
34021e66:	6878      	ldr	r0, [r7, #4]
34021e68:	f7ff fc9c 	bl	340217a4 <_tx_mutex_prioritize>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021e6c:	f3ef 8310 	mrs	r3, PRIMASK
34021e70:	61bb      	str	r3, [r7, #24]
    return(posture);
34021e72:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34021e74:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34021e76:	b672      	cpsid	i
    return(int_posture);
34021e78:	697b      	ldr	r3, [r7, #20]

                                    /* Optional processing extension.  */
                                    TX_MUTEX_PUT_EXTENSION_2

                                    /* Disable interrupts.  */
                                    TX_DISABLE
34021e7a:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94

                                    /* Determine if there still are threads suspended for this mutex.  */
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
34021e7e:	687b      	ldr	r3, [r7, #4]
34021e80:	699b      	ldr	r3, [r3, #24]
34021e82:	663b      	str	r3, [r7, #96]	@ 0x60
                                    if (suspended_thread != TX_NULL)
34021e84:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34021e86:	2b00      	cmp	r3, #0
34021e88:	d003      	beq.n	34021e92 <_tx_mutex_put+0x3f2>
                                    {

                                        /* Setup the highest priority thread waiting on this mutex.  */
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
34021e8a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34021e8c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34021e8e:	687b      	ldr	r3, [r7, #4]
34021e90:	629a      	str	r2, [r3, #40]	@ 0x28
34021e92:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021e96:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021e98:	693b      	ldr	r3, [r7, #16]
34021e9a:	f383 8810 	msr	PRIMASK, r3
}
34021e9e:	bf00      	nop

                                /* Restore previous priority needs to be restored after priority
                                   inheritance.  */

                                /* Is the priority different?  */
                                if (old_owner -> tx_thread_priority != old_priority)
34021ea0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34021ea4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34021ea6:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
34021eaa:	429a      	cmp	r2, r3
34021eac:	d005      	beq.n	34021eba <_tx_mutex_put+0x41a>
                                {

                                    /* Restore the priority of thread.  */
                                    _tx_mutex_priority_change(old_owner, old_priority);
34021eae:	f8d7 108c 	ldr.w	r1, [r7, #140]	@ 0x8c
34021eb2:	f8d7 0090 	ldr.w	r0, [r7, #144]	@ 0x90
34021eb6:	f7ff fd27 	bl	34021908 <_tx_mutex_priority_change>
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
34021eba:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
34021ebc:	f000 fd46 	bl	3402294c <_tx_thread_system_resume>
#endif

                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
34021ec0:	2300      	movs	r3, #0
34021ec2:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
34021ec6:	e009      	b.n	34021edc <_tx_mutex_put+0x43c>
34021ec8:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
34021ecc:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021ece:	68fb      	ldr	r3, [r7, #12]
34021ed0:	f383 8810 	msr	PRIMASK, r3
}
34021ed4:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Caller does not own the mutex.  */
        status =  TX_NOT_OWNED;
34021ed6:	231e      	movs	r3, #30
34021ed8:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    }

    /* Return the completion status.  */
    return(status);
34021edc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
}
34021ee0:	4618      	mov	r0, r3
34021ee2:	3798      	adds	r7, #152	@ 0x98
34021ee4:	46bd      	mov	sp, r7
34021ee6:	bd80      	pop	{r7, pc}
34021ee8:	3404ab8c 	.word	0x3404ab8c

34021eec <_tx_semaphore_ceiling_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_ceiling_put(TX_SEMAPHORE *semaphore_ptr, ULONG ceiling)
{
34021eec:	b580      	push	{r7, lr}
34021eee:	b08e      	sub	sp, #56	@ 0x38
34021ef0:	af00      	add	r7, sp, #0
34021ef2:	6078      	str	r0, [r7, #4]
34021ef4:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
34021ef6:	2300      	movs	r3, #0
34021ef8:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021efa:	f3ef 8310 	mrs	r3, PRIMASK
34021efe:	61bb      	str	r3, [r7, #24]
    return(posture);
34021f00:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34021f02:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
34021f04:	b672      	cpsid	i
    return(int_posture);
34021f06:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
34021f08:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_CEILING_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
34021f0a:	687b      	ldr	r3, [r7, #4]
34021f0c:	691b      	ldr	r3, [r3, #16]
34021f0e:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
34021f10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34021f12:	2b00      	cmp	r3, #0
34021f14:	d124      	bne.n	34021f60 <_tx_semaphore_ceiling_put+0x74>
    {

        /* Determine if the ceiling has been exceeded.  */
        if (semaphore_ptr -> tx_semaphore_count >= ceiling)
34021f16:	687b      	ldr	r3, [r7, #4]
34021f18:	689b      	ldr	r3, [r3, #8]
34021f1a:	683a      	ldr	r2, [r7, #0]
34021f1c:	429a      	cmp	r2, r3
34021f1e:	d808      	bhi.n	34021f32 <_tx_semaphore_ceiling_put+0x46>
34021f20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021f22:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021f24:	693b      	ldr	r3, [r7, #16]
34021f26:	f383 8810 	msr	PRIMASK, r3
}
34021f2a:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Return an error.  */
            status =  TX_CEILING_EXCEEDED;
34021f2c:	2321      	movs	r3, #33	@ 0x21
34021f2e:	637b      	str	r3, [r7, #52]	@ 0x34
34021f30:	e053      	b.n	34021fda <_tx_semaphore_ceiling_put+0xee>
        }
        else
        {

            /* Increment the semaphore count.  */
            semaphore_ptr -> tx_semaphore_count++;
34021f32:	687b      	ldr	r3, [r7, #4]
34021f34:	689b      	ldr	r3, [r3, #8]
34021f36:	1c5a      	adds	r2, r3, #1
34021f38:	687b      	ldr	r3, [r7, #4]
34021f3a:	609a      	str	r2, [r3, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Pickup the application notify function.  */
            semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
34021f3c:	687b      	ldr	r3, [r7, #4]
34021f3e:	69db      	ldr	r3, [r3, #28]
34021f40:	61fb      	str	r3, [r7, #28]
34021f42:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021f44:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021f46:	68fb      	ldr	r3, [r7, #12]
34021f48:	f383 8810 	msr	PRIMASK, r3
}
34021f4c:	bf00      	nop
            TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if notification is required.  */
            if (semaphore_put_notify != TX_NULL)
34021f4e:	69fb      	ldr	r3, [r7, #28]
34021f50:	2b00      	cmp	r3, #0
34021f52:	d002      	beq.n	34021f5a <_tx_semaphore_ceiling_put+0x6e>
            {

                /* Yes, call the appropriate notify callback function.  */
                (semaphore_put_notify)(semaphore_ptr);
34021f54:	69fb      	ldr	r3, [r7, #28]
34021f56:	6878      	ldr	r0, [r7, #4]
34021f58:	4798      	blx	r3
            }
#endif

            /* Return successful completion status.  */
            status =  TX_SUCCESS;
34021f5a:	2300      	movs	r3, #0
34021f5c:	637b      	str	r3, [r7, #52]	@ 0x34
34021f5e:	e03c      	b.n	34021fda <_tx_semaphore_ceiling_put+0xee>
    {

        /* Remove the suspended thread from the list.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
34021f60:	687b      	ldr	r3, [r7, #4]
34021f62:	68db      	ldr	r3, [r3, #12]
34021f64:	62bb      	str	r3, [r7, #40]	@ 0x28

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
34021f66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34021f68:	3b01      	subs	r3, #1
34021f6a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if (suspended_count == TX_NO_SUSPENSIONS)
34021f6c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34021f6e:	2b00      	cmp	r3, #0
34021f70:	d103      	bne.n	34021f7a <_tx_semaphore_ceiling_put+0x8e>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34021f72:	687b      	ldr	r3, [r7, #4]
34021f74:	2200      	movs	r2, #0
34021f76:	60da      	str	r2, [r3, #12]
34021f78:	e00e      	b.n	34021f98 <_tx_semaphore_ceiling_put+0xac>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
34021f7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021f7c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34021f7e:	627b      	str	r3, [r7, #36]	@ 0x24
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
34021f80:	687b      	ldr	r3, [r7, #4]
34021f82:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34021f84:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34021f86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021f88:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34021f8a:	623b      	str	r3, [r7, #32]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
34021f8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34021f8e:	6a3a      	ldr	r2, [r7, #32]
34021f90:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
34021f92:	6a3b      	ldr	r3, [r7, #32]
34021f94:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34021f96:	671a      	str	r2, [r3, #112]	@ 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
34021f98:	687b      	ldr	r3, [r7, #4]
34021f9a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34021f9c:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34021f9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021fa0:	2200      	movs	r2, #0
34021fa2:	669a      	str	r2, [r3, #104]	@ 0x68

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34021fa4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34021fa6:	2200      	movs	r2, #0
34021fa8:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
34021fac:	687b      	ldr	r3, [r7, #4]
34021fae:	69db      	ldr	r3, [r3, #28]
34021fb0:	61fb      	str	r3, [r7, #28]
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
34021fb2:	4b0c      	ldr	r3, [pc, #48]	@ (34021fe4 <_tx_semaphore_ceiling_put+0xf8>)
34021fb4:	681b      	ldr	r3, [r3, #0]
34021fb6:	3301      	adds	r3, #1
34021fb8:	4a0a      	ldr	r2, [pc, #40]	@ (34021fe4 <_tx_semaphore_ceiling_put+0xf8>)
34021fba:	6013      	str	r3, [r2, #0]
34021fbc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34021fbe:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34021fc0:	68bb      	ldr	r3, [r7, #8]
34021fc2:	f383 8810 	msr	PRIMASK, r3
}
34021fc6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
34021fc8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
34021fca:	f000 fcbf 	bl	3402294c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
34021fce:	69fb      	ldr	r3, [r7, #28]
34021fd0:	2b00      	cmp	r3, #0
34021fd2:	d002      	beq.n	34021fda <_tx_semaphore_ceiling_put+0xee>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
34021fd4:	69fb      	ldr	r3, [r7, #28]
34021fd6:	6878      	ldr	r0, [r7, #4]
34021fd8:	4798      	blx	r3
        }
#endif
    }

    /* Return successful completion.  */
    return(status);
34021fda:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
34021fdc:	4618      	mov	r0, r3
34021fde:	3738      	adds	r7, #56	@ 0x38
34021fe0:	46bd      	mov	sp, r7
34021fe2:	bd80      	pop	{r7, pc}
34021fe4:	3404ab8c 	.word	0x3404ab8c

34021fe8 <_tx_semaphore_cleanup>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
34021fe8:	b580      	push	{r7, lr}
34021fea:	b08e      	sub	sp, #56	@ 0x38
34021fec:	af00      	add	r7, sp, #0
34021fee:	6078      	str	r0, [r7, #4]
34021ff0:	6039      	str	r1, [r7, #0]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34021ff2:	f3ef 8310 	mrs	r3, PRIMASK
34021ff6:	623b      	str	r3, [r7, #32]
    return(posture);
34021ff8:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
34021ffa:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
34021ffc:	b672      	cpsid	i
    return(int_posture);
34021ffe:	69fb      	ldr	r3, [r7, #28]


#ifndef TX_NOT_INTERRUPTABLE

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE
34022000:	637b      	str	r3, [r7, #52]	@ 0x34

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
34022002:	687b      	ldr	r3, [r7, #4]
34022004:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34022006:	4a33      	ldr	r2, [pc, #204]	@ (340220d4 <_tx_semaphore_cleanup+0xec>)
34022008:	4293      	cmp	r3, r2
3402200a:	d158      	bne.n	340220be <_tx_semaphore_cleanup+0xd6>
    {

        /* Check for valid suspension sequence.  */
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
3402200c:	687b      	ldr	r3, [r7, #4]
3402200e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34022012:	683a      	ldr	r2, [r7, #0]
34022014:	429a      	cmp	r2, r3
34022016:	d152      	bne.n	340220be <_tx_semaphore_cleanup+0xd6>
        {

            /* Setup pointer to semaphore control block.  */
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
34022018:	687b      	ldr	r3, [r7, #4]
3402201a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3402201c:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for a NULL semaphore pointer.  */
            if (semaphore_ptr != TX_NULL)
3402201e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022020:	2b00      	cmp	r3, #0
34022022:	d04c      	beq.n	340220be <_tx_semaphore_cleanup+0xd6>
            {

                /* Check for a valid semaphore ID.  */
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
34022024:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022026:	681b      	ldr	r3, [r3, #0]
34022028:	4a2b      	ldr	r2, [pc, #172]	@ (340220d8 <_tx_semaphore_cleanup+0xf0>)
3402202a:	4293      	cmp	r3, r2
3402202c:	d147      	bne.n	340220be <_tx_semaphore_cleanup+0xd6>
                {

                    /* Determine if there are any thread suspensions.  */
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
3402202e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022030:	691b      	ldr	r3, [r3, #16]
34022032:	2b00      	cmp	r3, #0
34022034:	d043      	beq.n	340220be <_tx_semaphore_cleanup+0xd6>
#endif

                        /* Yes, we still have thread suspension!  */

                        /* Clear the suspension cleanup flag.  */
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34022036:	687b      	ldr	r3, [r7, #4]
34022038:	2200      	movs	r2, #0
3402203a:	669a      	str	r2, [r3, #104]	@ 0x68

                        /* Decrement the suspended count.  */
                        semaphore_ptr -> tx_semaphore_suspended_count--;
3402203c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402203e:	691b      	ldr	r3, [r3, #16]
34022040:	1e5a      	subs	r2, r3, #1
34022042:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022044:	611a      	str	r2, [r3, #16]

                        /* Pickup the suspended count.  */
                        suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
34022046:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022048:	691b      	ldr	r3, [r3, #16]
3402204a:	62fb      	str	r3, [r7, #44]	@ 0x2c

                        /* Remove the suspended thread from the list.  */

                        /* See if this is the only suspended thread on the list.  */
                        if (suspended_count == TX_NO_SUSPENSIONS)
3402204c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402204e:	2b00      	cmp	r3, #0
34022050:	d103      	bne.n	3402205a <_tx_semaphore_cleanup+0x72>
                        {

                            /* Yes, the only suspended thread.  */

                            /* Update the head pointer.  */
                            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34022052:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022054:	2200      	movs	r2, #0
34022056:	60da      	str	r2, [r3, #12]
34022058:	e013      	b.n	34022082 <_tx_semaphore_cleanup+0x9a>
                        {

                            /* At least one more thread is on the same suspension list.  */

                            /* Update the links of the adjacent threads.  */
                            next_thread =                                   thread_ptr -> tx_thread_suspended_next;
3402205a:	687b      	ldr	r3, [r7, #4]
3402205c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3402205e:	62bb      	str	r3, [r7, #40]	@ 0x28
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
34022060:	687b      	ldr	r3, [r7, #4]
34022062:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34022064:	627b      	str	r3, [r7, #36]	@ 0x24
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
34022066:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34022068:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3402206a:	675a      	str	r2, [r3, #116]	@ 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
3402206c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402206e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34022070:	671a      	str	r2, [r3, #112]	@ 0x70

                            /* Determine if we need to update the head pointer.  */
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
34022072:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022074:	68db      	ldr	r3, [r3, #12]
34022076:	687a      	ldr	r2, [r7, #4]
34022078:	429a      	cmp	r2, r3
3402207a:	d102      	bne.n	34022082 <_tx_semaphore_cleanup+0x9a>
                            {

                                /* Update the list head pointer.  */
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
3402207c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402207e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34022080:	60da      	str	r2, [r3, #12]
                            }
                        }

                        /* Now we need to determine if this cleanup is from a terminate, timeout,
                           or from a wait abort.  */
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
34022082:	687b      	ldr	r3, [r7, #4]
34022084:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022086:	2b06      	cmp	r3, #6
34022088:	d119      	bne.n	340220be <_tx_semaphore_cleanup+0xd6>
                            /* Increment the number of timeouts on this semaphore.  */
                            semaphore_ptr -> tx_semaphore_performance_timeout_count++;
#endif

                            /* Setup return status.  */
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
3402208a:	687b      	ldr	r3, [r7, #4]
3402208c:	220d      	movs	r2, #13
3402208e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
                            /* Resume the thread!  */
                            _tx_thread_system_ni_resume(thread_ptr);
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
34022092:	4b12      	ldr	r3, [pc, #72]	@ (340220dc <_tx_semaphore_cleanup+0xf4>)
34022094:	681b      	ldr	r3, [r3, #0]
34022096:	3301      	adds	r3, #1
34022098:	4a10      	ldr	r2, [pc, #64]	@ (340220dc <_tx_semaphore_cleanup+0xf4>)
3402209a:	6013      	str	r3, [r2, #0]
3402209c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3402209e:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340220a0:	693b      	ldr	r3, [r7, #16]
340220a2:	f383 8810 	msr	PRIMASK, r3
}
340220a6:	bf00      	nop

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Resume the thread!  */
                            _tx_thread_system_resume(thread_ptr);
340220a8:	6878      	ldr	r0, [r7, #4]
340220aa:	f000 fc4f 	bl	3402294c <_tx_thread_system_resume>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340220ae:	f3ef 8310 	mrs	r3, PRIMASK
340220b2:	61bb      	str	r3, [r7, #24]
    return(posture);
340220b4:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
340220b6:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
340220b8:	b672      	cpsid	i
    return(int_posture);
340220ba:	697b      	ldr	r3, [r7, #20]

                            /* Disable interrupts.  */
                            TX_DISABLE
340220bc:	637b      	str	r3, [r7, #52]	@ 0x34
340220be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340220c0:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340220c2:	68fb      	ldr	r3, [r7, #12]
340220c4:	f383 8810 	msr	PRIMASK, r3
}
340220c8:	bf00      	nop
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
340220ca:	bf00      	nop
340220cc:	3738      	adds	r7, #56	@ 0x38
340220ce:	46bd      	mov	sp, r7
340220d0:	bd80      	pop	{r7, pc}
340220d2:	bf00      	nop
340220d4:	34021fe9 	.word	0x34021fe9
340220d8:	53454d41 	.word	0x53454d41
340220dc:	3404ab8c 	.word	0x3404ab8c

340220e0 <_tx_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
340220e0:	b580      	push	{r7, lr}
340220e2:	b08a      	sub	sp, #40	@ 0x28
340220e4:	af00      	add	r7, sp, #0
340220e6:	60f8      	str	r0, [r7, #12]
340220e8:	60b9      	str	r1, [r7, #8]
340220ea:	607a      	str	r2, [r7, #4]
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
340220ec:	2220      	movs	r2, #32
340220ee:	2100      	movs	r1, #0
340220f0:	68f8      	ldr	r0, [r7, #12]
340220f2:	f005 f84f 	bl	34027194 <memset>

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
340220f6:	68fb      	ldr	r3, [r7, #12]
340220f8:	68ba      	ldr	r2, [r7, #8]
340220fa:	605a      	str	r2, [r3, #4]
    semaphore_ptr -> tx_semaphore_count =            initial_count;
340220fc:	68fb      	ldr	r3, [r7, #12]
340220fe:	687a      	ldr	r2, [r7, #4]
34022100:	609a      	str	r2, [r3, #8]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022102:	f3ef 8310 	mrs	r3, PRIMASK
34022106:	61bb      	str	r3, [r7, #24]
    return(posture);
34022108:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
3402210a:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
3402210c:	b672      	cpsid	i
    return(int_posture);
3402210e:	697b      	ldr	r3, [r7, #20]

    /* Disable interrupts to place the semaphore on the created list.  */
    TX_DISABLE
34022110:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
34022112:	68fb      	ldr	r3, [r7, #12]
34022114:	4a18      	ldr	r2, [pc, #96]	@ (34022178 <_tx_semaphore_create+0x98>)
34022116:	601a      	str	r2, [r3, #0]

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
34022118:	4b18      	ldr	r3, [pc, #96]	@ (3402217c <_tx_semaphore_create+0x9c>)
3402211a:	681b      	ldr	r3, [r3, #0]
3402211c:	2b00      	cmp	r3, #0
3402211e:	d109      	bne.n	34022134 <_tx_semaphore_create+0x54>
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
34022120:	4a17      	ldr	r2, [pc, #92]	@ (34022180 <_tx_semaphore_create+0xa0>)
34022122:	68fb      	ldr	r3, [r7, #12]
34022124:	6013      	str	r3, [r2, #0]
        semaphore_ptr -> tx_semaphore_created_next =      semaphore_ptr;
34022126:	68fb      	ldr	r3, [r7, #12]
34022128:	68fa      	ldr	r2, [r7, #12]
3402212a:	615a      	str	r2, [r3, #20]
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
3402212c:	68fb      	ldr	r3, [r7, #12]
3402212e:	68fa      	ldr	r2, [r7, #12]
34022130:	619a      	str	r2, [r3, #24]
34022132:	e011      	b.n	34022158 <_tx_semaphore_create+0x78>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
34022134:	4b12      	ldr	r3, [pc, #72]	@ (34022180 <_tx_semaphore_create+0xa0>)
34022136:	681b      	ldr	r3, [r3, #0]
34022138:	623b      	str	r3, [r7, #32]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
3402213a:	6a3b      	ldr	r3, [r7, #32]
3402213c:	699b      	ldr	r3, [r3, #24]
3402213e:	61fb      	str	r3, [r7, #28]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
34022140:	6a3b      	ldr	r3, [r7, #32]
34022142:	68fa      	ldr	r2, [r7, #12]
34022144:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
34022146:	69fb      	ldr	r3, [r7, #28]
34022148:	68fa      	ldr	r2, [r7, #12]
3402214a:	615a      	str	r2, [r3, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
3402214c:	68fb      	ldr	r3, [r7, #12]
3402214e:	69fa      	ldr	r2, [r7, #28]
34022150:	619a      	str	r2, [r3, #24]
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
34022152:	68fb      	ldr	r3, [r7, #12]
34022154:	6a3a      	ldr	r2, [r7, #32]
34022156:	615a      	str	r2, [r3, #20]
    }

    /* Increment the created count.  */
    _tx_semaphore_created_count++;
34022158:	4b08      	ldr	r3, [pc, #32]	@ (3402217c <_tx_semaphore_create+0x9c>)
3402215a:	681b      	ldr	r3, [r3, #0]
3402215c:	3301      	adds	r3, #1
3402215e:	4a07      	ldr	r2, [pc, #28]	@ (3402217c <_tx_semaphore_create+0x9c>)
34022160:	6013      	str	r3, [r2, #0]
34022162:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022164:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022166:	693b      	ldr	r3, [r7, #16]
34022168:	f383 8810 	msr	PRIMASK, r3
}
3402216c:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
3402216e:	2300      	movs	r3, #0
}
34022170:	4618      	mov	r0, r3
34022172:	3728      	adds	r7, #40	@ 0x28
34022174:	46bd      	mov	sp, r7
34022176:	bd80      	pop	{r7, pc}
34022178:	53454d41 	.word	0x53454d41
3402217c:	3404aabc 	.word	0x3404aabc
34022180:	3404aab8 	.word	0x3404aab8

34022184 <_tx_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
34022184:	b580      	push	{r7, lr}
34022186:	b092      	sub	sp, #72	@ 0x48
34022188:	af00      	add	r7, sp, #0
3402218a:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402218c:	f3ef 8310 	mrs	r3, PRIMASK
34022190:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34022192:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
34022194:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
34022196:	b672      	cpsid	i
    return(int_posture);
34022198:	6abb      	ldr	r3, [r7, #40]	@ 0x28
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Disable interrupts to remove the semaphore from the created list.  */
    TX_DISABLE
3402219a:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_DELETE_INSERT

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
3402219c:	687b      	ldr	r3, [r7, #4]
3402219e:	2200      	movs	r2, #0
340221a0:	601a      	str	r2, [r3, #0]

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
340221a2:	4b3d      	ldr	r3, [pc, #244]	@ (34022298 <_tx_semaphore_delete+0x114>)
340221a4:	681b      	ldr	r3, [r3, #0]
340221a6:	3b01      	subs	r3, #1
340221a8:	4a3b      	ldr	r2, [pc, #236]	@ (34022298 <_tx_semaphore_delete+0x114>)
340221aa:	6013      	str	r3, [r2, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
340221ac:	4b3a      	ldr	r3, [pc, #232]	@ (34022298 <_tx_semaphore_delete+0x114>)
340221ae:	681b      	ldr	r3, [r3, #0]
340221b0:	2b00      	cmp	r3, #0
340221b2:	d103      	bne.n	340221bc <_tx_semaphore_delete+0x38>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
340221b4:	4b39      	ldr	r3, [pc, #228]	@ (3402229c <_tx_semaphore_delete+0x118>)
340221b6:	2200      	movs	r2, #0
340221b8:	601a      	str	r2, [r3, #0]
340221ba:	e013      	b.n	340221e4 <_tx_semaphore_delete+0x60>
    }
    else
    {

        /* Link-up the neighbors.  */
        next_semaphore =                                   semaphore_ptr -> tx_semaphore_created_next;
340221bc:	687b      	ldr	r3, [r7, #4]
340221be:	695b      	ldr	r3, [r3, #20]
340221c0:	63bb      	str	r3, [r7, #56]	@ 0x38
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
340221c2:	687b      	ldr	r3, [r7, #4]
340221c4:	699b      	ldr	r3, [r3, #24]
340221c6:	637b      	str	r3, [r7, #52]	@ 0x34
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
340221c8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340221ca:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
340221cc:	619a      	str	r2, [r3, #24]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
340221ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
340221d0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
340221d2:	615a      	str	r2, [r3, #20]

        /* See if we have to update the created list head pointer.  */
        if (_tx_semaphore_created_ptr == semaphore_ptr)
340221d4:	4b31      	ldr	r3, [pc, #196]	@ (3402229c <_tx_semaphore_delete+0x118>)
340221d6:	681b      	ldr	r3, [r3, #0]
340221d8:	687a      	ldr	r2, [r7, #4]
340221da:	429a      	cmp	r2, r3
340221dc:	d102      	bne.n	340221e4 <_tx_semaphore_delete+0x60>
        {

            /* Yes, move the head pointer to the next link. */
            _tx_semaphore_created_ptr =  next_semaphore;
340221de:	4a2f      	ldr	r2, [pc, #188]	@ (3402229c <_tx_semaphore_delete+0x118>)
340221e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340221e2:	6013      	str	r3, [r2, #0]
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
340221e4:	4b2e      	ldr	r3, [pc, #184]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
340221e6:	681b      	ldr	r3, [r3, #0]
340221e8:	3301      	adds	r3, #1
340221ea:	4a2d      	ldr	r2, [pc, #180]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
340221ec:	6013      	str	r3, [r2, #0]

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
340221ee:	687b      	ldr	r3, [r7, #4]
340221f0:	68db      	ldr	r3, [r3, #12]
340221f2:	647b      	str	r3, [r7, #68]	@ 0x44
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
340221f4:	687b      	ldr	r3, [r7, #4]
340221f6:	2200      	movs	r2, #0
340221f8:	60da      	str	r2, [r3, #12]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
340221fa:	687b      	ldr	r3, [r7, #4]
340221fc:	691b      	ldr	r3, [r3, #16]
340221fe:	643b      	str	r3, [r7, #64]	@ 0x40
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
34022200:	687b      	ldr	r3, [r7, #4]
34022202:	2200      	movs	r2, #0
34022204:	611a      	str	r2, [r3, #16]
34022206:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34022208:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402220a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402220c:	f383 8810 	msr	PRIMASK, r3
}
34022210:	bf00      	nop
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
34022212:	e024      	b.n	3402225e <_tx_semaphore_delete+0xda>
    {

        /* Decrement the suspension count.  */
        suspended_count--;
34022214:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022216:	3b01      	subs	r3, #1
34022218:	643b      	str	r3, [r7, #64]	@ 0x40
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402221a:	f3ef 8310 	mrs	r3, PRIMASK
3402221e:	61fb      	str	r3, [r7, #28]
    return(posture);
34022220:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34022222:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34022224:	b672      	cpsid	i
    return(int_posture);
34022226:	69bb      	ldr	r3, [r7, #24]

        /* Lockout interrupts.  */
        TX_DISABLE
34022228:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Clear the cleanup pointer, this prevents the timeout from doing
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
3402222a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402222c:	2200      	movs	r2, #0
3402222e:	669a      	str	r2, [r3, #104]	@ 0x68

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
34022230:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34022232:	2201      	movs	r2, #1
34022234:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

        /* Move the thread pointer ahead.  */
        next_thread =  thread_ptr -> tx_thread_suspended_next;
34022238:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402223a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3402223c:	633b      	str	r3, [r7, #48]	@ 0x30
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
3402223e:	4b18      	ldr	r3, [pc, #96]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
34022240:	681b      	ldr	r3, [r3, #0]
34022242:	3301      	adds	r3, #1
34022244:	4a16      	ldr	r2, [pc, #88]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
34022246:	6013      	str	r3, [r2, #0]
34022248:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3402224a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402224c:	6a3b      	ldr	r3, [r7, #32]
3402224e:	f383 8810 	msr	PRIMASK, r3
}
34022252:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
34022254:	6c78      	ldr	r0, [r7, #68]	@ 0x44
34022256:	f000 fb79 	bl	3402294c <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
3402225a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402225c:	647b      	str	r3, [r7, #68]	@ 0x44
    while (suspended_count != TX_NO_SUSPENSIONS)
3402225e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022260:	2b00      	cmp	r3, #0
34022262:	d1d7      	bne.n	34022214 <_tx_semaphore_delete+0x90>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022264:	f3ef 8310 	mrs	r3, PRIMASK
34022268:	613b      	str	r3, [r7, #16]
    return(posture);
3402226a:	693b      	ldr	r3, [r7, #16]
    int_posture = __get_interrupt_posture();
3402226c:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSID i" : : : "memory");
3402226e:	b672      	cpsid	i
    return(int_posture);
34022270:	68fb      	ldr	r3, [r7, #12]

    /* Execute Port-Specific completion processing. If needed, it is typically defined in tx_port.h.  */
    TX_SEMAPHORE_DELETE_PORT_COMPLETION(semaphore_ptr)

    /* Disable interrupts.  */
    TX_DISABLE
34022272:	63fb      	str	r3, [r7, #60]	@ 0x3c

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
34022274:	4b0a      	ldr	r3, [pc, #40]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
34022276:	681b      	ldr	r3, [r3, #0]
34022278:	3b01      	subs	r3, #1
3402227a:	4a09      	ldr	r2, [pc, #36]	@ (340222a0 <_tx_semaphore_delete+0x11c>)
3402227c:	6013      	str	r3, [r2, #0]
3402227e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34022280:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022282:	697b      	ldr	r3, [r7, #20]
34022284:	f383 8810 	msr	PRIMASK, r3
}
34022288:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
3402228a:	f000 fb25 	bl	340228d8 <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
3402228e:	2300      	movs	r3, #0
}
34022290:	4618      	mov	r0, r3
34022292:	3748      	adds	r7, #72	@ 0x48
34022294:	46bd      	mov	sp, r7
34022296:	bd80      	pop	{r7, pc}
34022298:	3404aabc 	.word	0x3404aabc
3402229c:	3404aab8 	.word	0x3404aab8
340222a0:	3404ab8c 	.word	0x3404ab8c

340222a4 <_tx_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
340222a4:	b580      	push	{r7, lr}
340222a6:	b08e      	sub	sp, #56	@ 0x38
340222a8:	af00      	add	r7, sp, #0
340222aa:	6078      	str	r0, [r7, #4]
340222ac:	6039      	str	r1, [r7, #0]
TX_THREAD       *previous_thread;
UINT            status;


    /* Default the status to TX_SUCCESS.  */
    status =  TX_SUCCESS;
340222ae:	2300      	movs	r3, #0
340222b0:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340222b2:	f3ef 8310 	mrs	r3, PRIMASK
340222b6:	623b      	str	r3, [r7, #32]
    return(posture);
340222b8:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
340222ba:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
340222bc:	b672      	cpsid	i
    return(int_posture);
340222be:	69fb      	ldr	r3, [r7, #28]

    /* Disable interrupts to get an instance from the semaphore.  */
    TX_DISABLE
340222c0:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
340222c2:	687b      	ldr	r3, [r7, #4]
340222c4:	689b      	ldr	r3, [r3, #8]
340222c6:	2b00      	cmp	r3, #0
340222c8:	d00a      	beq.n	340222e0 <_tx_semaphore_get+0x3c>
    {

        /* Decrement the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count--;
340222ca:	687b      	ldr	r3, [r7, #4]
340222cc:	689b      	ldr	r3, [r3, #8]
340222ce:	1e5a      	subs	r2, r3, #1
340222d0:	687b      	ldr	r3, [r7, #4]
340222d2:	609a      	str	r2, [r3, #8]
340222d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340222d6:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340222d8:	69bb      	ldr	r3, [r7, #24]
340222da:	f383 8810 	msr	PRIMASK, r3
}
340222de:	e068      	b.n	340223b2 <_tx_semaphore_get+0x10e>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
340222e0:	683b      	ldr	r3, [r7, #0]
340222e2:	2b00      	cmp	r3, #0
340222e4:	d05d      	beq.n	340223a2 <_tx_semaphore_get+0xfe>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
340222e6:	4b35      	ldr	r3, [pc, #212]	@ (340223bc <_tx_semaphore_get+0x118>)
340222e8:	681b      	ldr	r3, [r3, #0]
340222ea:	2b00      	cmp	r3, #0
340222ec:	d008      	beq.n	34022300 <_tx_semaphore_get+0x5c>
340222ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340222f0:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340222f2:	697b      	ldr	r3, [r7, #20]
340222f4:	f383 8810 	msr	PRIMASK, r3
}
340222f8:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_NO_INSTANCE;
340222fa:	230d      	movs	r3, #13
340222fc:	637b      	str	r3, [r7, #52]	@ 0x34
340222fe:	e058      	b.n	340223b2 <_tx_semaphore_get+0x10e>
            /* Increment the number of suspensions on this semaphore.  */
            semaphore_ptr -> tx_semaphore_performance_suspension_count++;
#endif

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
34022300:	4b2f      	ldr	r3, [pc, #188]	@ (340223c0 <_tx_semaphore_get+0x11c>)
34022302:	681b      	ldr	r3, [r3, #0]
34022304:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
34022306:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022308:	4a2e      	ldr	r2, [pc, #184]	@ (340223c4 <_tx_semaphore_get+0x120>)
3402230a:	669a      	str	r2, [r3, #104]	@ 0x68

            /* Setup cleanup information, i.e. this semaphore control
               block.  */
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
3402230c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402230e:	687a      	ldr	r2, [r7, #4]
34022310:	66da      	str	r2, [r3, #108]	@ 0x6c

#ifndef TX_NOT_INTERRUPTABLE

            /* Increment the suspension sequence number, which is used to identify
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
34022312:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022314:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34022318:	1c5a      	adds	r2, r3, #1
3402231a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402231c:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
#endif

            /* Setup suspension list.  */
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
34022320:	687b      	ldr	r3, [r7, #4]
34022322:	691b      	ldr	r3, [r3, #16]
34022324:	2b00      	cmp	r3, #0
34022326:	d109      	bne.n	3402233c <_tx_semaphore_get+0x98>
            {

                /* No other threads are suspended.  Setup the head pointer and
                   just setup this threads pointers to itself.  */
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
34022328:	687b      	ldr	r3, [r7, #4]
3402232a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3402232c:	60da      	str	r2, [r3, #12]
                thread_ptr -> tx_thread_suspended_next =                thread_ptr;
3402232e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022330:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34022332:	671a      	str	r2, [r3, #112]	@ 0x70
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
34022334:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022336:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34022338:	675a      	str	r2, [r3, #116]	@ 0x74
3402233a:	e011      	b.n	34022360 <_tx_semaphore_get+0xbc>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
3402233c:	687b      	ldr	r3, [r7, #4]
3402233e:	68db      	ldr	r3, [r3, #12]
34022340:	62bb      	str	r3, [r7, #40]	@ 0x28
                thread_ptr -> tx_thread_suspended_next =        next_thread;
34022342:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022344:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34022346:	671a      	str	r2, [r3, #112]	@ 0x70
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
34022348:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3402234a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3402234c:	627b      	str	r3, [r7, #36]	@ 0x24
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
3402234e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022350:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34022352:	675a      	str	r2, [r3, #116]	@ 0x74
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
34022354:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022356:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34022358:	671a      	str	r2, [r3, #112]	@ 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
3402235a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3402235c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3402235e:	675a      	str	r2, [r3, #116]	@ 0x74
            }

            /* Increment the number of suspensions.  */
            semaphore_ptr -> tx_semaphore_suspended_count++;
34022360:	687b      	ldr	r3, [r7, #4]
34022362:	691b      	ldr	r3, [r3, #16]
34022364:	1c5a      	adds	r2, r3, #1
34022366:	687b      	ldr	r3, [r7, #4]
34022368:	611a      	str	r2, [r3, #16]

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
3402236a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402236c:	2206      	movs	r2, #6
3402236e:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag.  */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34022370:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022372:	2201      	movs	r2, #1
34022374:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
34022376:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022378:	683a      	ldr	r2, [r7, #0]
3402237a:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
3402237c:	4b0f      	ldr	r3, [pc, #60]	@ (340223bc <_tx_semaphore_get+0x118>)
3402237e:	681b      	ldr	r3, [r3, #0]
34022380:	3301      	adds	r3, #1
34022382:	4a0e      	ldr	r2, [pc, #56]	@ (340223bc <_tx_semaphore_get+0x118>)
34022384:	6013      	str	r3, [r2, #0]
34022386:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022388:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402238a:	693b      	ldr	r3, [r7, #16]
3402238c:	f383 8810 	msr	PRIMASK, r3
}
34022390:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
34022392:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34022394:	f000 fbee 	bl	34022b74 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
34022398:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402239a:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
3402239e:	637b      	str	r3, [r7, #52]	@ 0x34
340223a0:	e007      	b.n	340223b2 <_tx_semaphore_get+0x10e>
340223a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340223a4:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340223a6:	68fb      	ldr	r3, [r7, #12]
340223a8:	f383 8810 	msr	PRIMASK, r3
}
340223ac:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Immediate return, return error completion.  */
        status =  TX_NO_INSTANCE;
340223ae:	230d      	movs	r3, #13
340223b0:	637b      	str	r3, [r7, #52]	@ 0x34
    }

    /* Return completion status.  */
    return(status);
340223b2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
340223b4:	4618      	mov	r0, r3
340223b6:	3738      	adds	r7, #56	@ 0x38
340223b8:	46bd      	mov	sp, r7
340223ba:	bd80      	pop	{r7, pc}
340223bc:	3404ab8c 	.word	0x3404ab8c
340223c0:	3404aaf0 	.word	0x3404aaf0
340223c4:	34021fe9 	.word	0x34021fe9

340223c8 <_tx_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
340223c8:	b580      	push	{r7, lr}
340223ca:	b08c      	sub	sp, #48	@ 0x30
340223cc:	af00      	add	r7, sp, #0
340223ce:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340223d0:	f3ef 8310 	mrs	r3, PRIMASK
340223d4:	617b      	str	r3, [r7, #20]
    return(posture);
340223d6:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
340223d8:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
340223da:	b672      	cpsid	i
    return(int_posture);
340223dc:	693b      	ldr	r3, [r7, #16]
TX_THREAD       *next_thread;
TX_THREAD       *previous_thread;


    /* Disable interrupts to put an instance back to the semaphore.  */
    TX_DISABLE
340223de:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
340223e0:	687b      	ldr	r3, [r7, #4]
340223e2:	691b      	ldr	r3, [r3, #16]
340223e4:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
340223e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340223e8:	2b00      	cmp	r3, #0
340223ea:	d114      	bne.n	34022416 <_tx_semaphore_put+0x4e>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
340223ec:	687b      	ldr	r3, [r7, #4]
340223ee:	689b      	ldr	r3, [r3, #8]
340223f0:	1c5a      	adds	r2, r3, #1
340223f2:	687b      	ldr	r3, [r7, #4]
340223f4:	609a      	str	r2, [r3, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
340223f6:	687b      	ldr	r3, [r7, #4]
340223f8:	69db      	ldr	r3, [r3, #28]
340223fa:	61bb      	str	r3, [r7, #24]
340223fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340223fe:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022400:	68fb      	ldr	r3, [r7, #12]
34022402:	f383 8810 	msr	PRIMASK, r3
}
34022406:	bf00      	nop
        TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
34022408:	69bb      	ldr	r3, [r7, #24]
3402240a:	2b00      	cmp	r3, #0
3402240c:	d040      	beq.n	34022490 <_tx_semaphore_put+0xc8>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
3402240e:	69bb      	ldr	r3, [r7, #24]
34022410:	6878      	ldr	r0, [r7, #4]
34022412:	4798      	blx	r3
34022414:	e03c      	b.n	34022490 <_tx_semaphore_put+0xc8>
    {

        /* A thread is suspended on this semaphore.  */

        /* Pickup the pointer to the first suspended thread.  */
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
34022416:	687b      	ldr	r3, [r7, #4]
34022418:	68db      	ldr	r3, [r3, #12]
3402241a:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Remove the suspended thread from the list.  */

        /* See if this is the only suspended thread on the list.  */
        suspended_count--;
3402241c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3402241e:	3b01      	subs	r3, #1
34022420:	62bb      	str	r3, [r7, #40]	@ 0x28
        if (suspended_count == TX_NO_SUSPENSIONS)
34022422:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34022424:	2b00      	cmp	r3, #0
34022426:	d103      	bne.n	34022430 <_tx_semaphore_put+0x68>
        {

            /* Yes, the only suspended thread.  */

            /* Update the head pointer.  */
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
34022428:	687b      	ldr	r3, [r7, #4]
3402242a:	2200      	movs	r2, #0
3402242c:	60da      	str	r2, [r3, #12]
3402242e:	e00e      	b.n	3402244e <_tx_semaphore_put+0x86>
        {

            /* At least one more thread is on the same expiration list.  */

            /* Update the list head pointer.  */
            next_thread =                                     thread_ptr -> tx_thread_suspended_next;
34022430:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022432:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34022434:	623b      	str	r3, [r7, #32]
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
34022436:	687b      	ldr	r3, [r7, #4]
34022438:	6a3a      	ldr	r2, [r7, #32]
3402243a:	60da      	str	r2, [r3, #12]

            /* Update the links of the adjacent threads.  */
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
3402243c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402243e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34022440:	61fb      	str	r3, [r7, #28]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
34022442:	6a3b      	ldr	r3, [r7, #32]
34022444:	69fa      	ldr	r2, [r7, #28]
34022446:	675a      	str	r2, [r3, #116]	@ 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
34022448:	69fb      	ldr	r3, [r7, #28]
3402244a:	6a3a      	ldr	r2, [r7, #32]
3402244c:	671a      	str	r2, [r3, #112]	@ 0x70
        }

        /* Decrement the suspension count.  */
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
3402244e:	687b      	ldr	r3, [r7, #4]
34022450:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34022452:	611a      	str	r2, [r3, #16]

        /* Prepare for resumption of the first thread.  */

        /* Clear cleanup routine to avoid timeout.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
34022454:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022456:	2200      	movs	r2, #0
34022458:	669a      	str	r2, [r3, #104]	@ 0x68

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
3402245a:	687b      	ldr	r3, [r7, #4]
3402245c:	69db      	ldr	r3, [r3, #28]
3402245e:	61bb      	str	r3, [r7, #24]
#endif

        /* Put return status into the thread control block.  */
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
34022460:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022462:	2200      	movs	r2, #0
34022464:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption.  */
        _tx_thread_preempt_disable++;
34022468:	4b0c      	ldr	r3, [pc, #48]	@ (3402249c <_tx_semaphore_put+0xd4>)
3402246a:	681b      	ldr	r3, [r3, #0]
3402246c:	3301      	adds	r3, #1
3402246e:	4a0b      	ldr	r2, [pc, #44]	@ (3402249c <_tx_semaphore_put+0xd4>)
34022470:	6013      	str	r3, [r2, #0]
34022472:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022474:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022476:	68bb      	ldr	r3, [r7, #8]
34022478:	f383 8810 	msr	PRIMASK, r3
}
3402247c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Resume thread.  */
        _tx_thread_system_resume(thread_ptr);
3402247e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34022480:	f000 fa64 	bl	3402294c <_tx_thread_system_resume>
#endif

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
34022484:	69bb      	ldr	r3, [r7, #24]
34022486:	2b00      	cmp	r3, #0
34022488:	d002      	beq.n	34022490 <_tx_semaphore_put+0xc8>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
3402248a:	69bb      	ldr	r3, [r7, #24]
3402248c:	6878      	ldr	r0, [r7, #4]
3402248e:	4798      	blx	r3
        }
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
34022490:	2300      	movs	r3, #0
}
34022492:	4618      	mov	r0, r3
34022494:	3730      	adds	r7, #48	@ 0x30
34022496:	46bd      	mov	sp, r7
34022498:	bd80      	pop	{r7, pc}
3402249a:	bf00      	nop
3402249c:	3404ab8c 	.word	0x3404ab8c

340224a0 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
340224a0:	b580      	push	{r7, lr}
340224a2:	b092      	sub	sp, #72	@ 0x48
340224a4:	af00      	add	r7, sp, #0
340224a6:	60f8      	str	r0, [r7, #12]
340224a8:	60b9      	str	r1, [r7, #8]
340224aa:	607a      	str	r2, [r7, #4]
340224ac:	603b      	str	r3, [r7, #0]
TX_INTERRUPT_SAVE_AREA

TX_THREAD               *next_thread;
TX_THREAD               *previous_thread;
TX_THREAD               *saved_thread_ptr;
UINT                    saved_threshold =  ((UINT) 0);
340224ae:	2300      	movs	r3, #0
340224b0:	643b      	str	r3, [r7, #64]	@ 0x40
#endif

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
340224b2:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
340224b4:	21ef      	movs	r1, #239	@ 0xef
340224b6:	6d38      	ldr	r0, [r7, #80]	@ 0x50
340224b8:	f004 fe6c 	bl	34027194 <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
340224bc:	22c0      	movs	r2, #192	@ 0xc0
340224be:	2100      	movs	r1, #0
340224c0:	68f8      	ldr	r0, [r7, #12]
340224c2:	f004 fe67 	bl	34027194 <memset>

    /* Place the supplied parameters into the thread's control block.  */
    thread_ptr -> tx_thread_name =              name_ptr;
340224c6:	68fb      	ldr	r3, [r7, #12]
340224c8:	68ba      	ldr	r2, [r7, #8]
340224ca:	629a      	str	r2, [r3, #40]	@ 0x28
    thread_ptr -> tx_thread_entry =             entry_function;
340224cc:	68fb      	ldr	r3, [r7, #12]
340224ce:	687a      	ldr	r2, [r7, #4]
340224d0:	645a      	str	r2, [r3, #68]	@ 0x44
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
340224d2:	68fb      	ldr	r3, [r7, #12]
340224d4:	683a      	ldr	r2, [r7, #0]
340224d6:	649a      	str	r2, [r3, #72]	@ 0x48
    thread_ptr -> tx_thread_stack_start =       stack_start;
340224d8:	68fb      	ldr	r3, [r7, #12]
340224da:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
340224dc:	60da      	str	r2, [r3, #12]
    thread_ptr -> tx_thread_stack_size =        stack_size;
340224de:	68fb      	ldr	r3, [r7, #12]
340224e0:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
340224e2:	615a      	str	r2, [r3, #20]
    thread_ptr -> tx_thread_priority =          priority;
340224e4:	68fb      	ldr	r3, [r7, #12]
340224e6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
340224e8:	62da      	str	r2, [r3, #44]	@ 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
340224ea:	68fb      	ldr	r3, [r7, #12]
340224ec:	6dba      	ldr	r2, [r7, #88]	@ 0x58
340224ee:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    thread_ptr -> tx_thread_time_slice =        time_slice;
340224f2:	68fb      	ldr	r3, [r7, #12]
340224f4:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
340224f6:	619a      	str	r2, [r3, #24]
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
340224f8:	68fb      	ldr	r3, [r7, #12]
340224fa:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
340224fc:	61da      	str	r2, [r3, #28]
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
340224fe:	68fb      	ldr	r3, [r7, #12]
34022500:	2220      	movs	r2, #32
34022502:	f8c3 209c 	str.w	r2, [r3, #156]	@ 0x9c

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
34022506:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
34022508:	63fb      	str	r3, [r7, #60]	@ 0x3c
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
3402250a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
3402250c:	3b01      	subs	r3, #1
3402250e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34022510:	4413      	add	r3, r2
34022512:	63fb      	str	r3, [r7, #60]	@ 0x3c
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
34022514:	68fb      	ldr	r3, [r7, #12]
34022516:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
34022518:	611a      	str	r2, [r3, #16]

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

    /* Preemption-threshold is enabled, setup accordingly.  */
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
3402251a:	68fb      	ldr	r3, [r7, #12]
3402251c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
3402251e:	63da      	str	r2, [r3, #60]	@ 0x3c
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
34022520:	68fb      	ldr	r3, [r7, #12]
34022522:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
34022524:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
34022528:	68fb      	ldr	r3, [r7, #12]
3402252a:	2203      	movs	r2, #3
3402252c:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
3402252e:	68fb      	ldr	r3, [r7, #12]
34022530:	4a48      	ldr	r2, [pc, #288]	@ (34022654 <_tx_thread_create+0x1b4>)
34022532:	655a      	str	r2, [r3, #84]	@ 0x54
34022534:	68fa      	ldr	r2, [r7, #12]
34022536:	68fb      	ldr	r3, [r7, #12]
34022538:	659a      	str	r2, [r3, #88]	@ 0x58
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
3402253a:	4947      	ldr	r1, [pc, #284]	@ (34022658 <_tx_thread_create+0x1b8>)
3402253c:	68f8      	ldr	r0, [r7, #12]
3402253e:	f7de f9db 	bl	340008f8 <_tx_thread_stack_build>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022542:	f3ef 8310 	mrs	r3, PRIMASK
34022546:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34022548:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
3402254a:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
3402254c:	b672      	cpsid	i
    return(int_posture);
3402254e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    /* Setup the highest usage stack pointer.  */
    thread_ptr -> tx_thread_stack_highest_ptr =  thread_ptr -> tx_thread_stack_ptr;
#endif

    /* Prepare to make this thread a member of the created thread list.  */
    TX_DISABLE
34022550:	63bb      	str	r3, [r7, #56]	@ 0x38

    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
34022552:	68fb      	ldr	r3, [r7, #12]
34022554:	4a41      	ldr	r2, [pc, #260]	@ (3402265c <_tx_thread_create+0x1bc>)
34022556:	601a      	str	r2, [r3, #0]

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
34022558:	4b41      	ldr	r3, [pc, #260]	@ (34022660 <_tx_thread_create+0x1c0>)
3402255a:	681b      	ldr	r3, [r3, #0]
3402255c:	2b00      	cmp	r3, #0
3402255e:	d10b      	bne.n	34022578 <_tx_thread_create+0xd8>
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
34022560:	4a40      	ldr	r2, [pc, #256]	@ (34022664 <_tx_thread_create+0x1c4>)
34022562:	68fb      	ldr	r3, [r7, #12]
34022564:	6013      	str	r3, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
34022566:	68fb      	ldr	r3, [r7, #12]
34022568:	68fa      	ldr	r2, [r7, #12]
3402256a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
3402256e:	68fb      	ldr	r3, [r7, #12]
34022570:	68fa      	ldr	r2, [r7, #12]
34022572:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
34022576:	e016      	b.n	340225a6 <_tx_thread_create+0x106>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_thread =  _tx_thread_created_ptr;
34022578:	4b3a      	ldr	r3, [pc, #232]	@ (34022664 <_tx_thread_create+0x1c4>)
3402257a:	681b      	ldr	r3, [r3, #0]
3402257c:	637b      	str	r3, [r7, #52]	@ 0x34
        previous_thread =  next_thread -> tx_thread_created_previous;
3402257e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34022580:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34022584:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Place the new thread in the list.  */
        next_thread -> tx_thread_created_previous =  thread_ptr;
34022586:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34022588:	68fa      	ldr	r2, [r7, #12]
3402258a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
3402258e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022590:	68fa      	ldr	r2, [r7, #12]
34022592:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        /* Setup this thread's created links.  */
        thread_ptr -> tx_thread_created_previous =  previous_thread;
34022596:	68fb      	ldr	r3, [r7, #12]
34022598:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
3402259a:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
        thread_ptr -> tx_thread_created_next =      next_thread;
3402259e:	68fb      	ldr	r3, [r7, #12]
340225a0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
340225a2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
    }

    /* Increment the thread created count.  */
    _tx_thread_created_count++;
340225a6:	4b2e      	ldr	r3, [pc, #184]	@ (34022660 <_tx_thread_create+0x1c0>)
340225a8:	681b      	ldr	r3, [r3, #0]
340225aa:	3301      	adds	r3, #1
340225ac:	4a2c      	ldr	r2, [pc, #176]	@ (34022660 <_tx_thread_create+0x1c0>)
340225ae:	6013      	str	r3, [r2, #0]
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
340225b0:	4b2d      	ldr	r3, [pc, #180]	@ (34022668 <_tx_thread_create+0x1c8>)
340225b2:	681b      	ldr	r3, [r3, #0]
340225b4:	3301      	adds	r3, #1
340225b6:	4a2c      	ldr	r2, [pc, #176]	@ (34022668 <_tx_thread_create+0x1c8>)
340225b8:	6013      	str	r3, [r2, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
340225ba:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
340225bc:	2b01      	cmp	r3, #1
340225be:	d129      	bne.n	34022614 <_tx_thread_create+0x174>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
340225c0:	f3ef 8305 	mrs	r3, IPSR
340225c4:	627b      	str	r3, [r7, #36]	@ 0x24
    return(ipsr_value);
340225c6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
340225c8:	4b28      	ldr	r3, [pc, #160]	@ (3402266c <_tx_thread_create+0x1cc>)
340225ca:	681b      	ldr	r3, [r3, #0]
340225cc:	4313      	orrs	r3, r2
340225ce:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
340225d2:	d30d      	bcc.n	340225f0 <_tx_thread_create+0x150>

            /* Pickup the current thread execute pointer, which corresponds to the
               highest priority thread ready to execute.  Interrupt lockout is
               not required, since interrupts are assumed to be disabled during
               initialization.  */
            saved_thread_ptr =  _tx_thread_execute_ptr;
340225d4:	4b26      	ldr	r3, [pc, #152]	@ (34022670 <_tx_thread_create+0x1d0>)
340225d6:	681b      	ldr	r3, [r3, #0]
340225d8:	647b      	str	r3, [r7, #68]	@ 0x44

            /* Determine if there is thread ready for execution.  */
            if (saved_thread_ptr != TX_NULL)
340225da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340225dc:	2b00      	cmp	r3, #0
340225de:	d009      	beq.n	340225f4 <_tx_thread_create+0x154>
            {

                /* Yes, a thread is ready for execution when initialization completes.  */

                /* Save the current preemption-threshold.  */
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
340225e0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340225e2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340225e4:	643b      	str	r3, [r7, #64]	@ 0x40

                /* For initialization, temporarily set the preemption-threshold to the
                   priority level to make sure the highest-priority thread runs once
                   initialization is complete.  */
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
340225e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340225e8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
340225ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340225ec:	63da      	str	r2, [r3, #60]	@ 0x3c
340225ee:	e001      	b.n	340225f4 <_tx_thread_create+0x154>
        }
        else
        {

            /* Simply set the saved thread pointer to NULL.  */
            saved_thread_ptr =  TX_NULL;
340225f0:	2300      	movs	r3, #0
340225f2:	647b      	str	r3, [r7, #68]	@ 0x44
340225f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340225f6:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340225f8:	6a3b      	ldr	r3, [r7, #32]
340225fa:	f383 8810 	msr	PRIMASK, r3
}
340225fe:	bf00      	nop

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
34022600:	68f8      	ldr	r0, [r7, #12]
34022602:	f000 f9a3 	bl	3402294c <_tx_thread_system_resume>
#endif

        /* Determine if the thread's preemption-threshold needs to be restored.  */
        if (saved_thread_ptr != TX_NULL)
34022606:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34022608:	2b00      	cmp	r3, #0
3402260a:	d01e      	beq.n	3402264a <_tx_thread_create+0x1aa>
        {

            /* Yes, restore the previous highest-priority thread's preemption-threshold. This
               can only happen if this routine is called from initialization.  */
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
3402260c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402260e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
34022610:	63da      	str	r2, [r3, #60]	@ 0x3c
34022612:	e01a      	b.n	3402264a <_tx_thread_create+0x1aa>
34022614:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34022616:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022618:	693b      	ldr	r3, [r7, #16]
3402261a:	f383 8810 	msr	PRIMASK, r3
}
3402261e:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022620:	f3ef 8310 	mrs	r3, PRIMASK
34022624:	61bb      	str	r3, [r7, #24]
    return(posture);
34022626:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
34022628:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
3402262a:	b672      	cpsid	i
    return(int_posture);
3402262c:	697b      	ldr	r3, [r7, #20]

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Disable interrupts.  */
        TX_DISABLE
3402262e:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Re-enable preemption.  */
        _tx_thread_preempt_disable--;
34022630:	4b0d      	ldr	r3, [pc, #52]	@ (34022668 <_tx_thread_create+0x1c8>)
34022632:	681b      	ldr	r3, [r3, #0]
34022634:	3b01      	subs	r3, #1
34022636:	4a0c      	ldr	r2, [pc, #48]	@ (34022668 <_tx_thread_create+0x1c8>)
34022638:	6013      	str	r3, [r2, #0]
3402263a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402263c:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402263e:	69fb      	ldr	r3, [r7, #28]
34022640:	f383 8810 	msr	PRIMASK, r3
}
34022644:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34022646:	f000 f947 	bl	340228d8 <_tx_thread_system_preempt_check>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
3402264a:	2300      	movs	r3, #0
}
3402264c:	4618      	mov	r0, r3
3402264e:	3748      	adds	r7, #72	@ 0x48
34022650:	46bd      	mov	sp, r7
34022652:	bd80      	pop	{r7, pc}
34022654:	34022f39 	.word	0x34022f39
34022658:	340226f9 	.word	0x340226f9
3402265c:	54485244 	.word	0x54485244
34022660:	3404aafc 	.word	0x3404aafc
34022664:	3404aaf8 	.word	0x3404aaf8
34022668:	3404ab8c 	.word	0x3404ab8c
3402266c:	3404148c 	.word	0x3404148c
34022670:	3404aaf4 	.word	0x3404aaf4

34022674 <_tx_thread_initialize>:
/*                                            stack check error handling, */
/*                                            resulting in version 6.1.9  */   
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
34022674:	b580      	push	{r7, lr}
34022676:	af00      	add	r7, sp, #0
       respectively.  */

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)
34022678:	4b14      	ldr	r3, [pc, #80]	@ (340226cc <_tx_thread_initialize+0x58>)
3402267a:	2200      	movs	r2, #0
3402267c:	601a      	str	r2, [r3, #0]

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
3402267e:	4b14      	ldr	r3, [pc, #80]	@ (340226d0 <_tx_thread_initialize+0x5c>)
34022680:	2200      	movs	r2, #0
34022682:	601a      	str	r2, [r3, #0]

    /* Initialize the priority information.  */
    TX_MEMSET(&_tx_thread_priority_maps[0], 0, (sizeof(_tx_thread_priority_maps)));
34022684:	4b13      	ldr	r3, [pc, #76]	@ (340226d4 <_tx_thread_initialize+0x60>)
34022686:	2200      	movs	r2, #0
34022688:	601a      	str	r2, [r3, #0]

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD
    TX_MEMSET(&_tx_thread_preempted_maps[0], 0, (sizeof(_tx_thread_preempted_maps)));
3402268a:	4b13      	ldr	r3, [pc, #76]	@ (340226d8 <_tx_thread_initialize+0x64>)
3402268c:	2200      	movs	r2, #0
3402268e:	601a      	str	r2, [r3, #0]
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
34022690:	4b12      	ldr	r3, [pc, #72]	@ (340226dc <_tx_thread_initialize+0x68>)
34022692:	2220      	movs	r2, #32
34022694:	601a      	str	r2, [r3, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
34022696:	2280      	movs	r2, #128	@ 0x80
34022698:	2100      	movs	r1, #0
3402269a:	4811      	ldr	r0, [pc, #68]	@ (340226e0 <_tx_thread_initialize+0x6c>)
3402269c:	f004 fd7a 	bl	34027194 <memset>

    /* Initialize the head pointer of the created threads list and the
       number of threads created.  */
    _tx_thread_created_ptr =        TX_NULL;
340226a0:	4b10      	ldr	r3, [pc, #64]	@ (340226e4 <_tx_thread_initialize+0x70>)
340226a2:	2200      	movs	r2, #0
340226a4:	601a      	str	r2, [r3, #0]
    _tx_thread_created_count =      TX_EMPTY;
340226a6:	4b10      	ldr	r3, [pc, #64]	@ (340226e8 <_tx_thread_initialize+0x74>)
340226a8:	2200      	movs	r2, #0
340226aa:	601a      	str	r2, [r3, #0]

    /* Clear the global preempt disable variable.  */
    _tx_thread_preempt_disable =    ((UINT) 0);
340226ac:	4b0f      	ldr	r3, [pc, #60]	@ (340226ec <_tx_thread_initialize+0x78>)
340226ae:	2200      	movs	r2, #0
340226b0:	601a      	str	r2, [r3, #0]

    /* Initialize the thread mutex release function pointer.  */
    _tx_thread_mutex_release =      TX_NULL;
340226b2:	4b0f      	ldr	r3, [pc, #60]	@ (340226f0 <_tx_thread_initialize+0x7c>)
340226b4:	2200      	movs	r2, #0
340226b6:	601a      	str	r2, [r3, #0]
#endif
#ifdef TX_ENABLE_EVENT_TRACE
                            | (((ULONG) 1) << 8)
#endif
#if defined(TX_ENABLE_EXECUTION_CHANGE_NOTIFY) || defined(TX_EXECUTION_PROFILE_ENABLE)
                            | (((ULONG) 1) << 7)
340226b8:	4b0e      	ldr	r3, [pc, #56]	@ (340226f4 <_tx_thread_initialize+0x80>)
340226ba:	681b      	ldr	r3, [r3, #0]
340226bc:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
340226c0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
    _tx_build_options =  _tx_build_options 
340226c4:	4a0b      	ldr	r2, [pc, #44]	@ (340226f4 <_tx_thread_initialize+0x80>)
340226c6:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
340226c8:	bf00      	nop
340226ca:	bd80      	pop	{r7, pc}
340226cc:	3404aaf0 	.word	0x3404aaf0
340226d0:	3404aaf4 	.word	0x3404aaf4
340226d4:	3404ab00 	.word	0x3404ab00
340226d8:	3404ab04 	.word	0x3404ab04
340226dc:	3404ab08 	.word	0x3404ab08
340226e0:	3404ab0c 	.word	0x3404ab0c
340226e4:	3404aaf8 	.word	0x3404aaf8
340226e8:	3404aafc 	.word	0x3404aafc
340226ec:	3404ab8c 	.word	0x3404ab8c
340226f0:	3404ab90 	.word	0x3404ab90
340226f4:	3404ab94 	.word	0x3404ab94

340226f8 <_tx_thread_shell_entry>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_shell_entry(VOID)
{
340226f8:	b580      	push	{r7, lr}
340226fa:	b08c      	sub	sp, #48	@ 0x30
340226fc:	af00      	add	r7, sp, #0
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
340226fe:	4b33      	ldr	r3, [pc, #204]	@ (340227cc <_tx_thread_shell_entry+0xd4>)
34022700:	681b      	ldr	r3, [r3, #0]
34022702:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022704:	f3ef 8310 	mrs	r3, PRIMASK
34022708:	61bb      	str	r3, [r7, #24]
    return(posture);
3402270a:	69bb      	ldr	r3, [r7, #24]
    int_posture = __get_interrupt_posture();
3402270c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("CPSID i" : : : "memory");
3402270e:	b672      	cpsid	i
    return(int_posture);
34022710:	697b      	ldr	r3, [r7, #20]
    TX_THREAD_STARTED_EXTENSION(thread_ptr)

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Disable interrupts.  */
    TX_DISABLE
34022712:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Pickup the entry/exit application callback routine.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
34022714:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022716:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
3402271a:	627b      	str	r3, [r7, #36]	@ 0x24
3402271c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3402271e:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022720:	69fb      	ldr	r3, [r7, #28]
34022722:	f383 8810 	msr	PRIMASK, r3
}
34022726:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
34022728:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402272a:	2b00      	cmp	r3, #0
3402272c:	d003      	beq.n	34022736 <_tx_thread_shell_entry+0x3e>
    {

        /* Yes, notify application that this thread has been entered!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
3402272e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022730:	2100      	movs	r1, #0
34022732:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34022734:	4798      	blx	r3
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
34022736:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022738:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3402273a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
3402273c:	6c92      	ldr	r2, [r2, #72]	@ 0x48
3402273e:	4610      	mov	r0, r2
34022740:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
34022742:	4b23      	ldr	r3, [pc, #140]	@ (340227d0 <_tx_thread_shell_entry+0xd8>)
34022744:	681b      	ldr	r3, [r3, #0]
34022746:	2b00      	cmp	r3, #0
34022748:	d003      	beq.n	34022752 <_tx_thread_shell_entry+0x5a>
    {

        /* Yes, call the mutex release function via a function pointer that
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
3402274a:	4b21      	ldr	r3, [pc, #132]	@ (340227d0 <_tx_thread_shell_entry+0xd8>)
3402274c:	681b      	ldr	r3, [r3, #0]
3402274e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
34022750:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022752:	f3ef 8310 	mrs	r3, PRIMASK
34022756:	607b      	str	r3, [r7, #4]
    return(posture);
34022758:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
3402275a:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
3402275c:	b672      	cpsid	i
    return(int_posture);
3402275e:	683b      	ldr	r3, [r7, #0]
    }

    /* Lockout interrupts while the thread state is setup.  */
    TX_DISABLE
34022760:	62bb      	str	r3, [r7, #40]	@ 0x28

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Pickup the entry/exit application callback routine again.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
34022762:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022764:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34022768:	627b      	str	r3, [r7, #36]	@ 0x24
#endif

    /* Set the status to suspending, in order to indicate the suspension
       is in progress.  */
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
3402276a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402276c:	2201      	movs	r2, #1
3402276e:	631a      	str	r2, [r3, #48]	@ 0x30
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Set the suspending flag. */
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
34022770:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022772:	2201      	movs	r2, #1
34022774:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
34022776:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022778:	2200      	movs	r2, #0
3402277a:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
3402277c:	4b15      	ldr	r3, [pc, #84]	@ (340227d4 <_tx_thread_shell_entry+0xdc>)
3402277e:	681b      	ldr	r3, [r3, #0]
34022780:	3301      	adds	r3, #1
34022782:	4a14      	ldr	r2, [pc, #80]	@ (340227d4 <_tx_thread_shell_entry+0xdc>)
34022784:	6013      	str	r3, [r2, #0]
34022786:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34022788:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402278a:	68bb      	ldr	r3, [r7, #8]
3402278c:	f383 8810 	msr	PRIMASK, r3
}
34022790:	bf00      	nop
    __asm__ volatile (" MRS  %0,CONTROL ": "=r" (control_value) );
34022792:	f3ef 8314 	mrs	r3, CONTROL
34022796:	60fb      	str	r3, [r7, #12]
    return(control_value);
34022798:	68fb      	ldr	r3, [r7, #12]

    /* Restore interrupts.  */
    TX_RESTORE

    /* Perform any additional activities for tool or user purpose.  */
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)
3402279a:	623b      	str	r3, [r7, #32]
3402279c:	6a3b      	ldr	r3, [r7, #32]
3402279e:	f023 0304 	bic.w	r3, r3, #4
340227a2:	623b      	str	r3, [r7, #32]
340227a4:	6a3b      	ldr	r3, [r7, #32]
340227a6:	613b      	str	r3, [r7, #16]
    __asm__ volatile (" MSR  CONTROL,%0": : "r" (control_value): "memory" );
340227a8:	693b      	ldr	r3, [r7, #16]
340227aa:	f383 8814 	msr	CONTROL, r3
}
340227ae:	bf00      	nop

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
340227b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340227b2:	2b00      	cmp	r3, #0
340227b4:	d003      	beq.n	340227be <_tx_thread_shell_entry+0xc6>
    {

        /* Yes, notify application that this thread has exited!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
340227b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340227b8:	2101      	movs	r1, #1
340227ba:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
340227bc:	4798      	blx	r3
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
340227be:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
340227c0:	f000 f9d8 	bl	34022b74 <_tx_thread_system_suspend>
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
340227c4:	bf00      	nop
340227c6:	3730      	adds	r7, #48	@ 0x30
340227c8:	46bd      	mov	sp, r7
340227ca:	bd80      	pop	{r7, pc}
340227cc:	3404aaf0 	.word	0x3404aaf0
340227d0:	3404ab90 	.word	0x3404ab90
340227d4:	3404ab8c 	.word	0x3404ab8c

340227d8 <_tx_thread_sleep>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
340227d8:	b580      	push	{r7, lr}
340227da:	b08e      	sub	sp, #56	@ 0x38
340227dc:	af00      	add	r7, sp, #0
340227de:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340227e0:	f3ef 8310 	mrs	r3, PRIMASK
340227e4:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
340227e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
340227e8:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
340227ea:	b672      	cpsid	i
    return(int_posture);
340227ec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
UINT            status;
TX_THREAD       *thread_ptr;


    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
340227ee:	633b      	str	r3, [r7, #48]	@ 0x30

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
340227f0:	4b35      	ldr	r3, [pc, #212]	@ (340228c8 <_tx_thread_sleep+0xf0>)
340227f2:	681b      	ldr	r3, [r3, #0]
340227f4:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
340227f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340227f8:	2b00      	cmp	r3, #0
340227fa:	d108      	bne.n	3402280e <_tx_thread_sleep+0x36>
340227fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340227fe:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022800:	6a3b      	ldr	r3, [r7, #32]
34022802:	f383 8810 	msr	PRIMASK, r3
}
34022806:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
34022808:	2313      	movs	r3, #19
3402280a:	637b      	str	r3, [r7, #52]	@ 0x34
3402280c:	e056      	b.n	340228bc <_tx_thread_sleep+0xe4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3402280e:	f3ef 8305 	mrs	r3, IPSR
34022812:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
34022814:	69fa      	ldr	r2, [r7, #28]
    }

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34022816:	4b2d      	ldr	r3, [pc, #180]	@ (340228cc <_tx_thread_sleep+0xf4>)
34022818:	681b      	ldr	r3, [r3, #0]
3402281a:	4313      	orrs	r3, r2
3402281c:	2b00      	cmp	r3, #0
3402281e:	d008      	beq.n	34022832 <_tx_thread_sleep+0x5a>
34022820:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022822:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022824:	69bb      	ldr	r3, [r7, #24]
34022826:	f383 8810 	msr	PRIMASK, r3
}
3402282a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
3402282c:	2313      	movs	r3, #19
3402282e:	637b      	str	r3, [r7, #52]	@ 0x34
34022830:	e044      	b.n	340228bc <_tx_thread_sleep+0xe4>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
34022832:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022834:	4a26      	ldr	r2, [pc, #152]	@ (340228d0 <_tx_thread_sleep+0xf8>)
34022836:	4293      	cmp	r3, r2
34022838:	d108      	bne.n	3402284c <_tx_thread_sleep+0x74>
3402283a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402283c:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
3402283e:	697b      	ldr	r3, [r7, #20]
34022840:	f383 8810 	msr	PRIMASK, r3
}
34022844:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
34022846:	2313      	movs	r3, #19
34022848:	637b      	str	r3, [r7, #52]	@ 0x34
3402284a:	e037      	b.n	340228bc <_tx_thread_sleep+0xe4>
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
3402284c:	687b      	ldr	r3, [r7, #4]
3402284e:	2b00      	cmp	r3, #0
34022850:	d108      	bne.n	34022864 <_tx_thread_sleep+0x8c>
34022852:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022854:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022856:	693b      	ldr	r3, [r7, #16]
34022858:	f383 8810 	msr	PRIMASK, r3
}
3402285c:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Just return with a successful status.  */
        status =  TX_SUCCESS;
3402285e:	2300      	movs	r3, #0
34022860:	637b      	str	r3, [r7, #52]	@ 0x34
34022862:	e02b      	b.n	340228bc <_tx_thread_sleep+0xe4>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
34022864:	4b1b      	ldr	r3, [pc, #108]	@ (340228d4 <_tx_thread_sleep+0xfc>)
34022866:	681b      	ldr	r3, [r3, #0]
34022868:	2b00      	cmp	r3, #0
3402286a:	d008      	beq.n	3402287e <_tx_thread_sleep+0xa6>
3402286c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3402286e:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022870:	68fb      	ldr	r3, [r7, #12]
34022872:	f383 8810 	msr	PRIMASK, r3
}
34022876:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Suspension is not allowed if the preempt disable flag is non-zero at this point - return error completion.  */
            status =  TX_CALLER_ERROR;
34022878:	2313      	movs	r3, #19
3402287a:	637b      	str	r3, [r7, #52]	@ 0x34
3402287c:	e01e      	b.n	340228bc <_tx_thread_sleep+0xe4>
            TX_EL_THREAD_SLEEP_INSERT

            /* Suspend the current thread.  */

            /* Set the state to suspended.  */
            thread_ptr -> tx_thread_state =    TX_SLEEP;
3402287e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022880:	2204      	movs	r2, #4
34022882:	631a      	str	r2, [r3, #48]	@ 0x30
            /* Restore interrupts.  */
            TX_RESTORE
#else

            /* Set the suspending flag. */
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
34022884:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022886:	2201      	movs	r2, #1
34022888:	639a      	str	r2, [r3, #56]	@ 0x38

            /* Initialize the status to successful.  */
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
3402288a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402288c:	2200      	movs	r2, #0
3402288e:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
34022892:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022894:	687a      	ldr	r2, [r7, #4]
34022896:	64da      	str	r2, [r3, #76]	@ 0x4c

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
34022898:	4b0e      	ldr	r3, [pc, #56]	@ (340228d4 <_tx_thread_sleep+0xfc>)
3402289a:	681b      	ldr	r3, [r3, #0]
3402289c:	3301      	adds	r3, #1
3402289e:	4a0d      	ldr	r2, [pc, #52]	@ (340228d4 <_tx_thread_sleep+0xfc>)
340228a0:	6013      	str	r3, [r2, #0]
340228a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340228a4:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340228a6:	68bb      	ldr	r3, [r7, #8]
340228a8:	f383 8810 	msr	PRIMASK, r3
}
340228ac:	bf00      	nop

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
340228ae:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
340228b0:	f000 f960 	bl	34022b74 <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
340228b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340228b6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
340228ba:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }

    /* Return completion status.  */
    return(status);
340228bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
340228be:	4618      	mov	r0, r3
340228c0:	3738      	adds	r7, #56	@ 0x38
340228c2:	46bd      	mov	sp, r7
340228c4:	bd80      	pop	{r7, pc}
340228c6:	bf00      	nop
340228c8:	3404aaf0 	.word	0x3404aaf0
340228cc:	3404148c 	.word	0x3404148c
340228d0:	3404ac40 	.word	0x3404ac40
340228d4:	3404ab8c 	.word	0x3404ab8c

340228d8 <_tx_thread_system_preempt_check>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_preempt_check(VOID)
{
340228d8:	b480      	push	{r7}
340228da:	b089      	sub	sp, #36	@ 0x24
340228dc:	af00      	add	r7, sp, #0
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
340228de:	4b17      	ldr	r3, [pc, #92]	@ (3402293c <_tx_thread_system_preempt_check+0x64>)
340228e0:	681b      	ldr	r3, [r3, #0]
340228e2:	61fb      	str	r3, [r7, #28]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
340228e4:	69fb      	ldr	r3, [r7, #28]
340228e6:	2b00      	cmp	r3, #0
340228e8:	d121      	bne.n	3402292e <_tx_thread_system_preempt_check+0x56>
    {

        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
340228ea:	4b15      	ldr	r3, [pc, #84]	@ (34022940 <_tx_thread_system_preempt_check+0x68>)
340228ec:	681b      	ldr	r3, [r3, #0]
340228ee:	61bb      	str	r3, [r7, #24]

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
340228f0:	4b14      	ldr	r3, [pc, #80]	@ (34022944 <_tx_thread_system_preempt_check+0x6c>)
340228f2:	681b      	ldr	r3, [r3, #0]
340228f4:	617b      	str	r3, [r7, #20]

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
340228f6:	69ba      	ldr	r2, [r7, #24]
340228f8:	697b      	ldr	r3, [r7, #20]
340228fa:	429a      	cmp	r2, r3
340228fc:	d017      	beq.n	3402292e <_tx_thread_system_preempt_check+0x56>
__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
UINT interrupt_save;

    /* Set PendSV to invoke ThreadX scheduler.  */
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
340228fe:	4b12      	ldr	r3, [pc, #72]	@ (34022948 <_tx_thread_system_preempt_check+0x70>)
34022900:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022904:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022906:	f3ef 8305 	mrs	r3, IPSR
3402290a:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
3402290c:	693b      	ldr	r3, [r7, #16]
    if (_tx_ipsr_get() == 0)
3402290e:	2b00      	cmp	r3, #0
34022910:	d10c      	bne.n	3402292c <_tx_thread_system_preempt_check+0x54>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022912:	f3ef 8310 	mrs	r3, PRIMASK
34022916:	60fb      	str	r3, [r7, #12]
    return(posture);
34022918:	68fb      	ldr	r3, [r7, #12]
    {
        interrupt_save = __get_interrupt_posture();
3402291a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSIE  i": : : "memory");
3402291c:	b662      	cpsie	i
}
3402291e:	bf00      	nop
34022920:	68bb      	ldr	r3, [r7, #8]
34022922:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022924:	687b      	ldr	r3, [r7, #4]
34022926:	f383 8810 	msr	PRIMASK, r3
}
3402292a:	bf00      	nop
#else
        __enable_interrupts();
#endif
        __restore_interrupt(interrupt_save);
    }
}
3402292c:	bf00      	nop

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
3402292e:	bf00      	nop
34022930:	3724      	adds	r7, #36	@ 0x24
34022932:	46bd      	mov	sp, r7
34022934:	f85d 7b04 	ldr.w	r7, [sp], #4
34022938:	4770      	bx	lr
3402293a:	bf00      	nop
3402293c:	3404ab8c 	.word	0x3404ab8c
34022940:	3404aaf0 	.word	0x3404aaf0
34022944:	3404aaf4 	.word	0x3404aaf4
34022948:	e000ed04 	.word	0xe000ed04

3402294c <_tx_thread_system_resume>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
3402294c:	b580      	push	{r7, lr}
3402294e:	b096      	sub	sp, #88	@ 0x58
34022950:	af00      	add	r7, sp, #0
34022952:	6078      	str	r0, [r7, #4]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022954:	f3ef 8310 	mrs	r3, PRIMASK
34022958:	637b      	str	r3, [r7, #52]	@ 0x34
    return(posture);
3402295a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    int_posture = __get_interrupt_posture();
3402295c:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("CPSID i" : : : "memory");
3402295e:	b672      	cpsid	i
    return(int_posture);
34022960:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE
34022962:	657b      	str	r3, [r7, #84]	@ 0x54

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
34022964:	687b      	ldr	r3, [r7, #4]
34022966:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34022968:	2b00      	cmp	r3, #0
3402296a:	d005      	beq.n	34022978 <_tx_thread_system_resume+0x2c>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
3402296c:	687b      	ldr	r3, [r7, #4]
3402296e:	334c      	adds	r3, #76	@ 0x4c
34022970:	4618      	mov	r0, r3
34022972:	f000 fc3b 	bl	340231ec <_tx_timer_system_deactivate>
34022976:	e002      	b.n	3402297e <_tx_thread_system_resume+0x32>
    }
    else
    {

        /* Clear the remaining time to ensure timer doesn't get activated.  */
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
34022978:	687b      	ldr	r3, [r7, #4]
3402297a:	2200      	movs	r2, #0
3402297c:	64da      	str	r2, [r3, #76]	@ 0x4c
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
3402297e:	4b75      	ldr	r3, [pc, #468]	@ (34022b54 <_tx_thread_system_resume+0x208>)
34022980:	681b      	ldr	r3, [r3, #0]
34022982:	3b01      	subs	r3, #1
34022984:	4a73      	ldr	r2, [pc, #460]	@ (34022b54 <_tx_thread_system_resume+0x208>)
34022986:	6013      	str	r3, [r2, #0]

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
34022988:	687b      	ldr	r3, [r7, #4]
3402298a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3402298c:	2b00      	cmp	r3, #0
3402298e:	f040 8096 	bne.w	34022abe <_tx_thread_system_resume+0x172>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
34022992:	687b      	ldr	r3, [r7, #4]
34022994:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022996:	2b00      	cmp	r3, #0
34022998:	f000 80aa 	beq.w	34022af0 <_tx_thread_system_resume+0x1a4>
        {

            /* No, now check to see if the delayed suspension flag is set.  */
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
3402299c:	687b      	ldr	r3, [r7, #4]
3402299e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
340229a0:	2b00      	cmp	r3, #0
340229a2:	f040 8085 	bne.w	34022ab0 <_tx_thread_system_resume+0x164>
                /* Resume the thread!  */

                /* Make this thread ready.  */

                /* Change the state to ready.  */
                thread_ptr -> tx_thread_state =  TX_READY;
340229a6:	687b      	ldr	r3, [r7, #4]
340229a8:	2200      	movs	r2, #0
340229aa:	631a      	str	r2, [r3, #48]	@ 0x30

                /* Pickup priority of thread.  */
                priority =  thread_ptr -> tx_thread_priority;
340229ac:	687b      	ldr	r3, [r7, #4]
340229ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340229b0:	653b      	str	r3, [r7, #80]	@ 0x50
                thread_ptr -> tx_thread_performance_resume_count++;
#endif

                /* Determine if there are other threads at this priority that are
                   ready.  */
                head_ptr =  _tx_thread_priority_list[priority];
340229b2:	4a69      	ldr	r2, [pc, #420]	@ (34022b58 <_tx_thread_system_resume+0x20c>)
340229b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340229b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
340229ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
                if (head_ptr == TX_NULL)
340229bc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340229be:	2b00      	cmp	r3, #0
340229c0:	d166      	bne.n	34022a90 <_tx_thread_system_resume+0x144>
                {

                    /* First thread at this priority ready.  Add to the front of the list.  */
                    _tx_thread_priority_list[priority] =       thread_ptr;
340229c2:	4965      	ldr	r1, [pc, #404]	@ (34022b58 <_tx_thread_system_resume+0x20c>)
340229c4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340229c6:	687a      	ldr	r2, [r7, #4]
340229c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                    thread_ptr -> tx_thread_ready_next =       thread_ptr;
340229cc:	687b      	ldr	r3, [r7, #4]
340229ce:	687a      	ldr	r2, [r7, #4]
340229d0:	621a      	str	r2, [r3, #32]
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
340229d2:	687b      	ldr	r3, [r7, #4]
340229d4:	687a      	ldr	r2, [r7, #4]
340229d6:	625a      	str	r2, [r3, #36]	@ 0x24
                    TX_DIV32_BIT_SET(priority, priority_bit)
                    _tx_thread_priority_map_active =  _tx_thread_priority_map_active | priority_bit;
#endif

                    /* Or in the thread's priority bit.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
340229d8:	2201      	movs	r2, #1
340229da:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340229dc:	fa02 f303 	lsl.w	r3, r2, r3
340229e0:	647b      	str	r3, [r7, #68]	@ 0x44
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
340229e2:	4b5e      	ldr	r3, [pc, #376]	@ (34022b5c <_tx_thread_system_resume+0x210>)
340229e4:	681a      	ldr	r2, [r3, #0]
340229e6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
340229e8:	4313      	orrs	r3, r2
340229ea:	4a5c      	ldr	r2, [pc, #368]	@ (34022b5c <_tx_thread_system_resume+0x210>)
340229ec:	6013      	str	r3, [r2, #0]

                    /* Determine if this newly ready thread is the highest priority.  */
                    if (priority < _tx_thread_highest_priority)
340229ee:	4b5c      	ldr	r3, [pc, #368]	@ (34022b60 <_tx_thread_system_resume+0x214>)
340229f0:	681b      	ldr	r3, [r3, #0]
340229f2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
340229f4:	429a      	cmp	r2, r3
340229f6:	d27b      	bcs.n	34022af0 <_tx_thread_system_resume+0x1a4>
                    {

                        /* A new highest priority thread is present. */

                        /* Update the highest priority variable.  */
                        _tx_thread_highest_priority =  priority;
340229f8:	4a59      	ldr	r2, [pc, #356]	@ (34022b60 <_tx_thread_system_resume+0x214>)
340229fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340229fc:	6013      	str	r3, [r2, #0]

                        /* Pickup the execute pointer. Since it is going to be referenced multiple
                           times, it is placed in a local variable.  */
                        execute_ptr =  _tx_thread_execute_ptr;
340229fe:	4b59      	ldr	r3, [pc, #356]	@ (34022b64 <_tx_thread_system_resume+0x218>)
34022a00:	681b      	ldr	r3, [r3, #0]
34022a02:	643b      	str	r3, [r7, #64]	@ 0x40

                        /* Determine if no thread is currently executing.  */
                        if (execute_ptr == TX_NULL)
34022a04:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022a06:	2b00      	cmp	r3, #0
34022a08:	d103      	bne.n	34022a12 <_tx_thread_system_resume+0xc6>
                        {

                            /* Simply setup the execute pointer.  */
                            _tx_thread_execute_ptr =  thread_ptr;
34022a0a:	4a56      	ldr	r2, [pc, #344]	@ (34022b64 <_tx_thread_system_resume+0x218>)
34022a0c:	687b      	ldr	r3, [r7, #4]
34022a0e:	6013      	str	r3, [r2, #0]
34022a10:	e06e      	b.n	34022af0 <_tx_thread_system_resume+0x1a4>
                        {

                            /* Another thread has been scheduled for execution.  */

                            /* Check to see if this is a higher priority thread and determine if preemption is allowed.  */
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
34022a12:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022a14:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34022a16:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
34022a18:	429a      	cmp	r2, r3
34022a1a:	d269      	bcs.n	34022af0 <_tx_thread_system_resume+0x1a4>
                            {

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

                                /* Determine if the preempted thread had preemption-threshold set.  */
                                if (execute_ptr -> tx_thread_preempt_threshold != execute_ptr -> tx_thread_priority)
34022a1c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022a1e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34022a20:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022a22:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34022a24:	429a      	cmp	r2, r3
34022a26:	d00b      	beq.n	34022a40 <_tx_thread_system_resume+0xf4>
                                    TX_DIV32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
                                    _tx_thread_preempted_map_active =  _tx_thread_preempted_map_active | priority_bit;
#endif

                                    /* Remember that this thread was preempted by a thread above the thread's threshold.  */
                                    TX_MOD32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
34022a28:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022a2a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34022a2c:	2201      	movs	r2, #1
34022a2e:	fa02 f303 	lsl.w	r3, r2, r3
34022a32:	647b      	str	r3, [r7, #68]	@ 0x44
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
34022a34:	4b4c      	ldr	r3, [pc, #304]	@ (34022b68 <_tx_thread_system_resume+0x21c>)
34022a36:	681a      	ldr	r2, [r3, #0]
34022a38:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34022a3a:	4313      	orrs	r3, r2
34022a3c:	4a4a      	ldr	r2, [pc, #296]	@ (34022b68 <_tx_thread_system_resume+0x21c>)
34022a3e:	6013      	str	r3, [r2, #0]
                                execute_ptr -> tx_thread_performance_last_preempting_thread =  thread_ptr;

#endif

                                /* Yes, modify the execute thread pointer.  */
                                _tx_thread_execute_ptr =  thread_ptr;
34022a40:	4a48      	ldr	r2, [pc, #288]	@ (34022b64 <_tx_thread_system_resume+0x218>)
34022a42:	687b      	ldr	r3, [r7, #4]
34022a44:	6013      	str	r3, [r2, #0]
34022a46:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34022a48:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022a4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022a4c:	f383 8810 	msr	PRIMASK, r3
}
34022a50:	bf00      	nop
                                TX_THREAD_STACK_CHECK(thread_ptr)
#endif

                                /* Now determine if preemption should take place. This is only possible if the current thread pointer is
                                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34022a52:	4b40      	ldr	r3, [pc, #256]	@ (34022b54 <_tx_thread_system_resume+0x208>)
34022a54:	681b      	ldr	r3, [r3, #0]
34022a56:	63fb      	str	r3, [r7, #60]	@ 0x3c
                                if (combined_flags == ((ULONG) 0))
34022a58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34022a5a:	2b00      	cmp	r3, #0
34022a5c:	d174      	bne.n	34022b48 <_tx_thread_system_resume+0x1fc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34022a5e:	4b43      	ldr	r3, [pc, #268]	@ (34022b6c <_tx_thread_system_resume+0x220>)
34022a60:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022a64:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022a66:	f3ef 8305 	mrs	r3, IPSR
34022a6a:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(ipsr_value);
34022a6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    if (_tx_ipsr_get() == 0)
34022a6e:	2b00      	cmp	r3, #0
34022a70:	d10c      	bne.n	34022a8c <_tx_thread_system_resume+0x140>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022a72:	f3ef 8310 	mrs	r3, PRIMASK
34022a76:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34022a78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
        interrupt_save = __get_interrupt_posture();
34022a7a:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
34022a7c:	b662      	cpsie	i
}
34022a7e:	bf00      	nop
34022a80:	6a3b      	ldr	r3, [r7, #32]
34022a82:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022a84:	69fb      	ldr	r3, [r7, #28]
34022a86:	f383 8810 	msr	PRIMASK, r3
}
34022a8a:	bf00      	nop
}
34022a8c:	bf00      	nop
                                    /* Preemption is needed - return to the system!  */
                                    _tx_thread_system_return();
                                }

                                /* Return in-line when MISRA is not enabled.  */
                                return;
34022a8e:	e05b      	b.n	34022b48 <_tx_thread_system_resume+0x1fc>
                {

                    /* No, there are other threads at this priority already ready.  */

                    /* Just add this thread to the priority list.  */
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
34022a90:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34022a92:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34022a94:	64bb      	str	r3, [r7, #72]	@ 0x48
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
34022a96:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34022a98:	687a      	ldr	r2, [r7, #4]
34022a9a:	621a      	str	r2, [r3, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
34022a9c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34022a9e:	687a      	ldr	r2, [r7, #4]
34022aa0:	625a      	str	r2, [r3, #36]	@ 0x24
                    thread_ptr -> tx_thread_ready_previous =   tail_ptr;
34022aa2:	687b      	ldr	r3, [r7, #4]
34022aa4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
34022aa6:	625a      	str	r2, [r3, #36]	@ 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
34022aa8:	687b      	ldr	r3, [r7, #4]
34022aaa:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34022aac:	621a      	str	r2, [r3, #32]
34022aae:	e01f      	b.n	34022af0 <_tx_thread_system_resume+0x1a4>
            /* Else, delayed suspend flag was set.  */
            else
            {

                /* Clear the delayed suspend flag and change the state.  */
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
34022ab0:	687b      	ldr	r3, [r7, #4]
34022ab2:	2200      	movs	r2, #0
34022ab4:	635a      	str	r2, [r3, #52]	@ 0x34
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
34022ab6:	687b      	ldr	r3, [r7, #4]
34022ab8:	2203      	movs	r2, #3
34022aba:	631a      	str	r2, [r3, #48]	@ 0x30
34022abc:	e018      	b.n	34022af0 <_tx_thread_system_resume+0x1a4>
        /* A resumption occurred in the middle of a previous thread suspension.  */

        /* Make sure the type of suspension under way is not a terminate or
           thread completion.  In either of these cases, do not void the
           interrupted suspension processing.  */
        if (thread_ptr -> tx_thread_state != TX_COMPLETED)
34022abe:	687b      	ldr	r3, [r7, #4]
34022ac0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022ac2:	2b01      	cmp	r3, #1
34022ac4:	d014      	beq.n	34022af0 <_tx_thread_system_resume+0x1a4>
        {

            /* Make sure the thread isn't terminated.  */
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
34022ac6:	687b      	ldr	r3, [r7, #4]
34022ac8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022aca:	2b02      	cmp	r3, #2
34022acc:	d010      	beq.n	34022af0 <_tx_thread_system_resume+0x1a4>
            {

                /* No, now check to see if the delayed suspension flag is set.  */
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
34022ace:	687b      	ldr	r3, [r7, #4]
34022ad0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34022ad2:	2b00      	cmp	r3, #0
34022ad4:	d106      	bne.n	34022ae4 <_tx_thread_system_resume+0x198>
                {

                    /* Clear the suspending flag.  */
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
34022ad6:	687b      	ldr	r3, [r7, #4]
34022ad8:	2200      	movs	r2, #0
34022ada:	639a      	str	r2, [r3, #56]	@ 0x38

                    /* Restore the state to ready.  */
                    thread_ptr -> tx_thread_state =        TX_READY;
34022adc:	687b      	ldr	r3, [r7, #4]
34022ade:	2200      	movs	r2, #0
34022ae0:	631a      	str	r2, [r3, #48]	@ 0x30
34022ae2:	e005      	b.n	34022af0 <_tx_thread_system_resume+0x1a4>
                }
                else
                {

                    /* Clear the delayed suspend flag and change the state.  */
                    thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
34022ae4:	687b      	ldr	r3, [r7, #4]
34022ae6:	2200      	movs	r2, #0
34022ae8:	635a      	str	r2, [r3, #52]	@ 0x34
                    thread_ptr -> tx_thread_state =            TX_SUSPENDED;
34022aea:	687b      	ldr	r3, [r7, #4]
34022aec:	2203      	movs	r2, #3
34022aee:	631a      	str	r2, [r3, #48]	@ 0x30
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
34022af0:	4b1f      	ldr	r3, [pc, #124]	@ (34022b70 <_tx_thread_system_resume+0x224>)
34022af2:	681b      	ldr	r3, [r3, #0]
34022af4:	63bb      	str	r3, [r7, #56]	@ 0x38
34022af6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
34022af8:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022afa:	69bb      	ldr	r3, [r7, #24]
34022afc:	f383 8810 	msr	PRIMASK, r3
}
34022b00:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
34022b02:	4b18      	ldr	r3, [pc, #96]	@ (34022b64 <_tx_thread_system_resume+0x218>)
34022b04:	681b      	ldr	r3, [r3, #0]
34022b06:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34022b08:	429a      	cmp	r2, r3
34022b0a:	d020      	beq.n	34022b4e <_tx_thread_system_resume+0x202>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34022b0c:	4b11      	ldr	r3, [pc, #68]	@ (34022b54 <_tx_thread_system_resume+0x208>)
34022b0e:	681b      	ldr	r3, [r3, #0]
34022b10:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if (combined_flags == ((ULONG) 0))
34022b12:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34022b14:	2b00      	cmp	r3, #0
34022b16:	d11a      	bne.n	34022b4e <_tx_thread_system_resume+0x202>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34022b18:	4b14      	ldr	r3, [pc, #80]	@ (34022b6c <_tx_thread_system_resume+0x220>)
34022b1a:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022b1e:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022b20:	f3ef 8305 	mrs	r3, IPSR
34022b24:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34022b26:	697b      	ldr	r3, [r7, #20]
    if (_tx_ipsr_get() == 0)
34022b28:	2b00      	cmp	r3, #0
34022b2a:	d10f      	bne.n	34022b4c <_tx_thread_system_resume+0x200>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022b2c:	f3ef 8310 	mrs	r3, PRIMASK
34022b30:	613b      	str	r3, [r7, #16]
    return(posture);
34022b32:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
34022b34:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
34022b36:	b662      	cpsie	i
}
34022b38:	bf00      	nop
34022b3a:	68fb      	ldr	r3, [r7, #12]
34022b3c:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022b3e:	68bb      	ldr	r3, [r7, #8]
34022b40:	f383 8810 	msr	PRIMASK, r3
}
34022b44:	bf00      	nop
}
34022b46:	e001      	b.n	34022b4c <_tx_thread_system_resume+0x200>
                                return;
34022b48:	bf00      	nop
34022b4a:	e000      	b.n	34022b4e <_tx_thread_system_resume+0x202>
34022b4c:	bf00      	nop

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
34022b4e:	3758      	adds	r7, #88	@ 0x58
34022b50:	46bd      	mov	sp, r7
34022b52:	bd80      	pop	{r7, pc}
34022b54:	3404ab8c 	.word	0x3404ab8c
34022b58:	3404ab0c 	.word	0x3404ab0c
34022b5c:	3404ab00 	.word	0x3404ab00
34022b60:	3404ab08 	.word	0x3404ab08
34022b64:	3404aaf4 	.word	0x3404aaf4
34022b68:	3404ab04 	.word	0x3404ab04
34022b6c:	e000ed04 	.word	0xe000ed04
34022b70:	3404aaf0 	.word	0x3404aaf0

34022b74 <_tx_thread_system_suspend>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
34022b74:	b580      	push	{r7, lr}
34022b76:	b0a0      	sub	sp, #128	@ 0x80
34022b78:	af00      	add	r7, sp, #0
34022b7a:	6078      	str	r0, [r7, #4]
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
34022b7c:	4b5a      	ldr	r3, [pc, #360]	@ (34022ce8 <_tx_thread_system_suspend+0x174>)
34022b7e:	681b      	ldr	r3, [r3, #0]
34022b80:	67bb      	str	r3, [r7, #120]	@ 0x78
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022b82:	f3ef 8310 	mrs	r3, PRIMASK
34022b86:	657b      	str	r3, [r7, #84]	@ 0x54
    return(posture);
34022b88:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
    int_posture = __get_interrupt_posture();
34022b8a:	653b      	str	r3, [r7, #80]	@ 0x50
    __asm__ volatile ("CPSID i" : : : "memory");
34022b8c:	b672      	cpsid	i
    return(int_posture);
34022b8e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
    /* Check this thread's stack.  */
    TX_THREAD_STACK_CHECK(thread_ptr)
#endif

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
34022b90:	67fb      	str	r3, [r7, #124]	@ 0x7c

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
34022b92:	687a      	ldr	r2, [r7, #4]
34022b94:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
34022b96:	429a      	cmp	r2, r3
34022b98:	d112      	bne.n	34022bc0 <_tx_thread_system_suspend+0x4c>
    {

        /* Pickup the wait option.  */
        timeout =  thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks;
34022b9a:	687b      	ldr	r3, [r7, #4]
34022b9c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34022b9e:	677b      	str	r3, [r7, #116]	@ 0x74

        /* Determine if an activation is needed.  */
        if (timeout != TX_NO_WAIT)
34022ba0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34022ba2:	2b00      	cmp	r3, #0
34022ba4:	d008      	beq.n	34022bb8 <_tx_thread_system_suspend+0x44>
        {

            /* Make sure the suspension is not a wait-forever.  */
            if (timeout != TX_WAIT_FOREVER)
34022ba6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34022ba8:	f1b3 3fff 	cmp.w	r3, #4294967295
34022bac:	d004      	beq.n	34022bb8 <_tx_thread_system_suspend+0x44>
            {

                /* Activate the thread timer with the timeout value setup in the caller.  */
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
34022bae:	687b      	ldr	r3, [r7, #4]
34022bb0:	334c      	adds	r3, #76	@ 0x4c
34022bb2:	4618      	mov	r0, r3
34022bb4:	f000 fab8 	bl	34023128 <_tx_timer_system_activate>
            }
        }

        /* Yes, reset time slice for current thread.  */
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
34022bb8:	687b      	ldr	r3, [r7, #4]
34022bba:	69db      	ldr	r3, [r3, #28]
34022bbc:	4a4b      	ldr	r2, [pc, #300]	@ (34022cec <_tx_thread_system_suspend+0x178>)
34022bbe:	6013      	str	r3, [r2, #0]
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
34022bc0:	4b4b      	ldr	r3, [pc, #300]	@ (34022cf0 <_tx_thread_system_suspend+0x17c>)
34022bc2:	681b      	ldr	r3, [r3, #0]
34022bc4:	3b01      	subs	r3, #1
34022bc6:	4a4a      	ldr	r2, [pc, #296]	@ (34022cf0 <_tx_thread_system_suspend+0x17c>)
34022bc8:	6013      	str	r3, [r2, #0]
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
34022bca:	687b      	ldr	r3, [r7, #4]
34022bcc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34022bce:	2b01      	cmp	r3, #1
34022bd0:	f040 8122 	bne.w	34022e18 <_tx_thread_system_suspend+0x2a4>
            time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
        }
#endif

        /* Actually suspend this thread.  But first, clear the suspending flag.  */
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
34022bd4:	687b      	ldr	r3, [r7, #4]
34022bd6:	2200      	movs	r2, #0
34022bd8:	639a      	str	r2, [r3, #56]	@ 0x38

        /* Pickup priority of thread.  */
        priority =  thread_ptr -> tx_thread_priority;
34022bda:	687b      	ldr	r3, [r7, #4]
34022bdc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34022bde:	673b      	str	r3, [r7, #112]	@ 0x70

        /* Pickup the next ready thread pointer.  */
        ready_next =      thread_ptr -> tx_thread_ready_next;
34022be0:	687b      	ldr	r3, [r7, #4]
34022be2:	6a1b      	ldr	r3, [r3, #32]
34022be4:	66fb      	str	r3, [r7, #108]	@ 0x6c

        /* Determine if there are other threads at this priority that are
           ready.  */
        if (ready_next != thread_ptr)
34022be6:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34022be8:	687b      	ldr	r3, [r7, #4]
34022bea:	429a      	cmp	r2, r3
34022bec:	d027      	beq.n	34022c3e <_tx_thread_system_suspend+0xca>
        {

            /* Yes, there are other threads at this priority ready.  */

            /* Pickup the previous ready thread pointer.  */
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
34022bee:	687b      	ldr	r3, [r7, #4]
34022bf0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34022bf2:	65bb      	str	r3, [r7, #88]	@ 0x58

            /* Just remove this thread from the priority list.  */
            ready_next -> tx_thread_ready_previous =    ready_previous;
34022bf4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34022bf6:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34022bf8:	625a      	str	r2, [r3, #36]	@ 0x24
            ready_previous -> tx_thread_ready_next =    ready_next;
34022bfa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34022bfc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34022bfe:	621a      	str	r2, [r3, #32]

            /* Determine if this is the head of the priority list.  */
            if (_tx_thread_priority_list[priority] == thread_ptr)
34022c00:	4a3c      	ldr	r2, [pc, #240]	@ (34022cf4 <_tx_thread_system_suspend+0x180>)
34022c02:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34022c08:	687a      	ldr	r2, [r7, #4]
34022c0a:	429a      	cmp	r2, r3
34022c0c:	f040 808b 	bne.w	34022d26 <_tx_thread_system_suspend+0x1b2>
            {

                /* Update the head pointer of this priority list.  */
                _tx_thread_priority_list[priority] =  ready_next;
34022c10:	4938      	ldr	r1, [pc, #224]	@ (34022cf4 <_tx_thread_system_suspend+0x180>)
34022c12:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c14:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34022c16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                /* Calculate the index into the bit map array.  */
                map_index =  priority/((UINT) 32);
#endif

                /* Check for a thread preempted that had preemption threshold set.  */
                if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
34022c1a:	4b37      	ldr	r3, [pc, #220]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c1c:	681b      	ldr	r3, [r3, #0]
34022c1e:	2b00      	cmp	r3, #0
34022c20:	f000 8081 	beq.w	34022d26 <_tx_thread_system_suspend+0x1b2>
                {

                    /* Ensure that this thread's priority is clear in the preempt map.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
34022c24:	2201      	movs	r2, #1
34022c26:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c28:	fa02 f303 	lsl.w	r3, r2, r3
34022c2c:	66bb      	str	r3, [r7, #104]	@ 0x68
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
34022c2e:	4b32      	ldr	r3, [pc, #200]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c30:	681a      	ldr	r2, [r3, #0]
34022c32:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022c34:	43db      	mvns	r3, r3
34022c36:	4013      	ands	r3, r2
34022c38:	4a2f      	ldr	r2, [pc, #188]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c3a:	6013      	str	r3, [r2, #0]
34022c3c:	e073      	b.n	34022d26 <_tx_thread_system_suspend+0x1b2>
        else
        {

            /* This is the only thread at this priority ready to run.  Set the head
               pointer to NULL.  */
            _tx_thread_priority_list[priority] =    TX_NULL;
34022c3e:	4a2d      	ldr	r2, [pc, #180]	@ (34022cf4 <_tx_thread_system_suspend+0x180>)
34022c40:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c42:	2100      	movs	r1, #0
34022c44:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* Calculate the index into the bit map array.  */
            map_index =  priority/((UINT) 32);
#endif

            /* Clear this priority bit in the ready priority bit map.  */
            TX_MOD32_BIT_SET(priority, priority_bit)
34022c48:	2201      	movs	r2, #1
34022c4a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c4c:	fa02 f303 	lsl.w	r3, r2, r3
34022c50:	66bb      	str	r3, [r7, #104]	@ 0x68
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
34022c52:	4b2a      	ldr	r3, [pc, #168]	@ (34022cfc <_tx_thread_system_suspend+0x188>)
34022c54:	681a      	ldr	r2, [r3, #0]
34022c56:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022c58:	43db      	mvns	r3, r3
34022c5a:	4013      	ands	r3, r2
34022c5c:	4a27      	ldr	r2, [pc, #156]	@ (34022cfc <_tx_thread_system_suspend+0x188>)
34022c5e:	6013      	str	r3, [r2, #0]
#endif

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

            /* Check for a thread preempted that had preemption-threshold set.  */
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
34022c60:	4b25      	ldr	r3, [pc, #148]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c62:	681b      	ldr	r3, [r3, #0]
34022c64:	2b00      	cmp	r3, #0
34022c66:	d00b      	beq.n	34022c80 <_tx_thread_system_suspend+0x10c>
            {

                /* Ensure that this thread's priority is clear in the preempt map.  */
                TX_MOD32_BIT_SET(priority, priority_bit)
34022c68:	2201      	movs	r2, #1
34022c6a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022c6c:	fa02 f303 	lsl.w	r3, r2, r3
34022c70:	66bb      	str	r3, [r7, #104]	@ 0x68
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
34022c72:	4b21      	ldr	r3, [pc, #132]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c74:	681a      	ldr	r2, [r3, #0]
34022c76:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022c78:	43db      	mvns	r3, r3
34022c7a:	4013      	ands	r3, r2
34022c7c:	4a1e      	ldr	r2, [pc, #120]	@ (34022cf8 <_tx_thread_system_suspend+0x184>)
34022c7e:	6013      	str	r3, [r2, #0]
            /* Calculate the base priority as well.  */
            base_priority =  map_index * ((UINT) 32);
#else

            /* Setup the base priority to zero.  */
            base_priority =   ((UINT) 0);
34022c80:	2300      	movs	r3, #0
34022c82:	667b      	str	r3, [r7, #100]	@ 0x64
#endif

            /* Setup working variable for the priority map.  */
            priority_map =    _tx_thread_priority_maps[MAP_INDEX];
34022c84:	4b1d      	ldr	r3, [pc, #116]	@ (34022cfc <_tx_thread_system_suspend+0x188>)
34022c86:	681b      	ldr	r3, [r3, #0]
34022c88:	663b      	str	r3, [r7, #96]	@ 0x60

            /* Make a quick check for no other threads ready for execution.  */
            if (priority_map == ((ULONG) 0))
34022c8a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34022c8c:	2b00      	cmp	r3, #0
34022c8e:	d13d      	bne.n	34022d0c <_tx_thread_system_suspend+0x198>
            {

                /* Nothing else is ready.  Set highest priority and execute thread
                   accordingly.  */
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
34022c90:	4b1b      	ldr	r3, [pc, #108]	@ (34022d00 <_tx_thread_system_suspend+0x18c>)
34022c92:	2220      	movs	r2, #32
34022c94:	601a      	str	r2, [r3, #0]
                _tx_thread_execute_ptr =       TX_NULL;
34022c96:	4b1b      	ldr	r3, [pc, #108]	@ (34022d04 <_tx_thread_system_suspend+0x190>)
34022c98:	2200      	movs	r2, #0
34022c9a:	601a      	str	r2, [r3, #0]
34022c9c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34022c9e:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022ca0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34022ca2:	f383 8810 	msr	PRIMASK, r3
}
34022ca6:	bf00      	nop
                /* Restore interrupts.  */
                TX_RESTORE

                /* Determine if preemption should take place. This is only possible if the current thread pointer is
                   not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34022ca8:	4b11      	ldr	r3, [pc, #68]	@ (34022cf0 <_tx_thread_system_suspend+0x17c>)
34022caa:	681b      	ldr	r3, [r3, #0]
34022cac:	65fb      	str	r3, [r7, #92]	@ 0x5c
                if (combined_flags == ((ULONG) 0))
34022cae:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34022cb0:	2b00      	cmp	r3, #0
34022cb2:	f040 80db 	bne.w	34022e6c <_tx_thread_system_suspend+0x2f8>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34022cb6:	4b14      	ldr	r3, [pc, #80]	@ (34022d08 <_tx_thread_system_suspend+0x194>)
34022cb8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022cbc:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022cbe:	f3ef 8305 	mrs	r3, IPSR
34022cc2:	64bb      	str	r3, [r7, #72]	@ 0x48
    return(ipsr_value);
34022cc4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
    if (_tx_ipsr_get() == 0)
34022cc6:	2b00      	cmp	r3, #0
34022cc8:	d10c      	bne.n	34022ce4 <_tx_thread_system_suspend+0x170>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022cca:	f3ef 8310 	mrs	r3, PRIMASK
34022cce:	647b      	str	r3, [r7, #68]	@ 0x44
    return(posture);
34022cd0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
        interrupt_save = __get_interrupt_posture();
34022cd2:	643b      	str	r3, [r7, #64]	@ 0x40
    __asm__ volatile ("CPSIE  i": : : "memory");
34022cd4:	b662      	cpsie	i
}
34022cd6:	bf00      	nop
34022cd8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34022cda:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022cdc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34022cde:	f383 8810 	msr	PRIMASK, r3
}
34022ce2:	bf00      	nop
}
34022ce4:	bf00      	nop
                    /* Preemption is needed - return to the system!  */
                    _tx_thread_system_return();
                }

                /* Return to caller.  */
                return;
34022ce6:	e0c1      	b.n	34022e6c <_tx_thread_system_suspend+0x2f8>
34022ce8:	3404aaf0 	.word	0x3404aaf0
34022cec:	3404b10c 	.word	0x3404b10c
34022cf0:	3404ab8c 	.word	0x3404ab8c
34022cf4:	3404ab0c 	.word	0x3404ab0c
34022cf8:	3404ab04 	.word	0x3404ab04
34022cfc:	3404ab00 	.word	0x3404ab00
34022d00:	3404ab08 	.word	0x3404ab08
34022d04:	3404aaf4 	.word	0x3404aaf4
34022d08:	e000ed04 	.word	0xe000ed04
            {

                /* Other threads at different priority levels are ready to run.  */

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
34022d0c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34022d0e:	fa93 f3a3 	rbit	r3, r3
34022d12:	663b      	str	r3, [r7, #96]	@ 0x60
34022d14:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34022d16:	fab3 f383 	clz	r3, r3
34022d1a:	66bb      	str	r3, [r7, #104]	@ 0x68

                /* Setup the next highest priority variable.  */
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
34022d1c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34022d1e:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022d20:	4413      	add	r3, r2
34022d22:	4a56      	ldr	r2, [pc, #344]	@ (34022e7c <_tx_thread_system_suspend+0x308>)
34022d24:	6013      	str	r3, [r2, #0]
            }
        }

        /* Determine if the suspending thread is the thread designated to execute.  */
        if (thread_ptr == _tx_thread_execute_ptr)
34022d26:	4b56      	ldr	r3, [pc, #344]	@ (34022e80 <_tx_thread_system_suspend+0x30c>)
34022d28:	681b      	ldr	r3, [r3, #0]
34022d2a:	687a      	ldr	r2, [r7, #4]
34022d2c:	429a      	cmp	r2, r3
34022d2e:	d173      	bne.n	34022e18 <_tx_thread_system_suspend+0x2a4>
        {

            /* Pickup the highest priority thread to execute.  */
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
34022d30:	4b52      	ldr	r3, [pc, #328]	@ (34022e7c <_tx_thread_system_suspend+0x308>)
34022d32:	681b      	ldr	r3, [r3, #0]
34022d34:	4a53      	ldr	r2, [pc, #332]	@ (34022e84 <_tx_thread_system_suspend+0x310>)
34022d36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34022d3a:	4a51      	ldr	r2, [pc, #324]	@ (34022e80 <_tx_thread_system_suspend+0x30c>)
34022d3c:	6013      	str	r3, [r2, #0]

            /* Determine if a previous thread with preemption-threshold was preempted.  */
#if TX_MAX_PRIORITIES > 32
            if (_tx_thread_preempted_map_active != ((ULONG) 0))
#else
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
34022d3e:	4b52      	ldr	r3, [pc, #328]	@ (34022e88 <_tx_thread_system_suspend+0x314>)
34022d40:	681b      	ldr	r3, [r3, #0]
34022d42:	2b00      	cmp	r3, #0
34022d44:	d043      	beq.n	34022dce <_tx_thread_system_suspend+0x25a>
            {

                /* Yes, there was a thread preempted when it was using preemption-threshold.  */

                /* Disable preemption.  */
                _tx_thread_preempt_disable++;
34022d46:	4b51      	ldr	r3, [pc, #324]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022d48:	681b      	ldr	r3, [r3, #0]
34022d4a:	3301      	adds	r3, #1
34022d4c:	4a4f      	ldr	r2, [pc, #316]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022d4e:	6013      	str	r3, [r2, #0]
34022d50:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34022d52:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022d54:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34022d56:	f383 8810 	msr	PRIMASK, r3
}
34022d5a:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022d5c:	f3ef 8310 	mrs	r3, PRIMASK
34022d60:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
34022d62:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
34022d64:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
34022d66:	b672      	cpsid	i
    return(int_posture);
34022d68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34

                /* Interrupts are enabled briefly here to keep the interrupt
                   lockout time deterministic.  */

                /* Disable interrupts again.  */
                TX_DISABLE
34022d6a:	67fb      	str	r3, [r7, #124]	@ 0x7c

                /* Decrement the preemption disable variable.  */
                _tx_thread_preempt_disable--;
34022d6c:	4b47      	ldr	r3, [pc, #284]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022d6e:	681b      	ldr	r3, [r3, #0]
34022d70:	3b01      	subs	r3, #1
34022d72:	4a46      	ldr	r2, [pc, #280]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022d74:	6013      	str	r3, [r2, #0]
                /* Calculate the base priority as well.  */
                base_priority =  map_index * ((UINT) 32);
#else

                /* Setup the base priority to zero.  */
                base_priority =   ((UINT) 0);
34022d76:	2300      	movs	r3, #0
34022d78:	667b      	str	r3, [r7, #100]	@ 0x64
#endif

                /* Setup temporary preempted map.  */
                priority_map =  _tx_thread_preempted_maps[MAP_INDEX];
34022d7a:	4b43      	ldr	r3, [pc, #268]	@ (34022e88 <_tx_thread_system_suspend+0x314>)
34022d7c:	681b      	ldr	r3, [r3, #0]
34022d7e:	663b      	str	r3, [r7, #96]	@ 0x60

                /* Calculate the lowest bit set in the priority map. */
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
34022d80:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34022d82:	fa93 f3a3 	rbit	r3, r3
34022d86:	663b      	str	r3, [r7, #96]	@ 0x60
34022d88:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34022d8a:	fab3 f383 	clz	r3, r3
34022d8e:	66bb      	str	r3, [r7, #104]	@ 0x68

                /* Setup the highest priority preempted thread.  */
                priority =  base_priority + ((UINT) priority_bit);
34022d90:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34022d92:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022d94:	4413      	add	r3, r2
34022d96:	673b      	str	r3, [r7, #112]	@ 0x70

                /* Determine if the next highest priority thread is above the highest priority threshold value.  */
                if (_tx_thread_highest_priority >= (_tx_thread_priority_list[priority] -> tx_thread_preempt_threshold))
34022d98:	4a3a      	ldr	r2, [pc, #232]	@ (34022e84 <_tx_thread_system_suspend+0x310>)
34022d9a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022d9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34022da0:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
34022da2:	4b36      	ldr	r3, [pc, #216]	@ (34022e7c <_tx_thread_system_suspend+0x308>)
34022da4:	681b      	ldr	r3, [r3, #0]
34022da6:	429a      	cmp	r2, r3
34022da8:	d811      	bhi.n	34022dce <_tx_thread_system_suspend+0x25a>
                {

                    /* Thread not allowed to execute until earlier preempted thread finishes or lowers its
                       preemption-threshold.  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[priority];
34022daa:	4a36      	ldr	r2, [pc, #216]	@ (34022e84 <_tx_thread_system_suspend+0x310>)
34022dac:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022dae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34022db2:	4a33      	ldr	r2, [pc, #204]	@ (34022e80 <_tx_thread_system_suspend+0x30c>)
34022db4:	6013      	str	r3, [r2, #0]

                    /* Clear the corresponding bit in the preempted map, since the preemption has been restored.  */
                    TX_MOD32_BIT_SET(priority, priority_bit)
34022db6:	2201      	movs	r2, #1
34022db8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34022dba:	fa02 f303 	lsl.w	r3, r2, r3
34022dbe:	66bb      	str	r3, [r7, #104]	@ 0x68
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
34022dc0:	4b31      	ldr	r3, [pc, #196]	@ (34022e88 <_tx_thread_system_suspend+0x314>)
34022dc2:	681a      	ldr	r2, [r3, #0]
34022dc4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34022dc6:	43db      	mvns	r3, r3
34022dc8:	4013      	ands	r3, r2
34022dca:	4a2f      	ldr	r2, [pc, #188]	@ (34022e88 <_tx_thread_system_suspend+0x314>)
34022dcc:	6013      	str	r3, [r2, #0]
34022dce:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34022dd0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022dd2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34022dd4:	f383 8810 	msr	PRIMASK, r3
}
34022dd8:	bf00      	nop
            /* Restore interrupts.  */
            TX_RESTORE

            /* Determine if preemption should take place. This is only possible if the current thread pointer is
               not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34022dda:	4b2c      	ldr	r3, [pc, #176]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022ddc:	681b      	ldr	r3, [r3, #0]
34022dde:	65fb      	str	r3, [r7, #92]	@ 0x5c
            if (combined_flags == ((ULONG) 0))
34022de0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34022de2:	2b00      	cmp	r3, #0
34022de4:	d144      	bne.n	34022e70 <_tx_thread_system_suspend+0x2fc>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34022de6:	4b2a      	ldr	r3, [pc, #168]	@ (34022e90 <_tx_thread_system_suspend+0x31c>)
34022de8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022dec:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022dee:	f3ef 8305 	mrs	r3, IPSR
34022df2:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(ipsr_value);
34022df4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    if (_tx_ipsr_get() == 0)
34022df6:	2b00      	cmp	r3, #0
34022df8:	d10c      	bne.n	34022e14 <_tx_thread_system_suspend+0x2a0>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022dfa:	f3ef 8310 	mrs	r3, PRIMASK
34022dfe:	627b      	str	r3, [r7, #36]	@ 0x24
    return(posture);
34022e00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
        interrupt_save = __get_interrupt_posture();
34022e02:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("CPSIE  i": : : "memory");
34022e04:	b662      	cpsie	i
}
34022e06:	bf00      	nop
34022e08:	6a3b      	ldr	r3, [r7, #32]
34022e0a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022e0c:	69fb      	ldr	r3, [r7, #28]
34022e0e:	f383 8810 	msr	PRIMASK, r3
}
34022e12:	bf00      	nop
}
34022e14:	bf00      	nop
                /* Preemption is needed - return to the system!  */
                _tx_thread_system_return();
            }

            /* Return to caller.  */
            return;
34022e16:	e02b      	b.n	34022e70 <_tx_thread_system_suspend+0x2fc>
34022e18:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
34022e1a:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022e1c:	69bb      	ldr	r3, [r7, #24]
34022e1e:	f383 8810 	msr	PRIMASK, r3
}
34022e22:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
34022e24:	4b16      	ldr	r3, [pc, #88]	@ (34022e80 <_tx_thread_system_suspend+0x30c>)
34022e26:	681b      	ldr	r3, [r3, #0]
34022e28:	6fba      	ldr	r2, [r7, #120]	@ 0x78
34022e2a:	429a      	cmp	r2, r3
34022e2c:	d022      	beq.n	34022e74 <_tx_thread_system_suspend+0x300>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
34022e2e:	4b17      	ldr	r3, [pc, #92]	@ (34022e8c <_tx_thread_system_suspend+0x318>)
34022e30:	681b      	ldr	r3, [r3, #0]
34022e32:	65fb      	str	r3, [r7, #92]	@ 0x5c
        if (combined_flags == ((ULONG) 0))
34022e34:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34022e36:	2b00      	cmp	r3, #0
34022e38:	d11c      	bne.n	34022e74 <_tx_thread_system_suspend+0x300>
    *((volatile ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
34022e3a:	4b15      	ldr	r3, [pc, #84]	@ (34022e90 <_tx_thread_system_suspend+0x31c>)
34022e3c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
34022e40:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34022e42:	f3ef 8305 	mrs	r3, IPSR
34022e46:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34022e48:	697b      	ldr	r3, [r7, #20]
    if (_tx_ipsr_get() == 0)
34022e4a:	2b00      	cmp	r3, #0
34022e4c:	d10c      	bne.n	34022e68 <_tx_thread_system_suspend+0x2f4>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022e4e:	f3ef 8310 	mrs	r3, PRIMASK
34022e52:	613b      	str	r3, [r7, #16]
    return(posture);
34022e54:	693b      	ldr	r3, [r7, #16]
        interrupt_save = __get_interrupt_posture();
34022e56:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("CPSIE  i": : : "memory");
34022e58:	b662      	cpsie	i
}
34022e5a:	bf00      	nop
34022e5c:	68fb      	ldr	r3, [r7, #12]
34022e5e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022e60:	68bb      	ldr	r3, [r7, #8]
34022e62:	f383 8810 	msr	PRIMASK, r3
}
34022e66:	bf00      	nop
}
34022e68:	bf00      	nop
            _tx_thread_system_return();
        }
    }

    /* Return to caller.  */
    return;
34022e6a:	e003      	b.n	34022e74 <_tx_thread_system_suspend+0x300>
                return;
34022e6c:	bf00      	nop
34022e6e:	e002      	b.n	34022e76 <_tx_thread_system_suspend+0x302>
            return;
34022e70:	bf00      	nop
34022e72:	e000      	b.n	34022e76 <_tx_thread_system_suspend+0x302>
    return;
34022e74:	bf00      	nop
}
34022e76:	3780      	adds	r7, #128	@ 0x80
34022e78:	46bd      	mov	sp, r7
34022e7a:	bd80      	pop	{r7, pc}
34022e7c:	3404ab08 	.word	0x3404ab08
34022e80:	3404aaf4 	.word	0x3404aaf4
34022e84:	3404ab0c 	.word	0x3404ab0c
34022e88:	3404ab04 	.word	0x3404ab04
34022e8c:	3404ab8c 	.word	0x3404ab8c
34022e90:	e000ed04 	.word	0xe000ed04

34022e94 <_tx_thread_time_slice>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_time_slice(VOID)
{
34022e94:	b480      	push	{r7}
34022e96:	b087      	sub	sp, #28
34022e98:	af00      	add	r7, sp, #0
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
34022e9a:	4b21      	ldr	r3, [pc, #132]	@ (34022f20 <_tx_thread_time_slice+0x8c>)
34022e9c:	681b      	ldr	r3, [r3, #0]
34022e9e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022ea0:	f3ef 8310 	mrs	r3, PRIMASK
34022ea4:	60fb      	str	r3, [r7, #12]
    return(posture);
34022ea6:	68fb      	ldr	r3, [r7, #12]
    int_posture = __get_interrupt_posture();
34022ea8:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("CPSID i" : : : "memory");
34022eaa:	b672      	cpsid	i
    return(int_posture);
34022eac:	68bb      	ldr	r3, [r7, #8]
    /* Set the next thread pointer to NULL.  */
    next_thread_ptr =  TX_NULL;
#endif

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE
34022eae:	613b      	str	r3, [r7, #16]

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
34022eb0:	4b1c      	ldr	r3, [pc, #112]	@ (34022f24 <_tx_thread_time_slice+0x90>)
34022eb2:	2200      	movs	r2, #0
34022eb4:	601a      	str	r2, [r3, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
34022eb6:	697b      	ldr	r3, [r7, #20]
34022eb8:	2b00      	cmp	r3, #0
34022eba:	d024      	beq.n	34022f06 <_tx_thread_time_slice+0x72>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
34022ebc:	697b      	ldr	r3, [r7, #20]
34022ebe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022ec0:	2b00      	cmp	r3, #0
34022ec2:	d120      	bne.n	34022f06 <_tx_thread_time_slice+0x72>
        {

            /* Setup a fresh time-slice for the thread.  */
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
34022ec4:	697b      	ldr	r3, [r7, #20]
34022ec6:	69da      	ldr	r2, [r3, #28]
34022ec8:	697b      	ldr	r3, [r7, #20]
34022eca:	619a      	str	r2, [r3, #24]

            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
34022ecc:	697b      	ldr	r3, [r7, #20]
34022ece:	699b      	ldr	r3, [r3, #24]
34022ed0:	4a15      	ldr	r2, [pc, #84]	@ (34022f28 <_tx_thread_time_slice+0x94>)
34022ed2:	6013      	str	r3, [r2, #0]

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
34022ed4:	697b      	ldr	r3, [r7, #20]
34022ed6:	6a1b      	ldr	r3, [r3, #32]
34022ed8:	697a      	ldr	r2, [r7, #20]
34022eda:	429a      	cmp	r2, r3
34022edc:	d013      	beq.n	34022f06 <_tx_thread_time_slice+0x72>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
34022ede:	697b      	ldr	r3, [r7, #20]
34022ee0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34022ee2:	697b      	ldr	r3, [r7, #20]
34022ee4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34022ee6:	429a      	cmp	r2, r3
34022ee8:	d10d      	bne.n	34022f06 <_tx_thread_time_slice+0x72>

                    /* Preemption-threshold is not being used by this thread.  */

                    /* There is another thread at this priority, make it the highest at
                       this priority level.  */
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
34022eea:	697b      	ldr	r3, [r7, #20]
34022eec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34022eee:	697a      	ldr	r2, [r7, #20]
34022ef0:	6a12      	ldr	r2, [r2, #32]
34022ef2:	490e      	ldr	r1, [pc, #56]	@ (34022f2c <_tx_thread_time_slice+0x98>)
34022ef4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

                    /* Designate the highest priority thread as the one to execute.  Don't use this
                       thread's priority as an index just in case a higher priority thread is now
                       ready!  */
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
34022ef8:	4b0d      	ldr	r3, [pc, #52]	@ (34022f30 <_tx_thread_time_slice+0x9c>)
34022efa:	681b      	ldr	r3, [r3, #0]
34022efc:	4a0b      	ldr	r2, [pc, #44]	@ (34022f2c <_tx_thread_time_slice+0x98>)
34022efe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34022f02:	4a0c      	ldr	r2, [pc, #48]	@ (34022f34 <_tx_thread_time_slice+0xa0>)
34022f04:	6013      	str	r3, [r2, #0]
34022f06:	693b      	ldr	r3, [r7, #16]
34022f08:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022f0a:	687b      	ldr	r3, [r7, #4]
34022f0c:	f383 8810 	msr	PRIMASK, r3
}
34022f10:	bf00      	nop

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
34022f12:	bf00      	nop
34022f14:	371c      	adds	r7, #28
34022f16:	46bd      	mov	sp, r7
34022f18:	f85d 7b04 	ldr.w	r7, [sp], #4
34022f1c:	4770      	bx	lr
34022f1e:	bf00      	nop
34022f20:	3404aaf0 	.word	0x3404aaf0
34022f24:	3404ab9c 	.word	0x3404ab9c
34022f28:	3404b10c 	.word	0x3404b10c
34022f2c:	3404ab0c 	.word	0x3404ab0c
34022f30:	3404ab08 	.word	0x3404ab08
34022f34:	3404aaf4 	.word	0x3404aaf4

34022f38 <_tx_thread_timeout>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
34022f38:	b580      	push	{r7, lr}
34022f3a:	b08a      	sub	sp, #40	@ 0x28
34022f3c:	af00      	add	r7, sp, #0
34022f3e:	6078      	str	r0, [r7, #4]
VOID            (*suspend_cleanup)(struct TX_THREAD_STRUCT *suspend_thread_ptr, ULONG suspension_sequence);
ULONG           suspension_sequence;


    /* Pickup the thread pointer.  */
    TX_THREAD_TIMEOUT_POINTER_SETUP(thread_ptr)
34022f40:	687b      	ldr	r3, [r7, #4]
34022f42:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022f44:	f3ef 8310 	mrs	r3, PRIMASK
34022f48:	617b      	str	r3, [r7, #20]
    return(posture);
34022f4a:	697b      	ldr	r3, [r7, #20]
    int_posture = __get_interrupt_posture();
34022f4c:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("CPSID i" : : : "memory");
34022f4e:	b672      	cpsid	i
    return(int_posture);
34022f50:	693b      	ldr	r3, [r7, #16]

    /* Disable interrupts.  */
    TX_DISABLE
34022f52:	623b      	str	r3, [r7, #32]

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
34022f54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022f56:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34022f58:	2b04      	cmp	r3, #4
34022f5a:	d10e      	bne.n	34022f7a <_tx_thread_timeout+0x42>
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Increment the disable preemption flag.  */
        _tx_thread_preempt_disable++;
34022f5c:	4b13      	ldr	r3, [pc, #76]	@ (34022fac <_tx_thread_timeout+0x74>)
34022f5e:	681b      	ldr	r3, [r3, #0]
34022f60:	3301      	adds	r3, #1
34022f62:	4a12      	ldr	r2, [pc, #72]	@ (34022fac <_tx_thread_timeout+0x74>)
34022f64:	6013      	str	r3, [r2, #0]
34022f66:	6a3b      	ldr	r3, [r7, #32]
34022f68:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022f6a:	68fb      	ldr	r3, [r7, #12]
34022f6c:	f383 8810 	msr	PRIMASK, r3
}
34022f70:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Lift the suspension on the sleeping thread.  */
        _tx_thread_system_resume(thread_ptr);
34022f72:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34022f74:	f7ff fcea 	bl	3402294c <_tx_thread_system_resume>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
34022f78:	e013      	b.n	34022fa2 <_tx_thread_timeout+0x6a>
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
34022f7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022f7c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
34022f7e:	61fb      	str	r3, [r7, #28]
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
34022f80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34022f82:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34022f86:	61bb      	str	r3, [r7, #24]
34022f88:	6a3b      	ldr	r3, [r7, #32]
34022f8a:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022f8c:	68bb      	ldr	r3, [r7, #8]
34022f8e:	f383 8810 	msr	PRIMASK, r3
}
34022f92:	bf00      	nop
        if (suspend_cleanup != TX_NULL)
34022f94:	69fb      	ldr	r3, [r7, #28]
34022f96:	2b00      	cmp	r3, #0
34022f98:	d003      	beq.n	34022fa2 <_tx_thread_timeout+0x6a>
            (suspend_cleanup)(thread_ptr, suspension_sequence);
34022f9a:	69fb      	ldr	r3, [r7, #28]
34022f9c:	69b9      	ldr	r1, [r7, #24]
34022f9e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
34022fa0:	4798      	blx	r3
}
34022fa2:	bf00      	nop
34022fa4:	3728      	adds	r7, #40	@ 0x28
34022fa6:	46bd      	mov	sp, r7
34022fa8:	bd80      	pop	{r7, pc}
34022faa:	bf00      	nop
34022fac:	3404ab8c 	.word	0x3404ab8c

34022fb0 <_tx_time_get>:
/*  12-31-2020     Andres Mlinar            Modified comment(s),          */
/*                                            resulting in version 6.1.3  */
/*                                                                        */
/**************************************************************************/
ULONG  _tx_time_get(VOID)
{
34022fb0:	b480      	push	{r7}
34022fb2:	b087      	sub	sp, #28
34022fb4:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022fb6:	f3ef 8310 	mrs	r3, PRIMASK
34022fba:	60bb      	str	r3, [r7, #8]
    return(posture);
34022fbc:	68bb      	ldr	r3, [r7, #8]
    int_posture = __get_interrupt_posture();
34022fbe:	607b      	str	r3, [r7, #4]
    __asm__ volatile ("CPSID i" : : : "memory");
34022fc0:	b672      	cpsid	i
    return(int_posture);
34022fc2:	687b      	ldr	r3, [r7, #4]
#endif
ULONG   temp_time;


    /* Disable interrupts.  */
    TX_DISABLE
34022fc4:	617b      	str	r3, [r7, #20]

    /* Pickup the system clock time.  */
    temp_time =  _tx_timer_system_clock;
34022fc6:	4b08      	ldr	r3, [pc, #32]	@ (34022fe8 <_tx_time_get+0x38>)
34022fc8:	681b      	ldr	r3, [r3, #0]
34022fca:	613b      	str	r3, [r7, #16]
34022fcc:	697b      	ldr	r3, [r7, #20]
34022fce:	60fb      	str	r3, [r7, #12]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34022fd0:	68fb      	ldr	r3, [r7, #12]
34022fd2:	f383 8810 	msr	PRIMASK, r3
}
34022fd6:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the time.  */
    return(temp_time);
34022fd8:	693b      	ldr	r3, [r7, #16]
}
34022fda:	4618      	mov	r0, r3
34022fdc:	371c      	adds	r7, #28
34022fde:	46bd      	mov	sp, r7
34022fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
34022fe4:	4770      	bx	lr
34022fe6:	bf00      	nop
34022fe8:	3404ab98 	.word	0x3404ab98

34022fec <_tx_timer_expiration_process>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_expiration_process(VOID)
{
34022fec:	b580      	push	{r7, lr}
34022fee:	b084      	sub	sp, #16
34022ff0:	af00      	add	r7, sp, #0
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34022ff2:	f3ef 8310 	mrs	r3, PRIMASK
34022ff6:	607b      	str	r3, [r7, #4]
    return(posture);
34022ff8:	687b      	ldr	r3, [r7, #4]
    int_posture = __get_interrupt_posture();
34022ffa:	603b      	str	r3, [r7, #0]
    __asm__ volatile ("CPSID i" : : : "memory");
34022ffc:	b672      	cpsid	i
    return(int_posture);
34022ffe:	683b      	ldr	r3, [r7, #0]

    /* Don't process in the ISR, wakeup the system timer thread to process the
       timer expiration.  */

    /* Disable interrupts.  */
    TX_DISABLE
34023000:	60fb      	str	r3, [r7, #12]
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
34023002:	4b09      	ldr	r3, [pc, #36]	@ (34023028 <_tx_timer_expiration_process+0x3c>)
34023004:	681b      	ldr	r3, [r3, #0]
34023006:	3301      	adds	r3, #1
34023008:	4a07      	ldr	r2, [pc, #28]	@ (34023028 <_tx_timer_expiration_process+0x3c>)
3402300a:	6013      	str	r3, [r2, #0]
3402300c:	68fb      	ldr	r3, [r7, #12]
3402300e:	60bb      	str	r3, [r7, #8]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023010:	68bb      	ldr	r3, [r7, #8]
34023012:	f383 8810 	msr	PRIMASK, r3
}
34023016:	bf00      	nop

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
34023018:	4804      	ldr	r0, [pc, #16]	@ (3402302c <_tx_timer_expiration_process+0x40>)
3402301a:	f7ff fc97 	bl	3402294c <_tx_thread_system_resume>
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
3402301e:	bf00      	nop
34023020:	3710      	adds	r7, #16
34023022:	46bd      	mov	sp, r7
34023024:	bd80      	pop	{r7, pc}
34023026:	bf00      	nop
34023028:	3404ab8c 	.word	0x3404ab8c
3402302c:	3404ac40 	.word	0x3404ac40

34023030 <_tx_timer_initialize>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
34023030:	b590      	push	{r4, r7, lr}
34023032:	b089      	sub	sp, #36	@ 0x24
34023034:	af06      	add	r7, sp, #24
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
34023036:	4b28      	ldr	r3, [pc, #160]	@ (340230d8 <_tx_timer_initialize+0xa8>)
34023038:	2200      	movs	r2, #0
3402303a:	601a      	str	r2, [r3, #0]

    /* Initialize the time-slice value to 0 to make sure it is disabled.  */
    _tx_timer_time_slice =  ((ULONG) 0);
3402303c:	4b27      	ldr	r3, [pc, #156]	@ (340230dc <_tx_timer_initialize+0xac>)
3402303e:	2200      	movs	r2, #0
34023040:	601a      	str	r2, [r3, #0]

    /* Clear the expired flags.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
34023042:	4b27      	ldr	r3, [pc, #156]	@ (340230e0 <_tx_timer_initialize+0xb0>)
34023044:	2200      	movs	r2, #0
34023046:	601a      	str	r2, [r3, #0]
    _tx_timer_expired =             TX_FALSE;
34023048:	4b26      	ldr	r3, [pc, #152]	@ (340230e4 <_tx_timer_initialize+0xb4>)
3402304a:	2200      	movs	r2, #0
3402304c:	601a      	str	r2, [r3, #0]

    /* Set the currently expired timer being processed pointer to NULL.  */
    _tx_timer_expired_timer_ptr =  TX_NULL;
3402304e:	4b26      	ldr	r3, [pc, #152]	@ (340230e8 <_tx_timer_initialize+0xb8>)
34023050:	2200      	movs	r2, #0
34023052:	601a      	str	r2, [r3, #0]

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
34023054:	2280      	movs	r2, #128	@ 0x80
34023056:	2100      	movs	r1, #0
34023058:	4824      	ldr	r0, [pc, #144]	@ (340230ec <_tx_timer_initialize+0xbc>)
3402305a:	f004 f89b 	bl	34027194 <memset>
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
3402305e:	4b24      	ldr	r3, [pc, #144]	@ (340230f0 <_tx_timer_initialize+0xc0>)
34023060:	4a22      	ldr	r2, [pc, #136]	@ (340230ec <_tx_timer_initialize+0xbc>)
34023062:	601a      	str	r2, [r3, #0]
    _tx_timer_current_ptr =  &_tx_timer_list[0];
34023064:	4b23      	ldr	r3, [pc, #140]	@ (340230f4 <_tx_timer_initialize+0xc4>)
34023066:	4a21      	ldr	r2, [pc, #132]	@ (340230ec <_tx_timer_initialize+0xbc>)
34023068:	601a      	str	r2, [r3, #0]

    /* Set the timer list end pointer to one past the actual timer list.  This is done
       to make the timer interrupt handling in assembly language a little easier.  */
    _tx_timer_list_end =     &_tx_timer_list[TX_TIMER_ENTRIES-((ULONG) 1)];
3402306a:	4b23      	ldr	r3, [pc, #140]	@ (340230f8 <_tx_timer_initialize+0xc8>)
3402306c:	4a23      	ldr	r2, [pc, #140]	@ (340230fc <_tx_timer_initialize+0xcc>)
3402306e:	601a      	str	r2, [r3, #0]
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
34023070:	4b21      	ldr	r3, [pc, #132]	@ (340230f8 <_tx_timer_initialize+0xc8>)
34023072:	681b      	ldr	r3, [r3, #0]
34023074:	3304      	adds	r3, #4
34023076:	4a20      	ldr	r2, [pc, #128]	@ (340230f8 <_tx_timer_initialize+0xc8>)
34023078:	6013      	str	r3, [r2, #0]

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
3402307a:	4b21      	ldr	r3, [pc, #132]	@ (34023100 <_tx_timer_initialize+0xd0>)
3402307c:	4a21      	ldr	r2, [pc, #132]	@ (34023104 <_tx_timer_initialize+0xd4>)
3402307e:	601a      	str	r2, [r3, #0]
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
34023080:	4b21      	ldr	r3, [pc, #132]	@ (34023108 <_tx_timer_initialize+0xd8>)
34023082:	f44f 6280 	mov.w	r2, #1024	@ 0x400
34023086:	601a      	str	r2, [r3, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
34023088:	4b20      	ldr	r3, [pc, #128]	@ (3402310c <_tx_timer_initialize+0xdc>)
3402308a:	2200      	movs	r2, #0
3402308c:	601a      	str	r2, [r3, #0]
       low-level initialization component.  */
    do
    {

        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread,
3402308e:	4b1c      	ldr	r3, [pc, #112]	@ (34023100 <_tx_timer_initialize+0xd0>)
34023090:	681b      	ldr	r3, [r3, #0]
34023092:	4a1d      	ldr	r2, [pc, #116]	@ (34023108 <_tx_timer_initialize+0xd8>)
34023094:	6812      	ldr	r2, [r2, #0]
34023096:	491d      	ldr	r1, [pc, #116]	@ (3402310c <_tx_timer_initialize+0xdc>)
34023098:	6809      	ldr	r1, [r1, #0]
3402309a:	481c      	ldr	r0, [pc, #112]	@ (3402310c <_tx_timer_initialize+0xdc>)
3402309c:	6800      	ldr	r0, [r0, #0]
3402309e:	2400      	movs	r4, #0
340230a0:	9405      	str	r4, [sp, #20]
340230a2:	2400      	movs	r4, #0
340230a4:	9404      	str	r4, [sp, #16]
340230a6:	9003      	str	r0, [sp, #12]
340230a8:	9102      	str	r1, [sp, #8]
340230aa:	9201      	str	r2, [sp, #4]
340230ac:	9300      	str	r3, [sp, #0]
340230ae:	4b18      	ldr	r3, [pc, #96]	@ (34023110 <_tx_timer_initialize+0xe0>)
340230b0:	4a18      	ldr	r2, [pc, #96]	@ (34023114 <_tx_timer_initialize+0xe4>)
340230b2:	4919      	ldr	r1, [pc, #100]	@ (34023118 <_tx_timer_initialize+0xe8>)
340230b4:	4819      	ldr	r0, [pc, #100]	@ (3402311c <_tx_timer_initialize+0xec>)
340230b6:	f7ff f9f3 	bl	340224a0 <_tx_thread_create>
340230ba:	6078      	str	r0, [r7, #4]
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)

    } while (status != TX_SUCCESS);
340230bc:	687b      	ldr	r3, [r7, #4]
340230be:	2b00      	cmp	r3, #0
340230c0:	d1e5      	bne.n	3402308e <_tx_timer_initialize+0x5e>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
340230c2:	4b17      	ldr	r3, [pc, #92]	@ (34023120 <_tx_timer_initialize+0xf0>)
340230c4:	2200      	movs	r2, #0
340230c6:	601a      	str	r2, [r3, #0]

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
340230c8:	4b16      	ldr	r3, [pc, #88]	@ (34023124 <_tx_timer_initialize+0xf4>)
340230ca:	2200      	movs	r2, #0
340230cc:	601a      	str	r2, [r3, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
340230ce:	bf00      	nop
340230d0:	370c      	adds	r7, #12
340230d2:	46bd      	mov	sp, r7
340230d4:	bd90      	pop	{r4, r7, pc}
340230d6:	bf00      	nop
340230d8:	3404ab98 	.word	0x3404ab98
340230dc:	3404b10c 	.word	0x3404b10c
340230e0:	3404ab9c 	.word	0x3404ab9c
340230e4:	3404ac2c 	.word	0x3404ac2c
340230e8:	3404ac38 	.word	0x3404ac38
340230ec:	3404aba0 	.word	0x3404aba0
340230f0:	3404ac20 	.word	0x3404ac20
340230f4:	3404ac28 	.word	0x3404ac28
340230f8:	3404ac24 	.word	0x3404ac24
340230fc:	3404ac1c 	.word	0x3404ac1c
34023100:	3404ad00 	.word	0x3404ad00
34023104:	3404ad0c 	.word	0x3404ad0c
34023108:	3404ad04 	.word	0x3404ad04
3402310c:	3404ad08 	.word	0x3404ad08
34023110:	4154494d 	.word	0x4154494d
34023114:	3402325d 	.word	0x3402325d
34023118:	3402b680 	.word	0x3402b680
3402311c:	3404ac40 	.word	0x3404ac40
34023120:	3404ac30 	.word	0x3404ac30
34023124:	3404ac34 	.word	0x3404ac34

34023128 <_tx_timer_system_activate>:
/*                                            TX_NO_TIMER is defined,     */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_activate(TX_TIMER_INTERNAL *timer_ptr)
{
34023128:	b480      	push	{r7}
3402312a:	b089      	sub	sp, #36	@ 0x24
3402312c:	af00      	add	r7, sp, #0
3402312e:	6078      	str	r0, [r7, #4]
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
34023130:	687b      	ldr	r3, [r7, #4]
34023132:	681b      	ldr	r3, [r3, #0]
34023134:	617b      	str	r3, [r7, #20]

    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
34023136:	697b      	ldr	r3, [r7, #20]
34023138:	2b00      	cmp	r3, #0
3402313a:	d04a      	beq.n	340231d2 <_tx_timer_system_activate+0xaa>
    {

        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
3402313c:	697b      	ldr	r3, [r7, #20]
3402313e:	f1b3 3fff 	cmp.w	r3, #4294967295
34023142:	d046      	beq.n	340231d2 <_tx_timer_system_activate+0xaa>
        {

            /* Valid timer activate request.  */

            /* Determine if the timer still needs activation.  */
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
34023144:	687b      	ldr	r3, [r7, #4]
34023146:	699b      	ldr	r3, [r3, #24]
34023148:	2b00      	cmp	r3, #0
3402314a:	d142      	bne.n	340231d2 <_tx_timer_system_activate+0xaa>
            {

                /* Activate the timer.  */

                /* Calculate the amount of time remaining for the timer.  */
                if (remaining_ticks > TX_TIMER_ENTRIES)
3402314c:	697b      	ldr	r3, [r7, #20]
3402314e:	2b20      	cmp	r3, #32
34023150:	d902      	bls.n	34023158 <_tx_timer_system_activate+0x30>
                {

                    /* Set expiration time to the maximum number of entries.  */
                    expiration_time =  TX_TIMER_ENTRIES - ((ULONG) 1);
34023152:	231f      	movs	r3, #31
34023154:	61bb      	str	r3, [r7, #24]
34023156:	e002      	b.n	3402315e <_tx_timer_system_activate+0x36>
                {

                    /* Timer value fits in the timer entries.  */

                    /* Set the expiration time.  */
                    expiration_time =  (remaining_ticks - ((ULONG) 1));
34023158:	697b      	ldr	r3, [r7, #20]
3402315a:	3b01      	subs	r3, #1
3402315c:	61bb      	str	r3, [r7, #24]

                /* At this point, we are ready to put the timer on one of
                   the timer lists.  */

                /* Calculate the proper place for the timer.  */
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
3402315e:	4b20      	ldr	r3, [pc, #128]	@ (340231e0 <_tx_timer_system_activate+0xb8>)
34023160:	681a      	ldr	r2, [r3, #0]
34023162:	69bb      	ldr	r3, [r7, #24]
34023164:	009b      	lsls	r3, r3, #2
34023166:	4413      	add	r3, r2
34023168:	61fb      	str	r3, [r7, #28]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
3402316a:	4b1e      	ldr	r3, [pc, #120]	@ (340231e4 <_tx_timer_system_activate+0xbc>)
3402316c:	681b      	ldr	r3, [r3, #0]
3402316e:	69fa      	ldr	r2, [r7, #28]
34023170:	429a      	cmp	r2, r3
34023172:	d30b      	bcc.n	3402318c <_tx_timer_system_activate+0x64>
                {

                    /* Wrap from the beginning of the list.  */
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
34023174:	4b1b      	ldr	r3, [pc, #108]	@ (340231e4 <_tx_timer_system_activate+0xbc>)
34023176:	681b      	ldr	r3, [r3, #0]
34023178:	69fa      	ldr	r2, [r7, #28]
3402317a:	1ad3      	subs	r3, r2, r3
3402317c:	109b      	asrs	r3, r3, #2
3402317e:	613b      	str	r3, [r7, #16]
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
34023180:	4b19      	ldr	r3, [pc, #100]	@ (340231e8 <_tx_timer_system_activate+0xc0>)
34023182:	681a      	ldr	r2, [r3, #0]
34023184:	693b      	ldr	r3, [r7, #16]
34023186:	009b      	lsls	r3, r3, #2
34023188:	4413      	add	r3, r2
3402318a:	61fb      	str	r3, [r7, #28]
                }

                /* Now put the timer on this list.  */
                if ((*timer_list) == TX_NULL)
3402318c:	69fb      	ldr	r3, [r7, #28]
3402318e:	681b      	ldr	r3, [r3, #0]
34023190:	2b00      	cmp	r3, #0
34023192:	d109      	bne.n	340231a8 <_tx_timer_system_activate+0x80>
                {

                    /* This list is NULL, just put the new timer on it.  */

                    /* Setup the links in this timer.  */
                    timer_ptr -> tx_timer_internal_active_next =      timer_ptr;
34023194:	687b      	ldr	r3, [r7, #4]
34023196:	687a      	ldr	r2, [r7, #4]
34023198:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
3402319a:	687b      	ldr	r3, [r7, #4]
3402319c:	687a      	ldr	r2, [r7, #4]
3402319e:	615a      	str	r2, [r3, #20]

                    /* Setup the list head pointer.  */
                    *timer_list =  timer_ptr;
340231a0:	69fb      	ldr	r3, [r7, #28]
340231a2:	687a      	ldr	r2, [r7, #4]
340231a4:	601a      	str	r2, [r3, #0]
340231a6:	e011      	b.n	340231cc <_tx_timer_system_activate+0xa4>
                }
                else
                {

                    /* This list is not NULL, add current timer to the end. */
                    next_timer =                                        *timer_list;
340231a8:	69fb      	ldr	r3, [r7, #28]
340231aa:	681b      	ldr	r3, [r3, #0]
340231ac:	60fb      	str	r3, [r7, #12]
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
340231ae:	68fb      	ldr	r3, [r7, #12]
340231b0:	695b      	ldr	r3, [r3, #20]
340231b2:	60bb      	str	r3, [r7, #8]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
340231b4:	68bb      	ldr	r3, [r7, #8]
340231b6:	687a      	ldr	r2, [r7, #4]
340231b8:	611a      	str	r2, [r3, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
340231ba:	68fb      	ldr	r3, [r7, #12]
340231bc:	687a      	ldr	r2, [r7, #4]
340231be:	615a      	str	r2, [r3, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
340231c0:	687b      	ldr	r3, [r7, #4]
340231c2:	68fa      	ldr	r2, [r7, #12]
340231c4:	611a      	str	r2, [r3, #16]
                    timer_ptr -> tx_timer_internal_active_previous =    previous_timer;
340231c6:	687b      	ldr	r3, [r7, #4]
340231c8:	68ba      	ldr	r2, [r7, #8]
340231ca:	615a      	str	r2, [r3, #20]
                }

                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
340231cc:	687b      	ldr	r3, [r7, #4]
340231ce:	69fa      	ldr	r2, [r7, #28]
340231d0:	619a      	str	r2, [r3, #24]
            }
        }
    }
}
340231d2:	bf00      	nop
340231d4:	3724      	adds	r7, #36	@ 0x24
340231d6:	46bd      	mov	sp, r7
340231d8:	f85d 7b04 	ldr.w	r7, [sp], #4
340231dc:	4770      	bx	lr
340231de:	bf00      	nop
340231e0:	3404ac28 	.word	0x3404ac28
340231e4:	3404ac24 	.word	0x3404ac24
340231e8:	3404ac20 	.word	0x3404ac20

340231ec <_tx_timer_system_deactivate>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_system_deactivate(TX_TIMER_INTERNAL *timer_ptr)
{
340231ec:	b480      	push	{r7}
340231ee:	b087      	sub	sp, #28
340231f0:	af00      	add	r7, sp, #0
340231f2:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
340231f4:	687b      	ldr	r3, [r7, #4]
340231f6:	699b      	ldr	r3, [r3, #24]
340231f8:	617b      	str	r3, [r7, #20]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
340231fa:	697b      	ldr	r3, [r7, #20]
340231fc:	2b00      	cmp	r3, #0
340231fe:	d026      	beq.n	3402324e <_tx_timer_system_deactivate+0x62>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
34023200:	687b      	ldr	r3, [r7, #4]
34023202:	691b      	ldr	r3, [r3, #16]
34023204:	613b      	str	r3, [r7, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
34023206:	687a      	ldr	r2, [r7, #4]
34023208:	693b      	ldr	r3, [r7, #16]
3402320a:	429a      	cmp	r2, r3
3402320c:	d108      	bne.n	34023220 <_tx_timer_system_deactivate+0x34>
        {

            /* Yes, the only timer on the list.  */

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
3402320e:	697b      	ldr	r3, [r7, #20]
34023210:	681b      	ldr	r3, [r3, #0]
34023212:	687a      	ldr	r2, [r7, #4]
34023214:	429a      	cmp	r2, r3
34023216:	d117      	bne.n	34023248 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the head pointer.  */
                *(list_head) =  TX_NULL;
34023218:	697b      	ldr	r3, [r7, #20]
3402321a:	2200      	movs	r2, #0
3402321c:	601a      	str	r2, [r3, #0]
3402321e:	e013      	b.n	34023248 <_tx_timer_system_deactivate+0x5c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
34023220:	687b      	ldr	r3, [r7, #4]
34023222:	695b      	ldr	r3, [r3, #20]
34023224:	60fb      	str	r3, [r7, #12]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
34023226:	693b      	ldr	r3, [r7, #16]
34023228:	68fa      	ldr	r2, [r7, #12]
3402322a:	615a      	str	r2, [r3, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
3402322c:	68fb      	ldr	r3, [r7, #12]
3402322e:	693a      	ldr	r2, [r7, #16]
34023230:	611a      	str	r2, [r3, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
34023232:	697b      	ldr	r3, [r7, #20]
34023234:	681b      	ldr	r3, [r3, #0]
34023236:	687a      	ldr	r2, [r7, #4]
34023238:	429a      	cmp	r2, r3
3402323a:	d105      	bne.n	34023248 <_tx_timer_system_deactivate+0x5c>
            {

                /* Update the next timer in the list with the list head pointer.  */
                next_timer -> tx_timer_internal_list_head =  list_head;
3402323c:	693b      	ldr	r3, [r7, #16]
3402323e:	697a      	ldr	r2, [r7, #20]
34023240:	619a      	str	r2, [r3, #24]

                /* Update the head pointer.  */
                *(list_head) =  next_timer;
34023242:	697b      	ldr	r3, [r7, #20]
34023244:	693a      	ldr	r2, [r7, #16]
34023246:	601a      	str	r2, [r3, #0]
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
34023248:	687b      	ldr	r3, [r7, #4]
3402324a:	2200      	movs	r2, #0
3402324c:	619a      	str	r2, [r3, #24]
    }
}
3402324e:	bf00      	nop
34023250:	371c      	adds	r7, #28
34023252:	46bd      	mov	sp, r7
34023254:	f85d 7b04 	ldr.w	r7, [sp], #4
34023258:	4770      	bx	lr
	...

3402325c <_tx_timer_thread_entry>:
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
#ifndef TX_TIMER_PROCESS_IN_ISR
VOID  _tx_timer_thread_entry(ULONG timer_thread_input)
{
3402325c:	b580      	push	{r7, lr}
3402325e:	b098      	sub	sp, #96	@ 0x60
34023260:	af00      	add	r7, sp, #0
34023262:	6078      	str	r0, [r7, #4]
TX_TIMER_INTERNAL           *reactivate_timer;
TX_TIMER_INTERNAL           *next_timer;
TX_TIMER_INTERNAL           *previous_timer;
TX_TIMER_INTERNAL           *current_timer;
VOID                        (*timeout_function)(ULONG id);
ULONG                       timeout_param =  ((ULONG) 0);
34023264:	2300      	movs	r3, #0
34023266:	657b      	str	r3, [r7, #84]	@ 0x54
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
34023268:	687b      	ldr	r3, [r7, #4]
3402326a:	4a73      	ldr	r2, [pc, #460]	@ (34023438 <_tx_timer_thread_entry+0x1dc>)
3402326c:	4293      	cmp	r3, r2
3402326e:	f040 80de 	bne.w	3402342e <_tx_timer_thread_entry+0x1d2>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34023272:	f3ef 8310 	mrs	r3, PRIMASK
34023276:	643b      	str	r3, [r7, #64]	@ 0x40
    return(posture);
34023278:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    int_posture = __get_interrupt_posture();
3402327a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    __asm__ volatile ("CPSID i" : : : "memory");
3402327c:	b672      	cpsid	i
    return(int_posture);
3402327e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
        {

            /* First, move the current list pointer and clear the timer
               expired value.  This allows the interrupt handling portion
               to continue looking for timer expirations.  */
            TX_DISABLE
34023280:	65fb      	str	r3, [r7, #92]	@ 0x5c

            /* Save the current timer expiration list pointer.  */
            expired_timers =  *_tx_timer_current_ptr;
34023282:	4b6e      	ldr	r3, [pc, #440]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
34023284:	681b      	ldr	r3, [r3, #0]
34023286:	681b      	ldr	r3, [r3, #0]
34023288:	60fb      	str	r3, [r7, #12]

            /* Modify the head pointer in the first timer in the list, if there
               is one!  */
            if (expired_timers != TX_NULL)
3402328a:	68fb      	ldr	r3, [r7, #12]
3402328c:	2b00      	cmp	r3, #0
3402328e:	d003      	beq.n	34023298 <_tx_timer_thread_entry+0x3c>
            {

                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
34023290:	68fb      	ldr	r3, [r7, #12]
34023292:	f107 020c 	add.w	r2, r7, #12
34023296:	619a      	str	r2, [r3, #24]
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
34023298:	4b68      	ldr	r3, [pc, #416]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
3402329a:	681b      	ldr	r3, [r3, #0]
3402329c:	2200      	movs	r2, #0
3402329e:	601a      	str	r2, [r3, #0]

            /* Move the current pointer up one timer entry wrap if we get to
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
340232a0:	4b66      	ldr	r3, [pc, #408]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
340232a2:	681b      	ldr	r3, [r3, #0]
340232a4:	3304      	adds	r3, #4
340232a6:	4a65      	ldr	r2, [pc, #404]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
340232a8:	6013      	str	r3, [r2, #0]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
340232aa:	4b64      	ldr	r3, [pc, #400]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
340232ac:	681a      	ldr	r2, [r3, #0]
340232ae:	4b64      	ldr	r3, [pc, #400]	@ (34023440 <_tx_timer_thread_entry+0x1e4>)
340232b0:	681b      	ldr	r3, [r3, #0]
340232b2:	429a      	cmp	r2, r3
340232b4:	d103      	bne.n	340232be <_tx_timer_thread_entry+0x62>
            {

                _tx_timer_current_ptr =  _tx_timer_list_start;
340232b6:	4b63      	ldr	r3, [pc, #396]	@ (34023444 <_tx_timer_thread_entry+0x1e8>)
340232b8:	681b      	ldr	r3, [r3, #0]
340232ba:	4a60      	ldr	r2, [pc, #384]	@ (3402343c <_tx_timer_thread_entry+0x1e0>)
340232bc:	6013      	str	r3, [r2, #0]
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
340232be:	4b62      	ldr	r3, [pc, #392]	@ (34023448 <_tx_timer_thread_entry+0x1ec>)
340232c0:	2200      	movs	r2, #0
340232c2:	601a      	str	r2, [r3, #0]
340232c4:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
340232c6:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340232c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340232ca:	f383 8810 	msr	PRIMASK, r3
}
340232ce:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340232d0:	f3ef 8310 	mrs	r3, PRIMASK
340232d4:	63bb      	str	r3, [r7, #56]	@ 0x38
    return(posture);
340232d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
    int_posture = __get_interrupt_posture();
340232d8:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm__ volatile ("CPSID i" : : : "memory");
340232da:	b672      	cpsid	i
    return(int_posture);
340232dc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34

            /* Restore interrupts temporarily.  */
            TX_RESTORE

            /* Disable interrupts again.  */
            TX_DISABLE
340232de:	65fb      	str	r3, [r7, #92]	@ 0x5c

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
340232e0:	e07f      	b.n	340233e2 <_tx_timer_thread_entry+0x186>
            {

                /* Something is on the list.  Remove it and process the expiration.  */
                current_timer =  expired_timers;
340232e2:	68fb      	ldr	r3, [r7, #12]
340232e4:	64fb      	str	r3, [r7, #76]	@ 0x4c

                /* Pickup the next timer.  */
                next_timer =  expired_timers -> tx_timer_internal_active_next;
340232e6:	68fb      	ldr	r3, [r7, #12]
340232e8:	691b      	ldr	r3, [r3, #16]
340232ea:	64bb      	str	r3, [r7, #72]	@ 0x48

                /* Set the reactivate_timer to NULL.  */
                reactivate_timer =  TX_NULL;
340232ec:	2300      	movs	r3, #0
340232ee:	60bb      	str	r3, [r7, #8]

                /* Determine if this is the only timer.  */
                if (current_timer == next_timer)
340232f0:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
340232f2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
340232f4:	429a      	cmp	r2, r3
340232f6:	d102      	bne.n	340232fe <_tx_timer_thread_entry+0xa2>
                {

                    /* Yes, this is the only timer in the list.  */

                    /* Set the head pointer to NULL.  */
                    expired_timers =  TX_NULL;
340232f8:	2300      	movs	r3, #0
340232fa:	60fb      	str	r3, [r7, #12]
340232fc:	e00e      	b.n	3402331c <_tx_timer_thread_entry+0xc0>
                {

                    /* No, not the only expired timer.  */

                    /* Remove this timer from the expired list.  */
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
340232fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023300:	695b      	ldr	r3, [r3, #20]
34023302:	647b      	str	r3, [r7, #68]	@ 0x44
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
34023304:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34023306:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34023308:	615a      	str	r2, [r3, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
3402330a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402330c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3402330e:	611a      	str	r2, [r3, #16]

                    /* Modify the next timer's list head to point at the current list head.  */
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
34023310:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34023312:	f107 020c 	add.w	r2, r7, #12
34023316:	619a      	str	r2, [r3, #24]

                    /* Set the list head pointer.  */
                    expired_timers =  next_timer;
34023318:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3402331a:	60fb      	str	r3, [r7, #12]

                /* In any case, the timer is now off of the expired list.  */

                /* Determine if the timer has expired or if it is just a really
                   big timer that needs to be placed in the list again.  */
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
3402331c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402331e:	681b      	ldr	r3, [r3, #0]
34023320:	2b20      	cmp	r3, #32
34023322:	d911      	bls.n	34023348 <_tx_timer_thread_entry+0xec>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
34023324:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023326:	681b      	ldr	r3, [r3, #0]
34023328:	f1a3 0220 	sub.w	r2, r3, #32
                    current_timer -> tx_timer_internal_remaining_ticks =
3402332c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402332e:	601a      	str	r2, [r3, #0]

                    /* Set the timeout function to NULL in order to bypass the
                       expiration.  */
                    timeout_function =  TX_NULL;
34023330:	2300      	movs	r3, #0
34023332:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
34023334:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023336:	f107 0208 	add.w	r2, r7, #8
3402333a:	619a      	str	r2, [r3, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
3402333c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402333e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34023340:	611a      	str	r2, [r3, #16]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
34023342:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023344:	60bb      	str	r3, [r7, #8]
34023346:	e01a      	b.n	3402337e <_tx_timer_thread_entry+0x122>
                    }
#endif

                    /* Copy the calling function and ID into local variables before interrupts
                       are re-enabled.  */
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
34023348:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402334a:	689b      	ldr	r3, [r3, #8]
3402334c:	65bb      	str	r3, [r7, #88]	@ 0x58
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
3402334e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023350:	68db      	ldr	r3, [r3, #12]
34023352:	657b      	str	r3, [r7, #84]	@ 0x54

                    /* Copy the reinitialize ticks into the remaining ticks.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
34023354:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023356:	685a      	ldr	r2, [r3, #4]
34023358:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402335a:	601a      	str	r2, [r3, #0]

                    /* Determine if the timer should be reactivated.  */
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
3402335c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402335e:	681b      	ldr	r3, [r3, #0]
34023360:	2b00      	cmp	r3, #0
34023362:	d009      	beq.n	34023378 <_tx_timer_thread_entry+0x11c>

                        /* Make the timer appear that it is still active while processing
                           the expiration routine and with interrupts enabled.  This will
                           permit proper processing of a timer deactivate from both the
                           expiration routine and an ISR.  */
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
34023364:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023366:	f107 0208 	add.w	r2, r7, #8
3402336a:	619a      	str	r2, [r3, #24]
                        current_timer -> tx_timer_internal_active_next =  current_timer;
3402336c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402336e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
34023370:	611a      	str	r2, [r3, #16]

                        /* Setup the temporary timer list head pointer.  */
                        reactivate_timer =  current_timer;
34023372:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023374:	60bb      	str	r3, [r7, #8]
34023376:	e002      	b.n	3402337e <_tx_timer_thread_entry+0x122>
                    else
                    {

                        /* Set the list pointer of this timer to NULL.  This is used to indicate
                           the timer is no longer active.  */
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
34023378:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3402337a:	2200      	movs	r2, #0
3402337c:	619a      	str	r2, [r3, #24]
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
3402337e:	4a33      	ldr	r2, [pc, #204]	@ (3402344c <_tx_timer_thread_entry+0x1f0>)
34023380:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023382:	6013      	str	r3, [r2, #0]
34023384:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34023386:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023388:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3402338a:	f383 8810 	msr	PRIMASK, r3
}
3402338e:	bf00      	nop

                /* Restore interrupts for timer expiration call.  */
                TX_RESTORE

                /* Call the timer-expiration function, if non-NULL.  */
                if (timeout_function != TX_NULL)
34023390:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34023392:	2b00      	cmp	r3, #0
34023394:	d002      	beq.n	3402339c <_tx_timer_thread_entry+0x140>
                {

                    (timeout_function) (timeout_param);
34023396:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34023398:	6d78      	ldr	r0, [r7, #84]	@ 0x54
3402339a:	4798      	blx	r3
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
3402339c:	f3ef 8310 	mrs	r3, PRIMASK
340233a0:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
340233a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
340233a4:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
340233a6:	b672      	cpsid	i
    return(int_posture);
340233a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
                }

                /* Lockout interrupts again.  */
                TX_DISABLE
340233aa:	65fb      	str	r3, [r7, #92]	@ 0x5c

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;
340233ac:	4b27      	ldr	r3, [pc, #156]	@ (3402344c <_tx_timer_thread_entry+0x1f0>)
340233ae:	2200      	movs	r2, #0
340233b0:	601a      	str	r2, [r3, #0]

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
340233b2:	68bb      	ldr	r3, [r7, #8]
340233b4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
340233b6:	429a      	cmp	r2, r3
340233b8:	d105      	bne.n	340233c6 <_tx_timer_thread_entry+0x16a>
#else

                    /* Reactivate through the timer activate function.  */

                    /* Clear the list head for the timer activate call.  */
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
340233ba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
340233bc:	2200      	movs	r2, #0
340233be:	619a      	str	r2, [r3, #24]

                    /* Activate the current timer.  */
                    _tx_timer_system_activate(current_timer);
340233c0:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
340233c2:	f7ff feb1 	bl	34023128 <_tx_timer_system_activate>
340233c6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
340233c8:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340233ca:	69bb      	ldr	r3, [r7, #24]
340233cc:	f383 8810 	msr	PRIMASK, r3
}
340233d0:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340233d2:	f3ef 8310 	mrs	r3, PRIMASK
340233d6:	623b      	str	r3, [r7, #32]
    return(posture);
340233d8:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
340233da:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
340233dc:	b672      	cpsid	i
    return(int_posture);
340233de:	69fb      	ldr	r3, [r7, #28]

                /* Restore interrupts.  */
                TX_RESTORE

                /* Lockout interrupts again.  */
                TX_DISABLE
340233e0:	65fb      	str	r3, [r7, #92]	@ 0x5c
            while (expired_timers != TX_NULL)
340233e2:	68fb      	ldr	r3, [r7, #12]
340233e4:	2b00      	cmp	r3, #0
340233e6:	f47f af7c 	bne.w	340232e2 <_tx_timer_thread_entry+0x86>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
340233ea:	4b17      	ldr	r3, [pc, #92]	@ (34023448 <_tx_timer_thread_entry+0x1ec>)
340233ec:	681b      	ldr	r3, [r3, #0]
340233ee:	2b00      	cmp	r3, #0
340233f0:	d116      	bne.n	34023420 <_tx_timer_thread_entry+0x1c4>
            {

                /* Otherwise, no timer expiration, so suspend the thread.  */

                /* Build pointer to the timer thread.  */
                thread_ptr =  &_tx_timer_thread;
340233f2:	4b17      	ldr	r3, [pc, #92]	@ (34023450 <_tx_timer_thread_entry+0x1f4>)
340233f4:	653b      	str	r3, [r7, #80]	@ 0x50

                /* Set the status to suspending, in order to indicate the
                   suspension is in progress.  */
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
340233f6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340233f8:	2203      	movs	r2, #3
340233fa:	631a      	str	r2, [r3, #48]	@ 0x30
                /* Restore interrupts.  */
                TX_RESTORE
#else

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
340233fc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
340233fe:	2201      	movs	r2, #1
34023400:	639a      	str	r2, [r3, #56]	@ 0x38

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
34023402:	4b14      	ldr	r3, [pc, #80]	@ (34023454 <_tx_timer_thread_entry+0x1f8>)
34023404:	681b      	ldr	r3, [r3, #0]
34023406:	3301      	adds	r3, #1
34023408:	4a12      	ldr	r2, [pc, #72]	@ (34023454 <_tx_timer_thread_entry+0x1f8>)
3402340a:	6013      	str	r3, [r2, #0]
3402340c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
3402340e:	617b      	str	r3, [r7, #20]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023410:	697b      	ldr	r3, [r7, #20]
34023412:	f383 8810 	msr	PRIMASK, r3
}
34023416:	bf00      	nop

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
34023418:	6d38      	ldr	r0, [r7, #80]	@ 0x50
3402341a:	f7ff fbab 	bl	34022b74 <_tx_thread_system_suspend>
3402341e:	e728      	b.n	34023272 <_tx_timer_thread_entry+0x16>
34023420:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34023422:	613b      	str	r3, [r7, #16]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023424:	693b      	ldr	r3, [r7, #16]
34023426:	f383 8810 	msr	PRIMASK, r3
}
3402342a:	bf00      	nop
            TX_DISABLE
3402342c:	e721      	b.n	34023272 <_tx_timer_thread_entry+0x16>

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif

}
3402342e:	bf00      	nop
34023430:	3760      	adds	r7, #96	@ 0x60
34023432:	46bd      	mov	sp, r7
34023434:	bd80      	pop	{r7, pc}
34023436:	bf00      	nop
34023438:	4154494d 	.word	0x4154494d
3402343c:	3404ac28 	.word	0x3404ac28
34023440:	3404ac24 	.word	0x3404ac24
34023444:	3404ac20 	.word	0x3404ac20
34023448:	3404ac2c 	.word	0x3404ac2c
3402344c:	3404ac38 	.word	0x3404ac38
34023450:	3404ac40 	.word	0x3404ac40
34023454:	3404ab8c 	.word	0x3404ab8c

34023458 <_txe_mutex_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit, UINT mutex_control_block_size)
{
34023458:	b580      	push	{r7, lr}
3402345a:	b092      	sub	sp, #72	@ 0x48
3402345c:	af00      	add	r7, sp, #0
3402345e:	60f8      	str	r0, [r7, #12]
34023460:	60b9      	str	r1, [r7, #8]
34023462:	607a      	str	r2, [r7, #4]
34023464:	603b      	str	r3, [r7, #0]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34023466:	2300      	movs	r3, #0
34023468:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
3402346a:	68fb      	ldr	r3, [r7, #12]
3402346c:	2b00      	cmp	r3, #0
3402346e:	d102      	bne.n	34023476 <_txe_mutex_create+0x1e>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34023470:	231c      	movs	r3, #28
34023472:	647b      	str	r3, [r7, #68]	@ 0x44
34023474:	e053      	b.n	3402351e <_txe_mutex_create+0xc6>
    }

    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
34023476:	683b      	ldr	r3, [r7, #0]
34023478:	2b34      	cmp	r3, #52	@ 0x34
3402347a:	d002      	beq.n	34023482 <_txe_mutex_create+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
3402347c:	231c      	movs	r3, #28
3402347e:	647b      	str	r3, [r7, #68]	@ 0x44
34023480:	e04d      	b.n	3402351e <_txe_mutex_create+0xc6>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34023482:	f3ef 8310 	mrs	r3, PRIMASK
34023486:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
34023488:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
3402348a:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
3402348c:	b672      	cpsid	i
    return(int_posture);
3402348e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34023490:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
34023492:	4b3a      	ldr	r3, [pc, #232]	@ (3402357c <_txe_mutex_create+0x124>)
34023494:	681b      	ldr	r3, [r3, #0]
34023496:	3301      	adds	r3, #1
34023498:	4a38      	ldr	r2, [pc, #224]	@ (3402357c <_txe_mutex_create+0x124>)
3402349a:	6013      	str	r3, [r2, #0]
3402349c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402349e:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340234a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340234a2:	f383 8810 	msr	PRIMASK, r3
}
340234a6:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_mutex =   _tx_mutex_created_ptr;
340234a8:	4b35      	ldr	r3, [pc, #212]	@ (34023580 <_txe_mutex_create+0x128>)
340234aa:	681b      	ldr	r3, [r3, #0]
340234ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
340234ae:	2300      	movs	r3, #0
340234b0:	643b      	str	r3, [r7, #64]	@ 0x40
340234b2:	e009      	b.n	340234c8 <_txe_mutex_create+0x70>
        {

            /* Determine if this mutex matches the mutex in the list.  */
            if (mutex_ptr == next_mutex)
340234b4:	68fa      	ldr	r2, [r7, #12]
340234b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340234b8:	429a      	cmp	r2, r3
340234ba:	d00b      	beq.n	340234d4 <_txe_mutex_create+0x7c>
            }
            else
            {

                /* Move to the next mutex.  */
                next_mutex =  next_mutex -> tx_mutex_created_next;
340234bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340234be:	6a1b      	ldr	r3, [r3, #32]
340234c0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
340234c2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340234c4:	3301      	adds	r3, #1
340234c6:	643b      	str	r3, [r7, #64]	@ 0x40
340234c8:	4b2e      	ldr	r3, [pc, #184]	@ (34023584 <_txe_mutex_create+0x12c>)
340234ca:	681b      	ldr	r3, [r3, #0]
340234cc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
340234ce:	429a      	cmp	r2, r3
340234d0:	d3f0      	bcc.n	340234b4 <_txe_mutex_create+0x5c>
340234d2:	e000      	b.n	340234d6 <_txe_mutex_create+0x7e>
                break;
340234d4:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340234d6:	f3ef 8310 	mrs	r3, PRIMASK
340234da:	623b      	str	r3, [r7, #32]
    return(posture);
340234dc:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
340234de:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
340234e0:	b672      	cpsid	i
    return(int_posture);
340234e2:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
340234e4:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
340234e6:	4b25      	ldr	r3, [pc, #148]	@ (3402357c <_txe_mutex_create+0x124>)
340234e8:	681b      	ldr	r3, [r3, #0]
340234ea:	3b01      	subs	r3, #1
340234ec:	4a23      	ldr	r2, [pc, #140]	@ (3402357c <_txe_mutex_create+0x124>)
340234ee:	6013      	str	r3, [r2, #0]
340234f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340234f2:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340234f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340234f6:	f383 8810 	msr	PRIMASK, r3
}
340234fa:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
340234fc:	f7ff f9ec 	bl	340228d8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate mutex.  */
        if (mutex_ptr == next_mutex)
34023500:	68fa      	ldr	r2, [r7, #12]
34023502:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34023504:	429a      	cmp	r2, r3
34023506:	d102      	bne.n	3402350e <_txe_mutex_create+0xb6>
        {

            /* Mutex is already created, return appropriate error code.  */
            status =  TX_MUTEX_ERROR;
34023508:	231c      	movs	r3, #28
3402350a:	647b      	str	r3, [r7, #68]	@ 0x44
3402350c:	e007      	b.n	3402351e <_txe_mutex_create+0xc6>
        }
        else
        {

            /* Check for a valid inherit option.  */
            if (inherit != TX_INHERIT)
3402350e:	687b      	ldr	r3, [r7, #4]
34023510:	2b01      	cmp	r3, #1
34023512:	d004      	beq.n	3402351e <_txe_mutex_create+0xc6>
            {

                if (inherit != TX_NO_INHERIT)
34023514:	687b      	ldr	r3, [r7, #4]
34023516:	2b00      	cmp	r3, #0
34023518:	d001      	beq.n	3402351e <_txe_mutex_create+0xc6>
                {

                    /* Inherit option is illegal.  */
                    status =  TX_INHERIT_ERROR;
3402351a:	231f      	movs	r3, #31
3402351c:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3402351e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34023520:	2b00      	cmp	r3, #0
34023522:	d11d      	bne.n	34023560 <_txe_mutex_create+0x108>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
34023524:	4b18      	ldr	r3, [pc, #96]	@ (34023588 <_txe_mutex_create+0x130>)
34023526:	681b      	ldr	r3, [r3, #0]
34023528:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Check for invalid caller of this function.  First check for a calling thread.  */
        if (thread_ptr == &_tx_timer_thread)
3402352a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
3402352c:	4a17      	ldr	r2, [pc, #92]	@ (3402358c <_txe_mutex_create+0x134>)
3402352e:	4293      	cmp	r3, r2
34023530:	d101      	bne.n	34023536 <_txe_mutex_create+0xde>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
34023532:	2313      	movs	r3, #19
34023534:	647b      	str	r3, [r7, #68]	@ 0x44
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023536:	f3ef 8305 	mrs	r3, IPSR
3402353a:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
3402353c:	69ba      	ldr	r2, [r7, #24]
        }
#endif

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
3402353e:	4b14      	ldr	r3, [pc, #80]	@ (34023590 <_txe_mutex_create+0x138>)
34023540:	681b      	ldr	r3, [r3, #0]
34023542:	4313      	orrs	r3, r2
34023544:	2b00      	cmp	r3, #0
34023546:	d00b      	beq.n	34023560 <_txe_mutex_create+0x108>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023548:	f3ef 8305 	mrs	r3, IPSR
3402354c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
3402354e:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34023550:	4b0f      	ldr	r3, [pc, #60]	@ (34023590 <_txe_mutex_create+0x138>)
34023552:	681b      	ldr	r3, [r3, #0]
34023554:	4313      	orrs	r3, r2
34023556:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
3402355a:	d201      	bcs.n	34023560 <_txe_mutex_create+0x108>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
3402355c:	2313      	movs	r3, #19
3402355e:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34023560:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34023562:	2b00      	cmp	r3, #0
34023564:	d105      	bne.n	34023572 <_txe_mutex_create+0x11a>
    {

        /* Call actual mutex create function.  */
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
34023566:	687a      	ldr	r2, [r7, #4]
34023568:	68b9      	ldr	r1, [r7, #8]
3402356a:	68f8      	ldr	r0, [r7, #12]
3402356c:	f7fd ff0e 	bl	3402138c <_tx_mutex_create>
34023570:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
34023572:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34023574:	4618      	mov	r0, r3
34023576:	3748      	adds	r7, #72	@ 0x48
34023578:	46bd      	mov	sp, r7
3402357a:	bd80      	pop	{r7, pc}
3402357c:	3404ab8c 	.word	0x3404ab8c
34023580:	3404aad0 	.word	0x3404aad0
34023584:	3404aad4 	.word	0x3404aad4
34023588:	3404aaf0 	.word	0x3404aaf0
3402358c:	3404ac40 	.word	0x3404ac40
34023590:	3404148c 	.word	0x3404148c

34023594 <_txe_mutex_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_delete(TX_MUTEX *mutex_ptr)
{
34023594:	b580      	push	{r7, lr}
34023596:	b086      	sub	sp, #24
34023598:	af00      	add	r7, sp, #0
3402359a:	6078      	str	r0, [r7, #4]


#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Default status to success.  */
    status =  TX_SUCCESS;
3402359c:	2300      	movs	r3, #0
3402359e:	617b      	str	r3, [r7, #20]
#endif

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
340235a0:	687b      	ldr	r3, [r7, #4]
340235a2:	2b00      	cmp	r3, #0
340235a4:	d102      	bne.n	340235ac <_txe_mutex_delete+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
340235a6:	231c      	movs	r3, #28
340235a8:	617b      	str	r3, [r7, #20]
340235aa:	e023      	b.n	340235f4 <_txe_mutex_delete+0x60>
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
340235ac:	687b      	ldr	r3, [r7, #4]
340235ae:	681b      	ldr	r3, [r3, #0]
340235b0:	4a13      	ldr	r2, [pc, #76]	@ (34023600 <_txe_mutex_delete+0x6c>)
340235b2:	4293      	cmp	r3, r2
340235b4:	d002      	beq.n	340235bc <_txe_mutex_delete+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
340235b6:	231c      	movs	r3, #28
340235b8:	617b      	str	r3, [r7, #20]
340235ba:	e01b      	b.n	340235f4 <_txe_mutex_delete+0x60>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
340235bc:	f3ef 8305 	mrs	r3, IPSR
340235c0:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
340235c2:	68fa      	ldr	r2, [r7, #12]
    }

    /* Check for invalid caller of this function.  */

    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
340235c4:	4b0f      	ldr	r3, [pc, #60]	@ (34023604 <_txe_mutex_delete+0x70>)
340235c6:	681b      	ldr	r3, [r3, #0]
340235c8:	4313      	orrs	r3, r2
340235ca:	2b00      	cmp	r3, #0
340235cc:	d002      	beq.n	340235d4 <_txe_mutex_delete+0x40>
    {

        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
340235ce:	2313      	movs	r3, #19
340235d0:	617b      	str	r3, [r7, #20]
340235d2:	e00f      	b.n	340235f4 <_txe_mutex_delete+0x60>
    {

#ifndef TX_TIMER_PROCESS_IN_ISR

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(thread_ptr)
340235d4:	4b0c      	ldr	r3, [pc, #48]	@ (34023608 <_txe_mutex_delete+0x74>)
340235d6:	681b      	ldr	r3, [r3, #0]
340235d8:	613b      	str	r3, [r7, #16]

        /* Is the caller the system timer thread?  */
        if (thread_ptr == &_tx_timer_thread)
340235da:	693b      	ldr	r3, [r7, #16]
340235dc:	4a0b      	ldr	r2, [pc, #44]	@ (3402360c <_txe_mutex_delete+0x78>)
340235de:	4293      	cmp	r3, r2
340235e0:	d101      	bne.n	340235e6 <_txe_mutex_delete+0x52>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
340235e2:	2313      	movs	r3, #19
340235e4:	617b      	str	r3, [r7, #20]
        }

        /* Determine if everything is okay.  */
        if (status == TX_SUCCESS)
340235e6:	697b      	ldr	r3, [r7, #20]
340235e8:	2b00      	cmp	r3, #0
340235ea:	d103      	bne.n	340235f4 <_txe_mutex_delete+0x60>
        {
#endif

            /* Call actual mutex delete function.  */
            status =  _tx_mutex_delete(mutex_ptr);
340235ec:	6878      	ldr	r0, [r7, #4]
340235ee:	f7fd ff27 	bl	34021440 <_tx_mutex_delete>
340235f2:	6178      	str	r0, [r7, #20]
        }
#endif
    }

    /* Return completion status.  */
    return(status);
340235f4:	697b      	ldr	r3, [r7, #20]
}
340235f6:	4618      	mov	r0, r3
340235f8:	3718      	adds	r7, #24
340235fa:	46bd      	mov	sp, r7
340235fc:	bd80      	pop	{r7, pc}
340235fe:	bf00      	nop
34023600:	4d555445 	.word	0x4d555445
34023604:	3404148c 	.word	0x3404148c
34023608:	3404aaf0 	.word	0x3404aaf0
3402360c:	3404ac40 	.word	0x3404ac40

34023610 <_txe_mutex_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
34023610:	b580      	push	{r7, lr}
34023612:	b088      	sub	sp, #32
34023614:	af00      	add	r7, sp, #0
34023616:	6078      	str	r0, [r7, #4]
34023618:	6039      	str	r1, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
3402361a:	2300      	movs	r3, #0
3402361c:	61fb      	str	r3, [r7, #28]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
3402361e:	687b      	ldr	r3, [r7, #4]
34023620:	2b00      	cmp	r3, #0
34023622:	d102      	bne.n	3402362a <_txe_mutex_get+0x1a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34023624:	231c      	movs	r3, #28
34023626:	61fb      	str	r3, [r7, #28]
34023628:	e01f      	b.n	3402366a <_txe_mutex_get+0x5a>
    }

    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
3402362a:	687b      	ldr	r3, [r7, #4]
3402362c:	681b      	ldr	r3, [r3, #0]
3402362e:	4a21      	ldr	r2, [pc, #132]	@ (340236b4 <_txe_mutex_get+0xa4>)
34023630:	4293      	cmp	r3, r2
34023632:	d002      	beq.n	3402363a <_txe_mutex_get+0x2a>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
34023634:	231c      	movs	r3, #28
34023636:	61fb      	str	r3, [r7, #28]
34023638:	e017      	b.n	3402366a <_txe_mutex_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
3402363a:	683b      	ldr	r3, [r7, #0]
3402363c:	2b00      	cmp	r3, #0
3402363e:	d014      	beq.n	3402366a <_txe_mutex_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023640:	f3ef 8305 	mrs	r3, IPSR
34023644:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34023646:	697a      	ldr	r2, [r7, #20]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34023648:	4b1b      	ldr	r3, [pc, #108]	@ (340236b8 <_txe_mutex_get+0xa8>)
3402364a:	681b      	ldr	r3, [r3, #0]
3402364c:	4313      	orrs	r3, r2
3402364e:	2b00      	cmp	r3, #0
34023650:	d002      	beq.n	34023658 <_txe_mutex_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
34023652:	2304      	movs	r3, #4
34023654:	61fb      	str	r3, [r7, #28]
34023656:	e008      	b.n	3402366a <_txe_mutex_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
34023658:	4b18      	ldr	r3, [pc, #96]	@ (340236bc <_txe_mutex_get+0xac>)
3402365a:	681b      	ldr	r3, [r3, #0]
3402365c:	61bb      	str	r3, [r7, #24]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
3402365e:	69bb      	ldr	r3, [r7, #24]
34023660:	4a17      	ldr	r2, [pc, #92]	@ (340236c0 <_txe_mutex_get+0xb0>)
34023662:	4293      	cmp	r3, r2
34023664:	d101      	bne.n	3402366a <_txe_mutex_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
34023666:	2304      	movs	r3, #4
34023668:	61fb      	str	r3, [r7, #28]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3402366a:	69fb      	ldr	r3, [r7, #28]
3402366c:	2b00      	cmp	r3, #0
3402366e:	d114      	bne.n	3402369a <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023670:	f3ef 8305 	mrs	r3, IPSR
34023674:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34023676:	693a      	ldr	r2, [r7, #16]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34023678:	4b0f      	ldr	r3, [pc, #60]	@ (340236b8 <_txe_mutex_get+0xa8>)
3402367a:	681b      	ldr	r3, [r3, #0]
3402367c:	4313      	orrs	r3, r2
3402367e:	2b00      	cmp	r3, #0
34023680:	d00b      	beq.n	3402369a <_txe_mutex_get+0x8a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023682:	f3ef 8305 	mrs	r3, IPSR
34023686:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34023688:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
3402368a:	4b0b      	ldr	r3, [pc, #44]	@ (340236b8 <_txe_mutex_get+0xa8>)
3402368c:	681b      	ldr	r3, [r3, #0]
3402368e:	4313      	orrs	r3, r2
34023690:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34023694:	d201      	bcs.n	3402369a <_txe_mutex_get+0x8a>
            {

                /* Yes, invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34023696:	2313      	movs	r3, #19
34023698:	61fb      	str	r3, [r7, #28]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3402369a:	69fb      	ldr	r3, [r7, #28]
3402369c:	2b00      	cmp	r3, #0
3402369e:	d104      	bne.n	340236aa <_txe_mutex_get+0x9a>
    {

        /* Call actual get mutex function.  */
        status =  _tx_mutex_get(mutex_ptr, wait_option);
340236a0:	6839      	ldr	r1, [r7, #0]
340236a2:	6878      	ldr	r0, [r7, #4]
340236a4:	f7fd ff76 	bl	34021594 <_tx_mutex_get>
340236a8:	61f8      	str	r0, [r7, #28]
    }

    /* Return completion status.  */
    return(status);
340236aa:	69fb      	ldr	r3, [r7, #28]
}
340236ac:	4618      	mov	r0, r3
340236ae:	3720      	adds	r7, #32
340236b0:	46bd      	mov	sp, r7
340236b2:	bd80      	pop	{r7, pc}
340236b4:	4d555445 	.word	0x4d555445
340236b8:	3404148c 	.word	0x3404148c
340236bc:	3404aaf0 	.word	0x3404aaf0
340236c0:	3404ac40 	.word	0x3404ac40

340236c4 <_txe_mutex_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_mutex_put(TX_MUTEX *mutex_ptr)
{
340236c4:	b580      	push	{r7, lr}
340236c6:	b086      	sub	sp, #24
340236c8:	af00      	add	r7, sp, #0
340236ca:	6078      	str	r0, [r7, #4]

UINT            status;


    /* Default status to success.  */
    status =  TX_SUCCESS;
340236cc:	2300      	movs	r3, #0
340236ce:	617b      	str	r3, [r7, #20]

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
340236d0:	687b      	ldr	r3, [r7, #4]
340236d2:	2b00      	cmp	r3, #0
340236d4:	d102      	bne.n	340236dc <_txe_mutex_put+0x18>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
340236d6:	231c      	movs	r3, #28
340236d8:	617b      	str	r3, [r7, #20]
340236da:	e01c      	b.n	34023716 <_txe_mutex_put+0x52>
    }

    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
340236dc:	687b      	ldr	r3, [r7, #4]
340236de:	681b      	ldr	r3, [r3, #0]
340236e0:	4a13      	ldr	r2, [pc, #76]	@ (34023730 <_txe_mutex_put+0x6c>)
340236e2:	4293      	cmp	r3, r2
340236e4:	d002      	beq.n	340236ec <_txe_mutex_put+0x28>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
340236e6:	231c      	movs	r3, #28
340236e8:	617b      	str	r3, [r7, #20]
340236ea:	e014      	b.n	34023716 <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
340236ec:	f3ef 8305 	mrs	r3, IPSR
340236f0:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
340236f2:	693a      	ldr	r2, [r7, #16]
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
340236f4:	4b0f      	ldr	r3, [pc, #60]	@ (34023734 <_txe_mutex_put+0x70>)
340236f6:	681b      	ldr	r3, [r3, #0]
340236f8:	4313      	orrs	r3, r2
340236fa:	2b00      	cmp	r3, #0
340236fc:	d00b      	beq.n	34023716 <_txe_mutex_put+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
340236fe:	f3ef 8305 	mrs	r3, IPSR
34023702:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34023704:	68fa      	ldr	r2, [r7, #12]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34023706:	4b0b      	ldr	r3, [pc, #44]	@ (34023734 <_txe_mutex_put+0x70>)
34023708:	681b      	ldr	r3, [r3, #0]
3402370a:	4313      	orrs	r3, r2
3402370c:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34023710:	d201      	bcs.n	34023716 <_txe_mutex_put+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34023712:	2313      	movs	r3, #19
34023714:	617b      	str	r3, [r7, #20]
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34023716:	697b      	ldr	r3, [r7, #20]
34023718:	2b00      	cmp	r3, #0
3402371a:	d103      	bne.n	34023724 <_txe_mutex_put+0x60>
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
3402371c:	6878      	ldr	r0, [r7, #4]
3402371e:	f7fe f9bf 	bl	34021aa0 <_tx_mutex_put>
34023722:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
34023724:	697b      	ldr	r3, [r7, #20]
}
34023726:	4618      	mov	r0, r3
34023728:	3718      	adds	r7, #24
3402372a:	46bd      	mov	sp, r7
3402372c:	bd80      	pop	{r7, pc}
3402372e:	bf00      	nop
34023730:	4d555445 	.word	0x4d555445
34023734:	3404148c 	.word	0x3404148c

34023738 <_txe_semaphore_ceiling_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_ceiling_put(TX_SEMAPHORE *semaphore_ptr, ULONG ceiling)
{
34023738:	b580      	push	{r7, lr}
3402373a:	b084      	sub	sp, #16
3402373c:	af00      	add	r7, sp, #0
3402373e:	6078      	str	r0, [r7, #4]
34023740:	6039      	str	r1, [r7, #0]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
34023742:	687b      	ldr	r3, [r7, #4]
34023744:	2b00      	cmp	r3, #0
34023746:	d102      	bne.n	3402374e <_txe_semaphore_ceiling_put+0x16>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34023748:	230c      	movs	r3, #12
3402374a:	60fb      	str	r3, [r7, #12]
3402374c:	e012      	b.n	34023774 <_txe_semaphore_ceiling_put+0x3c>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
3402374e:	687b      	ldr	r3, [r7, #4]
34023750:	681b      	ldr	r3, [r3, #0]
34023752:	4a0b      	ldr	r2, [pc, #44]	@ (34023780 <_txe_semaphore_ceiling_put+0x48>)
34023754:	4293      	cmp	r3, r2
34023756:	d002      	beq.n	3402375e <_txe_semaphore_ceiling_put+0x26>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34023758:	230c      	movs	r3, #12
3402375a:	60fb      	str	r3, [r7, #12]
3402375c:	e00a      	b.n	34023774 <_txe_semaphore_ceiling_put+0x3c>
    }

    /* Determine if the ceiling is valid - must be greater than 1.  */
    else if (ceiling == ((ULONG) 0))
3402375e:	683b      	ldr	r3, [r7, #0]
34023760:	2b00      	cmp	r3, #0
34023762:	d102      	bne.n	3402376a <_txe_semaphore_ceiling_put+0x32>
    {

        /* Invalid ceiling, return error.  */
        status =  TX_INVALID_CEILING;
34023764:	2322      	movs	r3, #34	@ 0x22
34023766:	60fb      	str	r3, [r7, #12]
34023768:	e004      	b.n	34023774 <_txe_semaphore_ceiling_put+0x3c>
    }
    else
    {

        /* Call actual semaphore ceiling put function.  */
        status =  _tx_semaphore_ceiling_put(semaphore_ptr, ceiling);
3402376a:	6839      	ldr	r1, [r7, #0]
3402376c:	6878      	ldr	r0, [r7, #4]
3402376e:	f7fe fbbd 	bl	34021eec <_tx_semaphore_ceiling_put>
34023772:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
34023774:	68fb      	ldr	r3, [r7, #12]
}
34023776:	4618      	mov	r0, r3
34023778:	3710      	adds	r7, #16
3402377a:	46bd      	mov	sp, r7
3402377c:	bd80      	pop	{r7, pc}
3402377e:	bf00      	nop
34023780:	53454d41 	.word	0x53454d41

34023784 <_txe_semaphore_create>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count, UINT semaphore_control_block_size)
{
34023784:	b580      	push	{r7, lr}
34023786:	b092      	sub	sp, #72	@ 0x48
34023788:	af00      	add	r7, sp, #0
3402378a:	60f8      	str	r0, [r7, #12]
3402378c:	60b9      	str	r1, [r7, #8]
3402378e:	607a      	str	r2, [r7, #4]
34023790:	603b      	str	r3, [r7, #0]
TX_THREAD           *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34023792:	2300      	movs	r3, #0
34023794:	647b      	str	r3, [r7, #68]	@ 0x44

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
34023796:	68fb      	ldr	r3, [r7, #12]
34023798:	2b00      	cmp	r3, #0
3402379a:	d102      	bne.n	340237a2 <_txe_semaphore_create+0x1e>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
3402379c:	230c      	movs	r3, #12
3402379e:	647b      	str	r3, [r7, #68]	@ 0x44
340237a0:	e054      	b.n	3402384c <_txe_semaphore_create+0xc8>
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
340237a2:	683b      	ldr	r3, [r7, #0]
340237a4:	2b20      	cmp	r3, #32
340237a6:	d002      	beq.n	340237ae <_txe_semaphore_create+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
340237a8:	230c      	movs	r3, #12
340237aa:	647b      	str	r3, [r7, #68]	@ 0x44
340237ac:	e04e      	b.n	3402384c <_txe_semaphore_create+0xc8>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
340237ae:	f3ef 8310 	mrs	r3, PRIMASK
340237b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
    return(posture);
340237b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    int_posture = __get_interrupt_posture();
340237b6:	62bb      	str	r3, [r7, #40]	@ 0x28
    __asm__ volatile ("CPSID i" : : : "memory");
340237b8:	b672      	cpsid	i
    return(int_posture);
340237ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
340237bc:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
340237be:	4b36      	ldr	r3, [pc, #216]	@ (34023898 <_txe_semaphore_create+0x114>)
340237c0:	681b      	ldr	r3, [r3, #0]
340237c2:	3301      	adds	r3, #1
340237c4:	4a34      	ldr	r2, [pc, #208]	@ (34023898 <_txe_semaphore_create+0x114>)
340237c6:	6013      	str	r3, [r2, #0]
340237c8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
340237ca:	633b      	str	r3, [r7, #48]	@ 0x30
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
340237cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
340237ce:	f383 8810 	msr	PRIMASK, r3
}
340237d2:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        next_semaphore =  _tx_semaphore_created_ptr;
340237d4:	4b31      	ldr	r3, [pc, #196]	@ (3402389c <_txe_semaphore_create+0x118>)
340237d6:	681b      	ldr	r3, [r3, #0]
340237d8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
340237da:	2300      	movs	r3, #0
340237dc:	643b      	str	r3, [r7, #64]	@ 0x40
340237de:	e009      	b.n	340237f4 <_txe_semaphore_create+0x70>
        {

            /* Determine if this semaphore matches the current semaphore in the list.  */
            if (semaphore_ptr == next_semaphore)
340237e0:	68fa      	ldr	r2, [r7, #12]
340237e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340237e4:	429a      	cmp	r2, r3
340237e6:	d00b      	beq.n	34023800 <_txe_semaphore_create+0x7c>
            }
            else
            {

                /* Move to next semaphore.  */
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
340237e8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
340237ea:	695b      	ldr	r3, [r3, #20]
340237ec:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
340237ee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
340237f0:	3301      	adds	r3, #1
340237f2:	643b      	str	r3, [r7, #64]	@ 0x40
340237f4:	4b2a      	ldr	r3, [pc, #168]	@ (340238a0 <_txe_semaphore_create+0x11c>)
340237f6:	681b      	ldr	r3, [r3, #0]
340237f8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
340237fa:	429a      	cmp	r2, r3
340237fc:	d3f0      	bcc.n	340237e0 <_txe_semaphore_create+0x5c>
340237fe:	e000      	b.n	34023802 <_txe_semaphore_create+0x7e>
                break;
34023800:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34023802:	f3ef 8310 	mrs	r3, PRIMASK
34023806:	623b      	str	r3, [r7, #32]
    return(posture);
34023808:	6a3b      	ldr	r3, [r7, #32]
    int_posture = __get_interrupt_posture();
3402380a:	61fb      	str	r3, [r7, #28]
    __asm__ volatile ("CPSID i" : : : "memory");
3402380c:	b672      	cpsid	i
    return(int_posture);
3402380e:	69fb      	ldr	r3, [r7, #28]
            }
        }

        /* Disable interrupts.  */
        TX_DISABLE
34023810:	63bb      	str	r3, [r7, #56]	@ 0x38

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34023812:	4b21      	ldr	r3, [pc, #132]	@ (34023898 <_txe_semaphore_create+0x114>)
34023814:	681b      	ldr	r3, [r3, #0]
34023816:	3b01      	subs	r3, #1
34023818:	4a1f      	ldr	r2, [pc, #124]	@ (34023898 <_txe_semaphore_create+0x114>)
3402381a:	6013      	str	r3, [r2, #0]
3402381c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
3402381e:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023820:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34023822:	f383 8810 	msr	PRIMASK, r3
}
34023826:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34023828:	f7ff f856 	bl	340228d8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate semaphore.  */
        if (semaphore_ptr == next_semaphore)
3402382c:	68fa      	ldr	r2, [r7, #12]
3402382e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34023830:	429a      	cmp	r2, r3
34023832:	d102      	bne.n	3402383a <_txe_semaphore_create+0xb6>
        {

            /* Semaphore is already created, return appropriate error code.  */
            status =  TX_SEMAPHORE_ERROR;
34023834:	230c      	movs	r3, #12
34023836:	647b      	str	r3, [r7, #68]	@ 0x44
34023838:	e008      	b.n	3402384c <_txe_semaphore_create+0xc8>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
3402383a:	4b1a      	ldr	r3, [pc, #104]	@ (340238a4 <_txe_semaphore_create+0x120>)
3402383c:	681b      	ldr	r3, [r3, #0]
3402383e:	637b      	str	r3, [r7, #52]	@ 0x34

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (thread_ptr == &_tx_timer_thread)
34023840:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34023842:	4a19      	ldr	r2, [pc, #100]	@ (340238a8 <_txe_semaphore_create+0x124>)
34023844:	4293      	cmp	r3, r2
34023846:	d101      	bne.n	3402384c <_txe_semaphore_create+0xc8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34023848:	2313      	movs	r3, #19
3402384a:	647b      	str	r3, [r7, #68]	@ 0x44
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3402384c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402384e:	2b00      	cmp	r3, #0
34023850:	d114      	bne.n	3402387c <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023852:	f3ef 8305 	mrs	r3, IPSR
34023856:	61bb      	str	r3, [r7, #24]
    return(ipsr_value);
34023858:	69ba      	ldr	r2, [r7, #24]
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
3402385a:	4b14      	ldr	r3, [pc, #80]	@ (340238ac <_txe_semaphore_create+0x128>)
3402385c:	681b      	ldr	r3, [r3, #0]
3402385e:	4313      	orrs	r3, r2
34023860:	2b00      	cmp	r3, #0
34023862:	d00b      	beq.n	3402387c <_txe_semaphore_create+0xf8>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023864:	f3ef 8305 	mrs	r3, IPSR
34023868:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
3402386a:	697a      	ldr	r2, [r7, #20]
        {

            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
3402386c:	4b0f      	ldr	r3, [pc, #60]	@ (340238ac <_txe_semaphore_create+0x128>)
3402386e:	681b      	ldr	r3, [r3, #0]
34023870:	4313      	orrs	r3, r2
34023872:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34023876:	d201      	bcs.n	3402387c <_txe_semaphore_create+0xf8>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34023878:	2313      	movs	r3, #19
3402387a:	647b      	str	r3, [r7, #68]	@ 0x44
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
3402387c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3402387e:	2b00      	cmp	r3, #0
34023880:	d105      	bne.n	3402388e <_txe_semaphore_create+0x10a>
    {

        /* Call actual semaphore create function.  */
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
34023882:	687a      	ldr	r2, [r7, #4]
34023884:	68b9      	ldr	r1, [r7, #8]
34023886:	68f8      	ldr	r0, [r7, #12]
34023888:	f7fe fc2a 	bl	340220e0 <_tx_semaphore_create>
3402388c:	6478      	str	r0, [r7, #68]	@ 0x44
    }

    /* Return completion status.  */
    return(status);
3402388e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
34023890:	4618      	mov	r0, r3
34023892:	3748      	adds	r7, #72	@ 0x48
34023894:	46bd      	mov	sp, r7
34023896:	bd80      	pop	{r7, pc}
34023898:	3404ab8c 	.word	0x3404ab8c
3402389c:	3404aab8 	.word	0x3404aab8
340238a0:	3404aabc 	.word	0x3404aabc
340238a4:	3404aaf0 	.word	0x3404aaf0
340238a8:	3404ac40 	.word	0x3404ac40
340238ac:	3404148c 	.word	0x3404148c

340238b0 <_txe_semaphore_delete>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
340238b0:	b580      	push	{r7, lr}
340238b2:	b086      	sub	sp, #24
340238b4:	af00      	add	r7, sp, #0
340238b6:	6078      	str	r0, [r7, #4]
TX_THREAD       *thread_ptr;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
340238b8:	2300      	movs	r3, #0
340238ba:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
340238bc:	687b      	ldr	r3, [r7, #4]
340238be:	2b00      	cmp	r3, #0
340238c0:	d102      	bne.n	340238c8 <_txe_semaphore_delete+0x18>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
340238c2:	230c      	movs	r3, #12
340238c4:	617b      	str	r3, [r7, #20]
340238c6:	e01c      	b.n	34023902 <_txe_semaphore_delete+0x52>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
340238c8:	687b      	ldr	r3, [r7, #4]
340238ca:	681b      	ldr	r3, [r3, #0]
340238cc:	4a13      	ldr	r2, [pc, #76]	@ (3402391c <_txe_semaphore_delete+0x6c>)
340238ce:	4293      	cmp	r3, r2
340238d0:	d002      	beq.n	340238d8 <_txe_semaphore_delete+0x28>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
340238d2:	230c      	movs	r3, #12
340238d4:	617b      	str	r3, [r7, #20]
340238d6:	e014      	b.n	34023902 <_txe_semaphore_delete+0x52>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
340238d8:	f3ef 8305 	mrs	r3, IPSR
340238dc:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
340238de:	68fa      	ldr	r2, [r7, #12]
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
340238e0:	4b0f      	ldr	r3, [pc, #60]	@ (34023920 <_txe_semaphore_delete+0x70>)
340238e2:	681b      	ldr	r3, [r3, #0]
340238e4:	4313      	orrs	r3, r2
340238e6:	2b00      	cmp	r3, #0
340238e8:	d002      	beq.n	340238f0 <_txe_semaphore_delete+0x40>
        {

            /* Invalid caller of this function, return appropriate error code.  */
            status =  TX_CALLER_ERROR;
340238ea:	2313      	movs	r3, #19
340238ec:	617b      	str	r3, [r7, #20]
340238ee:	e008      	b.n	34023902 <_txe_semaphore_delete+0x52>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
340238f0:	4b0c      	ldr	r3, [pc, #48]	@ (34023924 <_txe_semaphore_delete+0x74>)
340238f2:	681b      	ldr	r3, [r3, #0]
340238f4:	613b      	str	r3, [r7, #16]

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
340238f6:	693b      	ldr	r3, [r7, #16]
340238f8:	4a0b      	ldr	r2, [pc, #44]	@ (34023928 <_txe_semaphore_delete+0x78>)
340238fa:	4293      	cmp	r3, r2
340238fc:	d101      	bne.n	34023902 <_txe_semaphore_delete+0x52>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
340238fe:	2313      	movs	r3, #19
34023900:	617b      	str	r3, [r7, #20]
        }
#endif
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34023902:	697b      	ldr	r3, [r7, #20]
34023904:	2b00      	cmp	r3, #0
34023906:	d103      	bne.n	34023910 <_txe_semaphore_delete+0x60>
    {

        /* Call actual semaphore delete function.  */
        status =  _tx_semaphore_delete(semaphore_ptr);
34023908:	6878      	ldr	r0, [r7, #4]
3402390a:	f7fe fc3b 	bl	34022184 <_tx_semaphore_delete>
3402390e:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
34023910:	697b      	ldr	r3, [r7, #20]
}
34023912:	4618      	mov	r0, r3
34023914:	3718      	adds	r7, #24
34023916:	46bd      	mov	sp, r7
34023918:	bd80      	pop	{r7, pc}
3402391a:	bf00      	nop
3402391c:	53454d41 	.word	0x53454d41
34023920:	3404148c 	.word	0x3404148c
34023924:	3404aaf0 	.word	0x3404aaf0
34023928:	3404ac40 	.word	0x3404ac40

3402392c <_txe_semaphore_get>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
3402392c:	b580      	push	{r7, lr}
3402392e:	b086      	sub	sp, #24
34023930:	af00      	add	r7, sp, #0
34023932:	6078      	str	r0, [r7, #4]
34023934:	6039      	str	r1, [r7, #0]
TX_THREAD   *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
34023936:	2300      	movs	r3, #0
34023938:	617b      	str	r3, [r7, #20]

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
3402393a:	687b      	ldr	r3, [r7, #4]
3402393c:	2b00      	cmp	r3, #0
3402393e:	d102      	bne.n	34023946 <_txe_semaphore_get+0x1a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34023940:	230c      	movs	r3, #12
34023942:	617b      	str	r3, [r7, #20]
34023944:	e01f      	b.n	34023986 <_txe_semaphore_get+0x5a>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
34023946:	687b      	ldr	r3, [r7, #4]
34023948:	681b      	ldr	r3, [r3, #0]
3402394a:	4a15      	ldr	r2, [pc, #84]	@ (340239a0 <_txe_semaphore_get+0x74>)
3402394c:	4293      	cmp	r3, r2
3402394e:	d002      	beq.n	34023956 <_txe_semaphore_get+0x2a>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
34023950:	230c      	movs	r3, #12
34023952:	617b      	str	r3, [r7, #20]
34023954:	e017      	b.n	34023986 <_txe_semaphore_get+0x5a>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of
           suspension.  */
        if (wait_option != TX_NO_WAIT)
34023956:	683b      	ldr	r3, [r7, #0]
34023958:	2b00      	cmp	r3, #0
3402395a:	d014      	beq.n	34023986 <_txe_semaphore_get+0x5a>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
3402395c:	f3ef 8305 	mrs	r3, IPSR
34023960:	60fb      	str	r3, [r7, #12]
    return(ipsr_value);
34023962:	68fa      	ldr	r2, [r7, #12]
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34023964:	4b0f      	ldr	r3, [pc, #60]	@ (340239a4 <_txe_semaphore_get+0x78>)
34023966:	681b      	ldr	r3, [r3, #0]
34023968:	4313      	orrs	r3, r2
3402396a:	2b00      	cmp	r3, #0
3402396c:	d002      	beq.n	34023974 <_txe_semaphore_get+0x48>
            {

                /* A non-thread is trying to suspend, return appropriate error code.  */
                status =  TX_WAIT_ERROR;
3402396e:	2304      	movs	r3, #4
34023970:	617b      	str	r3, [r7, #20]
34023972:	e008      	b.n	34023986 <_txe_semaphore_get+0x5a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {

                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
34023974:	4b0c      	ldr	r3, [pc, #48]	@ (340239a8 <_txe_semaphore_get+0x7c>)
34023976:	681b      	ldr	r3, [r3, #0]
34023978:	613b      	str	r3, [r7, #16]

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
3402397a:	693b      	ldr	r3, [r7, #16]
3402397c:	4a0b      	ldr	r2, [pc, #44]	@ (340239ac <_txe_semaphore_get+0x80>)
3402397e:	4293      	cmp	r3, r2
34023980:	d101      	bne.n	34023986 <_txe_semaphore_get+0x5a>
                {

                    /* A non-thread is trying to suspend, return appropriate error code.  */
                    status =  TX_WAIT_ERROR;
34023982:	2304      	movs	r3, #4
34023984:	617b      	str	r3, [r7, #20]
#endif
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34023986:	697b      	ldr	r3, [r7, #20]
34023988:	2b00      	cmp	r3, #0
3402398a:	d104      	bne.n	34023996 <_txe_semaphore_get+0x6a>
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
3402398c:	6839      	ldr	r1, [r7, #0]
3402398e:	6878      	ldr	r0, [r7, #4]
34023990:	f7fe fc88 	bl	340222a4 <_tx_semaphore_get>
34023994:	6178      	str	r0, [r7, #20]
    }

    /* Return completion status.  */
    return(status);
34023996:	697b      	ldr	r3, [r7, #20]
}
34023998:	4618      	mov	r0, r3
3402399a:	3718      	adds	r7, #24
3402399c:	46bd      	mov	sp, r7
3402399e:	bd80      	pop	{r7, pc}
340239a0:	53454d41 	.word	0x53454d41
340239a4:	3404148c 	.word	0x3404148c
340239a8:	3404aaf0 	.word	0x3404aaf0
340239ac:	3404ac40 	.word	0x3404ac40

340239b0 <_txe_semaphore_put>:
/*  09-30-2020     Yuxin Zhou               Modified comment(s),          */
/*                                            resulting in version 6.1    */
/*                                                                        */
/**************************************************************************/
UINT  _txe_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
340239b0:	b580      	push	{r7, lr}
340239b2:	b084      	sub	sp, #16
340239b4:	af00      	add	r7, sp, #0
340239b6:	6078      	str	r0, [r7, #4]

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
340239b8:	687b      	ldr	r3, [r7, #4]
340239ba:	2b00      	cmp	r3, #0
340239bc:	d102      	bne.n	340239c4 <_txe_semaphore_put+0x14>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
340239be:	230c      	movs	r3, #12
340239c0:	60fb      	str	r3, [r7, #12]
340239c2:	e00b      	b.n	340239dc <_txe_semaphore_put+0x2c>
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
340239c4:	687b      	ldr	r3, [r7, #4]
340239c6:	681b      	ldr	r3, [r3, #0]
340239c8:	4a07      	ldr	r2, [pc, #28]	@ (340239e8 <_txe_semaphore_put+0x38>)
340239ca:	4293      	cmp	r3, r2
340239cc:	d002      	beq.n	340239d4 <_txe_semaphore_put+0x24>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
340239ce:	230c      	movs	r3, #12
340239d0:	60fb      	str	r3, [r7, #12]
340239d2:	e003      	b.n	340239dc <_txe_semaphore_put+0x2c>
    }
    else
    {

        /* Call actual put semaphore function.  */
        status =  _tx_semaphore_put(semaphore_ptr);
340239d4:	6878      	ldr	r0, [r7, #4]
340239d6:	f7fe fcf7 	bl	340223c8 <_tx_semaphore_put>
340239da:	60f8      	str	r0, [r7, #12]
    }

    /* Return completion status.  */
    return(status);
340239dc:	68fb      	ldr	r3, [r7, #12]
}
340239de:	4618      	mov	r0, r3
340239e0:	3710      	adds	r7, #16
340239e2:	46bd      	mov	sp, r7
340239e4:	bd80      	pop	{r7, pc}
340239e6:	bf00      	nop
340239e8:	53454d41 	.word	0x53454d41

340239ec <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr,
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size,
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
340239ec:	b580      	push	{r7, lr}
340239ee:	b09a      	sub	sp, #104	@ 0x68
340239f0:	af06      	add	r7, sp, #24
340239f2:	60f8      	str	r0, [r7, #12]
340239f4:	60b9      	str	r1, [r7, #8]
340239f6:	607a      	str	r2, [r7, #4]
340239f8:	603b      	str	r3, [r7, #0]
TX_THREAD       *current_thread;
#endif


    /* Default status to success.  */
    status =  TX_SUCCESS;
340239fa:	2300      	movs	r3, #0
340239fc:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
340239fe:	68fb      	ldr	r3, [r7, #12]
34023a00:	2b00      	cmp	r3, #0
34023a02:	d102      	bne.n	34023a0a <_txe_thread_create+0x1e>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34023a04:	230e      	movs	r3, #14
34023a06:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023a08:	e0bb      	b.n	34023b82 <_txe_thread_create+0x196>
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
34023a0a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34023a0c:	2bc0      	cmp	r3, #192	@ 0xc0
34023a0e:	d002      	beq.n	34023a16 <_txe_thread_create+0x2a>
    {

        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
34023a10:	230e      	movs	r3, #14
34023a12:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023a14:	e0b5      	b.n	34023b82 <_txe_thread_create+0x196>
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34023a16:	f3ef 8310 	mrs	r3, PRIMASK
34023a1a:	62bb      	str	r3, [r7, #40]	@ 0x28
    return(posture);
34023a1c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    int_posture = __get_interrupt_posture();
34023a1e:	627b      	str	r3, [r7, #36]	@ 0x24
    __asm__ volatile ("CPSID i" : : : "memory");
34023a20:	b672      	cpsid	i
    return(int_posture);
34023a22:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    }
    else
    {

        /* Disable interrupts.  */
        TX_DISABLE
34023a24:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
34023a26:	4b64      	ldr	r3, [pc, #400]	@ (34023bb8 <_txe_thread_create+0x1cc>)
34023a28:	681b      	ldr	r3, [r3, #0]
34023a2a:	3301      	adds	r3, #1
34023a2c:	4a62      	ldr	r2, [pc, #392]	@ (34023bb8 <_txe_thread_create+0x1cc>)
34023a2e:	6013      	str	r3, [r2, #0]
34023a30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34023a32:	62fb      	str	r3, [r7, #44]	@ 0x2c
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023a34:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023a36:	f383 8810 	msr	PRIMASK, r3
}
34023a3a:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        break_flag =   TX_FALSE;
34023a3c:	2300      	movs	r3, #0
34023a3e:	64bb      	str	r3, [r7, #72]	@ 0x48
        next_thread =  _tx_thread_created_ptr;
34023a40:	4b5e      	ldr	r3, [pc, #376]	@ (34023bbc <_txe_thread_create+0x1d0>)
34023a42:	681b      	ldr	r3, [r3, #0]
34023a44:	643b      	str	r3, [r7, #64]	@ 0x40
        work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
34023a46:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34023a48:	63bb      	str	r3, [r7, #56]	@ 0x38
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
34023a4a:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34023a4c:	3b01      	subs	r3, #1
34023a4e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34023a50:	4413      	add	r3, r2
34023a52:	63bb      	str	r3, [r7, #56]	@ 0x38
        stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
34023a54:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34023a56:	637b      	str	r3, [r7, #52]	@ 0x34
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
34023a58:	2300      	movs	r3, #0
34023a5a:	647b      	str	r3, [r7, #68]	@ 0x44
34023a5c:	e02b      	b.n	34023ab6 <_txe_thread_create+0xca>
        {

            /* Determine if this thread matches the thread in the list.  */
            if (thread_ptr == next_thread)
34023a5e:	68fa      	ldr	r2, [r7, #12]
34023a60:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023a62:	429a      	cmp	r2, r3
34023a64:	d101      	bne.n	34023a6a <_txe_thread_create+0x7e>
            {

                /* Set the break flag.  */
                break_flag =  TX_TRUE;
34023a66:	2301      	movs	r3, #1
34023a68:	64bb      	str	r3, [r7, #72]	@ 0x48
            }

            /* Determine if we need to break the loop.  */
            if (break_flag == TX_TRUE)
34023a6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
34023a6c:	2b01      	cmp	r3, #1
34023a6e:	d028      	beq.n	34023ac2 <_txe_thread_create+0xd6>
                /* Yes, break out of the loop.  */
                break;
            }

            /* Check the stack pointer to see if it overlaps with this thread's stack.  */
            if (stack_start >= next_thread -> tx_thread_stack_start)
34023a70:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023a72:	68db      	ldr	r3, [r3, #12]
34023a74:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34023a76:	429a      	cmp	r2, r3
34023a78:	d308      	bcc.n	34023a8c <_txe_thread_create+0xa0>
            {

                if (stack_start < next_thread -> tx_thread_stack_end)
34023a7a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023a7c:	691b      	ldr	r3, [r3, #16]
34023a7e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
34023a80:	429a      	cmp	r2, r3
34023a82:	d203      	bcs.n	34023a8c <_txe_thread_create+0xa0>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
34023a84:	2300      	movs	r3, #0
34023a86:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
34023a88:	2301      	movs	r3, #1
34023a8a:	64bb      	str	r3, [r7, #72]	@ 0x48
                }
            }

            /* Check the end of the stack to see if it is inside this thread's stack area as well.  */
            if (stack_end >= next_thread -> tx_thread_stack_start)
34023a8c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023a8e:	68db      	ldr	r3, [r3, #12]
34023a90:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023a92:	429a      	cmp	r2, r3
34023a94:	d308      	bcc.n	34023aa8 <_txe_thread_create+0xbc>
            {

                if (stack_end < next_thread -> tx_thread_stack_end)
34023a96:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023a98:	691b      	ldr	r3, [r3, #16]
34023a9a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023a9c:	429a      	cmp	r2, r3
34023a9e:	d203      	bcs.n	34023aa8 <_txe_thread_create+0xbc>
                {

                    /* This stack overlaps with an existing thread, clear the stack pointer to
                       force a stack error below.  */
                    stack_start =  TX_NULL;
34023aa0:	2300      	movs	r3, #0
34023aa2:	65bb      	str	r3, [r7, #88]	@ 0x58

                    /* Set the break flag.  */
                    break_flag =  TX_TRUE;
34023aa4:	2301      	movs	r3, #1
34023aa6:	64bb      	str	r3, [r7, #72]	@ 0x48
                }
            }

            /* Move to the next thread.  */
            next_thread =  next_thread -> tx_thread_created_next;
34023aa8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023aaa:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34023aae:	643b      	str	r3, [r7, #64]	@ 0x40
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
34023ab0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
34023ab2:	3301      	adds	r3, #1
34023ab4:	647b      	str	r3, [r7, #68]	@ 0x44
34023ab6:	4b42      	ldr	r3, [pc, #264]	@ (34023bc0 <_txe_thread_create+0x1d4>)
34023ab8:	681b      	ldr	r3, [r3, #0]
34023aba:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
34023abc:	429a      	cmp	r2, r3
34023abe:	d3ce      	bcc.n	34023a5e <_txe_thread_create+0x72>
34023ac0:	e000      	b.n	34023ac4 <_txe_thread_create+0xd8>
                break;
34023ac2:	bf00      	nop
    __asm__ volatile ("MRS  %0, PRIMASK ": "=r" (posture));
34023ac4:	f3ef 8310 	mrs	r3, PRIMASK
34023ac8:	61fb      	str	r3, [r7, #28]
    return(posture);
34023aca:	69fb      	ldr	r3, [r7, #28]
    int_posture = __get_interrupt_posture();
34023acc:	61bb      	str	r3, [r7, #24]
    __asm__ volatile ("CPSID i" : : : "memory");
34023ace:	b672      	cpsid	i
    return(int_posture);
34023ad0:	69bb      	ldr	r3, [r7, #24]
        }

        /* Disable interrupts.  */
        TX_DISABLE
34023ad2:	63fb      	str	r3, [r7, #60]	@ 0x3c

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
34023ad4:	4b38      	ldr	r3, [pc, #224]	@ (34023bb8 <_txe_thread_create+0x1cc>)
34023ad6:	681b      	ldr	r3, [r3, #0]
34023ad8:	3b01      	subs	r3, #1
34023ada:	4a37      	ldr	r2, [pc, #220]	@ (34023bb8 <_txe_thread_create+0x1cc>)
34023adc:	6013      	str	r3, [r2, #0]
34023ade:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
34023ae0:	623b      	str	r3, [r7, #32]
    __asm__ volatile ("MSR  PRIMASK,%0": : "r" (int_posture): "memory");
34023ae2:	6a3b      	ldr	r3, [r7, #32]
34023ae4:	f383 8810 	msr	PRIMASK, r3
}
34023ae8:	bf00      	nop

        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
34023aea:	f7fe fef5 	bl	340228d8 <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate thread.  */
        if (thread_ptr == next_thread)
34023aee:	68fa      	ldr	r2, [r7, #12]
34023af0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
34023af2:	429a      	cmp	r2, r3
34023af4:	d102      	bne.n	34023afc <_txe_thread_create+0x110>
        {

            /* Thread is already created, return appropriate error code.  */
            status =  TX_THREAD_ERROR;
34023af6:	230e      	movs	r3, #14
34023af8:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023afa:	e042      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check for invalid starting address of stack.  */
        else if (stack_start == TX_NULL)
34023afc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34023afe:	2b00      	cmp	r3, #0
34023b00:	d102      	bne.n	34023b08 <_txe_thread_create+0x11c>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
34023b02:	2303      	movs	r3, #3
34023b04:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b06:	e03c      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check for invalid thread entry point.  */
        else if (entry_function == TX_NULL)
34023b08:	687b      	ldr	r3, [r7, #4]
34023b0a:	2b00      	cmp	r3, #0
34023b0c:	d102      	bne.n	34023b14 <_txe_thread_create+0x128>
        {

            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
34023b0e:	2303      	movs	r3, #3
34023b10:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b12:	e036      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check the stack size.  */
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
34023b14:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34023b16:	2bc7      	cmp	r3, #199	@ 0xc7
34023b18:	d802      	bhi.n	34023b20 <_txe_thread_create+0x134>
        {

            /* Stack is not big enough, return appropriate error code.  */
            status =  TX_SIZE_ERROR;
34023b1a:	2305      	movs	r3, #5
34023b1c:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b1e:	e030      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check the priority specified.  */
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
34023b20:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34023b22:	2b1f      	cmp	r3, #31
34023b24:	d902      	bls.n	34023b2c <_txe_thread_create+0x140>
        {

            /* Invalid priority selected, return appropriate error code.  */
            status =  TX_PRIORITY_ERROR;
34023b26:	230f      	movs	r3, #15
34023b28:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b2a:	e02a      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check preemption threshold. */
        else if (preempt_threshold > priority)
34023b2c:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
34023b2e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34023b30:	429a      	cmp	r2, r3
34023b32:	d902      	bls.n	34023b3a <_txe_thread_create+0x14e>
        {

            /* Invalid preempt threshold, return appropriate error code.  */
            status =  TX_THRESH_ERROR;
34023b34:	2318      	movs	r3, #24
34023b36:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b38:	e023      	b.n	34023b82 <_txe_thread_create+0x196>
        }

        /* Check the start selection.  */
        else if (auto_start > TX_AUTO_START)
34023b3a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34023b3c:	2b01      	cmp	r3, #1
34023b3e:	d902      	bls.n	34023b46 <_txe_thread_create+0x15a>
        {

            /* Invalid auto start selection, return appropriate error code.  */
            status =  TX_START_ERROR;
34023b40:	2310      	movs	r3, #16
34023b42:	64fb      	str	r3, [r7, #76]	@ 0x4c
34023b44:	e01d      	b.n	34023b82 <_txe_thread_create+0x196>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(current_thread)
34023b46:	4b1f      	ldr	r3, [pc, #124]	@ (34023bc4 <_txe_thread_create+0x1d8>)
34023b48:	681b      	ldr	r3, [r3, #0]
34023b4a:	633b      	str	r3, [r7, #48]	@ 0x30

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (current_thread == &_tx_timer_thread)
34023b4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34023b4e:	4a1e      	ldr	r2, [pc, #120]	@ (34023bc8 <_txe_thread_create+0x1dc>)
34023b50:	4293      	cmp	r3, r2
34023b52:	d101      	bne.n	34023b58 <_txe_thread_create+0x16c>
            {

                /* Invalid caller of this function, return appropriate error code.  */
                status =  TX_CALLER_ERROR;
34023b54:	2313      	movs	r3, #19
34023b56:	64fb      	str	r3, [r7, #76]	@ 0x4c
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023b58:	f3ef 8305 	mrs	r3, IPSR
34023b5c:	617b      	str	r3, [r7, #20]
    return(ipsr_value);
34023b5e:	697a      	ldr	r2, [r7, #20]
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
34023b60:	4b1a      	ldr	r3, [pc, #104]	@ (34023bcc <_txe_thread_create+0x1e0>)
34023b62:	681b      	ldr	r3, [r3, #0]
34023b64:	4313      	orrs	r3, r2
34023b66:	2b00      	cmp	r3, #0
34023b68:	d00b      	beq.n	34023b82 <_txe_thread_create+0x196>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023b6a:	f3ef 8305 	mrs	r3, IPSR
34023b6e:	613b      	str	r3, [r7, #16]
    return(ipsr_value);
34023b70:	693a      	ldr	r2, [r7, #16]
            {

                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
34023b72:	4b16      	ldr	r3, [pc, #88]	@ (34023bcc <_txe_thread_create+0x1e0>)
34023b74:	681b      	ldr	r3, [r3, #0]
34023b76:	4313      	orrs	r3, r2
34023b78:	f1b3 3ff0 	cmp.w	r3, #4042322160	@ 0xf0f0f0f0
34023b7c:	d201      	bcs.n	34023b82 <_txe_thread_create+0x196>
                {

                    /* Invalid caller of this function, return appropriate error code.  */
                    status =  TX_CALLER_ERROR;
34023b7e:	2313      	movs	r3, #19
34023b80:	64fb      	str	r3, [r7, #76]	@ 0x4c
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
34023b82:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
34023b84:	2b00      	cmp	r3, #0
34023b86:	d112      	bne.n	34023bae <_txe_thread_create+0x1c2>
    {

        /* Call actual thread create function.  */
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
34023b88:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
34023b8a:	9305      	str	r3, [sp, #20]
34023b8c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
34023b8e:	9304      	str	r3, [sp, #16]
34023b90:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
34023b92:	9303      	str	r3, [sp, #12]
34023b94:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
34023b96:	9302      	str	r3, [sp, #8]
34023b98:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
34023b9a:	9301      	str	r3, [sp, #4]
34023b9c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
34023b9e:	9300      	str	r3, [sp, #0]
34023ba0:	683b      	ldr	r3, [r7, #0]
34023ba2:	687a      	ldr	r2, [r7, #4]
34023ba4:	68b9      	ldr	r1, [r7, #8]
34023ba6:	68f8      	ldr	r0, [r7, #12]
34023ba8:	f7fe fc7a 	bl	340224a0 <_tx_thread_create>
34023bac:	64f8      	str	r0, [r7, #76]	@ 0x4c
                        stack_start, stack_size, priority, preempt_threshold,
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
34023bae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
34023bb0:	4618      	mov	r0, r3
34023bb2:	3750      	adds	r7, #80	@ 0x50
34023bb4:	46bd      	mov	sp, r7
34023bb6:	bd80      	pop	{r7, pc}
34023bb8:	3404ab8c 	.word	0x3404ab8c
34023bbc:	3404aaf8 	.word	0x3404aaf8
34023bc0:	3404aafc 	.word	0x3404aafc
34023bc4:	3404aaf0 	.word	0x3404aaf0
34023bc8:	3404ac40 	.word	0x3404ac40
34023bcc:	3404148c 	.word	0x3404148c

34023bd0 <_tx_execution_initialize>:
/*                                                                        */
/*  04-25-2022      Scott Larson            Initial Version 6.1.11        */
/*                                                                        */
/**************************************************************************/
VOID  _tx_execution_initialize(void)
{
34023bd0:	b480      	push	{r7}
34023bd2:	af00      	add	r7, sp, #0
    /* In idle mode until a thread is scheduled or ISR occurs.  */
    _tx_execution_idle_active = TX_TRUE;
34023bd4:	4b05      	ldr	r3, [pc, #20]	@ (34023bec <_tx_execution_initialize+0x1c>)
34023bd6:	2201      	movs	r2, #1
34023bd8:	601a      	str	r2, [r3, #0]

    /* Pickup the start of idle time.  */
    _tx_execution_idle_time_last_start =  TX_EXECUTION_TIME_SOURCE;
34023bda:	4b05      	ldr	r3, [pc, #20]	@ (34023bf0 <_tx_execution_initialize+0x20>)
34023bdc:	681b      	ldr	r3, [r3, #0]
34023bde:	4a05      	ldr	r2, [pc, #20]	@ (34023bf4 <_tx_execution_initialize+0x24>)
34023be0:	6013      	str	r3, [r2, #0]
}
34023be2:	bf00      	nop
34023be4:	46bd      	mov	sp, r7
34023be6:	f85d 7b04 	ldr.w	r7, [sp], #4
34023bea:	4770      	bx	lr
34023bec:	3404b134 	.word	0x3404b134
34023bf0:	e0001004 	.word	0xe0001004
34023bf4:	3404b130 	.word	0x3404b130

34023bf8 <_tx_execution_thread_enter>:
/*                                            wrap-around calculation,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_execution_thread_enter(void)
{
34023bf8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
34023bfc:	b08a      	sub	sp, #40	@ 0x28
34023bfe:	af00      	add	r7, sp, #0
EXECUTION_TIME              total_time;
EXECUTION_TIME              new_total_time;


    /* Pickup the current time.  */
    current_time =  TX_EXECUTION_TIME_SOURCE;
34023c00:	4e27      	ldr	r6, [pc, #156]	@ (34023ca0 <_tx_execution_thread_enter+0xa8>)
34023c02:	6836      	ldr	r6, [r6, #0]
34023c04:	617e      	str	r6, [r7, #20]

    /* Pickup the current thread control block.  */
    thread_ptr =  _tx_thread_current_ptr;
34023c06:	4e27      	ldr	r6, [pc, #156]	@ (34023ca4 <_tx_execution_thread_enter+0xac>)
34023c08:	6836      	ldr	r6, [r6, #0]
34023c0a:	613e      	str	r6, [r7, #16]

    /* This thread is being scheduled.  Simply setup the last start time in the
       thread control block.  */
    thread_ptr -> tx_thread_execution_time_last_start =  current_time;
34023c0c:	693e      	ldr	r6, [r7, #16]
34023c0e:	697b      	ldr	r3, [r7, #20]
34023c10:	f8c6 30b8 	str.w	r3, [r6, #184]	@ 0xb8
    
    /* Pickup the last idle start time.  */
    last_start_time =  _tx_execution_idle_time_last_start;
34023c14:	4e24      	ldr	r6, [pc, #144]	@ (34023ca8 <_tx_execution_thread_enter+0xb0>)
34023c16:	6836      	ldr	r6, [r6, #0]
34023c18:	60fe      	str	r6, [r7, #12]
    
    /* Determine if idle time is being measured.  */
    if (_tx_execution_idle_active)
34023c1a:	4e24      	ldr	r6, [pc, #144]	@ (34023cac <_tx_execution_thread_enter+0xb4>)
34023c1c:	6836      	ldr	r6, [r6, #0]
34023c1e:	2e00      	cmp	r6, #0
34023c20:	d038      	beq.n	34023c94 <_tx_execution_thread_enter+0x9c>
    {

        /* Determine how to calculate the difference.  */
        if (current_time >= last_start_time)
34023c22:	697b      	ldr	r3, [r7, #20]
34023c24:	68fe      	ldr	r6, [r7, #12]
34023c26:	42b3      	cmp	r3, r6
34023c28:	d308      	bcc.n	34023c3c <_tx_execution_thread_enter+0x44>
        {
        
            /* Simply subtract.  */
            delta_time =  (EXECUTION_TIME) (current_time - last_start_time);
34023c2a:	697a      	ldr	r2, [r7, #20]
34023c2c:	68fb      	ldr	r3, [r7, #12]
34023c2e:	1ad3      	subs	r3, r2, r3
34023c30:	2200      	movs	r2, #0
34023c32:	4618      	mov	r0, r3
34023c34:	4611      	mov	r1, r2
34023c36:	e9c7 0108 	strd	r0, r1, [r7, #32]
34023c3a:	e007      	b.n	34023c4c <_tx_execution_thread_enter+0x54>
        }
        else
        {
        
            /* Timer wrapped, compute the delta assuming incrementing time counter.  */
            delta_time =  (EXECUTION_TIME) (current_time + ((((EXECUTION_TIME_SOURCE_TYPE) TX_EXECUTION_MAX_TIME_SOURCE) + 1) - last_start_time));
34023c3c:	6978      	ldr	r0, [r7, #20]
34023c3e:	68f9      	ldr	r1, [r7, #12]
34023c40:	1a41      	subs	r1, r0, r1
34023c42:	2000      	movs	r0, #0
34023c44:	4688      	mov	r8, r1
34023c46:	4681      	mov	r9, r0
34023c48:	e9c7 8908 	strd	r8, r9, [r7, #32]
        }
    
        /* Pickup the total time.  */
        total_time =  _tx_execution_idle_time_total;
34023c4c:	4b18      	ldr	r3, [pc, #96]	@ (34023cb0 <_tx_execution_thread_enter+0xb8>)
34023c4e:	e9d3 2300 	ldrd	r2, r3, [r3]
34023c52:	e9c7 2300 	strd	r2, r3, [r7]

        /* Now compute the new total time.  */
        new_total_time =  total_time + delta_time;
34023c56:	e9d7 0100 	ldrd	r0, r1, [r7]
34023c5a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34023c5e:	1884      	adds	r4, r0, r2
34023c60:	eb41 0503 	adc.w	r5, r1, r3
34023c64:	e9c7 4506 	strd	r4, r5, [r7, #24]
        
        /* Determine if a rollover on the total time is present.  */
        if (new_total_time < total_time)
34023c68:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34023c6c:	e9d7 2300 	ldrd	r2, r3, [r7]
34023c70:	4290      	cmp	r0, r2
34023c72:	eb71 0303 	sbcs.w	r3, r1, r3
34023c76:	d205      	bcs.n	34023c84 <_tx_execution_thread_enter+0x8c>
        {
        
            /* Rollover. Set the total time to max value.  */
            new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023c78:	f04f 32ff 	mov.w	r2, #4294967295
34023c7c:	f04f 0300 	mov.w	r3, #0
34023c80:	e9c7 2306 	strd	r2, r3, [r7, #24]
        }
    
        /* Now store back the total idle time.  */
        _tx_execution_idle_time_total =  new_total_time;
34023c84:	490a      	ldr	r1, [pc, #40]	@ (34023cb0 <_tx_execution_thread_enter+0xb8>)
34023c86:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
34023c8a:	e9c1 2300 	strd	r2, r3, [r1]
        
        /* Disable the idle time measurement.  */
        _tx_execution_idle_active = TX_FALSE;
34023c8e:	4b07      	ldr	r3, [pc, #28]	@ (34023cac <_tx_execution_thread_enter+0xb4>)
34023c90:	2200      	movs	r2, #0
34023c92:	601a      	str	r2, [r3, #0]
    }
}
34023c94:	bf00      	nop
34023c96:	3728      	adds	r7, #40	@ 0x28
34023c98:	46bd      	mov	sp, r7
34023c9a:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
34023c9e:	4770      	bx	lr
34023ca0:	e0001004 	.word	0xe0001004
34023ca4:	3404aaf0 	.word	0x3404aaf0
34023ca8:	3404b130 	.word	0x3404b130
34023cac:	3404b134 	.word	0x3404b134
34023cb0:	3404b128 	.word	0x3404b128

34023cb4 <_tx_execution_thread_exit>:
/*                                            wrap-around calculation,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_execution_thread_exit(void)
{
34023cb4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
34023cb8:	b08a      	sub	sp, #40	@ 0x28
34023cba:	af00      	add	r7, sp, #0
EXECUTION_TIME_SOURCE_TYPE  current_time;
EXECUTION_TIME              delta_time;


    /* Pickup the current thread control block.  */
    thread_ptr =  _tx_thread_current_ptr;
34023cbc:	4e3c      	ldr	r6, [pc, #240]	@ (34023db0 <_tx_execution_thread_exit+0xfc>)
34023cbe:	6836      	ldr	r6, [r6, #0]
34023cc0:	617e      	str	r6, [r7, #20]

    /* Determine if there is a thread.  */
    if (thread_ptr)
34023cc2:	697e      	ldr	r6, [r7, #20]
34023cc4:	2e00      	cmp	r6, #0
34023cc6:	d06d      	beq.n	34023da4 <_tx_execution_thread_exit+0xf0>
    {
    
        /* Pickup the current time.  */
        current_time =  TX_EXECUTION_TIME_SOURCE;
34023cc8:	4e3a      	ldr	r6, [pc, #232]	@ (34023db4 <_tx_execution_thread_exit+0x100>)
34023cca:	6836      	ldr	r6, [r6, #0]
34023ccc:	613e      	str	r6, [r7, #16]

        /* Pickup the last start time.  */
        last_start_time =  thread_ptr -> tx_thread_execution_time_last_start;
34023cce:	697e      	ldr	r6, [r7, #20]
34023cd0:	f8d6 60b8 	ldr.w	r6, [r6, #184]	@ 0xb8
34023cd4:	60fe      	str	r6, [r7, #12]

        /* Determine if there is an actual start time.  */
        if (last_start_time)
34023cd6:	68fe      	ldr	r6, [r7, #12]
34023cd8:	2e00      	cmp	r6, #0
34023cda:	d058      	beq.n	34023d8e <_tx_execution_thread_exit+0xda>
        {

            /* Clear the last start time.  */
            thread_ptr -> tx_thread_execution_time_last_start =  0;
34023cdc:	697e      	ldr	r6, [r7, #20]
34023cde:	2300      	movs	r3, #0
34023ce0:	f8c6 30b8 	str.w	r3, [r6, #184]	@ 0xb8
      
            /* Determine how to calculate the difference.  */
            if (current_time >= last_start_time)
34023ce4:	693b      	ldr	r3, [r7, #16]
34023ce6:	68fe      	ldr	r6, [r7, #12]
34023ce8:	42b3      	cmp	r3, r6
34023cea:	d308      	bcc.n	34023cfe <_tx_execution_thread_exit+0x4a>
            {
        
                /* Simply subtract.  */
                delta_time =  (EXECUTION_TIME) (current_time - last_start_time);
34023cec:	693a      	ldr	r2, [r7, #16]
34023cee:	68fb      	ldr	r3, [r7, #12]
34023cf0:	1ad3      	subs	r3, r2, r3
34023cf2:	2200      	movs	r2, #0
34023cf4:	4618      	mov	r0, r3
34023cf6:	4611      	mov	r1, r2
34023cf8:	e9c7 0106 	strd	r0, r1, [r7, #24]
34023cfc:	e007      	b.n	34023d0e <_tx_execution_thread_exit+0x5a>
            }        
            else
            {
        
                /* Timer wrapped, compute the delta assuming incrementing time counter.  */
                delta_time =  (EXECUTION_TIME) (current_time + ((((EXECUTION_TIME_SOURCE_TYPE) TX_EXECUTION_MAX_TIME_SOURCE) + 1) - last_start_time));
34023cfe:	6938      	ldr	r0, [r7, #16]
34023d00:	68f9      	ldr	r1, [r7, #12]
34023d02:	1a41      	subs	r1, r0, r1
34023d04:	2000      	movs	r0, #0
34023d06:	468a      	mov	sl, r1
34023d08:	4683      	mov	fp, r0
34023d0a:	e9c7 ab06 	strd	sl, fp, [r7, #24]
            }

            /* Pickup the total time.  */
            total_time =  thread_ptr -> tx_thread_execution_time_total;
34023d0e:	697b      	ldr	r3, [r7, #20]
34023d10:	e9d3 232c 	ldrd	r2, r3, [r3, #176]	@ 0xb0
34023d14:	e9c7 2300 	strd	r2, r3, [r7]

            /* Now compute the new total time.  */
            new_total_time =  total_time + delta_time;
34023d18:	e9d7 0100 	ldrd	r0, r1, [r7]
34023d1c:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
34023d20:	eb10 0802 	adds.w	r8, r0, r2
34023d24:	eb41 0903 	adc.w	r9, r1, r3
34023d28:	e9c7 8908 	strd	r8, r9, [r7, #32]
        
            /* Determine if a rollover on the total time is present.  */
            if (new_total_time < total_time)
34023d2c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34023d30:	e9d7 2300 	ldrd	r2, r3, [r7]
34023d34:	4290      	cmp	r0, r2
34023d36:	eb71 0303 	sbcs.w	r3, r1, r3
34023d3a:	d205      	bcs.n	34023d48 <_tx_execution_thread_exit+0x94>
            {
        
                /* Rollover. Set the total time to max value.  */
                new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023d3c:	f04f 32ff 	mov.w	r2, #4294967295
34023d40:	f04f 0300 	mov.w	r3, #0
34023d44:	e9c7 2308 	strd	r2, r3, [r7, #32]
            }
    
            /* Store back the new total time.  */
            thread_ptr -> tx_thread_execution_time_total =  new_total_time;
34023d48:	6979      	ldr	r1, [r7, #20]
34023d4a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34023d4e:	e9c1 232c 	strd	r2, r3, [r1, #176]	@ 0xb0
            
            /* Now accumulate this thread's execution time into the total thread execution time.  */
            new_total_time =  _tx_execution_thread_time_total + delta_time;
34023d52:	4b19      	ldr	r3, [pc, #100]	@ (34023db8 <_tx_execution_thread_exit+0x104>)
34023d54:	e9d3 2300 	ldrd	r2, r3, [r3]
34023d58:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
34023d5c:	1884      	adds	r4, r0, r2
34023d5e:	eb41 0503 	adc.w	r5, r1, r3
34023d62:	e9c7 4508 	strd	r4, r5, [r7, #32]
            
            /* Determine if a rollover on the total time is present.  */
            if (new_total_time < _tx_execution_thread_time_total)
34023d66:	4b14      	ldr	r3, [pc, #80]	@ (34023db8 <_tx_execution_thread_exit+0x104>)
34023d68:	e9d3 2300 	ldrd	r2, r3, [r3]
34023d6c:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34023d70:	4290      	cmp	r0, r2
34023d72:	eb71 0303 	sbcs.w	r3, r1, r3
34023d76:	d205      	bcs.n	34023d84 <_tx_execution_thread_exit+0xd0>
            {
        
                /* Rollover. Set the total time to max value.  */
                new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023d78:	f04f 32ff 	mov.w	r2, #4294967295
34023d7c:	f04f 0300 	mov.w	r3, #0
34023d80:	e9c7 2308 	strd	r2, r3, [r7, #32]
            }

            /* Store back the new total time.  */
            _tx_execution_thread_time_total =  new_total_time;
34023d84:	490c      	ldr	r1, [pc, #48]	@ (34023db8 <_tx_execution_thread_exit+0x104>)
34023d86:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34023d8a:	e9c1 2300 	strd	r2, r3, [r1]
        }

        /* Is the system now idle?  */
        if (_tx_thread_execute_ptr == TX_NULL)
34023d8e:	4b0b      	ldr	r3, [pc, #44]	@ (34023dbc <_tx_execution_thread_exit+0x108>)
34023d90:	681b      	ldr	r3, [r3, #0]
34023d92:	2b00      	cmp	r3, #0
34023d94:	d106      	bne.n	34023da4 <_tx_execution_thread_exit+0xf0>
        {
            /* Yes, idle system. Pickup the start of idle time.  */
            _tx_execution_idle_time_last_start =  TX_EXECUTION_TIME_SOURCE;
34023d96:	4b07      	ldr	r3, [pc, #28]	@ (34023db4 <_tx_execution_thread_exit+0x100>)
34023d98:	681b      	ldr	r3, [r3, #0]
34023d9a:	4a09      	ldr	r2, [pc, #36]	@ (34023dc0 <_tx_execution_thread_exit+0x10c>)
34023d9c:	6013      	str	r3, [r2, #0]
            _tx_execution_idle_active = TX_TRUE;
34023d9e:	4b09      	ldr	r3, [pc, #36]	@ (34023dc4 <_tx_execution_thread_exit+0x110>)
34023da0:	2201      	movs	r2, #1
34023da2:	601a      	str	r2, [r3, #0]
        }
    }
}
34023da4:	bf00      	nop
34023da6:	3728      	adds	r7, #40	@ 0x28
34023da8:	46bd      	mov	sp, r7
34023daa:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
34023dae:	4770      	bx	lr
34023db0:	3404aaf0 	.word	0x3404aaf0
34023db4:	e0001004 	.word	0xe0001004
34023db8:	3404b110 	.word	0x3404b110
34023dbc:	3404aaf4 	.word	0x3404aaf4
34023dc0:	3404b130 	.word	0x3404b130
34023dc4:	3404b134 	.word	0x3404b134

34023dc8 <_tx_execution_isr_enter>:
/*                                            wrap-around calculation,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_execution_isr_enter(void)
{
34023dc8:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
34023dcc:	b093      	sub	sp, #76	@ 0x4c
34023dce:	af00      	add	r7, sp, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023dd0:	f3ef 8305 	mrs	r3, IPSR
34023dd4:	61fb      	str	r3, [r7, #28]
    return(ipsr_value);
34023dd6:	69fa      	ldr	r2, [r7, #28]
    /* Determine if this is the first interrupt. Nested interrupts are all treated as
       general interrupt processing.  */
#ifdef TX_CORTEX_M_EPK
    if ((TX_THREAD_GET_SYSTEM_STATE()) && (_tx_execution_isr_nest_counter == 1))
#else
    if (TX_THREAD_GET_SYSTEM_STATE() == 1)
34023dd8:	4b60      	ldr	r3, [pc, #384]	@ (34023f5c <_tx_execution_isr_enter+0x194>)
34023dda:	681b      	ldr	r3, [r3, #0]
34023ddc:	4313      	orrs	r3, r2
34023dde:	2b01      	cmp	r3, #1
34023de0:	f040 80b5 	bne.w	34023f4e <_tx_execution_isr_enter+0x186>
#endif
    {
        /* Pickup the current time.  */
        current_time =  TX_EXECUTION_TIME_SOURCE;
34023de4:	4b5e      	ldr	r3, [pc, #376]	@ (34023f60 <_tx_execution_isr_enter+0x198>)
34023de6:	681b      	ldr	r3, [r3, #0]
34023de8:	637b      	str	r3, [r7, #52]	@ 0x34

        /* Pickup the current thread control block.  */
        thread_ptr =  _tx_thread_current_ptr;
34023dea:	4b5e      	ldr	r3, [pc, #376]	@ (34023f64 <_tx_execution_isr_enter+0x19c>)
34023dec:	681b      	ldr	r3, [r3, #0]
34023dee:	633b      	str	r3, [r7, #48]	@ 0x30

        /* Determine if a thread was interrupted.  */
        if (thread_ptr)
34023df0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34023df2:	2b00      	cmp	r3, #0
34023df4:	d066      	beq.n	34023ec4 <_tx_execution_isr_enter+0xfc>
        {
        
            /* Pickup the last start time.  */
            last_start_time =  thread_ptr -> tx_thread_execution_time_last_start;
34023df6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34023df8:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34023dfc:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /* Determine if there is an actual start time.  */
            if (last_start_time)
34023dfe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023e00:	2b00      	cmp	r3, #0
34023e02:	f000 80a1 	beq.w	34023f48 <_tx_execution_isr_enter+0x180>
            {

                /* Clear the last start time.  */
                thread_ptr -> tx_thread_execution_time_last_start =  0;
34023e06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34023e08:	2200      	movs	r2, #0
34023e0a:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
        
                /* Determine how to calculate the difference.  */
                if (current_time >= last_start_time)
34023e0e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023e10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023e12:	429a      	cmp	r2, r3
34023e14:	d30a      	bcc.n	34023e2c <_tx_execution_isr_enter+0x64>
                {
        
                    /* Simply subtract.  */
                    delta_time =  (EXECUTION_TIME) (current_time - last_start_time);
34023e16:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023e18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023e1a:	1ad3      	subs	r3, r2, r3
34023e1c:	2200      	movs	r2, #0
34023e1e:	613b      	str	r3, [r7, #16]
34023e20:	617a      	str	r2, [r7, #20]
34023e22:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
34023e26:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
34023e2a:	e009      	b.n	34023e40 <_tx_execution_isr_enter+0x78>
                }        
                else
                {
        
                    /* Timer wrapped, compute the delta assuming incrementing time counter.  */
                    delta_time =  (EXECUTION_TIME) (current_time + ((((EXECUTION_TIME_SOURCE_TYPE) TX_EXECUTION_MAX_TIME_SOURCE) + 1) - last_start_time));
34023e2c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023e2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023e30:	1ad3      	subs	r3, r2, r3
34023e32:	2200      	movs	r2, #0
34023e34:	60bb      	str	r3, [r7, #8]
34023e36:	60fa      	str	r2, [r7, #12]
34023e38:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
34023e3c:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
                }

                /* Pickup the total time.  */
                total_time =  thread_ptr -> tx_thread_execution_time_total;
34023e40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34023e42:	e9d3 232c 	ldrd	r2, r3, [r3, #176]	@ 0xb0
34023e46:	e9c7 2308 	strd	r2, r3, [r7, #32]

                /* Now compute the new total time.  */
                new_total_time =  total_time + delta_time;
34023e4a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34023e4e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
34023e52:	eb10 0a02 	adds.w	sl, r0, r2
34023e56:	eb41 0b03 	adc.w	fp, r1, r3
34023e5a:	e9c7 ab10 	strd	sl, fp, [r7, #64]	@ 0x40
        
                /* Determine if a rollover on the total time is present.  */
                if (new_total_time < total_time)
34023e5e:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34023e62:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34023e66:	4290      	cmp	r0, r2
34023e68:	eb71 0303 	sbcs.w	r3, r1, r3
34023e6c:	d205      	bcs.n	34023e7a <_tx_execution_isr_enter+0xb2>
                {
        
                    /* Rollover. Set the total time to max value.  */
                    new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023e6e:	f04f 32ff 	mov.w	r2, #4294967295
34023e72:	f04f 0300 	mov.w	r3, #0
34023e76:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
                }
    
                /* Store back the new total time.  */
                thread_ptr -> tx_thread_execution_time_total =  new_total_time;
34023e7a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
34023e7c:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
34023e80:	e9c1 232c 	strd	r2, r3, [r1, #176]	@ 0xb0

                /* Now accumulate this thread's execution time into the total thread execution time.  */
                new_total_time =  _tx_execution_thread_time_total + delta_time;
34023e84:	4b38      	ldr	r3, [pc, #224]	@ (34023f68 <_tx_execution_isr_enter+0x1a0>)
34023e86:	e9d3 2300 	ldrd	r2, r3, [r3]
34023e8a:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
34023e8e:	eb10 0802 	adds.w	r8, r0, r2
34023e92:	eb41 0903 	adc.w	r9, r1, r3
34023e96:	e9c7 8910 	strd	r8, r9, [r7, #64]	@ 0x40
            
                /* Determine if a rollover on the total time is present.  */
                if (new_total_time < _tx_execution_thread_time_total)
34023e9a:	4b33      	ldr	r3, [pc, #204]	@ (34023f68 <_tx_execution_isr_enter+0x1a0>)
34023e9c:	e9d3 2300 	ldrd	r2, r3, [r3]
34023ea0:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34023ea4:	4290      	cmp	r0, r2
34023ea6:	eb71 0303 	sbcs.w	r3, r1, r3
34023eaa:	d205      	bcs.n	34023eb8 <_tx_execution_isr_enter+0xf0>
                {
        
                    /* Rollover. Set the total time to max value.  */
                    new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023eac:	f04f 32ff 	mov.w	r2, #4294967295
34023eb0:	f04f 0300 	mov.w	r3, #0
34023eb4:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
                }            

                /* Store back the new total time.  */
                _tx_execution_thread_time_total =  new_total_time;
34023eb8:	492b      	ldr	r1, [pc, #172]	@ (34023f68 <_tx_execution_isr_enter+0x1a0>)
34023eba:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
34023ebe:	e9c1 2300 	strd	r2, r3, [r1]
34023ec2:	e041      	b.n	34023f48 <_tx_execution_isr_enter+0x180>
            }
        }
        
        /* Has idle time started?  */
        else if (_tx_execution_idle_active)
34023ec4:	4b29      	ldr	r3, [pc, #164]	@ (34023f6c <_tx_execution_isr_enter+0x1a4>)
34023ec6:	681b      	ldr	r3, [r3, #0]
34023ec8:	2b00      	cmp	r3, #0
34023eca:	d03d      	beq.n	34023f48 <_tx_execution_isr_enter+0x180>
        {
        
            /* Pickup the last idle start time.  */
            last_start_time =  _tx_execution_idle_time_last_start;
34023ecc:	4b28      	ldr	r3, [pc, #160]	@ (34023f70 <_tx_execution_isr_enter+0x1a8>)
34023ece:	681b      	ldr	r3, [r3, #0]
34023ed0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    
            /* Determine how to calculate the difference.  */
            if (current_time >= last_start_time)
34023ed2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023ed4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023ed6:	429a      	cmp	r2, r3
34023ed8:	d30a      	bcc.n	34023ef0 <_tx_execution_isr_enter+0x128>
            {
        
                /* Simply subtract.  */
                delta_time =  (EXECUTION_TIME) (current_time - last_start_time);
34023eda:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023edc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023ede:	1ad3      	subs	r3, r2, r3
34023ee0:	2200      	movs	r2, #0
34023ee2:	603b      	str	r3, [r7, #0]
34023ee4:	607a      	str	r2, [r7, #4]
34023ee6:	e9d7 2300 	ldrd	r2, r3, [r7]
34023eea:	e9c7 230e 	strd	r2, r3, [r7, #56]	@ 0x38
34023eee:	e007      	b.n	34023f00 <_tx_execution_isr_enter+0x138>
            }        
            else
            {
        
                /* Timer wrapped, compute the delta assuming incrementing time counter.  */
                delta_time =  (EXECUTION_TIME) (current_time + ((((EXECUTION_TIME_SOURCE_TYPE) TX_EXECUTION_MAX_TIME_SOURCE) + 1) - last_start_time));
34023ef0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
34023ef2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34023ef4:	1ad3      	subs	r3, r2, r3
34023ef6:	2200      	movs	r2, #0
34023ef8:	4618      	mov	r0, r3
34023efa:	4611      	mov	r1, r2
34023efc:	e9c7 010e 	strd	r0, r1, [r7, #56]	@ 0x38
            }
    
            /* Pickup the total time.  */
            total_time =  _tx_execution_idle_time_total;
34023f00:	4b1c      	ldr	r3, [pc, #112]	@ (34023f74 <_tx_execution_isr_enter+0x1ac>)
34023f02:	e9d3 2300 	ldrd	r2, r3, [r3]
34023f06:	e9c7 2308 	strd	r2, r3, [r7, #32]

            /* Now compute the new total time.  */
            new_total_time =  total_time + delta_time;
34023f0a:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34023f0e:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	@ 0x38
34023f12:	1884      	adds	r4, r0, r2
34023f14:	eb41 0503 	adc.w	r5, r1, r3
34023f18:	e9c7 4510 	strd	r4, r5, [r7, #64]	@ 0x40
        
            /* Determine if a rollover on the total time is present.  */
            if (new_total_time < total_time)
34023f1c:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
34023f20:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
34023f24:	4290      	cmp	r0, r2
34023f26:	eb71 0303 	sbcs.w	r3, r1, r3
34023f2a:	d205      	bcs.n	34023f38 <_tx_execution_isr_enter+0x170>
            {
        
                /* Rollover. Set the total time to max value.  */
                new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023f2c:	f04f 32ff 	mov.w	r2, #4294967295
34023f30:	f04f 0300 	mov.w	r3, #0
34023f34:	e9c7 2310 	strd	r2, r3, [r7, #64]	@ 0x40
            }
    
            /* Now store back the total idle time.  */
            _tx_execution_idle_time_total =  new_total_time;    
34023f38:	490e      	ldr	r1, [pc, #56]	@ (34023f74 <_tx_execution_isr_enter+0x1ac>)
34023f3a:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	@ 0x40
34023f3e:	e9c1 2300 	strd	r2, r3, [r1]
        
            /* Disable the idle time measurement.  */
            _tx_execution_idle_active = TX_FALSE;
34023f42:	4b0a      	ldr	r3, [pc, #40]	@ (34023f6c <_tx_execution_isr_enter+0x1a4>)
34023f44:	2200      	movs	r2, #0
34023f46:	601a      	str	r2, [r3, #0]
        }

        /* Save the ISR start time.  */
        _tx_execution_isr_time_last_start =  current_time;
34023f48:	4a0b      	ldr	r2, [pc, #44]	@ (34023f78 <_tx_execution_isr_enter+0x1b0>)
34023f4a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
34023f4c:	6013      	str	r3, [r2, #0]
    }
}
34023f4e:	bf00      	nop
34023f50:	374c      	adds	r7, #76	@ 0x4c
34023f52:	46bd      	mov	sp, r7
34023f54:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
34023f58:	4770      	bx	lr
34023f5a:	bf00      	nop
34023f5c:	3404148c 	.word	0x3404148c
34023f60:	e0001004 	.word	0xe0001004
34023f64:	3404aaf0 	.word	0x3404aaf0
34023f68:	3404b110 	.word	0x3404b110
34023f6c:	3404b134 	.word	0x3404b134
34023f70:	3404b130 	.word	0x3404b130
34023f74:	3404b128 	.word	0x3404b128
34023f78:	3404b120 	.word	0x3404b120

34023f7c <_tx_execution_isr_exit>:
/*                                            wrap-around calculation,    */
/*                                            resulting in version 6.1.11 */
/*                                                                        */
/**************************************************************************/
VOID  _tx_execution_isr_exit(void)
{
34023f7c:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
34023f80:	b08a      	sub	sp, #40	@ 0x28
34023f82:	af00      	add	r7, sp, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
34023f84:	f3ef 8605 	mrs	r6, IPSR
34023f88:	603e      	str	r6, [r7, #0]
    return(ipsr_value);
34023f8a:	683e      	ldr	r6, [r7, #0]
34023f8c:	4633      	mov	r3, r6
    /* Determine if this is the first interrupt. Nested interrupts are all treated as 
       general interrupt processing.  */
#ifdef TX_CORTEX_M_EPK
    if ((TX_THREAD_GET_SYSTEM_STATE()) && (_tx_execution_isr_nest_counter == 1))
#else
    if (TX_THREAD_GET_SYSTEM_STATE() == 1)
34023f8e:	4e33      	ldr	r6, [pc, #204]	@ (3402405c <_tx_execution_isr_exit+0xe0>)
34023f90:	6836      	ldr	r6, [r6, #0]
34023f92:	431e      	orrs	r6, r3
34023f94:	2e01      	cmp	r6, #1
34023f96:	d15a      	bne.n	3402404e <_tx_execution_isr_exit+0xd2>
#endif
    {

        /* Pickup the current time.  */
        current_time =  TX_EXECUTION_TIME_SOURCE;
34023f98:	4e31      	ldr	r6, [pc, #196]	@ (34024060 <_tx_execution_isr_exit+0xe4>)
34023f9a:	6836      	ldr	r6, [r6, #0]
34023f9c:	617e      	str	r6, [r7, #20]

        /* Pickup the last start time.  */
        last_start_time =  _tx_execution_isr_time_last_start;
34023f9e:	4e31      	ldr	r6, [pc, #196]	@ (34024064 <_tx_execution_isr_exit+0xe8>)
34023fa0:	6836      	ldr	r6, [r6, #0]
34023fa2:	613e      	str	r6, [r7, #16]
        
        /* Determine how to calculate the difference.  */
        if (current_time >= last_start_time)
34023fa4:	697b      	ldr	r3, [r7, #20]
34023fa6:	693e      	ldr	r6, [r7, #16]
34023fa8:	42b3      	cmp	r3, r6
34023faa:	d308      	bcc.n	34023fbe <_tx_execution_isr_exit+0x42>
        {
        
           /* Simply subtract.  */
           delta_time =  (EXECUTION_TIME) (current_time - last_start_time);
34023fac:	697a      	ldr	r2, [r7, #20]
34023fae:	693b      	ldr	r3, [r7, #16]
34023fb0:	1ad3      	subs	r3, r2, r3
34023fb2:	2200      	movs	r2, #0
34023fb4:	4618      	mov	r0, r3
34023fb6:	4611      	mov	r1, r2
34023fb8:	e9c7 0106 	strd	r0, r1, [r7, #24]
34023fbc:	e008      	b.n	34023fd0 <_tx_execution_isr_exit+0x54>
        }
        else
        {
        
            /* Timer wrapped, compute the delta assuming incrementing time counter.  */
            delta_time =  (EXECUTION_TIME) (current_time + (((EXECUTION_TIME_SOURCE_TYPE) TX_EXECUTION_MAX_TIME_SOURCE) - last_start_time));
34023fbe:	6978      	ldr	r0, [r7, #20]
34023fc0:	6939      	ldr	r1, [r7, #16]
34023fc2:	1a41      	subs	r1, r0, r1
34023fc4:	3901      	subs	r1, #1
34023fc6:	2000      	movs	r0, #0
34023fc8:	4688      	mov	r8, r1
34023fca:	4681      	mov	r9, r0
34023fcc:	e9c7 8906 	strd	r8, r9, [r7, #24]
        }

        /* Pickup the total time.  */
        total_time =  _tx_execution_isr_time_total;
34023fd0:	4b25      	ldr	r3, [pc, #148]	@ (34024068 <_tx_execution_isr_exit+0xec>)
34023fd2:	e9d3 2300 	ldrd	r2, r3, [r3]
34023fd6:	e9c7 2302 	strd	r2, r3, [r7, #8]

        /* Now compute the new total time.  */
        new_total_time =  total_time + delta_time;
34023fda:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
34023fde:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
34023fe2:	1884      	adds	r4, r0, r2
34023fe4:	eb41 0503 	adc.w	r5, r1, r3
34023fe8:	e9c7 4508 	strd	r4, r5, [r7, #32]
        
        /* Determine if a rollover on the total time is present.  */
        if (new_total_time < total_time)
34023fec:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
34023ff0:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
34023ff4:	4290      	cmp	r0, r2
34023ff6:	eb71 0303 	sbcs.w	r3, r1, r3
34023ffa:	d205      	bcs.n	34024008 <_tx_execution_isr_exit+0x8c>
        {
        
            /* Rollover. Set the total time to max value.  */
            new_total_time =  (EXECUTION_TIME) TX_EXECUTION_MAX_TIME_SOURCE;
34023ffc:	f04f 32ff 	mov.w	r2, #4294967295
34024000:	f04f 0300 	mov.w	r3, #0
34024004:	e9c7 2308 	strd	r2, r3, [r7, #32]
        }
    
        /* Store back the new total time.  */
        _tx_execution_isr_time_total =  new_total_time;
34024008:	4917      	ldr	r1, [pc, #92]	@ (34024068 <_tx_execution_isr_exit+0xec>)
3402400a:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
3402400e:	e9c1 2300 	strd	r2, r3, [r1]
        
        /* Pickup the current thread control block.  */
        thread_ptr =  _tx_thread_current_ptr;
34024012:	4b16      	ldr	r3, [pc, #88]	@ (3402406c <_tx_execution_isr_exit+0xf0>)
34024014:	681b      	ldr	r3, [r3, #0]
34024016:	607b      	str	r3, [r7, #4]

        /* Was a thread interrupted?  */
        if (thread_ptr)
34024018:	687b      	ldr	r3, [r7, #4]
3402401a:	2b00      	cmp	r3, #0
3402401c:	d00c      	beq.n	34024038 <_tx_execution_isr_exit+0xbc>
        {

            /* Now determine if the thread will execution is going to occur immediately.  */
            if ((thread_ptr == _tx_thread_execute_ptr) || (_tx_thread_preempt_disable))
3402401e:	4b14      	ldr	r3, [pc, #80]	@ (34024070 <_tx_execution_isr_exit+0xf4>)
34024020:	681b      	ldr	r3, [r3, #0]
34024022:	687a      	ldr	r2, [r7, #4]
34024024:	429a      	cmp	r2, r3
34024026:	d003      	beq.n	34024030 <_tx_execution_isr_exit+0xb4>
34024028:	4b12      	ldr	r3, [pc, #72]	@ (34024074 <_tx_execution_isr_exit+0xf8>)
3402402a:	681b      	ldr	r3, [r3, #0]
3402402c:	2b00      	cmp	r3, #0
3402402e:	d003      	beq.n	34024038 <_tx_execution_isr_exit+0xbc>
            {
            
                /* Yes, setup the thread last start time in the thread control block.  */
                thread_ptr -> tx_thread_execution_time_last_start =  current_time;
34024030:	687b      	ldr	r3, [r7, #4]
34024032:	697a      	ldr	r2, [r7, #20]
34024034:	f8c3 20b8 	str.w	r2, [r3, #184]	@ 0xb8
            }
        }
        
        /* Determine if the system is now idle.  */
        if (_tx_thread_execute_ptr == TX_NULL)
34024038:	4b0d      	ldr	r3, [pc, #52]	@ (34024070 <_tx_execution_isr_exit+0xf4>)
3402403a:	681b      	ldr	r3, [r3, #0]
3402403c:	2b00      	cmp	r3, #0
3402403e:	d106      	bne.n	3402404e <_tx_execution_isr_exit+0xd2>
        {
        
            /* Yes, idle system. Pickup the start of idle time.  */
            _tx_execution_idle_time_last_start =  TX_EXECUTION_TIME_SOURCE;
34024040:	4b07      	ldr	r3, [pc, #28]	@ (34024060 <_tx_execution_isr_exit+0xe4>)
34024042:	681b      	ldr	r3, [r3, #0]
34024044:	4a0c      	ldr	r2, [pc, #48]	@ (34024078 <_tx_execution_isr_exit+0xfc>)
34024046:	6013      	str	r3, [r2, #0]
            _tx_execution_idle_active = TX_TRUE;
34024048:	4b0c      	ldr	r3, [pc, #48]	@ (3402407c <_tx_execution_isr_exit+0x100>)
3402404a:	2201      	movs	r2, #1
3402404c:	601a      	str	r2, [r3, #0]
    
#ifdef TX_CORTEX_M_EPK
    /* Decrement the nested interrupt counter.  */
    _tx_execution_isr_nest_counter--;
#endif
}
3402404e:	bf00      	nop
34024050:	3728      	adds	r7, #40	@ 0x28
34024052:	46bd      	mov	sp, r7
34024054:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
34024058:	4770      	bx	lr
3402405a:	bf00      	nop
3402405c:	3404148c 	.word	0x3404148c
34024060:	e0001004 	.word	0xe0001004
34024064:	3404b120 	.word	0x3404b120
34024068:	3404b118 	.word	0x3404b118
3402406c:	3404aaf0 	.word	0x3404aaf0
34024070:	3404aaf4 	.word	0x3404aaf4
34024074:	3404ab8c 	.word	0x3404ab8c
34024078:	3404b130 	.word	0x3404b130
3402407c:	3404b134 	.word	0x3404b134

34024080 <_tx_execution_thread_total_time_get>:
/*                                                                        */
/*  06-02-2021      William E. Lamie        Initial Version 6.1.7         */
/*                                                                        */
/**************************************************************************/
UINT  _tx_execution_thread_total_time_get(EXECUTION_TIME *total_time)
{
34024080:	b480      	push	{r7}
34024082:	b083      	sub	sp, #12
34024084:	af00      	add	r7, sp, #0
34024086:	6078      	str	r0, [r7, #4]

    /* Return the total time.  */
    *total_time =  _tx_execution_thread_time_total;
34024088:	4b06      	ldr	r3, [pc, #24]	@ (340240a4 <_tx_execution_thread_total_time_get+0x24>)
3402408a:	e9d3 2300 	ldrd	r2, r3, [r3]
3402408e:	6879      	ldr	r1, [r7, #4]
34024090:	e9c1 2300 	strd	r2, r3, [r1]

    /* Return success.  */
    return(TX_SUCCESS);
34024094:	2300      	movs	r3, #0
}
34024096:	4618      	mov	r0, r3
34024098:	370c      	adds	r7, #12
3402409a:	46bd      	mov	sp, r7
3402409c:	f85d 7b04 	ldr.w	r7, [sp], #4
340240a0:	4770      	bx	lr
340240a2:	bf00      	nop
340240a4:	3404b110 	.word	0x3404b110

340240a8 <_tx_execution_isr_time_get>:
/*                                                                        */
/*  06-02-2021      William E. Lamie        Initial Version 6.1.7         */
/*                                                                        */
/**************************************************************************/
UINT  _tx_execution_isr_time_get(EXECUTION_TIME *total_time)
{
340240a8:	b480      	push	{r7}
340240aa:	b083      	sub	sp, #12
340240ac:	af00      	add	r7, sp, #0
340240ae:	6078      	str	r0, [r7, #4]

    /* Return the total time.  */
    *total_time =  _tx_execution_isr_time_total;
340240b0:	4b06      	ldr	r3, [pc, #24]	@ (340240cc <_tx_execution_isr_time_get+0x24>)
340240b2:	e9d3 2300 	ldrd	r2, r3, [r3]
340240b6:	6879      	ldr	r1, [r7, #4]
340240b8:	e9c1 2300 	strd	r2, r3, [r1]

    /* Return success.  */
    return(TX_SUCCESS);
340240bc:	2300      	movs	r3, #0
}
340240be:	4618      	mov	r0, r3
340240c0:	370c      	adds	r7, #12
340240c2:	46bd      	mov	sp, r7
340240c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340240c8:	4770      	bx	lr
340240ca:	bf00      	nop
340240cc:	3404b118 	.word	0x3404b118

340240d0 <_tx_execution_idle_time_get>:
/*                                                                        */
/*  06-02-2021      William E. Lamie        Initial Version 6.1.7         */
/*                                                                        */
/**************************************************************************/
UINT  _tx_execution_idle_time_get(EXECUTION_TIME *total_time)
{
340240d0:	b480      	push	{r7}
340240d2:	b083      	sub	sp, #12
340240d4:	af00      	add	r7, sp, #0
340240d6:	6078      	str	r0, [r7, #4]

    /* Return the total time.  */
    *total_time =  _tx_execution_idle_time_total;
340240d8:	4b06      	ldr	r3, [pc, #24]	@ (340240f4 <_tx_execution_idle_time_get+0x24>)
340240da:	e9d3 2300 	ldrd	r2, r3, [r3]
340240de:	6879      	ldr	r1, [r7, #4]
340240e0:	e9c1 2300 	strd	r2, r3, [r1]

    /* Return success.  */
    return(TX_SUCCESS);
340240e4:	2300      	movs	r3, #0
}
340240e6:	4618      	mov	r0, r3
340240e8:	370c      	adds	r7, #12
340240ea:	46bd      	mov	sp, r7
340240ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340240f0:	4770      	bx	lr
340240f2:	bf00      	nop
340240f4:	3404b128 	.word	0x3404b128

340240f8 <LL_ATON_Set_User_Input_Buffer_Default>:

/* User Output allocated buffer (mempool 9) size 5880 */
static unsigned char *_mem_pool__user_io_output_0_Default = NULL; /* tensor name Transpose_55_out_0 */

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
340240f8:	b480      	push	{r7}
340240fa:	b085      	sub	sp, #20
340240fc:	af00      	add	r7, sp, #0
340240fe:	60f8      	str	r0, [r7, #12]
34024100:	60b9      	str	r1, [r7, #8]
34024102:	607a      	str	r2, [r7, #4]
  if (num == 0) {
34024104:	68fb      	ldr	r3, [r7, #12]
34024106:	2b00      	cmp	r3, #0
34024108:	d111      	bne.n	3402412e <LL_ATON_Set_User_Input_Buffer_Default+0x36>
    if (((uintptr_t)buffer % 32) != 0)
3402410a:	68bb      	ldr	r3, [r7, #8]
3402410c:	f003 031f 	and.w	r3, r3, #31
34024110:	2b00      	cmp	r3, #0
34024112:	d001      	beq.n	34024118 <LL_ATON_Set_User_Input_Buffer_Default+0x20>
      return LL_ATON_User_IO_WRONG_ALIGN; /* enforce MCU cacheline alignment */
34024114:	2301      	movs	r3, #1
34024116:	e00b      	b.n	34024130 <LL_ATON_Set_User_Input_Buffer_Default+0x38>
    if (size < 150528)
34024118:	687b      	ldr	r3, [r7, #4]
3402411a:	f5b3 3f13 	cmp.w	r3, #150528	@ 0x24c00
3402411e:	d201      	bcs.n	34024124 <LL_ATON_Set_User_Input_Buffer_Default+0x2c>
      return LL_ATON_User_IO_WRONG_SIZE; /* enforce size needed */
34024120:	2302      	movs	r3, #2
34024122:	e005      	b.n	34024130 <LL_ATON_Set_User_Input_Buffer_Default+0x38>
    _mem_pool__user_io_input_0_Default = buffer;
34024124:	4a05      	ldr	r2, [pc, #20]	@ (3402413c <LL_ATON_Set_User_Input_Buffer_Default+0x44>)
34024126:	68bb      	ldr	r3, [r7, #8]
34024128:	6013      	str	r3, [r2, #0]
    return LL_ATON_User_IO_NOERROR;
3402412a:	2300      	movs	r3, #0
3402412c:	e000      	b.n	34024130 <LL_ATON_Set_User_Input_Buffer_Default+0x38>
  } else
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
3402412e:	2303      	movs	r3, #3
  }
}
34024130:	4618      	mov	r0, r3
34024132:	3714      	adds	r7, #20
34024134:	46bd      	mov	sp, r7
34024136:	f85d 7b04 	ldr.w	r7, [sp], #4
3402413a:	4770      	bx	lr
3402413c:	3404b138 	.word	0x3404b138

34024140 <LL_ATON_Get_User_Input_Buffer_Default>:

void *LL_ATON_Get_User_Input_Buffer_Default(uint32_t num)
{
34024140:	b480      	push	{r7}
34024142:	b083      	sub	sp, #12
34024144:	af00      	add	r7, sp, #0
34024146:	6078      	str	r0, [r7, #4]
  if (num == 0) {
34024148:	687b      	ldr	r3, [r7, #4]
3402414a:	2b00      	cmp	r3, #0
3402414c:	d102      	bne.n	34024154 <LL_ATON_Get_User_Input_Buffer_Default+0x14>
    return _mem_pool__user_io_input_0_Default;
3402414e:	4b05      	ldr	r3, [pc, #20]	@ (34024164 <LL_ATON_Get_User_Input_Buffer_Default+0x24>)
34024150:	681b      	ldr	r3, [r3, #0]
34024152:	e000      	b.n	34024156 <LL_ATON_Get_User_Input_Buffer_Default+0x16>
  } else
  { 
    return NULL;
34024154:	2300      	movs	r3, #0
  }
}
34024156:	4618      	mov	r0, r3
34024158:	370c      	adds	r7, #12
3402415a:	46bd      	mov	sp, r7
3402415c:	f85d 7b04 	ldr.w	r7, [sp], #4
34024160:	4770      	bx	lr
34024162:	bf00      	nop
34024164:	3404b138 	.word	0x3404b138

34024168 <LL_ATON_Set_User_Output_Buffer_Default>:

LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_Default(uint32_t num, void* buffer, uint32_t size)
{
34024168:	b480      	push	{r7}
3402416a:	b085      	sub	sp, #20
3402416c:	af00      	add	r7, sp, #0
3402416e:	60f8      	str	r0, [r7, #12]
34024170:	60b9      	str	r1, [r7, #8]
34024172:	607a      	str	r2, [r7, #4]
  if (num == 0) {
34024174:	68fb      	ldr	r3, [r7, #12]
34024176:	2b00      	cmp	r3, #0
34024178:	d112      	bne.n	340241a0 <LL_ATON_Set_User_Output_Buffer_Default+0x38>
    if (((uintptr_t)buffer % 32) != 0)
3402417a:	68bb      	ldr	r3, [r7, #8]
3402417c:	f003 031f 	and.w	r3, r3, #31
34024180:	2b00      	cmp	r3, #0
34024182:	d001      	beq.n	34024188 <LL_ATON_Set_User_Output_Buffer_Default+0x20>
      return LL_ATON_User_IO_WRONG_ALIGN; /* enforce MCU cacheline alignment */
34024184:	2301      	movs	r3, #1
34024186:	e00c      	b.n	340241a2 <LL_ATON_Set_User_Output_Buffer_Default+0x3a>
    if (size < 5880)
34024188:	687b      	ldr	r3, [r7, #4]
3402418a:	f241 62f7 	movw	r2, #5879	@ 0x16f7
3402418e:	4293      	cmp	r3, r2
34024190:	d801      	bhi.n	34024196 <LL_ATON_Set_User_Output_Buffer_Default+0x2e>
      return LL_ATON_User_IO_WRONG_SIZE; /* enforce size needed */
34024192:	2302      	movs	r3, #2
34024194:	e005      	b.n	340241a2 <LL_ATON_Set_User_Output_Buffer_Default+0x3a>
    _mem_pool__user_io_output_0_Default = buffer;
34024196:	4a06      	ldr	r2, [pc, #24]	@ (340241b0 <LL_ATON_Set_User_Output_Buffer_Default+0x48>)
34024198:	68bb      	ldr	r3, [r7, #8]
3402419a:	6013      	str	r3, [r2, #0]
    return LL_ATON_User_IO_NOERROR;
3402419c:	2300      	movs	r3, #0
3402419e:	e000      	b.n	340241a2 <LL_ATON_Set_User_Output_Buffer_Default+0x3a>
  } else
  { 
    return LL_ATON_User_IO_WRONG_INDEX;
340241a0:	2303      	movs	r3, #3
  }
}
340241a2:	4618      	mov	r0, r3
340241a4:	3714      	adds	r7, #20
340241a6:	46bd      	mov	sp, r7
340241a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340241ac:	4770      	bx	lr
340241ae:	bf00      	nop
340241b0:	3404b13c 	.word	0x3404b13c

340241b4 <LL_ATON_Get_User_Output_Buffer_Default>:

void *LL_ATON_Get_User_Output_Buffer_Default(uint32_t num)
{
340241b4:	b480      	push	{r7}
340241b6:	b083      	sub	sp, #12
340241b8:	af00      	add	r7, sp, #0
340241ba:	6078      	str	r0, [r7, #4]
  if (num == 0) {
340241bc:	687b      	ldr	r3, [r7, #4]
340241be:	2b00      	cmp	r3, #0
340241c0:	d102      	bne.n	340241c8 <LL_ATON_Get_User_Output_Buffer_Default+0x14>
    return _mem_pool__user_io_output_0_Default;
340241c2:	4b05      	ldr	r3, [pc, #20]	@ (340241d8 <LL_ATON_Get_User_Output_Buffer_Default+0x24>)
340241c4:	681b      	ldr	r3, [r3, #0]
340241c6:	e000      	b.n	340241ca <LL_ATON_Get_User_Output_Buffer_Default+0x16>
  } else
  { 
    return NULL;
340241c8:	2300      	movs	r3, #0
  }
}
340241ca:	4618      	mov	r0, r3
340241cc:	370c      	adds	r7, #12
340241ce:	46bd      	mov	sp, r7
340241d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340241d4:	4770      	bx	lr
340241d6:	bf00      	nop
340241d8:	3404b13c 	.word	0x3404b13c

340241dc <LL_ATON_Cache_MCU_Clean_Range>:
   *       for both its `address` & `size` (to better correspond to what this operation will actually do)!
   * @note this function is intended to handle the case where a buffer has been filled by the MCU/processor (such
   * passing thru the MCU cache) and should be called AFTER that the buffer has been filled
   */
  static inline void LL_ATON_Cache_MCU_Clean_Range(uintptr_t virtual_addr, uint32_t size)
  {
340241dc:	b580      	push	{r7, lr}
340241de:	b082      	sub	sp, #8
340241e0:	af00      	add	r7, sp, #0
340241e2:	6078      	str	r0, [r7, #4]
340241e4:	6039      	str	r1, [r7, #0]
    LL_ATON_LOCK_MCU_CACHE();
    mcu_cache_clean_range((uintptr_t)((unsigned char *)(virtual_addr + 0)),
                          (uintptr_t)((unsigned char *)(virtual_addr + size)));
340241e6:	687a      	ldr	r2, [r7, #4]
340241e8:	683b      	ldr	r3, [r7, #0]
340241ea:	4413      	add	r3, r2
    mcu_cache_clean_range((uintptr_t)((unsigned char *)(virtual_addr + 0)),
340241ec:	4619      	mov	r1, r3
340241ee:	6878      	ldr	r0, [r7, #4]
340241f0:	f7f4 ffba 	bl	34019168 <mcu_cache_clean_range>
    LL_ATON_UNLOCK_MCU_CACHE();
  }
340241f4:	bf00      	nop
340241f6:	3708      	adds	r7, #8
340241f8:	46bd      	mov	sp, r7
340241fa:	bd80      	pop	{r7, pc}

340241fc <LL_ATON_Cache_NPU_Clean_Invalidate_Range>:
   * @note the NPU cache provides only a "clean & invalidate range" (and not a - pure - "invalidate range") cache
   *       maintenance function which will be called by "stai_ext_cache_npu_clean_invalidate_range()", therefore it is
   *       even more important to call it BEFORE the buffer gets filled
   */
  static inline void LL_ATON_Cache_NPU_Clean_Invalidate_Range(uintptr_t virtual_addr, uint32_t size)
  {
340241fc:	b580      	push	{r7, lr}
340241fe:	b082      	sub	sp, #8
34024200:	af00      	add	r7, sp, #0
34024202:	6078      	str	r0, [r7, #4]
34024204:	6039      	str	r1, [r7, #0]
    /* NOTE: The ATON NPU cache does not provide a pure invalidate-range function, but only a clean-invalidate range
       function! One has to take this into account when using `stai_ext_cache_npu_clean_invalidate_range`. */
    LL_ATON_LOCK_NPU_CACHE();
    npu_cache_clean_invalidate_range(
        __LL_ATON_LIB_VIRTUAL_TO_PHYSICAL_ADDR((uintptr_t)((unsigned char *)(virtual_addr + 0))),
        __LL_ATON_LIB_VIRTUAL_TO_PHYSICAL_ADDR((uintptr_t)((unsigned char *)(virtual_addr + size))));
34024206:	687a      	ldr	r2, [r7, #4]
34024208:	683b      	ldr	r3, [r7, #0]
3402420a:	4413      	add	r3, r2
    npu_cache_clean_invalidate_range(
3402420c:	4619      	mov	r1, r3
3402420e:	6878      	ldr	r0, [r7, #4]
34024210:	f7f5 f80c 	bl	3401922c <npu_cache_clean_invalidate_range>
    LL_ATON_UNLOCK_NPU_CACHE();
  }
34024214:	bf00      	nop
34024216:	3708      	adds	r7, #8
34024218:	46bd      	mov	sp, r7
3402421a:	bd80      	pop	{r7, pc}

3402421c <LL_ATON_EC_Network_Init_Default>:
};


// this function MUST be called ONLY ONCE once for initializing the network
bool LL_ATON_EC_Network_Init_Default(void)
{
3402421c:	b580      	push	{r7, lr}
3402421e:	b082      	sub	sp, #8
34024220:	af00      	add	r7, sp, #0
  memset(_ec_blob_1_prev_base_addrs, 0, 1 * sizeof(ECAddr));
34024222:	4b15      	ldr	r3, [pc, #84]	@ (34024278 <LL_ATON_EC_Network_Init_Default+0x5c>)
34024224:	2200      	movs	r2, #0
34024226:	601a      	str	r2, [r3, #0]

  LL_ATON_Cache_NPU_Clean_Invalidate_Range((uintptr_t)_ec_blob_1, (uint32_t)46328);
34024228:	4b14      	ldr	r3, [pc, #80]	@ (3402427c <LL_ATON_EC_Network_Init_Default+0x60>)
3402422a:	f24b 41f8 	movw	r1, #46328	@ 0xb4f8
3402422e:	4618      	mov	r0, r3
34024230:	f7ff ffe4 	bl	340241fc <LL_ATON_Cache_NPU_Clean_Invalidate_Range>

  unsigned int size;
  size = 11582;
34024234:	f642 533e 	movw	r3, #11582	@ 0x2d3e
34024238:	607b      	str	r3, [r7, #4]

  if (!ec_copy_program((const uint8_t *)_ec_blob_1_reloc, (ECInstr *)_ec_blob_1, &size))
3402423a:	1d3b      	adds	r3, r7, #4
3402423c:	461a      	mov	r2, r3
3402423e:	490f      	ldr	r1, [pc, #60]	@ (3402427c <LL_ATON_EC_Network_Init_Default+0x60>)
34024240:	480f      	ldr	r0, [pc, #60]	@ (34024280 <LL_ATON_EC_Network_Init_Default+0x64>)
34024242:	f7f5 f807 	bl	34019254 <ec_copy_program>
34024246:	4603      	mov	r3, r0
34024248:	f083 0301 	eor.w	r3, r3, #1
3402424c:	b2db      	uxtb	r3, r3
3402424e:	2b00      	cmp	r3, #0
34024250:	d001      	beq.n	34024256 <LL_ATON_EC_Network_Init_Default+0x3a>
  {
    // TODO maybe generate/print error because it was not possible to copy the blob
    return false;
34024252:	2300      	movs	r3, #0
34024254:	e00c      	b.n	34024270 <LL_ATON_EC_Network_Init_Default+0x54>
  }

  _ec_blob_1_reloc_table_ptr = ec_get_reloc_table_ptr((const uint8_t *)_ec_blob_1_reloc);
34024256:	480a      	ldr	r0, [pc, #40]	@ (34024280 <LL_ATON_EC_Network_Init_Default+0x64>)
34024258:	f7f5 f8a2 	bl	340193a0 <ec_get_reloc_table_ptr>
3402425c:	4603      	mov	r3, r0
3402425e:	4a09      	ldr	r2, [pc, #36]	@ (34024284 <LL_ATON_EC_Network_Init_Default+0x68>)
34024260:	6013      	str	r3, [r2, #0]

  LL_ATON_Cache_MCU_Clean_Range((uintptr_t)_ec_blob_1, (uint32_t)46328);
34024262:	4b06      	ldr	r3, [pc, #24]	@ (3402427c <LL_ATON_EC_Network_Init_Default+0x60>)
34024264:	f24b 41f8 	movw	r1, #46328	@ 0xb4f8
34024268:	4618      	mov	r0, r3
3402426a:	f7ff ffb7 	bl	340241dc <LL_ATON_Cache_MCU_Clean_Range>

  return true;
3402426e:	2301      	movs	r3, #1
}
34024270:	4618      	mov	r0, r3
34024272:	3708      	adds	r7, #8
34024274:	46bd      	mov	sp, r7
34024276:	bd80      	pop	{r7, pc}
34024278:	3405663c 	.word	0x3405663c
3402427c:	3404b140 	.word	0x3404b140
34024280:	3402c720 	.word	0x3402c720
34024284:	34056638 	.word	0x34056638

34024288 <LL_ATON_EC_Inference_Init_Default>:

// this function should be called before each inference
bool LL_ATON_EC_Inference_Init_Default(void)
{
34024288:	b580      	push	{r7, lr}
3402428a:	b082      	sub	sp, #8
3402428c:	af02      	add	r7, sp, #8
  LL_ATON_Cache_NPU_Clean_Invalidate_Range((uintptr_t)_ec_blob_1, (uint32_t)46328);
3402428e:	4b12      	ldr	r3, [pc, #72]	@ (340242d8 <LL_ATON_EC_Inference_Init_Default+0x50>)
34024290:	f24b 41f8 	movw	r1, #46328	@ 0xb4f8
34024294:	4618      	mov	r0, r3
34024296:	f7ff ffb1 	bl	340241fc <LL_ATON_Cache_NPU_Clean_Invalidate_Range>

  if (!ec_reloc(_ec_blob_1_reloc_table_ptr, (ECInstr *)_ec_blob_1, _ec_blob_1__user_io_input_0_RELOC_IDX, (ECAddr)(uintptr_t)_ec_blob_1__user_io_input_0_BASE_SYMBOL, _ec_blob_1_prev_base_addrs + _ec_blob_1__user_io_input_0_RELOC_IDX))
3402429a:	4b10      	ldr	r3, [pc, #64]	@ (340242dc <LL_ATON_EC_Inference_Init_Default+0x54>)
3402429c:	6818      	ldr	r0, [r3, #0]
3402429e:	4b10      	ldr	r3, [pc, #64]	@ (340242e0 <LL_ATON_EC_Inference_Init_Default+0x58>)
340242a0:	681b      	ldr	r3, [r3, #0]
340242a2:	461a      	mov	r2, r3
340242a4:	4b0f      	ldr	r3, [pc, #60]	@ (340242e4 <LL_ATON_EC_Inference_Init_Default+0x5c>)
340242a6:	9300      	str	r3, [sp, #0]
340242a8:	4613      	mov	r3, r2
340242aa:	2200      	movs	r2, #0
340242ac:	490a      	ldr	r1, [pc, #40]	@ (340242d8 <LL_ATON_EC_Inference_Init_Default+0x50>)
340242ae:	f7f5 f8a3 	bl	340193f8 <ec_reloc>
340242b2:	4603      	mov	r3, r0
340242b4:	f083 0301 	eor.w	r3, r3, #1
340242b8:	b2db      	uxtb	r3, r3
340242ba:	2b00      	cmp	r3, #0
340242bc:	d001      	beq.n	340242c2 <LL_ATON_EC_Inference_Init_Default+0x3a>
  {
    // TODO maybe generate/print error because it was not possible to relocate the blob
    return false;
340242be:	2300      	movs	r3, #0
340242c0:	e006      	b.n	340242d0 <LL_ATON_EC_Inference_Init_Default+0x48>
  }

  LL_ATON_Cache_MCU_Clean_Range((uintptr_t)_ec_blob_1, (uint32_t)46328);
340242c2:	4b05      	ldr	r3, [pc, #20]	@ (340242d8 <LL_ATON_EC_Inference_Init_Default+0x50>)
340242c4:	f24b 41f8 	movw	r1, #46328	@ 0xb4f8
340242c8:	4618      	mov	r0, r3
340242ca:	f7ff ff87 	bl	340241dc <LL_ATON_Cache_MCU_Clean_Range>

  return true;
340242ce:	2301      	movs	r3, #1
}
340242d0:	4618      	mov	r0, r3
340242d2:	46bd      	mov	sp, r7
340242d4:	bd80      	pop	{r7, pc}
340242d6:	bf00      	nop
340242d8:	3404b140 	.word	0x3404b140
340242dc:	34056638 	.word	0x34056638
340242e0:	3404b138 	.word	0x3404b138
340242e4:	3405663c 	.word	0x3405663c

340242e8 <_ec_blob_cache_start_func_1>:
/* scheduling epoch=0    nodes=49  ------------------------------------------------------------------- */

// Epoch Controller Blob (name='_ec_blob_1') micro instructions needed

// Epoch Controller Blob (name='_ec_blob_1') start function
static void _ec_blob_cache_start_func_1(const void *epoch_block) {
340242e8:	b580      	push	{r7, lr}
340242ea:	b082      	sub	sp, #8
340242ec:	af00      	add	r7, sp, #0
340242ee:	6078      	str	r0, [r7, #4]
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation (HW, whole range) *** */
  /*     memory pool: 7 */
  /*     start: (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34200000UL + 26560) */
  /*     end:   (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34200000UL + 28032) */
  mcu_cache_invalidate_range((uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34200000UL + 26560) /* Equivalent hex address = 0x342067c0UL */, (uintptr_t)__LL_ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(0x34200000UL + 28032) /* Equivalent hex address = 0x34206d80UL */);
340242f0:	4903      	ldr	r1, [pc, #12]	@ (34024300 <_ec_blob_cache_start_func_1+0x18>)
340242f2:	4804      	ldr	r0, [pc, #16]	@ (34024304 <_ec_blob_cache_start_func_1+0x1c>)
340242f4:	f7f4 fef6 	bl	340190e4 <mcu_cache_invalidate_range>
#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)

  // Un-lock MCU cache
  LL_ATON_UNLOCK_MCU_CACHE();

};
340242f8:	bf00      	nop
340242fa:	3708      	adds	r7, #8
340242fc:	46bd      	mov	sp, r7
340242fe:	bd80      	pop	{r7, pc}
34024300:	34206d80 	.word	0x34206d80
34024304:	342067c0 	.word	0x342067c0

34024308 <LL_ATON_End_EpochBlock_20>:


/* scheduling epoch=20   nodes=1   ------------------------------------------------------------------- */

static void LL_ATON_End_EpochBlock_20(const void *epoch_block)
{
34024308:	b580      	push	{r7, lr}
3402430a:	b0b0      	sub	sp, #192	@ 0xc0
3402430c:	af00      	add	r7, sp, #0
3402430e:	6078      	str	r0, [r7, #4]
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache invalidate (only) operation for unaligned buffer end address (last line) *** */
  /*     memory pool: 9 */
  /*     start: (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5856) */
  /*     end:   (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5888) */
  mcu_cache_invalidate_range((uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5856) /* Equivalent hex offset = 0x16e0 */, (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5888) /* Equivalent hex offset = 0x1700 */);
34024310:	4b36      	ldr	r3, [pc, #216]	@ (340243ec <LL_ATON_End_EpochBlock_20+0xe4>)
34024312:	681b      	ldr	r3, [r3, #0]
34024314:	f503 53b7 	add.w	r3, r3, #5856	@ 0x16e0
34024318:	4a34      	ldr	r2, [pc, #208]	@ (340243ec <LL_ATON_End_EpochBlock_20+0xe4>)
3402431a:	6812      	ldr	r2, [r2, #0]
3402431c:	f502 52b8 	add.w	r2, r2, #5888	@ 0x1700
34024320:	4611      	mov	r1, r2
34024322:	4618      	mov	r0, r3
34024324:	f7f4 fede 	bl	340190e4 <mcu_cache_invalidate_range>
  LL_ATON_LIB_UNUSED(epoch_block);


/* Unit= 27 [PROCESSOR 0] */
/* kind=DequantizeLinear node=Dequantize_54 */
  Dequantizelinear_sw_info dequantizelinear1_sw_info = {
34024328:	f107 030c 	add.w	r3, r7, #12
3402432c:	22b4      	movs	r2, #180	@ 0xb4
3402432e:	2100      	movs	r1, #0
34024330:	4618      	mov	r0, r3
34024332:	f002 ff2f 	bl	34027194 <memset>
34024336:	232a      	movs	r3, #42	@ 0x2a
34024338:	733b      	strb	r3, [r7, #12]
3402433a:	2307      	movs	r3, #7
3402433c:	613b      	str	r3, [r7, #16]
3402433e:	2307      	movs	r3, #7
34024340:	617b      	str	r3, [r7, #20]
34024342:	231e      	movs	r3, #30
34024344:	61bb      	str	r3, [r7, #24]
34024346:	2301      	movs	r3, #1
34024348:	61fb      	str	r3, [r7, #28]
3402434a:	f240 53be 	movw	r3, #1470	@ 0x5be
3402434e:	623b      	str	r3, [r7, #32]
34024350:	23d2      	movs	r3, #210	@ 0xd2
34024352:	627b      	str	r3, [r7, #36]	@ 0x24
34024354:	231e      	movs	r3, #30
34024356:	62bb      	str	r3, [r7, #40]	@ 0x28
34024358:	2301      	movs	r3, #1
3402435a:	62fb      	str	r3, [r7, #44]	@ 0x2c
3402435c:	f240 53be 	movw	r3, #1470	@ 0x5be
34024360:	633b      	str	r3, [r7, #48]	@ 0x30
34024362:	4b23      	ldr	r3, [pc, #140]	@ (340243f0 <LL_ATON_End_EpochBlock_20+0xe8>)
34024364:	637b      	str	r3, [r7, #52]	@ 0x34
34024366:	2301      	movs	r3, #1
34024368:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
3402436c:	2307      	movs	r3, #7
3402436e:	63fb      	str	r3, [r7, #60]	@ 0x3c
34024370:	2307      	movs	r3, #7
34024372:	643b      	str	r3, [r7, #64]	@ 0x40
34024374:	231e      	movs	r3, #30
34024376:	647b      	str	r3, [r7, #68]	@ 0x44
34024378:	2301      	movs	r3, #1
3402437a:	64bb      	str	r3, [r7, #72]	@ 0x48
3402437c:	f240 53be 	movw	r3, #1470	@ 0x5be
34024380:	64fb      	str	r3, [r7, #76]	@ 0x4c
34024382:	f44f 7352 	mov.w	r3, #840	@ 0x348
34024386:	653b      	str	r3, [r7, #80]	@ 0x50
34024388:	2378      	movs	r3, #120	@ 0x78
3402438a:	657b      	str	r3, [r7, #84]	@ 0x54
3402438c:	2304      	movs	r3, #4
3402438e:	65bb      	str	r3, [r7, #88]	@ 0x58
34024390:	f241 63f8 	movw	r3, #5880	@ 0x16f8
34024394:	65fb      	str	r3, [r7, #92]	@ 0x5c
34024396:	4b15      	ldr	r3, [pc, #84]	@ (340243ec <LL_ATON_End_EpochBlock_20+0xe4>)
34024398:	681b      	ldr	r3, [r3, #0]
3402439a:	663b      	str	r3, [r7, #96]	@ 0x60
3402439c:	2301      	movs	r3, #1
3402439e:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
340243a2:	2301      	movs	r3, #1
340243a4:	67bb      	str	r3, [r7, #120]	@ 0x78
340243a6:	4b13      	ldr	r3, [pc, #76]	@ (340243f4 <LL_ATON_End_EpochBlock_20+0xec>)
340243a8:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
340243ac:	2301      	movs	r3, #1
340243ae:	f887 3090 	strb.w	r3, [r7, #144]	@ 0x90
340243b2:	2301      	movs	r3, #1
340243b4:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
340243b8:	4b0f      	ldr	r3, [pc, #60]	@ (340243f8 <LL_ATON_End_EpochBlock_20+0xf0>)
340243ba:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
340243be:	2301      	movs	r3, #1
340243c0:	f887 30bc 	strb.w	r3, [r7, #188]	@ 0xbc
    .general.type = LL_SW_DEQUANTIZELINEAR,
  };

  /* Low Level SW Layer function invocation. This will exploit EmbedNets libs) */
  /* Node Dequantize_54 mapped on EmbedNets (INTEGER) as DequantizeLinear | Category: Format-Converter */
  ll_sw_forward_dequantizelinear(&dequantizelinear1_sw_info);
340243c4:	f107 030c 	add.w	r3, r7, #12
340243c8:	4618      	mov	r0, r3
340243ca:	f7f7 f89b 	bl	3401b504 <ll_sw_forward_dequantizelinear>
#if (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)
  /* *** MCU cache clean (only) operation (SW, whole range) *** */
  /*     memory pool: 9 */
  /*     start: (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 0) */
  /*     end:   (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5888) */
  mcu_cache_clean_range((uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 0) /* Equivalent hex offset = 0x0 */, (uintptr_t)((uintptr_t)(_mem_pool__user_io_output_0_Default) + 5888) /* Equivalent hex offset = 0x1700 */);
340243ce:	4b07      	ldr	r3, [pc, #28]	@ (340243ec <LL_ATON_End_EpochBlock_20+0xe4>)
340243d0:	681b      	ldr	r3, [r3, #0]
340243d2:	461a      	mov	r2, r3
340243d4:	4b05      	ldr	r3, [pc, #20]	@ (340243ec <LL_ATON_End_EpochBlock_20+0xe4>)
340243d6:	681b      	ldr	r3, [r3, #0]
340243d8:	f503 53b8 	add.w	r3, r3, #5888	@ 0x1700
340243dc:	4619      	mov	r1, r3
340243de:	4610      	mov	r0, r2
340243e0:	f7f4 fec2 	bl	34019168 <mcu_cache_clean_range>
#endif // (LL_ATON_PLATFORM == LL_ATON_PLAT_STM32N6)

  // Un-lock MCU cache
  LL_ATON_UNLOCK_MCU_CACHE();

}
340243e4:	bf00      	nop
340243e6:	37c0      	adds	r7, #192	@ 0xc0
340243e8:	46bd      	mov	sp, r7
340243ea:	bd80      	pop	{r7, pc}
340243ec:	3404b13c 	.word	0x3404b13c
340243f0:	342067c0 	.word	0x342067c0
340243f4:	70c8d3e0 	.word	0x70c8d3e0
340243f8:	70c8d410 	.word	0x70c8d410

340243fc <LL_ATON_EpochBlockItems_Default>:
// Epoch Controller Blob (name='_ec_blob_21') micro instructions needed


/* scheduling DONE                 ------------------------------------------------------------------- */

const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_Default(void) {
340243fc:	b480      	push	{r7}
340243fe:	af00      	add	r7, sp, #0
      .flags = EpochBlock_Flags_last_eb,
    },
  };


  return ll_atonn_rt_epoch_block_array;
34024400:	4b02      	ldr	r3, [pc, #8]	@ (3402440c <LL_ATON_EpochBlockItems_Default+0x10>)
}
34024402:	4618      	mov	r0, r3
34024404:	46bd      	mov	sp, r7
34024406:	f85d 7b04 	ldr.w	r7, [sp], #4
3402440a:	4770      	bx	lr
3402440c:	34037c70 	.word	0x34037c70

34024410 <LL_ATON_Input_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_Default(void)
{
34024410:	b480      	push	{r7}
34024412:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
34024414:	4b02      	ldr	r3, [pc, #8]	@ (34024420 <LL_ATON_Input_Buffers_Info_Default+0x10>)
}
34024416:	4618      	mov	r0, r3
34024418:	46bd      	mov	sp, r7
3402441a:	f85d 7b04 	ldr.w	r7, [sp], #4
3402441e:	4770      	bx	lr
34024420:	34037cc0 	.word	0x34037cc0

34024424 <LL_ATON_Output_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_Default(void)
{
34024424:	b480      	push	{r7}
34024426:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
34024428:	4b02      	ldr	r3, [pc, #8]	@ (34024434 <LL_ATON_Output_Buffers_Info_Default+0x10>)
}
3402442a:	4618      	mov	r0, r3
3402442c:	46bd      	mov	sp, r7
3402442e:	f85d 7b04 	ldr.w	r7, [sp], #4
34024432:	4770      	bx	lr
34024434:	3403c710 	.word	0x3403c710

34024438 <LL_ATON_Internal_Buffers_Info_Default>:

const LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_Default(void)
{
34024438:	b480      	push	{r7}
3402443a:	af00      	add	r7, sp, #0
    {
      .name = NULL,
    }
  };

  return buff_info;
3402443c:	4b02      	ldr	r3, [pc, #8]	@ (34024448 <LL_ATON_Internal_Buffers_Info_Default+0x10>)
}
3402443e:	4618      	mov	r0, r3
34024440:	46bd      	mov	sp, r7
34024442:	f85d 7b04 	ldr.w	r7, [sp], #4
34024446:	4770      	bx	lr
34024448:	3403c7a0 	.word	0x3403c7a0

3402444c <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
3402444c:	b580      	push	{r7, lr}
3402444e:	b082      	sub	sp, #8
34024450:	af00      	add	r7, sp, #0
34024452:	6078      	str	r0, [r7, #4]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
34024454:	687b      	ldr	r3, [r7, #4]
34024456:	681b      	ldr	r3, [r3, #0]
34024458:	4a22      	ldr	r2, [pc, #136]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
3402445a:	6013      	str	r3, [r2, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
3402445c:	687b      	ldr	r3, [r7, #4]
3402445e:	685b      	ldr	r3, [r3, #4]
34024460:	4a20      	ldr	r2, [pc, #128]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
34024462:	6053      	str	r3, [r2, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
34024464:	687b      	ldr	r3, [r7, #4]
34024466:	689b      	ldr	r3, [r3, #8]
34024468:	4a1e      	ldr	r2, [pc, #120]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
3402446a:	6093      	str	r3, [r2, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
3402446c:	687b      	ldr	r3, [r7, #4]
3402446e:	68db      	ldr	r3, [r3, #12]
34024470:	4a1c      	ldr	r2, [pc, #112]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
34024472:	60d3      	str	r3, [r2, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
34024474:	687b      	ldr	r3, [r7, #4]
34024476:	691b      	ldr	r3, [r3, #16]
34024478:	4a1a      	ldr	r2, [pc, #104]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
3402447a:	6113      	str	r3, [r2, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
3402447c:	687b      	ldr	r3, [r7, #4]
3402447e:	695b      	ldr	r3, [r3, #20]
34024480:	4a18      	ldr	r2, [pc, #96]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
34024482:	6153      	str	r3, [r2, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
34024484:	687b      	ldr	r3, [r7, #4]
34024486:	699b      	ldr	r3, [r3, #24]
34024488:	4a16      	ldr	r2, [pc, #88]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
3402448a:	6193      	str	r3, [r2, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
3402448c:	687b      	ldr	r3, [r7, #4]
3402448e:	69db      	ldr	r3, [r3, #28]
34024490:	4a14      	ldr	r2, [pc, #80]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
34024492:	61d3      	str	r3, [r2, #28]
  FuncDriver.GetYSize       = pDrv->GetYSize;
34024494:	687b      	ldr	r3, [r7, #4]
34024496:	6a1b      	ldr	r3, [r3, #32]
34024498:	4a12      	ldr	r2, [pc, #72]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
3402449a:	6213      	str	r3, [r2, #32]
  FuncDriver.SetLayer       = pDrv->SetLayer;
3402449c:	687b      	ldr	r3, [r7, #4]
3402449e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340244a0:	4a10      	ldr	r2, [pc, #64]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
340244a2:	6253      	str	r3, [r2, #36]	@ 0x24
  FuncDriver.GetFormat      = pDrv->GetFormat;
340244a4:	687b      	ldr	r3, [r7, #4]
340244a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340244a8:	4a0e      	ldr	r2, [pc, #56]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
340244aa:	6293      	str	r3, [r2, #40]	@ 0x28

  DrawProp->LcdLayer = 0;
340244ac:	4b0e      	ldr	r3, [pc, #56]	@ (340244e8 <UTIL_LCD_SetFuncDriver+0x9c>)
340244ae:	2200      	movs	r2, #0
340244b0:	60da      	str	r2, [r3, #12]
  DrawProp->LcdDevice = 0;
340244b2:	4b0d      	ldr	r3, [pc, #52]	@ (340244e8 <UTIL_LCD_SetFuncDriver+0x9c>)
340244b4:	2200      	movs	r2, #0
340244b6:	611a      	str	r2, [r3, #16]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
340244b8:	4b0a      	ldr	r3, [pc, #40]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
340244ba:	69db      	ldr	r3, [r3, #28]
340244bc:	4a0b      	ldr	r2, [pc, #44]	@ (340244ec <UTIL_LCD_SetFuncDriver+0xa0>)
340244be:	4611      	mov	r1, r2
340244c0:	2000      	movs	r0, #0
340244c2:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
340244c4:	4b07      	ldr	r3, [pc, #28]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
340244c6:	6a1b      	ldr	r3, [r3, #32]
340244c8:	4a09      	ldr	r2, [pc, #36]	@ (340244f0 <UTIL_LCD_SetFuncDriver+0xa4>)
340244ca:	4611      	mov	r1, r2
340244cc:	2000      	movs	r0, #0
340244ce:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
340244d0:	4b04      	ldr	r3, [pc, #16]	@ (340244e4 <UTIL_LCD_SetFuncDriver+0x98>)
340244d2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
340244d4:	4a07      	ldr	r2, [pc, #28]	@ (340244f4 <UTIL_LCD_SetFuncDriver+0xa8>)
340244d6:	4611      	mov	r1, r2
340244d8:	2000      	movs	r0, #0
340244da:	4798      	blx	r3
}
340244dc:	bf00      	nop
340244de:	3708      	adds	r7, #8
340244e0:	46bd      	mov	sp, r7
340244e2:	bd80      	pop	{r7, pc}
340244e4:	34056680 	.word	0x34056680
340244e8:	34056640 	.word	0x34056640
340244ec:	34056654 	.word	0x34056654
340244f0:	34056658 	.word	0x34056658
340244f4:	3405665c 	.word	0x3405665c

340244f8 <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
340244f8:	b580      	push	{r7, lr}
340244fa:	b082      	sub	sp, #8
340244fc:	af00      	add	r7, sp, #0
340244fe:	6078      	str	r0, [r7, #4]
  if(FuncDriver.SetLayer != NULL)
34024500:	4b1d      	ldr	r3, [pc, #116]	@ (34024578 <UTIL_LCD_SetLayer+0x80>)
34024502:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34024504:	2b00      	cmp	r3, #0
34024506:	d032      	beq.n	3402456e <UTIL_LCD_SetLayer+0x76>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
34024508:	4b1b      	ldr	r3, [pc, #108]	@ (34024578 <UTIL_LCD_SetLayer+0x80>)
3402450a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3402450c:	4a1b      	ldr	r2, [pc, #108]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402450e:	6912      	ldr	r2, [r2, #16]
34024510:	6879      	ldr	r1, [r7, #4]
34024512:	4610      	mov	r0, r2
34024514:	4798      	blx	r3
34024516:	4603      	mov	r3, r0
34024518:	2b00      	cmp	r3, #0
3402451a:	d128      	bne.n	3402456e <UTIL_LCD_SetLayer+0x76>
    {
      DrawProp->LcdLayer = Layer;
3402451c:	4a17      	ldr	r2, [pc, #92]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402451e:	687b      	ldr	r3, [r7, #4]
34024520:	60d3      	str	r3, [r2, #12]
      FuncDriver.GetXSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdXsize);
34024522:	4b15      	ldr	r3, [pc, #84]	@ (34024578 <UTIL_LCD_SetLayer+0x80>)
34024524:	69db      	ldr	r3, [r3, #28]
34024526:	4a15      	ldr	r2, [pc, #84]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
34024528:	6910      	ldr	r0, [r2, #16]
3402452a:	4a14      	ldr	r2, [pc, #80]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402452c:	68d2      	ldr	r2, [r2, #12]
3402452e:	0152      	lsls	r2, r2, #5
34024530:	3210      	adds	r2, #16
34024532:	4912      	ldr	r1, [pc, #72]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
34024534:	440a      	add	r2, r1
34024536:	3204      	adds	r2, #4
34024538:	4611      	mov	r1, r2
3402453a:	4798      	blx	r3
      FuncDriver.GetYSize(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdYsize);
3402453c:	4b0e      	ldr	r3, [pc, #56]	@ (34024578 <UTIL_LCD_SetLayer+0x80>)
3402453e:	6a1b      	ldr	r3, [r3, #32]
34024540:	4a0e      	ldr	r2, [pc, #56]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
34024542:	6910      	ldr	r0, [r2, #16]
34024544:	4a0d      	ldr	r2, [pc, #52]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
34024546:	68d2      	ldr	r2, [r2, #12]
34024548:	0152      	lsls	r2, r2, #5
3402454a:	3218      	adds	r2, #24
3402454c:	490b      	ldr	r1, [pc, #44]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402454e:	440a      	add	r2, r1
34024550:	4611      	mov	r1, r2
34024552:	4798      	blx	r3
      FuncDriver.GetFormat(DrawProp->LcdDevice, &DrawProp[DrawProp->LcdLayer].LcdPixelFormat);
34024554:	4b08      	ldr	r3, [pc, #32]	@ (34024578 <UTIL_LCD_SetLayer+0x80>)
34024556:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34024558:	4a08      	ldr	r2, [pc, #32]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402455a:	6910      	ldr	r0, [r2, #16]
3402455c:	4a07      	ldr	r2, [pc, #28]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
3402455e:	68d2      	ldr	r2, [r2, #12]
34024560:	0152      	lsls	r2, r2, #5
34024562:	3218      	adds	r2, #24
34024564:	4905      	ldr	r1, [pc, #20]	@ (3402457c <UTIL_LCD_SetLayer+0x84>)
34024566:	440a      	add	r2, r1
34024568:	3204      	adds	r2, #4
3402456a:	4611      	mov	r1, r2
3402456c:	4798      	blx	r3
    }
  }
}
3402456e:	bf00      	nop
34024570:	3708      	adds	r7, #8
34024572:	46bd      	mov	sp, r7
34024574:	bd80      	pop	{r7, pc}
34024576:	bf00      	nop
34024578:	34056680 	.word	0x34056680
3402457c:	34056640 	.word	0x34056640

34024580 <UTIL_LCD_SetTextColor>:
/**
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
34024580:	b480      	push	{r7}
34024582:	b083      	sub	sp, #12
34024584:	af00      	add	r7, sp, #0
34024586:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
34024588:	4b06      	ldr	r3, [pc, #24]	@ (340245a4 <UTIL_LCD_SetTextColor+0x24>)
3402458a:	68db      	ldr	r3, [r3, #12]
3402458c:	4a05      	ldr	r2, [pc, #20]	@ (340245a4 <UTIL_LCD_SetTextColor+0x24>)
3402458e:	015b      	lsls	r3, r3, #5
34024590:	4413      	add	r3, r2
34024592:	687a      	ldr	r2, [r7, #4]
34024594:	601a      	str	r2, [r3, #0]
}
34024596:	bf00      	nop
34024598:	370c      	adds	r7, #12
3402459a:	46bd      	mov	sp, r7
3402459c:	f85d 7b04 	ldr.w	r7, [sp], #4
340245a0:	4770      	bx	lr
340245a2:	bf00      	nop
340245a4:	34056640 	.word	0x34056640

340245a8 <UTIL_LCD_SetFont>:
/**
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
340245a8:	b480      	push	{r7}
340245aa:	b083      	sub	sp, #12
340245ac:	af00      	add	r7, sp, #0
340245ae:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
340245b0:	4b06      	ldr	r3, [pc, #24]	@ (340245cc <UTIL_LCD_SetFont+0x24>)
340245b2:	68db      	ldr	r3, [r3, #12]
340245b4:	4a05      	ldr	r2, [pc, #20]	@ (340245cc <UTIL_LCD_SetFont+0x24>)
340245b6:	015b      	lsls	r3, r3, #5
340245b8:	4413      	add	r3, r2
340245ba:	3308      	adds	r3, #8
340245bc:	687a      	ldr	r2, [r7, #4]
340245be:	601a      	str	r2, [r3, #0]
}
340245c0:	bf00      	nop
340245c2:	370c      	adds	r7, #12
340245c4:	46bd      	mov	sp, r7
340245c6:	f85d 7b04 	ldr.w	r7, [sp], #4
340245ca:	4770      	bx	lr
340245cc:	34056640 	.word	0x34056640

340245d0 <UTIL_LCD_GetFont>:
/**
  * @brief  Gets the LCD text font.
  * @retval Used layer font
  */
sFONT *UTIL_LCD_GetFont(void)
{
340245d0:	b480      	push	{r7}
340245d2:	af00      	add	r7, sp, #0
  return DrawProp[DrawProp->LcdLayer].pFont;
340245d4:	4b05      	ldr	r3, [pc, #20]	@ (340245ec <UTIL_LCD_GetFont+0x1c>)
340245d6:	68db      	ldr	r3, [r3, #12]
340245d8:	4a04      	ldr	r2, [pc, #16]	@ (340245ec <UTIL_LCD_GetFont+0x1c>)
340245da:	015b      	lsls	r3, r3, #5
340245dc:	4413      	add	r3, r2
340245de:	3308      	adds	r3, #8
340245e0:	681b      	ldr	r3, [r3, #0]
}
340245e2:	4618      	mov	r0, r3
340245e4:	46bd      	mov	sp, r7
340245e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340245ea:	4770      	bx	lr
340245ec:	34056640 	.word	0x34056640

340245f0 <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
340245f0:	b590      	push	{r4, r7, lr}
340245f2:	b087      	sub	sp, #28
340245f4:	af02      	add	r7, sp, #8
340245f6:	60f8      	str	r0, [r7, #12]
340245f8:	60b9      	str	r1, [r7, #8]
340245fa:	607a      	str	r2, [r7, #4]
340245fc:	603b      	str	r3, [r7, #0]
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
340245fe:	4b08      	ldr	r3, [pc, #32]	@ (34024620 <UTIL_LCD_FillRGBRect+0x30>)
34024600:	685c      	ldr	r4, [r3, #4]
34024602:	4b08      	ldr	r3, [pc, #32]	@ (34024624 <UTIL_LCD_FillRGBRect+0x34>)
34024604:	6918      	ldr	r0, [r3, #16]
34024606:	6a3b      	ldr	r3, [r7, #32]
34024608:	9301      	str	r3, [sp, #4]
3402460a:	683b      	ldr	r3, [r7, #0]
3402460c:	9300      	str	r3, [sp, #0]
3402460e:	687b      	ldr	r3, [r7, #4]
34024610:	68ba      	ldr	r2, [r7, #8]
34024612:	68f9      	ldr	r1, [r7, #12]
34024614:	47a0      	blx	r4
}
34024616:	bf00      	nop
34024618:	3714      	adds	r7, #20
3402461a:	46bd      	mov	sp, r7
3402461c:	bd90      	pop	{r4, r7, pc}
3402461e:	bf00      	nop
34024620:	34056680 	.word	0x34056680
34024624:	34056640 	.word	0x34056640

34024628 <UTIL_LCD_DrawHLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawHLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
34024628:	b590      	push	{r4, r7, lr}
3402462a:	b087      	sub	sp, #28
3402462c:	af02      	add	r7, sp, #8
3402462e:	60f8      	str	r0, [r7, #12]
34024630:	60b9      	str	r1, [r7, #8]
34024632:	607a      	str	r2, [r7, #4]
34024634:	603b      	str	r3, [r7, #0]
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34024636:	4b33      	ldr	r3, [pc, #204]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
34024638:	68db      	ldr	r3, [r3, #12]
3402463a:	4a32      	ldr	r2, [pc, #200]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
3402463c:	015b      	lsls	r3, r3, #5
3402463e:	4413      	add	r3, r2
34024640:	331c      	adds	r3, #28
34024642:	681b      	ldr	r3, [r3, #0]
34024644:	2b02      	cmp	r3, #2
34024646:	d118      	bne.n	3402467a <UTIL_LCD_DrawHLine+0x52>
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
34024648:	4b2f      	ldr	r3, [pc, #188]	@ (34024708 <UTIL_LCD_DrawHLine+0xe0>)
3402464a:	689c      	ldr	r4, [r3, #8]
3402464c:	4b2d      	ldr	r3, [pc, #180]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
3402464e:	6918      	ldr	r0, [r3, #16]
34024650:	683b      	ldr	r3, [r7, #0]
34024652:	08db      	lsrs	r3, r3, #3
34024654:	f003 021f 	and.w	r2, r3, #31
34024658:	683b      	ldr	r3, [r7, #0]
3402465a:	0a9b      	lsrs	r3, r3, #10
3402465c:	015b      	lsls	r3, r3, #5
3402465e:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34024662:	431a      	orrs	r2, r3
34024664:	683b      	ldr	r3, [r7, #0]
34024666:	0cdb      	lsrs	r3, r3, #19
34024668:	02db      	lsls	r3, r3, #11
3402466a:	b29b      	uxth	r3, r3
3402466c:	4313      	orrs	r3, r2
3402466e:	9300      	str	r3, [sp, #0]
34024670:	687b      	ldr	r3, [r7, #4]
34024672:	68ba      	ldr	r2, [r7, #8]
34024674:	68f9      	ldr	r1, [r7, #12]
34024676:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
  }
}
34024678:	e040      	b.n	340246fc <UTIL_LCD_DrawHLine+0xd4>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3402467a:	4b22      	ldr	r3, [pc, #136]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
3402467c:	69db      	ldr	r3, [r3, #28]
3402467e:	2b01      	cmp	r3, #1
34024680:	d10c      	bne.n	3402469c <UTIL_LCD_DrawHLine+0x74>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
34024682:	4b21      	ldr	r3, [pc, #132]	@ (34024708 <UTIL_LCD_DrawHLine+0xe0>)
34024684:	689c      	ldr	r4, [r3, #8]
34024686:	4b1f      	ldr	r3, [pc, #124]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
34024688:	6918      	ldr	r0, [r3, #16]
3402468a:	683b      	ldr	r3, [r7, #0]
3402468c:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34024690:	9300      	str	r3, [sp, #0]
34024692:	687b      	ldr	r3, [r7, #4]
34024694:	68ba      	ldr	r2, [r7, #8]
34024696:	68f9      	ldr	r1, [r7, #12]
34024698:	47a0      	blx	r4
}
3402469a:	e02f      	b.n	340246fc <UTIL_LCD_DrawHLine+0xd4>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
3402469c:	4b19      	ldr	r3, [pc, #100]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
3402469e:	68db      	ldr	r3, [r3, #12]
340246a0:	4a18      	ldr	r2, [pc, #96]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
340246a2:	015b      	lsls	r3, r3, #5
340246a4:	4413      	add	r3, r2
340246a6:	331c      	adds	r3, #28
340246a8:	681b      	ldr	r3, [r3, #0]
340246aa:	2b04      	cmp	r3, #4
340246ac:	d11c      	bne.n	340246e8 <UTIL_LCD_DrawHLine+0xc0>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
340246ae:	4b16      	ldr	r3, [pc, #88]	@ (34024708 <UTIL_LCD_DrawHLine+0xe0>)
340246b0:	689c      	ldr	r4, [r3, #8]
340246b2:	4b14      	ldr	r3, [pc, #80]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
340246b4:	6918      	ldr	r0, [r3, #16]
340246b6:	683b      	ldr	r3, [r7, #0]
340246b8:	091b      	lsrs	r3, r3, #4
340246ba:	f003 020f 	and.w	r2, r3, #15
340246be:	683b      	ldr	r3, [r7, #0]
340246c0:	0b1b      	lsrs	r3, r3, #12
340246c2:	011b      	lsls	r3, r3, #4
340246c4:	b2db      	uxtb	r3, r3
340246c6:	431a      	orrs	r2, r3
340246c8:	683b      	ldr	r3, [r7, #0]
340246ca:	0d1b      	lsrs	r3, r3, #20
340246cc:	021b      	lsls	r3, r3, #8
340246ce:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340246d2:	431a      	orrs	r2, r3
340246d4:	683b      	ldr	r3, [r7, #0]
340246d6:	0f1b      	lsrs	r3, r3, #28
340246d8:	031b      	lsls	r3, r3, #12
340246da:	4313      	orrs	r3, r2
340246dc:	9300      	str	r3, [sp, #0]
340246de:	687b      	ldr	r3, [r7, #4]
340246e0:	68ba      	ldr	r2, [r7, #8]
340246e2:	68f9      	ldr	r1, [r7, #12]
340246e4:	47a0      	blx	r4
}
340246e6:	e009      	b.n	340246fc <UTIL_LCD_DrawHLine+0xd4>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340246e8:	4b07      	ldr	r3, [pc, #28]	@ (34024708 <UTIL_LCD_DrawHLine+0xe0>)
340246ea:	689c      	ldr	r4, [r3, #8]
340246ec:	4b05      	ldr	r3, [pc, #20]	@ (34024704 <UTIL_LCD_DrawHLine+0xdc>)
340246ee:	6918      	ldr	r0, [r3, #16]
340246f0:	683b      	ldr	r3, [r7, #0]
340246f2:	9300      	str	r3, [sp, #0]
340246f4:	687b      	ldr	r3, [r7, #4]
340246f6:	68ba      	ldr	r2, [r7, #8]
340246f8:	68f9      	ldr	r1, [r7, #12]
340246fa:	47a0      	blx	r4
}
340246fc:	bf00      	nop
340246fe:	3714      	adds	r7, #20
34024700:	46bd      	mov	sp, r7
34024702:	bd90      	pop	{r4, r7, pc}
34024704:	34056640 	.word	0x34056640
34024708:	34056680 	.word	0x34056680

3402470c <UTIL_LCD_DrawVLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawVLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
3402470c:	b590      	push	{r4, r7, lr}
3402470e:	b087      	sub	sp, #28
34024710:	af02      	add	r7, sp, #8
34024712:	60f8      	str	r0, [r7, #12]
34024714:	60b9      	str	r1, [r7, #8]
34024716:	607a      	str	r2, [r7, #4]
34024718:	603b      	str	r3, [r7, #0]
  /* Write line */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
3402471a:	4b33      	ldr	r3, [pc, #204]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
3402471c:	68db      	ldr	r3, [r3, #12]
3402471e:	4a32      	ldr	r2, [pc, #200]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024720:	015b      	lsls	r3, r3, #5
34024722:	4413      	add	r3, r2
34024724:	331c      	adds	r3, #28
34024726:	681b      	ldr	r3, [r3, #0]
34024728:	2b02      	cmp	r3, #2
3402472a:	d118      	bne.n	3402475e <UTIL_LCD_DrawVLine+0x52>
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
3402472c:	4b2f      	ldr	r3, [pc, #188]	@ (340247ec <UTIL_LCD_DrawVLine+0xe0>)
3402472e:	68dc      	ldr	r4, [r3, #12]
34024730:	4b2d      	ldr	r3, [pc, #180]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024732:	6918      	ldr	r0, [r3, #16]
34024734:	683b      	ldr	r3, [r7, #0]
34024736:	08db      	lsrs	r3, r3, #3
34024738:	f003 021f 	and.w	r2, r3, #31
3402473c:	683b      	ldr	r3, [r7, #0]
3402473e:	0a9b      	lsrs	r3, r3, #10
34024740:	015b      	lsls	r3, r3, #5
34024742:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34024746:	431a      	orrs	r2, r3
34024748:	683b      	ldr	r3, [r7, #0]
3402474a:	0cdb      	lsrs	r3, r3, #19
3402474c:	02db      	lsls	r3, r3, #11
3402474e:	b29b      	uxth	r3, r3
34024750:	4313      	orrs	r3, r2
34024752:	9300      	str	r3, [sp, #0]
34024754:	687b      	ldr	r3, [r7, #4]
34024756:	68ba      	ldr	r2, [r7, #8]
34024758:	68f9      	ldr	r1, [r7, #12]
3402475a:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB888*/
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
  }
}
3402475c:	e040      	b.n	340247e0 <UTIL_LCD_DrawVLine+0xd4>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
3402475e:	4b22      	ldr	r3, [pc, #136]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024760:	69db      	ldr	r3, [r3, #28]
34024762:	2b01      	cmp	r3, #1
34024764:	d10c      	bne.n	34024780 <UTIL_LCD_DrawVLine+0x74>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB888(Color));
34024766:	4b21      	ldr	r3, [pc, #132]	@ (340247ec <UTIL_LCD_DrawVLine+0xe0>)
34024768:	68dc      	ldr	r4, [r3, #12]
3402476a:	4b1f      	ldr	r3, [pc, #124]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
3402476c:	6918      	ldr	r0, [r3, #16]
3402476e:	683b      	ldr	r3, [r7, #0]
34024770:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34024774:	9300      	str	r3, [sp, #0]
34024776:	687b      	ldr	r3, [r7, #4]
34024778:	68ba      	ldr	r2, [r7, #8]
3402477a:	68f9      	ldr	r1, [r7, #12]
3402477c:	47a0      	blx	r4
}
3402477e:	e02f      	b.n	340247e0 <UTIL_LCD_DrawVLine+0xd4>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34024780:	4b19      	ldr	r3, [pc, #100]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024782:	68db      	ldr	r3, [r3, #12]
34024784:	4a18      	ldr	r2, [pc, #96]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024786:	015b      	lsls	r3, r3, #5
34024788:	4413      	add	r3, r2
3402478a:	331c      	adds	r3, #28
3402478c:	681b      	ldr	r3, [r3, #0]
3402478e:	2b04      	cmp	r3, #4
34024790:	d11c      	bne.n	340247cc <UTIL_LCD_DrawVLine+0xc0>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882ARGB4444(Color));
34024792:	4b16      	ldr	r3, [pc, #88]	@ (340247ec <UTIL_LCD_DrawVLine+0xe0>)
34024794:	68dc      	ldr	r4, [r3, #12]
34024796:	4b14      	ldr	r3, [pc, #80]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
34024798:	6918      	ldr	r0, [r3, #16]
3402479a:	683b      	ldr	r3, [r7, #0]
3402479c:	091b      	lsrs	r3, r3, #4
3402479e:	f003 020f 	and.w	r2, r3, #15
340247a2:	683b      	ldr	r3, [r7, #0]
340247a4:	0b1b      	lsrs	r3, r3, #12
340247a6:	011b      	lsls	r3, r3, #4
340247a8:	b2db      	uxtb	r3, r3
340247aa:	431a      	orrs	r2, r3
340247ac:	683b      	ldr	r3, [r7, #0]
340247ae:	0d1b      	lsrs	r3, r3, #20
340247b0:	021b      	lsls	r3, r3, #8
340247b2:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
340247b6:	431a      	orrs	r2, r3
340247b8:	683b      	ldr	r3, [r7, #0]
340247ba:	0f1b      	lsrs	r3, r3, #28
340247bc:	031b      	lsls	r3, r3, #12
340247be:	4313      	orrs	r3, r2
340247c0:	9300      	str	r3, [sp, #0]
340247c2:	687b      	ldr	r3, [r7, #4]
340247c4:	68ba      	ldr	r2, [r7, #8]
340247c6:	68f9      	ldr	r1, [r7, #12]
340247c8:	47a0      	blx	r4
}
340247ca:	e009      	b.n	340247e0 <UTIL_LCD_DrawVLine+0xd4>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
340247cc:	4b07      	ldr	r3, [pc, #28]	@ (340247ec <UTIL_LCD_DrawVLine+0xe0>)
340247ce:	68dc      	ldr	r4, [r3, #12]
340247d0:	4b05      	ldr	r3, [pc, #20]	@ (340247e8 <UTIL_LCD_DrawVLine+0xdc>)
340247d2:	6918      	ldr	r0, [r3, #16]
340247d4:	683b      	ldr	r3, [r7, #0]
340247d6:	9300      	str	r3, [sp, #0]
340247d8:	687b      	ldr	r3, [r7, #4]
340247da:	68ba      	ldr	r2, [r7, #8]
340247dc:	68f9      	ldr	r1, [r7, #12]
340247de:	47a0      	blx	r4
}
340247e0:	bf00      	nop
340247e2:	3714      	adds	r7, #20
340247e4:	46bd      	mov	sp, r7
340247e6:	bd90      	pop	{r4, r7, pc}
340247e8:	34056640 	.word	0x34056640
340247ec:	34056680 	.word	0x34056680

340247f0 <UTIL_LCD_Clear>:
/**
  * @brief  Clears the whole currently active layer of LTDC.
  * @param  Color  Color of the background
  */
void UTIL_LCD_Clear(uint32_t Color)
{
340247f0:	b580      	push	{r7, lr}
340247f2:	b084      	sub	sp, #16
340247f4:	af02      	add	r7, sp, #8
340247f6:	6078      	str	r0, [r7, #4]
  /* Clear the LCD */
  UTIL_LCD_FillRect(0, 0, DrawProp[DrawProp->LcdLayer].LcdXsize, DrawProp[DrawProp->LcdLayer].LcdYsize, Color);
340247f8:	4b0c      	ldr	r3, [pc, #48]	@ (3402482c <UTIL_LCD_Clear+0x3c>)
340247fa:	68db      	ldr	r3, [r3, #12]
340247fc:	4a0b      	ldr	r2, [pc, #44]	@ (3402482c <UTIL_LCD_Clear+0x3c>)
340247fe:	015b      	lsls	r3, r3, #5
34024800:	4413      	add	r3, r2
34024802:	3314      	adds	r3, #20
34024804:	681a      	ldr	r2, [r3, #0]
34024806:	4b09      	ldr	r3, [pc, #36]	@ (3402482c <UTIL_LCD_Clear+0x3c>)
34024808:	68db      	ldr	r3, [r3, #12]
3402480a:	4908      	ldr	r1, [pc, #32]	@ (3402482c <UTIL_LCD_Clear+0x3c>)
3402480c:	015b      	lsls	r3, r3, #5
3402480e:	440b      	add	r3, r1
34024810:	3318      	adds	r3, #24
34024812:	6819      	ldr	r1, [r3, #0]
34024814:	687b      	ldr	r3, [r7, #4]
34024816:	9300      	str	r3, [sp, #0]
34024818:	460b      	mov	r3, r1
3402481a:	2100      	movs	r1, #0
3402481c:	2000      	movs	r0, #0
3402481e:	f000 f91f 	bl	34024a60 <UTIL_LCD_FillRect>
}
34024822:	bf00      	nop
34024824:	3708      	adds	r7, #8
34024826:	46bd      	mov	sp, r7
34024828:	bd80      	pop	{r7, pc}
3402482a:	bf00      	nop
3402482c:	34056640 	.word	0x34056640

34024830 <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
34024830:	b580      	push	{r7, lr}
34024832:	b084      	sub	sp, #16
34024834:	af00      	add	r7, sp, #0
34024836:	60f8      	str	r0, [r7, #12]
34024838:	60b9      	str	r1, [r7, #8]
3402483a:	4613      	mov	r3, r2
3402483c:	71fb      	strb	r3, [r7, #7]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
3402483e:	4b16      	ldr	r3, [pc, #88]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
34024840:	68db      	ldr	r3, [r3, #12]
34024842:	4a15      	ldr	r2, [pc, #84]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
34024844:	015b      	lsls	r3, r3, #5
34024846:	4413      	add	r3, r2
34024848:	3308      	adds	r3, #8
3402484a:	681b      	ldr	r3, [r3, #0]
3402484c:	681a      	ldr	r2, [r3, #0]
3402484e:	79fb      	ldrb	r3, [r7, #7]
34024850:	3b20      	subs	r3, #32
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34024852:	4911      	ldr	r1, [pc, #68]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
34024854:	68c9      	ldr	r1, [r1, #12]
34024856:	4810      	ldr	r0, [pc, #64]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
34024858:	0149      	lsls	r1, r1, #5
3402485a:	4401      	add	r1, r0
3402485c:	3108      	adds	r1, #8
3402485e:	6809      	ldr	r1, [r1, #0]
34024860:	88c9      	ldrh	r1, [r1, #6]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34024862:	fb03 f101 	mul.w	r1, r3, r1
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
34024866:	4b0c      	ldr	r3, [pc, #48]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
34024868:	68db      	ldr	r3, [r3, #12]
3402486a:	480b      	ldr	r0, [pc, #44]	@ (34024898 <UTIL_LCD_DisplayChar+0x68>)
3402486c:	015b      	lsls	r3, r3, #5
3402486e:	4403      	add	r3, r0
34024870:	3308      	adds	r3, #8
34024872:	681b      	ldr	r3, [r3, #0]
34024874:	889b      	ldrh	r3, [r3, #4]
34024876:	3307      	adds	r3, #7
34024878:	2b00      	cmp	r3, #0
3402487a:	da00      	bge.n	3402487e <UTIL_LCD_DisplayChar+0x4e>
3402487c:	3307      	adds	r3, #7
3402487e:	10db      	asrs	r3, r3, #3
34024880:	fb01 f303 	mul.w	r3, r1, r3
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
34024884:	4413      	add	r3, r2
34024886:	461a      	mov	r2, r3
34024888:	68b9      	ldr	r1, [r7, #8]
3402488a:	68f8      	ldr	r0, [r7, #12]
3402488c:	f000 f962 	bl	34024b54 <DrawChar>
}
34024890:	bf00      	nop
34024892:	3710      	adds	r7, #16
34024894:	46bd      	mov	sp, r7
34024896:	bd80      	pop	{r7, pc}
34024898:	34056640 	.word	0x34056640

3402489c <UTIL_LCD_DisplayStringAt>:
  *            @arg  CENTER_MODE
  *            @arg  RIGHT_MODE
  *            @arg  LEFT_MODE
  */
void UTIL_LCD_DisplayStringAt(uint32_t Xpos, uint32_t Ypos, uint8_t *Text, Text_AlignModeTypdef Mode)
{
3402489c:	b580      	push	{r7, lr}
3402489e:	b08a      	sub	sp, #40	@ 0x28
340248a0:	af00      	add	r7, sp, #0
340248a2:	60f8      	str	r0, [r7, #12]
340248a4:	60b9      	str	r1, [r7, #8]
340248a6:	607a      	str	r2, [r7, #4]
340248a8:	70fb      	strb	r3, [r7, #3]
  uint32_t refcolumn = 1, i = 0;
340248aa:	2301      	movs	r3, #1
340248ac:	627b      	str	r3, [r7, #36]	@ 0x24
340248ae:	2300      	movs	r3, #0
340248b0:	623b      	str	r3, [r7, #32]
  uint32_t size = 0, xsize = 0;
340248b2:	2300      	movs	r3, #0
340248b4:	61fb      	str	r3, [r7, #28]
340248b6:	2300      	movs	r3, #0
340248b8:	617b      	str	r3, [r7, #20]
  uint8_t  *ptr = Text;
340248ba:	687b      	ldr	r3, [r7, #4]
340248bc:	61bb      	str	r3, [r7, #24]

  /* Get the text size */
  while (*ptr++) size ++ ;
340248be:	e002      	b.n	340248c6 <UTIL_LCD_DisplayStringAt+0x2a>
340248c0:	69fb      	ldr	r3, [r7, #28]
340248c2:	3301      	adds	r3, #1
340248c4:	61fb      	str	r3, [r7, #28]
340248c6:	69bb      	ldr	r3, [r7, #24]
340248c8:	1c5a      	adds	r2, r3, #1
340248ca:	61ba      	str	r2, [r7, #24]
340248cc:	781b      	ldrb	r3, [r3, #0]
340248ce:	2b00      	cmp	r3, #0
340248d0:	d1f6      	bne.n	340248c0 <UTIL_LCD_DisplayStringAt+0x24>

  /* Characters number per line */
  xsize = (DrawProp[DrawProp->LcdLayer].LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
340248d2:	4b4d      	ldr	r3, [pc, #308]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340248d4:	68db      	ldr	r3, [r3, #12]
340248d6:	4a4c      	ldr	r2, [pc, #304]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340248d8:	015b      	lsls	r3, r3, #5
340248da:	4413      	add	r3, r2
340248dc:	3314      	adds	r3, #20
340248de:	681b      	ldr	r3, [r3, #0]
340248e0:	4a49      	ldr	r2, [pc, #292]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340248e2:	68d2      	ldr	r2, [r2, #12]
340248e4:	4948      	ldr	r1, [pc, #288]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340248e6:	0152      	lsls	r2, r2, #5
340248e8:	440a      	add	r2, r1
340248ea:	3208      	adds	r2, #8
340248ec:	6812      	ldr	r2, [r2, #0]
340248ee:	8892      	ldrh	r2, [r2, #4]
340248f0:	fbb3 f3f2 	udiv	r3, r3, r2
340248f4:	617b      	str	r3, [r7, #20]

  switch (Mode)
340248f6:	78fb      	ldrb	r3, [r7, #3]
340248f8:	2b03      	cmp	r3, #3
340248fa:	d018      	beq.n	3402492e <UTIL_LCD_DisplayStringAt+0x92>
340248fc:	2b03      	cmp	r3, #3
340248fe:	dc2a      	bgt.n	34024956 <UTIL_LCD_DisplayStringAt+0xba>
34024900:	2b01      	cmp	r3, #1
34024902:	d002      	beq.n	3402490a <UTIL_LCD_DisplayStringAt+0x6e>
34024904:	2b02      	cmp	r3, #2
34024906:	d015      	beq.n	34024934 <UTIL_LCD_DisplayStringAt+0x98>
34024908:	e025      	b.n	34024956 <UTIL_LCD_DisplayStringAt+0xba>
  {
  case CENTER_MODE:
    {
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
3402490a:	697a      	ldr	r2, [r7, #20]
3402490c:	69fb      	ldr	r3, [r7, #28]
3402490e:	1ad3      	subs	r3, r2, r3
34024910:	4a3d      	ldr	r2, [pc, #244]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
34024912:	68d2      	ldr	r2, [r2, #12]
34024914:	493c      	ldr	r1, [pc, #240]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
34024916:	0152      	lsls	r2, r2, #5
34024918:	440a      	add	r2, r1
3402491a:	3208      	adds	r2, #8
3402491c:	6812      	ldr	r2, [r2, #0]
3402491e:	8892      	ldrh	r2, [r2, #4]
34024920:	fb02 f303 	mul.w	r3, r2, r3
34024924:	085b      	lsrs	r3, r3, #1
34024926:	68fa      	ldr	r2, [r7, #12]
34024928:	4413      	add	r3, r2
3402492a:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
3402492c:	e016      	b.n	3402495c <UTIL_LCD_DisplayStringAt+0xc0>
    }
  case LEFT_MODE:
    {
      refcolumn = Xpos;
3402492e:	68fb      	ldr	r3, [r7, #12]
34024930:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
34024932:	e013      	b.n	3402495c <UTIL_LCD_DisplayStringAt+0xc0>
    }
  case RIGHT_MODE:
    {
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
34024934:	697a      	ldr	r2, [r7, #20]
34024936:	69fb      	ldr	r3, [r7, #28]
34024938:	1ad3      	subs	r3, r2, r3
3402493a:	4a33      	ldr	r2, [pc, #204]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
3402493c:	68d2      	ldr	r2, [r2, #12]
3402493e:	4932      	ldr	r1, [pc, #200]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
34024940:	0152      	lsls	r2, r2, #5
34024942:	440a      	add	r2, r1
34024944:	3208      	adds	r2, #8
34024946:	6812      	ldr	r2, [r2, #0]
34024948:	8892      	ldrh	r2, [r2, #4]
3402494a:	fb03 f202 	mul.w	r2, r3, r2
3402494e:	68fb      	ldr	r3, [r7, #12]
34024950:	1ad3      	subs	r3, r2, r3
34024952:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
34024954:	e002      	b.n	3402495c <UTIL_LCD_DisplayStringAt+0xc0>
    }
  default:
    {
      refcolumn = Xpos;
34024956:	68fb      	ldr	r3, [r7, #12]
34024958:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
3402495a:	bf00      	nop
    }
  }

  /* Check that the Start column is located in the screen */
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
3402495c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3402495e:	2b00      	cmp	r3, #0
34024960:	d003      	beq.n	3402496a <UTIL_LCD_DisplayStringAt+0xce>
34024962:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34024964:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34024968:	d31b      	bcc.n	340249a2 <UTIL_LCD_DisplayStringAt+0x106>
  {
    refcolumn = 1;
3402496a:	2301      	movs	r3, #1
3402496c:	627b      	str	r3, [r7, #36]	@ 0x24
  }

  /* Send the string character by character on LCD */
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
3402496e:	e018      	b.n	340249a2 <UTIL_LCD_DisplayStringAt+0x106>
  {
    /* Display one character on LCD */
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
34024970:	687b      	ldr	r3, [r7, #4]
34024972:	781b      	ldrb	r3, [r3, #0]
34024974:	461a      	mov	r2, r3
34024976:	68b9      	ldr	r1, [r7, #8]
34024978:	6a78      	ldr	r0, [r7, #36]	@ 0x24
3402497a:	f7ff ff59 	bl	34024830 <UTIL_LCD_DisplayChar>
    /* Decrement the column position by 16 */
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
3402497e:	4b22      	ldr	r3, [pc, #136]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
34024980:	68db      	ldr	r3, [r3, #12]
34024982:	4a21      	ldr	r2, [pc, #132]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
34024984:	015b      	lsls	r3, r3, #5
34024986:	4413      	add	r3, r2
34024988:	3308      	adds	r3, #8
3402498a:	681b      	ldr	r3, [r3, #0]
3402498c:	889b      	ldrh	r3, [r3, #4]
3402498e:	461a      	mov	r2, r3
34024990:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34024992:	4413      	add	r3, r2
34024994:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Point on the next character */
    Text++;
34024996:	687b      	ldr	r3, [r7, #4]
34024998:	3301      	adds	r3, #1
3402499a:	607b      	str	r3, [r7, #4]
    i++;
3402499c:	6a3b      	ldr	r3, [r7, #32]
3402499e:	3301      	adds	r3, #1
340249a0:	623b      	str	r3, [r7, #32]
  while ((*Text != 0) & (((DrawProp[DrawProp->LcdLayer].LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
340249a2:	687b      	ldr	r3, [r7, #4]
340249a4:	781b      	ldrb	r3, [r3, #0]
340249a6:	2b00      	cmp	r3, #0
340249a8:	bf14      	ite	ne
340249aa:	2301      	movne	r3, #1
340249ac:	2300      	moveq	r3, #0
340249ae:	b2da      	uxtb	r2, r3
340249b0:	4b15      	ldr	r3, [pc, #84]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249b2:	68db      	ldr	r3, [r3, #12]
340249b4:	4914      	ldr	r1, [pc, #80]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249b6:	015b      	lsls	r3, r3, #5
340249b8:	440b      	add	r3, r1
340249ba:	3314      	adds	r3, #20
340249bc:	6819      	ldr	r1, [r3, #0]
340249be:	4b12      	ldr	r3, [pc, #72]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249c0:	68db      	ldr	r3, [r3, #12]
340249c2:	4811      	ldr	r0, [pc, #68]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249c4:	015b      	lsls	r3, r3, #5
340249c6:	4403      	add	r3, r0
340249c8:	3308      	adds	r3, #8
340249ca:	681b      	ldr	r3, [r3, #0]
340249cc:	889b      	ldrh	r3, [r3, #4]
340249ce:	4618      	mov	r0, r3
340249d0:	6a3b      	ldr	r3, [r7, #32]
340249d2:	fb00 f303 	mul.w	r3, r0, r3
340249d6:	1acb      	subs	r3, r1, r3
340249d8:	b29b      	uxth	r3, r3
340249da:	490b      	ldr	r1, [pc, #44]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249dc:	68c9      	ldr	r1, [r1, #12]
340249de:	480a      	ldr	r0, [pc, #40]	@ (34024a08 <UTIL_LCD_DisplayStringAt+0x16c>)
340249e0:	0149      	lsls	r1, r1, #5
340249e2:	4401      	add	r1, r0
340249e4:	3108      	adds	r1, #8
340249e6:	6809      	ldr	r1, [r1, #0]
340249e8:	8889      	ldrh	r1, [r1, #4]
340249ea:	428b      	cmp	r3, r1
340249ec:	bf2c      	ite	cs
340249ee:	2301      	movcs	r3, #1
340249f0:	2300      	movcc	r3, #0
340249f2:	b2db      	uxtb	r3, r3
340249f4:	4013      	ands	r3, r2
340249f6:	b2db      	uxtb	r3, r3
340249f8:	2b00      	cmp	r3, #0
340249fa:	d1b9      	bne.n	34024970 <UTIL_LCD_DisplayStringAt+0xd4>
  }
}
340249fc:	bf00      	nop
340249fe:	bf00      	nop
34024a00:	3728      	adds	r7, #40	@ 0x28
34024a02:	46bd      	mov	sp, r7
34024a04:	bd80      	pop	{r7, pc}
34024a06:	bf00      	nop
34024a08:	34056640 	.word	0x34056640

34024a0c <UTIL_LCD_DrawRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_DrawRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34024a0c:	b580      	push	{r7, lr}
34024a0e:	b084      	sub	sp, #16
34024a10:	af00      	add	r7, sp, #0
34024a12:	60f8      	str	r0, [r7, #12]
34024a14:	60b9      	str	r1, [r7, #8]
34024a16:	607a      	str	r2, [r7, #4]
34024a18:	603b      	str	r3, [r7, #0]
  /* Draw horizontal lines */
  UTIL_LCD_DrawHLine(Xpos, Ypos, Width, Color);
34024a1a:	69bb      	ldr	r3, [r7, #24]
34024a1c:	687a      	ldr	r2, [r7, #4]
34024a1e:	68b9      	ldr	r1, [r7, #8]
34024a20:	68f8      	ldr	r0, [r7, #12]
34024a22:	f7ff fe01 	bl	34024628 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawHLine(Xpos, (Ypos+ Height - 1U), Width, Color);
34024a26:	68ba      	ldr	r2, [r7, #8]
34024a28:	683b      	ldr	r3, [r7, #0]
34024a2a:	4413      	add	r3, r2
34024a2c:	1e59      	subs	r1, r3, #1
34024a2e:	69bb      	ldr	r3, [r7, #24]
34024a30:	687a      	ldr	r2, [r7, #4]
34024a32:	68f8      	ldr	r0, [r7, #12]
34024a34:	f7ff fdf8 	bl	34024628 <UTIL_LCD_DrawHLine>

  /* Draw vertical lines */
  UTIL_LCD_DrawVLine(Xpos, Ypos, Height, Color);
34024a38:	69bb      	ldr	r3, [r7, #24]
34024a3a:	683a      	ldr	r2, [r7, #0]
34024a3c:	68b9      	ldr	r1, [r7, #8]
34024a3e:	68f8      	ldr	r0, [r7, #12]
34024a40:	f7ff fe64 	bl	3402470c <UTIL_LCD_DrawVLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
34024a44:	68fa      	ldr	r2, [r7, #12]
34024a46:	687b      	ldr	r3, [r7, #4]
34024a48:	4413      	add	r3, r2
34024a4a:	1e58      	subs	r0, r3, #1
34024a4c:	69bb      	ldr	r3, [r7, #24]
34024a4e:	683a      	ldr	r2, [r7, #0]
34024a50:	68b9      	ldr	r1, [r7, #8]
34024a52:	f7ff fe5b 	bl	3402470c <UTIL_LCD_DrawVLine>
}
34024a56:	bf00      	nop
34024a58:	3710      	adds	r7, #16
34024a5a:	46bd      	mov	sp, r7
34024a5c:	bd80      	pop	{r7, pc}
	...

34024a60 <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
34024a60:	b590      	push	{r4, r7, lr}
34024a62:	b087      	sub	sp, #28
34024a64:	af02      	add	r7, sp, #8
34024a66:	60f8      	str	r0, [r7, #12]
34024a68:	60b9      	str	r1, [r7, #8]
34024a6a:	607a      	str	r2, [r7, #4]
34024a6c:	603b      	str	r3, [r7, #0]
  /* Fill the rectangle */
  if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34024a6e:	4b37      	ldr	r3, [pc, #220]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024a70:	68db      	ldr	r3, [r3, #12]
34024a72:	4a36      	ldr	r2, [pc, #216]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024a74:	015b      	lsls	r3, r3, #5
34024a76:	4413      	add	r3, r2
34024a78:	331c      	adds	r3, #28
34024a7a:	681b      	ldr	r3, [r3, #0]
34024a7c:	2b02      	cmp	r3, #2
34024a7e:	d11a      	bne.n	34024ab6 <UTIL_LCD_FillRect+0x56>
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
34024a80:	4b33      	ldr	r3, [pc, #204]	@ (34024b50 <UTIL_LCD_FillRect+0xf0>)
34024a82:	691c      	ldr	r4, [r3, #16]
34024a84:	4b31      	ldr	r3, [pc, #196]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024a86:	6918      	ldr	r0, [r3, #16]
34024a88:	6a3b      	ldr	r3, [r7, #32]
34024a8a:	08db      	lsrs	r3, r3, #3
34024a8c:	f003 021f 	and.w	r2, r3, #31
34024a90:	6a3b      	ldr	r3, [r7, #32]
34024a92:	0a9b      	lsrs	r3, r3, #10
34024a94:	015b      	lsls	r3, r3, #5
34024a96:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34024a9a:	431a      	orrs	r2, r3
34024a9c:	6a3b      	ldr	r3, [r7, #32]
34024a9e:	0cdb      	lsrs	r3, r3, #19
34024aa0:	02db      	lsls	r3, r3, #11
34024aa2:	b29b      	uxth	r3, r3
34024aa4:	4313      	orrs	r3, r2
34024aa6:	9301      	str	r3, [sp, #4]
34024aa8:	683b      	ldr	r3, [r7, #0]
34024aaa:	9300      	str	r3, [sp, #0]
34024aac:	687b      	ldr	r3, [r7, #4]
34024aae:	68ba      	ldr	r2, [r7, #8]
34024ab0:	68f9      	ldr	r1, [r7, #12]
34024ab2:	47a0      	blx	r4
  }
  else /*LCD_PIXEL_FORMAT_ARGB8888*/
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
  }
}
34024ab4:	e046      	b.n	34024b44 <UTIL_LCD_FillRect+0xe4>
  else if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
34024ab6:	4b25      	ldr	r3, [pc, #148]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024ab8:	69db      	ldr	r3, [r3, #28]
34024aba:	2b01      	cmp	r3, #1
34024abc:	d10e      	bne.n	34024adc <UTIL_LCD_FillRect+0x7c>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB888(Color));
34024abe:	4b24      	ldr	r3, [pc, #144]	@ (34024b50 <UTIL_LCD_FillRect+0xf0>)
34024ac0:	691c      	ldr	r4, [r3, #16]
34024ac2:	4b22      	ldr	r3, [pc, #136]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024ac4:	6918      	ldr	r0, [r3, #16]
34024ac6:	6a3b      	ldr	r3, [r7, #32]
34024ac8:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34024acc:	9301      	str	r3, [sp, #4]
34024ace:	683b      	ldr	r3, [r7, #0]
34024ad0:	9300      	str	r3, [sp, #0]
34024ad2:	687b      	ldr	r3, [r7, #4]
34024ad4:	68ba      	ldr	r2, [r7, #8]
34024ad6:	68f9      	ldr	r1, [r7, #12]
34024ad8:	47a0      	blx	r4
}
34024ada:	e033      	b.n	34024b44 <UTIL_LCD_FillRect+0xe4>
  else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34024adc:	4b1b      	ldr	r3, [pc, #108]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024ade:	68db      	ldr	r3, [r3, #12]
34024ae0:	4a1a      	ldr	r2, [pc, #104]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024ae2:	015b      	lsls	r3, r3, #5
34024ae4:	4413      	add	r3, r2
34024ae6:	331c      	adds	r3, #28
34024ae8:	681b      	ldr	r3, [r3, #0]
34024aea:	2b04      	cmp	r3, #4
34024aec:	d11e      	bne.n	34024b2c <UTIL_LCD_FillRect+0xcc>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882ARGB4444(Color));
34024aee:	4b18      	ldr	r3, [pc, #96]	@ (34024b50 <UTIL_LCD_FillRect+0xf0>)
34024af0:	691c      	ldr	r4, [r3, #16]
34024af2:	4b16      	ldr	r3, [pc, #88]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024af4:	6918      	ldr	r0, [r3, #16]
34024af6:	6a3b      	ldr	r3, [r7, #32]
34024af8:	091b      	lsrs	r3, r3, #4
34024afa:	f003 020f 	and.w	r2, r3, #15
34024afe:	6a3b      	ldr	r3, [r7, #32]
34024b00:	0b1b      	lsrs	r3, r3, #12
34024b02:	011b      	lsls	r3, r3, #4
34024b04:	b2db      	uxtb	r3, r3
34024b06:	431a      	orrs	r2, r3
34024b08:	6a3b      	ldr	r3, [r7, #32]
34024b0a:	0d1b      	lsrs	r3, r3, #20
34024b0c:	021b      	lsls	r3, r3, #8
34024b0e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34024b12:	431a      	orrs	r2, r3
34024b14:	6a3b      	ldr	r3, [r7, #32]
34024b16:	0f1b      	lsrs	r3, r3, #28
34024b18:	031b      	lsls	r3, r3, #12
34024b1a:	4313      	orrs	r3, r2
34024b1c:	9301      	str	r3, [sp, #4]
34024b1e:	683b      	ldr	r3, [r7, #0]
34024b20:	9300      	str	r3, [sp, #0]
34024b22:	687b      	ldr	r3, [r7, #4]
34024b24:	68ba      	ldr	r2, [r7, #8]
34024b26:	68f9      	ldr	r1, [r7, #12]
34024b28:	47a0      	blx	r4
}
34024b2a:	e00b      	b.n	34024b44 <UTIL_LCD_FillRect+0xe4>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
34024b2c:	4b08      	ldr	r3, [pc, #32]	@ (34024b50 <UTIL_LCD_FillRect+0xf0>)
34024b2e:	691c      	ldr	r4, [r3, #16]
34024b30:	4b06      	ldr	r3, [pc, #24]	@ (34024b4c <UTIL_LCD_FillRect+0xec>)
34024b32:	6918      	ldr	r0, [r3, #16]
34024b34:	6a3b      	ldr	r3, [r7, #32]
34024b36:	9301      	str	r3, [sp, #4]
34024b38:	683b      	ldr	r3, [r7, #0]
34024b3a:	9300      	str	r3, [sp, #0]
34024b3c:	687b      	ldr	r3, [r7, #4]
34024b3e:	68ba      	ldr	r2, [r7, #8]
34024b40:	68f9      	ldr	r1, [r7, #12]
34024b42:	47a0      	blx	r4
}
34024b44:	bf00      	nop
34024b46:	3714      	adds	r7, #20
34024b48:	46bd      	mov	sp, r7
34024b4a:	bd90      	pop	{r4, r7, pc}
34024b4c:	34056640 	.word	0x34056640
34024b50:	34056680 	.word	0x34056680

34024b54 <DrawChar>:
  * @param  Xpos  Line where to display the character shape
  * @param  Ypos  Start column address
  * @param  pData Pointer to the character data
  */
static void DrawChar(uint32_t Xpos, uint32_t Ypos, const uint8_t *pData)
{
34024b54:	b580      	push	{r7, lr}
34024b56:	b0a8      	sub	sp, #160	@ 0xa0
34024b58:	af02      	add	r7, sp, #8
34024b5a:	60f8      	str	r0, [r7, #12]
34024b5c:	60b9      	str	r1, [r7, #8]
34024b5e:	607a      	str	r2, [r7, #4]
  uint32_t i = 0, j = 0, offset;
34024b60:	2300      	movs	r3, #0
34024b62:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34024b66:	2300      	movs	r3, #0
34024b68:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  uint32_t height, width;
  uint8_t  *pchar;
  uint32_t line;

  height = DrawProp[DrawProp->LcdLayer].pFont->Height;
34024b6c:	4ba0      	ldr	r3, [pc, #640]	@ (34024df0 <DrawChar+0x29c>)
34024b6e:	68db      	ldr	r3, [r3, #12]
34024b70:	4a9f      	ldr	r2, [pc, #636]	@ (34024df0 <DrawChar+0x29c>)
34024b72:	015b      	lsls	r3, r3, #5
34024b74:	4413      	add	r3, r2
34024b76:	3308      	adds	r3, #8
34024b78:	681b      	ldr	r3, [r3, #0]
34024b7a:	88db      	ldrh	r3, [r3, #6]
34024b7c:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
  width  = DrawProp[DrawProp->LcdLayer].pFont->Width;
34024b80:	4b9b      	ldr	r3, [pc, #620]	@ (34024df0 <DrawChar+0x29c>)
34024b82:	68db      	ldr	r3, [r3, #12]
34024b84:	4a9a      	ldr	r2, [pc, #616]	@ (34024df0 <DrawChar+0x29c>)
34024b86:	015b      	lsls	r3, r3, #5
34024b88:	4413      	add	r3, r2
34024b8a:	3308      	adds	r3, #8
34024b8c:	681b      	ldr	r3, [r3, #0]
34024b8e:	889b      	ldrh	r3, [r3, #4]
34024b90:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

  uint8_t rgb8[24*4];
  uint16_t* rgb16 = (uint16_t*)rgb8;
34024b94:	f107 0310 	add.w	r3, r7, #16
34024b98:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
  uint32_t* argb32 = (uint32_t*)rgb8;
34024b9c:	f107 0310 	add.w	r3, r7, #16
34024ba0:	67fb      	str	r3, [r7, #124]	@ 0x7c
  uint16_t* argb4444 = (uint16_t*)rgb8;
34024ba2:	f107 0310 	add.w	r3, r7, #16
34024ba6:	67bb      	str	r3, [r7, #120]	@ 0x78

  offset =  8 *((width + 7)/8) -  width ;
34024ba8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024bac:	3307      	adds	r3, #7
34024bae:	f023 0207 	bic.w	r2, r3, #7
34024bb2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024bb6:	1ad3      	subs	r3, r2, r3
34024bb8:	677b      	str	r3, [r7, #116]	@ 0x74

  for(i = 0; i < height; i++)
34024bba:	2300      	movs	r3, #0
34024bbc:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34024bc0:	e260      	b.n	34025084 <DrawChar+0x530>
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
34024bc2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024bc6:	3307      	adds	r3, #7
34024bc8:	08db      	lsrs	r3, r3, #3
34024bca:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
34024bce:	fb02 f303 	mul.w	r3, r2, r3
34024bd2:	687a      	ldr	r2, [r7, #4]
34024bd4:	4413      	add	r3, r2
34024bd6:	673b      	str	r3, [r7, #112]	@ 0x70

    switch(((width + 7)/8))
34024bd8:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024bdc:	3307      	adds	r3, #7
34024bde:	08db      	lsrs	r3, r3, #3
34024be0:	2b01      	cmp	r3, #1
34024be2:	d002      	beq.n	34024bea <DrawChar+0x96>
34024be4:	2b02      	cmp	r3, #2
34024be6:	d005      	beq.n	34024bf4 <DrawChar+0xa0>
34024be8:	e00e      	b.n	34024c08 <DrawChar+0xb4>
    {

    case 1:
      line =  pchar[0];
34024bea:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34024bec:	781b      	ldrb	r3, [r3, #0]
34024bee:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
34024bf2:	e018      	b.n	34024c26 <DrawChar+0xd2>

    case 2:
      line =  (pchar[0]<< 8) | pchar[1];
34024bf4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34024bf6:	781b      	ldrb	r3, [r3, #0]
34024bf8:	021b      	lsls	r3, r3, #8
34024bfa:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
34024bfc:	3201      	adds	r2, #1
34024bfe:	7812      	ldrb	r2, [r2, #0]
34024c00:	4313      	orrs	r3, r2
34024c02:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
34024c06:	e00e      	b.n	34024c26 <DrawChar+0xd2>

    case 3:
    default:
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
34024c08:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34024c0a:	781b      	ldrb	r3, [r3, #0]
34024c0c:	041a      	lsls	r2, r3, #16
34024c0e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
34024c10:	3301      	adds	r3, #1
34024c12:	781b      	ldrb	r3, [r3, #0]
34024c14:	021b      	lsls	r3, r3, #8
34024c16:	4313      	orrs	r3, r2
34024c18:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
34024c1a:	3202      	adds	r2, #2
34024c1c:	7812      	ldrb	r2, [r2, #0]
34024c1e:	4313      	orrs	r3, r2
34024c20:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
      break;
34024c24:	bf00      	nop
    }

    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
34024c26:	4b72      	ldr	r3, [pc, #456]	@ (34024df0 <DrawChar+0x29c>)
34024c28:	68db      	ldr	r3, [r3, #12]
34024c2a:	4a71      	ldr	r2, [pc, #452]	@ (34024df0 <DrawChar+0x29c>)
34024c2c:	015b      	lsls	r3, r3, #5
34024c2e:	4413      	add	r3, r2
34024c30:	331c      	adds	r3, #28
34024c32:	681b      	ldr	r3, [r3, #0]
34024c34:	2b02      	cmp	r3, #2
34024c36:	f040 808b 	bne.w	34024d50 <DrawChar+0x1fc>
    {
      for (j = 0; j < width; j++)
34024c3a:	2300      	movs	r3, #0
34024c3c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024c40:	e073      	b.n	34024d2a <DrawChar+0x1d6>
      {
        if(line & (1 << (width- j + offset- 1)))
34024c42:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34024c46:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024c4a:	1ad2      	subs	r2, r2, r3
34024c4c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34024c4e:	4413      	add	r3, r2
34024c50:	3b01      	subs	r3, #1
34024c52:	2201      	movs	r2, #1
34024c54:	fa02 f303 	lsl.w	r3, r2, r3
34024c58:	461a      	mov	r2, r3
34024c5a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34024c5e:	4013      	ands	r3, r2
34024c60:	2b00      	cmp	r3, #0
34024c62:	d02d      	beq.n	34024cc0 <DrawChar+0x16c>
        {
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
34024c64:	4b62      	ldr	r3, [pc, #392]	@ (34024df0 <DrawChar+0x29c>)
34024c66:	68db      	ldr	r3, [r3, #12]
34024c68:	4a61      	ldr	r2, [pc, #388]	@ (34024df0 <DrawChar+0x29c>)
34024c6a:	015b      	lsls	r3, r3, #5
34024c6c:	4413      	add	r3, r2
34024c6e:	681b      	ldr	r3, [r3, #0]
34024c70:	08db      	lsrs	r3, r3, #3
34024c72:	b29b      	uxth	r3, r3
34024c74:	f003 031f 	and.w	r3, r3, #31
34024c78:	b29a      	uxth	r2, r3
34024c7a:	4b5d      	ldr	r3, [pc, #372]	@ (34024df0 <DrawChar+0x29c>)
34024c7c:	68db      	ldr	r3, [r3, #12]
34024c7e:	495c      	ldr	r1, [pc, #368]	@ (34024df0 <DrawChar+0x29c>)
34024c80:	015b      	lsls	r3, r3, #5
34024c82:	440b      	add	r3, r1
34024c84:	681b      	ldr	r3, [r3, #0]
34024c86:	0a9b      	lsrs	r3, r3, #10
34024c88:	b29b      	uxth	r3, r3
34024c8a:	015b      	lsls	r3, r3, #5
34024c8c:	b29b      	uxth	r3, r3
34024c8e:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34024c92:	b29b      	uxth	r3, r3
34024c94:	4313      	orrs	r3, r2
34024c96:	b299      	uxth	r1, r3
34024c98:	4b55      	ldr	r3, [pc, #340]	@ (34024df0 <DrawChar+0x29c>)
34024c9a:	68db      	ldr	r3, [r3, #12]
34024c9c:	4a54      	ldr	r2, [pc, #336]	@ (34024df0 <DrawChar+0x29c>)
34024c9e:	015b      	lsls	r3, r3, #5
34024ca0:	4413      	add	r3, r2
34024ca2:	681b      	ldr	r3, [r3, #0]
34024ca4:	0cdb      	lsrs	r3, r3, #19
34024ca6:	b29b      	uxth	r3, r3
34024ca8:	02db      	lsls	r3, r3, #11
34024caa:	b29a      	uxth	r2, r3
34024cac:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024cb0:	005b      	lsls	r3, r3, #1
34024cb2:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
34024cb6:	4403      	add	r3, r0
34024cb8:	430a      	orrs	r2, r1
34024cba:	b292      	uxth	r2, r2
34024cbc:	801a      	strh	r2, [r3, #0]
34024cbe:	e02f      	b.n	34024d20 <DrawChar+0x1cc>
        }
        else
        {
          rgb16[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
34024cc0:	4b4b      	ldr	r3, [pc, #300]	@ (34024df0 <DrawChar+0x29c>)
34024cc2:	68db      	ldr	r3, [r3, #12]
34024cc4:	4a4a      	ldr	r2, [pc, #296]	@ (34024df0 <DrawChar+0x29c>)
34024cc6:	015b      	lsls	r3, r3, #5
34024cc8:	4413      	add	r3, r2
34024cca:	3304      	adds	r3, #4
34024ccc:	681b      	ldr	r3, [r3, #0]
34024cce:	08db      	lsrs	r3, r3, #3
34024cd0:	b29b      	uxth	r3, r3
34024cd2:	f003 031f 	and.w	r3, r3, #31
34024cd6:	b29a      	uxth	r2, r3
34024cd8:	4b45      	ldr	r3, [pc, #276]	@ (34024df0 <DrawChar+0x29c>)
34024cda:	68db      	ldr	r3, [r3, #12]
34024cdc:	4944      	ldr	r1, [pc, #272]	@ (34024df0 <DrawChar+0x29c>)
34024cde:	015b      	lsls	r3, r3, #5
34024ce0:	440b      	add	r3, r1
34024ce2:	3304      	adds	r3, #4
34024ce4:	681b      	ldr	r3, [r3, #0]
34024ce6:	0a9b      	lsrs	r3, r3, #10
34024ce8:	b29b      	uxth	r3, r3
34024cea:	015b      	lsls	r3, r3, #5
34024cec:	b29b      	uxth	r3, r3
34024cee:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34024cf2:	b29b      	uxth	r3, r3
34024cf4:	4313      	orrs	r3, r2
34024cf6:	b299      	uxth	r1, r3
34024cf8:	4b3d      	ldr	r3, [pc, #244]	@ (34024df0 <DrawChar+0x29c>)
34024cfa:	68db      	ldr	r3, [r3, #12]
34024cfc:	4a3c      	ldr	r2, [pc, #240]	@ (34024df0 <DrawChar+0x29c>)
34024cfe:	015b      	lsls	r3, r3, #5
34024d00:	4413      	add	r3, r2
34024d02:	3304      	adds	r3, #4
34024d04:	681b      	ldr	r3, [r3, #0]
34024d06:	0cdb      	lsrs	r3, r3, #19
34024d08:	b29b      	uxth	r3, r3
34024d0a:	02db      	lsls	r3, r3, #11
34024d0c:	b29a      	uxth	r2, r3
34024d0e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024d12:	005b      	lsls	r3, r3, #1
34024d14:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
34024d18:	4403      	add	r3, r0
34024d1a:	430a      	orrs	r2, r1
34024d1c:	b292      	uxth	r2, r2
34024d1e:	801a      	strh	r2, [r3, #0]
      for (j = 0; j < width; j++)
34024d20:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024d24:	3301      	adds	r3, #1
34024d26:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024d2a:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
34024d2e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024d32:	429a      	cmp	r2, r3
34024d34:	d385      	bcc.n	34024c42 <DrawChar+0xee>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34024d36:	68b9      	ldr	r1, [r7, #8]
34024d38:	1c4b      	adds	r3, r1, #1
34024d3a:	60bb      	str	r3, [r7, #8]
34024d3c:	f107 0210 	add.w	r2, r7, #16
34024d40:	2301      	movs	r3, #1
34024d42:	9300      	str	r3, [sp, #0]
34024d44:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024d48:	68f8      	ldr	r0, [r7, #12]
34024d4a:	f7ff fc51 	bl	340245f0 <UTIL_LCD_FillRGBRect>
34024d4e:	e194      	b.n	3402507a <DrawChar+0x526>
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB888)
34024d50:	4b27      	ldr	r3, [pc, #156]	@ (34024df0 <DrawChar+0x29c>)
34024d52:	68db      	ldr	r3, [r3, #12]
34024d54:	4a26      	ldr	r2, [pc, #152]	@ (34024df0 <DrawChar+0x29c>)
34024d56:	015b      	lsls	r3, r3, #5
34024d58:	4413      	add	r3, r2
34024d5a:	331c      	adds	r3, #28
34024d5c:	681b      	ldr	r3, [r3, #0]
34024d5e:	2b01      	cmp	r3, #1
34024d60:	f040 8095 	bne.w	34024e8e <DrawChar+0x33a>
    {
      for (j = 0; j < width*3; j = j+ 3)
34024d64:	2300      	movs	r3, #0
34024d66:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024d6a:	e079      	b.n	34024e60 <DrawChar+0x30c>
      {
        if(line & (1 << (width- j/3 + offset- 1)))
34024d6c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024d70:	4a20      	ldr	r2, [pc, #128]	@ (34024df4 <DrawChar+0x2a0>)
34024d72:	fba2 2303 	umull	r2, r3, r2, r3
34024d76:	085b      	lsrs	r3, r3, #1
34024d78:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34024d7c:	1ad2      	subs	r2, r2, r3
34024d7e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34024d80:	4413      	add	r3, r2
34024d82:	3b01      	subs	r3, #1
34024d84:	2201      	movs	r2, #1
34024d86:	fa02 f303 	lsl.w	r3, r2, r3
34024d8a:	461a      	mov	r2, r3
34024d8c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34024d90:	4013      	ands	r3, r2
34024d92:	2b00      	cmp	r3, #0
34024d94:	d030      	beq.n	34024df8 <DrawChar+0x2a4>
        {
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) & 0xFFU;
34024d96:	4b16      	ldr	r3, [pc, #88]	@ (34024df0 <DrawChar+0x29c>)
34024d98:	68db      	ldr	r3, [r3, #12]
34024d9a:	4a15      	ldr	r2, [pc, #84]	@ (34024df0 <DrawChar+0x29c>)
34024d9c:	015b      	lsls	r3, r3, #5
34024d9e:	4413      	add	r3, r2
34024da0:	681b      	ldr	r3, [r3, #0]
34024da2:	b2d9      	uxtb	r1, r3
34024da4:	f107 0210 	add.w	r2, r7, #16
34024da8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024dac:	4413      	add	r3, r2
34024dae:	460a      	mov	r2, r1
34024db0:	701a      	strb	r2, [r3, #0]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 8) & 0xFFU;
34024db2:	4b0f      	ldr	r3, [pc, #60]	@ (34024df0 <DrawChar+0x29c>)
34024db4:	68db      	ldr	r3, [r3, #12]
34024db6:	4a0e      	ldr	r2, [pc, #56]	@ (34024df0 <DrawChar+0x29c>)
34024db8:	015b      	lsls	r3, r3, #5
34024dba:	4413      	add	r3, r2
34024dbc:	681b      	ldr	r3, [r3, #0]
34024dbe:	0a1a      	lsrs	r2, r3, #8
34024dc0:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024dc4:	3301      	adds	r3, #1
34024dc6:	b2d2      	uxtb	r2, r2
34024dc8:	3398      	adds	r3, #152	@ 0x98
34024dca:	443b      	add	r3, r7
34024dcc:	f803 2c88 	strb.w	r2, [r3, #-136]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].TextColor)) >> 16) & 0xFFU;
34024dd0:	4b07      	ldr	r3, [pc, #28]	@ (34024df0 <DrawChar+0x29c>)
34024dd2:	68db      	ldr	r3, [r3, #12]
34024dd4:	4a06      	ldr	r2, [pc, #24]	@ (34024df0 <DrawChar+0x29c>)
34024dd6:	015b      	lsls	r3, r3, #5
34024dd8:	4413      	add	r3, r2
34024dda:	681b      	ldr	r3, [r3, #0]
34024ddc:	0c1a      	lsrs	r2, r3, #16
34024dde:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024de2:	3302      	adds	r3, #2
34024de4:	b2d2      	uxtb	r2, r2
34024de6:	3398      	adds	r3, #152	@ 0x98
34024de8:	443b      	add	r3, r7
34024dea:	f803 2c88 	strb.w	r2, [r3, #-136]
34024dee:	e032      	b.n	34024e56 <DrawChar+0x302>
34024df0:	34056640 	.word	0x34056640
34024df4:	aaaaaaab 	.word	0xaaaaaaab
        }
        else
        {
          rgb8[j] = CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) & 0xFFU;
34024df8:	4ba8      	ldr	r3, [pc, #672]	@ (3402509c <DrawChar+0x548>)
34024dfa:	68db      	ldr	r3, [r3, #12]
34024dfc:	4aa7      	ldr	r2, [pc, #668]	@ (3402509c <DrawChar+0x548>)
34024dfe:	015b      	lsls	r3, r3, #5
34024e00:	4413      	add	r3, r2
34024e02:	3304      	adds	r3, #4
34024e04:	681b      	ldr	r3, [r3, #0]
34024e06:	b2d9      	uxtb	r1, r3
34024e08:	f107 0210 	add.w	r2, r7, #16
34024e0c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024e10:	4413      	add	r3, r2
34024e12:	460a      	mov	r2, r1
34024e14:	701a      	strb	r2, [r3, #0]
          rgb8[j + 1U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 8) & 0xFFU;
34024e16:	4ba1      	ldr	r3, [pc, #644]	@ (3402509c <DrawChar+0x548>)
34024e18:	68db      	ldr	r3, [r3, #12]
34024e1a:	4aa0      	ldr	r2, [pc, #640]	@ (3402509c <DrawChar+0x548>)
34024e1c:	015b      	lsls	r3, r3, #5
34024e1e:	4413      	add	r3, r2
34024e20:	3304      	adds	r3, #4
34024e22:	681b      	ldr	r3, [r3, #0]
34024e24:	0a1a      	lsrs	r2, r3, #8
34024e26:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024e2a:	3301      	adds	r3, #1
34024e2c:	b2d2      	uxtb	r2, r2
34024e2e:	3398      	adds	r3, #152	@ 0x98
34024e30:	443b      	add	r3, r7
34024e32:	f803 2c88 	strb.w	r2, [r3, #-136]
          rgb8[j + 2U] = (CONVERTARGB88882RGB888((DrawProp[DrawProp->LcdLayer].BackColor)) >> 16) & 0xFFU;
34024e36:	4b99      	ldr	r3, [pc, #612]	@ (3402509c <DrawChar+0x548>)
34024e38:	68db      	ldr	r3, [r3, #12]
34024e3a:	4a98      	ldr	r2, [pc, #608]	@ (3402509c <DrawChar+0x548>)
34024e3c:	015b      	lsls	r3, r3, #5
34024e3e:	4413      	add	r3, r2
34024e40:	3304      	adds	r3, #4
34024e42:	681b      	ldr	r3, [r3, #0]
34024e44:	0c1a      	lsrs	r2, r3, #16
34024e46:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024e4a:	3302      	adds	r3, #2
34024e4c:	b2d2      	uxtb	r2, r2
34024e4e:	3398      	adds	r3, #152	@ 0x98
34024e50:	443b      	add	r3, r7
34024e52:	f803 2c88 	strb.w	r2, [r3, #-136]
      for (j = 0; j < width*3; j = j+ 3)
34024e56:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024e5a:	3303      	adds	r3, #3
34024e5c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024e60:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34024e64:	4613      	mov	r3, r2
34024e66:	005b      	lsls	r3, r3, #1
34024e68:	4413      	add	r3, r2
34024e6a:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
34024e6e:	429a      	cmp	r2, r3
34024e70:	f4ff af7c 	bcc.w	34024d6c <DrawChar+0x218>
        }
      }

      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34024e74:	68b9      	ldr	r1, [r7, #8]
34024e76:	1c4b      	adds	r3, r1, #1
34024e78:	60bb      	str	r3, [r7, #8]
34024e7a:	f107 0210 	add.w	r2, r7, #16
34024e7e:	2301      	movs	r3, #1
34024e80:	9300      	str	r3, [sp, #0]
34024e82:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024e86:	68f8      	ldr	r0, [r7, #12]
34024e88:	f7ff fbb2 	bl	340245f0 <UTIL_LCD_FillRGBRect>
34024e8c:	e0f5      	b.n	3402507a <DrawChar+0x526>
    }
    else if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34024e8e:	4b83      	ldr	r3, [pc, #524]	@ (3402509c <DrawChar+0x548>)
34024e90:	68db      	ldr	r3, [r3, #12]
34024e92:	4a82      	ldr	r2, [pc, #520]	@ (3402509c <DrawChar+0x548>)
34024e94:	015b      	lsls	r3, r3, #5
34024e96:	4413      	add	r3, r2
34024e98:	331c      	adds	r3, #28
34024e9a:	681b      	ldr	r3, [r3, #0]
34024e9c:	2b04      	cmp	r3, #4
34024e9e:	f040 80a6 	bne.w	34024fee <DrawChar+0x49a>
    {
      for (j = 0; j < width; j++)
34024ea2:	2300      	movs	r3, #0
34024ea4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024ea8:	e08e      	b.n	34024fc8 <DrawChar+0x474>
      {
        if(line & (1 << (width- j + offset- 1)))
34024eaa:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34024eae:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024eb2:	1ad2      	subs	r2, r2, r3
34024eb4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34024eb6:	4413      	add	r3, r2
34024eb8:	3b01      	subs	r3, #1
34024eba:	2201      	movs	r2, #1
34024ebc:	fa02 f303 	lsl.w	r3, r2, r3
34024ec0:	461a      	mov	r2, r3
34024ec2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34024ec6:	4013      	ands	r3, r2
34024ec8:	2b00      	cmp	r3, #0
34024eca:	d03a      	beq.n	34024f42 <DrawChar+0x3ee>
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].TextColor);
34024ecc:	4b73      	ldr	r3, [pc, #460]	@ (3402509c <DrawChar+0x548>)
34024ece:	68db      	ldr	r3, [r3, #12]
34024ed0:	4a72      	ldr	r2, [pc, #456]	@ (3402509c <DrawChar+0x548>)
34024ed2:	015b      	lsls	r3, r3, #5
34024ed4:	4413      	add	r3, r2
34024ed6:	681b      	ldr	r3, [r3, #0]
34024ed8:	091b      	lsrs	r3, r3, #4
34024eda:	b29b      	uxth	r3, r3
34024edc:	f003 030f 	and.w	r3, r3, #15
34024ee0:	b29a      	uxth	r2, r3
34024ee2:	4b6e      	ldr	r3, [pc, #440]	@ (3402509c <DrawChar+0x548>)
34024ee4:	68db      	ldr	r3, [r3, #12]
34024ee6:	496d      	ldr	r1, [pc, #436]	@ (3402509c <DrawChar+0x548>)
34024ee8:	015b      	lsls	r3, r3, #5
34024eea:	440b      	add	r3, r1
34024eec:	681b      	ldr	r3, [r3, #0]
34024eee:	0b1b      	lsrs	r3, r3, #12
34024ef0:	b29b      	uxth	r3, r3
34024ef2:	011b      	lsls	r3, r3, #4
34024ef4:	b29b      	uxth	r3, r3
34024ef6:	b2db      	uxtb	r3, r3
34024ef8:	b29b      	uxth	r3, r3
34024efa:	4313      	orrs	r3, r2
34024efc:	b29a      	uxth	r2, r3
34024efe:	4b67      	ldr	r3, [pc, #412]	@ (3402509c <DrawChar+0x548>)
34024f00:	68db      	ldr	r3, [r3, #12]
34024f02:	4966      	ldr	r1, [pc, #408]	@ (3402509c <DrawChar+0x548>)
34024f04:	015b      	lsls	r3, r3, #5
34024f06:	440b      	add	r3, r1
34024f08:	681b      	ldr	r3, [r3, #0]
34024f0a:	0d1b      	lsrs	r3, r3, #20
34024f0c:	b29b      	uxth	r3, r3
34024f0e:	021b      	lsls	r3, r3, #8
34024f10:	b29b      	uxth	r3, r3
34024f12:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34024f16:	b29b      	uxth	r3, r3
34024f18:	4313      	orrs	r3, r2
34024f1a:	b299      	uxth	r1, r3
34024f1c:	4b5f      	ldr	r3, [pc, #380]	@ (3402509c <DrawChar+0x548>)
34024f1e:	68db      	ldr	r3, [r3, #12]
34024f20:	4a5e      	ldr	r2, [pc, #376]	@ (3402509c <DrawChar+0x548>)
34024f22:	015b      	lsls	r3, r3, #5
34024f24:	4413      	add	r3, r2
34024f26:	681b      	ldr	r3, [r3, #0]
34024f28:	0f1b      	lsrs	r3, r3, #28
34024f2a:	b29b      	uxth	r3, r3
34024f2c:	031b      	lsls	r3, r3, #12
34024f2e:	b29a      	uxth	r2, r3
34024f30:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024f34:	005b      	lsls	r3, r3, #1
34024f36:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
34024f38:	4403      	add	r3, r0
34024f3a:	430a      	orrs	r2, r1
34024f3c:	b292      	uxth	r2, r2
34024f3e:	801a      	strh	r2, [r3, #0]
34024f40:	e03d      	b.n	34024fbe <DrawChar+0x46a>
        }
        else
        {
          argb4444[j] = CONVERTARGB88882ARGB4444(DrawProp[DrawProp->LcdLayer].BackColor);
34024f42:	4b56      	ldr	r3, [pc, #344]	@ (3402509c <DrawChar+0x548>)
34024f44:	68db      	ldr	r3, [r3, #12]
34024f46:	4a55      	ldr	r2, [pc, #340]	@ (3402509c <DrawChar+0x548>)
34024f48:	015b      	lsls	r3, r3, #5
34024f4a:	4413      	add	r3, r2
34024f4c:	3304      	adds	r3, #4
34024f4e:	681b      	ldr	r3, [r3, #0]
34024f50:	091b      	lsrs	r3, r3, #4
34024f52:	b29b      	uxth	r3, r3
34024f54:	f003 030f 	and.w	r3, r3, #15
34024f58:	b29a      	uxth	r2, r3
34024f5a:	4b50      	ldr	r3, [pc, #320]	@ (3402509c <DrawChar+0x548>)
34024f5c:	68db      	ldr	r3, [r3, #12]
34024f5e:	494f      	ldr	r1, [pc, #316]	@ (3402509c <DrawChar+0x548>)
34024f60:	015b      	lsls	r3, r3, #5
34024f62:	440b      	add	r3, r1
34024f64:	3304      	adds	r3, #4
34024f66:	681b      	ldr	r3, [r3, #0]
34024f68:	0b1b      	lsrs	r3, r3, #12
34024f6a:	b29b      	uxth	r3, r3
34024f6c:	011b      	lsls	r3, r3, #4
34024f6e:	b29b      	uxth	r3, r3
34024f70:	b2db      	uxtb	r3, r3
34024f72:	b29b      	uxth	r3, r3
34024f74:	4313      	orrs	r3, r2
34024f76:	b29a      	uxth	r2, r3
34024f78:	4b48      	ldr	r3, [pc, #288]	@ (3402509c <DrawChar+0x548>)
34024f7a:	68db      	ldr	r3, [r3, #12]
34024f7c:	4947      	ldr	r1, [pc, #284]	@ (3402509c <DrawChar+0x548>)
34024f7e:	015b      	lsls	r3, r3, #5
34024f80:	440b      	add	r3, r1
34024f82:	3304      	adds	r3, #4
34024f84:	681b      	ldr	r3, [r3, #0]
34024f86:	0d1b      	lsrs	r3, r3, #20
34024f88:	b29b      	uxth	r3, r3
34024f8a:	021b      	lsls	r3, r3, #8
34024f8c:	b29b      	uxth	r3, r3
34024f8e:	f403 6370 	and.w	r3, r3, #3840	@ 0xf00
34024f92:	b29b      	uxth	r3, r3
34024f94:	4313      	orrs	r3, r2
34024f96:	b299      	uxth	r1, r3
34024f98:	4b40      	ldr	r3, [pc, #256]	@ (3402509c <DrawChar+0x548>)
34024f9a:	68db      	ldr	r3, [r3, #12]
34024f9c:	4a3f      	ldr	r2, [pc, #252]	@ (3402509c <DrawChar+0x548>)
34024f9e:	015b      	lsls	r3, r3, #5
34024fa0:	4413      	add	r3, r2
34024fa2:	3304      	adds	r3, #4
34024fa4:	681b      	ldr	r3, [r3, #0]
34024fa6:	0f1b      	lsrs	r3, r3, #28
34024fa8:	b29b      	uxth	r3, r3
34024faa:	031b      	lsls	r3, r3, #12
34024fac:	b29a      	uxth	r2, r3
34024fae:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024fb2:	005b      	lsls	r3, r3, #1
34024fb4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
34024fb6:	4403      	add	r3, r0
34024fb8:	430a      	orrs	r2, r1
34024fba:	b292      	uxth	r2, r2
34024fbc:	801a      	strh	r2, [r3, #0]
      for (j = 0; j < width; j++)
34024fbe:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024fc2:	3301      	adds	r3, #1
34024fc4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024fc8:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
34024fcc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024fd0:	429a      	cmp	r2, r3
34024fd2:	f4ff af6a 	bcc.w	34024eaa <DrawChar+0x356>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb4444[0], width, 1);
34024fd6:	68b9      	ldr	r1, [r7, #8]
34024fd8:	1c4b      	adds	r3, r1, #1
34024fda:	60bb      	str	r3, [r7, #8]
34024fdc:	2301      	movs	r3, #1
34024fde:	9300      	str	r3, [sp, #0]
34024fe0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34024fe4:	6fba      	ldr	r2, [r7, #120]	@ 0x78
34024fe6:	68f8      	ldr	r0, [r7, #12]
34024fe8:	f7ff fb02 	bl	340245f0 <UTIL_LCD_FillRGBRect>
34024fec:	e045      	b.n	3402507a <DrawChar+0x526>
    }
    else /*LCD_PIXEL_FORMAT_ARGB888*/
    {
      for (j = 0; j < width; j++)
34024fee:	2300      	movs	r3, #0
34024ff0:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34024ff4:	e02f      	b.n	34025056 <DrawChar+0x502>
      {
        if(line & (1 << (width- j + offset- 1)))
34024ff6:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
34024ffa:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34024ffe:	1ad2      	subs	r2, r2, r3
34025000:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
34025002:	4413      	add	r3, r2
34025004:	3b01      	subs	r3, #1
34025006:	2201      	movs	r2, #1
34025008:	fa02 f303 	lsl.w	r3, r2, r3
3402500c:	461a      	mov	r2, r3
3402500e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
34025012:	4013      	ands	r3, r2
34025014:	2b00      	cmp	r3, #0
34025016:	d00c      	beq.n	34025032 <DrawChar+0x4de>
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].TextColor;
34025018:	4b20      	ldr	r3, [pc, #128]	@ (3402509c <DrawChar+0x548>)
3402501a:	68da      	ldr	r2, [r3, #12]
3402501c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34025020:	009b      	lsls	r3, r3, #2
34025022:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
34025024:	440b      	add	r3, r1
34025026:	491d      	ldr	r1, [pc, #116]	@ (3402509c <DrawChar+0x548>)
34025028:	0152      	lsls	r2, r2, #5
3402502a:	440a      	add	r2, r1
3402502c:	6812      	ldr	r2, [r2, #0]
3402502e:	601a      	str	r2, [r3, #0]
34025030:	e00c      	b.n	3402504c <DrawChar+0x4f8>
        }
        else
        {
          argb32[j] = DrawProp[DrawProp->LcdLayer].BackColor;
34025032:	4b1a      	ldr	r3, [pc, #104]	@ (3402509c <DrawChar+0x548>)
34025034:	68da      	ldr	r2, [r3, #12]
34025036:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
3402503a:	009b      	lsls	r3, r3, #2
3402503c:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
3402503e:	440b      	add	r3, r1
34025040:	4916      	ldr	r1, [pc, #88]	@ (3402509c <DrawChar+0x548>)
34025042:	0152      	lsls	r2, r2, #5
34025044:	440a      	add	r2, r1
34025046:	3204      	adds	r2, #4
34025048:	6812      	ldr	r2, [r2, #0]
3402504a:	601a      	str	r2, [r3, #0]
      for (j = 0; j < width; j++)
3402504c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
34025050:	3301      	adds	r3, #1
34025052:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
34025056:	f8d7 2090 	ldr.w	r2, [r7, #144]	@ 0x90
3402505a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
3402505e:	429a      	cmp	r2, r3
34025060:	d3c9      	bcc.n	34024ff6 <DrawChar+0x4a2>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, &rgb8[0], width, 1);
34025062:	68b9      	ldr	r1, [r7, #8]
34025064:	1c4b      	adds	r3, r1, #1
34025066:	60bb      	str	r3, [r7, #8]
34025068:	f107 0210 	add.w	r2, r7, #16
3402506c:	2301      	movs	r3, #1
3402506e:	9300      	str	r3, [sp, #0]
34025070:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
34025074:	68f8      	ldr	r0, [r7, #12]
34025076:	f7ff fabb 	bl	340245f0 <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
3402507a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
3402507e:	3301      	adds	r3, #1
34025080:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
34025084:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
34025088:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
3402508c:	429a      	cmp	r2, r3
3402508e:	f4ff ad98 	bcc.w	34024bc2 <DrawChar+0x6e>
    }
  }
}
34025092:	bf00      	nop
34025094:	bf00      	nop
34025096:	3798      	adds	r7, #152	@ 0x98
34025098:	46bd      	mov	sp, r7
3402509a:	bd80      	pop	{r7, pc}
3402509c:	34056640 	.word	0x34056640

340250a0 <node_convert>:
340250a0:	6982      	ldr	r2, [r0, #24]
340250a2:	8813      	ldrh	r3, [r2, #0]
340250a4:	2b00      	cmp	r3, #0
340250a6:	d048      	beq.n	3402513a <node_convert+0x9a>
340250a8:	6852      	ldr	r2, [r2, #4]
340250aa:	6851      	ldr	r1, [r2, #4]
340250ac:	b101      	cbz	r1, 340250b0 <node_convert+0x10>
340250ae:	6809      	ldr	r1, [r1, #0]
340250b0:	2b01      	cmp	r3, #1
340250b2:	f000 8147 	beq.w	34025344 <node_convert+0x2a4>
340250b6:	b5f0      	push	{r4, r5, r6, r7, lr}
340250b8:	6910      	ldr	r0, [r2, #16]
340250ba:	b083      	sub	sp, #12
340250bc:	b100      	cbz	r0, 340250c0 <node_convert+0x20>
340250be:	6800      	ldr	r0, [r0, #0]
340250c0:	688b      	ldr	r3, [r1, #8]
340250c2:	2401      	movs	r4, #1
340250c4:	0a1a      	lsrs	r2, r3, #8
340250c6:	d011      	beq.n	340250ec <node_convert+0x4c>
340250c8:	ea4f 0e82 	mov.w	lr, r2, lsl #2
340250cc:	f1ae 0e04 	sub.w	lr, lr, #4
340250d0:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
340250d4:	44a6      	add	lr, r4
340250d6:	f04e e001 	dls	lr, lr
340250da:	68cb      	ldr	r3, [r1, #12]
340250dc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
340250e0:	f853 2d04 	ldr.w	r2, [r3, #-4]!
340250e4:	fb02 f404 	mul.w	r4, r2, r4
340250e8:	f00f c007 	le	lr, 340250e0 <node_convert+0x40>
340250ec:	698a      	ldr	r2, [r1, #24]
340250ee:	6985      	ldr	r5, [r0, #24]
340250f0:	6813      	ldr	r3, [r2, #0]
340250f2:	f3c3 4c43 	ubfx	ip, r3, #17, #4
340250f6:	f1bc 0f01 	cmp.w	ip, #1
340250fa:	d020      	beq.n	3402513e <node_convert+0x9e>
340250fc:	680e      	ldr	r6, [r1, #0]
340250fe:	68ad      	ldr	r5, [r5, #8]
34025100:	2e00      	cmp	r6, #0
34025102:	d03a      	beq.n	3402517a <node_convert+0xda>
34025104:	6871      	ldr	r1, [r6, #4]
34025106:	6890      	ldr	r0, [r2, #8]
34025108:	f3c3 52c0 	ubfx	r2, r3, #23, #1
3402510c:	2900      	cmp	r1, #0
3402510e:	f000 8099 	beq.w	34025244 <node_convert+0x1a4>
34025112:	8873      	ldrh	r3, [r6, #2]
34025114:	2b00      	cmp	r3, #0
34025116:	f000 8082 	beq.w	3402521e <node_convert+0x17e>
3402511a:	680b      	ldr	r3, [r1, #0]
3402511c:	ed93 0a00 	vldr	s0, [r3]
34025120:	684b      	ldr	r3, [r1, #4]
34025122:	2a00      	cmp	r2, #0
34025124:	f000 809a 	beq.w	3402525c <node_convert+0x1bc>
34025128:	f993 3000 	ldrsb.w	r3, [r3]
3402512c:	4622      	mov	r2, r4
3402512e:	4629      	mov	r1, r5
34025130:	b003      	add	sp, #12
34025132:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34025136:	f000 b909 	b.w	3402534c <forward_lite_node_convert_integer_is8of32>
3402513a:	685b      	ldr	r3, [r3, #4]
3402513c:	deff      	udf	#255	@ 0xff
3402513e:	6806      	ldr	r6, [r0, #0]
34025140:	6890      	ldr	r0, [r2, #8]
34025142:	2e00      	cmp	r6, #0
34025144:	f000 8092 	beq.w	3402526c <node_convert+0x1cc>
34025148:	682b      	ldr	r3, [r5, #0]
3402514a:	6872      	ldr	r2, [r6, #4]
3402514c:	68a9      	ldr	r1, [r5, #8]
3402514e:	f3c3 53c0 	ubfx	r3, r3, #23, #1
34025152:	2a00      	cmp	r2, #0
34025154:	d067      	beq.n	34025226 <node_convert+0x186>
34025156:	8875      	ldrh	r5, [r6, #2]
34025158:	2d00      	cmp	r5, #0
3402515a:	d069      	beq.n	34025230 <node_convert+0x190>
3402515c:	6815      	ldr	r5, [r2, #0]
3402515e:	ed95 0a00 	vldr	s0, [r5]
34025162:	2b00      	cmp	r3, #0
34025164:	f000 80e3 	beq.w	3402532e <node_convert+0x28e>
34025168:	6853      	ldr	r3, [r2, #4]
3402516a:	f993 3000 	ldrsb.w	r3, [r3]
3402516e:	4622      	mov	r2, r4
34025170:	b003      	add	sp, #12
34025172:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34025176:	f000 b8ed 	b.w	34025354 <forward_lite_node_convert_integer_if32os8>
3402517a:	f3c3 11c6 	ubfx	r1, r3, #7, #7
3402517e:	f003 067f 	and.w	r6, r3, #127	@ 0x7f
34025182:	1b8e      	subs	r6, r1, r6
34025184:	3640      	adds	r6, #64	@ 0x40
34025186:	f3c3 53c0 	ubfx	r3, r3, #23, #1
3402518a:	2908      	cmp	r1, #8
3402518c:	6890      	ldr	r0, [r2, #8]
3402518e:	4629      	mov	r1, r5
34025190:	4622      	mov	r2, r4
34025192:	eba6 0603 	sub.w	r6, r6, r3
34025196:	f000 80bc 	beq.w	34025312 <node_convert+0x272>
3402519a:	f000 fd57 	bl	34025c4c <st_int16_to_f32>
3402519e:	b3e6      	cbz	r6, 3402521a <node_convert+0x17a>
340251a0:	ee07 6a90 	vmov	s15, r6
340251a4:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
340251a8:	eef8 0ae7 	vcvt.f32.s32	s1, s15
340251ac:	f004 fd74 	bl	34029c98 <powf>
340251b0:	b39c      	cbz	r4, 3402521a <node_convert+0x17a>
340251b2:	1e63      	subs	r3, r4, #1
340251b4:	2b02      	cmp	r3, #2
340251b6:	f240 80c1 	bls.w	3402533c <node_convert+0x29c>
340251ba:	ee10 3a10 	vmov	r3, s0
340251be:	08a2      	lsrs	r2, r4, #2
340251c0:	eea4 3b10 	vdup.32	q2, r3
340251c4:	f042 e001 	dls	lr, r2
340251c8:	462b      	mov	r3, r5
340251ca:	ed93 7f00 	ldc	15, cr7, [r3]
340251ce:	461a      	mov	r2, r3
340251d0:	ff06 6d54 	vmul.f32	q3, q3, q2
340251d4:	3310      	adds	r3, #16
340251d6:	ed82 7f00 	stc	15, cr7, [r2]
340251da:	f00f c00b 	le	lr, 340251ca <node_convert+0x12a>
340251de:	f024 0303 	bic.w	r3, r4, #3
340251e2:	429c      	cmp	r4, r3
340251e4:	eb05 0583 	add.w	r5, r5, r3, lsl #2
340251e8:	d017      	beq.n	3402521a <node_convert+0x17a>
340251ea:	edd5 7a00 	vldr	s15, [r5]
340251ee:	ee67 7a80 	vmul.f32	s15, s15, s0
340251f2:	1c5a      	adds	r2, r3, #1
340251f4:	4294      	cmp	r4, r2
340251f6:	edc5 7a00 	vstr	s15, [r5]
340251fa:	d90e      	bls.n	3402521a <node_convert+0x17a>
340251fc:	edd5 7a01 	vldr	s15, [r5, #4]
34025200:	ee67 7a80 	vmul.f32	s15, s15, s0
34025204:	3302      	adds	r3, #2
34025206:	429c      	cmp	r4, r3
34025208:	edc5 7a01 	vstr	s15, [r5, #4]
3402520c:	d905      	bls.n	3402521a <node_convert+0x17a>
3402520e:	edd5 7a02 	vldr	s15, [r5, #8]
34025212:	ee67 7a80 	vmul.f32	s15, s15, s0
34025216:	edc5 7a02 	vstr	s15, [r5, #8]
3402521a:	b003      	add	sp, #12
3402521c:	bdf0      	pop	{r4, r5, r6, r7, pc}
3402521e:	b19a      	cbz	r2, 34025248 <node_convert+0x1a8>
34025220:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34025224:	e782      	b.n	3402512c <node_convert+0x8c>
34025226:	b12b      	cbz	r3, 34025234 <node_convert+0x194>
34025228:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3402522c:	4613      	mov	r3, r2
3402522e:	e79e      	b.n	3402516e <node_convert+0xce>
34025230:	2b00      	cmp	r3, #0
34025232:	d17f      	bne.n	34025334 <node_convert+0x294>
34025234:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34025238:	4622      	mov	r2, r4
3402523a:	b003      	add	sp, #12
3402523c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34025240:	f000 b88a 	b.w	34025358 <forward_lite_node_convert_integer_if32ou8>
34025244:	2a00      	cmp	r2, #0
34025246:	d167      	bne.n	34025318 <node_convert+0x278>
34025248:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3402524c:	2300      	movs	r3, #0
3402524e:	4622      	mov	r2, r4
34025250:	4629      	mov	r1, r5
34025252:	b003      	add	sp, #12
34025254:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34025258:	f000 b87a 	b.w	34025350 <forward_lite_node_convert_integer_iu8of32>
3402525c:	4622      	mov	r2, r4
3402525e:	4629      	mov	r1, r5
34025260:	781b      	ldrb	r3, [r3, #0]
34025262:	b003      	add	sp, #12
34025264:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
34025268:	f000 b872 	b.w	34025350 <forward_lite_node_convert_integer_iu8of32>
3402526c:	682a      	ldr	r2, [r5, #0]
3402526e:	f3c2 17c6 	ubfx	r7, r2, #7, #7
34025272:	f002 037f 	and.w	r3, r2, #127	@ 0x7f
34025276:	1afb      	subs	r3, r7, r3
34025278:	3340      	adds	r3, #64	@ 0x40
3402527a:	f3c2 52c0 	ubfx	r2, r2, #23, #1
3402527e:	1a9b      	subs	r3, r3, r2
34025280:	d03e      	beq.n	34025300 <node_convert+0x260>
34025282:	425b      	negs	r3, r3
34025284:	ee00 3a90 	vmov	s1, r3
34025288:	eeb0 0a00 	vmov.f32	s0, #0	@ 0x40000000  2.0
3402528c:	eef8 0ae0 	vcvt.f32.s32	s1, s1
34025290:	9001      	str	r0, [sp, #4]
34025292:	f004 fd01 	bl	34029c98 <powf>
34025296:	9801      	ldr	r0, [sp, #4]
34025298:	b394      	cbz	r4, 34025300 <node_convert+0x260>
3402529a:	1e63      	subs	r3, r4, #1
3402529c:	2b02      	cmp	r3, #2
3402529e:	d94f      	bls.n	34025340 <node_convert+0x2a0>
340252a0:	ee10 2a10 	vmov	r2, s0
340252a4:	08a3      	lsrs	r3, r4, #2
340252a6:	f043 e001 	dls	lr, r3
340252aa:	eea4 2b10 	vdup.32	q2, r2
340252ae:	4603      	mov	r3, r0
340252b0:	ed93 7f00 	ldc	15, cr7, [r3]
340252b4:	461a      	mov	r2, r3
340252b6:	ff06 6d54 	vmul.f32	q3, q3, q2
340252ba:	3310      	adds	r3, #16
340252bc:	ed82 7f00 	stc	15, cr7, [r2]
340252c0:	f00f c00b 	le	lr, 340252b0 <node_convert+0x210>
340252c4:	f024 0603 	bic.w	r6, r4, #3
340252c8:	42a6      	cmp	r6, r4
340252ca:	eb00 0386 	add.w	r3, r0, r6, lsl #2
340252ce:	d017      	beq.n	34025300 <node_convert+0x260>
340252d0:	edd3 7a00 	vldr	s15, [r3]
340252d4:	ee67 7a80 	vmul.f32	s15, s15, s0
340252d8:	1c72      	adds	r2, r6, #1
340252da:	42a2      	cmp	r2, r4
340252dc:	edc3 7a00 	vstr	s15, [r3]
340252e0:	d20e      	bcs.n	34025300 <node_convert+0x260>
340252e2:	edd3 7a01 	vldr	s15, [r3, #4]
340252e6:	ee67 7a80 	vmul.f32	s15, s15, s0
340252ea:	3602      	adds	r6, #2
340252ec:	42b4      	cmp	r4, r6
340252ee:	edc3 7a01 	vstr	s15, [r3, #4]
340252f2:	d905      	bls.n	34025300 <node_convert+0x260>
340252f4:	edd3 7a02 	vldr	s15, [r3, #8]
340252f8:	ee67 7a80 	vmul.f32	s15, s15, s0
340252fc:	edc3 7a02 	vstr	s15, [r3, #8]
34025300:	2f08      	cmp	r7, #8
34025302:	d00d      	beq.n	34025320 <node_convert+0x280>
34025304:	4622      	mov	r2, r4
34025306:	68a9      	ldr	r1, [r5, #8]
34025308:	b003      	add	sp, #12
3402530a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3402530e:	f000 ba07 	b.w	34025720 <st_f32_to_int16>
34025312:	f000 fcdd 	bl	34025cd0 <st_int8_to_f32>
34025316:	e742      	b.n	3402519e <node_convert+0xfe>
34025318:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
3402531c:	460b      	mov	r3, r1
3402531e:	e705      	b.n	3402512c <node_convert+0x8c>
34025320:	4622      	mov	r2, r4
34025322:	68a9      	ldr	r1, [r5, #8]
34025324:	b003      	add	sp, #12
34025326:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
3402532a:	f000 bacd 	b.w	340258c8 <st_f32_to_int8>
3402532e:	6853      	ldr	r3, [r2, #4]
34025330:	781b      	ldrb	r3, [r3, #0]
34025332:	e781      	b.n	34025238 <node_convert+0x198>
34025334:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34025338:	462b      	mov	r3, r5
3402533a:	e718      	b.n	3402516e <node_convert+0xce>
3402533c:	2300      	movs	r3, #0
3402533e:	e754      	b.n	340251ea <node_convert+0x14a>
34025340:	4603      	mov	r3, r0
34025342:	e7c5      	b.n	340252d0 <node_convert+0x230>
34025344:	2300      	movs	r3, #0
34025346:	685b      	ldr	r3, [r3, #4]
34025348:	deff      	udf	#255	@ 0xff
3402534a:	bf00      	nop

3402534c <forward_lite_node_convert_integer_is8of32>:
3402534c:	f000 b806 	b.w	3402535c <lite_convert_is8of32>

34025350 <forward_lite_node_convert_integer_iu8of32>:
34025350:	f000 b83a 	b.w	340253c8 <lite_convert_iu8of32>

34025354 <forward_lite_node_convert_integer_if32os8>:
34025354:	f000 b860 	b.w	34025418 <lite_convert_if32os8>

34025358 <forward_lite_node_convert_integer_if32ou8>:
34025358:	f000 b956 	b.w	34025608 <lite_convert_if32ou8>

3402535c <lite_convert_is8of32>:
3402535c:	2a00      	cmp	r2, #0
3402535e:	dd31      	ble.n	340253c4 <lite_convert_is8of32+0x68>
34025360:	b570      	push	{r4, r5, r6, lr}
34025362:	1885      	adds	r5, r0, r2
34025364:	1e50      	subs	r0, r2, #1
34025366:	f020 0003 	bic.w	r0, r0, #3
3402536a:	1f16      	subs	r6, r2, #4
3402536c:	ea4f 0c92 	mov.w	ip, r2, lsr #2
34025370:	ee10 4a10 	vmov	r4, s0
34025374:	1a36      	subs	r6, r6, r0
34025376:	f10c 0c01 	add.w	ip, ip, #1
3402537a:	e008      	b.n	3402538e <lite_convert_is8of32+0x32>
3402537c:	4608      	mov	r0, r1
3402537e:	4296      	cmp	r6, r2
34025380:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34025384:	ed80 7f00 	stc	15, cr7, [r0]
34025388:	f101 0110 	add.w	r1, r1, #16
3402538c:	d019      	beq.n	340253c2 <lite_convert_is8of32+0x66>
3402538e:	f022 e801 	bfcsel	0, 34025394 <lite_convert_is8of32+0x38>, 4, hi
34025392:	1aa8      	subs	r0, r5, r2
34025394:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34025398:	ed90 6f00 	ldc	15, cr6, [r0]
3402539c:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
340253a0:	ffbb 6646 	vcvt.f32.s32	q3, q3
340253a4:	f1bc 0c01 	subs.w	ip, ip, #1
340253a8:	eefd ea10 	vmrs	lr, <impl def 0xd>
340253ac:	ee37 6e64 	cdp	14, 3, cr6, cr7, cr4, {3}
340253b0:	f1a2 0204 	sub.w	r2, r2, #4
340253b4:	d1e2      	bne.n	3402537c <lite_convert_is8of32+0x20>
340253b6:	eeed ea10 	vmsr	<impl def 0xd>, lr
340253ba:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340253be:	ed81 7f00 	stc	15, cr7, [r1]
340253c2:	bd70      	pop	{r4, r5, r6, pc}
340253c4:	4770      	bx	lr
340253c6:	bf00      	nop

340253c8 <lite_convert_iu8of32>:
340253c8:	2a00      	cmp	r2, #0
340253ca:	dd22      	ble.n	34025412 <lite_convert_iu8of32+0x4a>
340253cc:	b530      	push	{r4, r5, lr}
340253ce:	f102 3eff 	add.w	lr, r2, #4294967295
340253d2:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
340253d6:	f10e 0e01 	add.w	lr, lr, #1
340253da:	ee10 5a10 	vmov	r5, s0
340253de:	f04e e001 	dls	lr, lr
340253e2:	1884      	adds	r4, r0, r2
340253e4:	f022 e801 	bfcsel	0, 340253ea <lite_convert_iu8of32+0x22>, 4, hi
340253e8:	1aa0      	subs	r0, r4, r2
340253ea:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340253ee:	fd90 6f00 	ldc2	15, cr6, [r0]
340253f2:	ee26 7f63 	cdp	15, 2, cr7, cr6, cr3, {3}
340253f6:	ffbb 6646 	vcvt.f32.s32	q3, q3
340253fa:	4608      	mov	r0, r1
340253fc:	ee37 6e65 	cdp	14, 3, cr6, cr7, cr5, {3}
34025400:	3a04      	subs	r2, #4
34025402:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34025406:	ed80 7f00 	stc	15, cr7, [r0]
3402540a:	3110      	adds	r1, #16
3402540c:	f00f c017 	le	lr, 340253e4 <lite_convert_iu8of32+0x1c>
34025410:	bd30      	pop	{r4, r5, pc}
34025412:	4770      	bx	lr
34025414:	0000      	movs	r0, r0
	...

34025418 <lite_convert_if32os8>:
34025418:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3402541c:	ee07 3a10 	vmov	s14, r3
34025420:	eec7 7a80 	vdiv.f32	s15, s15, s0
34025424:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
34025428:	ee17 ca90 	vmov	ip, s15
3402542c:	b500      	push	{lr}
3402542e:	ed2d 8b10 	vpush	{d8-d15}
34025432:	ee17 3a10 	vmov	r3, s14
34025436:	eea8 cb10 	vdup.32	q4, ip
3402543a:	b09d      	sub	sp, #116	@ 0x74
3402543c:	eea0 3b10 	vdup.32	q0, r3
34025440:	2a00      	cmp	r2, #0
34025442:	ab10      	add	r3, sp, #64	@ 0x40
34025444:	ed83 9f00 	stc	15, cr9, [r3]
34025448:	dd6a      	ble.n	34025520 <lite_convert_if32os8+0x108>
3402544a:	2a0f      	cmp	r2, #15
3402544c:	dd6d      	ble.n	3402552a <lite_convert_if32os8+0x112>
3402544e:	f1a2 0c10 	sub.w	ip, r2, #16
34025452:	ea4f 131c 	mov.w	r3, ip, lsr #4
34025456:	3301      	adds	r3, #1
34025458:	f1bc 0f00 	cmp.w	ip, #0
3402545c:	f04f 0e01 	mov.w	lr, #1
34025460:	ed9f 2b61 	vldr	d2, [pc, #388]	@ 340255e8 <lite_convert_if32os8+0x1d0>
34025464:	ed9f 3b62 	vldr	d3, [pc, #392]	@ 340255f0 <lite_convert_if32os8+0x1d8>
34025468:	bfa8      	it	ge
3402546a:	469e      	movge	lr, r3
3402546c:	ab14      	add	r3, sp, #80	@ 0x50
3402546e:	ed9f 4b62 	vldr	d4, [pc, #392]	@ 340255f8 <lite_convert_if32os8+0x1e0>
34025472:	ed9f 5b63 	vldr	d5, [pc, #396]	@ 34025600 <lite_convert_if32os8+0x1e8>
34025476:	f04e e001 	dls	lr, lr
3402547a:	ef22 6152 	vorr	q3, q1, q1
3402547e:	ed83 9f00 	stc	15, cr9, [r3]
34025482:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
34025486:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
3402548a:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3402548e:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
34025492:	466b      	mov	r3, sp
34025494:	ec8d 8b10 	vstmia	sp, {d8-d15}
34025498:	ed93 df00 	ldc	15, cr13, [r3]
3402549c:	ab14      	add	r3, sp, #80	@ 0x50
3402549e:	ed93 ff00 	ldc	15, cr15, [r3]
340254a2:	ef20 a150 	vorr	q5, q0, q0
340254a6:	ef0c ac5e 	vfma.f32	q5, q6, q7
340254aa:	ffbb a04a 	vcvta.s32.f32	q5, q5
340254ae:	ab04      	add	r3, sp, #16
340254b0:	ed93 df00 	ldc	15, cr13, [r3]
340254b4:	ee37 6e0b 	cdp	14, 3, cr6, cr7, cr11, {0}
340254b8:	ef20 a150 	vorr	q5, q0, q0
340254bc:	ef0c ac5e 	vfma.f32	q5, q6, q7
340254c0:	ffbb a04a 	vcvta.s32.f32	q5, q5
340254c4:	ab08      	add	r3, sp, #32
340254c6:	ee37 2e0b 	cdp	14, 3, cr2, cr7, cr11, {0}
340254ca:	ef20 c150 	vorr	q6, q0, q0
340254ce:	ed93 bf00 	ldc	15, cr11, [r3]
340254d2:	ab0c      	add	r3, sp, #48	@ 0x30
340254d4:	ef0a cc5e 	vfma.f32	q6, q5, q7
340254d8:	ed93 9f00 	ldc	15, cr9, [r3]
340254dc:	ef20 a150 	vorr	q5, q0, q0
340254e0:	ffbb c04c 	vcvta.s32.f32	q6, q6
340254e4:	ef08 ac5e 	vfma.f32	q5, q4, q7
340254e8:	ee37 7e0d 	cdp	14, 3, cr7, cr7, cr13, {0}
340254ec:	ffbb a04a 	vcvta.s32.f32	q5, q5
340254f0:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
340254f4:	ee37 3e0b 	cdp	14, 3, cr3, cr7, cr11, {0}
340254f8:	f002 e801 	bfcsel	0, 340254fe <lite_convert_if32os8+0xe6>, 4, eq
340254fc:	468c      	mov	ip, r1
340254fe:	ee33 5e03 	cdp	14, 3, cr5, cr3, cr3, {0}
34025502:	3110      	adds	r1, #16
34025504:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
34025508:	ed8c 5e00 	stc	14, cr5, [ip]
3402550c:	3a10      	subs	r2, #16
3402550e:	f00f c049 	le	lr, 34025482 <lite_convert_if32os8+0x6a>
34025512:	ab14      	add	r3, sp, #80	@ 0x50
34025514:	ed83 5e00 	stc	14, cr5, [r3]
34025518:	ab18      	add	r3, sp, #96	@ 0x60
3402551a:	ed83 3e80 	stc	14, cr3, [r3, #512]	@ 0x200
3402551e:	b9a2      	cbnz	r2, 3402554a <lite_convert_if32os8+0x132>
34025520:	b01d      	add	sp, #116	@ 0x74
34025522:	ecbd 8b10 	vpop	{d8-d15}
34025526:	f85d fb04 	ldr.w	pc, [sp], #4
3402552a:	ed9f 4b2f 	vldr	d4, [pc, #188]	@ 340255e8 <lite_convert_if32os8+0x1d0>
3402552e:	ed9f 5b30 	vldr	d5, [pc, #192]	@ 340255f0 <lite_convert_if32os8+0x1d8>
34025532:	ed9f 6b31 	vldr	d6, [pc, #196]	@ 340255f8 <lite_convert_if32os8+0x1e0>
34025536:	ed9f 7b32 	vldr	d7, [pc, #200]	@ 34025600 <lite_convert_if32os8+0x1e8>
3402553a:	ab18      	add	r3, sp, #96	@ 0x60
3402553c:	ed83 5e80 	stc	14, cr5, [r3, #512]	@ 0x200
34025540:	ab14      	add	r3, sp, #80	@ 0x50
34025542:	ed83 7e00 	stc	14, cr7, [r3]
34025546:	ef24 6154 	vorr	q3, q2, q2
3402554a:	f002 e801 	bfcsel	0, 34025550 <lite_convert_if32os8+0x138>, 4, eq
3402554e:	aa10      	add	r2, sp, #64	@ 0x40
34025550:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
34025554:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
34025558:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3402555c:	fc90 9f61 	ldc2	15, cr9, [r0], {97}	@ 0x61
34025560:	ed92 5f00 	ldc	15, cr5, [r2]
34025564:	ef20 2150 	vorr	q1, q0, q0
34025568:	ef08 2c54 	vfma.f32	q1, q4, q2
3402556c:	ffbb 4042 	vcvta.s32.f32	q2, q1
34025570:	466a      	mov	r2, sp
34025572:	ee37 6e05 	cdp	14, 3, cr6, cr7, cr5, {0}
34025576:	ed82 7e80 	stc	14, cr7, [r2, #512]	@ 0x200
3402557a:	aa10      	add	r2, sp, #64	@ 0x40
3402557c:	ed92 5f00 	ldc	15, cr5, [r2]
34025580:	ef20 2150 	vorr	q1, q0, q0
34025584:	ef0a 2c54 	vfma.f32	q1, q5, q2
34025588:	aa18      	add	r2, sp, #96	@ 0x60
3402558a:	ffbb 6042 	vcvta.s32.f32	q3, q1
3402558e:	ed92 3e80 	ldc	14, cr3, [r2, #512]	@ 0x200
34025592:	ee37 2e07 	cdp	14, 3, cr2, cr7, cr7, {0}
34025596:	aa10      	add	r2, sp, #64	@ 0x40
34025598:	ef22 4152 	vorr	q2, q1, q1
3402559c:	ed92 3f00 	ldc	15, cr3, [r2]
340255a0:	ef20 6150 	vorr	q3, q0, q0
340255a4:	ef0e 0c52 	vfma.f32	q0, q7, q1
340255a8:	ef0c 6c52 	vfma.f32	q3, q6, q1
340255ac:	466a      	mov	r2, sp
340255ae:	ef20 2150 	vorr	q1, q0, q0
340255b2:	ffbb 0046 	vcvta.s32.f32	q0, q3
340255b6:	ffbb 2042 	vcvta.s32.f32	q1, q1
340255ba:	ed92 7e80 	ldc	14, cr7, [r2, #512]	@ 0x200
340255be:	aa14      	add	r2, sp, #80	@ 0x50
340255c0:	ee37 5e03 	cdp	14, 3, cr5, cr7, cr3, {0}
340255c4:	ee37 7e01 	cdp	14, 3, cr7, cr7, cr1, {0}
340255c8:	ed92 3e00 	ldc	14, cr3, [r2]
340255cc:	ee33 2e07 	cdp	14, 3, cr2, cr3, cr7, {0}
340255d0:	ee33 3e05 	cdp	14, 3, cr3, cr3, cr5, {0}
340255d4:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340255d8:	ed81 3e00 	stc	14, cr3, [r1]
340255dc:	b01d      	add	sp, #116	@ 0x74
340255de:	ecbd 8b10 	vpop	{d8-d15}
340255e2:	f85d fb04 	ldr.w	pc, [sp], #4
340255e6:	bf00      	nop
	...

34025608 <lite_convert_if32ou8>:
34025608:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
3402560c:	2a00      	cmp	r2, #0
3402560e:	eec7 7a80 	vdiv.f32	s15, s15, s0
34025612:	dd72      	ble.n	340256fa <lite_convert_if32ou8+0xf2>
34025614:	ee07 3a10 	vmov	s14, r3
34025618:	eeb8 7a47 	vcvt.f32.u32	s14, s14
3402561c:	ee17 ca90 	vmov	ip, s15
34025620:	b500      	push	{lr}
34025622:	ed2d 8b10 	vpush	{d8-d15}
34025626:	ee17 3a10 	vmov	r3, s14
3402562a:	eea8 cb10 	vdup.32	q4, ip
3402562e:	ed9f 6b34 	vldr	d6, [pc, #208]	@ 34025700 <lite_convert_if32ou8+0xf8>
34025632:	ed9f 7b35 	vldr	d7, [pc, #212]	@ 34025708 <lite_convert_if32ou8+0x100>
34025636:	f102 3eff 	add.w	lr, r2, #4294967295
3402563a:	b095      	sub	sp, #84	@ 0x54
3402563c:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
34025640:	eea0 3b10 	vdup.32	q0, r3
34025644:	f10e 0e01 	add.w	lr, lr, #1
34025648:	ab10      	add	r3, sp, #64	@ 0x40
3402564a:	ed9f 2b31 	vldr	d2, [pc, #196]	@ 34025710 <lite_convert_if32ou8+0x108>
3402564e:	ed9f 3b32 	vldr	d3, [pc, #200]	@ 34025718 <lite_convert_if32ou8+0x110>
34025652:	f04e e001 	dls	lr, lr
34025656:	ef26 4156 	vorr	q2, q3, q3
3402565a:	ed83 9f00 	stc	15, cr9, [r3]
3402565e:	4411      	add	r1, r2
34025660:	fc90 9f01 	ldc2	15, cr9, [r0], {1}
34025664:	fc90 9f21 	ldc2	15, cr9, [r0], {33}	@ 0x21
34025668:	fc90 9f41 	ldc2	15, cr9, [r0], {65}	@ 0x41
3402566c:	fcb0 9f61 	ldc2	15, cr9, [r0], #388	@ 0x184
34025670:	466b      	mov	r3, sp
34025672:	ec8d 8b10 	vstmia	sp, {d8-d15}
34025676:	ed93 df00 	ldc	15, cr13, [r3]
3402567a:	ab10      	add	r3, sp, #64	@ 0x40
3402567c:	ed93 ff00 	ldc	15, cr15, [r3]
34025680:	ef20 a150 	vorr	q5, q0, q0
34025684:	ef0c ac5e 	vfma.f32	q5, q6, q7
34025688:	ffbb a0ca 	vcvta.u32.f32	q5, q5
3402568c:	ab04      	add	r3, sp, #16
3402568e:	ed93 df00 	ldc	15, cr13, [r3]
34025692:	fe37 4e0b 	cdp2	14, 3, cr4, cr7, cr11, {0}
34025696:	ef20 a150 	vorr	q5, q0, q0
3402569a:	ef0c ac5e 	vfma.f32	q5, q6, q7
3402569e:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340256a2:	ab08      	add	r3, sp, #32
340256a4:	fe37 6e0b 	cdp2	14, 3, cr6, cr7, cr11, {0}
340256a8:	ef20 c150 	vorr	q6, q0, q0
340256ac:	ed93 bf00 	ldc	15, cr11, [r3]
340256b0:	ab0c      	add	r3, sp, #48	@ 0x30
340256b2:	ef0a cc5e 	vfma.f32	q6, q5, q7
340256b6:	ed93 9f00 	ldc	15, cr9, [r3]
340256ba:	ef20 a150 	vorr	q5, q0, q0
340256be:	ffbb c0cc 	vcvta.u32.f32	q6, q6
340256c2:	ef08 ac5e 	vfma.f32	q5, q4, q7
340256c6:	fe37 5e0d 	cdp2	14, 3, cr5, cr7, cr13, {0}
340256ca:	ffbb a0ca 	vcvta.u32.f32	q5, q5
340256ce:	fe33 2e05 	cdp2	14, 3, cr2, cr3, cr5, {0}
340256d2:	fe37 7e0b 	cdp2	14, 3, cr7, cr7, cr11, {0}
340256d6:	f022 e801 	bfcsel	0, 340256dc <lite_convert_if32ou8+0xd4>, 4, hi
340256da:	fe33 3e07 	cdp2	14, 3, cr3, cr3, cr7, {0}
340256de:	eba1 0c02 	sub.w	ip, r1, r2
340256e2:	fe71 0f4d 	cdp2	15, 7, cr0, cr1, cr13, {2}
340256e6:	ed8c 3e00 	stc	14, cr3, [ip]
340256ea:	3a10      	subs	r2, #16
340256ec:	f00f c049 	le	lr, 34025660 <lite_convert_if32ou8+0x58>
340256f0:	b015      	add	sp, #84	@ 0x54
340256f2:	ecbd 8b10 	vpop	{d8-d15}
340256f6:	f85d fb04 	ldr.w	pc, [sp], #4
340256fa:	4770      	bx	lr
340256fc:	f3af 8000 	nop.w
	...

34025720 <st_f32_to_int16>:
34025720:	b570      	push	{r4, r5, r6, lr}
34025722:	08d5      	lsrs	r5, r2, #3
34025724:	ed2d 8b08 	vpush	{d8-d11}
34025728:	d022      	beq.n	34025770 <st_f32_to_int16+0x50>
3402572a:	460c      	mov	r4, r1
3402572c:	ed9f 6b60 	vldr	d6, [pc, #384]	@ 340258b0 <st_f32_to_int16+0x190>
34025730:	ed9f 7b61 	vldr	d7, [pc, #388]	@ 340258b8 <st_f32_to_int16+0x198>
34025734:	4684      	mov	ip, r0
34025736:	f045 e001 	dls	lr, r5
3402573a:	4b61      	ldr	r3, [pc, #388]	@ (340258c0 <st_f32_to_int16+0x1a0>)
3402573c:	fc9c 9f00 	ldc2	15, cr9, [ip], {0}
34025740:	fcbc 9f20 	ldc2	15, cr9, [ip], #128	@ 0x80
34025744:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
34025748:	ee3b 4e63 	cdp	14, 3, cr4, cr11, cr3, {3}
3402574c:	ffbb 2042 	vcvta.s32.f32	q1, q1
34025750:	ffbb 4044 	vcvta.s32.f32	q2, q2
34025754:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
34025758:	4626      	mov	r6, r4
3402575a:	ee37 7e05 	cdp	14, 3, cr7, cr7, cr5, {0}
3402575e:	3410      	adds	r4, #16
34025760:	ed86 7e80 	stc	14, cr7, [r6, #512]	@ 0x200
34025764:	f00f c017 	le	lr, 3402573c <st_f32_to_int16+0x1c>
34025768:	eb00 1045 	add.w	r0, r0, r5, lsl #5
3402576c:	eb01 1105 	add.w	r1, r1, r5, lsl #4
34025770:	f012 0207 	ands.w	r2, r2, #7
34025774:	f000 8097 	beq.w	340258a6 <st_f32_to_int16+0x186>
34025778:	edd0 5a00 	vldr	s11, [r0]
3402577c:	ed9f 6a51 	vldr	s12, [pc, #324]	@ 340258c4 <st_f32_to_int16+0x1a4>
34025780:	ee65 5a86 	vmul.f32	s11, s11, s12
34025784:	eef5 5ac0 	vcmpe.f32	s11, #0.0
34025788:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
3402578c:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
34025790:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025794:	fe77 7a26 	vselgt.f32	s15, s14, s13
34025798:	ee77 7aa5 	vadd.f32	s15, s15, s11
3402579c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340257a0:	ee17 3a90 	vmov	r3, s15
340257a4:	f303 030f 	ssat	r3, #16, r3
340257a8:	2a01      	cmp	r2, #1
340257aa:	800b      	strh	r3, [r1, #0]
340257ac:	d07b      	beq.n	340258a6 <st_f32_to_int16+0x186>
340257ae:	edd0 7a01 	vldr	s15, [r0, #4]
340257b2:	ee67 7a86 	vmul.f32	s15, s15, s12
340257b6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340257ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340257be:	fe77 5a26 	vselgt.f32	s11, s14, s13
340257c2:	ee77 7aa5 	vadd.f32	s15, s15, s11
340257c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340257ca:	ee17 3a90 	vmov	r3, s15
340257ce:	f303 030f 	ssat	r3, #16, r3
340257d2:	2a02      	cmp	r2, #2
340257d4:	804b      	strh	r3, [r1, #2]
340257d6:	d066      	beq.n	340258a6 <st_f32_to_int16+0x186>
340257d8:	edd0 7a02 	vldr	s15, [r0, #8]
340257dc:	ee67 7a86 	vmul.f32	s15, s15, s12
340257e0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340257e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340257e8:	fe77 5a26 	vselgt.f32	s11, s14, s13
340257ec:	ee77 7aa5 	vadd.f32	s15, s15, s11
340257f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340257f4:	ee17 3a90 	vmov	r3, s15
340257f8:	f303 030f 	ssat	r3, #16, r3
340257fc:	2a03      	cmp	r2, #3
340257fe:	808b      	strh	r3, [r1, #4]
34025800:	d051      	beq.n	340258a6 <st_f32_to_int16+0x186>
34025802:	edd0 7a03 	vldr	s15, [r0, #12]
34025806:	ee67 7a86 	vmul.f32	s15, s15, s12
3402580a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3402580e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025812:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025816:	ee77 7aa5 	vadd.f32	s15, s15, s11
3402581a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3402581e:	ee17 3a90 	vmov	r3, s15
34025822:	f303 030f 	ssat	r3, #16, r3
34025826:	2a04      	cmp	r2, #4
34025828:	80cb      	strh	r3, [r1, #6]
3402582a:	d03c      	beq.n	340258a6 <st_f32_to_int16+0x186>
3402582c:	edd0 7a04 	vldr	s15, [r0, #16]
34025830:	ee67 7a86 	vmul.f32	s15, s15, s12
34025834:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025838:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402583c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025840:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025844:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025848:	ee17 3a90 	vmov	r3, s15
3402584c:	f303 030f 	ssat	r3, #16, r3
34025850:	3a05      	subs	r2, #5
34025852:	810b      	strh	r3, [r1, #8]
34025854:	d027      	beq.n	340258a6 <st_f32_to_int16+0x186>
34025856:	edd0 7a05 	vldr	s15, [r0, #20]
3402585a:	ee67 7a86 	vmul.f32	s15, s15, s12
3402585e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025862:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025866:	fe77 5a26 	vselgt.f32	s11, s14, s13
3402586a:	ee77 7aa5 	vadd.f32	s15, s15, s11
3402586e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025872:	ee17 3a90 	vmov	r3, s15
34025876:	f303 030f 	ssat	r3, #16, r3
3402587a:	2a01      	cmp	r2, #1
3402587c:	814b      	strh	r3, [r1, #10]
3402587e:	d012      	beq.n	340258a6 <st_f32_to_int16+0x186>
34025880:	edd0 7a06 	vldr	s15, [r0, #24]
34025884:	ee67 7a86 	vmul.f32	s15, s15, s12
34025888:	eef5 7ac0 	vcmpe.f32	s15, #0.0
3402588c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025890:	fe37 7a26 	vselgt.f32	s14, s14, s13
34025894:	ee37 7a27 	vadd.f32	s14, s14, s15
34025898:	eebd 7ac7 	vcvt.s32.f32	s14, s14
3402589c:	ee17 3a10 	vmov	r3, s14
340258a0:	f303 030f 	ssat	r3, #16, r3
340258a4:	818b      	strh	r3, [r1, #12]
340258a6:	ecbd 8b08 	vpop	{d8-d11}
340258aa:	bd70      	pop	{r4, r5, r6, pc}
340258ac:	f3af 8000 	nop.w
	...
340258c0:	46fffe00 	.word	0x46fffe00
340258c4:	47000000 	.word	0x47000000

340258c8 <st_f32_to_int8>:
340258c8:	b570      	push	{r4, r5, r6, lr}
340258ca:	0915      	lsrs	r5, r2, #4
340258cc:	ed2d 8b10 	vpush	{d8-d15}
340258d0:	f000 81a5 	beq.w	34025c1e <st_f32_to_int8+0x356>
340258d4:	ed9f 0bd4 	vldr	d0, [pc, #848]	@ 34025c28 <st_f32_to_int8+0x360>
340258d8:	ed9f 1bd5 	vldr	d1, [pc, #852]	@ 34025c30 <st_f32_to_int8+0x368>
340258dc:	ea4f 1e05 	mov.w	lr, r5, lsl #4
340258e0:	f1ae 0e10 	sub.w	lr, lr, #16
340258e4:	ea4f 1e1e 	mov.w	lr, lr, lsr #4
340258e8:	f10e 0e01 	add.w	lr, lr, #1
340258ec:	ed9f 4bd2 	vldr	d4, [pc, #840]	@ 34025c38 <st_f32_to_int8+0x370>
340258f0:	ed9f 5bd3 	vldr	d5, [pc, #844]	@ 34025c40 <st_f32_to_int8+0x378>
340258f4:	f04f 4386 	mov.w	r3, #1124073472	@ 0x43000000
340258f8:	f04e e001 	dls	lr, lr
340258fc:	4684      	mov	ip, r0
340258fe:	ef20 6150 	vorr	q3, q0, q0
34025902:	eb01 1405 	add.w	r4, r1, r5, lsl #4
34025906:	fc9c 9f01 	ldc2	15, cr9, [ip], {1}
3402590a:	fc9c 9f21 	ldc2	15, cr9, [ip], {33}	@ 0x21
3402590e:	fc9c 9f41 	ldc2	15, cr9, [ip], {65}	@ 0x41
34025912:	fcbc 9f61 	ldc2	15, cr9, [ip], #388	@ 0x184
34025916:	ee39 2e63 	cdp	14, 3, cr2, cr9, cr3, {3}
3402591a:	ffbb 2042 	vcvta.s32.f32	q1, q1
3402591e:	ee37 6e03 	cdp	14, 3, cr6, cr7, cr3, {0}
34025922:	ee3b 2e63 	cdp	14, 3, cr2, cr11, cr3, {3}
34025926:	ffbb 2042 	vcvta.s32.f32	q1, q1
3402592a:	ee37 0e03 	cdp	14, 3, cr0, cr7, cr3, {0}
3402592e:	ee3d 2e63 	cdp	14, 3, cr2, cr13, cr3, {3}
34025932:	ee3f 8e63 	cdp	14, 3, cr8, cr15, cr3, {3}
34025936:	ffbb 2042 	vcvta.s32.f32	q1, q1
3402593a:	ffbb 8048 	vcvta.s32.f32	q4, q4
3402593e:	ee37 7e03 	cdp	14, 3, cr7, cr7, cr3, {0}
34025942:	ee37 1e09 	cdp	14, 3, cr1, cr7, cr9, {0}
34025946:	ee33 4e07 	cdp	14, 3, cr4, cr3, cr7, {0}
3402594a:	460e      	mov	r6, r1
3402594c:	ee33 5e01 	cdp	14, 3, cr5, cr3, cr1, {0}
34025950:	3110      	adds	r1, #16
34025952:	ed86 5e00 	stc	14, cr5, [r6]
34025956:	f00f c02b 	le	lr, 34025906 <st_f32_to_int8+0x3e>
3402595a:	eb00 1085 	add.w	r0, r0, r5, lsl #6
3402595e:	f012 030f 	ands.w	r3, r2, #15
34025962:	f000 8159 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025966:	edd0 5a00 	vldr	s11, [r0]
3402596a:	ed9f 6ab7 	vldr	s12, [pc, #732]	@ 34025c48 <st_f32_to_int8+0x380>
3402596e:	ee65 5a86 	vmul.f32	s11, s11, s12
34025972:	eef5 5ac0 	vcmpe.f32	s11, #0.0
34025976:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
3402597a:	eefe 6a00 	vmov.f32	s13, #224	@ 0xbf000000 -0.5
3402597e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025982:	fe77 7a26 	vselgt.f32	s15, s14, s13
34025986:	ee77 7aa5 	vadd.f32	s15, s15, s11
3402598a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
3402598e:	ee17 2a90 	vmov	r2, s15
34025992:	b212      	sxth	r2, r2
34025994:	f302 0207 	ssat	r2, #8, r2
34025998:	2b01      	cmp	r3, #1
3402599a:	7022      	strb	r2, [r4, #0]
3402599c:	f000 813c 	beq.w	34025c18 <st_f32_to_int8+0x350>
340259a0:	edd0 7a01 	vldr	s15, [r0, #4]
340259a4:	ee67 7a86 	vmul.f32	s15, s15, s12
340259a8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340259ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340259b0:	fe77 5a26 	vselgt.f32	s11, s14, s13
340259b4:	ee77 7aa5 	vadd.f32	s15, s15, s11
340259b8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340259bc:	ee17 2a90 	vmov	r2, s15
340259c0:	b212      	sxth	r2, r2
340259c2:	f302 0207 	ssat	r2, #8, r2
340259c6:	2b02      	cmp	r3, #2
340259c8:	7062      	strb	r2, [r4, #1]
340259ca:	f000 8125 	beq.w	34025c18 <st_f32_to_int8+0x350>
340259ce:	edd0 7a02 	vldr	s15, [r0, #8]
340259d2:	ee67 7a86 	vmul.f32	s15, s15, s12
340259d6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
340259da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340259de:	fe77 5a26 	vselgt.f32	s11, s14, s13
340259e2:	ee77 7aa5 	vadd.f32	s15, s15, s11
340259e6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
340259ea:	ee17 2a90 	vmov	r2, s15
340259ee:	b212      	sxth	r2, r2
340259f0:	f302 0207 	ssat	r2, #8, r2
340259f4:	2b03      	cmp	r3, #3
340259f6:	70a2      	strb	r2, [r4, #2]
340259f8:	f000 810e 	beq.w	34025c18 <st_f32_to_int8+0x350>
340259fc:	edd0 7a03 	vldr	s15, [r0, #12]
34025a00:	ee67 7a86 	vmul.f32	s15, s15, s12
34025a04:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025a08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025a0c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025a10:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025a14:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025a18:	ee17 2a90 	vmov	r2, s15
34025a1c:	b212      	sxth	r2, r2
34025a1e:	f302 0207 	ssat	r2, #8, r2
34025a22:	2b04      	cmp	r3, #4
34025a24:	70e2      	strb	r2, [r4, #3]
34025a26:	f000 80f7 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025a2a:	edd0 7a04 	vldr	s15, [r0, #16]
34025a2e:	ee67 7a86 	vmul.f32	s15, s15, s12
34025a32:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025a36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025a3a:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025a3e:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025a42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025a46:	ee17 2a90 	vmov	r2, s15
34025a4a:	b212      	sxth	r2, r2
34025a4c:	f302 0207 	ssat	r2, #8, r2
34025a50:	2b05      	cmp	r3, #5
34025a52:	7122      	strb	r2, [r4, #4]
34025a54:	f000 80e0 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025a58:	edd0 7a05 	vldr	s15, [r0, #20]
34025a5c:	ee67 7a86 	vmul.f32	s15, s15, s12
34025a60:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025a64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025a68:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025a6c:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025a70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025a74:	ee17 2a90 	vmov	r2, s15
34025a78:	b212      	sxth	r2, r2
34025a7a:	f302 0207 	ssat	r2, #8, r2
34025a7e:	2b06      	cmp	r3, #6
34025a80:	7162      	strb	r2, [r4, #5]
34025a82:	f000 80c9 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025a86:	edd0 7a06 	vldr	s15, [r0, #24]
34025a8a:	ee67 7a86 	vmul.f32	s15, s15, s12
34025a8e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025a92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025a96:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025a9a:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025a9e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025aa2:	ee17 2a90 	vmov	r2, s15
34025aa6:	b212      	sxth	r2, r2
34025aa8:	f302 0207 	ssat	r2, #8, r2
34025aac:	2b07      	cmp	r3, #7
34025aae:	71a2      	strb	r2, [r4, #6]
34025ab0:	f000 80b2 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025ab4:	edd0 7a07 	vldr	s15, [r0, #28]
34025ab8:	ee67 7a86 	vmul.f32	s15, s15, s12
34025abc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025ac0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025ac4:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025ac8:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025acc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025ad0:	ee17 2a90 	vmov	r2, s15
34025ad4:	b212      	sxth	r2, r2
34025ad6:	f302 0207 	ssat	r2, #8, r2
34025ada:	2b08      	cmp	r3, #8
34025adc:	71e2      	strb	r2, [r4, #7]
34025ade:	f000 809b 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025ae2:	edd0 7a08 	vldr	s15, [r0, #32]
34025ae6:	ee67 7a86 	vmul.f32	s15, s15, s12
34025aea:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025aee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025af2:	fe37 7a26 	vselgt.f32	s14, s14, s13
34025af6:	ee77 7a87 	vadd.f32	s15, s15, s14
34025afa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025afe:	ee17 2a90 	vmov	r2, s15
34025b02:	b212      	sxth	r2, r2
34025b04:	f302 0207 	ssat	r2, #8, r2
34025b08:	2b09      	cmp	r3, #9
34025b0a:	7222      	strb	r2, [r4, #8]
34025b0c:	f000 8084 	beq.w	34025c18 <st_f32_to_int8+0x350>
34025b10:	edd0 7a09 	vldr	s15, [r0, #36]	@ 0x24
34025b14:	ee67 7a86 	vmul.f32	s15, s15, s12
34025b18:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025b1c:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
34025b20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025b24:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025b28:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025b2c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025b30:	ee17 2a90 	vmov	r2, s15
34025b34:	b212      	sxth	r2, r2
34025b36:	f302 0207 	ssat	r2, #8, r2
34025b3a:	2b0a      	cmp	r3, #10
34025b3c:	7262      	strb	r2, [r4, #9]
34025b3e:	d06b      	beq.n	34025c18 <st_f32_to_int8+0x350>
34025b40:	edd0 7a0a 	vldr	s15, [r0, #40]	@ 0x28
34025b44:	ee67 7a86 	vmul.f32	s15, s15, s12
34025b48:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025b4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025b50:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025b54:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025b58:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025b5c:	ee17 2a90 	vmov	r2, s15
34025b60:	b212      	sxth	r2, r2
34025b62:	f302 0207 	ssat	r2, #8, r2
34025b66:	2b0b      	cmp	r3, #11
34025b68:	72a2      	strb	r2, [r4, #10]
34025b6a:	d055      	beq.n	34025c18 <st_f32_to_int8+0x350>
34025b6c:	edd0 7a0b 	vldr	s15, [r0, #44]	@ 0x2c
34025b70:	ee67 7a86 	vmul.f32	s15, s15, s12
34025b74:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025b78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025b7c:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025b80:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025b84:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025b88:	ee17 2a90 	vmov	r2, s15
34025b8c:	b212      	sxth	r2, r2
34025b8e:	f302 0207 	ssat	r2, #8, r2
34025b92:	2b0c      	cmp	r3, #12
34025b94:	72e2      	strb	r2, [r4, #11]
34025b96:	d03f      	beq.n	34025c18 <st_f32_to_int8+0x350>
34025b98:	edd0 7a0c 	vldr	s15, [r0, #48]	@ 0x30
34025b9c:	ee67 7a86 	vmul.f32	s15, s15, s12
34025ba0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025ba4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025ba8:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025bac:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025bb0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025bb4:	ee17 2a90 	vmov	r2, s15
34025bb8:	b212      	sxth	r2, r2
34025bba:	f302 0207 	ssat	r2, #8, r2
34025bbe:	3b0d      	subs	r3, #13
34025bc0:	7322      	strb	r2, [r4, #12]
34025bc2:	d029      	beq.n	34025c18 <st_f32_to_int8+0x350>
34025bc4:	edd0 7a0d 	vldr	s15, [r0, #52]	@ 0x34
34025bc8:	ee67 7a86 	vmul.f32	s15, s15, s12
34025bcc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
34025bd0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025bd4:	fe77 5a26 	vselgt.f32	s11, s14, s13
34025bd8:	ee77 7aa5 	vadd.f32	s15, s15, s11
34025bdc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025be0:	ee17 2a90 	vmov	r2, s15
34025be4:	b212      	sxth	r2, r2
34025be6:	f302 0207 	ssat	r2, #8, r2
34025bea:	2b01      	cmp	r3, #1
34025bec:	7362      	strb	r2, [r4, #13]
34025bee:	d013      	beq.n	34025c18 <st_f32_to_int8+0x350>
34025bf0:	edd0 7a0e 	vldr	s15, [r0, #56]	@ 0x38
34025bf4:	ee27 6a86 	vmul.f32	s12, s15, s12
34025bf8:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
34025bfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34025c00:	fe77 7a26 	vselgt.f32	s15, s14, s13
34025c04:	ee77 7a86 	vadd.f32	s15, s15, s12
34025c08:	eefd 7ae7 	vcvt.s32.f32	s15, s15
34025c0c:	ee17 3a90 	vmov	r3, s15
34025c10:	b21b      	sxth	r3, r3
34025c12:	f303 0307 	ssat	r3, #8, r3
34025c16:	73a3      	strb	r3, [r4, #14]
34025c18:	ecbd 8b10 	vpop	{d8-d15}
34025c1c:	bd70      	pop	{r4, r5, r6, pc}
34025c1e:	460c      	mov	r4, r1
34025c20:	e69d      	b.n	3402595e <st_f32_to_int8+0x96>
34025c22:	bf00      	nop
34025c24:	f3af 8000 	nop.w
	...
34025c48:	43000000 	.word	0x43000000

34025c4c <st_int16_to_f32>:
34025c4c:	ea5f 0c92 	movs.w	ip, r2, lsr #2
34025c50:	b530      	push	{r4, r5, lr}
34025c52:	d013      	beq.n	34025c7c <st_int16_to_f32+0x30>
34025c54:	4604      	mov	r4, r0
34025c56:	460b      	mov	r3, r1
34025c58:	f04c e001 	dls	lr, ip
34025c5c:	4625      	mov	r5, r4
34025c5e:	ed9d 6f00 	ldc	15, cr6, [sp]
34025c62:	461d      	mov	r5, r3
34025c64:	efb1 6e56 	vcvt.f32.s32	q3, q3, #15
34025c68:	3408      	adds	r4, #8
34025c6a:	ed85 7f00 	stc	15, cr7, [r5]
34025c6e:	3310      	adds	r3, #16
34025c70:	f00f c00d 	le	lr, 34025c5c <st_int16_to_f32+0x10>
34025c74:	eb01 110c 	add.w	r1, r1, ip, lsl #4
34025c78:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
34025c7c:	f012 0203 	ands.w	r2, r2, #3
34025c80:	d023      	beq.n	34025cca <st_int16_to_f32+0x7e>
34025c82:	f9b0 3000 	ldrsh.w	r3, [r0]
34025c86:	ed9f 7a11 	vldr	s14, [pc, #68]	@ 34025ccc <st_int16_to_f32+0x80>
34025c8a:	ee07 3a90 	vmov	s15, r3
34025c8e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025c92:	ee67 7a87 	vmul.f32	s15, s15, s14
34025c96:	3a01      	subs	r2, #1
34025c98:	edc1 7a00 	vstr	s15, [r1]
34025c9c:	d015      	beq.n	34025cca <st_int16_to_f32+0x7e>
34025c9e:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
34025ca2:	2a01      	cmp	r2, #1
34025ca4:	ee07 3a90 	vmov	s15, r3
34025ca8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025cac:	ee67 7a87 	vmul.f32	s15, s15, s14
34025cb0:	edc1 7a01 	vstr	s15, [r1, #4]
34025cb4:	d009      	beq.n	34025cca <st_int16_to_f32+0x7e>
34025cb6:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
34025cba:	ee07 3a90 	vmov	s15, r3
34025cbe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025cc2:	ee67 7a87 	vmul.f32	s15, s15, s14
34025cc6:	edc1 7a02 	vstr	s15, [r1, #8]
34025cca:	bd30      	pop	{r4, r5, pc}
34025ccc:	38000000 	.word	0x38000000

34025cd0 <st_int8_to_f32>:
34025cd0:	ea5f 0c92 	movs.w	ip, r2, lsr #2
34025cd4:	b530      	push	{r4, r5, lr}
34025cd6:	d042      	beq.n	34025d5e <st_int8_to_f32+0x8e>
34025cd8:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
34025cdc:	f1ae 0e04 	sub.w	lr, lr, #4
34025ce0:	ea4f 0e9e 	mov.w	lr, lr, lsr #2
34025ce4:	f10e 0e01 	add.w	lr, lr, #1
34025ce8:	f04e e001 	dls	lr, lr
34025cec:	460b      	mov	r3, r1
34025cee:	eb00 048c 	add.w	r4, r0, ip, lsl #2
34025cf2:	4605      	mov	r5, r0
34025cf4:	ed95 6f00 	ldc	15, cr6, [r5]
34025cf8:	461d      	mov	r5, r3
34025cfa:	efb9 6e56 	vcvt.f32.s32	q3, q3, #7
34025cfe:	3004      	adds	r0, #4
34025d00:	ed85 7f00 	stc	15, cr7, [r5]
34025d04:	3310      	adds	r3, #16
34025d06:	f00f c00d 	le	lr, 34025cf2 <st_int8_to_f32+0x22>
34025d0a:	eb01 110c 	add.w	r1, r1, ip, lsl #4
34025d0e:	f012 0203 	ands.w	r2, r2, #3
34025d12:	d023      	beq.n	34025d5c <st_int8_to_f32+0x8c>
34025d14:	f994 3000 	ldrsb.w	r3, [r4]
34025d18:	ed9f 7a12 	vldr	s14, [pc, #72]	@ 34025d64 <st_int8_to_f32+0x94>
34025d1c:	ee07 3a90 	vmov	s15, r3
34025d20:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025d24:	ee67 7a87 	vmul.f32	s15, s15, s14
34025d28:	3a01      	subs	r2, #1
34025d2a:	edc1 7a00 	vstr	s15, [r1]
34025d2e:	d015      	beq.n	34025d5c <st_int8_to_f32+0x8c>
34025d30:	f994 3001 	ldrsb.w	r3, [r4, #1]
34025d34:	2a01      	cmp	r2, #1
34025d36:	ee07 3a90 	vmov	s15, r3
34025d3a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025d3e:	ee67 7a87 	vmul.f32	s15, s15, s14
34025d42:	edc1 7a01 	vstr	s15, [r1, #4]
34025d46:	d009      	beq.n	34025d5c <st_int8_to_f32+0x8c>
34025d48:	f994 3002 	ldrsb.w	r3, [r4, #2]
34025d4c:	ee07 3a90 	vmov	s15, r3
34025d50:	eef8 7ae7 	vcvt.f32.s32	s15, s15
34025d54:	ee67 7a87 	vmul.f32	s15, s15, s14
34025d58:	edc1 7a02 	vstr	s15, [r1, #8]
34025d5c:	bd30      	pop	{r4, r5, pc}
34025d5e:	4604      	mov	r4, r0
34025d60:	e7d5      	b.n	34025d0e <st_int8_to_f32+0x3e>
34025d62:	bf00      	nop
34025d64:	3c000000 	.word	0x3c000000

34025d68 <__assert_func>:
34025d68:	b51f      	push	{r0, r1, r2, r3, r4, lr}
34025d6a:	4614      	mov	r4, r2
34025d6c:	461a      	mov	r2, r3
34025d6e:	4b09      	ldr	r3, [pc, #36]	@ (34025d94 <__assert_func+0x2c>)
34025d70:	4605      	mov	r5, r0
34025d72:	681b      	ldr	r3, [r3, #0]
34025d74:	68d8      	ldr	r0, [r3, #12]
34025d76:	b14c      	cbz	r4, 34025d8c <__assert_func+0x24>
34025d78:	4b07      	ldr	r3, [pc, #28]	@ (34025d98 <__assert_func+0x30>)
34025d7a:	9100      	str	r1, [sp, #0]
34025d7c:	4907      	ldr	r1, [pc, #28]	@ (34025d9c <__assert_func+0x34>)
34025d7e:	e9cd 3401 	strd	r3, r4, [sp, #4]
34025d82:	462b      	mov	r3, r5
34025d84:	f000 ff4e 	bl	34026c24 <fiprintf>
34025d88:	f001 fca0 	bl	340276cc <abort>
34025d8c:	4b04      	ldr	r3, [pc, #16]	@ (34025da0 <__assert_func+0x38>)
34025d8e:	461c      	mov	r4, r3
34025d90:	e7f3      	b.n	34025d7a <__assert_func+0x12>
34025d92:	bf00      	nop
34025d94:	340414a4 	.word	0x340414a4
34025d98:	3403e5a5 	.word	0x3403e5a5
34025d9c:	3403e5b2 	.word	0x3403e5b2
34025da0:	3403e15d 	.word	0x3403e15d

34025da4 <malloc>:
34025da4:	4b02      	ldr	r3, [pc, #8]	@ (34025db0 <malloc+0xc>)
34025da6:	4601      	mov	r1, r0
34025da8:	6818      	ldr	r0, [r3, #0]
34025daa:	f000 b825 	b.w	34025df8 <_malloc_r>
34025dae:	bf00      	nop
34025db0:	340414a4 	.word	0x340414a4

34025db4 <sbrk_aligned>:
34025db4:	b570      	push	{r4, r5, r6, lr}
34025db6:	4e0f      	ldr	r6, [pc, #60]	@ (34025df4 <sbrk_aligned+0x40>)
34025db8:	460c      	mov	r4, r1
34025dba:	4605      	mov	r5, r0
34025dbc:	6831      	ldr	r1, [r6, #0]
34025dbe:	b911      	cbnz	r1, 34025dc6 <sbrk_aligned+0x12>
34025dc0:	f001 fc1a 	bl	340275f8 <_sbrk_r>
34025dc4:	6030      	str	r0, [r6, #0]
34025dc6:	4621      	mov	r1, r4
34025dc8:	4628      	mov	r0, r5
34025dca:	f001 fc15 	bl	340275f8 <_sbrk_r>
34025dce:	1c43      	adds	r3, r0, #1
34025dd0:	d103      	bne.n	34025dda <sbrk_aligned+0x26>
34025dd2:	f04f 34ff 	mov.w	r4, #4294967295
34025dd6:	4620      	mov	r0, r4
34025dd8:	bd70      	pop	{r4, r5, r6, pc}
34025dda:	1cc4      	adds	r4, r0, #3
34025ddc:	f024 0403 	bic.w	r4, r4, #3
34025de0:	42a0      	cmp	r0, r4
34025de2:	d0f8      	beq.n	34025dd6 <sbrk_aligned+0x22>
34025de4:	1a21      	subs	r1, r4, r0
34025de6:	4628      	mov	r0, r5
34025de8:	f001 fc06 	bl	340275f8 <_sbrk_r>
34025dec:	3001      	adds	r0, #1
34025dee:	d1f2      	bne.n	34025dd6 <sbrk_aligned+0x22>
34025df0:	e7ef      	b.n	34025dd2 <sbrk_aligned+0x1e>
34025df2:	bf00      	nop
34025df4:	340566ac 	.word	0x340566ac

34025df8 <_malloc_r>:
34025df8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34025dfc:	1ccd      	adds	r5, r1, #3
34025dfe:	4606      	mov	r6, r0
34025e00:	f025 0503 	bic.w	r5, r5, #3
34025e04:	3508      	adds	r5, #8
34025e06:	2d0c      	cmp	r5, #12
34025e08:	bf38      	it	cc
34025e0a:	250c      	movcc	r5, #12
34025e0c:	2d00      	cmp	r5, #0
34025e0e:	db01      	blt.n	34025e14 <_malloc_r+0x1c>
34025e10:	42a9      	cmp	r1, r5
34025e12:	d904      	bls.n	34025e1e <_malloc_r+0x26>
34025e14:	230c      	movs	r3, #12
34025e16:	6033      	str	r3, [r6, #0]
34025e18:	2000      	movs	r0, #0
34025e1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34025e1e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 34025ef4 <_malloc_r+0xfc>
34025e22:	f000 f869 	bl	34025ef8 <__malloc_lock>
34025e26:	f8d8 3000 	ldr.w	r3, [r8]
34025e2a:	461c      	mov	r4, r3
34025e2c:	bb44      	cbnz	r4, 34025e80 <_malloc_r+0x88>
34025e2e:	4629      	mov	r1, r5
34025e30:	4630      	mov	r0, r6
34025e32:	f7ff ffbf 	bl	34025db4 <sbrk_aligned>
34025e36:	1c43      	adds	r3, r0, #1
34025e38:	4604      	mov	r4, r0
34025e3a:	d158      	bne.n	34025eee <_malloc_r+0xf6>
34025e3c:	f8d8 4000 	ldr.w	r4, [r8]
34025e40:	4627      	mov	r7, r4
34025e42:	2f00      	cmp	r7, #0
34025e44:	d143      	bne.n	34025ece <_malloc_r+0xd6>
34025e46:	2c00      	cmp	r4, #0
34025e48:	d04b      	beq.n	34025ee2 <_malloc_r+0xea>
34025e4a:	6823      	ldr	r3, [r4, #0]
34025e4c:	4639      	mov	r1, r7
34025e4e:	4630      	mov	r0, r6
34025e50:	eb04 0903 	add.w	r9, r4, r3
34025e54:	f001 fbd0 	bl	340275f8 <_sbrk_r>
34025e58:	4581      	cmp	r9, r0
34025e5a:	d142      	bne.n	34025ee2 <_malloc_r+0xea>
34025e5c:	6821      	ldr	r1, [r4, #0]
34025e5e:	4630      	mov	r0, r6
34025e60:	1a6d      	subs	r5, r5, r1
34025e62:	4629      	mov	r1, r5
34025e64:	f7ff ffa6 	bl	34025db4 <sbrk_aligned>
34025e68:	3001      	adds	r0, #1
34025e6a:	d03a      	beq.n	34025ee2 <_malloc_r+0xea>
34025e6c:	6823      	ldr	r3, [r4, #0]
34025e6e:	442b      	add	r3, r5
34025e70:	6023      	str	r3, [r4, #0]
34025e72:	f8d8 3000 	ldr.w	r3, [r8]
34025e76:	685a      	ldr	r2, [r3, #4]
34025e78:	bb62      	cbnz	r2, 34025ed4 <_malloc_r+0xdc>
34025e7a:	f8c8 7000 	str.w	r7, [r8]
34025e7e:	e00f      	b.n	34025ea0 <_malloc_r+0xa8>
34025e80:	6822      	ldr	r2, [r4, #0]
34025e82:	1b52      	subs	r2, r2, r5
34025e84:	d420      	bmi.n	34025ec8 <_malloc_r+0xd0>
34025e86:	2a0b      	cmp	r2, #11
34025e88:	d917      	bls.n	34025eba <_malloc_r+0xc2>
34025e8a:	1961      	adds	r1, r4, r5
34025e8c:	42a3      	cmp	r3, r4
34025e8e:	6025      	str	r5, [r4, #0]
34025e90:	bf18      	it	ne
34025e92:	6059      	strne	r1, [r3, #4]
34025e94:	6863      	ldr	r3, [r4, #4]
34025e96:	bf08      	it	eq
34025e98:	f8c8 1000 	streq.w	r1, [r8]
34025e9c:	5162      	str	r2, [r4, r5]
34025e9e:	604b      	str	r3, [r1, #4]
34025ea0:	4630      	mov	r0, r6
34025ea2:	f000 f82f 	bl	34025f04 <__malloc_unlock>
34025ea6:	f104 000b 	add.w	r0, r4, #11
34025eaa:	1d23      	adds	r3, r4, #4
34025eac:	f020 0007 	bic.w	r0, r0, #7
34025eb0:	1ac2      	subs	r2, r0, r3
34025eb2:	bf1c      	itt	ne
34025eb4:	1a1b      	subne	r3, r3, r0
34025eb6:	50a3      	strne	r3, [r4, r2]
34025eb8:	e7af      	b.n	34025e1a <_malloc_r+0x22>
34025eba:	6862      	ldr	r2, [r4, #4]
34025ebc:	42a3      	cmp	r3, r4
34025ebe:	bf0c      	ite	eq
34025ec0:	f8c8 2000 	streq.w	r2, [r8]
34025ec4:	605a      	strne	r2, [r3, #4]
34025ec6:	e7eb      	b.n	34025ea0 <_malloc_r+0xa8>
34025ec8:	4623      	mov	r3, r4
34025eca:	6864      	ldr	r4, [r4, #4]
34025ecc:	e7ae      	b.n	34025e2c <_malloc_r+0x34>
34025ece:	463c      	mov	r4, r7
34025ed0:	687f      	ldr	r7, [r7, #4]
34025ed2:	e7b6      	b.n	34025e42 <_malloc_r+0x4a>
34025ed4:	461a      	mov	r2, r3
34025ed6:	685b      	ldr	r3, [r3, #4]
34025ed8:	42a3      	cmp	r3, r4
34025eda:	d1fb      	bne.n	34025ed4 <_malloc_r+0xdc>
34025edc:	2300      	movs	r3, #0
34025ede:	6053      	str	r3, [r2, #4]
34025ee0:	e7de      	b.n	34025ea0 <_malloc_r+0xa8>
34025ee2:	230c      	movs	r3, #12
34025ee4:	4630      	mov	r0, r6
34025ee6:	6033      	str	r3, [r6, #0]
34025ee8:	f000 f80c 	bl	34025f04 <__malloc_unlock>
34025eec:	e794      	b.n	34025e18 <_malloc_r+0x20>
34025eee:	6005      	str	r5, [r0, #0]
34025ef0:	e7d6      	b.n	34025ea0 <_malloc_r+0xa8>
34025ef2:	bf00      	nop
34025ef4:	340566b0 	.word	0x340566b0

34025ef8 <__malloc_lock>:
34025ef8:	4801      	ldr	r0, [pc, #4]	@ (34025f00 <__malloc_lock+0x8>)
34025efa:	f001 bbca 	b.w	34027692 <__retarget_lock_acquire_recursive>
34025efe:	bf00      	nop
34025f00:	340567f4 	.word	0x340567f4

34025f04 <__malloc_unlock>:
34025f04:	4801      	ldr	r0, [pc, #4]	@ (34025f0c <__malloc_unlock+0x8>)
34025f06:	f001 bbc5 	b.w	34027694 <__retarget_lock_release_recursive>
34025f0a:	bf00      	nop
34025f0c:	340567f4 	.word	0x340567f4

34025f10 <_realloc_r>:
34025f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34025f14:	4607      	mov	r7, r0
34025f16:	4614      	mov	r4, r2
34025f18:	460d      	mov	r5, r1
34025f1a:	b921      	cbnz	r1, 34025f26 <_realloc_r+0x16>
34025f1c:	4611      	mov	r1, r2
34025f1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34025f22:	f7ff bf69 	b.w	34025df8 <_malloc_r>
34025f26:	b92a      	cbnz	r2, 34025f34 <_realloc_r+0x24>
34025f28:	4625      	mov	r5, r4
34025f2a:	f002 f9c3 	bl	340282b4 <_free_r>
34025f2e:	4628      	mov	r0, r5
34025f30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34025f34:	f002 fd8a 	bl	34028a4c <_malloc_usable_size_r>
34025f38:	4284      	cmp	r4, r0
34025f3a:	4606      	mov	r6, r0
34025f3c:	d802      	bhi.n	34025f44 <_realloc_r+0x34>
34025f3e:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
34025f42:	d8f4      	bhi.n	34025f2e <_realloc_r+0x1e>
34025f44:	4621      	mov	r1, r4
34025f46:	4638      	mov	r0, r7
34025f48:	f7ff ff56 	bl	34025df8 <_malloc_r>
34025f4c:	4680      	mov	r8, r0
34025f4e:	b908      	cbnz	r0, 34025f54 <_realloc_r+0x44>
34025f50:	4645      	mov	r5, r8
34025f52:	e7ec      	b.n	34025f2e <_realloc_r+0x1e>
34025f54:	42b4      	cmp	r4, r6
34025f56:	4622      	mov	r2, r4
34025f58:	4629      	mov	r1, r5
34025f5a:	bf28      	it	cs
34025f5c:	4632      	movcs	r2, r6
34025f5e:	f001 fba8 	bl	340276b2 <memcpy>
34025f62:	4629      	mov	r1, r5
34025f64:	4638      	mov	r0, r7
34025f66:	f002 f9a5 	bl	340282b4 <_free_r>
34025f6a:	e7f1      	b.n	34025f50 <_realloc_r+0x40>

34025f6c <swapfunc>:
34025f6c:	2b02      	cmp	r3, #2
34025f6e:	b510      	push	{r4, lr}
34025f70:	d00a      	beq.n	34025f88 <swapfunc+0x1c>
34025f72:	0892      	lsrs	r2, r2, #2
34025f74:	3a01      	subs	r2, #1
34025f76:	6803      	ldr	r3, [r0, #0]
34025f78:	680c      	ldr	r4, [r1, #0]
34025f7a:	2a00      	cmp	r2, #0
34025f7c:	f840 4b04 	str.w	r4, [r0], #4
34025f80:	f841 3b04 	str.w	r3, [r1], #4
34025f84:	dcf6      	bgt.n	34025f74 <swapfunc+0x8>
34025f86:	bd10      	pop	{r4, pc}
34025f88:	4402      	add	r2, r0
34025f8a:	7803      	ldrb	r3, [r0, #0]
34025f8c:	780c      	ldrb	r4, [r1, #0]
34025f8e:	f800 4b01 	strb.w	r4, [r0], #1
34025f92:	f801 3b01 	strb.w	r3, [r1], #1
34025f96:	1a13      	subs	r3, r2, r0
34025f98:	2b00      	cmp	r3, #0
34025f9a:	dcf6      	bgt.n	34025f8a <swapfunc+0x1e>
34025f9c:	e7f3      	b.n	34025f86 <swapfunc+0x1a>

34025f9e <med3.constprop.0>:
34025f9e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34025fa0:	460f      	mov	r7, r1
34025fa2:	4616      	mov	r6, r2
34025fa4:	4604      	mov	r4, r0
34025fa6:	461d      	mov	r5, r3
34025fa8:	4798      	blx	r3
34025faa:	2800      	cmp	r0, #0
34025fac:	4631      	mov	r1, r6
34025fae:	4638      	mov	r0, r7
34025fb0:	da0c      	bge.n	34025fcc <med3.constprop.0+0x2e>
34025fb2:	47a8      	blx	r5
34025fb4:	2800      	cmp	r0, #0
34025fb6:	da02      	bge.n	34025fbe <med3.constprop.0+0x20>
34025fb8:	463c      	mov	r4, r7
34025fba:	4620      	mov	r0, r4
34025fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
34025fbe:	4631      	mov	r1, r6
34025fc0:	4620      	mov	r0, r4
34025fc2:	47a8      	blx	r5
34025fc4:	2800      	cmp	r0, #0
34025fc6:	daf8      	bge.n	34025fba <med3.constprop.0+0x1c>
34025fc8:	4634      	mov	r4, r6
34025fca:	e7f6      	b.n	34025fba <med3.constprop.0+0x1c>
34025fcc:	47a8      	blx	r5
34025fce:	2800      	cmp	r0, #0
34025fd0:	dcf2      	bgt.n	34025fb8 <med3.constprop.0+0x1a>
34025fd2:	4631      	mov	r1, r6
34025fd4:	4620      	mov	r0, r4
34025fd6:	47a8      	blx	r5
34025fd8:	2800      	cmp	r0, #0
34025fda:	daf5      	bge.n	34025fc8 <med3.constprop.0+0x2a>
34025fdc:	e7ed      	b.n	34025fba <med3.constprop.0+0x1c>

34025fde <qsort>:
34025fde:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34025fe2:	b095      	sub	sp, #84	@ 0x54
34025fe4:	4607      	mov	r7, r0
34025fe6:	4615      	mov	r5, r2
34025fe8:	9300      	str	r3, [sp, #0]
34025fea:	ea40 0302 	orr.w	r3, r0, r2
34025fee:	079b      	lsls	r3, r3, #30
34025ff0:	d119      	bne.n	34026026 <qsort+0x48>
34025ff2:	f1b2 0804 	subs.w	r8, r2, #4
34025ff6:	bf18      	it	ne
34025ff8:	f04f 0801 	movne.w	r8, #1
34025ffc:	2300      	movs	r3, #0
34025ffe:	9301      	str	r3, [sp, #4]
34026000:	fb05 f401 	mul.w	r4, r5, r1
34026004:	2906      	cmp	r1, #6
34026006:	eb07 0b05 	add.w	fp, r7, r5
3402600a:	eb07 0304 	add.w	r3, r7, r4
3402600e:	9302      	str	r3, [sp, #8]
34026010:	d828      	bhi.n	34026064 <qsort+0x86>
34026012:	9b02      	ldr	r3, [sp, #8]
34026014:	459b      	cmp	fp, r3
34026016:	d310      	bcc.n	3402603a <qsort+0x5c>
34026018:	9b01      	ldr	r3, [sp, #4]
3402601a:	2b00      	cmp	r3, #0
3402601c:	f040 8117 	bne.w	3402624e <qsort+0x270>
34026020:	b015      	add	sp, #84	@ 0x54
34026022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34026026:	f04f 0802 	mov.w	r8, #2
3402602a:	e7e7      	b.n	34025ffc <qsort+0x1e>
3402602c:	4643      	mov	r3, r8
3402602e:	462a      	mov	r2, r5
34026030:	4631      	mov	r1, r6
34026032:	4620      	mov	r0, r4
34026034:	f7ff ff9a 	bl	34025f6c <swapfunc>
34026038:	e00f      	b.n	3402605a <qsort+0x7c>
3402603a:	465c      	mov	r4, fp
3402603c:	e00e      	b.n	3402605c <qsort+0x7e>
3402603e:	1b66      	subs	r6, r4, r5
34026040:	4621      	mov	r1, r4
34026042:	9b00      	ldr	r3, [sp, #0]
34026044:	4630      	mov	r0, r6
34026046:	4798      	blx	r3
34026048:	2800      	cmp	r0, #0
3402604a:	dd09      	ble.n	34026060 <qsort+0x82>
3402604c:	f1b8 0f00 	cmp.w	r8, #0
34026050:	d1ec      	bne.n	3402602c <qsort+0x4e>
34026052:	6823      	ldr	r3, [r4, #0]
34026054:	6832      	ldr	r2, [r6, #0]
34026056:	6022      	str	r2, [r4, #0]
34026058:	6033      	str	r3, [r6, #0]
3402605a:	4634      	mov	r4, r6
3402605c:	42a7      	cmp	r7, r4
3402605e:	d3ee      	bcc.n	3402603e <qsort+0x60>
34026060:	44ab      	add	fp, r5
34026062:	e7d6      	b.n	34026012 <qsort+0x34>
34026064:	ea4f 0951 	mov.w	r9, r1, lsr #1
34026068:	1b64      	subs	r4, r4, r5
3402606a:	2907      	cmp	r1, #7
3402606c:	fb05 7909 	mla	r9, r5, r9, r7
34026070:	443c      	add	r4, r7
34026072:	d021      	beq.n	340260b8 <qsort+0xda>
34026074:	2928      	cmp	r1, #40	@ 0x28
34026076:	d944      	bls.n	34026102 <qsort+0x124>
34026078:	08ce      	lsrs	r6, r1, #3
3402607a:	9b00      	ldr	r3, [sp, #0]
3402607c:	4638      	mov	r0, r7
3402607e:	436e      	muls	r6, r5
34026080:	eb07 0246 	add.w	r2, r7, r6, lsl #1
34026084:	19b9      	adds	r1, r7, r6
34026086:	f7ff ff8a 	bl	34025f9e <med3.constprop.0>
3402608a:	4649      	mov	r1, r9
3402608c:	eb09 0206 	add.w	r2, r9, r6
34026090:	9b00      	ldr	r3, [sp, #0]
34026092:	4682      	mov	sl, r0
34026094:	1b88      	subs	r0, r1, r6
34026096:	f7ff ff82 	bl	34025f9e <med3.constprop.0>
3402609a:	4622      	mov	r2, r4
3402609c:	4681      	mov	r9, r0
3402609e:	9b00      	ldr	r3, [sp, #0]
340260a0:	1ba1      	subs	r1, r4, r6
340260a2:	eba4 0046 	sub.w	r0, r4, r6, lsl #1
340260a6:	f7ff ff7a 	bl	34025f9e <med3.constprop.0>
340260aa:	4602      	mov	r2, r0
340260ac:	4649      	mov	r1, r9
340260ae:	9b00      	ldr	r3, [sp, #0]
340260b0:	4650      	mov	r0, sl
340260b2:	f7ff ff74 	bl	34025f9e <med3.constprop.0>
340260b6:	4681      	mov	r9, r0
340260b8:	f1b8 0f00 	cmp.w	r8, #0
340260bc:	d124      	bne.n	34026108 <qsort+0x12a>
340260be:	683b      	ldr	r3, [r7, #0]
340260c0:	f8d9 2000 	ldr.w	r2, [r9]
340260c4:	603a      	str	r2, [r7, #0]
340260c6:	f8c9 3000 	str.w	r3, [r9]
340260ca:	46d9      	mov	r9, fp
340260cc:	46a2      	mov	sl, r4
340260ce:	465e      	mov	r6, fp
340260d0:	2300      	movs	r3, #0
340260d2:	45a1      	cmp	r9, r4
340260d4:	d836      	bhi.n	34026144 <qsort+0x166>
340260d6:	9303      	str	r3, [sp, #12]
340260d8:	4639      	mov	r1, r7
340260da:	9b00      	ldr	r3, [sp, #0]
340260dc:	4648      	mov	r0, r9
340260de:	4798      	blx	r3
340260e0:	2800      	cmp	r0, #0
340260e2:	9b03      	ldr	r3, [sp, #12]
340260e4:	dc2c      	bgt.n	34026140 <qsort+0x162>
340260e6:	d10a      	bne.n	340260fe <qsort+0x120>
340260e8:	f1b8 0f00 	cmp.w	r8, #0
340260ec:	d113      	bne.n	34026116 <qsort+0x138>
340260ee:	6833      	ldr	r3, [r6, #0]
340260f0:	f8d9 2000 	ldr.w	r2, [r9]
340260f4:	6032      	str	r2, [r6, #0]
340260f6:	f8c9 3000 	str.w	r3, [r9]
340260fa:	442e      	add	r6, r5
340260fc:	2301      	movs	r3, #1
340260fe:	44a9      	add	r9, r5
34026100:	e7e7      	b.n	340260d2 <qsort+0xf4>
34026102:	4622      	mov	r2, r4
34026104:	46ba      	mov	sl, r7
34026106:	e7d1      	b.n	340260ac <qsort+0xce>
34026108:	4643      	mov	r3, r8
3402610a:	462a      	mov	r2, r5
3402610c:	4649      	mov	r1, r9
3402610e:	4638      	mov	r0, r7
34026110:	f7ff ff2c 	bl	34025f6c <swapfunc>
34026114:	e7d9      	b.n	340260ca <qsort+0xec>
34026116:	4643      	mov	r3, r8
34026118:	462a      	mov	r2, r5
3402611a:	4649      	mov	r1, r9
3402611c:	4630      	mov	r0, r6
3402611e:	f7ff ff25 	bl	34025f6c <swapfunc>
34026122:	e7ea      	b.n	340260fa <qsort+0x11c>
34026124:	d10b      	bne.n	3402613e <qsort+0x160>
34026126:	f1b8 0f00 	cmp.w	r8, #0
3402612a:	d113      	bne.n	34026154 <qsort+0x176>
3402612c:	6823      	ldr	r3, [r4, #0]
3402612e:	f8da 2000 	ldr.w	r2, [sl]
34026132:	6022      	str	r2, [r4, #0]
34026134:	f8ca 3000 	str.w	r3, [sl]
34026138:	ebaa 0a05 	sub.w	sl, sl, r5
3402613c:	2301      	movs	r3, #1
3402613e:	1b64      	subs	r4, r4, r5
34026140:	45a1      	cmp	r9, r4
34026142:	d90e      	bls.n	34026162 <qsort+0x184>
34026144:	2b00      	cmp	r3, #0
34026146:	d140      	bne.n	340261ca <qsort+0x1ec>
34026148:	9b02      	ldr	r3, [sp, #8]
3402614a:	459b      	cmp	fp, r3
3402614c:	f4bf af64 	bcs.w	34026018 <qsort+0x3a>
34026150:	465c      	mov	r4, fp
34026152:	e036      	b.n	340261c2 <qsort+0x1e4>
34026154:	4643      	mov	r3, r8
34026156:	462a      	mov	r2, r5
34026158:	4651      	mov	r1, sl
3402615a:	4620      	mov	r0, r4
3402615c:	f7ff ff06 	bl	34025f6c <swapfunc>
34026160:	e7ea      	b.n	34026138 <qsort+0x15a>
34026162:	9303      	str	r3, [sp, #12]
34026164:	4639      	mov	r1, r7
34026166:	9b00      	ldr	r3, [sp, #0]
34026168:	4620      	mov	r0, r4
3402616a:	4798      	blx	r3
3402616c:	2800      	cmp	r0, #0
3402616e:	9b03      	ldr	r3, [sp, #12]
34026170:	dad8      	bge.n	34026124 <qsort+0x146>
34026172:	f1b8 0f00 	cmp.w	r8, #0
34026176:	d107      	bne.n	34026188 <qsort+0x1aa>
34026178:	f8d9 3000 	ldr.w	r3, [r9]
3402617c:	6822      	ldr	r2, [r4, #0]
3402617e:	f8c9 2000 	str.w	r2, [r9]
34026182:	6023      	str	r3, [r4, #0]
34026184:	1b64      	subs	r4, r4, r5
34026186:	e7b9      	b.n	340260fc <qsort+0x11e>
34026188:	4643      	mov	r3, r8
3402618a:	462a      	mov	r2, r5
3402618c:	4621      	mov	r1, r4
3402618e:	4648      	mov	r0, r9
34026190:	f7ff feec 	bl	34025f6c <swapfunc>
34026194:	e7f6      	b.n	34026184 <qsort+0x1a6>
34026196:	4643      	mov	r3, r8
34026198:	462a      	mov	r2, r5
3402619a:	4631      	mov	r1, r6
3402619c:	4620      	mov	r0, r4
3402619e:	f7ff fee5 	bl	34025f6c <swapfunc>
340261a2:	e00d      	b.n	340261c0 <qsort+0x1e2>
340261a4:	1b66      	subs	r6, r4, r5
340261a6:	4621      	mov	r1, r4
340261a8:	9b00      	ldr	r3, [sp, #0]
340261aa:	4630      	mov	r0, r6
340261ac:	4798      	blx	r3
340261ae:	2800      	cmp	r0, #0
340261b0:	dd09      	ble.n	340261c6 <qsort+0x1e8>
340261b2:	f1b8 0f00 	cmp.w	r8, #0
340261b6:	d1ee      	bne.n	34026196 <qsort+0x1b8>
340261b8:	6823      	ldr	r3, [r4, #0]
340261ba:	6832      	ldr	r2, [r6, #0]
340261bc:	6022      	str	r2, [r4, #0]
340261be:	6033      	str	r3, [r6, #0]
340261c0:	4634      	mov	r4, r6
340261c2:	42a7      	cmp	r7, r4
340261c4:	d3ee      	bcc.n	340261a4 <qsort+0x1c6>
340261c6:	44ab      	add	fp, r5
340261c8:	e7be      	b.n	34026148 <qsort+0x16a>
340261ca:	eba9 0b06 	sub.w	fp, r9, r6
340261ce:	1bf2      	subs	r2, r6, r7
340261d0:	455a      	cmp	r2, fp
340261d2:	bfa8      	it	ge
340261d4:	465a      	movge	r2, fp
340261d6:	b12a      	cbz	r2, 340261e4 <qsort+0x206>
340261d8:	4643      	mov	r3, r8
340261da:	eba9 0102 	sub.w	r1, r9, r2
340261de:	4638      	mov	r0, r7
340261e0:	f7ff fec4 	bl	34025f6c <swapfunc>
340261e4:	9b02      	ldr	r3, [sp, #8]
340261e6:	ebaa 0404 	sub.w	r4, sl, r4
340261ea:	eba3 020a 	sub.w	r2, r3, sl
340261ee:	1b52      	subs	r2, r2, r5
340261f0:	42a2      	cmp	r2, r4
340261f2:	bf28      	it	cs
340261f4:	4622      	movcs	r2, r4
340261f6:	b12a      	cbz	r2, 34026204 <qsort+0x226>
340261f8:	9902      	ldr	r1, [sp, #8]
340261fa:	4643      	mov	r3, r8
340261fc:	4648      	mov	r0, r9
340261fe:	1a89      	subs	r1, r1, r2
34026200:	f7ff feb4 	bl	34025f6c <swapfunc>
34026204:	9b02      	ldr	r3, [sp, #8]
34026206:	455c      	cmp	r4, fp
34026208:	eba3 0604 	sub.w	r6, r3, r4
3402620c:	d805      	bhi.n	3402621a <qsort+0x23c>
3402620e:	4623      	mov	r3, r4
34026210:	465c      	mov	r4, fp
34026212:	469b      	mov	fp, r3
34026214:	4633      	mov	r3, r6
34026216:	463e      	mov	r6, r7
34026218:	461f      	mov	r7, r3
3402621a:	45ab      	cmp	fp, r5
3402621c:	d920      	bls.n	34026260 <qsort+0x282>
3402621e:	9b01      	ldr	r3, [sp, #4]
34026220:	2b07      	cmp	r3, #7
34026222:	fbbb f1f5 	udiv	r1, fp, r5
34026226:	d80b      	bhi.n	34026240 <qsort+0x262>
34026228:	aa14      	add	r2, sp, #80	@ 0x50
3402622a:	fbb4 f4f5 	udiv	r4, r4, r5
3402622e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
34026232:	f843 6c40 	str.w	r6, [r3, #-64]
34026236:	f843 4c3c 	str.w	r4, [r3, #-60]
3402623a:	9b01      	ldr	r3, [sp, #4]
3402623c:	3301      	adds	r3, #1
3402623e:	e6de      	b.n	34025ffe <qsort+0x20>
34026240:	9b00      	ldr	r3, [sp, #0]
34026242:	462a      	mov	r2, r5
34026244:	4638      	mov	r0, r7
34026246:	f7ff feca 	bl	34025fde <qsort>
3402624a:	42ac      	cmp	r4, r5
3402624c:	d80b      	bhi.n	34026266 <qsort+0x288>
3402624e:	9b01      	ldr	r3, [sp, #4]
34026250:	aa14      	add	r2, sp, #80	@ 0x50
34026252:	3b01      	subs	r3, #1
34026254:	9301      	str	r3, [sp, #4]
34026256:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
3402625a:	e953 7110 	ldrd	r7, r1, [r3, #-64]	@ 0x40
3402625e:	e6cf      	b.n	34026000 <qsort+0x22>
34026260:	42ac      	cmp	r4, r5
34026262:	f67f aed9 	bls.w	34026018 <qsort+0x3a>
34026266:	4637      	mov	r7, r6
34026268:	fbb4 f1f5 	udiv	r1, r4, r5
3402626c:	e6c8      	b.n	34026000 <qsort+0x22>

3402626e <__cvt>:
3402626e:	b5f0      	push	{r4, r5, r6, r7, lr}
34026270:	ed2d 8b02 	vpush	{d8}
34026274:	eeb0 8b40 	vmov.f64	d8, d0
34026278:	b085      	sub	sp, #20
3402627a:	4617      	mov	r7, r2
3402627c:	460c      	mov	r4, r1
3402627e:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
34026280:	ee18 2a90 	vmov	r2, s17
34026284:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
34026286:	f025 0520 	bic.w	r5, r5, #32
3402628a:	2a00      	cmp	r2, #0
3402628c:	bfb6      	itet	lt
3402628e:	222d      	movlt	r2, #45	@ 0x2d
34026290:	2200      	movge	r2, #0
34026292:	eeb1 8b40 	vneglt.f64	d8, d0
34026296:	2d46      	cmp	r5, #70	@ 0x46
34026298:	701a      	strb	r2, [r3, #0]
3402629a:	d004      	beq.n	340262a6 <__cvt+0x38>
3402629c:	2d45      	cmp	r5, #69	@ 0x45
3402629e:	d100      	bne.n	340262a2 <__cvt+0x34>
340262a0:	3401      	adds	r4, #1
340262a2:	2102      	movs	r1, #2
340262a4:	e000      	b.n	340262a8 <__cvt+0x3a>
340262a6:	2103      	movs	r1, #3
340262a8:	ab03      	add	r3, sp, #12
340262aa:	eeb0 0b48 	vmov.f64	d0, d8
340262ae:	4622      	mov	r2, r4
340262b0:	9301      	str	r3, [sp, #4]
340262b2:	ab02      	add	r3, sp, #8
340262b4:	9300      	str	r3, [sp, #0]
340262b6:	4633      	mov	r3, r6
340262b8:	f001 fa9e 	bl	340277f8 <_dtoa_r>
340262bc:	2d47      	cmp	r5, #71	@ 0x47
340262be:	d114      	bne.n	340262ea <__cvt+0x7c>
340262c0:	07fb      	lsls	r3, r7, #31
340262c2:	d50a      	bpl.n	340262da <__cvt+0x6c>
340262c4:	1902      	adds	r2, r0, r4
340262c6:	eeb5 8b40 	vcmp.f64	d8, #0.0
340262ca:	2130      	movs	r1, #48	@ 0x30
340262cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340262d0:	bf08      	it	eq
340262d2:	9203      	streq	r2, [sp, #12]
340262d4:	9b03      	ldr	r3, [sp, #12]
340262d6:	4293      	cmp	r3, r2
340262d8:	d319      	bcc.n	3402630e <__cvt+0xa0>
340262da:	9b03      	ldr	r3, [sp, #12]
340262dc:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340262de:	1a1b      	subs	r3, r3, r0
340262e0:	6013      	str	r3, [r2, #0]
340262e2:	b005      	add	sp, #20
340262e4:	ecbd 8b02 	vpop	{d8}
340262e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
340262ea:	2d46      	cmp	r5, #70	@ 0x46
340262ec:	eb00 0204 	add.w	r2, r0, r4
340262f0:	d1e9      	bne.n	340262c6 <__cvt+0x58>
340262f2:	7803      	ldrb	r3, [r0, #0]
340262f4:	2b30      	cmp	r3, #48	@ 0x30
340262f6:	d107      	bne.n	34026308 <__cvt+0x9a>
340262f8:	eeb5 8b40 	vcmp.f64	d8, #0.0
340262fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34026300:	bf1c      	itt	ne
34026302:	f1c4 0401 	rsbne	r4, r4, #1
34026306:	6034      	strne	r4, [r6, #0]
34026308:	6833      	ldr	r3, [r6, #0]
3402630a:	441a      	add	r2, r3
3402630c:	e7db      	b.n	340262c6 <__cvt+0x58>
3402630e:	1c5c      	adds	r4, r3, #1
34026310:	9403      	str	r4, [sp, #12]
34026312:	7019      	strb	r1, [r3, #0]
34026314:	e7de      	b.n	340262d4 <__cvt+0x66>

34026316 <__exponent>:
34026316:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34026318:	2900      	cmp	r1, #0
3402631a:	7002      	strb	r2, [r0, #0]
3402631c:	bfba      	itte	lt
3402631e:	4249      	neglt	r1, r1
34026320:	232d      	movlt	r3, #45	@ 0x2d
34026322:	232b      	movge	r3, #43	@ 0x2b
34026324:	2909      	cmp	r1, #9
34026326:	7043      	strb	r3, [r0, #1]
34026328:	dd28      	ble.n	3402637c <__exponent+0x66>
3402632a:	f10d 0307 	add.w	r3, sp, #7
3402632e:	270a      	movs	r7, #10
34026330:	461d      	mov	r5, r3
34026332:	461a      	mov	r2, r3
34026334:	3b01      	subs	r3, #1
34026336:	fbb1 f6f7 	udiv	r6, r1, r7
3402633a:	fb07 1416 	mls	r4, r7, r6, r1
3402633e:	3430      	adds	r4, #48	@ 0x30
34026340:	f802 4c01 	strb.w	r4, [r2, #-1]
34026344:	460c      	mov	r4, r1
34026346:	4631      	mov	r1, r6
34026348:	2c63      	cmp	r4, #99	@ 0x63
3402634a:	dcf2      	bgt.n	34026332 <__exponent+0x1c>
3402634c:	3130      	adds	r1, #48	@ 0x30
3402634e:	1e94      	subs	r4, r2, #2
34026350:	f803 1c01 	strb.w	r1, [r3, #-1]
34026354:	1c41      	adds	r1, r0, #1
34026356:	4623      	mov	r3, r4
34026358:	42ab      	cmp	r3, r5
3402635a:	d30a      	bcc.n	34026372 <__exponent+0x5c>
3402635c:	f10d 0309 	add.w	r3, sp, #9
34026360:	1a9b      	subs	r3, r3, r2
34026362:	42ac      	cmp	r4, r5
34026364:	bf88      	it	hi
34026366:	2300      	movhi	r3, #0
34026368:	3302      	adds	r3, #2
3402636a:	4403      	add	r3, r0
3402636c:	1a18      	subs	r0, r3, r0
3402636e:	b003      	add	sp, #12
34026370:	bdf0      	pop	{r4, r5, r6, r7, pc}
34026372:	f813 6b01 	ldrb.w	r6, [r3], #1
34026376:	f801 6f01 	strb.w	r6, [r1, #1]!
3402637a:	e7ed      	b.n	34026358 <__exponent+0x42>
3402637c:	2330      	movs	r3, #48	@ 0x30
3402637e:	3130      	adds	r1, #48	@ 0x30
34026380:	7083      	strb	r3, [r0, #2]
34026382:	1d03      	adds	r3, r0, #4
34026384:	70c1      	strb	r1, [r0, #3]
34026386:	e7f1      	b.n	3402636c <__exponent+0x56>

34026388 <_printf_float>:
34026388:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
3402638c:	b08d      	sub	sp, #52	@ 0x34
3402638e:	460c      	mov	r4, r1
34026390:	4616      	mov	r6, r2
34026392:	461f      	mov	r7, r3
34026394:	f8dd 8058 	ldr.w	r8, [sp, #88]	@ 0x58
34026398:	4605      	mov	r5, r0
3402639a:	f001 f8f5 	bl	34027588 <_localeconv_r>
3402639e:	f8d0 b000 	ldr.w	fp, [r0]
340263a2:	4658      	mov	r0, fp
340263a4:	f7db f9f2 	bl	3400178c <strlen>
340263a8:	2300      	movs	r3, #0
340263aa:	f894 9018 	ldrb.w	r9, [r4, #24]
340263ae:	930a      	str	r3, [sp, #40]	@ 0x28
340263b0:	f8d8 3000 	ldr.w	r3, [r8]
340263b4:	6822      	ldr	r2, [r4, #0]
340263b6:	3307      	adds	r3, #7
340263b8:	9005      	str	r0, [sp, #20]
340263ba:	f023 0307 	bic.w	r3, r3, #7
340263be:	f103 0108 	add.w	r1, r3, #8
340263c2:	f8c8 1000 	str.w	r1, [r8]
340263c6:	ed93 0b00 	vldr	d0, [r3]
340263ca:	ed9f 6b97 	vldr	d6, [pc, #604]	@ 34026628 <_printf_float+0x2a0>
340263ce:	eeb0 7bc0 	vabs.f64	d7, d0
340263d2:	ed84 0b12 	vstr	d0, [r4, #72]	@ 0x48
340263d6:	eeb4 7b46 	vcmp.f64	d7, d6
340263da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340263de:	dd24      	ble.n	3402642a <_printf_float+0xa2>
340263e0:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
340263e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340263e8:	d502      	bpl.n	340263f0 <_printf_float+0x68>
340263ea:	232d      	movs	r3, #45	@ 0x2d
340263ec:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340263f0:	498f      	ldr	r1, [pc, #572]	@ (34026630 <_printf_float+0x2a8>)
340263f2:	4b90      	ldr	r3, [pc, #576]	@ (34026634 <_printf_float+0x2ac>)
340263f4:	f1b9 0f47 	cmp.w	r9, #71	@ 0x47
340263f8:	bf8c      	ite	hi
340263fa:	4688      	movhi	r8, r1
340263fc:	4698      	movls	r8, r3
340263fe:	f022 0204 	bic.w	r2, r2, #4
34026402:	2303      	movs	r3, #3
34026404:	f04f 0a00 	mov.w	sl, #0
34026408:	6022      	str	r2, [r4, #0]
3402640a:	6123      	str	r3, [r4, #16]
3402640c:	4633      	mov	r3, r6
3402640e:	aa0b      	add	r2, sp, #44	@ 0x2c
34026410:	4621      	mov	r1, r4
34026412:	4628      	mov	r0, r5
34026414:	9700      	str	r7, [sp, #0]
34026416:	f000 f9d1 	bl	340267bc <_printf_common>
3402641a:	3001      	adds	r0, #1
3402641c:	f040 8089 	bne.w	34026532 <_printf_float+0x1aa>
34026420:	f04f 30ff 	mov.w	r0, #4294967295
34026424:	b00d      	add	sp, #52	@ 0x34
34026426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3402642a:	eeb4 0b40 	vcmp.f64	d0, d0
3402642e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34026432:	d709      	bvc.n	34026448 <_printf_float+0xc0>
34026434:	ee10 3a90 	vmov	r3, s1
34026438:	497f      	ldr	r1, [pc, #508]	@ (34026638 <_printf_float+0x2b0>)
3402643a:	2b00      	cmp	r3, #0
3402643c:	bfbc      	itt	lt
3402643e:	232d      	movlt	r3, #45	@ 0x2d
34026440:	f884 3043 	strblt.w	r3, [r4, #67]	@ 0x43
34026444:	4b7d      	ldr	r3, [pc, #500]	@ (3402663c <_printf_float+0x2b4>)
34026446:	e7d5      	b.n	340263f4 <_printf_float+0x6c>
34026448:	6863      	ldr	r3, [r4, #4]
3402644a:	f009 0adf 	and.w	sl, r9, #223	@ 0xdf
3402644e:	1c59      	adds	r1, r3, #1
34026450:	d139      	bne.n	340264c6 <_printf_float+0x13e>
34026452:	2306      	movs	r3, #6
34026454:	6063      	str	r3, [r4, #4]
34026456:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
3402645a:	2300      	movs	r3, #0
3402645c:	4628      	mov	r0, r5
3402645e:	6022      	str	r2, [r4, #0]
34026460:	9303      	str	r3, [sp, #12]
34026462:	ab0a      	add	r3, sp, #40	@ 0x28
34026464:	e9cd 9301 	strd	r9, r3, [sp, #4]
34026468:	ab09      	add	r3, sp, #36	@ 0x24
3402646a:	9300      	str	r3, [sp, #0]
3402646c:	f10d 0323 	add.w	r3, sp, #35	@ 0x23
34026470:	6861      	ldr	r1, [r4, #4]
34026472:	f7ff fefc 	bl	3402626e <__cvt>
34026476:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
3402647a:	4680      	mov	r8, r0
3402647c:	9909      	ldr	r1, [sp, #36]	@ 0x24
3402647e:	d129      	bne.n	340264d4 <_printf_float+0x14c>
34026480:	1cc8      	adds	r0, r1, #3
34026482:	db02      	blt.n	3402648a <_printf_float+0x102>
34026484:	6863      	ldr	r3, [r4, #4]
34026486:	4299      	cmp	r1, r3
34026488:	dd41      	ble.n	3402650e <_printf_float+0x186>
3402648a:	f1a9 0902 	sub.w	r9, r9, #2
3402648e:	fa5f f989 	uxtb.w	r9, r9
34026492:	3901      	subs	r1, #1
34026494:	464a      	mov	r2, r9
34026496:	f104 0050 	add.w	r0, r4, #80	@ 0x50
3402649a:	9109      	str	r1, [sp, #36]	@ 0x24
3402649c:	f7ff ff3b 	bl	34026316 <__exponent>
340264a0:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
340264a2:	4682      	mov	sl, r0
340264a4:	1813      	adds	r3, r2, r0
340264a6:	2a01      	cmp	r2, #1
340264a8:	6123      	str	r3, [r4, #16]
340264aa:	dc02      	bgt.n	340264b2 <_printf_float+0x12a>
340264ac:	6822      	ldr	r2, [r4, #0]
340264ae:	07d2      	lsls	r2, r2, #31
340264b0:	d501      	bpl.n	340264b6 <_printf_float+0x12e>
340264b2:	3301      	adds	r3, #1
340264b4:	6123      	str	r3, [r4, #16]
340264b6:	f89d 3023 	ldrb.w	r3, [sp, #35]	@ 0x23
340264ba:	2b00      	cmp	r3, #0
340264bc:	d0a6      	beq.n	3402640c <_printf_float+0x84>
340264be:	232d      	movs	r3, #45	@ 0x2d
340264c0:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
340264c4:	e7a2      	b.n	3402640c <_printf_float+0x84>
340264c6:	f1ba 0f47 	cmp.w	sl, #71	@ 0x47
340264ca:	d1c4      	bne.n	34026456 <_printf_float+0xce>
340264cc:	2b00      	cmp	r3, #0
340264ce:	d1c2      	bne.n	34026456 <_printf_float+0xce>
340264d0:	2301      	movs	r3, #1
340264d2:	e7bf      	b.n	34026454 <_printf_float+0xcc>
340264d4:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
340264d8:	d9db      	bls.n	34026492 <_printf_float+0x10a>
340264da:	f1b9 0f66 	cmp.w	r9, #102	@ 0x66
340264de:	d118      	bne.n	34026512 <_printf_float+0x18a>
340264e0:	2900      	cmp	r1, #0
340264e2:	6863      	ldr	r3, [r4, #4]
340264e4:	dd0b      	ble.n	340264fe <_printf_float+0x176>
340264e6:	6121      	str	r1, [r4, #16]
340264e8:	b913      	cbnz	r3, 340264f0 <_printf_float+0x168>
340264ea:	6822      	ldr	r2, [r4, #0]
340264ec:	07d0      	lsls	r0, r2, #31
340264ee:	d502      	bpl.n	340264f6 <_printf_float+0x16e>
340264f0:	3301      	adds	r3, #1
340264f2:	440b      	add	r3, r1
340264f4:	6123      	str	r3, [r4, #16]
340264f6:	f04f 0a00 	mov.w	sl, #0
340264fa:	65a1      	str	r1, [r4, #88]	@ 0x58
340264fc:	e7db      	b.n	340264b6 <_printf_float+0x12e>
340264fe:	b913      	cbnz	r3, 34026506 <_printf_float+0x17e>
34026500:	6822      	ldr	r2, [r4, #0]
34026502:	07d2      	lsls	r2, r2, #31
34026504:	d501      	bpl.n	3402650a <_printf_float+0x182>
34026506:	3302      	adds	r3, #2
34026508:	e7f4      	b.n	340264f4 <_printf_float+0x16c>
3402650a:	2301      	movs	r3, #1
3402650c:	e7f2      	b.n	340264f4 <_printf_float+0x16c>
3402650e:	f04f 0967 	mov.w	r9, #103	@ 0x67
34026512:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34026514:	4299      	cmp	r1, r3
34026516:	db05      	blt.n	34026524 <_printf_float+0x19c>
34026518:	6823      	ldr	r3, [r4, #0]
3402651a:	6121      	str	r1, [r4, #16]
3402651c:	07d8      	lsls	r0, r3, #31
3402651e:	d5ea      	bpl.n	340264f6 <_printf_float+0x16e>
34026520:	1c4b      	adds	r3, r1, #1
34026522:	e7e7      	b.n	340264f4 <_printf_float+0x16c>
34026524:	2900      	cmp	r1, #0
34026526:	bfd4      	ite	le
34026528:	f1c1 0202 	rsble	r2, r1, #2
3402652c:	2201      	movgt	r2, #1
3402652e:	4413      	add	r3, r2
34026530:	e7e0      	b.n	340264f4 <_printf_float+0x16c>
34026532:	6823      	ldr	r3, [r4, #0]
34026534:	055a      	lsls	r2, r3, #21
34026536:	d407      	bmi.n	34026548 <_printf_float+0x1c0>
34026538:	6923      	ldr	r3, [r4, #16]
3402653a:	4642      	mov	r2, r8
3402653c:	4631      	mov	r1, r6
3402653e:	4628      	mov	r0, r5
34026540:	47b8      	blx	r7
34026542:	3001      	adds	r0, #1
34026544:	d12a      	bne.n	3402659c <_printf_float+0x214>
34026546:	e76b      	b.n	34026420 <_printf_float+0x98>
34026548:	f1b9 0f65 	cmp.w	r9, #101	@ 0x65
3402654c:	f240 80e0 	bls.w	34026710 <_printf_float+0x388>
34026550:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
34026554:	eeb5 7b40 	vcmp.f64	d7, #0.0
34026558:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402655c:	d133      	bne.n	340265c6 <_printf_float+0x23e>
3402655e:	2301      	movs	r3, #1
34026560:	4a37      	ldr	r2, [pc, #220]	@ (34026640 <_printf_float+0x2b8>)
34026562:	4631      	mov	r1, r6
34026564:	4628      	mov	r0, r5
34026566:	47b8      	blx	r7
34026568:	3001      	adds	r0, #1
3402656a:	f43f af59 	beq.w	34026420 <_printf_float+0x98>
3402656e:	e9dd 3809 	ldrd	r3, r8, [sp, #36]	@ 0x24
34026572:	4543      	cmp	r3, r8
34026574:	db02      	blt.n	3402657c <_printf_float+0x1f4>
34026576:	6823      	ldr	r3, [r4, #0]
34026578:	07d8      	lsls	r0, r3, #31
3402657a:	d50f      	bpl.n	3402659c <_printf_float+0x214>
3402657c:	9b05      	ldr	r3, [sp, #20]
3402657e:	465a      	mov	r2, fp
34026580:	4631      	mov	r1, r6
34026582:	4628      	mov	r0, r5
34026584:	47b8      	blx	r7
34026586:	3001      	adds	r0, #1
34026588:	f43f af4a 	beq.w	34026420 <_printf_float+0x98>
3402658c:	f04f 0900 	mov.w	r9, #0
34026590:	f108 38ff 	add.w	r8, r8, #4294967295
34026594:	f104 0a1a 	add.w	sl, r4, #26
34026598:	45c8      	cmp	r8, r9
3402659a:	dc09      	bgt.n	340265b0 <_printf_float+0x228>
3402659c:	6823      	ldr	r3, [r4, #0]
3402659e:	079b      	lsls	r3, r3, #30
340265a0:	f100 8107 	bmi.w	340267b2 <_printf_float+0x42a>
340265a4:	68e0      	ldr	r0, [r4, #12]
340265a6:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
340265a8:	4298      	cmp	r0, r3
340265aa:	bfb8      	it	lt
340265ac:	4618      	movlt	r0, r3
340265ae:	e739      	b.n	34026424 <_printf_float+0x9c>
340265b0:	2301      	movs	r3, #1
340265b2:	4652      	mov	r2, sl
340265b4:	4631      	mov	r1, r6
340265b6:	4628      	mov	r0, r5
340265b8:	47b8      	blx	r7
340265ba:	3001      	adds	r0, #1
340265bc:	f43f af30 	beq.w	34026420 <_printf_float+0x98>
340265c0:	f109 0901 	add.w	r9, r9, #1
340265c4:	e7e8      	b.n	34026598 <_printf_float+0x210>
340265c6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340265c8:	2b00      	cmp	r3, #0
340265ca:	dc3b      	bgt.n	34026644 <_printf_float+0x2bc>
340265cc:	2301      	movs	r3, #1
340265ce:	4a1c      	ldr	r2, [pc, #112]	@ (34026640 <_printf_float+0x2b8>)
340265d0:	4631      	mov	r1, r6
340265d2:	4628      	mov	r0, r5
340265d4:	47b8      	blx	r7
340265d6:	3001      	adds	r0, #1
340265d8:	f43f af22 	beq.w	34026420 <_printf_float+0x98>
340265dc:	e9dd 3909 	ldrd	r3, r9, [sp, #36]	@ 0x24
340265e0:	ea59 0303 	orrs.w	r3, r9, r3
340265e4:	d102      	bne.n	340265ec <_printf_float+0x264>
340265e6:	6823      	ldr	r3, [r4, #0]
340265e8:	07d9      	lsls	r1, r3, #31
340265ea:	d5d7      	bpl.n	3402659c <_printf_float+0x214>
340265ec:	9b05      	ldr	r3, [sp, #20]
340265ee:	465a      	mov	r2, fp
340265f0:	4631      	mov	r1, r6
340265f2:	4628      	mov	r0, r5
340265f4:	47b8      	blx	r7
340265f6:	3001      	adds	r0, #1
340265f8:	f43f af12 	beq.w	34026420 <_printf_float+0x98>
340265fc:	f04f 0a00 	mov.w	sl, #0
34026600:	f104 0b1a 	add.w	fp, r4, #26
34026604:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34026606:	425b      	negs	r3, r3
34026608:	4553      	cmp	r3, sl
3402660a:	dc01      	bgt.n	34026610 <_printf_float+0x288>
3402660c:	464b      	mov	r3, r9
3402660e:	e794      	b.n	3402653a <_printf_float+0x1b2>
34026610:	2301      	movs	r3, #1
34026612:	465a      	mov	r2, fp
34026614:	4631      	mov	r1, r6
34026616:	4628      	mov	r0, r5
34026618:	47b8      	blx	r7
3402661a:	3001      	adds	r0, #1
3402661c:	f43f af00 	beq.w	34026420 <_printf_float+0x98>
34026620:	f10a 0a01 	add.w	sl, sl, #1
34026624:	e7ee      	b.n	34026604 <_printf_float+0x27c>
34026626:	bf00      	nop
34026628:	ffffffff 	.word	0xffffffff
3402662c:	7fefffff 	.word	0x7fefffff
34026630:	3403e5e5 	.word	0x3403e5e5
34026634:	3403e5e1 	.word	0x3403e5e1
34026638:	3403e5ed 	.word	0x3403e5ed
3402663c:	3403e5e9 	.word	0x3403e5e9
34026640:	3403e5f1 	.word	0x3403e5f1
34026644:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34026646:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
3402664a:	4553      	cmp	r3, sl
3402664c:	bfa8      	it	ge
3402664e:	4653      	movge	r3, sl
34026650:	2b00      	cmp	r3, #0
34026652:	4699      	mov	r9, r3
34026654:	dc37      	bgt.n	340266c6 <_printf_float+0x33e>
34026656:	2300      	movs	r3, #0
34026658:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
3402665c:	f104 021a 	add.w	r2, r4, #26
34026660:	9307      	str	r3, [sp, #28]
34026662:	6da3      	ldr	r3, [r4, #88]	@ 0x58
34026664:	9907      	ldr	r1, [sp, #28]
34026666:	9306      	str	r3, [sp, #24]
34026668:	eba3 0309 	sub.w	r3, r3, r9
3402666c:	428b      	cmp	r3, r1
3402666e:	dc31      	bgt.n	340266d4 <_printf_float+0x34c>
34026670:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34026672:	459a      	cmp	sl, r3
34026674:	dc3b      	bgt.n	340266ee <_printf_float+0x366>
34026676:	6823      	ldr	r3, [r4, #0]
34026678:	07da      	lsls	r2, r3, #31
3402667a:	d438      	bmi.n	340266ee <_printf_float+0x366>
3402667c:	9b09      	ldr	r3, [sp, #36]	@ 0x24
3402667e:	ebaa 0903 	sub.w	r9, sl, r3
34026682:	9b06      	ldr	r3, [sp, #24]
34026684:	ebaa 0303 	sub.w	r3, sl, r3
34026688:	4599      	cmp	r9, r3
3402668a:	bfa8      	it	ge
3402668c:	4699      	movge	r9, r3
3402668e:	f1b9 0f00 	cmp.w	r9, #0
34026692:	dc34      	bgt.n	340266fe <_printf_float+0x376>
34026694:	f04f 0800 	mov.w	r8, #0
34026698:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
3402669c:	f104 0b1a 	add.w	fp, r4, #26
340266a0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
340266a2:	ebaa 0303 	sub.w	r3, sl, r3
340266a6:	eba3 0309 	sub.w	r3, r3, r9
340266aa:	4543      	cmp	r3, r8
340266ac:	f77f af76 	ble.w	3402659c <_printf_float+0x214>
340266b0:	2301      	movs	r3, #1
340266b2:	465a      	mov	r2, fp
340266b4:	4631      	mov	r1, r6
340266b6:	4628      	mov	r0, r5
340266b8:	47b8      	blx	r7
340266ba:	3001      	adds	r0, #1
340266bc:	f43f aeb0 	beq.w	34026420 <_printf_float+0x98>
340266c0:	f108 0801 	add.w	r8, r8, #1
340266c4:	e7ec      	b.n	340266a0 <_printf_float+0x318>
340266c6:	4642      	mov	r2, r8
340266c8:	4631      	mov	r1, r6
340266ca:	4628      	mov	r0, r5
340266cc:	47b8      	blx	r7
340266ce:	3001      	adds	r0, #1
340266d0:	d1c1      	bne.n	34026656 <_printf_float+0x2ce>
340266d2:	e6a5      	b.n	34026420 <_printf_float+0x98>
340266d4:	2301      	movs	r3, #1
340266d6:	4631      	mov	r1, r6
340266d8:	4628      	mov	r0, r5
340266da:	9206      	str	r2, [sp, #24]
340266dc:	47b8      	blx	r7
340266de:	3001      	adds	r0, #1
340266e0:	f43f ae9e 	beq.w	34026420 <_printf_float+0x98>
340266e4:	9b07      	ldr	r3, [sp, #28]
340266e6:	9a06      	ldr	r2, [sp, #24]
340266e8:	3301      	adds	r3, #1
340266ea:	9307      	str	r3, [sp, #28]
340266ec:	e7b9      	b.n	34026662 <_printf_float+0x2da>
340266ee:	9b05      	ldr	r3, [sp, #20]
340266f0:	465a      	mov	r2, fp
340266f2:	4631      	mov	r1, r6
340266f4:	4628      	mov	r0, r5
340266f6:	47b8      	blx	r7
340266f8:	3001      	adds	r0, #1
340266fa:	d1bf      	bne.n	3402667c <_printf_float+0x2f4>
340266fc:	e690      	b.n	34026420 <_printf_float+0x98>
340266fe:	9a06      	ldr	r2, [sp, #24]
34026700:	464b      	mov	r3, r9
34026702:	4631      	mov	r1, r6
34026704:	4628      	mov	r0, r5
34026706:	4442      	add	r2, r8
34026708:	47b8      	blx	r7
3402670a:	3001      	adds	r0, #1
3402670c:	d1c2      	bne.n	34026694 <_printf_float+0x30c>
3402670e:	e687      	b.n	34026420 <_printf_float+0x98>
34026710:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
34026714:	f1b9 0f01 	cmp.w	r9, #1
34026718:	dc01      	bgt.n	3402671e <_printf_float+0x396>
3402671a:	07db      	lsls	r3, r3, #31
3402671c:	d536      	bpl.n	3402678c <_printf_float+0x404>
3402671e:	2301      	movs	r3, #1
34026720:	4642      	mov	r2, r8
34026722:	4631      	mov	r1, r6
34026724:	4628      	mov	r0, r5
34026726:	47b8      	blx	r7
34026728:	3001      	adds	r0, #1
3402672a:	f43f ae79 	beq.w	34026420 <_printf_float+0x98>
3402672e:	9b05      	ldr	r3, [sp, #20]
34026730:	465a      	mov	r2, fp
34026732:	4631      	mov	r1, r6
34026734:	4628      	mov	r0, r5
34026736:	47b8      	blx	r7
34026738:	3001      	adds	r0, #1
3402673a:	f43f ae71 	beq.w	34026420 <_printf_float+0x98>
3402673e:	f109 39ff 	add.w	r9, r9, #4294967295
34026742:	ed94 7b12 	vldr	d7, [r4, #72]	@ 0x48
34026746:	eeb5 7b40 	vcmp.f64	d7, #0.0
3402674a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402674e:	d018      	beq.n	34026782 <_printf_float+0x3fa>
34026750:	464b      	mov	r3, r9
34026752:	f108 0201 	add.w	r2, r8, #1
34026756:	4631      	mov	r1, r6
34026758:	4628      	mov	r0, r5
3402675a:	47b8      	blx	r7
3402675c:	3001      	adds	r0, #1
3402675e:	d10c      	bne.n	3402677a <_printf_float+0x3f2>
34026760:	e65e      	b.n	34026420 <_printf_float+0x98>
34026762:	2301      	movs	r3, #1
34026764:	465a      	mov	r2, fp
34026766:	4631      	mov	r1, r6
34026768:	4628      	mov	r0, r5
3402676a:	47b8      	blx	r7
3402676c:	3001      	adds	r0, #1
3402676e:	f43f ae57 	beq.w	34026420 <_printf_float+0x98>
34026772:	f108 0801 	add.w	r8, r8, #1
34026776:	45c8      	cmp	r8, r9
34026778:	dbf3      	blt.n	34026762 <_printf_float+0x3da>
3402677a:	4653      	mov	r3, sl
3402677c:	f104 0250 	add.w	r2, r4, #80	@ 0x50
34026780:	e6dc      	b.n	3402653c <_printf_float+0x1b4>
34026782:	f04f 0800 	mov.w	r8, #0
34026786:	f104 0b1a 	add.w	fp, r4, #26
3402678a:	e7f4      	b.n	34026776 <_printf_float+0x3ee>
3402678c:	2301      	movs	r3, #1
3402678e:	4642      	mov	r2, r8
34026790:	e7e1      	b.n	34026756 <_printf_float+0x3ce>
34026792:	2301      	movs	r3, #1
34026794:	464a      	mov	r2, r9
34026796:	4631      	mov	r1, r6
34026798:	4628      	mov	r0, r5
3402679a:	47b8      	blx	r7
3402679c:	3001      	adds	r0, #1
3402679e:	f43f ae3f 	beq.w	34026420 <_printf_float+0x98>
340267a2:	f108 0801 	add.w	r8, r8, #1
340267a6:	68e3      	ldr	r3, [r4, #12]
340267a8:	990b      	ldr	r1, [sp, #44]	@ 0x2c
340267aa:	1a5b      	subs	r3, r3, r1
340267ac:	4543      	cmp	r3, r8
340267ae:	dcf0      	bgt.n	34026792 <_printf_float+0x40a>
340267b0:	e6f8      	b.n	340265a4 <_printf_float+0x21c>
340267b2:	f04f 0800 	mov.w	r8, #0
340267b6:	f104 0919 	add.w	r9, r4, #25
340267ba:	e7f4      	b.n	340267a6 <_printf_float+0x41e>

340267bc <_printf_common>:
340267bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
340267c0:	4616      	mov	r6, r2
340267c2:	4698      	mov	r8, r3
340267c4:	688a      	ldr	r2, [r1, #8]
340267c6:	4607      	mov	r7, r0
340267c8:	690b      	ldr	r3, [r1, #16]
340267ca:	460c      	mov	r4, r1
340267cc:	f8dd 9020 	ldr.w	r9, [sp, #32]
340267d0:	4293      	cmp	r3, r2
340267d2:	bfb8      	it	lt
340267d4:	4613      	movlt	r3, r2
340267d6:	6033      	str	r3, [r6, #0]
340267d8:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
340267dc:	b10a      	cbz	r2, 340267e2 <_printf_common+0x26>
340267de:	3301      	adds	r3, #1
340267e0:	6033      	str	r3, [r6, #0]
340267e2:	6823      	ldr	r3, [r4, #0]
340267e4:	0699      	lsls	r1, r3, #26
340267e6:	bf42      	ittt	mi
340267e8:	6833      	ldrmi	r3, [r6, #0]
340267ea:	3302      	addmi	r3, #2
340267ec:	6033      	strmi	r3, [r6, #0]
340267ee:	6825      	ldr	r5, [r4, #0]
340267f0:	f015 0506 	ands.w	r5, r5, #6
340267f4:	d106      	bne.n	34026804 <_printf_common+0x48>
340267f6:	f104 0a19 	add.w	sl, r4, #25
340267fa:	68e3      	ldr	r3, [r4, #12]
340267fc:	6832      	ldr	r2, [r6, #0]
340267fe:	1a9b      	subs	r3, r3, r2
34026800:	42ab      	cmp	r3, r5
34026802:	dc2b      	bgt.n	3402685c <_printf_common+0xa0>
34026804:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
34026808:	6822      	ldr	r2, [r4, #0]
3402680a:	3b00      	subs	r3, #0
3402680c:	bf18      	it	ne
3402680e:	2301      	movne	r3, #1
34026810:	0692      	lsls	r2, r2, #26
34026812:	d430      	bmi.n	34026876 <_printf_common+0xba>
34026814:	f104 0243 	add.w	r2, r4, #67	@ 0x43
34026818:	4641      	mov	r1, r8
3402681a:	4638      	mov	r0, r7
3402681c:	47c8      	blx	r9
3402681e:	3001      	adds	r0, #1
34026820:	d023      	beq.n	3402686a <_printf_common+0xae>
34026822:	6823      	ldr	r3, [r4, #0]
34026824:	341a      	adds	r4, #26
34026826:	f854 2c0a 	ldr.w	r2, [r4, #-10]
3402682a:	f003 0306 	and.w	r3, r3, #6
3402682e:	2b04      	cmp	r3, #4
34026830:	bf0a      	itet	eq
34026832:	f854 5c0e 	ldreq.w	r5, [r4, #-14]
34026836:	2500      	movne	r5, #0
34026838:	6833      	ldreq	r3, [r6, #0]
3402683a:	f04f 0600 	mov.w	r6, #0
3402683e:	bf08      	it	eq
34026840:	1aed      	subeq	r5, r5, r3
34026842:	f854 3c12 	ldr.w	r3, [r4, #-18]
34026846:	bf08      	it	eq
34026848:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
3402684c:	4293      	cmp	r3, r2
3402684e:	bfc4      	itt	gt
34026850:	1a9b      	subgt	r3, r3, r2
34026852:	18ed      	addgt	r5, r5, r3
34026854:	42b5      	cmp	r5, r6
34026856:	d11a      	bne.n	3402688e <_printf_common+0xd2>
34026858:	2000      	movs	r0, #0
3402685a:	e008      	b.n	3402686e <_printf_common+0xb2>
3402685c:	2301      	movs	r3, #1
3402685e:	4652      	mov	r2, sl
34026860:	4641      	mov	r1, r8
34026862:	4638      	mov	r0, r7
34026864:	47c8      	blx	r9
34026866:	3001      	adds	r0, #1
34026868:	d103      	bne.n	34026872 <_printf_common+0xb6>
3402686a:	f04f 30ff 	mov.w	r0, #4294967295
3402686e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34026872:	3501      	adds	r5, #1
34026874:	e7c1      	b.n	340267fa <_printf_common+0x3e>
34026876:	18e1      	adds	r1, r4, r3
34026878:	1c5a      	adds	r2, r3, #1
3402687a:	2030      	movs	r0, #48	@ 0x30
3402687c:	3302      	adds	r3, #2
3402687e:	4422      	add	r2, r4
34026880:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
34026884:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
34026888:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
3402688c:	e7c2      	b.n	34026814 <_printf_common+0x58>
3402688e:	2301      	movs	r3, #1
34026890:	4622      	mov	r2, r4
34026892:	4641      	mov	r1, r8
34026894:	4638      	mov	r0, r7
34026896:	47c8      	blx	r9
34026898:	3001      	adds	r0, #1
3402689a:	d0e6      	beq.n	3402686a <_printf_common+0xae>
3402689c:	3601      	adds	r6, #1
3402689e:	e7d9      	b.n	34026854 <_printf_common+0x98>

340268a0 <_printf_i>:
340268a0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
340268a4:	7e0f      	ldrb	r7, [r1, #24]
340268a6:	4691      	mov	r9, r2
340268a8:	4680      	mov	r8, r0
340268aa:	460c      	mov	r4, r1
340268ac:	2f78      	cmp	r7, #120	@ 0x78
340268ae:	469a      	mov	sl, r3
340268b0:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
340268b2:	f101 0243 	add.w	r2, r1, #67	@ 0x43
340268b6:	d807      	bhi.n	340268c8 <_printf_i+0x28>
340268b8:	2f62      	cmp	r7, #98	@ 0x62
340268ba:	d80a      	bhi.n	340268d2 <_printf_i+0x32>
340268bc:	2f00      	cmp	r7, #0
340268be:	f000 80d1 	beq.w	34026a64 <_printf_i+0x1c4>
340268c2:	2f58      	cmp	r7, #88	@ 0x58
340268c4:	f000 80b8 	beq.w	34026a38 <_printf_i+0x198>
340268c8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
340268cc:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
340268d0:	e03a      	b.n	34026948 <_printf_i+0xa8>
340268d2:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
340268d6:	2b15      	cmp	r3, #21
340268d8:	d8f6      	bhi.n	340268c8 <_printf_i+0x28>
340268da:	a101      	add	r1, pc, #4	@ (adr r1, 340268e0 <_printf_i+0x40>)
340268dc:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
340268e0:	34026939 	.word	0x34026939
340268e4:	3402694d 	.word	0x3402694d
340268e8:	340268c9 	.word	0x340268c9
340268ec:	340268c9 	.word	0x340268c9
340268f0:	340268c9 	.word	0x340268c9
340268f4:	340268c9 	.word	0x340268c9
340268f8:	3402694d 	.word	0x3402694d
340268fc:	340268c9 	.word	0x340268c9
34026900:	340268c9 	.word	0x340268c9
34026904:	340268c9 	.word	0x340268c9
34026908:	340268c9 	.word	0x340268c9
3402690c:	34026a4b 	.word	0x34026a4b
34026910:	34026977 	.word	0x34026977
34026914:	34026a05 	.word	0x34026a05
34026918:	340268c9 	.word	0x340268c9
3402691c:	340268c9 	.word	0x340268c9
34026920:	34026a6d 	.word	0x34026a6d
34026924:	340268c9 	.word	0x340268c9
34026928:	34026977 	.word	0x34026977
3402692c:	340268c9 	.word	0x340268c9
34026930:	340268c9 	.word	0x340268c9
34026934:	34026a0d 	.word	0x34026a0d
34026938:	6833      	ldr	r3, [r6, #0]
3402693a:	1d1a      	adds	r2, r3, #4
3402693c:	681b      	ldr	r3, [r3, #0]
3402693e:	6032      	str	r2, [r6, #0]
34026940:	f104 0642 	add.w	r6, r4, #66	@ 0x42
34026944:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
34026948:	2301      	movs	r3, #1
3402694a:	e09c      	b.n	34026a86 <_printf_i+0x1e6>
3402694c:	6833      	ldr	r3, [r6, #0]
3402694e:	6820      	ldr	r0, [r4, #0]
34026950:	1d19      	adds	r1, r3, #4
34026952:	6031      	str	r1, [r6, #0]
34026954:	0606      	lsls	r6, r0, #24
34026956:	d501      	bpl.n	3402695c <_printf_i+0xbc>
34026958:	681d      	ldr	r5, [r3, #0]
3402695a:	e003      	b.n	34026964 <_printf_i+0xc4>
3402695c:	0645      	lsls	r5, r0, #25
3402695e:	d5fb      	bpl.n	34026958 <_printf_i+0xb8>
34026960:	f9b3 5000 	ldrsh.w	r5, [r3]
34026964:	2d00      	cmp	r5, #0
34026966:	da03      	bge.n	34026970 <_printf_i+0xd0>
34026968:	232d      	movs	r3, #45	@ 0x2d
3402696a:	426d      	negs	r5, r5
3402696c:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34026970:	4858      	ldr	r0, [pc, #352]	@ (34026ad4 <_printf_i+0x234>)
34026972:	230a      	movs	r3, #10
34026974:	e011      	b.n	3402699a <_printf_i+0xfa>
34026976:	6821      	ldr	r1, [r4, #0]
34026978:	6833      	ldr	r3, [r6, #0]
3402697a:	0608      	lsls	r0, r1, #24
3402697c:	f853 5b04 	ldr.w	r5, [r3], #4
34026980:	d402      	bmi.n	34026988 <_printf_i+0xe8>
34026982:	0649      	lsls	r1, r1, #25
34026984:	bf48      	it	mi
34026986:	b2ad      	uxthmi	r5, r5
34026988:	2f6f      	cmp	r7, #111	@ 0x6f
3402698a:	6033      	str	r3, [r6, #0]
3402698c:	4851      	ldr	r0, [pc, #324]	@ (34026ad4 <_printf_i+0x234>)
3402698e:	bf14      	ite	ne
34026990:	230a      	movne	r3, #10
34026992:	2308      	moveq	r3, #8
34026994:	2100      	movs	r1, #0
34026996:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
3402699a:	6866      	ldr	r6, [r4, #4]
3402699c:	2e00      	cmp	r6, #0
3402699e:	60a6      	str	r6, [r4, #8]
340269a0:	db05      	blt.n	340269ae <_printf_i+0x10e>
340269a2:	6821      	ldr	r1, [r4, #0]
340269a4:	432e      	orrs	r6, r5
340269a6:	f021 0104 	bic.w	r1, r1, #4
340269aa:	6021      	str	r1, [r4, #0]
340269ac:	d04b      	beq.n	34026a46 <_printf_i+0x1a6>
340269ae:	4616      	mov	r6, r2
340269b0:	fbb5 f1f3 	udiv	r1, r5, r3
340269b4:	fb03 5711 	mls	r7, r3, r1, r5
340269b8:	5dc7      	ldrb	r7, [r0, r7]
340269ba:	f806 7d01 	strb.w	r7, [r6, #-1]!
340269be:	462f      	mov	r7, r5
340269c0:	460d      	mov	r5, r1
340269c2:	42bb      	cmp	r3, r7
340269c4:	d9f4      	bls.n	340269b0 <_printf_i+0x110>
340269c6:	2b08      	cmp	r3, #8
340269c8:	d10b      	bne.n	340269e2 <_printf_i+0x142>
340269ca:	6823      	ldr	r3, [r4, #0]
340269cc:	07df      	lsls	r7, r3, #31
340269ce:	d508      	bpl.n	340269e2 <_printf_i+0x142>
340269d0:	6923      	ldr	r3, [r4, #16]
340269d2:	6861      	ldr	r1, [r4, #4]
340269d4:	4299      	cmp	r1, r3
340269d6:	bfde      	ittt	le
340269d8:	2330      	movle	r3, #48	@ 0x30
340269da:	f806 3c01 	strble.w	r3, [r6, #-1]
340269de:	f106 36ff 	addle.w	r6, r6, #4294967295
340269e2:	1b92      	subs	r2, r2, r6
340269e4:	6122      	str	r2, [r4, #16]
340269e6:	464b      	mov	r3, r9
340269e8:	aa03      	add	r2, sp, #12
340269ea:	4621      	mov	r1, r4
340269ec:	4640      	mov	r0, r8
340269ee:	f8cd a000 	str.w	sl, [sp]
340269f2:	f7ff fee3 	bl	340267bc <_printf_common>
340269f6:	3001      	adds	r0, #1
340269f8:	d14a      	bne.n	34026a90 <_printf_i+0x1f0>
340269fa:	f04f 30ff 	mov.w	r0, #4294967295
340269fe:	b004      	add	sp, #16
34026a00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34026a04:	6823      	ldr	r3, [r4, #0]
34026a06:	f043 0320 	orr.w	r3, r3, #32
34026a0a:	6023      	str	r3, [r4, #0]
34026a0c:	2778      	movs	r7, #120	@ 0x78
34026a0e:	4832      	ldr	r0, [pc, #200]	@ (34026ad8 <_printf_i+0x238>)
34026a10:	6823      	ldr	r3, [r4, #0]
34026a12:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
34026a16:	061f      	lsls	r7, r3, #24
34026a18:	6831      	ldr	r1, [r6, #0]
34026a1a:	f851 5b04 	ldr.w	r5, [r1], #4
34026a1e:	d402      	bmi.n	34026a26 <_printf_i+0x186>
34026a20:	065f      	lsls	r7, r3, #25
34026a22:	bf48      	it	mi
34026a24:	b2ad      	uxthmi	r5, r5
34026a26:	6031      	str	r1, [r6, #0]
34026a28:	07d9      	lsls	r1, r3, #31
34026a2a:	bf44      	itt	mi
34026a2c:	f043 0320 	orrmi.w	r3, r3, #32
34026a30:	6023      	strmi	r3, [r4, #0]
34026a32:	b11d      	cbz	r5, 34026a3c <_printf_i+0x19c>
34026a34:	2310      	movs	r3, #16
34026a36:	e7ad      	b.n	34026994 <_printf_i+0xf4>
34026a38:	4826      	ldr	r0, [pc, #152]	@ (34026ad4 <_printf_i+0x234>)
34026a3a:	e7e9      	b.n	34026a10 <_printf_i+0x170>
34026a3c:	6823      	ldr	r3, [r4, #0]
34026a3e:	f023 0320 	bic.w	r3, r3, #32
34026a42:	6023      	str	r3, [r4, #0]
34026a44:	e7f6      	b.n	34026a34 <_printf_i+0x194>
34026a46:	4616      	mov	r6, r2
34026a48:	e7bd      	b.n	340269c6 <_printf_i+0x126>
34026a4a:	6833      	ldr	r3, [r6, #0]
34026a4c:	6825      	ldr	r5, [r4, #0]
34026a4e:	1d18      	adds	r0, r3, #4
34026a50:	6961      	ldr	r1, [r4, #20]
34026a52:	6030      	str	r0, [r6, #0]
34026a54:	062e      	lsls	r6, r5, #24
34026a56:	681b      	ldr	r3, [r3, #0]
34026a58:	d501      	bpl.n	34026a5e <_printf_i+0x1be>
34026a5a:	6019      	str	r1, [r3, #0]
34026a5c:	e002      	b.n	34026a64 <_printf_i+0x1c4>
34026a5e:	0668      	lsls	r0, r5, #25
34026a60:	d5fb      	bpl.n	34026a5a <_printf_i+0x1ba>
34026a62:	8019      	strh	r1, [r3, #0]
34026a64:	2300      	movs	r3, #0
34026a66:	4616      	mov	r6, r2
34026a68:	6123      	str	r3, [r4, #16]
34026a6a:	e7bc      	b.n	340269e6 <_printf_i+0x146>
34026a6c:	6833      	ldr	r3, [r6, #0]
34026a6e:	2100      	movs	r1, #0
34026a70:	1d1a      	adds	r2, r3, #4
34026a72:	6032      	str	r2, [r6, #0]
34026a74:	681e      	ldr	r6, [r3, #0]
34026a76:	6862      	ldr	r2, [r4, #4]
34026a78:	4630      	mov	r0, r6
34026a7a:	f000 fe0c 	bl	34027696 <memchr>
34026a7e:	b108      	cbz	r0, 34026a84 <_printf_i+0x1e4>
34026a80:	1b80      	subs	r0, r0, r6
34026a82:	6060      	str	r0, [r4, #4]
34026a84:	6863      	ldr	r3, [r4, #4]
34026a86:	6123      	str	r3, [r4, #16]
34026a88:	2300      	movs	r3, #0
34026a8a:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
34026a8e:	e7aa      	b.n	340269e6 <_printf_i+0x146>
34026a90:	6923      	ldr	r3, [r4, #16]
34026a92:	4632      	mov	r2, r6
34026a94:	4649      	mov	r1, r9
34026a96:	4640      	mov	r0, r8
34026a98:	47d0      	blx	sl
34026a9a:	3001      	adds	r0, #1
34026a9c:	d0ad      	beq.n	340269fa <_printf_i+0x15a>
34026a9e:	6823      	ldr	r3, [r4, #0]
34026aa0:	079b      	lsls	r3, r3, #30
34026aa2:	d413      	bmi.n	34026acc <_printf_i+0x22c>
34026aa4:	68e0      	ldr	r0, [r4, #12]
34026aa6:	9b03      	ldr	r3, [sp, #12]
34026aa8:	4298      	cmp	r0, r3
34026aaa:	bfb8      	it	lt
34026aac:	4618      	movlt	r0, r3
34026aae:	e7a6      	b.n	340269fe <_printf_i+0x15e>
34026ab0:	2301      	movs	r3, #1
34026ab2:	4632      	mov	r2, r6
34026ab4:	4649      	mov	r1, r9
34026ab6:	4640      	mov	r0, r8
34026ab8:	47d0      	blx	sl
34026aba:	3001      	adds	r0, #1
34026abc:	d09d      	beq.n	340269fa <_printf_i+0x15a>
34026abe:	3501      	adds	r5, #1
34026ac0:	68e3      	ldr	r3, [r4, #12]
34026ac2:	9903      	ldr	r1, [sp, #12]
34026ac4:	1a5b      	subs	r3, r3, r1
34026ac6:	42ab      	cmp	r3, r5
34026ac8:	dcf2      	bgt.n	34026ab0 <_printf_i+0x210>
34026aca:	e7eb      	b.n	34026aa4 <_printf_i+0x204>
34026acc:	2500      	movs	r5, #0
34026ace:	f104 0619 	add.w	r6, r4, #25
34026ad2:	e7f5      	b.n	34026ac0 <_printf_i+0x220>
34026ad4:	3403e5f3 	.word	0x3403e5f3
34026ad8:	3403e604 	.word	0x3403e604

34026adc <std>:
34026adc:	2300      	movs	r3, #0
34026ade:	b510      	push	{r4, lr}
34026ae0:	4604      	mov	r4, r0
34026ae2:	6083      	str	r3, [r0, #8]
34026ae4:	8181      	strh	r1, [r0, #12]
34026ae6:	4619      	mov	r1, r3
34026ae8:	6643      	str	r3, [r0, #100]	@ 0x64
34026aea:	81c2      	strh	r2, [r0, #14]
34026aec:	2208      	movs	r2, #8
34026aee:	6183      	str	r3, [r0, #24]
34026af0:	e9c0 3300 	strd	r3, r3, [r0]
34026af4:	e9c0 3304 	strd	r3, r3, [r0, #16]
34026af8:	305c      	adds	r0, #92	@ 0x5c
34026afa:	f000 fb4b 	bl	34027194 <memset>
34026afe:	4b0d      	ldr	r3, [pc, #52]	@ (34026b34 <std+0x58>)
34026b00:	6224      	str	r4, [r4, #32]
34026b02:	6263      	str	r3, [r4, #36]	@ 0x24
34026b04:	4b0c      	ldr	r3, [pc, #48]	@ (34026b38 <std+0x5c>)
34026b06:	62a3      	str	r3, [r4, #40]	@ 0x28
34026b08:	4b0c      	ldr	r3, [pc, #48]	@ (34026b3c <std+0x60>)
34026b0a:	62e3      	str	r3, [r4, #44]	@ 0x2c
34026b0c:	4b0c      	ldr	r3, [pc, #48]	@ (34026b40 <std+0x64>)
34026b0e:	6323      	str	r3, [r4, #48]	@ 0x30
34026b10:	4b0c      	ldr	r3, [pc, #48]	@ (34026b44 <std+0x68>)
34026b12:	429c      	cmp	r4, r3
34026b14:	d006      	beq.n	34026b24 <std+0x48>
34026b16:	f103 0268 	add.w	r2, r3, #104	@ 0x68
34026b1a:	4294      	cmp	r4, r2
34026b1c:	d002      	beq.n	34026b24 <std+0x48>
34026b1e:	33d0      	adds	r3, #208	@ 0xd0
34026b20:	429c      	cmp	r4, r3
34026b22:	d105      	bne.n	34026b30 <std+0x54>
34026b24:	f104 0058 	add.w	r0, r4, #88	@ 0x58
34026b28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34026b2c:	f000 bdb0 	b.w	34027690 <__retarget_lock_init_recursive>
34026b30:	bd10      	pop	{r4, pc}
34026b32:	bf00      	nop
34026b34:	34026f39 	.word	0x34026f39
34026b38:	34026f5b 	.word	0x34026f5b
34026b3c:	34026f93 	.word	0x34026f93
34026b40:	34026fb7 	.word	0x34026fb7
34026b44:	340566b4 	.word	0x340566b4

34026b48 <stdio_exit_handler>:
34026b48:	4a02      	ldr	r2, [pc, #8]	@ (34026b54 <stdio_exit_handler+0xc>)
34026b4a:	4903      	ldr	r1, [pc, #12]	@ (34026b58 <stdio_exit_handler+0x10>)
34026b4c:	4803      	ldr	r0, [pc, #12]	@ (34026b5c <stdio_exit_handler+0x14>)
34026b4e:	f000 b87b 	b.w	34026c48 <_fwalk_sglue>
34026b52:	bf00      	nop
34026b54:	34041498 	.word	0x34041498
34026b58:	34029099 	.word	0x34029099
34026b5c:	340414a8 	.word	0x340414a8

34026b60 <cleanup_stdio>:
34026b60:	6841      	ldr	r1, [r0, #4]
34026b62:	4b0c      	ldr	r3, [pc, #48]	@ (34026b94 <cleanup_stdio+0x34>)
34026b64:	4299      	cmp	r1, r3
34026b66:	b510      	push	{r4, lr}
34026b68:	4604      	mov	r4, r0
34026b6a:	d001      	beq.n	34026b70 <cleanup_stdio+0x10>
34026b6c:	f002 fa94 	bl	34029098 <_fflush_r>
34026b70:	68a1      	ldr	r1, [r4, #8]
34026b72:	4b09      	ldr	r3, [pc, #36]	@ (34026b98 <cleanup_stdio+0x38>)
34026b74:	4299      	cmp	r1, r3
34026b76:	d002      	beq.n	34026b7e <cleanup_stdio+0x1e>
34026b78:	4620      	mov	r0, r4
34026b7a:	f002 fa8d 	bl	34029098 <_fflush_r>
34026b7e:	68e1      	ldr	r1, [r4, #12]
34026b80:	4b06      	ldr	r3, [pc, #24]	@ (34026b9c <cleanup_stdio+0x3c>)
34026b82:	4299      	cmp	r1, r3
34026b84:	d004      	beq.n	34026b90 <cleanup_stdio+0x30>
34026b86:	4620      	mov	r0, r4
34026b88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34026b8c:	f002 ba84 	b.w	34029098 <_fflush_r>
34026b90:	bd10      	pop	{r4, pc}
34026b92:	bf00      	nop
34026b94:	340566b4 	.word	0x340566b4
34026b98:	3405671c 	.word	0x3405671c
34026b9c:	34056784 	.word	0x34056784

34026ba0 <global_stdio_init.part.0>:
34026ba0:	b510      	push	{r4, lr}
34026ba2:	4b0b      	ldr	r3, [pc, #44]	@ (34026bd0 <global_stdio_init.part.0+0x30>)
34026ba4:	2104      	movs	r1, #4
34026ba6:	4c0b      	ldr	r4, [pc, #44]	@ (34026bd4 <global_stdio_init.part.0+0x34>)
34026ba8:	4a0b      	ldr	r2, [pc, #44]	@ (34026bd8 <global_stdio_init.part.0+0x38>)
34026baa:	4620      	mov	r0, r4
34026bac:	601a      	str	r2, [r3, #0]
34026bae:	2200      	movs	r2, #0
34026bb0:	f7ff ff94 	bl	34026adc <std>
34026bb4:	f104 0068 	add.w	r0, r4, #104	@ 0x68
34026bb8:	2201      	movs	r2, #1
34026bba:	2109      	movs	r1, #9
34026bbc:	f7ff ff8e 	bl	34026adc <std>
34026bc0:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
34026bc4:	2202      	movs	r2, #2
34026bc6:	2112      	movs	r1, #18
34026bc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34026bcc:	f7ff bf86 	b.w	34026adc <std>
34026bd0:	340567ec 	.word	0x340567ec
34026bd4:	340566b4 	.word	0x340566b4
34026bd8:	34026b49 	.word	0x34026b49

34026bdc <__sfp_lock_acquire>:
34026bdc:	4801      	ldr	r0, [pc, #4]	@ (34026be4 <__sfp_lock_acquire+0x8>)
34026bde:	f000 bd58 	b.w	34027692 <__retarget_lock_acquire_recursive>
34026be2:	bf00      	nop
34026be4:	340567f5 	.word	0x340567f5

34026be8 <__sfp_lock_release>:
34026be8:	4801      	ldr	r0, [pc, #4]	@ (34026bf0 <__sfp_lock_release+0x8>)
34026bea:	f000 bd53 	b.w	34027694 <__retarget_lock_release_recursive>
34026bee:	bf00      	nop
34026bf0:	340567f5 	.word	0x340567f5

34026bf4 <__sinit>:
34026bf4:	b510      	push	{r4, lr}
34026bf6:	4604      	mov	r4, r0
34026bf8:	f7ff fff0 	bl	34026bdc <__sfp_lock_acquire>
34026bfc:	6a23      	ldr	r3, [r4, #32]
34026bfe:	b11b      	cbz	r3, 34026c08 <__sinit+0x14>
34026c00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
34026c04:	f7ff bff0 	b.w	34026be8 <__sfp_lock_release>
34026c08:	4b04      	ldr	r3, [pc, #16]	@ (34026c1c <__sinit+0x28>)
34026c0a:	6223      	str	r3, [r4, #32]
34026c0c:	4b04      	ldr	r3, [pc, #16]	@ (34026c20 <__sinit+0x2c>)
34026c0e:	681b      	ldr	r3, [r3, #0]
34026c10:	2b00      	cmp	r3, #0
34026c12:	d1f5      	bne.n	34026c00 <__sinit+0xc>
34026c14:	f7ff ffc4 	bl	34026ba0 <global_stdio_init.part.0>
34026c18:	e7f2      	b.n	34026c00 <__sinit+0xc>
34026c1a:	bf00      	nop
34026c1c:	34026b61 	.word	0x34026b61
34026c20:	340567ec 	.word	0x340567ec

34026c24 <fiprintf>:
34026c24:	b40e      	push	{r1, r2, r3}
34026c26:	b503      	push	{r0, r1, lr}
34026c28:	ab03      	add	r3, sp, #12
34026c2a:	4601      	mov	r1, r0
34026c2c:	4805      	ldr	r0, [pc, #20]	@ (34026c44 <fiprintf+0x20>)
34026c2e:	f853 2b04 	ldr.w	r2, [r3], #4
34026c32:	6800      	ldr	r0, [r0, #0]
34026c34:	9301      	str	r3, [sp, #4]
34026c36:	f002 f893 	bl	34028d60 <_vfiprintf_r>
34026c3a:	b002      	add	sp, #8
34026c3c:	f85d eb04 	ldr.w	lr, [sp], #4
34026c40:	b003      	add	sp, #12
34026c42:	4770      	bx	lr
34026c44:	340414a4 	.word	0x340414a4

34026c48 <_fwalk_sglue>:
34026c48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
34026c4c:	4607      	mov	r7, r0
34026c4e:	4688      	mov	r8, r1
34026c50:	4614      	mov	r4, r2
34026c52:	2600      	movs	r6, #0
34026c54:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
34026c58:	f1b9 0901 	subs.w	r9, r9, #1
34026c5c:	d505      	bpl.n	34026c6a <_fwalk_sglue+0x22>
34026c5e:	6824      	ldr	r4, [r4, #0]
34026c60:	2c00      	cmp	r4, #0
34026c62:	d1f7      	bne.n	34026c54 <_fwalk_sglue+0xc>
34026c64:	4630      	mov	r0, r6
34026c66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
34026c6a:	89ab      	ldrh	r3, [r5, #12]
34026c6c:	2b01      	cmp	r3, #1
34026c6e:	d907      	bls.n	34026c80 <_fwalk_sglue+0x38>
34026c70:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
34026c74:	3301      	adds	r3, #1
34026c76:	d003      	beq.n	34026c80 <_fwalk_sglue+0x38>
34026c78:	4629      	mov	r1, r5
34026c7a:	4638      	mov	r0, r7
34026c7c:	47c0      	blx	r8
34026c7e:	4306      	orrs	r6, r0
34026c80:	3568      	adds	r5, #104	@ 0x68
34026c82:	e7e9      	b.n	34026c58 <_fwalk_sglue+0x10>

34026c84 <iprintf>:
34026c84:	b40f      	push	{r0, r1, r2, r3}
34026c86:	b507      	push	{r0, r1, r2, lr}
34026c88:	4906      	ldr	r1, [pc, #24]	@ (34026ca4 <iprintf+0x20>)
34026c8a:	ab04      	add	r3, sp, #16
34026c8c:	6808      	ldr	r0, [r1, #0]
34026c8e:	f853 2b04 	ldr.w	r2, [r3], #4
34026c92:	6881      	ldr	r1, [r0, #8]
34026c94:	9301      	str	r3, [sp, #4]
34026c96:	f002 f863 	bl	34028d60 <_vfiprintf_r>
34026c9a:	b003      	add	sp, #12
34026c9c:	f85d eb04 	ldr.w	lr, [sp], #4
34026ca0:	b004      	add	sp, #16
34026ca2:	4770      	bx	lr
34026ca4:	340414a4 	.word	0x340414a4

34026ca8 <_puts_r>:
34026ca8:	6a03      	ldr	r3, [r0, #32]
34026caa:	b570      	push	{r4, r5, r6, lr}
34026cac:	4605      	mov	r5, r0
34026cae:	460e      	mov	r6, r1
34026cb0:	6884      	ldr	r4, [r0, #8]
34026cb2:	b90b      	cbnz	r3, 34026cb8 <_puts_r+0x10>
34026cb4:	f7ff ff9e 	bl	34026bf4 <__sinit>
34026cb8:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34026cba:	07db      	lsls	r3, r3, #31
34026cbc:	d405      	bmi.n	34026cca <_puts_r+0x22>
34026cbe:	89a3      	ldrh	r3, [r4, #12]
34026cc0:	0598      	lsls	r0, r3, #22
34026cc2:	d402      	bmi.n	34026cca <_puts_r+0x22>
34026cc4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34026cc6:	f000 fce4 	bl	34027692 <__retarget_lock_acquire_recursive>
34026cca:	89a3      	ldrh	r3, [r4, #12]
34026ccc:	0719      	lsls	r1, r3, #28
34026cce:	d502      	bpl.n	34026cd6 <_puts_r+0x2e>
34026cd0:	6923      	ldr	r3, [r4, #16]
34026cd2:	2b00      	cmp	r3, #0
34026cd4:	d135      	bne.n	34026d42 <_puts_r+0x9a>
34026cd6:	4621      	mov	r1, r4
34026cd8:	4628      	mov	r0, r5
34026cda:	f000 f9eb 	bl	340270b4 <__swsetup_r>
34026cde:	b380      	cbz	r0, 34026d42 <_puts_r+0x9a>
34026ce0:	f04f 35ff 	mov.w	r5, #4294967295
34026ce4:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34026ce6:	07da      	lsls	r2, r3, #31
34026ce8:	d405      	bmi.n	34026cf6 <_puts_r+0x4e>
34026cea:	89a3      	ldrh	r3, [r4, #12]
34026cec:	059b      	lsls	r3, r3, #22
34026cee:	d402      	bmi.n	34026cf6 <_puts_r+0x4e>
34026cf0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34026cf2:	f000 fccf 	bl	34027694 <__retarget_lock_release_recursive>
34026cf6:	4628      	mov	r0, r5
34026cf8:	bd70      	pop	{r4, r5, r6, pc}
34026cfa:	2b00      	cmp	r3, #0
34026cfc:	da04      	bge.n	34026d08 <_puts_r+0x60>
34026cfe:	69a2      	ldr	r2, [r4, #24]
34026d00:	429a      	cmp	r2, r3
34026d02:	dc17      	bgt.n	34026d34 <_puts_r+0x8c>
34026d04:	290a      	cmp	r1, #10
34026d06:	d015      	beq.n	34026d34 <_puts_r+0x8c>
34026d08:	6823      	ldr	r3, [r4, #0]
34026d0a:	1c5a      	adds	r2, r3, #1
34026d0c:	6022      	str	r2, [r4, #0]
34026d0e:	7019      	strb	r1, [r3, #0]
34026d10:	68a3      	ldr	r3, [r4, #8]
34026d12:	f816 1f01 	ldrb.w	r1, [r6, #1]!
34026d16:	3b01      	subs	r3, #1
34026d18:	60a3      	str	r3, [r4, #8]
34026d1a:	2900      	cmp	r1, #0
34026d1c:	d1ed      	bne.n	34026cfa <_puts_r+0x52>
34026d1e:	2b00      	cmp	r3, #0
34026d20:	da11      	bge.n	34026d46 <_puts_r+0x9e>
34026d22:	4622      	mov	r2, r4
34026d24:	210a      	movs	r1, #10
34026d26:	4628      	mov	r0, r5
34026d28:	f000 f986 	bl	34027038 <__swbuf_r>
34026d2c:	3001      	adds	r0, #1
34026d2e:	d0d7      	beq.n	34026ce0 <_puts_r+0x38>
34026d30:	250a      	movs	r5, #10
34026d32:	e7d7      	b.n	34026ce4 <_puts_r+0x3c>
34026d34:	4622      	mov	r2, r4
34026d36:	4628      	mov	r0, r5
34026d38:	f000 f97e 	bl	34027038 <__swbuf_r>
34026d3c:	3001      	adds	r0, #1
34026d3e:	d1e7      	bne.n	34026d10 <_puts_r+0x68>
34026d40:	e7ce      	b.n	34026ce0 <_puts_r+0x38>
34026d42:	3e01      	subs	r6, #1
34026d44:	e7e4      	b.n	34026d10 <_puts_r+0x68>
34026d46:	6823      	ldr	r3, [r4, #0]
34026d48:	1c5a      	adds	r2, r3, #1
34026d4a:	6022      	str	r2, [r4, #0]
34026d4c:	220a      	movs	r2, #10
34026d4e:	701a      	strb	r2, [r3, #0]
34026d50:	e7ee      	b.n	34026d30 <_puts_r+0x88>
	...

34026d54 <puts>:
34026d54:	4b02      	ldr	r3, [pc, #8]	@ (34026d60 <puts+0xc>)
34026d56:	4601      	mov	r1, r0
34026d58:	6818      	ldr	r0, [r3, #0]
34026d5a:	f7ff bfa5 	b.w	34026ca8 <_puts_r>
34026d5e:	bf00      	nop
34026d60:	340414a4 	.word	0x340414a4

34026d64 <setvbuf>:
34026d64:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
34026d68:	461d      	mov	r5, r3
34026d6a:	4b57      	ldr	r3, [pc, #348]	@ (34026ec8 <setvbuf+0x164>)
34026d6c:	4604      	mov	r4, r0
34026d6e:	460e      	mov	r6, r1
34026d70:	681f      	ldr	r7, [r3, #0]
34026d72:	4690      	mov	r8, r2
34026d74:	b127      	cbz	r7, 34026d80 <setvbuf+0x1c>
34026d76:	6a3b      	ldr	r3, [r7, #32]
34026d78:	b913      	cbnz	r3, 34026d80 <setvbuf+0x1c>
34026d7a:	4638      	mov	r0, r7
34026d7c:	f7ff ff3a 	bl	34026bf4 <__sinit>
34026d80:	f1b8 0f02 	cmp.w	r8, #2
34026d84:	d006      	beq.n	34026d94 <setvbuf+0x30>
34026d86:	f1b8 0f01 	cmp.w	r8, #1
34026d8a:	f200 8099 	bhi.w	34026ec0 <setvbuf+0x15c>
34026d8e:	2d00      	cmp	r5, #0
34026d90:	f2c0 8096 	blt.w	34026ec0 <setvbuf+0x15c>
34026d94:	6e63      	ldr	r3, [r4, #100]	@ 0x64
34026d96:	07d9      	lsls	r1, r3, #31
34026d98:	d405      	bmi.n	34026da6 <setvbuf+0x42>
34026d9a:	89a3      	ldrh	r3, [r4, #12]
34026d9c:	059a      	lsls	r2, r3, #22
34026d9e:	d402      	bmi.n	34026da6 <setvbuf+0x42>
34026da0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34026da2:	f000 fc76 	bl	34027692 <__retarget_lock_acquire_recursive>
34026da6:	4621      	mov	r1, r4
34026da8:	4638      	mov	r0, r7
34026daa:	f002 f975 	bl	34029098 <_fflush_r>
34026dae:	6b61      	ldr	r1, [r4, #52]	@ 0x34
34026db0:	b141      	cbz	r1, 34026dc4 <setvbuf+0x60>
34026db2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34026db6:	4299      	cmp	r1, r3
34026db8:	d002      	beq.n	34026dc0 <setvbuf+0x5c>
34026dba:	4638      	mov	r0, r7
34026dbc:	f001 fa7a 	bl	340282b4 <_free_r>
34026dc0:	2300      	movs	r3, #0
34026dc2:	6363      	str	r3, [r4, #52]	@ 0x34
34026dc4:	2300      	movs	r3, #0
34026dc6:	61a3      	str	r3, [r4, #24]
34026dc8:	6063      	str	r3, [r4, #4]
34026dca:	89a3      	ldrh	r3, [r4, #12]
34026dcc:	061b      	lsls	r3, r3, #24
34026dce:	d503      	bpl.n	34026dd8 <setvbuf+0x74>
34026dd0:	6921      	ldr	r1, [r4, #16]
34026dd2:	4638      	mov	r0, r7
34026dd4:	f001 fa6e 	bl	340282b4 <_free_r>
34026dd8:	89a3      	ldrh	r3, [r4, #12]
34026dda:	f1b8 0f02 	cmp.w	r8, #2
34026dde:	f423 634a 	bic.w	r3, r3, #3232	@ 0xca0
34026de2:	f023 0303 	bic.w	r3, r3, #3
34026de6:	81a3      	strh	r3, [r4, #12]
34026de8:	d060      	beq.n	34026eac <setvbuf+0x148>
34026dea:	ab01      	add	r3, sp, #4
34026dec:	466a      	mov	r2, sp
34026dee:	4621      	mov	r1, r4
34026df0:	4638      	mov	r0, r7
34026df2:	f002 f979 	bl	340290e8 <__swhatbuf_r>
34026df6:	89a3      	ldrh	r3, [r4, #12]
34026df8:	4318      	orrs	r0, r3
34026dfa:	81a0      	strh	r0, [r4, #12]
34026dfc:	bb2d      	cbnz	r5, 34026e4a <setvbuf+0xe6>
34026dfe:	9d00      	ldr	r5, [sp, #0]
34026e00:	4628      	mov	r0, r5
34026e02:	f7fe ffcf 	bl	34025da4 <malloc>
34026e06:	4606      	mov	r6, r0
34026e08:	2800      	cmp	r0, #0
34026e0a:	d151      	bne.n	34026eb0 <setvbuf+0x14c>
34026e0c:	f8dd 9000 	ldr.w	r9, [sp]
34026e10:	45a9      	cmp	r9, r5
34026e12:	d13f      	bne.n	34026e94 <setvbuf+0x130>
34026e14:	f04f 35ff 	mov.w	r5, #4294967295
34026e18:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34026e1c:	f043 0202 	orr.w	r2, r3, #2
34026e20:	81a2      	strh	r2, [r4, #12]
34026e22:	2200      	movs	r2, #0
34026e24:	60a2      	str	r2, [r4, #8]
34026e26:	f104 0247 	add.w	r2, r4, #71	@ 0x47
34026e2a:	6022      	str	r2, [r4, #0]
34026e2c:	6122      	str	r2, [r4, #16]
34026e2e:	2201      	movs	r2, #1
34026e30:	6162      	str	r2, [r4, #20]
34026e32:	6e62      	ldr	r2, [r4, #100]	@ 0x64
34026e34:	07d6      	lsls	r6, r2, #31
34026e36:	d404      	bmi.n	34026e42 <setvbuf+0xde>
34026e38:	0598      	lsls	r0, r3, #22
34026e3a:	d402      	bmi.n	34026e42 <setvbuf+0xde>
34026e3c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34026e3e:	f000 fc29 	bl	34027694 <__retarget_lock_release_recursive>
34026e42:	4628      	mov	r0, r5
34026e44:	b003      	add	sp, #12
34026e46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
34026e4a:	2e00      	cmp	r6, #0
34026e4c:	d0d8      	beq.n	34026e00 <setvbuf+0x9c>
34026e4e:	6a3b      	ldr	r3, [r7, #32]
34026e50:	b913      	cbnz	r3, 34026e58 <setvbuf+0xf4>
34026e52:	4638      	mov	r0, r7
34026e54:	f7ff fece 	bl	34026bf4 <__sinit>
34026e58:	f1b8 0f01 	cmp.w	r8, #1
34026e5c:	6026      	str	r6, [r4, #0]
34026e5e:	bf02      	ittt	eq
34026e60:	89a3      	ldrheq	r3, [r4, #12]
34026e62:	f043 0301 	orreq.w	r3, r3, #1
34026e66:	81a3      	strheq	r3, [r4, #12]
34026e68:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34026e6c:	f013 0208 	ands.w	r2, r3, #8
34026e70:	e9c4 6504 	strd	r6, r5, [r4, #16]
34026e74:	d01e      	beq.n	34026eb4 <setvbuf+0x150>
34026e76:	07d9      	lsls	r1, r3, #31
34026e78:	bf45      	ittet	mi
34026e7a:	2200      	movmi	r2, #0
34026e7c:	426d      	negmi	r5, r5
34026e7e:	60a5      	strpl	r5, [r4, #8]
34026e80:	60a2      	strmi	r2, [r4, #8]
34026e82:	bf48      	it	mi
34026e84:	61a5      	strmi	r5, [r4, #24]
34026e86:	6e62      	ldr	r2, [r4, #100]	@ 0x64
34026e88:	07d2      	lsls	r2, r2, #31
34026e8a:	d401      	bmi.n	34026e90 <setvbuf+0x12c>
34026e8c:	059b      	lsls	r3, r3, #22
34026e8e:	d513      	bpl.n	34026eb8 <setvbuf+0x154>
34026e90:	2500      	movs	r5, #0
34026e92:	e7d6      	b.n	34026e42 <setvbuf+0xde>
34026e94:	4648      	mov	r0, r9
34026e96:	f7fe ff85 	bl	34025da4 <malloc>
34026e9a:	4606      	mov	r6, r0
34026e9c:	2800      	cmp	r0, #0
34026e9e:	d0b9      	beq.n	34026e14 <setvbuf+0xb0>
34026ea0:	89a3      	ldrh	r3, [r4, #12]
34026ea2:	464d      	mov	r5, r9
34026ea4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34026ea8:	81a3      	strh	r3, [r4, #12]
34026eaa:	e7d0      	b.n	34026e4e <setvbuf+0xea>
34026eac:	2500      	movs	r5, #0
34026eae:	e7b3      	b.n	34026e18 <setvbuf+0xb4>
34026eb0:	46a9      	mov	r9, r5
34026eb2:	e7f5      	b.n	34026ea0 <setvbuf+0x13c>
34026eb4:	60a2      	str	r2, [r4, #8]
34026eb6:	e7e6      	b.n	34026e86 <setvbuf+0x122>
34026eb8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
34026eba:	f000 fbeb 	bl	34027694 <__retarget_lock_release_recursive>
34026ebe:	e7e7      	b.n	34026e90 <setvbuf+0x12c>
34026ec0:	f04f 35ff 	mov.w	r5, #4294967295
34026ec4:	e7bd      	b.n	34026e42 <setvbuf+0xde>
34026ec6:	bf00      	nop
34026ec8:	340414a4 	.word	0x340414a4

34026ecc <sniprintf>:
34026ecc:	b40c      	push	{r2, r3}
34026ece:	4b19      	ldr	r3, [pc, #100]	@ (34026f34 <sniprintf+0x68>)
34026ed0:	b530      	push	{r4, r5, lr}
34026ed2:	1e0c      	subs	r4, r1, #0
34026ed4:	b09d      	sub	sp, #116	@ 0x74
34026ed6:	681d      	ldr	r5, [r3, #0]
34026ed8:	da08      	bge.n	34026eec <sniprintf+0x20>
34026eda:	238b      	movs	r3, #139	@ 0x8b
34026edc:	f04f 30ff 	mov.w	r0, #4294967295
34026ee0:	602b      	str	r3, [r5, #0]
34026ee2:	b01d      	add	sp, #116	@ 0x74
34026ee4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34026ee8:	b002      	add	sp, #8
34026eea:	4770      	bx	lr
34026eec:	f44f 7302 	mov.w	r3, #520	@ 0x208
34026ef0:	9002      	str	r0, [sp, #8]
34026ef2:	9006      	str	r0, [sp, #24]
34026ef4:	a902      	add	r1, sp, #8
34026ef6:	f8ad 3014 	strh.w	r3, [sp, #20]
34026efa:	f04f 0300 	mov.w	r3, #0
34026efe:	9a20      	ldr	r2, [sp, #128]	@ 0x80
34026f00:	4628      	mov	r0, r5
34026f02:	931b      	str	r3, [sp, #108]	@ 0x6c
34026f04:	bf14      	ite	ne
34026f06:	f104 33ff 	addne.w	r3, r4, #4294967295
34026f0a:	4623      	moveq	r3, r4
34026f0c:	9304      	str	r3, [sp, #16]
34026f0e:	9307      	str	r3, [sp, #28]
34026f10:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34026f14:	f8ad 3016 	strh.w	r3, [sp, #22]
34026f18:	ab21      	add	r3, sp, #132	@ 0x84
34026f1a:	9301      	str	r3, [sp, #4]
34026f1c:	f001 fdfa 	bl	34028b14 <_svfiprintf_r>
34026f20:	1c43      	adds	r3, r0, #1
34026f22:	bfbc      	itt	lt
34026f24:	238b      	movlt	r3, #139	@ 0x8b
34026f26:	602b      	strlt	r3, [r5, #0]
34026f28:	2c00      	cmp	r4, #0
34026f2a:	d0da      	beq.n	34026ee2 <sniprintf+0x16>
34026f2c:	9b02      	ldr	r3, [sp, #8]
34026f2e:	2200      	movs	r2, #0
34026f30:	701a      	strb	r2, [r3, #0]
34026f32:	e7d6      	b.n	34026ee2 <sniprintf+0x16>
34026f34:	340414a4 	.word	0x340414a4

34026f38 <__sread>:
34026f38:	b510      	push	{r4, lr}
34026f3a:	460c      	mov	r4, r1
34026f3c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34026f40:	f000 fb48 	bl	340275d4 <_read_r>
34026f44:	2800      	cmp	r0, #0
34026f46:	bfab      	itete	ge
34026f48:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
34026f4a:	89a3      	ldrhlt	r3, [r4, #12]
34026f4c:	181b      	addge	r3, r3, r0
34026f4e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
34026f52:	bfac      	ite	ge
34026f54:	6563      	strge	r3, [r4, #84]	@ 0x54
34026f56:	81a3      	strhlt	r3, [r4, #12]
34026f58:	bd10      	pop	{r4, pc}

34026f5a <__swrite>:
34026f5a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34026f5e:	461f      	mov	r7, r3
34026f60:	898b      	ldrh	r3, [r1, #12]
34026f62:	4605      	mov	r5, r0
34026f64:	460c      	mov	r4, r1
34026f66:	05db      	lsls	r3, r3, #23
34026f68:	4616      	mov	r6, r2
34026f6a:	d505      	bpl.n	34026f78 <__swrite+0x1e>
34026f6c:	2302      	movs	r3, #2
34026f6e:	2200      	movs	r2, #0
34026f70:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34026f74:	f000 fb1c 	bl	340275b0 <_lseek_r>
34026f78:	89a3      	ldrh	r3, [r4, #12]
34026f7a:	4632      	mov	r2, r6
34026f7c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
34026f80:	4628      	mov	r0, r5
34026f82:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
34026f86:	81a3      	strh	r3, [r4, #12]
34026f88:	463b      	mov	r3, r7
34026f8a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
34026f8e:	f000 bb43 	b.w	34027618 <_write_r>

34026f92 <__sseek>:
34026f92:	b510      	push	{r4, lr}
34026f94:	460c      	mov	r4, r1
34026f96:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34026f9a:	f000 fb09 	bl	340275b0 <_lseek_r>
34026f9e:	1c43      	adds	r3, r0, #1
34026fa0:	89a3      	ldrh	r3, [r4, #12]
34026fa2:	bf15      	itete	ne
34026fa4:	6560      	strne	r0, [r4, #84]	@ 0x54
34026fa6:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
34026faa:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
34026fae:	81a3      	strheq	r3, [r4, #12]
34026fb0:	bf18      	it	ne
34026fb2:	81a3      	strhne	r3, [r4, #12]
34026fb4:	bd10      	pop	{r4, pc}

34026fb6 <__sclose>:
34026fb6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
34026fba:	f000 bae9 	b.w	34027590 <_close_r>

34026fbe <_vsniprintf_r>:
34026fbe:	b530      	push	{r4, r5, lr}
34026fc0:	4614      	mov	r4, r2
34026fc2:	b09b      	sub	sp, #108	@ 0x6c
34026fc4:	4605      	mov	r5, r0
34026fc6:	461a      	mov	r2, r3
34026fc8:	2c00      	cmp	r4, #0
34026fca:	da05      	bge.n	34026fd8 <_vsniprintf_r+0x1a>
34026fcc:	238b      	movs	r3, #139	@ 0x8b
34026fce:	6003      	str	r3, [r0, #0]
34026fd0:	f04f 30ff 	mov.w	r0, #4294967295
34026fd4:	b01b      	add	sp, #108	@ 0x6c
34026fd6:	bd30      	pop	{r4, r5, pc}
34026fd8:	f44f 7302 	mov.w	r3, #520	@ 0x208
34026fdc:	9100      	str	r1, [sp, #0]
34026fde:	9104      	str	r1, [sp, #16]
34026fe0:	4669      	mov	r1, sp
34026fe2:	f8ad 300c 	strh.w	r3, [sp, #12]
34026fe6:	f04f 0300 	mov.w	r3, #0
34026fea:	9319      	str	r3, [sp, #100]	@ 0x64
34026fec:	bf14      	ite	ne
34026fee:	f104 33ff 	addne.w	r3, r4, #4294967295
34026ff2:	4623      	moveq	r3, r4
34026ff4:	9302      	str	r3, [sp, #8]
34026ff6:	9305      	str	r3, [sp, #20]
34026ff8:	f64f 73ff 	movw	r3, #65535	@ 0xffff
34026ffc:	f8ad 300e 	strh.w	r3, [sp, #14]
34027000:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
34027002:	f001 fd87 	bl	34028b14 <_svfiprintf_r>
34027006:	1c43      	adds	r3, r0, #1
34027008:	bfbc      	itt	lt
3402700a:	238b      	movlt	r3, #139	@ 0x8b
3402700c:	602b      	strlt	r3, [r5, #0]
3402700e:	2c00      	cmp	r4, #0
34027010:	d0e0      	beq.n	34026fd4 <_vsniprintf_r+0x16>
34027012:	9b00      	ldr	r3, [sp, #0]
34027014:	2200      	movs	r2, #0
34027016:	701a      	strb	r2, [r3, #0]
34027018:	e7dc      	b.n	34026fd4 <_vsniprintf_r+0x16>
	...

3402701c <vsniprintf>:
3402701c:	b507      	push	{r0, r1, r2, lr}
3402701e:	9300      	str	r3, [sp, #0]
34027020:	4613      	mov	r3, r2
34027022:	460a      	mov	r2, r1
34027024:	4601      	mov	r1, r0
34027026:	4803      	ldr	r0, [pc, #12]	@ (34027034 <vsniprintf+0x18>)
34027028:	6800      	ldr	r0, [r0, #0]
3402702a:	f7ff ffc8 	bl	34026fbe <_vsniprintf_r>
3402702e:	b003      	add	sp, #12
34027030:	f85d fb04 	ldr.w	pc, [sp], #4
34027034:	340414a4 	.word	0x340414a4

34027038 <__swbuf_r>:
34027038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3402703a:	460e      	mov	r6, r1
3402703c:	4614      	mov	r4, r2
3402703e:	4605      	mov	r5, r0
34027040:	b118      	cbz	r0, 3402704a <__swbuf_r+0x12>
34027042:	6a03      	ldr	r3, [r0, #32]
34027044:	b90b      	cbnz	r3, 3402704a <__swbuf_r+0x12>
34027046:	f7ff fdd5 	bl	34026bf4 <__sinit>
3402704a:	69a3      	ldr	r3, [r4, #24]
3402704c:	60a3      	str	r3, [r4, #8]
3402704e:	89a3      	ldrh	r3, [r4, #12]
34027050:	071a      	lsls	r2, r3, #28
34027052:	d501      	bpl.n	34027058 <__swbuf_r+0x20>
34027054:	6923      	ldr	r3, [r4, #16]
34027056:	b943      	cbnz	r3, 3402706a <__swbuf_r+0x32>
34027058:	4621      	mov	r1, r4
3402705a:	4628      	mov	r0, r5
3402705c:	f000 f82a 	bl	340270b4 <__swsetup_r>
34027060:	b118      	cbz	r0, 3402706a <__swbuf_r+0x32>
34027062:	f04f 37ff 	mov.w	r7, #4294967295
34027066:	4638      	mov	r0, r7
34027068:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
3402706a:	6823      	ldr	r3, [r4, #0]
3402706c:	b2f6      	uxtb	r6, r6
3402706e:	6922      	ldr	r2, [r4, #16]
34027070:	4637      	mov	r7, r6
34027072:	1a98      	subs	r0, r3, r2
34027074:	6963      	ldr	r3, [r4, #20]
34027076:	4283      	cmp	r3, r0
34027078:	dc05      	bgt.n	34027086 <__swbuf_r+0x4e>
3402707a:	4621      	mov	r1, r4
3402707c:	4628      	mov	r0, r5
3402707e:	f002 f80b 	bl	34029098 <_fflush_r>
34027082:	2800      	cmp	r0, #0
34027084:	d1ed      	bne.n	34027062 <__swbuf_r+0x2a>
34027086:	68a3      	ldr	r3, [r4, #8]
34027088:	3b01      	subs	r3, #1
3402708a:	60a3      	str	r3, [r4, #8]
3402708c:	6823      	ldr	r3, [r4, #0]
3402708e:	1c5a      	adds	r2, r3, #1
34027090:	6022      	str	r2, [r4, #0]
34027092:	701e      	strb	r6, [r3, #0]
34027094:	1c43      	adds	r3, r0, #1
34027096:	6962      	ldr	r2, [r4, #20]
34027098:	429a      	cmp	r2, r3
3402709a:	d004      	beq.n	340270a6 <__swbuf_r+0x6e>
3402709c:	89a3      	ldrh	r3, [r4, #12]
3402709e:	07db      	lsls	r3, r3, #31
340270a0:	d5e1      	bpl.n	34027066 <__swbuf_r+0x2e>
340270a2:	2e0a      	cmp	r6, #10
340270a4:	d1df      	bne.n	34027066 <__swbuf_r+0x2e>
340270a6:	4621      	mov	r1, r4
340270a8:	4628      	mov	r0, r5
340270aa:	f001 fff5 	bl	34029098 <_fflush_r>
340270ae:	2800      	cmp	r0, #0
340270b0:	d0d9      	beq.n	34027066 <__swbuf_r+0x2e>
340270b2:	e7d6      	b.n	34027062 <__swbuf_r+0x2a>

340270b4 <__swsetup_r>:
340270b4:	b538      	push	{r3, r4, r5, lr}
340270b6:	4b29      	ldr	r3, [pc, #164]	@ (3402715c <__swsetup_r+0xa8>)
340270b8:	4605      	mov	r5, r0
340270ba:	460c      	mov	r4, r1
340270bc:	6818      	ldr	r0, [r3, #0]
340270be:	b118      	cbz	r0, 340270c8 <__swsetup_r+0x14>
340270c0:	6a03      	ldr	r3, [r0, #32]
340270c2:	b90b      	cbnz	r3, 340270c8 <__swsetup_r+0x14>
340270c4:	f7ff fd96 	bl	34026bf4 <__sinit>
340270c8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
340270cc:	0719      	lsls	r1, r3, #28
340270ce:	d422      	bmi.n	34027116 <__swsetup_r+0x62>
340270d0:	06da      	lsls	r2, r3, #27
340270d2:	d407      	bmi.n	340270e4 <__swsetup_r+0x30>
340270d4:	2209      	movs	r2, #9
340270d6:	602a      	str	r2, [r5, #0]
340270d8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
340270dc:	f04f 30ff 	mov.w	r0, #4294967295
340270e0:	81a3      	strh	r3, [r4, #12]
340270e2:	e033      	b.n	3402714c <__swsetup_r+0x98>
340270e4:	0758      	lsls	r0, r3, #29
340270e6:	d512      	bpl.n	3402710e <__swsetup_r+0x5a>
340270e8:	6b61      	ldr	r1, [r4, #52]	@ 0x34
340270ea:	b141      	cbz	r1, 340270fe <__swsetup_r+0x4a>
340270ec:	f104 0344 	add.w	r3, r4, #68	@ 0x44
340270f0:	4299      	cmp	r1, r3
340270f2:	d002      	beq.n	340270fa <__swsetup_r+0x46>
340270f4:	4628      	mov	r0, r5
340270f6:	f001 f8dd 	bl	340282b4 <_free_r>
340270fa:	2300      	movs	r3, #0
340270fc:	6363      	str	r3, [r4, #52]	@ 0x34
340270fe:	89a3      	ldrh	r3, [r4, #12]
34027100:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
34027104:	81a3      	strh	r3, [r4, #12]
34027106:	2300      	movs	r3, #0
34027108:	6063      	str	r3, [r4, #4]
3402710a:	6923      	ldr	r3, [r4, #16]
3402710c:	6023      	str	r3, [r4, #0]
3402710e:	89a3      	ldrh	r3, [r4, #12]
34027110:	f043 0308 	orr.w	r3, r3, #8
34027114:	81a3      	strh	r3, [r4, #12]
34027116:	6923      	ldr	r3, [r4, #16]
34027118:	b94b      	cbnz	r3, 3402712e <__swsetup_r+0x7a>
3402711a:	89a3      	ldrh	r3, [r4, #12]
3402711c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
34027120:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
34027124:	d003      	beq.n	3402712e <__swsetup_r+0x7a>
34027126:	4621      	mov	r1, r4
34027128:	4628      	mov	r0, r5
3402712a:	f002 f802 	bl	34029132 <__smakebuf_r>
3402712e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34027132:	f013 0201 	ands.w	r2, r3, #1
34027136:	d00a      	beq.n	3402714e <__swsetup_r+0x9a>
34027138:	2200      	movs	r2, #0
3402713a:	60a2      	str	r2, [r4, #8]
3402713c:	6962      	ldr	r2, [r4, #20]
3402713e:	4252      	negs	r2, r2
34027140:	61a2      	str	r2, [r4, #24]
34027142:	6922      	ldr	r2, [r4, #16]
34027144:	b942      	cbnz	r2, 34027158 <__swsetup_r+0xa4>
34027146:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
3402714a:	d1c5      	bne.n	340270d8 <__swsetup_r+0x24>
3402714c:	bd38      	pop	{r3, r4, r5, pc}
3402714e:	0799      	lsls	r1, r3, #30
34027150:	bf58      	it	pl
34027152:	6962      	ldrpl	r2, [r4, #20]
34027154:	60a2      	str	r2, [r4, #8]
34027156:	e7f4      	b.n	34027142 <__swsetup_r+0x8e>
34027158:	2000      	movs	r0, #0
3402715a:	e7f7      	b.n	3402714c <__swsetup_r+0x98>
3402715c:	340414a4 	.word	0x340414a4

34027160 <memmove>:
34027160:	4288      	cmp	r0, r1
34027162:	b510      	push	{r4, lr}
34027164:	eb01 0402 	add.w	r4, r1, r2
34027168:	d902      	bls.n	34027170 <memmove+0x10>
3402716a:	4284      	cmp	r4, r0
3402716c:	4623      	mov	r3, r4
3402716e:	d807      	bhi.n	34027180 <memmove+0x20>
34027170:	1e43      	subs	r3, r0, #1
34027172:	42a1      	cmp	r1, r4
34027174:	d008      	beq.n	34027188 <memmove+0x28>
34027176:	f811 2b01 	ldrb.w	r2, [r1], #1
3402717a:	f803 2f01 	strb.w	r2, [r3, #1]!
3402717e:	e7f8      	b.n	34027172 <memmove+0x12>
34027180:	4402      	add	r2, r0
34027182:	4601      	mov	r1, r0
34027184:	428a      	cmp	r2, r1
34027186:	d100      	bne.n	3402718a <memmove+0x2a>
34027188:	bd10      	pop	{r4, pc}
3402718a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
3402718e:	f802 4d01 	strb.w	r4, [r2, #-1]!
34027192:	e7f7      	b.n	34027184 <memmove+0x24>

34027194 <memset>:
34027194:	4402      	add	r2, r0
34027196:	4603      	mov	r3, r0
34027198:	4293      	cmp	r3, r2
3402719a:	d100      	bne.n	3402719e <memset+0xa>
3402719c:	4770      	bx	lr
3402719e:	f803 1b01 	strb.w	r1, [r3], #1
340271a2:	e7f9      	b.n	34027198 <memset+0x4>

340271a4 <_strerror_r>:
340271a4:	b510      	push	{r4, lr}
340271a6:	4604      	mov	r4, r0
340271a8:	4608      	mov	r0, r1
340271aa:	4611      	mov	r1, r2
340271ac:	461a      	mov	r2, r3
340271ae:	288e      	cmp	r0, #142	@ 0x8e
340271b0:	f200 8130 	bhi.w	34027414 <_strerror_r+0x270>
340271b4:	e8df f010 	tbh	[pc, r0, lsl #1]
340271b8:	0138008f 	.word	0x0138008f
340271bc:	00940092 	.word	0x00940092
340271c0:	00980096 	.word	0x00980096
340271c4:	009c009a 	.word	0x009c009a
340271c8:	00a2009e 	.word	0x00a2009e
340271cc:	00a800a4 	.word	0x00a800a4
340271d0:	00ac00aa 	.word	0x00ac00aa
340271d4:	012e00ae 	.word	0x012e00ae
340271d8:	00b200b0 	.word	0x00b200b0
340271dc:	00b600b4 	.word	0x00b600b4
340271e0:	00be00b8 	.word	0x00be00b8
340271e4:	00c600c0 	.word	0x00c600c0
340271e8:	00ca00c8 	.word	0x00ca00c8
340271ec:	00ce00cc 	.word	0x00ce00cc
340271f0:	00d600d2 	.word	0x00d600d2
340271f4:	00da00d8 	.word	0x00da00d8
340271f8:	00de00dc 	.word	0x00de00dc
340271fc:	00e200e0 	.word	0x00e200e0
34027200:	012e00e4 	.word	0x012e00e4
34027204:	012e012e 	.word	0x012e012e
34027208:	012e012e 	.word	0x012e012e
3402720c:	012e012e 	.word	0x012e012e
34027210:	00e8012e 	.word	0x00e8012e
34027214:	012e00ec 	.word	0x012e00ec
34027218:	012e012e 	.word	0x012e012e
3402721c:	012e012e 	.word	0x012e012e
34027220:	012e012e 	.word	0x012e012e
34027224:	012e012e 	.word	0x012e012e
34027228:	012e012e 	.word	0x012e012e
3402722c:	012e012e 	.word	0x012e012e
34027230:	010800ee 	.word	0x010800ee
34027234:	00f200f0 	.word	0x00f200f0
34027238:	012e012e 	.word	0x012e012e
3402723c:	00f4012e 	.word	0x00f4012e
34027240:	012e012e 	.word	0x012e012e
34027244:	00f6012e 	.word	0x00f6012e
34027248:	012e012e 	.word	0x012e012e
3402724c:	012e00fa 	.word	0x012e00fa
34027250:	00fc012e 	.word	0x00fc012e
34027254:	012e012e 	.word	0x012e012e
34027258:	012e012e 	.word	0x012e012e
3402725c:	012e012e 	.word	0x012e012e
34027260:	012e012e 	.word	0x012e012e
34027264:	012e012e 	.word	0x012e012e
34027268:	012e00fe 	.word	0x012e00fe
3402726c:	01020100 	.word	0x01020100
34027270:	012e0104 	.word	0x012e0104
34027274:	0126012e 	.word	0x0126012e
34027278:	012e012e 	.word	0x012e012e
3402727c:	012e012e 	.word	0x012e012e
34027280:	012e012e 	.word	0x012e012e
34027284:	012e012e 	.word	0x012e012e
34027288:	01060114 	.word	0x01060114
3402728c:	010c010a 	.word	0x010c010a
34027290:	0110010e 	.word	0x0110010e
34027294:	0112012e 	.word	0x0112012e
34027298:	011a0116 	.word	0x011a0116
3402729c:	00c200ea 	.word	0x00c200ea
340272a0:	00ba012c 	.word	0x00ba012c
340272a4:	00bc00d0 	.word	0x00bc00d0
340272a8:	00a600a0 	.word	0x00a600a0
340272ac:	00f8012a 	.word	0x00f8012a
340272b0:	0118012e 	.word	0x0118012e
340272b4:	011e00c4 	.word	0x011e00c4
340272b8:	012e011c 	.word	0x012e011c
340272bc:	012e012e 	.word	0x012e012e
340272c0:	012e012e 	.word	0x012e012e
340272c4:	012e00d4 	.word	0x012e00d4
340272c8:	012e012e 	.word	0x012e012e
340272cc:	012800e6 	.word	0x012800e6
340272d0:	01220120 	.word	0x01220120
340272d4:	0124      	.short	0x0124
340272d6:	4b55      	ldr	r3, [pc, #340]	@ (3402742c <_strerror_r+0x288>)
340272d8:	4618      	mov	r0, r3
340272da:	bd10      	pop	{r4, pc}
340272dc:	4b54      	ldr	r3, [pc, #336]	@ (34027430 <_strerror_r+0x28c>)
340272de:	e7fb      	b.n	340272d8 <_strerror_r+0x134>
340272e0:	4b54      	ldr	r3, [pc, #336]	@ (34027434 <_strerror_r+0x290>)
340272e2:	e7f9      	b.n	340272d8 <_strerror_r+0x134>
340272e4:	4b54      	ldr	r3, [pc, #336]	@ (34027438 <_strerror_r+0x294>)
340272e6:	e7f7      	b.n	340272d8 <_strerror_r+0x134>
340272e8:	4b54      	ldr	r3, [pc, #336]	@ (3402743c <_strerror_r+0x298>)
340272ea:	e7f5      	b.n	340272d8 <_strerror_r+0x134>
340272ec:	4b54      	ldr	r3, [pc, #336]	@ (34027440 <_strerror_r+0x29c>)
340272ee:	e7f3      	b.n	340272d8 <_strerror_r+0x134>
340272f0:	4b54      	ldr	r3, [pc, #336]	@ (34027444 <_strerror_r+0x2a0>)
340272f2:	e7f1      	b.n	340272d8 <_strerror_r+0x134>
340272f4:	4b54      	ldr	r3, [pc, #336]	@ (34027448 <_strerror_r+0x2a4>)
340272f6:	e7ef      	b.n	340272d8 <_strerror_r+0x134>
340272f8:	4b54      	ldr	r3, [pc, #336]	@ (3402744c <_strerror_r+0x2a8>)
340272fa:	e7ed      	b.n	340272d8 <_strerror_r+0x134>
340272fc:	4b54      	ldr	r3, [pc, #336]	@ (34027450 <_strerror_r+0x2ac>)
340272fe:	e7eb      	b.n	340272d8 <_strerror_r+0x134>
34027300:	4b54      	ldr	r3, [pc, #336]	@ (34027454 <_strerror_r+0x2b0>)
34027302:	e7e9      	b.n	340272d8 <_strerror_r+0x134>
34027304:	4b54      	ldr	r3, [pc, #336]	@ (34027458 <_strerror_r+0x2b4>)
34027306:	e7e7      	b.n	340272d8 <_strerror_r+0x134>
34027308:	4b54      	ldr	r3, [pc, #336]	@ (3402745c <_strerror_r+0x2b8>)
3402730a:	e7e5      	b.n	340272d8 <_strerror_r+0x134>
3402730c:	4b54      	ldr	r3, [pc, #336]	@ (34027460 <_strerror_r+0x2bc>)
3402730e:	e7e3      	b.n	340272d8 <_strerror_r+0x134>
34027310:	4b54      	ldr	r3, [pc, #336]	@ (34027464 <_strerror_r+0x2c0>)
34027312:	e7e1      	b.n	340272d8 <_strerror_r+0x134>
34027314:	4b54      	ldr	r3, [pc, #336]	@ (34027468 <_strerror_r+0x2c4>)
34027316:	e7df      	b.n	340272d8 <_strerror_r+0x134>
34027318:	4b54      	ldr	r3, [pc, #336]	@ (3402746c <_strerror_r+0x2c8>)
3402731a:	e7dd      	b.n	340272d8 <_strerror_r+0x134>
3402731c:	4b54      	ldr	r3, [pc, #336]	@ (34027470 <_strerror_r+0x2cc>)
3402731e:	e7db      	b.n	340272d8 <_strerror_r+0x134>
34027320:	4b54      	ldr	r3, [pc, #336]	@ (34027474 <_strerror_r+0x2d0>)
34027322:	e7d9      	b.n	340272d8 <_strerror_r+0x134>
34027324:	4b54      	ldr	r3, [pc, #336]	@ (34027478 <_strerror_r+0x2d4>)
34027326:	e7d7      	b.n	340272d8 <_strerror_r+0x134>
34027328:	4b54      	ldr	r3, [pc, #336]	@ (3402747c <_strerror_r+0x2d8>)
3402732a:	e7d5      	b.n	340272d8 <_strerror_r+0x134>
3402732c:	4b54      	ldr	r3, [pc, #336]	@ (34027480 <_strerror_r+0x2dc>)
3402732e:	e7d3      	b.n	340272d8 <_strerror_r+0x134>
34027330:	4b54      	ldr	r3, [pc, #336]	@ (34027484 <_strerror_r+0x2e0>)
34027332:	e7d1      	b.n	340272d8 <_strerror_r+0x134>
34027334:	4b54      	ldr	r3, [pc, #336]	@ (34027488 <_strerror_r+0x2e4>)
34027336:	e7cf      	b.n	340272d8 <_strerror_r+0x134>
34027338:	4b54      	ldr	r3, [pc, #336]	@ (3402748c <_strerror_r+0x2e8>)
3402733a:	e7cd      	b.n	340272d8 <_strerror_r+0x134>
3402733c:	4b54      	ldr	r3, [pc, #336]	@ (34027490 <_strerror_r+0x2ec>)
3402733e:	e7cb      	b.n	340272d8 <_strerror_r+0x134>
34027340:	4b54      	ldr	r3, [pc, #336]	@ (34027494 <_strerror_r+0x2f0>)
34027342:	e7c9      	b.n	340272d8 <_strerror_r+0x134>
34027344:	4b54      	ldr	r3, [pc, #336]	@ (34027498 <_strerror_r+0x2f4>)
34027346:	e7c7      	b.n	340272d8 <_strerror_r+0x134>
34027348:	4b54      	ldr	r3, [pc, #336]	@ (3402749c <_strerror_r+0x2f8>)
3402734a:	e7c5      	b.n	340272d8 <_strerror_r+0x134>
3402734c:	4b54      	ldr	r3, [pc, #336]	@ (340274a0 <_strerror_r+0x2fc>)
3402734e:	e7c3      	b.n	340272d8 <_strerror_r+0x134>
34027350:	4b54      	ldr	r3, [pc, #336]	@ (340274a4 <_strerror_r+0x300>)
34027352:	e7c1      	b.n	340272d8 <_strerror_r+0x134>
34027354:	4b54      	ldr	r3, [pc, #336]	@ (340274a8 <_strerror_r+0x304>)
34027356:	e7bf      	b.n	340272d8 <_strerror_r+0x134>
34027358:	4b54      	ldr	r3, [pc, #336]	@ (340274ac <_strerror_r+0x308>)
3402735a:	e7bd      	b.n	340272d8 <_strerror_r+0x134>
3402735c:	4b54      	ldr	r3, [pc, #336]	@ (340274b0 <_strerror_r+0x30c>)
3402735e:	e7bb      	b.n	340272d8 <_strerror_r+0x134>
34027360:	4b54      	ldr	r3, [pc, #336]	@ (340274b4 <_strerror_r+0x310>)
34027362:	e7b9      	b.n	340272d8 <_strerror_r+0x134>
34027364:	4b54      	ldr	r3, [pc, #336]	@ (340274b8 <_strerror_r+0x314>)
34027366:	e7b7      	b.n	340272d8 <_strerror_r+0x134>
34027368:	4b54      	ldr	r3, [pc, #336]	@ (340274bc <_strerror_r+0x318>)
3402736a:	e7b5      	b.n	340272d8 <_strerror_r+0x134>
3402736c:	4b54      	ldr	r3, [pc, #336]	@ (340274c0 <_strerror_r+0x31c>)
3402736e:	e7b3      	b.n	340272d8 <_strerror_r+0x134>
34027370:	4b54      	ldr	r3, [pc, #336]	@ (340274c4 <_strerror_r+0x320>)
34027372:	e7b1      	b.n	340272d8 <_strerror_r+0x134>
34027374:	4b54      	ldr	r3, [pc, #336]	@ (340274c8 <_strerror_r+0x324>)
34027376:	e7af      	b.n	340272d8 <_strerror_r+0x134>
34027378:	4b54      	ldr	r3, [pc, #336]	@ (340274cc <_strerror_r+0x328>)
3402737a:	e7ad      	b.n	340272d8 <_strerror_r+0x134>
3402737c:	4b54      	ldr	r3, [pc, #336]	@ (340274d0 <_strerror_r+0x32c>)
3402737e:	e7ab      	b.n	340272d8 <_strerror_r+0x134>
34027380:	4b54      	ldr	r3, [pc, #336]	@ (340274d4 <_strerror_r+0x330>)
34027382:	e7a9      	b.n	340272d8 <_strerror_r+0x134>
34027384:	4b54      	ldr	r3, [pc, #336]	@ (340274d8 <_strerror_r+0x334>)
34027386:	e7a7      	b.n	340272d8 <_strerror_r+0x134>
34027388:	4b54      	ldr	r3, [pc, #336]	@ (340274dc <_strerror_r+0x338>)
3402738a:	e7a5      	b.n	340272d8 <_strerror_r+0x134>
3402738c:	4b54      	ldr	r3, [pc, #336]	@ (340274e0 <_strerror_r+0x33c>)
3402738e:	e7a3      	b.n	340272d8 <_strerror_r+0x134>
34027390:	4b54      	ldr	r3, [pc, #336]	@ (340274e4 <_strerror_r+0x340>)
34027392:	e7a1      	b.n	340272d8 <_strerror_r+0x134>
34027394:	4b54      	ldr	r3, [pc, #336]	@ (340274e8 <_strerror_r+0x344>)
34027396:	e79f      	b.n	340272d8 <_strerror_r+0x134>
34027398:	4b54      	ldr	r3, [pc, #336]	@ (340274ec <_strerror_r+0x348>)
3402739a:	e79d      	b.n	340272d8 <_strerror_r+0x134>
3402739c:	4b54      	ldr	r3, [pc, #336]	@ (340274f0 <_strerror_r+0x34c>)
3402739e:	e79b      	b.n	340272d8 <_strerror_r+0x134>
340273a0:	4b54      	ldr	r3, [pc, #336]	@ (340274f4 <_strerror_r+0x350>)
340273a2:	e799      	b.n	340272d8 <_strerror_r+0x134>
340273a4:	4b54      	ldr	r3, [pc, #336]	@ (340274f8 <_strerror_r+0x354>)
340273a6:	e797      	b.n	340272d8 <_strerror_r+0x134>
340273a8:	4b54      	ldr	r3, [pc, #336]	@ (340274fc <_strerror_r+0x358>)
340273aa:	e795      	b.n	340272d8 <_strerror_r+0x134>
340273ac:	4b54      	ldr	r3, [pc, #336]	@ (34027500 <_strerror_r+0x35c>)
340273ae:	e793      	b.n	340272d8 <_strerror_r+0x134>
340273b0:	4b54      	ldr	r3, [pc, #336]	@ (34027504 <_strerror_r+0x360>)
340273b2:	e791      	b.n	340272d8 <_strerror_r+0x134>
340273b4:	4b54      	ldr	r3, [pc, #336]	@ (34027508 <_strerror_r+0x364>)
340273b6:	e78f      	b.n	340272d8 <_strerror_r+0x134>
340273b8:	4b54      	ldr	r3, [pc, #336]	@ (3402750c <_strerror_r+0x368>)
340273ba:	e78d      	b.n	340272d8 <_strerror_r+0x134>
340273bc:	4b54      	ldr	r3, [pc, #336]	@ (34027510 <_strerror_r+0x36c>)
340273be:	e78b      	b.n	340272d8 <_strerror_r+0x134>
340273c0:	4b54      	ldr	r3, [pc, #336]	@ (34027514 <_strerror_r+0x370>)
340273c2:	e789      	b.n	340272d8 <_strerror_r+0x134>
340273c4:	4b54      	ldr	r3, [pc, #336]	@ (34027518 <_strerror_r+0x374>)
340273c6:	e787      	b.n	340272d8 <_strerror_r+0x134>
340273c8:	4b54      	ldr	r3, [pc, #336]	@ (3402751c <_strerror_r+0x378>)
340273ca:	e785      	b.n	340272d8 <_strerror_r+0x134>
340273cc:	4b54      	ldr	r3, [pc, #336]	@ (34027520 <_strerror_r+0x37c>)
340273ce:	e783      	b.n	340272d8 <_strerror_r+0x134>
340273d0:	4b54      	ldr	r3, [pc, #336]	@ (34027524 <_strerror_r+0x380>)
340273d2:	e781      	b.n	340272d8 <_strerror_r+0x134>
340273d4:	4b54      	ldr	r3, [pc, #336]	@ (34027528 <_strerror_r+0x384>)
340273d6:	e77f      	b.n	340272d8 <_strerror_r+0x134>
340273d8:	4b54      	ldr	r3, [pc, #336]	@ (3402752c <_strerror_r+0x388>)
340273da:	e77d      	b.n	340272d8 <_strerror_r+0x134>
340273dc:	4b54      	ldr	r3, [pc, #336]	@ (34027530 <_strerror_r+0x38c>)
340273de:	e77b      	b.n	340272d8 <_strerror_r+0x134>
340273e0:	4b54      	ldr	r3, [pc, #336]	@ (34027534 <_strerror_r+0x390>)
340273e2:	e779      	b.n	340272d8 <_strerror_r+0x134>
340273e4:	4b54      	ldr	r3, [pc, #336]	@ (34027538 <_strerror_r+0x394>)
340273e6:	e777      	b.n	340272d8 <_strerror_r+0x134>
340273e8:	4b54      	ldr	r3, [pc, #336]	@ (3402753c <_strerror_r+0x398>)
340273ea:	e775      	b.n	340272d8 <_strerror_r+0x134>
340273ec:	4b54      	ldr	r3, [pc, #336]	@ (34027540 <_strerror_r+0x39c>)
340273ee:	e773      	b.n	340272d8 <_strerror_r+0x134>
340273f0:	4b54      	ldr	r3, [pc, #336]	@ (34027544 <_strerror_r+0x3a0>)
340273f2:	e771      	b.n	340272d8 <_strerror_r+0x134>
340273f4:	4b54      	ldr	r3, [pc, #336]	@ (34027548 <_strerror_r+0x3a4>)
340273f6:	e76f      	b.n	340272d8 <_strerror_r+0x134>
340273f8:	4b54      	ldr	r3, [pc, #336]	@ (3402754c <_strerror_r+0x3a8>)
340273fa:	e76d      	b.n	340272d8 <_strerror_r+0x134>
340273fc:	4b54      	ldr	r3, [pc, #336]	@ (34027550 <_strerror_r+0x3ac>)
340273fe:	e76b      	b.n	340272d8 <_strerror_r+0x134>
34027400:	4b54      	ldr	r3, [pc, #336]	@ (34027554 <_strerror_r+0x3b0>)
34027402:	e769      	b.n	340272d8 <_strerror_r+0x134>
34027404:	4b54      	ldr	r3, [pc, #336]	@ (34027558 <_strerror_r+0x3b4>)
34027406:	e767      	b.n	340272d8 <_strerror_r+0x134>
34027408:	4b54      	ldr	r3, [pc, #336]	@ (3402755c <_strerror_r+0x3b8>)
3402740a:	e765      	b.n	340272d8 <_strerror_r+0x134>
3402740c:	4b54      	ldr	r3, [pc, #336]	@ (34027560 <_strerror_r+0x3bc>)
3402740e:	e763      	b.n	340272d8 <_strerror_r+0x134>
34027410:	4b54      	ldr	r3, [pc, #336]	@ (34027564 <_strerror_r+0x3c0>)
34027412:	e761      	b.n	340272d8 <_strerror_r+0x134>
34027414:	2a00      	cmp	r2, #0
34027416:	bf08      	it	eq
34027418:	4622      	moveq	r2, r4
3402741a:	f000 f8b3 	bl	34027584 <_user_strerror>
3402741e:	4b52      	ldr	r3, [pc, #328]	@ (34027568 <_strerror_r+0x3c4>)
34027420:	2800      	cmp	r0, #0
34027422:	bf18      	it	ne
34027424:	4603      	movne	r3, r0
34027426:	e757      	b.n	340272d8 <_strerror_r+0x134>
34027428:	4b50      	ldr	r3, [pc, #320]	@ (3402756c <_strerror_r+0x3c8>)
3402742a:	e755      	b.n	340272d8 <_strerror_r+0x134>
3402742c:	3403e615 	.word	0x3403e615
34027430:	3403e627 	.word	0x3403e627
34027434:	3403e641 	.word	0x3403e641
34027438:	3403e651 	.word	0x3403e651
3402743c:	3403e669 	.word	0x3403e669
34027440:	3403e673 	.word	0x3403e673
34027444:	3403e68d 	.word	0x3403e68d
34027448:	3403e69f 	.word	0x3403e69f
3402744c:	3403e6b1 	.word	0x3403e6b1
34027450:	3403e6ca 	.word	0x3403e6ca
34027454:	3403e6da 	.word	0x3403e6da
34027458:	3403e6e6 	.word	0x3403e6e6
3402745c:	3403e703 	.word	0x3403e703
34027460:	3403e715 	.word	0x3403e715
34027464:	3403e726 	.word	0x3403e726
34027468:	3403e738 	.word	0x3403e738
3402746c:	3403e744 	.word	0x3403e744
34027470:	3403e75c 	.word	0x3403e75c
34027474:	3403e768 	.word	0x3403e768
34027478:	3403e77a 	.word	0x3403e77a
3402747c:	3403e789 	.word	0x3403e789
34027480:	3403e799 	.word	0x3403e799
34027484:	3403e7a6 	.word	0x3403e7a6
34027488:	3403e7c5 	.word	0x3403e7c5
3402748c:	3403e7d4 	.word	0x3403e7d4
34027490:	3403e7e5 	.word	0x3403e7e5
34027494:	3403e809 	.word	0x3403e809
34027498:	3403e827 	.word	0x3403e827
3402749c:	3403e845 	.word	0x3403e845
340274a0:	3403e865 	.word	0x3403e865
340274a4:	3403e87c 	.word	0x3403e87c
340274a8:	3403e88b 	.word	0x3403e88b
340274ac:	3403e89a 	.word	0x3403e89a
340274b0:	3403e8ae 	.word	0x3403e8ae
340274b4:	3403e8c6 	.word	0x3403e8c6
340274b8:	3403e8d4 	.word	0x3403e8d4
340274bc:	3403e8e1 	.word	0x3403e8e1
340274c0:	3403e8f7 	.word	0x3403e8f7
340274c4:	3403e906 	.word	0x3403e906
340274c8:	3403e912 	.word	0x3403e912
340274cc:	3403e941 	.word	0x3403e941
340274d0:	3403e952 	.word	0x3403e952
340274d4:	3403e96d 	.word	0x3403e96d
340274d8:	3403e980 	.word	0x3403e980
340274dc:	3403e996 	.word	0x3403e996
340274e0:	3403e99f 	.word	0x3403e99f
340274e4:	3403e9b6 	.word	0x3403e9b6
340274e8:	3403e9be 	.word	0x3403e9be
340274ec:	3403e9cb 	.word	0x3403e9cb
340274f0:	3403e9e0 	.word	0x3403e9e0
340274f4:	3403e9f4 	.word	0x3403e9f4
340274f8:	3403ea0c 	.word	0x3403ea0c
340274fc:	3403ea1b 	.word	0x3403ea1b
34027500:	3403ea2c 	.word	0x3403ea2c
34027504:	3403ea3f 	.word	0x3403ea3f
34027508:	3403ea4b 	.word	0x3403ea4b
3402750c:	3403ea64 	.word	0x3403ea64
34027510:	3403ea78 	.word	0x3403ea78
34027514:	3403ea93 	.word	0x3403ea93
34027518:	3403eaab 	.word	0x3403eaab
3402751c:	3403eac5 	.word	0x3403eac5
34027520:	3403eacd 	.word	0x3403eacd
34027524:	3403eafd 	.word	0x3403eafd
34027528:	3403eb1c 	.word	0x3403eb1c
3402752c:	3403eb3b 	.word	0x3403eb3b
34027530:	3403eb52 	.word	0x3403eb52
34027534:	3403eb65 	.word	0x3403eb65
34027538:	3403eb7e 	.word	0x3403eb7e
3402753c:	3403eb95 	.word	0x3403eb95
34027540:	3403ebab 	.word	0x3403ebab
34027544:	3403ebcc 	.word	0x3403ebcc
34027548:	3403ebe4 	.word	0x3403ebe4
3402754c:	3403ec00 	.word	0x3403ec00
34027550:	3403ec13 	.word	0x3403ec13
34027554:	3403ec29 	.word	0x3403ec29
34027558:	3403ec3d 	.word	0x3403ec3d
3402755c:	3403ec5f 	.word	0x3403ec5f
34027560:	3403ec85 	.word	0x3403ec85
34027564:	3403ec96 	.word	0x3403ec96
34027568:	3403e15d 	.word	0x3403e15d
3402756c:	3403e61d 	.word	0x3403e61d

34027570 <strerror>:
34027570:	4601      	mov	r1, r0
34027572:	2300      	movs	r3, #0
34027574:	4802      	ldr	r0, [pc, #8]	@ (34027580 <strerror+0x10>)
34027576:	461a      	mov	r2, r3
34027578:	6800      	ldr	r0, [r0, #0]
3402757a:	f7ff be13 	b.w	340271a4 <_strerror_r>
3402757e:	bf00      	nop
34027580:	340414a4 	.word	0x340414a4

34027584 <_user_strerror>:
34027584:	2000      	movs	r0, #0
34027586:	4770      	bx	lr

34027588 <_localeconv_r>:
34027588:	4800      	ldr	r0, [pc, #0]	@ (3402758c <_localeconv_r+0x4>)
3402758a:	4770      	bx	lr
3402758c:	340415e4 	.word	0x340415e4

34027590 <_close_r>:
34027590:	b538      	push	{r3, r4, r5, lr}
34027592:	2300      	movs	r3, #0
34027594:	4d05      	ldr	r5, [pc, #20]	@ (340275ac <_close_r+0x1c>)
34027596:	4604      	mov	r4, r0
34027598:	4608      	mov	r0, r1
3402759a:	602b      	str	r3, [r5, #0]
3402759c:	f7dd fbef 	bl	34004d7e <_close>
340275a0:	1c43      	adds	r3, r0, #1
340275a2:	d102      	bne.n	340275aa <_close_r+0x1a>
340275a4:	682b      	ldr	r3, [r5, #0]
340275a6:	b103      	cbz	r3, 340275aa <_close_r+0x1a>
340275a8:	6023      	str	r3, [r4, #0]
340275aa:	bd38      	pop	{r3, r4, r5, pc}
340275ac:	340567f0 	.word	0x340567f0

340275b0 <_lseek_r>:
340275b0:	b538      	push	{r3, r4, r5, lr}
340275b2:	4604      	mov	r4, r0
340275b4:	4d06      	ldr	r5, [pc, #24]	@ (340275d0 <_lseek_r+0x20>)
340275b6:	4608      	mov	r0, r1
340275b8:	4611      	mov	r1, r2
340275ba:	2200      	movs	r2, #0
340275bc:	602a      	str	r2, [r5, #0]
340275be:	461a      	mov	r2, r3
340275c0:	f7dd fc04 	bl	34004dcc <_lseek>
340275c4:	1c43      	adds	r3, r0, #1
340275c6:	d102      	bne.n	340275ce <_lseek_r+0x1e>
340275c8:	682b      	ldr	r3, [r5, #0]
340275ca:	b103      	cbz	r3, 340275ce <_lseek_r+0x1e>
340275cc:	6023      	str	r3, [r4, #0]
340275ce:	bd38      	pop	{r3, r4, r5, pc}
340275d0:	340567f0 	.word	0x340567f0

340275d4 <_read_r>:
340275d4:	b538      	push	{r3, r4, r5, lr}
340275d6:	4604      	mov	r4, r0
340275d8:	4d06      	ldr	r5, [pc, #24]	@ (340275f4 <_read_r+0x20>)
340275da:	4608      	mov	r0, r1
340275dc:	4611      	mov	r1, r2
340275de:	2200      	movs	r2, #0
340275e0:	602a      	str	r2, [r5, #0]
340275e2:	461a      	mov	r2, r3
340275e4:	f7dd fb92 	bl	34004d0c <_read>
340275e8:	1c43      	adds	r3, r0, #1
340275ea:	d102      	bne.n	340275f2 <_read_r+0x1e>
340275ec:	682b      	ldr	r3, [r5, #0]
340275ee:	b103      	cbz	r3, 340275f2 <_read_r+0x1e>
340275f0:	6023      	str	r3, [r4, #0]
340275f2:	bd38      	pop	{r3, r4, r5, pc}
340275f4:	340567f0 	.word	0x340567f0

340275f8 <_sbrk_r>:
340275f8:	b538      	push	{r3, r4, r5, lr}
340275fa:	2300      	movs	r3, #0
340275fc:	4d05      	ldr	r5, [pc, #20]	@ (34027614 <_sbrk_r+0x1c>)
340275fe:	4604      	mov	r4, r0
34027600:	4608      	mov	r0, r1
34027602:	602b      	str	r3, [r5, #0]
34027604:	f7dd fbf0 	bl	34004de8 <_sbrk>
34027608:	1c43      	adds	r3, r0, #1
3402760a:	d102      	bne.n	34027612 <_sbrk_r+0x1a>
3402760c:	682b      	ldr	r3, [r5, #0]
3402760e:	b103      	cbz	r3, 34027612 <_sbrk_r+0x1a>
34027610:	6023      	str	r3, [r4, #0]
34027612:	bd38      	pop	{r3, r4, r5, pc}
34027614:	340567f0 	.word	0x340567f0

34027618 <_write_r>:
34027618:	b538      	push	{r3, r4, r5, lr}
3402761a:	4604      	mov	r4, r0
3402761c:	4d06      	ldr	r5, [pc, #24]	@ (34027638 <_write_r+0x20>)
3402761e:	4608      	mov	r0, r1
34027620:	4611      	mov	r1, r2
34027622:	2200      	movs	r2, #0
34027624:	602a      	str	r2, [r5, #0]
34027626:	461a      	mov	r2, r3
34027628:	f7dd fb8d 	bl	34004d46 <_write>
3402762c:	1c43      	adds	r3, r0, #1
3402762e:	d102      	bne.n	34027636 <_write_r+0x1e>
34027630:	682b      	ldr	r3, [r5, #0]
34027632:	b103      	cbz	r3, 34027636 <_write_r+0x1e>
34027634:	6023      	str	r3, [r4, #0]
34027636:	bd38      	pop	{r3, r4, r5, pc}
34027638:	340567f0 	.word	0x340567f0

3402763c <__errno>:
3402763c:	4b01      	ldr	r3, [pc, #4]	@ (34027644 <__errno+0x8>)
3402763e:	6818      	ldr	r0, [r3, #0]
34027640:	4770      	bx	lr
34027642:	bf00      	nop
34027644:	340414a4 	.word	0x340414a4

34027648 <__libc_init_array>:
34027648:	b570      	push	{r4, r5, r6, lr}
3402764a:	4d0d      	ldr	r5, [pc, #52]	@ (34027680 <__libc_init_array+0x38>)
3402764c:	2600      	movs	r6, #0
3402764e:	4c0d      	ldr	r4, [pc, #52]	@ (34027684 <__libc_init_array+0x3c>)
34027650:	1b64      	subs	r4, r4, r5
34027652:	10a4      	asrs	r4, r4, #2
34027654:	42a6      	cmp	r6, r4
34027656:	d109      	bne.n	3402766c <__libc_init_array+0x24>
34027658:	4d0b      	ldr	r5, [pc, #44]	@ (34027688 <__libc_init_array+0x40>)
3402765a:	2600      	movs	r6, #0
3402765c:	4c0b      	ldr	r4, [pc, #44]	@ (3402768c <__libc_init_array+0x44>)
3402765e:	f002 fd39 	bl	3402a0d4 <_init>
34027662:	1b64      	subs	r4, r4, r5
34027664:	10a4      	asrs	r4, r4, #2
34027666:	42a6      	cmp	r6, r4
34027668:	d105      	bne.n	34027676 <__libc_init_array+0x2e>
3402766a:	bd70      	pop	{r4, r5, r6, pc}
3402766c:	f855 3b04 	ldr.w	r3, [r5], #4
34027670:	3601      	adds	r6, #1
34027672:	4798      	blx	r3
34027674:	e7ee      	b.n	34027654 <__libc_init_array+0xc>
34027676:	f855 3b04 	ldr.w	r3, [r5], #4
3402767a:	3601      	adds	r6, #1
3402767c:	4798      	blx	r3
3402767e:	e7f2      	b.n	34027666 <__libc_init_array+0x1e>
34027680:	3404137c 	.word	0x3404137c
34027684:	3404137c 	.word	0x3404137c
34027688:	3404137c 	.word	0x3404137c
3402768c:	34041380 	.word	0x34041380

34027690 <__retarget_lock_init_recursive>:
34027690:	4770      	bx	lr

34027692 <__retarget_lock_acquire_recursive>:
34027692:	4770      	bx	lr

34027694 <__retarget_lock_release_recursive>:
34027694:	4770      	bx	lr

34027696 <memchr>:
34027696:	b2c9      	uxtb	r1, r1
34027698:	4603      	mov	r3, r0
3402769a:	4402      	add	r2, r0
3402769c:	b510      	push	{r4, lr}
3402769e:	4293      	cmp	r3, r2
340276a0:	4618      	mov	r0, r3
340276a2:	d101      	bne.n	340276a8 <memchr+0x12>
340276a4:	2000      	movs	r0, #0
340276a6:	e003      	b.n	340276b0 <memchr+0x1a>
340276a8:	7804      	ldrb	r4, [r0, #0]
340276aa:	3301      	adds	r3, #1
340276ac:	428c      	cmp	r4, r1
340276ae:	d1f6      	bne.n	3402769e <memchr+0x8>
340276b0:	bd10      	pop	{r4, pc}

340276b2 <memcpy>:
340276b2:	440a      	add	r2, r1
340276b4:	1e43      	subs	r3, r0, #1
340276b6:	4291      	cmp	r1, r2
340276b8:	d100      	bne.n	340276bc <memcpy+0xa>
340276ba:	4770      	bx	lr
340276bc:	b510      	push	{r4, lr}
340276be:	f811 4b01 	ldrb.w	r4, [r1], #1
340276c2:	4291      	cmp	r1, r2
340276c4:	f803 4f01 	strb.w	r4, [r3, #1]!
340276c8:	d1f9      	bne.n	340276be <memcpy+0xc>
340276ca:	bd10      	pop	{r4, pc}

340276cc <abort>:
340276cc:	2006      	movs	r0, #6
340276ce:	b508      	push	{r3, lr}
340276d0:	f001 fd94 	bl	340291fc <raise>
340276d4:	2001      	movs	r0, #1
340276d6:	f7dd fb0e 	bl	34004cf6 <_exit>

340276da <quorem>:
340276da:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
340276de:	6903      	ldr	r3, [r0, #16]
340276e0:	4607      	mov	r7, r0
340276e2:	690c      	ldr	r4, [r1, #16]
340276e4:	42a3      	cmp	r3, r4
340276e6:	f2c0 8083 	blt.w	340277f0 <quorem+0x116>
340276ea:	3c01      	subs	r4, #1
340276ec:	f100 0514 	add.w	r5, r0, #20
340276f0:	f101 0814 	add.w	r8, r1, #20
340276f4:	00a3      	lsls	r3, r4, #2
340276f6:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
340276fa:	eb08 0984 	add.w	r9, r8, r4, lsl #2
340276fe:	9300      	str	r3, [sp, #0]
34027700:	eb05 0384 	add.w	r3, r5, r4, lsl #2
34027704:	9301      	str	r3, [sp, #4]
34027706:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
3402770a:	3301      	adds	r3, #1
3402770c:	429a      	cmp	r2, r3
3402770e:	fbb2 f6f3 	udiv	r6, r2, r3
34027712:	d331      	bcc.n	34027778 <quorem+0x9e>
34027714:	f04f 0a00 	mov.w	sl, #0
34027718:	46c4      	mov	ip, r8
3402771a:	46ae      	mov	lr, r5
3402771c:	46d3      	mov	fp, sl
3402771e:	f85c 3b04 	ldr.w	r3, [ip], #4
34027722:	b298      	uxth	r0, r3
34027724:	45e1      	cmp	r9, ip
34027726:	ea4f 4313 	mov.w	r3, r3, lsr #16
3402772a:	fb06 a000 	mla	r0, r6, r0, sl
3402772e:	ea4f 4210 	mov.w	r2, r0, lsr #16
34027732:	b280      	uxth	r0, r0
34027734:	fb06 2303 	mla	r3, r6, r3, r2
34027738:	f8de 2000 	ldr.w	r2, [lr]
3402773c:	b292      	uxth	r2, r2
3402773e:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34027742:	eba2 0200 	sub.w	r2, r2, r0
34027746:	b29b      	uxth	r3, r3
34027748:	f8de 0000 	ldr.w	r0, [lr]
3402774c:	445a      	add	r2, fp
3402774e:	ebc3 4322 	rsb	r3, r3, r2, asr #16
34027752:	b292      	uxth	r2, r2
34027754:	eb03 4310 	add.w	r3, r3, r0, lsr #16
34027758:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
3402775c:	ea4f 4b23 	mov.w	fp, r3, asr #16
34027760:	f84e 2b04 	str.w	r2, [lr], #4
34027764:	d2db      	bcs.n	3402771e <quorem+0x44>
34027766:	9b00      	ldr	r3, [sp, #0]
34027768:	58eb      	ldr	r3, [r5, r3]
3402776a:	b92b      	cbnz	r3, 34027778 <quorem+0x9e>
3402776c:	9b01      	ldr	r3, [sp, #4]
3402776e:	3b04      	subs	r3, #4
34027770:	429d      	cmp	r5, r3
34027772:	461a      	mov	r2, r3
34027774:	d330      	bcc.n	340277d8 <quorem+0xfe>
34027776:	613c      	str	r4, [r7, #16]
34027778:	4638      	mov	r0, r7
3402777a:	f001 f85b 	bl	34028834 <__mcmp>
3402777e:	2800      	cmp	r0, #0
34027780:	db26      	blt.n	340277d0 <quorem+0xf6>
34027782:	4629      	mov	r1, r5
34027784:	2000      	movs	r0, #0
34027786:	f858 2b04 	ldr.w	r2, [r8], #4
3402778a:	f8d1 c000 	ldr.w	ip, [r1]
3402778e:	fa1f fe82 	uxth.w	lr, r2
34027792:	45c1      	cmp	r9, r8
34027794:	fa1f f38c 	uxth.w	r3, ip
34027798:	ea4f 4212 	mov.w	r2, r2, lsr #16
3402779c:	eba3 030e 	sub.w	r3, r3, lr
340277a0:	4403      	add	r3, r0
340277a2:	ebc2 4223 	rsb	r2, r2, r3, asr #16
340277a6:	b29b      	uxth	r3, r3
340277a8:	eb02 421c 	add.w	r2, r2, ip, lsr #16
340277ac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
340277b0:	ea4f 4022 	mov.w	r0, r2, asr #16
340277b4:	f841 3b04 	str.w	r3, [r1], #4
340277b8:	d2e5      	bcs.n	34027786 <quorem+0xac>
340277ba:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
340277be:	eb05 0384 	add.w	r3, r5, r4, lsl #2
340277c2:	b922      	cbnz	r2, 340277ce <quorem+0xf4>
340277c4:	3b04      	subs	r3, #4
340277c6:	429d      	cmp	r5, r3
340277c8:	461a      	mov	r2, r3
340277ca:	d30b      	bcc.n	340277e4 <quorem+0x10a>
340277cc:	613c      	str	r4, [r7, #16]
340277ce:	3601      	adds	r6, #1
340277d0:	4630      	mov	r0, r6
340277d2:	b003      	add	sp, #12
340277d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340277d8:	6812      	ldr	r2, [r2, #0]
340277da:	3b04      	subs	r3, #4
340277dc:	2a00      	cmp	r2, #0
340277de:	d1ca      	bne.n	34027776 <quorem+0x9c>
340277e0:	3c01      	subs	r4, #1
340277e2:	e7c5      	b.n	34027770 <quorem+0x96>
340277e4:	6812      	ldr	r2, [r2, #0]
340277e6:	3b04      	subs	r3, #4
340277e8:	2a00      	cmp	r2, #0
340277ea:	d1ef      	bne.n	340277cc <quorem+0xf2>
340277ec:	3c01      	subs	r4, #1
340277ee:	e7ea      	b.n	340277c6 <quorem+0xec>
340277f0:	2000      	movs	r0, #0
340277f2:	e7ee      	b.n	340277d2 <quorem+0xf8>
340277f4:	0000      	movs	r0, r0
	...

340277f8 <_dtoa_r>:
340277f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340277fc:	69c7      	ldr	r7, [r0, #28]
340277fe:	4681      	mov	r9, r0
34027800:	ed2d 8b02 	vpush	{d8}
34027804:	b091      	sub	sp, #68	@ 0x44
34027806:	ec55 4b10 	vmov	r4, r5, d0
3402780a:	9e1c      	ldr	r6, [sp, #112]	@ 0x70
3402780c:	9107      	str	r1, [sp, #28]
3402780e:	9209      	str	r2, [sp, #36]	@ 0x24
34027810:	930d      	str	r3, [sp, #52]	@ 0x34
34027812:	ed8d 0b02 	vstr	d0, [sp, #8]
34027816:	b97f      	cbnz	r7, 34027838 <_dtoa_r+0x40>
34027818:	2010      	movs	r0, #16
3402781a:	f7fe fac3 	bl	34025da4 <malloc>
3402781e:	4602      	mov	r2, r0
34027820:	f8c9 001c 	str.w	r0, [r9, #28]
34027824:	b920      	cbnz	r0, 34027830 <_dtoa_r+0x38>
34027826:	4ba0      	ldr	r3, [pc, #640]	@ (34027aa8 <_dtoa_r+0x2b0>)
34027828:	21ef      	movs	r1, #239	@ 0xef
3402782a:	48a0      	ldr	r0, [pc, #640]	@ (34027aac <_dtoa_r+0x2b4>)
3402782c:	f7fe fa9c 	bl	34025d68 <__assert_func>
34027830:	e9c0 7701 	strd	r7, r7, [r0, #4]
34027834:	6007      	str	r7, [r0, #0]
34027836:	60c7      	str	r7, [r0, #12]
34027838:	f8d9 301c 	ldr.w	r3, [r9, #28]
3402783c:	6819      	ldr	r1, [r3, #0]
3402783e:	b159      	cbz	r1, 34027858 <_dtoa_r+0x60>
34027840:	685a      	ldr	r2, [r3, #4]
34027842:	2301      	movs	r3, #1
34027844:	4648      	mov	r0, r9
34027846:	4093      	lsls	r3, r2
34027848:	604a      	str	r2, [r1, #4]
3402784a:	608b      	str	r3, [r1, #8]
3402784c:	f000 fdbc 	bl	340283c8 <_Bfree>
34027850:	f8d9 301c 	ldr.w	r3, [r9, #28]
34027854:	2200      	movs	r2, #0
34027856:	601a      	str	r2, [r3, #0]
34027858:	1e2b      	subs	r3, r5, #0
3402785a:	bfb7      	itett	lt
3402785c:	f023 4300 	biclt.w	r3, r3, #2147483648	@ 0x80000000
34027860:	2300      	movge	r3, #0
34027862:	2201      	movlt	r2, #1
34027864:	9303      	strlt	r3, [sp, #12]
34027866:	bfac      	ite	ge
34027868:	6033      	strge	r3, [r6, #0]
3402786a:	6032      	strlt	r2, [r6, #0]
3402786c:	4b90      	ldr	r3, [pc, #576]	@ (34027ab0 <_dtoa_r+0x2b8>)
3402786e:	9e03      	ldr	r6, [sp, #12]
34027870:	43b3      	bics	r3, r6
34027872:	d110      	bne.n	34027896 <_dtoa_r+0x9e>
34027874:	f242 730f 	movw	r3, #9999	@ 0x270f
34027878:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
3402787a:	6013      	str	r3, [r2, #0]
3402787c:	f3c6 0313 	ubfx	r3, r6, #0, #20
34027880:	4323      	orrs	r3, r4
34027882:	f000 84e6 	beq.w	34028252 <_dtoa_r+0xa5a>
34027886:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34027888:	4f8a      	ldr	r7, [pc, #552]	@ (34027ab4 <_dtoa_r+0x2bc>)
3402788a:	2b00      	cmp	r3, #0
3402788c:	f000 84e8 	beq.w	34028260 <_dtoa_r+0xa68>
34027890:	1cfb      	adds	r3, r7, #3
34027892:	f000 bce3 	b.w	3402825c <_dtoa_r+0xa64>
34027896:	ed9d 8b02 	vldr	d8, [sp, #8]
3402789a:	eeb5 8b40 	vcmp.f64	d8, #0.0
3402789e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340278a2:	d10a      	bne.n	340278ba <_dtoa_r+0xc2>
340278a4:	2301      	movs	r3, #1
340278a6:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
340278a8:	6013      	str	r3, [r2, #0]
340278aa:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
340278ac:	b113      	cbz	r3, 340278b4 <_dtoa_r+0xbc>
340278ae:	4b82      	ldr	r3, [pc, #520]	@ (34027ab8 <_dtoa_r+0x2c0>)
340278b0:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
340278b2:	6013      	str	r3, [r2, #0]
340278b4:	4f81      	ldr	r7, [pc, #516]	@ (34027abc <_dtoa_r+0x2c4>)
340278b6:	f000 bcd3 	b.w	34028260 <_dtoa_r+0xa68>
340278ba:	aa0e      	add	r2, sp, #56	@ 0x38
340278bc:	eeb0 0b48 	vmov.f64	d0, d8
340278c0:	a90f      	add	r1, sp, #60	@ 0x3c
340278c2:	4648      	mov	r0, r9
340278c4:	f001 f86a 	bl	3402899c <__d2b>
340278c8:	f3c6 530a 	ubfx	r3, r6, #20, #11
340278cc:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
340278ce:	9001      	str	r0, [sp, #4]
340278d0:	2b00      	cmp	r3, #0
340278d2:	d045      	beq.n	34027960 <_dtoa_r+0x168>
340278d4:	ee18 1a90 	vmov	r1, s17
340278d8:	eeb0 7b48 	vmov.f64	d7, d8
340278dc:	f2a3 33ff 	subw	r3, r3, #1023	@ 0x3ff
340278e0:	2500      	movs	r5, #0
340278e2:	f3c1 0113 	ubfx	r1, r1, #0, #20
340278e6:	f041 517f 	orr.w	r1, r1, #1069547520	@ 0x3fc00000
340278ea:	f441 1140 	orr.w	r1, r1, #3145728	@ 0x300000
340278ee:	eeb7 6b08 	vmov.f64	d6, #120	@ 0x3fc00000  1.5
340278f2:	ee07 1a90 	vmov	s15, r1
340278f6:	ed9f 5b66 	vldr	d5, [pc, #408]	@ 34027a90 <_dtoa_r+0x298>
340278fa:	ee37 7b46 	vsub.f64	d7, d7, d6
340278fe:	ed9f 6b66 	vldr	d6, [pc, #408]	@ 34027a98 <_dtoa_r+0x2a0>
34027902:	eea7 6b05 	vfma.f64	d6, d7, d5
34027906:	ee07 3a90 	vmov	s15, r3
3402790a:	eeb8 4be7 	vcvt.f64.s32	d4, s15
3402790e:	ed9f 5b64 	vldr	d5, [pc, #400]	@ 34027aa0 <_dtoa_r+0x2a8>
34027912:	eeb0 7b46 	vmov.f64	d7, d6
34027916:	eea4 7b05 	vfma.f64	d7, d4, d5
3402791a:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
3402791e:	eefd 6bc7 	vcvt.s32.f64	s13, d7
34027922:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027926:	ee16 8a90 	vmov	r8, s13
3402792a:	d508      	bpl.n	3402793e <_dtoa_r+0x146>
3402792c:	eeb8 6be6 	vcvt.f64.s32	d6, s13
34027930:	eeb4 6b47 	vcmp.f64	d6, d7
34027934:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027938:	bf18      	it	ne
3402793a:	f108 38ff 	addne.w	r8, r8, #4294967295
3402793e:	f1b8 0f16 	cmp.w	r8, #22
34027942:	d82d      	bhi.n	340279a0 <_dtoa_r+0x1a8>
34027944:	495e      	ldr	r1, [pc, #376]	@ (34027ac0 <_dtoa_r+0x2c8>)
34027946:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
3402794a:	ed91 7b00 	vldr	d7, [r1]
3402794e:	eeb4 8bc7 	vcmpe.f64	d8, d7
34027952:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027956:	d501      	bpl.n	3402795c <_dtoa_r+0x164>
34027958:	f108 38ff 	add.w	r8, r8, #4294967295
3402795c:	2100      	movs	r1, #0
3402795e:	e020      	b.n	340279a2 <_dtoa_r+0x1aa>
34027960:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
34027962:	2501      	movs	r5, #1
34027964:	4413      	add	r3, r2
34027966:	f203 4132 	addw	r1, r3, #1074	@ 0x432
3402796a:	2920      	cmp	r1, #32
3402796c:	bfc9      	itett	gt
3402796e:	f1c1 0140 	rsbgt	r1, r1, #64	@ 0x40
34027972:	f1c1 0120 	rsble	r1, r1, #32
34027976:	408e      	lslgt	r6, r1
34027978:	f203 4112 	addwgt	r1, r3, #1042	@ 0x412
3402797c:	bfd8      	it	le
3402797e:	fa04 f101 	lslle.w	r1, r4, r1
34027982:	f103 33ff 	add.w	r3, r3, #4294967295
34027986:	bfc4      	itt	gt
34027988:	fa24 f101 	lsrgt.w	r1, r4, r1
3402798c:	4331      	orrgt	r1, r6
3402798e:	ee07 1a90 	vmov	s15, r1
34027992:	eeb8 7b67 	vcvt.f64.u32	d7, s15
34027996:	ee17 1a90 	vmov	r1, s15
3402799a:	f1a1 71f8 	sub.w	r1, r1, #32505856	@ 0x1f00000
3402799e:	e7a6      	b.n	340278ee <_dtoa_r+0xf6>
340279a0:	2101      	movs	r1, #1
340279a2:	1ad2      	subs	r2, r2, r3
340279a4:	910c      	str	r1, [sp, #48]	@ 0x30
340279a6:	1e53      	subs	r3, r2, #1
340279a8:	9306      	str	r3, [sp, #24]
340279aa:	bf49      	itett	mi
340279ac:	f1c2 0301 	rsbmi	r3, r2, #1
340279b0:	2300      	movpl	r3, #0
340279b2:	9304      	strmi	r3, [sp, #16]
340279b4:	2300      	movmi	r3, #0
340279b6:	bf54      	ite	pl
340279b8:	9304      	strpl	r3, [sp, #16]
340279ba:	9306      	strmi	r3, [sp, #24]
340279bc:	f1b8 0f00 	cmp.w	r8, #0
340279c0:	db16      	blt.n	340279f0 <_dtoa_r+0x1f8>
340279c2:	9b06      	ldr	r3, [sp, #24]
340279c4:	f8cd 8028 	str.w	r8, [sp, #40]	@ 0x28
340279c8:	4443      	add	r3, r8
340279ca:	9306      	str	r3, [sp, #24]
340279cc:	2300      	movs	r3, #0
340279ce:	9a07      	ldr	r2, [sp, #28]
340279d0:	2a09      	cmp	r2, #9
340279d2:	d843      	bhi.n	34027a5c <_dtoa_r+0x264>
340279d4:	2a05      	cmp	r2, #5
340279d6:	bfc5      	ittet	gt
340279d8:	3a04      	subgt	r2, #4
340279da:	2400      	movgt	r4, #0
340279dc:	2401      	movle	r4, #1
340279de:	9207      	strgt	r2, [sp, #28]
340279e0:	9a07      	ldr	r2, [sp, #28]
340279e2:	3a02      	subs	r2, #2
340279e4:	2a03      	cmp	r2, #3
340279e6:	d844      	bhi.n	34027a72 <_dtoa_r+0x27a>
340279e8:	e8df f002 	tbb	[pc, r2]
340279ec:	0b173634 	.word	0x0b173634
340279f0:	9b04      	ldr	r3, [sp, #16]
340279f2:	2200      	movs	r2, #0
340279f4:	eba3 0308 	sub.w	r3, r3, r8
340279f8:	920a      	str	r2, [sp, #40]	@ 0x28
340279fa:	9304      	str	r3, [sp, #16]
340279fc:	f1c8 0300 	rsb	r3, r8, #0
34027a00:	e7e5      	b.n	340279ce <_dtoa_r+0x1d6>
34027a02:	2201      	movs	r2, #1
34027a04:	9208      	str	r2, [sp, #32]
34027a06:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34027a08:	eb08 0b02 	add.w	fp, r8, r2
34027a0c:	f10b 0a01 	add.w	sl, fp, #1
34027a10:	4652      	mov	r2, sl
34027a12:	2a01      	cmp	r2, #1
34027a14:	bfb8      	it	lt
34027a16:	2201      	movlt	r2, #1
34027a18:	e006      	b.n	34027a28 <_dtoa_r+0x230>
34027a1a:	2201      	movs	r2, #1
34027a1c:	9208      	str	r2, [sp, #32]
34027a1e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34027a20:	2a00      	cmp	r2, #0
34027a22:	dd29      	ble.n	34027a78 <_dtoa_r+0x280>
34027a24:	4693      	mov	fp, r2
34027a26:	4692      	mov	sl, r2
34027a28:	f8d9 701c 	ldr.w	r7, [r9, #28]
34027a2c:	2100      	movs	r1, #0
34027a2e:	2004      	movs	r0, #4
34027a30:	f100 0614 	add.w	r6, r0, #20
34027a34:	4296      	cmp	r6, r2
34027a36:	d926      	bls.n	34027a86 <_dtoa_r+0x28e>
34027a38:	6079      	str	r1, [r7, #4]
34027a3a:	4648      	mov	r0, r9
34027a3c:	9305      	str	r3, [sp, #20]
34027a3e:	f000 fc83 	bl	34028348 <_Balloc>
34027a42:	9b05      	ldr	r3, [sp, #20]
34027a44:	4607      	mov	r7, r0
34027a46:	2800      	cmp	r0, #0
34027a48:	d13e      	bne.n	34027ac8 <_dtoa_r+0x2d0>
34027a4a:	4b1e      	ldr	r3, [pc, #120]	@ (34027ac4 <_dtoa_r+0x2cc>)
34027a4c:	4602      	mov	r2, r0
34027a4e:	f240 11af 	movw	r1, #431	@ 0x1af
34027a52:	e6ea      	b.n	3402782a <_dtoa_r+0x32>
34027a54:	2200      	movs	r2, #0
34027a56:	e7e1      	b.n	34027a1c <_dtoa_r+0x224>
34027a58:	2200      	movs	r2, #0
34027a5a:	e7d3      	b.n	34027a04 <_dtoa_r+0x20c>
34027a5c:	2401      	movs	r4, #1
34027a5e:	2200      	movs	r2, #0
34027a60:	e9cd 2407 	strd	r2, r4, [sp, #28]
34027a64:	f04f 3bff 	mov.w	fp, #4294967295
34027a68:	2100      	movs	r1, #0
34027a6a:	2212      	movs	r2, #18
34027a6c:	46da      	mov	sl, fp
34027a6e:	9109      	str	r1, [sp, #36]	@ 0x24
34027a70:	e7da      	b.n	34027a28 <_dtoa_r+0x230>
34027a72:	2201      	movs	r2, #1
34027a74:	9208      	str	r2, [sp, #32]
34027a76:	e7f5      	b.n	34027a64 <_dtoa_r+0x26c>
34027a78:	f04f 0b01 	mov.w	fp, #1
34027a7c:	46da      	mov	sl, fp
34027a7e:	465a      	mov	r2, fp
34027a80:	f8cd b024 	str.w	fp, [sp, #36]	@ 0x24
34027a84:	e7d0      	b.n	34027a28 <_dtoa_r+0x230>
34027a86:	3101      	adds	r1, #1
34027a88:	0040      	lsls	r0, r0, #1
34027a8a:	e7d1      	b.n	34027a30 <_dtoa_r+0x238>
34027a8c:	f3af 8000 	nop.w
34027a90:	636f4361 	.word	0x636f4361
34027a94:	3fd287a7 	.word	0x3fd287a7
34027a98:	8b60c8b3 	.word	0x8b60c8b3
34027a9c:	3fc68a28 	.word	0x3fc68a28
34027aa0:	509f79fb 	.word	0x509f79fb
34027aa4:	3fd34413 	.word	0x3fd34413
34027aa8:	3403ecb8 	.word	0x3403ecb8
34027aac:	3403eccf 	.word	0x3403eccf
34027ab0:	7ff00000 	.word	0x7ff00000
34027ab4:	3403ecb4 	.word	0x3403ecb4
34027ab8:	3403e5f2 	.word	0x3403e5f2
34027abc:	3403e5f1 	.word	0x3403e5f1
34027ac0:	3403ede0 	.word	0x3403ede0
34027ac4:	3403ed27 	.word	0x3403ed27
34027ac8:	f8d9 201c 	ldr.w	r2, [r9, #28]
34027acc:	f1ba 0f0e 	cmp.w	sl, #14
34027ad0:	6010      	str	r0, [r2, #0]
34027ad2:	d86e      	bhi.n	34027bb2 <_dtoa_r+0x3ba>
34027ad4:	2c00      	cmp	r4, #0
34027ad6:	d06c      	beq.n	34027bb2 <_dtoa_r+0x3ba>
34027ad8:	f1b8 0f00 	cmp.w	r8, #0
34027adc:	f340 80b4 	ble.w	34027c48 <_dtoa_r+0x450>
34027ae0:	f008 010f 	and.w	r1, r8, #15
34027ae4:	4ac7      	ldr	r2, [pc, #796]	@ (34027e04 <_dtoa_r+0x60c>)
34027ae6:	f418 7f80 	tst.w	r8, #256	@ 0x100
34027aea:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
34027aee:	ea4f 1128 	mov.w	r1, r8, asr #4
34027af2:	ed92 7b00 	vldr	d7, [r2]
34027af6:	f000 809b 	beq.w	34027c30 <_dtoa_r+0x438>
34027afa:	4ac3      	ldr	r2, [pc, #780]	@ (34027e08 <_dtoa_r+0x610>)
34027afc:	f001 010f 	and.w	r1, r1, #15
34027b00:	ed92 6b08 	vldr	d6, [r2, #32]
34027b04:	2203      	movs	r2, #3
34027b06:	ee88 6b06 	vdiv.f64	d6, d8, d6
34027b0a:	ed8d 6b02 	vstr	d6, [sp, #8]
34027b0e:	48be      	ldr	r0, [pc, #760]	@ (34027e08 <_dtoa_r+0x610>)
34027b10:	2900      	cmp	r1, #0
34027b12:	f040 808f 	bne.w	34027c34 <_dtoa_r+0x43c>
34027b16:	ed9d 6b02 	vldr	d6, [sp, #8]
34027b1a:	ee86 7b07 	vdiv.f64	d7, d6, d7
34027b1e:	ed8d 7b02 	vstr	d7, [sp, #8]
34027b22:	990c      	ldr	r1, [sp, #48]	@ 0x30
34027b24:	ed9d 7b02 	vldr	d7, [sp, #8]
34027b28:	2900      	cmp	r1, #0
34027b2a:	f000 80b3 	beq.w	34027c94 <_dtoa_r+0x49c>
34027b2e:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
34027b32:	eeb4 7bc6 	vcmpe.f64	d7, d6
34027b36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027b3a:	f140 80ab 	bpl.w	34027c94 <_dtoa_r+0x49c>
34027b3e:	f1ba 0f00 	cmp.w	sl, #0
34027b42:	f000 80a7 	beq.w	34027c94 <_dtoa_r+0x49c>
34027b46:	f1bb 0f00 	cmp.w	fp, #0
34027b4a:	dd30      	ble.n	34027bae <_dtoa_r+0x3b6>
34027b4c:	eeb2 6b04 	vmov.f64	d6, #36	@ 0x41200000  10.0
34027b50:	f108 31ff 	add.w	r1, r8, #4294967295
34027b54:	3201      	adds	r2, #1
34027b56:	465c      	mov	r4, fp
34027b58:	9105      	str	r1, [sp, #20]
34027b5a:	ee27 7b06 	vmul.f64	d7, d7, d6
34027b5e:	ed8d 7b02 	vstr	d7, [sp, #8]
34027b62:	ee07 2a90 	vmov	s15, r2
34027b66:	eeb1 5b0c 	vmov.f64	d5, #28	@ 0x40e00000  7.0
34027b6a:	ed9d 6b02 	vldr	d6, [sp, #8]
34027b6e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
34027b72:	eea7 5b06 	vfma.f64	d5, d7, d6
34027b76:	ee15 2a90 	vmov	r2, s11
34027b7a:	ec51 0b15 	vmov	r0, r1, d5
34027b7e:	f1a2 7150 	sub.w	r1, r2, #54525952	@ 0x3400000
34027b82:	2c00      	cmp	r4, #0
34027b84:	f040 808a 	bne.w	34027c9c <_dtoa_r+0x4a4>
34027b88:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
34027b8c:	ee36 6b47 	vsub.f64	d6, d6, d7
34027b90:	ec41 0b17 	vmov	d7, r0, r1
34027b94:	eeb4 6bc7 	vcmpe.f64	d6, d7
34027b98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027b9c:	f300 826a 	bgt.w	34028074 <_dtoa_r+0x87c>
34027ba0:	eeb1 7b47 	vneg.f64	d7, d7
34027ba4:	eeb4 6bc7 	vcmpe.f64	d6, d7
34027ba8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027bac:	d423      	bmi.n	34027bf6 <_dtoa_r+0x3fe>
34027bae:	ed8d 8b02 	vstr	d8, [sp, #8]
34027bb2:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
34027bb4:	2a00      	cmp	r2, #0
34027bb6:	f2c0 8129 	blt.w	34027e0c <_dtoa_r+0x614>
34027bba:	f1b8 0f0e 	cmp.w	r8, #14
34027bbe:	f300 8125 	bgt.w	34027e0c <_dtoa_r+0x614>
34027bc2:	4b90      	ldr	r3, [pc, #576]	@ (34027e04 <_dtoa_r+0x60c>)
34027bc4:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
34027bc8:	ed93 6b00 	vldr	d6, [r3]
34027bcc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34027bce:	2b00      	cmp	r3, #0
34027bd0:	f280 80c8 	bge.w	34027d64 <_dtoa_r+0x56c>
34027bd4:	f1ba 0f00 	cmp.w	sl, #0
34027bd8:	f300 80c4 	bgt.w	34027d64 <_dtoa_r+0x56c>
34027bdc:	d10b      	bne.n	34027bf6 <_dtoa_r+0x3fe>
34027bde:	eeb1 7b04 	vmov.f64	d7, #20	@ 0x40a00000  5.0
34027be2:	ee26 6b07 	vmul.f64	d6, d6, d7
34027be6:	ed9d 7b02 	vldr	d7, [sp, #8]
34027bea:	eeb4 6bc7 	vcmpe.f64	d6, d7
34027bee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027bf2:	f2c0 823c 	blt.w	3402806e <_dtoa_r+0x876>
34027bf6:	2400      	movs	r4, #0
34027bf8:	4625      	mov	r5, r4
34027bfa:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34027bfc:	463e      	mov	r6, r7
34027bfe:	43db      	mvns	r3, r3
34027c00:	9305      	str	r3, [sp, #20]
34027c02:	f04f 0800 	mov.w	r8, #0
34027c06:	4621      	mov	r1, r4
34027c08:	4648      	mov	r0, r9
34027c0a:	f000 fbdd 	bl	340283c8 <_Bfree>
34027c0e:	2d00      	cmp	r5, #0
34027c10:	f000 80a2 	beq.w	34027d58 <_dtoa_r+0x560>
34027c14:	f1b8 0f00 	cmp.w	r8, #0
34027c18:	d005      	beq.n	34027c26 <_dtoa_r+0x42e>
34027c1a:	45a8      	cmp	r8, r5
34027c1c:	d003      	beq.n	34027c26 <_dtoa_r+0x42e>
34027c1e:	4641      	mov	r1, r8
34027c20:	4648      	mov	r0, r9
34027c22:	f000 fbd1 	bl	340283c8 <_Bfree>
34027c26:	4629      	mov	r1, r5
34027c28:	4648      	mov	r0, r9
34027c2a:	f000 fbcd 	bl	340283c8 <_Bfree>
34027c2e:	e093      	b.n	34027d58 <_dtoa_r+0x560>
34027c30:	2202      	movs	r2, #2
34027c32:	e76c      	b.n	34027b0e <_dtoa_r+0x316>
34027c34:	07cc      	lsls	r4, r1, #31
34027c36:	d504      	bpl.n	34027c42 <_dtoa_r+0x44a>
34027c38:	3201      	adds	r2, #1
34027c3a:	ed90 6b00 	vldr	d6, [r0]
34027c3e:	ee27 7b06 	vmul.f64	d7, d7, d6
34027c42:	1049      	asrs	r1, r1, #1
34027c44:	3008      	adds	r0, #8
34027c46:	e763      	b.n	34027b10 <_dtoa_r+0x318>
34027c48:	d022      	beq.n	34027c90 <_dtoa_r+0x498>
34027c4a:	f1c8 0100 	rsb	r1, r8, #0
34027c4e:	4a6d      	ldr	r2, [pc, #436]	@ (34027e04 <_dtoa_r+0x60c>)
34027c50:	2400      	movs	r4, #0
34027c52:	f001 000f 	and.w	r0, r1, #15
34027c56:	1109      	asrs	r1, r1, #4
34027c58:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
34027c5c:	486a      	ldr	r0, [pc, #424]	@ (34027e08 <_dtoa_r+0x610>)
34027c5e:	ed92 7b00 	vldr	d7, [r2]
34027c62:	2202      	movs	r2, #2
34027c64:	ee28 7b07 	vmul.f64	d7, d8, d7
34027c68:	ed8d 7b02 	vstr	d7, [sp, #8]
34027c6c:	b929      	cbnz	r1, 34027c7a <_dtoa_r+0x482>
34027c6e:	2c00      	cmp	r4, #0
34027c70:	f43f af57 	beq.w	34027b22 <_dtoa_r+0x32a>
34027c74:	ed8d 7b02 	vstr	d7, [sp, #8]
34027c78:	e753      	b.n	34027b22 <_dtoa_r+0x32a>
34027c7a:	07ce      	lsls	r6, r1, #31
34027c7c:	d505      	bpl.n	34027c8a <_dtoa_r+0x492>
34027c7e:	3201      	adds	r2, #1
34027c80:	2401      	movs	r4, #1
34027c82:	ed90 6b00 	vldr	d6, [r0]
34027c86:	ee27 7b06 	vmul.f64	d7, d7, d6
34027c8a:	1049      	asrs	r1, r1, #1
34027c8c:	3008      	adds	r0, #8
34027c8e:	e7ed      	b.n	34027c6c <_dtoa_r+0x474>
34027c90:	2202      	movs	r2, #2
34027c92:	e746      	b.n	34027b22 <_dtoa_r+0x32a>
34027c94:	4654      	mov	r4, sl
34027c96:	f8cd 8014 	str.w	r8, [sp, #20]
34027c9a:	e762      	b.n	34027b62 <_dtoa_r+0x36a>
34027c9c:	4a59      	ldr	r2, [pc, #356]	@ (34027e04 <_dtoa_r+0x60c>)
34027c9e:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
34027ca2:	443c      	add	r4, r7
34027ca4:	ed12 4b02 	vldr	d4, [r2, #-8]
34027ca8:	9a08      	ldr	r2, [sp, #32]
34027caa:	ec41 0b17 	vmov	d7, r0, r1
34027cae:	b34a      	cbz	r2, 34027d04 <_dtoa_r+0x50c>
34027cb0:	eeb6 3b00 	vmov.f64	d3, #96	@ 0x3f000000  0.5
34027cb4:	463e      	mov	r6, r7
34027cb6:	eeb7 2b00 	vmov.f64	d2, #112	@ 0x3f800000  1.0
34027cba:	ee83 5b04 	vdiv.f64	d5, d3, d4
34027cbe:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
34027cc2:	ee35 7b47 	vsub.f64	d7, d5, d7
34027cc6:	eefd 4bc6 	vcvt.s32.f64	s9, d6
34027cca:	eeb8 5be4 	vcvt.f64.s32	d5, s9
34027cce:	ee14 2a90 	vmov	r2, s9
34027cd2:	3230      	adds	r2, #48	@ 0x30
34027cd4:	ee36 6b45 	vsub.f64	d6, d6, d5
34027cd8:	f806 2b01 	strb.w	r2, [r6], #1
34027cdc:	eeb4 6bc7 	vcmpe.f64	d6, d7
34027ce0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027ce4:	d438      	bmi.n	34027d58 <_dtoa_r+0x560>
34027ce6:	ee32 5b46 	vsub.f64	d5, d2, d6
34027cea:	eeb4 5bc7 	vcmpe.f64	d5, d7
34027cee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027cf2:	d46e      	bmi.n	34027dd2 <_dtoa_r+0x5da>
34027cf4:	42a6      	cmp	r6, r4
34027cf6:	f43f af5a 	beq.w	34027bae <_dtoa_r+0x3b6>
34027cfa:	ee27 7b03 	vmul.f64	d7, d7, d3
34027cfe:	ee26 6b03 	vmul.f64	d6, d6, d3
34027d02:	e7e0      	b.n	34027cc6 <_dtoa_r+0x4ce>
34027d04:	ee27 7b04 	vmul.f64	d7, d7, d4
34027d08:	4621      	mov	r1, r4
34027d0a:	463e      	mov	r6, r7
34027d0c:	eeb2 3b04 	vmov.f64	d3, #36	@ 0x41200000  10.0
34027d10:	eefd 4bc6 	vcvt.s32.f64	s9, d6
34027d14:	ee14 2a90 	vmov	r2, s9
34027d18:	eeb8 5be4 	vcvt.f64.s32	d5, s9
34027d1c:	3230      	adds	r2, #48	@ 0x30
34027d1e:	ee36 6b45 	vsub.f64	d6, d6, d5
34027d22:	f806 2b01 	strb.w	r2, [r6], #1
34027d26:	42a6      	cmp	r6, r4
34027d28:	d119      	bne.n	34027d5e <_dtoa_r+0x566>
34027d2a:	eeb6 5b00 	vmov.f64	d5, #96	@ 0x3f000000  0.5
34027d2e:	ee37 4b05 	vadd.f64	d4, d7, d5
34027d32:	eeb4 6bc4 	vcmpe.f64	d6, d4
34027d36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027d3a:	dc4a      	bgt.n	34027dd2 <_dtoa_r+0x5da>
34027d3c:	ee35 5b47 	vsub.f64	d5, d5, d7
34027d40:	eeb4 6bc5 	vcmpe.f64	d6, d5
34027d44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027d48:	f57f af31 	bpl.w	34027bae <_dtoa_r+0x3b6>
34027d4c:	460e      	mov	r6, r1
34027d4e:	3901      	subs	r1, #1
34027d50:	f816 3c01 	ldrb.w	r3, [r6, #-1]
34027d54:	2b30      	cmp	r3, #48	@ 0x30
34027d56:	d0f9      	beq.n	34027d4c <_dtoa_r+0x554>
34027d58:	f8dd 8014 	ldr.w	r8, [sp, #20]
34027d5c:	e027      	b.n	34027dae <_dtoa_r+0x5b6>
34027d5e:	ee26 6b03 	vmul.f64	d6, d6, d3
34027d62:	e7d5      	b.n	34027d10 <_dtoa_r+0x518>
34027d64:	ed9d 7b02 	vldr	d7, [sp, #8]
34027d68:	eeb2 4b04 	vmov.f64	d4, #36	@ 0x41200000  10.0
34027d6c:	463e      	mov	r6, r7
34027d6e:	ee87 5b06 	vdiv.f64	d5, d7, d6
34027d72:	eebd 5bc5 	vcvt.s32.f64	s10, d5
34027d76:	ee15 3a10 	vmov	r3, s10
34027d7a:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
34027d7e:	3330      	adds	r3, #48	@ 0x30
34027d80:	eea3 7b46 	vfms.f64	d7, d3, d6
34027d84:	f806 3b01 	strb.w	r3, [r6], #1
34027d88:	1bf3      	subs	r3, r6, r7
34027d8a:	459a      	cmp	sl, r3
34027d8c:	d132      	bne.n	34027df4 <_dtoa_r+0x5fc>
34027d8e:	ee37 7b07 	vadd.f64	d7, d7, d7
34027d92:	eeb4 7bc6 	vcmpe.f64	d7, d6
34027d96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027d9a:	dc18      	bgt.n	34027dce <_dtoa_r+0x5d6>
34027d9c:	eeb4 7b46 	vcmp.f64	d7, d6
34027da0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027da4:	d103      	bne.n	34027dae <_dtoa_r+0x5b6>
34027da6:	ee15 3a10 	vmov	r3, s10
34027daa:	07db      	lsls	r3, r3, #31
34027dac:	d40f      	bmi.n	34027dce <_dtoa_r+0x5d6>
34027dae:	9901      	ldr	r1, [sp, #4]
34027db0:	4648      	mov	r0, r9
34027db2:	f000 fb09 	bl	340283c8 <_Bfree>
34027db6:	2300      	movs	r3, #0
34027db8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
34027dba:	7033      	strb	r3, [r6, #0]
34027dbc:	f108 0301 	add.w	r3, r8, #1
34027dc0:	6013      	str	r3, [r2, #0]
34027dc2:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34027dc4:	2b00      	cmp	r3, #0
34027dc6:	f000 824b 	beq.w	34028260 <_dtoa_r+0xa68>
34027dca:	601e      	str	r6, [r3, #0]
34027dcc:	e248      	b.n	34028260 <_dtoa_r+0xa68>
34027dce:	f8cd 8014 	str.w	r8, [sp, #20]
34027dd2:	4633      	mov	r3, r6
34027dd4:	461e      	mov	r6, r3
34027dd6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
34027dda:	2a39      	cmp	r2, #57	@ 0x39
34027ddc:	d106      	bne.n	34027dec <_dtoa_r+0x5f4>
34027dde:	429f      	cmp	r7, r3
34027de0:	d1f8      	bne.n	34027dd4 <_dtoa_r+0x5dc>
34027de2:	9a05      	ldr	r2, [sp, #20]
34027de4:	3201      	adds	r2, #1
34027de6:	9205      	str	r2, [sp, #20]
34027de8:	2230      	movs	r2, #48	@ 0x30
34027dea:	703a      	strb	r2, [r7, #0]
34027dec:	781a      	ldrb	r2, [r3, #0]
34027dee:	3201      	adds	r2, #1
34027df0:	701a      	strb	r2, [r3, #0]
34027df2:	e7b1      	b.n	34027d58 <_dtoa_r+0x560>
34027df4:	ee27 7b04 	vmul.f64	d7, d7, d4
34027df8:	eeb5 7b40 	vcmp.f64	d7, #0.0
34027dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34027e00:	d1b5      	bne.n	34027d6e <_dtoa_r+0x576>
34027e02:	e7d4      	b.n	34027dae <_dtoa_r+0x5b6>
34027e04:	3403ede0 	.word	0x3403ede0
34027e08:	3403edb8 	.word	0x3403edb8
34027e0c:	9908      	ldr	r1, [sp, #32]
34027e0e:	2900      	cmp	r1, #0
34027e10:	f000 80e9 	beq.w	34027fe6 <_dtoa_r+0x7ee>
34027e14:	9907      	ldr	r1, [sp, #28]
34027e16:	2901      	cmp	r1, #1
34027e18:	f300 80cb 	bgt.w	34027fb2 <_dtoa_r+0x7ba>
34027e1c:	2d00      	cmp	r5, #0
34027e1e:	f000 80c4 	beq.w	34027faa <_dtoa_r+0x7b2>
34027e22:	f202 4233 	addw	r2, r2, #1075	@ 0x433
34027e26:	461c      	mov	r4, r3
34027e28:	9e04      	ldr	r6, [sp, #16]
34027e2a:	9305      	str	r3, [sp, #20]
34027e2c:	2101      	movs	r1, #1
34027e2e:	9b04      	ldr	r3, [sp, #16]
34027e30:	4648      	mov	r0, r9
34027e32:	4413      	add	r3, r2
34027e34:	9304      	str	r3, [sp, #16]
34027e36:	9b06      	ldr	r3, [sp, #24]
34027e38:	4413      	add	r3, r2
34027e3a:	9306      	str	r3, [sp, #24]
34027e3c:	f000 fb7a 	bl	34028534 <__i2b>
34027e40:	9b05      	ldr	r3, [sp, #20]
34027e42:	4605      	mov	r5, r0
34027e44:	b166      	cbz	r6, 34027e60 <_dtoa_r+0x668>
34027e46:	9a06      	ldr	r2, [sp, #24]
34027e48:	2a00      	cmp	r2, #0
34027e4a:	dd09      	ble.n	34027e60 <_dtoa_r+0x668>
34027e4c:	42b2      	cmp	r2, r6
34027e4e:	9904      	ldr	r1, [sp, #16]
34027e50:	bfa8      	it	ge
34027e52:	4632      	movge	r2, r6
34027e54:	1a89      	subs	r1, r1, r2
34027e56:	1ab6      	subs	r6, r6, r2
34027e58:	9104      	str	r1, [sp, #16]
34027e5a:	9906      	ldr	r1, [sp, #24]
34027e5c:	1a8a      	subs	r2, r1, r2
34027e5e:	9206      	str	r2, [sp, #24]
34027e60:	b30b      	cbz	r3, 34027ea6 <_dtoa_r+0x6ae>
34027e62:	9a08      	ldr	r2, [sp, #32]
34027e64:	2a00      	cmp	r2, #0
34027e66:	f000 80c5 	beq.w	34027ff4 <_dtoa_r+0x7fc>
34027e6a:	2c00      	cmp	r4, #0
34027e6c:	f000 80bf 	beq.w	34027fee <_dtoa_r+0x7f6>
34027e70:	4629      	mov	r1, r5
34027e72:	4622      	mov	r2, r4
34027e74:	4648      	mov	r0, r9
34027e76:	930b      	str	r3, [sp, #44]	@ 0x2c
34027e78:	f000 fc16 	bl	340286a8 <__pow5mult>
34027e7c:	9a01      	ldr	r2, [sp, #4]
34027e7e:	4601      	mov	r1, r0
34027e80:	4605      	mov	r5, r0
34027e82:	4648      	mov	r0, r9
34027e84:	f000 fb6c 	bl	34028560 <__multiply>
34027e88:	9901      	ldr	r1, [sp, #4]
34027e8a:	9005      	str	r0, [sp, #20]
34027e8c:	4648      	mov	r0, r9
34027e8e:	f000 fa9b 	bl	340283c8 <_Bfree>
34027e92:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34027e94:	1b1b      	subs	r3, r3, r4
34027e96:	f000 80b0 	beq.w	34027ffa <_dtoa_r+0x802>
34027e9a:	461a      	mov	r2, r3
34027e9c:	9905      	ldr	r1, [sp, #20]
34027e9e:	4648      	mov	r0, r9
34027ea0:	f000 fc02 	bl	340286a8 <__pow5mult>
34027ea4:	9001      	str	r0, [sp, #4]
34027ea6:	2101      	movs	r1, #1
34027ea8:	4648      	mov	r0, r9
34027eaa:	f000 fb43 	bl	34028534 <__i2b>
34027eae:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34027eb0:	4604      	mov	r4, r0
34027eb2:	2b00      	cmp	r3, #0
34027eb4:	f000 81da 	beq.w	3402826c <_dtoa_r+0xa74>
34027eb8:	461a      	mov	r2, r3
34027eba:	4601      	mov	r1, r0
34027ebc:	4648      	mov	r0, r9
34027ebe:	f000 fbf3 	bl	340286a8 <__pow5mult>
34027ec2:	9b07      	ldr	r3, [sp, #28]
34027ec4:	4604      	mov	r4, r0
34027ec6:	2b01      	cmp	r3, #1
34027ec8:	f300 80a0 	bgt.w	3402800c <_dtoa_r+0x814>
34027ecc:	9b02      	ldr	r3, [sp, #8]
34027ece:	2b00      	cmp	r3, #0
34027ed0:	f040 8096 	bne.w	34028000 <_dtoa_r+0x808>
34027ed4:	9b03      	ldr	r3, [sp, #12]
34027ed6:	f3c3 0213 	ubfx	r2, r3, #0, #20
34027eda:	2a00      	cmp	r2, #0
34027edc:	f040 8092 	bne.w	34028004 <_dtoa_r+0x80c>
34027ee0:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
34027ee4:	0d12      	lsrs	r2, r2, #20
34027ee6:	0512      	lsls	r2, r2, #20
34027ee8:	2a00      	cmp	r2, #0
34027eea:	f000 808d 	beq.w	34028008 <_dtoa_r+0x810>
34027eee:	9b04      	ldr	r3, [sp, #16]
34027ef0:	3301      	adds	r3, #1
34027ef2:	9304      	str	r3, [sp, #16]
34027ef4:	9b06      	ldr	r3, [sp, #24]
34027ef6:	3301      	adds	r3, #1
34027ef8:	9306      	str	r3, [sp, #24]
34027efa:	2301      	movs	r3, #1
34027efc:	930b      	str	r3, [sp, #44]	@ 0x2c
34027efe:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34027f00:	2b00      	cmp	r3, #0
34027f02:	f000 81b9 	beq.w	34028278 <_dtoa_r+0xa80>
34027f06:	6922      	ldr	r2, [r4, #16]
34027f08:	eb04 0282 	add.w	r2, r4, r2, lsl #2
34027f0c:	6910      	ldr	r0, [r2, #16]
34027f0e:	f000 fac5 	bl	3402849c <__hi0bits>
34027f12:	f1c0 0020 	rsb	r0, r0, #32
34027f16:	9b06      	ldr	r3, [sp, #24]
34027f18:	4418      	add	r0, r3
34027f1a:	f010 001f 	ands.w	r0, r0, #31
34027f1e:	f000 8081 	beq.w	34028024 <_dtoa_r+0x82c>
34027f22:	f1c0 0220 	rsb	r2, r0, #32
34027f26:	2a04      	cmp	r2, #4
34027f28:	dd73      	ble.n	34028012 <_dtoa_r+0x81a>
34027f2a:	f1c0 001c 	rsb	r0, r0, #28
34027f2e:	9b04      	ldr	r3, [sp, #16]
34027f30:	4403      	add	r3, r0
34027f32:	4406      	add	r6, r0
34027f34:	9304      	str	r3, [sp, #16]
34027f36:	9b06      	ldr	r3, [sp, #24]
34027f38:	4403      	add	r3, r0
34027f3a:	9306      	str	r3, [sp, #24]
34027f3c:	9b04      	ldr	r3, [sp, #16]
34027f3e:	2b00      	cmp	r3, #0
34027f40:	dd05      	ble.n	34027f4e <_dtoa_r+0x756>
34027f42:	461a      	mov	r2, r3
34027f44:	9901      	ldr	r1, [sp, #4]
34027f46:	4648      	mov	r0, r9
34027f48:	f000 fc08 	bl	3402875c <__lshift>
34027f4c:	9001      	str	r0, [sp, #4]
34027f4e:	9b06      	ldr	r3, [sp, #24]
34027f50:	2b00      	cmp	r3, #0
34027f52:	dd05      	ble.n	34027f60 <_dtoa_r+0x768>
34027f54:	4621      	mov	r1, r4
34027f56:	461a      	mov	r2, r3
34027f58:	4648      	mov	r0, r9
34027f5a:	f000 fbff 	bl	3402875c <__lshift>
34027f5e:	4604      	mov	r4, r0
34027f60:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
34027f62:	2b00      	cmp	r3, #0
34027f64:	d060      	beq.n	34028028 <_dtoa_r+0x830>
34027f66:	4621      	mov	r1, r4
34027f68:	9801      	ldr	r0, [sp, #4]
34027f6a:	f000 fc63 	bl	34028834 <__mcmp>
34027f6e:	2800      	cmp	r0, #0
34027f70:	da5a      	bge.n	34028028 <_dtoa_r+0x830>
34027f72:	f108 33ff 	add.w	r3, r8, #4294967295
34027f76:	220a      	movs	r2, #10
34027f78:	9901      	ldr	r1, [sp, #4]
34027f7a:	4648      	mov	r0, r9
34027f7c:	9305      	str	r3, [sp, #20]
34027f7e:	2300      	movs	r3, #0
34027f80:	f000 fa44 	bl	3402840c <__multadd>
34027f84:	9b08      	ldr	r3, [sp, #32]
34027f86:	9001      	str	r0, [sp, #4]
34027f88:	2b00      	cmp	r3, #0
34027f8a:	f000 8177 	beq.w	3402827c <_dtoa_r+0xa84>
34027f8e:	4629      	mov	r1, r5
34027f90:	2300      	movs	r3, #0
34027f92:	220a      	movs	r2, #10
34027f94:	4648      	mov	r0, r9
34027f96:	f000 fa39 	bl	3402840c <__multadd>
34027f9a:	f1bb 0f00 	cmp.w	fp, #0
34027f9e:	4605      	mov	r5, r0
34027fa0:	dc6e      	bgt.n	34028080 <_dtoa_r+0x888>
34027fa2:	9b07      	ldr	r3, [sp, #28]
34027fa4:	2b02      	cmp	r3, #2
34027fa6:	dc48      	bgt.n	3402803a <_dtoa_r+0x842>
34027fa8:	e06a      	b.n	34028080 <_dtoa_r+0x888>
34027faa:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
34027fac:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
34027fb0:	e739      	b.n	34027e26 <_dtoa_r+0x62e>
34027fb2:	f10a 34ff 	add.w	r4, sl, #4294967295
34027fb6:	42a3      	cmp	r3, r4
34027fb8:	db07      	blt.n	34027fca <_dtoa_r+0x7d2>
34027fba:	f1ba 0f00 	cmp.w	sl, #0
34027fbe:	eba3 0404 	sub.w	r4, r3, r4
34027fc2:	db0b      	blt.n	34027fdc <_dtoa_r+0x7e4>
34027fc4:	9e04      	ldr	r6, [sp, #16]
34027fc6:	4652      	mov	r2, sl
34027fc8:	e72f      	b.n	34027e2a <_dtoa_r+0x632>
34027fca:	1ae2      	subs	r2, r4, r3
34027fcc:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34027fce:	9e04      	ldr	r6, [sp, #16]
34027fd0:	4413      	add	r3, r2
34027fd2:	4652      	mov	r2, sl
34027fd4:	930a      	str	r3, [sp, #40]	@ 0x28
34027fd6:	4623      	mov	r3, r4
34027fd8:	2400      	movs	r4, #0
34027fda:	e726      	b.n	34027e2a <_dtoa_r+0x632>
34027fdc:	9a04      	ldr	r2, [sp, #16]
34027fde:	eba2 060a 	sub.w	r6, r2, sl
34027fe2:	2200      	movs	r2, #0
34027fe4:	e721      	b.n	34027e2a <_dtoa_r+0x632>
34027fe6:	461c      	mov	r4, r3
34027fe8:	9e04      	ldr	r6, [sp, #16]
34027fea:	9d08      	ldr	r5, [sp, #32]
34027fec:	e72a      	b.n	34027e44 <_dtoa_r+0x64c>
34027fee:	9a01      	ldr	r2, [sp, #4]
34027ff0:	9205      	str	r2, [sp, #20]
34027ff2:	e752      	b.n	34027e9a <_dtoa_r+0x6a2>
34027ff4:	461a      	mov	r2, r3
34027ff6:	9901      	ldr	r1, [sp, #4]
34027ff8:	e751      	b.n	34027e9e <_dtoa_r+0x6a6>
34027ffa:	9b05      	ldr	r3, [sp, #20]
34027ffc:	9301      	str	r3, [sp, #4]
34027ffe:	e752      	b.n	34027ea6 <_dtoa_r+0x6ae>
34028000:	2300      	movs	r3, #0
34028002:	e77b      	b.n	34027efc <_dtoa_r+0x704>
34028004:	9b02      	ldr	r3, [sp, #8]
34028006:	e779      	b.n	34027efc <_dtoa_r+0x704>
34028008:	920b      	str	r2, [sp, #44]	@ 0x2c
3402800a:	e778      	b.n	34027efe <_dtoa_r+0x706>
3402800c:	2300      	movs	r3, #0
3402800e:	930b      	str	r3, [sp, #44]	@ 0x2c
34028010:	e779      	b.n	34027f06 <_dtoa_r+0x70e>
34028012:	d093      	beq.n	34027f3c <_dtoa_r+0x744>
34028014:	321c      	adds	r2, #28
34028016:	9b04      	ldr	r3, [sp, #16]
34028018:	4413      	add	r3, r2
3402801a:	4416      	add	r6, r2
3402801c:	9304      	str	r3, [sp, #16]
3402801e:	9b06      	ldr	r3, [sp, #24]
34028020:	4413      	add	r3, r2
34028022:	e78a      	b.n	34027f3a <_dtoa_r+0x742>
34028024:	4602      	mov	r2, r0
34028026:	e7f5      	b.n	34028014 <_dtoa_r+0x81c>
34028028:	f1ba 0f00 	cmp.w	sl, #0
3402802c:	46d3      	mov	fp, sl
3402802e:	f8cd 8014 	str.w	r8, [sp, #20]
34028032:	dc21      	bgt.n	34028078 <_dtoa_r+0x880>
34028034:	9b07      	ldr	r3, [sp, #28]
34028036:	2b02      	cmp	r3, #2
34028038:	dd1e      	ble.n	34028078 <_dtoa_r+0x880>
3402803a:	f1bb 0f00 	cmp.w	fp, #0
3402803e:	f47f addc 	bne.w	34027bfa <_dtoa_r+0x402>
34028042:	4621      	mov	r1, r4
34028044:	465b      	mov	r3, fp
34028046:	2205      	movs	r2, #5
34028048:	4648      	mov	r0, r9
3402804a:	f000 f9df 	bl	3402840c <__multadd>
3402804e:	4601      	mov	r1, r0
34028050:	4604      	mov	r4, r0
34028052:	9801      	ldr	r0, [sp, #4]
34028054:	f000 fbee 	bl	34028834 <__mcmp>
34028058:	2800      	cmp	r0, #0
3402805a:	f77f adce 	ble.w	34027bfa <_dtoa_r+0x402>
3402805e:	2331      	movs	r3, #49	@ 0x31
34028060:	463e      	mov	r6, r7
34028062:	f806 3b01 	strb.w	r3, [r6], #1
34028066:	9b05      	ldr	r3, [sp, #20]
34028068:	3301      	adds	r3, #1
3402806a:	9305      	str	r3, [sp, #20]
3402806c:	e5c9      	b.n	34027c02 <_dtoa_r+0x40a>
3402806e:	4654      	mov	r4, sl
34028070:	f8cd 8014 	str.w	r8, [sp, #20]
34028074:	4625      	mov	r5, r4
34028076:	e7f2      	b.n	3402805e <_dtoa_r+0x866>
34028078:	9b08      	ldr	r3, [sp, #32]
3402807a:	2b00      	cmp	r3, #0
3402807c:	f000 8102 	beq.w	34028284 <_dtoa_r+0xa8c>
34028080:	2e00      	cmp	r6, #0
34028082:	dd05      	ble.n	34028090 <_dtoa_r+0x898>
34028084:	4629      	mov	r1, r5
34028086:	4632      	mov	r2, r6
34028088:	4648      	mov	r0, r9
3402808a:	f000 fb67 	bl	3402875c <__lshift>
3402808e:	4605      	mov	r5, r0
34028090:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
34028092:	2b00      	cmp	r3, #0
34028094:	d058      	beq.n	34028148 <_dtoa_r+0x950>
34028096:	6869      	ldr	r1, [r5, #4]
34028098:	4648      	mov	r0, r9
3402809a:	f000 f955 	bl	34028348 <_Balloc>
3402809e:	4606      	mov	r6, r0
340280a0:	b928      	cbnz	r0, 340280ae <_dtoa_r+0x8b6>
340280a2:	4b82      	ldr	r3, [pc, #520]	@ (340282ac <_dtoa_r+0xab4>)
340280a4:	4602      	mov	r2, r0
340280a6:	f240 21ef 	movw	r1, #751	@ 0x2ef
340280aa:	f7ff bbbe 	b.w	3402782a <_dtoa_r+0x32>
340280ae:	692a      	ldr	r2, [r5, #16]
340280b0:	f105 010c 	add.w	r1, r5, #12
340280b4:	300c      	adds	r0, #12
340280b6:	3202      	adds	r2, #2
340280b8:	0092      	lsls	r2, r2, #2
340280ba:	f7ff fafa 	bl	340276b2 <memcpy>
340280be:	2201      	movs	r2, #1
340280c0:	4631      	mov	r1, r6
340280c2:	4648      	mov	r0, r9
340280c4:	f000 fb4a 	bl	3402875c <__lshift>
340280c8:	1c7b      	adds	r3, r7, #1
340280ca:	46a8      	mov	r8, r5
340280cc:	4605      	mov	r5, r0
340280ce:	9304      	str	r3, [sp, #16]
340280d0:	eb07 030b 	add.w	r3, r7, fp
340280d4:	9309      	str	r3, [sp, #36]	@ 0x24
340280d6:	9b02      	ldr	r3, [sp, #8]
340280d8:	f003 0301 	and.w	r3, r3, #1
340280dc:	9308      	str	r3, [sp, #32]
340280de:	9b04      	ldr	r3, [sp, #16]
340280e0:	4621      	mov	r1, r4
340280e2:	9801      	ldr	r0, [sp, #4]
340280e4:	f103 3bff 	add.w	fp, r3, #4294967295
340280e8:	f7ff faf7 	bl	340276da <quorem>
340280ec:	4641      	mov	r1, r8
340280ee:	9002      	str	r0, [sp, #8]
340280f0:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
340280f4:	9801      	ldr	r0, [sp, #4]
340280f6:	f000 fb9d 	bl	34028834 <__mcmp>
340280fa:	462a      	mov	r2, r5
340280fc:	9006      	str	r0, [sp, #24]
340280fe:	4621      	mov	r1, r4
34028100:	4648      	mov	r0, r9
34028102:	f000 fbb3 	bl	3402886c <__mdiff>
34028106:	68c2      	ldr	r2, [r0, #12]
34028108:	4606      	mov	r6, r0
3402810a:	b9fa      	cbnz	r2, 3402814c <_dtoa_r+0x954>
3402810c:	4601      	mov	r1, r0
3402810e:	9801      	ldr	r0, [sp, #4]
34028110:	f000 fb90 	bl	34028834 <__mcmp>
34028114:	4602      	mov	r2, r0
34028116:	4631      	mov	r1, r6
34028118:	4648      	mov	r0, r9
3402811a:	920a      	str	r2, [sp, #40]	@ 0x28
3402811c:	f000 f954 	bl	340283c8 <_Bfree>
34028120:	9b07      	ldr	r3, [sp, #28]
34028122:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
34028124:	9e04      	ldr	r6, [sp, #16]
34028126:	ea42 0103 	orr.w	r1, r2, r3
3402812a:	9b08      	ldr	r3, [sp, #32]
3402812c:	4319      	orrs	r1, r3
3402812e:	d10f      	bne.n	34028150 <_dtoa_r+0x958>
34028130:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34028134:	d028      	beq.n	34028188 <_dtoa_r+0x990>
34028136:	9b06      	ldr	r3, [sp, #24]
34028138:	2b00      	cmp	r3, #0
3402813a:	dd02      	ble.n	34028142 <_dtoa_r+0x94a>
3402813c:	9b02      	ldr	r3, [sp, #8]
3402813e:	f103 0a31 	add.w	sl, r3, #49	@ 0x31
34028142:	f88b a000 	strb.w	sl, [fp]
34028146:	e55e      	b.n	34027c06 <_dtoa_r+0x40e>
34028148:	4628      	mov	r0, r5
3402814a:	e7bd      	b.n	340280c8 <_dtoa_r+0x8d0>
3402814c:	2201      	movs	r2, #1
3402814e:	e7e2      	b.n	34028116 <_dtoa_r+0x91e>
34028150:	9b06      	ldr	r3, [sp, #24]
34028152:	2b00      	cmp	r3, #0
34028154:	db04      	blt.n	34028160 <_dtoa_r+0x968>
34028156:	9907      	ldr	r1, [sp, #28]
34028158:	430b      	orrs	r3, r1
3402815a:	9908      	ldr	r1, [sp, #32]
3402815c:	430b      	orrs	r3, r1
3402815e:	d120      	bne.n	340281a2 <_dtoa_r+0x9aa>
34028160:	2a00      	cmp	r2, #0
34028162:	ddee      	ble.n	34028142 <_dtoa_r+0x94a>
34028164:	2201      	movs	r2, #1
34028166:	9901      	ldr	r1, [sp, #4]
34028168:	4648      	mov	r0, r9
3402816a:	f000 faf7 	bl	3402875c <__lshift>
3402816e:	4621      	mov	r1, r4
34028170:	9001      	str	r0, [sp, #4]
34028172:	f000 fb5f 	bl	34028834 <__mcmp>
34028176:	2800      	cmp	r0, #0
34028178:	dc03      	bgt.n	34028182 <_dtoa_r+0x98a>
3402817a:	d1e2      	bne.n	34028142 <_dtoa_r+0x94a>
3402817c:	f01a 0f01 	tst.w	sl, #1
34028180:	d0df      	beq.n	34028142 <_dtoa_r+0x94a>
34028182:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
34028186:	d1d9      	bne.n	3402813c <_dtoa_r+0x944>
34028188:	2339      	movs	r3, #57	@ 0x39
3402818a:	f88b 3000 	strb.w	r3, [fp]
3402818e:	4633      	mov	r3, r6
34028190:	461e      	mov	r6, r3
34028192:	3b01      	subs	r3, #1
34028194:	f816 2c01 	ldrb.w	r2, [r6, #-1]
34028198:	2a39      	cmp	r2, #57	@ 0x39
3402819a:	d052      	beq.n	34028242 <_dtoa_r+0xa4a>
3402819c:	3201      	adds	r2, #1
3402819e:	701a      	strb	r2, [r3, #0]
340281a0:	e531      	b.n	34027c06 <_dtoa_r+0x40e>
340281a2:	2a00      	cmp	r2, #0
340281a4:	dd07      	ble.n	340281b6 <_dtoa_r+0x9be>
340281a6:	f1ba 0f39 	cmp.w	sl, #57	@ 0x39
340281aa:	d0ed      	beq.n	34028188 <_dtoa_r+0x990>
340281ac:	f10a 0301 	add.w	r3, sl, #1
340281b0:	f88b 3000 	strb.w	r3, [fp]
340281b4:	e527      	b.n	34027c06 <_dtoa_r+0x40e>
340281b6:	9b04      	ldr	r3, [sp, #16]
340281b8:	9a09      	ldr	r2, [sp, #36]	@ 0x24
340281ba:	f803 ac01 	strb.w	sl, [r3, #-1]
340281be:	4293      	cmp	r3, r2
340281c0:	d029      	beq.n	34028216 <_dtoa_r+0xa1e>
340281c2:	2300      	movs	r3, #0
340281c4:	220a      	movs	r2, #10
340281c6:	9901      	ldr	r1, [sp, #4]
340281c8:	4648      	mov	r0, r9
340281ca:	f000 f91f 	bl	3402840c <__multadd>
340281ce:	45a8      	cmp	r8, r5
340281d0:	9001      	str	r0, [sp, #4]
340281d2:	f04f 0300 	mov.w	r3, #0
340281d6:	f04f 020a 	mov.w	r2, #10
340281da:	4641      	mov	r1, r8
340281dc:	4648      	mov	r0, r9
340281de:	d107      	bne.n	340281f0 <_dtoa_r+0x9f8>
340281e0:	f000 f914 	bl	3402840c <__multadd>
340281e4:	4680      	mov	r8, r0
340281e6:	4605      	mov	r5, r0
340281e8:	9b04      	ldr	r3, [sp, #16]
340281ea:	3301      	adds	r3, #1
340281ec:	9304      	str	r3, [sp, #16]
340281ee:	e776      	b.n	340280de <_dtoa_r+0x8e6>
340281f0:	f000 f90c 	bl	3402840c <__multadd>
340281f4:	4629      	mov	r1, r5
340281f6:	4680      	mov	r8, r0
340281f8:	2300      	movs	r3, #0
340281fa:	220a      	movs	r2, #10
340281fc:	4648      	mov	r0, r9
340281fe:	f000 f905 	bl	3402840c <__multadd>
34028202:	4605      	mov	r5, r0
34028204:	e7f0      	b.n	340281e8 <_dtoa_r+0x9f0>
34028206:	f1bb 0f00 	cmp.w	fp, #0
3402820a:	f04f 0800 	mov.w	r8, #0
3402820e:	bfcc      	ite	gt
34028210:	465e      	movgt	r6, fp
34028212:	2601      	movle	r6, #1
34028214:	443e      	add	r6, r7
34028216:	2201      	movs	r2, #1
34028218:	9901      	ldr	r1, [sp, #4]
3402821a:	4648      	mov	r0, r9
3402821c:	f000 fa9e 	bl	3402875c <__lshift>
34028220:	4621      	mov	r1, r4
34028222:	9001      	str	r0, [sp, #4]
34028224:	f000 fb06 	bl	34028834 <__mcmp>
34028228:	2800      	cmp	r0, #0
3402822a:	dcb0      	bgt.n	3402818e <_dtoa_r+0x996>
3402822c:	d102      	bne.n	34028234 <_dtoa_r+0xa3c>
3402822e:	f01a 0f01 	tst.w	sl, #1
34028232:	d1ac      	bne.n	3402818e <_dtoa_r+0x996>
34028234:	4633      	mov	r3, r6
34028236:	461e      	mov	r6, r3
34028238:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
3402823c:	2a30      	cmp	r2, #48	@ 0x30
3402823e:	d0fa      	beq.n	34028236 <_dtoa_r+0xa3e>
34028240:	e4e1      	b.n	34027c06 <_dtoa_r+0x40e>
34028242:	429f      	cmp	r7, r3
34028244:	d1a4      	bne.n	34028190 <_dtoa_r+0x998>
34028246:	9b05      	ldr	r3, [sp, #20]
34028248:	3301      	adds	r3, #1
3402824a:	9305      	str	r3, [sp, #20]
3402824c:	2331      	movs	r3, #49	@ 0x31
3402824e:	703b      	strb	r3, [r7, #0]
34028250:	e4d9      	b.n	34027c06 <_dtoa_r+0x40e>
34028252:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
34028254:	4f16      	ldr	r7, [pc, #88]	@ (340282b0 <_dtoa_r+0xab8>)
34028256:	b11b      	cbz	r3, 34028260 <_dtoa_r+0xa68>
34028258:	f107 0308 	add.w	r3, r7, #8
3402825c:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
3402825e:	6013      	str	r3, [r2, #0]
34028260:	4638      	mov	r0, r7
34028262:	b011      	add	sp, #68	@ 0x44
34028264:	ecbd 8b02 	vpop	{d8}
34028268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
3402826c:	9b07      	ldr	r3, [sp, #28]
3402826e:	2b01      	cmp	r3, #1
34028270:	f77f ae2c 	ble.w	34027ecc <_dtoa_r+0x6d4>
34028274:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
34028276:	930b      	str	r3, [sp, #44]	@ 0x2c
34028278:	2001      	movs	r0, #1
3402827a:	e64c      	b.n	34027f16 <_dtoa_r+0x71e>
3402827c:	f1bb 0f00 	cmp.w	fp, #0
34028280:	f77f aed8 	ble.w	34028034 <_dtoa_r+0x83c>
34028284:	463e      	mov	r6, r7
34028286:	4621      	mov	r1, r4
34028288:	9801      	ldr	r0, [sp, #4]
3402828a:	f7ff fa26 	bl	340276da <quorem>
3402828e:	f100 0a30 	add.w	sl, r0, #48	@ 0x30
34028292:	f806 ab01 	strb.w	sl, [r6], #1
34028296:	1bf2      	subs	r2, r6, r7
34028298:	4593      	cmp	fp, r2
3402829a:	ddb4      	ble.n	34028206 <_dtoa_r+0xa0e>
3402829c:	2300      	movs	r3, #0
3402829e:	220a      	movs	r2, #10
340282a0:	9901      	ldr	r1, [sp, #4]
340282a2:	4648      	mov	r0, r9
340282a4:	f000 f8b2 	bl	3402840c <__multadd>
340282a8:	9001      	str	r0, [sp, #4]
340282aa:	e7ec      	b.n	34028286 <_dtoa_r+0xa8e>
340282ac:	3403ed27 	.word	0x3403ed27
340282b0:	3403ecab 	.word	0x3403ecab

340282b4 <_free_r>:
340282b4:	b538      	push	{r3, r4, r5, lr}
340282b6:	4605      	mov	r5, r0
340282b8:	2900      	cmp	r1, #0
340282ba:	d041      	beq.n	34028340 <_free_r+0x8c>
340282bc:	f851 3c04 	ldr.w	r3, [r1, #-4]
340282c0:	1f0c      	subs	r4, r1, #4
340282c2:	2b00      	cmp	r3, #0
340282c4:	bfb8      	it	lt
340282c6:	18e4      	addlt	r4, r4, r3
340282c8:	f7fd fe16 	bl	34025ef8 <__malloc_lock>
340282cc:	4a1d      	ldr	r2, [pc, #116]	@ (34028344 <_free_r+0x90>)
340282ce:	6813      	ldr	r3, [r2, #0]
340282d0:	b933      	cbnz	r3, 340282e0 <_free_r+0x2c>
340282d2:	6063      	str	r3, [r4, #4]
340282d4:	6014      	str	r4, [r2, #0]
340282d6:	4628      	mov	r0, r5
340282d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
340282dc:	f7fd be12 	b.w	34025f04 <__malloc_unlock>
340282e0:	42a3      	cmp	r3, r4
340282e2:	d908      	bls.n	340282f6 <_free_r+0x42>
340282e4:	6820      	ldr	r0, [r4, #0]
340282e6:	1821      	adds	r1, r4, r0
340282e8:	428b      	cmp	r3, r1
340282ea:	bf01      	itttt	eq
340282ec:	6819      	ldreq	r1, [r3, #0]
340282ee:	685b      	ldreq	r3, [r3, #4]
340282f0:	1809      	addeq	r1, r1, r0
340282f2:	6021      	streq	r1, [r4, #0]
340282f4:	e7ed      	b.n	340282d2 <_free_r+0x1e>
340282f6:	461a      	mov	r2, r3
340282f8:	685b      	ldr	r3, [r3, #4]
340282fa:	b10b      	cbz	r3, 34028300 <_free_r+0x4c>
340282fc:	42a3      	cmp	r3, r4
340282fe:	d9fa      	bls.n	340282f6 <_free_r+0x42>
34028300:	6811      	ldr	r1, [r2, #0]
34028302:	1850      	adds	r0, r2, r1
34028304:	42a0      	cmp	r0, r4
34028306:	d10b      	bne.n	34028320 <_free_r+0x6c>
34028308:	6820      	ldr	r0, [r4, #0]
3402830a:	4401      	add	r1, r0
3402830c:	1850      	adds	r0, r2, r1
3402830e:	6011      	str	r1, [r2, #0]
34028310:	4283      	cmp	r3, r0
34028312:	d1e0      	bne.n	340282d6 <_free_r+0x22>
34028314:	6818      	ldr	r0, [r3, #0]
34028316:	685b      	ldr	r3, [r3, #4]
34028318:	4408      	add	r0, r1
3402831a:	6053      	str	r3, [r2, #4]
3402831c:	6010      	str	r0, [r2, #0]
3402831e:	e7da      	b.n	340282d6 <_free_r+0x22>
34028320:	d902      	bls.n	34028328 <_free_r+0x74>
34028322:	230c      	movs	r3, #12
34028324:	602b      	str	r3, [r5, #0]
34028326:	e7d6      	b.n	340282d6 <_free_r+0x22>
34028328:	6820      	ldr	r0, [r4, #0]
3402832a:	1821      	adds	r1, r4, r0
3402832c:	428b      	cmp	r3, r1
3402832e:	bf02      	ittt	eq
34028330:	6819      	ldreq	r1, [r3, #0]
34028332:	685b      	ldreq	r3, [r3, #4]
34028334:	1809      	addeq	r1, r1, r0
34028336:	6063      	str	r3, [r4, #4]
34028338:	bf08      	it	eq
3402833a:	6021      	streq	r1, [r4, #0]
3402833c:	6054      	str	r4, [r2, #4]
3402833e:	e7ca      	b.n	340282d6 <_free_r+0x22>
34028340:	bd38      	pop	{r3, r4, r5, pc}
34028342:	bf00      	nop
34028344:	340566b0 	.word	0x340566b0

34028348 <_Balloc>:
34028348:	b570      	push	{r4, r5, r6, lr}
3402834a:	69c6      	ldr	r6, [r0, #28]
3402834c:	4604      	mov	r4, r0
3402834e:	460d      	mov	r5, r1
34028350:	b976      	cbnz	r6, 34028370 <_Balloc+0x28>
34028352:	2010      	movs	r0, #16
34028354:	f7fd fd26 	bl	34025da4 <malloc>
34028358:	4602      	mov	r2, r0
3402835a:	61e0      	str	r0, [r4, #28]
3402835c:	b920      	cbnz	r0, 34028368 <_Balloc+0x20>
3402835e:	4b18      	ldr	r3, [pc, #96]	@ (340283c0 <_Balloc+0x78>)
34028360:	216b      	movs	r1, #107	@ 0x6b
34028362:	4818      	ldr	r0, [pc, #96]	@ (340283c4 <_Balloc+0x7c>)
34028364:	f7fd fd00 	bl	34025d68 <__assert_func>
34028368:	e9c0 6601 	strd	r6, r6, [r0, #4]
3402836c:	6006      	str	r6, [r0, #0]
3402836e:	60c6      	str	r6, [r0, #12]
34028370:	69e6      	ldr	r6, [r4, #28]
34028372:	68f3      	ldr	r3, [r6, #12]
34028374:	b183      	cbz	r3, 34028398 <_Balloc+0x50>
34028376:	69e3      	ldr	r3, [r4, #28]
34028378:	68db      	ldr	r3, [r3, #12]
3402837a:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
3402837e:	b9b8      	cbnz	r0, 340283b0 <_Balloc+0x68>
34028380:	2101      	movs	r1, #1
34028382:	4620      	mov	r0, r4
34028384:	fa01 f605 	lsl.w	r6, r1, r5
34028388:	1d72      	adds	r2, r6, #5
3402838a:	0092      	lsls	r2, r2, #2
3402838c:	f000 ff74 	bl	34029278 <_calloc_r>
34028390:	b160      	cbz	r0, 340283ac <_Balloc+0x64>
34028392:	e9c0 5601 	strd	r5, r6, [r0, #4]
34028396:	e00e      	b.n	340283b6 <_Balloc+0x6e>
34028398:	2221      	movs	r2, #33	@ 0x21
3402839a:	2104      	movs	r1, #4
3402839c:	4620      	mov	r0, r4
3402839e:	f000 ff6b 	bl	34029278 <_calloc_r>
340283a2:	69e3      	ldr	r3, [r4, #28]
340283a4:	60f0      	str	r0, [r6, #12]
340283a6:	68db      	ldr	r3, [r3, #12]
340283a8:	2b00      	cmp	r3, #0
340283aa:	d1e4      	bne.n	34028376 <_Balloc+0x2e>
340283ac:	2000      	movs	r0, #0
340283ae:	bd70      	pop	{r4, r5, r6, pc}
340283b0:	6802      	ldr	r2, [r0, #0]
340283b2:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
340283b6:	2300      	movs	r3, #0
340283b8:	e9c0 3303 	strd	r3, r3, [r0, #12]
340283bc:	e7f7      	b.n	340283ae <_Balloc+0x66>
340283be:	bf00      	nop
340283c0:	3403ecb8 	.word	0x3403ecb8
340283c4:	3403ed38 	.word	0x3403ed38

340283c8 <_Bfree>:
340283c8:	b570      	push	{r4, r5, r6, lr}
340283ca:	69c6      	ldr	r6, [r0, #28]
340283cc:	4605      	mov	r5, r0
340283ce:	460c      	mov	r4, r1
340283d0:	b976      	cbnz	r6, 340283f0 <_Bfree+0x28>
340283d2:	2010      	movs	r0, #16
340283d4:	f7fd fce6 	bl	34025da4 <malloc>
340283d8:	4602      	mov	r2, r0
340283da:	61e8      	str	r0, [r5, #28]
340283dc:	b920      	cbnz	r0, 340283e8 <_Bfree+0x20>
340283de:	4b09      	ldr	r3, [pc, #36]	@ (34028404 <_Bfree+0x3c>)
340283e0:	218f      	movs	r1, #143	@ 0x8f
340283e2:	4809      	ldr	r0, [pc, #36]	@ (34028408 <_Bfree+0x40>)
340283e4:	f7fd fcc0 	bl	34025d68 <__assert_func>
340283e8:	e9c0 6601 	strd	r6, r6, [r0, #4]
340283ec:	6006      	str	r6, [r0, #0]
340283ee:	60c6      	str	r6, [r0, #12]
340283f0:	b13c      	cbz	r4, 34028402 <_Bfree+0x3a>
340283f2:	69eb      	ldr	r3, [r5, #28]
340283f4:	6862      	ldr	r2, [r4, #4]
340283f6:	68db      	ldr	r3, [r3, #12]
340283f8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
340283fc:	6021      	str	r1, [r4, #0]
340283fe:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
34028402:	bd70      	pop	{r4, r5, r6, pc}
34028404:	3403ecb8 	.word	0x3403ecb8
34028408:	3403ed38 	.word	0x3403ed38

3402840c <__multadd>:
3402840c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34028410:	f101 0c14 	add.w	ip, r1, #20
34028414:	4607      	mov	r7, r0
34028416:	460c      	mov	r4, r1
34028418:	461e      	mov	r6, r3
3402841a:	690d      	ldr	r5, [r1, #16]
3402841c:	2000      	movs	r0, #0
3402841e:	f8dc 3000 	ldr.w	r3, [ip]
34028422:	3001      	adds	r0, #1
34028424:	b299      	uxth	r1, r3
34028426:	4285      	cmp	r5, r0
34028428:	fb02 6101 	mla	r1, r2, r1, r6
3402842c:	ea4f 4613 	mov.w	r6, r3, lsr #16
34028430:	ea4f 4311 	mov.w	r3, r1, lsr #16
34028434:	b289      	uxth	r1, r1
34028436:	fb02 3306 	mla	r3, r2, r6, r3
3402843a:	eb01 4103 	add.w	r1, r1, r3, lsl #16
3402843e:	ea4f 4613 	mov.w	r6, r3, lsr #16
34028442:	f84c 1b04 	str.w	r1, [ip], #4
34028446:	dcea      	bgt.n	3402841e <__multadd+0x12>
34028448:	b30e      	cbz	r6, 3402848e <__multadd+0x82>
3402844a:	68a3      	ldr	r3, [r4, #8]
3402844c:	42ab      	cmp	r3, r5
3402844e:	dc19      	bgt.n	34028484 <__multadd+0x78>
34028450:	6861      	ldr	r1, [r4, #4]
34028452:	4638      	mov	r0, r7
34028454:	3101      	adds	r1, #1
34028456:	f7ff ff77 	bl	34028348 <_Balloc>
3402845a:	4680      	mov	r8, r0
3402845c:	b928      	cbnz	r0, 3402846a <__multadd+0x5e>
3402845e:	4602      	mov	r2, r0
34028460:	4b0c      	ldr	r3, [pc, #48]	@ (34028494 <__multadd+0x88>)
34028462:	21ba      	movs	r1, #186	@ 0xba
34028464:	480c      	ldr	r0, [pc, #48]	@ (34028498 <__multadd+0x8c>)
34028466:	f7fd fc7f 	bl	34025d68 <__assert_func>
3402846a:	6922      	ldr	r2, [r4, #16]
3402846c:	f104 010c 	add.w	r1, r4, #12
34028470:	300c      	adds	r0, #12
34028472:	3202      	adds	r2, #2
34028474:	0092      	lsls	r2, r2, #2
34028476:	f7ff f91c 	bl	340276b2 <memcpy>
3402847a:	4621      	mov	r1, r4
3402847c:	4644      	mov	r4, r8
3402847e:	4638      	mov	r0, r7
34028480:	f7ff ffa2 	bl	340283c8 <_Bfree>
34028484:	eb04 0385 	add.w	r3, r4, r5, lsl #2
34028488:	3501      	adds	r5, #1
3402848a:	615e      	str	r6, [r3, #20]
3402848c:	6125      	str	r5, [r4, #16]
3402848e:	4620      	mov	r0, r4
34028490:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
34028494:	3403ed27 	.word	0x3403ed27
34028498:	3403ed38 	.word	0x3403ed38

3402849c <__hi0bits>:
3402849c:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
340284a0:	4603      	mov	r3, r0
340284a2:	bf36      	itet	cc
340284a4:	0403      	lslcc	r3, r0, #16
340284a6:	2000      	movcs	r0, #0
340284a8:	2010      	movcc	r0, #16
340284aa:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340284ae:	bf3c      	itt	cc
340284b0:	021b      	lslcc	r3, r3, #8
340284b2:	3008      	addcc	r0, #8
340284b4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340284b8:	bf3c      	itt	cc
340284ba:	011b      	lslcc	r3, r3, #4
340284bc:	3004      	addcc	r0, #4
340284be:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
340284c2:	bf3c      	itt	cc
340284c4:	009b      	lslcc	r3, r3, #2
340284c6:	3002      	addcc	r0, #2
340284c8:	2b00      	cmp	r3, #0
340284ca:	db05      	blt.n	340284d8 <__hi0bits+0x3c>
340284cc:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
340284d0:	f100 0001 	add.w	r0, r0, #1
340284d4:	bf08      	it	eq
340284d6:	2020      	moveq	r0, #32
340284d8:	4770      	bx	lr

340284da <__lo0bits>:
340284da:	6803      	ldr	r3, [r0, #0]
340284dc:	4602      	mov	r2, r0
340284de:	f013 0007 	ands.w	r0, r3, #7
340284e2:	d00b      	beq.n	340284fc <__lo0bits+0x22>
340284e4:	07d9      	lsls	r1, r3, #31
340284e6:	d421      	bmi.n	3402852c <__lo0bits+0x52>
340284e8:	0798      	lsls	r0, r3, #30
340284ea:	bf47      	ittee	mi
340284ec:	085b      	lsrmi	r3, r3, #1
340284ee:	2001      	movmi	r0, #1
340284f0:	089b      	lsrpl	r3, r3, #2
340284f2:	2002      	movpl	r0, #2
340284f4:	bf4c      	ite	mi
340284f6:	6013      	strmi	r3, [r2, #0]
340284f8:	6013      	strpl	r3, [r2, #0]
340284fa:	4770      	bx	lr
340284fc:	b299      	uxth	r1, r3
340284fe:	b909      	cbnz	r1, 34028504 <__lo0bits+0x2a>
34028500:	0c1b      	lsrs	r3, r3, #16
34028502:	2010      	movs	r0, #16
34028504:	b2d9      	uxtb	r1, r3
34028506:	b909      	cbnz	r1, 3402850c <__lo0bits+0x32>
34028508:	3008      	adds	r0, #8
3402850a:	0a1b      	lsrs	r3, r3, #8
3402850c:	0719      	lsls	r1, r3, #28
3402850e:	bf04      	itt	eq
34028510:	091b      	lsreq	r3, r3, #4
34028512:	3004      	addeq	r0, #4
34028514:	0799      	lsls	r1, r3, #30
34028516:	bf04      	itt	eq
34028518:	089b      	lsreq	r3, r3, #2
3402851a:	3002      	addeq	r0, #2
3402851c:	07d9      	lsls	r1, r3, #31
3402851e:	d403      	bmi.n	34028528 <__lo0bits+0x4e>
34028520:	085b      	lsrs	r3, r3, #1
34028522:	f100 0001 	add.w	r0, r0, #1
34028526:	d003      	beq.n	34028530 <__lo0bits+0x56>
34028528:	6013      	str	r3, [r2, #0]
3402852a:	4770      	bx	lr
3402852c:	2000      	movs	r0, #0
3402852e:	4770      	bx	lr
34028530:	2020      	movs	r0, #32
34028532:	4770      	bx	lr

34028534 <__i2b>:
34028534:	b510      	push	{r4, lr}
34028536:	460c      	mov	r4, r1
34028538:	2101      	movs	r1, #1
3402853a:	f7ff ff05 	bl	34028348 <_Balloc>
3402853e:	4602      	mov	r2, r0
34028540:	b928      	cbnz	r0, 3402854e <__i2b+0x1a>
34028542:	4b05      	ldr	r3, [pc, #20]	@ (34028558 <__i2b+0x24>)
34028544:	f240 1145 	movw	r1, #325	@ 0x145
34028548:	4804      	ldr	r0, [pc, #16]	@ (3402855c <__i2b+0x28>)
3402854a:	f7fd fc0d 	bl	34025d68 <__assert_func>
3402854e:	2301      	movs	r3, #1
34028550:	6144      	str	r4, [r0, #20]
34028552:	6103      	str	r3, [r0, #16]
34028554:	bd10      	pop	{r4, pc}
34028556:	bf00      	nop
34028558:	3403ed27 	.word	0x3403ed27
3402855c:	3403ed38 	.word	0x3403ed38

34028560 <__multiply>:
34028560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34028564:	4617      	mov	r7, r2
34028566:	690a      	ldr	r2, [r1, #16]
34028568:	4689      	mov	r9, r1
3402856a:	b085      	sub	sp, #20
3402856c:	693b      	ldr	r3, [r7, #16]
3402856e:	429a      	cmp	r2, r3
34028570:	bfa2      	ittt	ge
34028572:	463b      	movge	r3, r7
34028574:	460f      	movge	r7, r1
34028576:	4699      	movge	r9, r3
34028578:	693d      	ldr	r5, [r7, #16]
3402857a:	68bb      	ldr	r3, [r7, #8]
3402857c:	f8d9 a010 	ldr.w	sl, [r9, #16]
34028580:	6879      	ldr	r1, [r7, #4]
34028582:	eb05 060a 	add.w	r6, r5, sl
34028586:	42b3      	cmp	r3, r6
34028588:	bfb8      	it	lt
3402858a:	3101      	addlt	r1, #1
3402858c:	f7ff fedc 	bl	34028348 <_Balloc>
34028590:	b930      	cbnz	r0, 340285a0 <__multiply+0x40>
34028592:	4602      	mov	r2, r0
34028594:	4b42      	ldr	r3, [pc, #264]	@ (340286a0 <__multiply+0x140>)
34028596:	f44f 71b1 	mov.w	r1, #354	@ 0x162
3402859a:	4842      	ldr	r0, [pc, #264]	@ (340286a4 <__multiply+0x144>)
3402859c:	f7fd fbe4 	bl	34025d68 <__assert_func>
340285a0:	f100 0414 	add.w	r4, r0, #20
340285a4:	2200      	movs	r2, #0
340285a6:	eb04 0e86 	add.w	lr, r4, r6, lsl #2
340285aa:	4623      	mov	r3, r4
340285ac:	4573      	cmp	r3, lr
340285ae:	d320      	bcc.n	340285f2 <__multiply+0x92>
340285b0:	f107 0814 	add.w	r8, r7, #20
340285b4:	f109 0114 	add.w	r1, r9, #20
340285b8:	eb08 0585 	add.w	r5, r8, r5, lsl #2
340285bc:	eb01 038a 	add.w	r3, r1, sl, lsl #2
340285c0:	9302      	str	r3, [sp, #8]
340285c2:	1beb      	subs	r3, r5, r7
340285c4:	3715      	adds	r7, #21
340285c6:	3b15      	subs	r3, #21
340285c8:	f023 0303 	bic.w	r3, r3, #3
340285cc:	3304      	adds	r3, #4
340285ce:	42bd      	cmp	r5, r7
340285d0:	bf38      	it	cc
340285d2:	2304      	movcc	r3, #4
340285d4:	9301      	str	r3, [sp, #4]
340285d6:	9b02      	ldr	r3, [sp, #8]
340285d8:	9103      	str	r1, [sp, #12]
340285da:	428b      	cmp	r3, r1
340285dc:	d80c      	bhi.n	340285f8 <__multiply+0x98>
340285de:	2e00      	cmp	r6, #0
340285e0:	dd03      	ble.n	340285ea <__multiply+0x8a>
340285e2:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
340285e6:	2b00      	cmp	r3, #0
340285e8:	d057      	beq.n	3402869a <__multiply+0x13a>
340285ea:	6106      	str	r6, [r0, #16]
340285ec:	b005      	add	sp, #20
340285ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340285f2:	f843 2b04 	str.w	r2, [r3], #4
340285f6:	e7d9      	b.n	340285ac <__multiply+0x4c>
340285f8:	f8b1 a000 	ldrh.w	sl, [r1]
340285fc:	f1ba 0f00 	cmp.w	sl, #0
34028600:	d021      	beq.n	34028646 <__multiply+0xe6>
34028602:	46c4      	mov	ip, r8
34028604:	46a1      	mov	r9, r4
34028606:	2700      	movs	r7, #0
34028608:	f85c 2b04 	ldr.w	r2, [ip], #4
3402860c:	f8d9 3000 	ldr.w	r3, [r9]
34028610:	fa1f fb82 	uxth.w	fp, r2
34028614:	4565      	cmp	r5, ip
34028616:	b29b      	uxth	r3, r3
34028618:	ea4f 4212 	mov.w	r2, r2, lsr #16
3402861c:	fb0a 330b 	mla	r3, sl, fp, r3
34028620:	443b      	add	r3, r7
34028622:	f8d9 7000 	ldr.w	r7, [r9]
34028626:	ea4f 4717 	mov.w	r7, r7, lsr #16
3402862a:	fb0a 7202 	mla	r2, sl, r2, r7
3402862e:	eb02 4213 	add.w	r2, r2, r3, lsr #16
34028632:	b29b      	uxth	r3, r3
34028634:	ea4f 4712 	mov.w	r7, r2, lsr #16
34028638:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
3402863c:	f849 3b04 	str.w	r3, [r9], #4
34028640:	d8e2      	bhi.n	34028608 <__multiply+0xa8>
34028642:	9b01      	ldr	r3, [sp, #4]
34028644:	50e7      	str	r7, [r4, r3]
34028646:	9b03      	ldr	r3, [sp, #12]
34028648:	3104      	adds	r1, #4
3402864a:	f8b3 9002 	ldrh.w	r9, [r3, #2]
3402864e:	f1b9 0f00 	cmp.w	r9, #0
34028652:	d020      	beq.n	34028696 <__multiply+0x136>
34028654:	6823      	ldr	r3, [r4, #0]
34028656:	4647      	mov	r7, r8
34028658:	46a4      	mov	ip, r4
3402865a:	f04f 0a00 	mov.w	sl, #0
3402865e:	f8b7 b000 	ldrh.w	fp, [r7]
34028662:	b29b      	uxth	r3, r3
34028664:	f8bc 2002 	ldrh.w	r2, [ip, #2]
34028668:	fb09 220b 	mla	r2, r9, fp, r2
3402866c:	4452      	add	r2, sl
3402866e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
34028672:	f84c 3b04 	str.w	r3, [ip], #4
34028676:	f857 3b04 	ldr.w	r3, [r7], #4
3402867a:	ea4f 4a13 	mov.w	sl, r3, lsr #16
3402867e:	f8bc 3000 	ldrh.w	r3, [ip]
34028682:	42bd      	cmp	r5, r7
34028684:	fb09 330a 	mla	r3, r9, sl, r3
34028688:	eb03 4312 	add.w	r3, r3, r2, lsr #16
3402868c:	ea4f 4a13 	mov.w	sl, r3, lsr #16
34028690:	d8e5      	bhi.n	3402865e <__multiply+0xfe>
34028692:	9a01      	ldr	r2, [sp, #4]
34028694:	50a3      	str	r3, [r4, r2]
34028696:	3404      	adds	r4, #4
34028698:	e79d      	b.n	340285d6 <__multiply+0x76>
3402869a:	3e01      	subs	r6, #1
3402869c:	e79f      	b.n	340285de <__multiply+0x7e>
3402869e:	bf00      	nop
340286a0:	3403ed27 	.word	0x3403ed27
340286a4:	3403ed38 	.word	0x3403ed38

340286a8 <__pow5mult>:
340286a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
340286ac:	4615      	mov	r5, r2
340286ae:	f012 0203 	ands.w	r2, r2, #3
340286b2:	4607      	mov	r7, r0
340286b4:	460e      	mov	r6, r1
340286b6:	d007      	beq.n	340286c8 <__pow5mult+0x20>
340286b8:	3a01      	subs	r2, #1
340286ba:	4c25      	ldr	r4, [pc, #148]	@ (34028750 <__pow5mult+0xa8>)
340286bc:	2300      	movs	r3, #0
340286be:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
340286c2:	f7ff fea3 	bl	3402840c <__multadd>
340286c6:	4606      	mov	r6, r0
340286c8:	10ad      	asrs	r5, r5, #2
340286ca:	d03d      	beq.n	34028748 <__pow5mult+0xa0>
340286cc:	69fc      	ldr	r4, [r7, #28]
340286ce:	b97c      	cbnz	r4, 340286f0 <__pow5mult+0x48>
340286d0:	2010      	movs	r0, #16
340286d2:	f7fd fb67 	bl	34025da4 <malloc>
340286d6:	4602      	mov	r2, r0
340286d8:	61f8      	str	r0, [r7, #28]
340286da:	b928      	cbnz	r0, 340286e8 <__pow5mult+0x40>
340286dc:	4b1d      	ldr	r3, [pc, #116]	@ (34028754 <__pow5mult+0xac>)
340286de:	f240 11b3 	movw	r1, #435	@ 0x1b3
340286e2:	481d      	ldr	r0, [pc, #116]	@ (34028758 <__pow5mult+0xb0>)
340286e4:	f7fd fb40 	bl	34025d68 <__assert_func>
340286e8:	e9c0 4401 	strd	r4, r4, [r0, #4]
340286ec:	6004      	str	r4, [r0, #0]
340286ee:	60c4      	str	r4, [r0, #12]
340286f0:	f8d7 801c 	ldr.w	r8, [r7, #28]
340286f4:	f8d8 4008 	ldr.w	r4, [r8, #8]
340286f8:	b94c      	cbnz	r4, 3402870e <__pow5mult+0x66>
340286fa:	f240 2171 	movw	r1, #625	@ 0x271
340286fe:	4638      	mov	r0, r7
34028700:	f7ff ff18 	bl	34028534 <__i2b>
34028704:	2300      	movs	r3, #0
34028706:	4604      	mov	r4, r0
34028708:	f8c8 0008 	str.w	r0, [r8, #8]
3402870c:	6003      	str	r3, [r0, #0]
3402870e:	f04f 0900 	mov.w	r9, #0
34028712:	07eb      	lsls	r3, r5, #31
34028714:	d50a      	bpl.n	3402872c <__pow5mult+0x84>
34028716:	4631      	mov	r1, r6
34028718:	4622      	mov	r2, r4
3402871a:	4638      	mov	r0, r7
3402871c:	f7ff ff20 	bl	34028560 <__multiply>
34028720:	4680      	mov	r8, r0
34028722:	4631      	mov	r1, r6
34028724:	4638      	mov	r0, r7
34028726:	4646      	mov	r6, r8
34028728:	f7ff fe4e 	bl	340283c8 <_Bfree>
3402872c:	106d      	asrs	r5, r5, #1
3402872e:	d00b      	beq.n	34028748 <__pow5mult+0xa0>
34028730:	6820      	ldr	r0, [r4, #0]
34028732:	b938      	cbnz	r0, 34028744 <__pow5mult+0x9c>
34028734:	4622      	mov	r2, r4
34028736:	4621      	mov	r1, r4
34028738:	4638      	mov	r0, r7
3402873a:	f7ff ff11 	bl	34028560 <__multiply>
3402873e:	6020      	str	r0, [r4, #0]
34028740:	f8c0 9000 	str.w	r9, [r0]
34028744:	4604      	mov	r4, r0
34028746:	e7e4      	b.n	34028712 <__pow5mult+0x6a>
34028748:	4630      	mov	r0, r6
3402874a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
3402874e:	bf00      	nop
34028750:	3403edac 	.word	0x3403edac
34028754:	3403ecb8 	.word	0x3403ecb8
34028758:	3403ed38 	.word	0x3403ed38

3402875c <__lshift>:
3402875c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34028760:	460c      	mov	r4, r1
34028762:	4607      	mov	r7, r0
34028764:	4691      	mov	r9, r2
34028766:	ea4f 1a62 	mov.w	sl, r2, asr #5
3402876a:	6923      	ldr	r3, [r4, #16]
3402876c:	6849      	ldr	r1, [r1, #4]
3402876e:	eb03 1862 	add.w	r8, r3, r2, asr #5
34028772:	68a3      	ldr	r3, [r4, #8]
34028774:	f108 0601 	add.w	r6, r8, #1
34028778:	42b3      	cmp	r3, r6
3402877a:	db0b      	blt.n	34028794 <__lshift+0x38>
3402877c:	4638      	mov	r0, r7
3402877e:	f7ff fde3 	bl	34028348 <_Balloc>
34028782:	4605      	mov	r5, r0
34028784:	b948      	cbnz	r0, 3402879a <__lshift+0x3e>
34028786:	4602      	mov	r2, r0
34028788:	4b28      	ldr	r3, [pc, #160]	@ (3402882c <__lshift+0xd0>)
3402878a:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
3402878e:	4828      	ldr	r0, [pc, #160]	@ (34028830 <__lshift+0xd4>)
34028790:	f7fd faea 	bl	34025d68 <__assert_func>
34028794:	3101      	adds	r1, #1
34028796:	005b      	lsls	r3, r3, #1
34028798:	e7ee      	b.n	34028778 <__lshift+0x1c>
3402879a:	2300      	movs	r3, #0
3402879c:	f100 0114 	add.w	r1, r0, #20
340287a0:	f100 0210 	add.w	r2, r0, #16
340287a4:	4618      	mov	r0, r3
340287a6:	4553      	cmp	r3, sl
340287a8:	db33      	blt.n	34028812 <__lshift+0xb6>
340287aa:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
340287ae:	f104 0314 	add.w	r3, r4, #20
340287b2:	6920      	ldr	r0, [r4, #16]
340287b4:	f019 091f 	ands.w	r9, r9, #31
340287b8:	eb01 018a 	add.w	r1, r1, sl, lsl #2
340287bc:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
340287c0:	d02b      	beq.n	3402881a <__lshift+0xbe>
340287c2:	f1c9 0e20 	rsb	lr, r9, #32
340287c6:	468a      	mov	sl, r1
340287c8:	2200      	movs	r2, #0
340287ca:	6818      	ldr	r0, [r3, #0]
340287cc:	fa00 f009 	lsl.w	r0, r0, r9
340287d0:	4310      	orrs	r0, r2
340287d2:	f84a 0b04 	str.w	r0, [sl], #4
340287d6:	f853 2b04 	ldr.w	r2, [r3], #4
340287da:	459c      	cmp	ip, r3
340287dc:	fa22 f20e 	lsr.w	r2, r2, lr
340287e0:	d8f3      	bhi.n	340287ca <__lshift+0x6e>
340287e2:	ebac 0304 	sub.w	r3, ip, r4
340287e6:	f104 0015 	add.w	r0, r4, #21
340287ea:	3b15      	subs	r3, #21
340287ec:	f023 0303 	bic.w	r3, r3, #3
340287f0:	3304      	adds	r3, #4
340287f2:	4560      	cmp	r0, ip
340287f4:	bf88      	it	hi
340287f6:	2304      	movhi	r3, #4
340287f8:	50ca      	str	r2, [r1, r3]
340287fa:	b10a      	cbz	r2, 34028800 <__lshift+0xa4>
340287fc:	f108 0602 	add.w	r6, r8, #2
34028800:	3e01      	subs	r6, #1
34028802:	4638      	mov	r0, r7
34028804:	4621      	mov	r1, r4
34028806:	612e      	str	r6, [r5, #16]
34028808:	f7ff fdde 	bl	340283c8 <_Bfree>
3402880c:	4628      	mov	r0, r5
3402880e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34028812:	3301      	adds	r3, #1
34028814:	f842 0f04 	str.w	r0, [r2, #4]!
34028818:	e7c5      	b.n	340287a6 <__lshift+0x4a>
3402881a:	3904      	subs	r1, #4
3402881c:	f853 2b04 	ldr.w	r2, [r3], #4
34028820:	459c      	cmp	ip, r3
34028822:	f841 2f04 	str.w	r2, [r1, #4]!
34028826:	d8f9      	bhi.n	3402881c <__lshift+0xc0>
34028828:	e7ea      	b.n	34028800 <__lshift+0xa4>
3402882a:	bf00      	nop
3402882c:	3403ed27 	.word	0x3403ed27
34028830:	3403ed38 	.word	0x3403ed38

34028834 <__mcmp>:
34028834:	4603      	mov	r3, r0
34028836:	690a      	ldr	r2, [r1, #16]
34028838:	6900      	ldr	r0, [r0, #16]
3402883a:	1a80      	subs	r0, r0, r2
3402883c:	b530      	push	{r4, r5, lr}
3402883e:	d10e      	bne.n	3402885e <__mcmp+0x2a>
34028840:	3314      	adds	r3, #20
34028842:	3114      	adds	r1, #20
34028844:	eb03 0482 	add.w	r4, r3, r2, lsl #2
34028848:	eb01 0182 	add.w	r1, r1, r2, lsl #2
3402884c:	f854 5d04 	ldr.w	r5, [r4, #-4]!
34028850:	f851 2d04 	ldr.w	r2, [r1, #-4]!
34028854:	4295      	cmp	r5, r2
34028856:	d003      	beq.n	34028860 <__mcmp+0x2c>
34028858:	d205      	bcs.n	34028866 <__mcmp+0x32>
3402885a:	f04f 30ff 	mov.w	r0, #4294967295
3402885e:	bd30      	pop	{r4, r5, pc}
34028860:	42a3      	cmp	r3, r4
34028862:	d3f3      	bcc.n	3402884c <__mcmp+0x18>
34028864:	e7fb      	b.n	3402885e <__mcmp+0x2a>
34028866:	2001      	movs	r0, #1
34028868:	e7f9      	b.n	3402885e <__mcmp+0x2a>
	...

3402886c <__mdiff>:
3402886c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
34028870:	4689      	mov	r9, r1
34028872:	4606      	mov	r6, r0
34028874:	4611      	mov	r1, r2
34028876:	4614      	mov	r4, r2
34028878:	4648      	mov	r0, r9
3402887a:	f7ff ffdb 	bl	34028834 <__mcmp>
3402887e:	1e05      	subs	r5, r0, #0
34028880:	d112      	bne.n	340288a8 <__mdiff+0x3c>
34028882:	4629      	mov	r1, r5
34028884:	4630      	mov	r0, r6
34028886:	f7ff fd5f 	bl	34028348 <_Balloc>
3402888a:	4602      	mov	r2, r0
3402888c:	b928      	cbnz	r0, 3402889a <__mdiff+0x2e>
3402888e:	4b41      	ldr	r3, [pc, #260]	@ (34028994 <__mdiff+0x128>)
34028890:	f240 2137 	movw	r1, #567	@ 0x237
34028894:	4840      	ldr	r0, [pc, #256]	@ (34028998 <__mdiff+0x12c>)
34028896:	f7fd fa67 	bl	34025d68 <__assert_func>
3402889a:	2301      	movs	r3, #1
3402889c:	e9c0 3504 	strd	r3, r5, [r0, #16]
340288a0:	4610      	mov	r0, r2
340288a2:	b003      	add	sp, #12
340288a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340288a8:	bfbc      	itt	lt
340288aa:	464b      	movlt	r3, r9
340288ac:	46a1      	movlt	r9, r4
340288ae:	4630      	mov	r0, r6
340288b0:	bfb8      	it	lt
340288b2:	2501      	movlt	r5, #1
340288b4:	f8d9 1004 	ldr.w	r1, [r9, #4]
340288b8:	bfb4      	ite	lt
340288ba:	461c      	movlt	r4, r3
340288bc:	2500      	movge	r5, #0
340288be:	f7ff fd43 	bl	34028348 <_Balloc>
340288c2:	4602      	mov	r2, r0
340288c4:	b918      	cbnz	r0, 340288ce <__mdiff+0x62>
340288c6:	4b33      	ldr	r3, [pc, #204]	@ (34028994 <__mdiff+0x128>)
340288c8:	f240 2145 	movw	r1, #581	@ 0x245
340288cc:	e7e2      	b.n	34028894 <__mdiff+0x28>
340288ce:	f8d9 7010 	ldr.w	r7, [r9, #16]
340288d2:	f104 0e14 	add.w	lr, r4, #20
340288d6:	6926      	ldr	r6, [r4, #16]
340288d8:	f100 0b14 	add.w	fp, r0, #20
340288dc:	60c5      	str	r5, [r0, #12]
340288de:	f109 0514 	add.w	r5, r9, #20
340288e2:	f109 0310 	add.w	r3, r9, #16
340288e6:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
340288ea:	eb05 0887 	add.w	r8, r5, r7, lsl #2
340288ee:	46d9      	mov	r9, fp
340288f0:	f04f 0c00 	mov.w	ip, #0
340288f4:	9301      	str	r3, [sp, #4]
340288f6:	9b01      	ldr	r3, [sp, #4]
340288f8:	f85e 0b04 	ldr.w	r0, [lr], #4
340288fc:	f853 af04 	ldr.w	sl, [r3, #4]!
34028900:	4576      	cmp	r6, lr
34028902:	9301      	str	r3, [sp, #4]
34028904:	fa1f f38a 	uxth.w	r3, sl
34028908:	4619      	mov	r1, r3
3402890a:	b283      	uxth	r3, r0
3402890c:	ea4f 4010 	mov.w	r0, r0, lsr #16
34028910:	eba1 0303 	sub.w	r3, r1, r3
34028914:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
34028918:	4463      	add	r3, ip
3402891a:	eb00 4023 	add.w	r0, r0, r3, asr #16
3402891e:	b29b      	uxth	r3, r3
34028920:	ea4f 4c20 	mov.w	ip, r0, asr #16
34028924:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
34028928:	f849 3b04 	str.w	r3, [r9], #4
3402892c:	d8e3      	bhi.n	340288f6 <__mdiff+0x8a>
3402892e:	1b33      	subs	r3, r6, r4
34028930:	3415      	adds	r4, #21
34028932:	3b15      	subs	r3, #21
34028934:	f023 0303 	bic.w	r3, r3, #3
34028938:	3304      	adds	r3, #4
3402893a:	42a6      	cmp	r6, r4
3402893c:	bf38      	it	cc
3402893e:	2304      	movcc	r3, #4
34028940:	441d      	add	r5, r3
34028942:	445b      	add	r3, fp
34028944:	462c      	mov	r4, r5
34028946:	461e      	mov	r6, r3
34028948:	4544      	cmp	r4, r8
3402894a:	d30e      	bcc.n	3402896a <__mdiff+0xfe>
3402894c:	f108 0103 	add.w	r1, r8, #3
34028950:	1b49      	subs	r1, r1, r5
34028952:	3d03      	subs	r5, #3
34028954:	f021 0103 	bic.w	r1, r1, #3
34028958:	45a8      	cmp	r8, r5
3402895a:	bf38      	it	cc
3402895c:	2100      	movcc	r1, #0
3402895e:	440b      	add	r3, r1
34028960:	f853 1d04 	ldr.w	r1, [r3, #-4]!
34028964:	b199      	cbz	r1, 3402898e <__mdiff+0x122>
34028966:	6117      	str	r7, [r2, #16]
34028968:	e79a      	b.n	340288a0 <__mdiff+0x34>
3402896a:	f854 1b04 	ldr.w	r1, [r4], #4
3402896e:	46e6      	mov	lr, ip
34028970:	fa1f fc81 	uxth.w	ip, r1
34028974:	0c08      	lsrs	r0, r1, #16
34028976:	4471      	add	r1, lr
34028978:	44f4      	add	ip, lr
3402897a:	b289      	uxth	r1, r1
3402897c:	eb00 402c 	add.w	r0, r0, ip, asr #16
34028980:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
34028984:	ea4f 4c20 	mov.w	ip, r0, asr #16
34028988:	f846 1b04 	str.w	r1, [r6], #4
3402898c:	e7dc      	b.n	34028948 <__mdiff+0xdc>
3402898e:	3f01      	subs	r7, #1
34028990:	e7e6      	b.n	34028960 <__mdiff+0xf4>
34028992:	bf00      	nop
34028994:	3403ed27 	.word	0x3403ed27
34028998:	3403ed38 	.word	0x3403ed38

3402899c <__d2b>:
3402899c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
340289a0:	460f      	mov	r7, r1
340289a2:	2101      	movs	r1, #1
340289a4:	4616      	mov	r6, r2
340289a6:	ec59 8b10 	vmov	r8, r9, d0
340289aa:	f7ff fccd 	bl	34028348 <_Balloc>
340289ae:	4604      	mov	r4, r0
340289b0:	b930      	cbnz	r0, 340289c0 <__d2b+0x24>
340289b2:	4602      	mov	r2, r0
340289b4:	4b23      	ldr	r3, [pc, #140]	@ (34028a44 <__d2b+0xa8>)
340289b6:	f240 310f 	movw	r1, #783	@ 0x30f
340289ba:	4823      	ldr	r0, [pc, #140]	@ (34028a48 <__d2b+0xac>)
340289bc:	f7fd f9d4 	bl	34025d68 <__assert_func>
340289c0:	f3c9 550a 	ubfx	r5, r9, #20, #11
340289c4:	f3c9 0313 	ubfx	r3, r9, #0, #20
340289c8:	b10d      	cbz	r5, 340289ce <__d2b+0x32>
340289ca:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
340289ce:	9301      	str	r3, [sp, #4]
340289d0:	f1b8 0300 	subs.w	r3, r8, #0
340289d4:	d023      	beq.n	34028a1e <__d2b+0x82>
340289d6:	4668      	mov	r0, sp
340289d8:	9300      	str	r3, [sp, #0]
340289da:	f7ff fd7e 	bl	340284da <__lo0bits>
340289de:	e9dd 1200 	ldrd	r1, r2, [sp]
340289e2:	b1d0      	cbz	r0, 34028a1a <__d2b+0x7e>
340289e4:	f1c0 0320 	rsb	r3, r0, #32
340289e8:	fa02 f303 	lsl.w	r3, r2, r3
340289ec:	40c2      	lsrs	r2, r0
340289ee:	430b      	orrs	r3, r1
340289f0:	9201      	str	r2, [sp, #4]
340289f2:	6163      	str	r3, [r4, #20]
340289f4:	9b01      	ldr	r3, [sp, #4]
340289f6:	2b00      	cmp	r3, #0
340289f8:	61a3      	str	r3, [r4, #24]
340289fa:	bf0c      	ite	eq
340289fc:	2201      	moveq	r2, #1
340289fe:	2202      	movne	r2, #2
34028a00:	6122      	str	r2, [r4, #16]
34028a02:	b1a5      	cbz	r5, 34028a2e <__d2b+0x92>
34028a04:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
34028a08:	4405      	add	r5, r0
34028a0a:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
34028a0e:	603d      	str	r5, [r7, #0]
34028a10:	6030      	str	r0, [r6, #0]
34028a12:	4620      	mov	r0, r4
34028a14:	b003      	add	sp, #12
34028a16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
34028a1a:	6161      	str	r1, [r4, #20]
34028a1c:	e7ea      	b.n	340289f4 <__d2b+0x58>
34028a1e:	a801      	add	r0, sp, #4
34028a20:	f7ff fd5b 	bl	340284da <__lo0bits>
34028a24:	9b01      	ldr	r3, [sp, #4]
34028a26:	3020      	adds	r0, #32
34028a28:	2201      	movs	r2, #1
34028a2a:	6163      	str	r3, [r4, #20]
34028a2c:	e7e8      	b.n	34028a00 <__d2b+0x64>
34028a2e:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
34028a32:	eb04 0382 	add.w	r3, r4, r2, lsl #2
34028a36:	6038      	str	r0, [r7, #0]
34028a38:	6918      	ldr	r0, [r3, #16]
34028a3a:	f7ff fd2f 	bl	3402849c <__hi0bits>
34028a3e:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
34028a42:	e7e5      	b.n	34028a10 <__d2b+0x74>
34028a44:	3403ed27 	.word	0x3403ed27
34028a48:	3403ed38 	.word	0x3403ed38

34028a4c <_malloc_usable_size_r>:
34028a4c:	f851 3c04 	ldr.w	r3, [r1, #-4]
34028a50:	1f18      	subs	r0, r3, #4
34028a52:	2b00      	cmp	r3, #0
34028a54:	bfbc      	itt	lt
34028a56:	580b      	ldrlt	r3, [r1, r0]
34028a58:	18c0      	addlt	r0, r0, r3
34028a5a:	4770      	bx	lr

34028a5c <__ssputs_r>:
34028a5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
34028a60:	461f      	mov	r7, r3
34028a62:	688e      	ldr	r6, [r1, #8]
34028a64:	4682      	mov	sl, r0
34028a66:	460c      	mov	r4, r1
34028a68:	42be      	cmp	r6, r7
34028a6a:	4690      	mov	r8, r2
34028a6c:	680b      	ldr	r3, [r1, #0]
34028a6e:	d82d      	bhi.n	34028acc <__ssputs_r+0x70>
34028a70:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
34028a74:	f412 6f90 	tst.w	r2, #1152	@ 0x480
34028a78:	d026      	beq.n	34028ac8 <__ssputs_r+0x6c>
34028a7a:	6965      	ldr	r5, [r4, #20]
34028a7c:	6909      	ldr	r1, [r1, #16]
34028a7e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
34028a82:	eba3 0901 	sub.w	r9, r3, r1
34028a86:	1c7b      	adds	r3, r7, #1
34028a88:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
34028a8c:	444b      	add	r3, r9
34028a8e:	106d      	asrs	r5, r5, #1
34028a90:	429d      	cmp	r5, r3
34028a92:	bf38      	it	cc
34028a94:	461d      	movcc	r5, r3
34028a96:	0553      	lsls	r3, r2, #21
34028a98:	d527      	bpl.n	34028aea <__ssputs_r+0x8e>
34028a9a:	4629      	mov	r1, r5
34028a9c:	f7fd f9ac 	bl	34025df8 <_malloc_r>
34028aa0:	4606      	mov	r6, r0
34028aa2:	b360      	cbz	r0, 34028afe <__ssputs_r+0xa2>
34028aa4:	464a      	mov	r2, r9
34028aa6:	6921      	ldr	r1, [r4, #16]
34028aa8:	f7fe fe03 	bl	340276b2 <memcpy>
34028aac:	89a3      	ldrh	r3, [r4, #12]
34028aae:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
34028ab2:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34028ab6:	81a3      	strh	r3, [r4, #12]
34028ab8:	6126      	str	r6, [r4, #16]
34028aba:	444e      	add	r6, r9
34028abc:	6165      	str	r5, [r4, #20]
34028abe:	eba5 0509 	sub.w	r5, r5, r9
34028ac2:	6026      	str	r6, [r4, #0]
34028ac4:	463e      	mov	r6, r7
34028ac6:	60a5      	str	r5, [r4, #8]
34028ac8:	42be      	cmp	r6, r7
34028aca:	d900      	bls.n	34028ace <__ssputs_r+0x72>
34028acc:	463e      	mov	r6, r7
34028ace:	4632      	mov	r2, r6
34028ad0:	4641      	mov	r1, r8
34028ad2:	6820      	ldr	r0, [r4, #0]
34028ad4:	f7fe fb44 	bl	34027160 <memmove>
34028ad8:	68a3      	ldr	r3, [r4, #8]
34028ada:	2000      	movs	r0, #0
34028adc:	1b9b      	subs	r3, r3, r6
34028ade:	60a3      	str	r3, [r4, #8]
34028ae0:	6823      	ldr	r3, [r4, #0]
34028ae2:	4433      	add	r3, r6
34028ae4:	6023      	str	r3, [r4, #0]
34028ae6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
34028aea:	462a      	mov	r2, r5
34028aec:	f7fd fa10 	bl	34025f10 <_realloc_r>
34028af0:	4606      	mov	r6, r0
34028af2:	2800      	cmp	r0, #0
34028af4:	d1e0      	bne.n	34028ab8 <__ssputs_r+0x5c>
34028af6:	6921      	ldr	r1, [r4, #16]
34028af8:	4650      	mov	r0, sl
34028afa:	f7ff fbdb 	bl	340282b4 <_free_r>
34028afe:	230c      	movs	r3, #12
34028b00:	f04f 30ff 	mov.w	r0, #4294967295
34028b04:	f8ca 3000 	str.w	r3, [sl]
34028b08:	89a3      	ldrh	r3, [r4, #12]
34028b0a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34028b0e:	81a3      	strh	r3, [r4, #12]
34028b10:	e7e9      	b.n	34028ae6 <__ssputs_r+0x8a>
	...

34028b14 <_svfiprintf_r>:
34028b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34028b18:	4698      	mov	r8, r3
34028b1a:	898b      	ldrh	r3, [r1, #12]
34028b1c:	b09d      	sub	sp, #116	@ 0x74
34028b1e:	4607      	mov	r7, r0
34028b20:	061b      	lsls	r3, r3, #24
34028b22:	460d      	mov	r5, r1
34028b24:	4614      	mov	r4, r2
34028b26:	d510      	bpl.n	34028b4a <_svfiprintf_r+0x36>
34028b28:	690b      	ldr	r3, [r1, #16]
34028b2a:	b973      	cbnz	r3, 34028b4a <_svfiprintf_r+0x36>
34028b2c:	2140      	movs	r1, #64	@ 0x40
34028b2e:	f7fd f963 	bl	34025df8 <_malloc_r>
34028b32:	6028      	str	r0, [r5, #0]
34028b34:	6128      	str	r0, [r5, #16]
34028b36:	b930      	cbnz	r0, 34028b46 <_svfiprintf_r+0x32>
34028b38:	230c      	movs	r3, #12
34028b3a:	603b      	str	r3, [r7, #0]
34028b3c:	f04f 30ff 	mov.w	r0, #4294967295
34028b40:	b01d      	add	sp, #116	@ 0x74
34028b42:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34028b46:	2340      	movs	r3, #64	@ 0x40
34028b48:	616b      	str	r3, [r5, #20]
34028b4a:	2300      	movs	r3, #0
34028b4c:	f8cd 800c 	str.w	r8, [sp, #12]
34028b50:	f04f 0901 	mov.w	r9, #1
34028b54:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 34028cf8 <_svfiprintf_r+0x1e4>
34028b58:	9309      	str	r3, [sp, #36]	@ 0x24
34028b5a:	2320      	movs	r3, #32
34028b5c:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
34028b60:	2330      	movs	r3, #48	@ 0x30
34028b62:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
34028b66:	4623      	mov	r3, r4
34028b68:	469a      	mov	sl, r3
34028b6a:	f813 2b01 	ldrb.w	r2, [r3], #1
34028b6e:	b10a      	cbz	r2, 34028b74 <_svfiprintf_r+0x60>
34028b70:	2a25      	cmp	r2, #37	@ 0x25
34028b72:	d1f9      	bne.n	34028b68 <_svfiprintf_r+0x54>
34028b74:	ebba 0b04 	subs.w	fp, sl, r4
34028b78:	d00b      	beq.n	34028b92 <_svfiprintf_r+0x7e>
34028b7a:	465b      	mov	r3, fp
34028b7c:	4622      	mov	r2, r4
34028b7e:	4629      	mov	r1, r5
34028b80:	4638      	mov	r0, r7
34028b82:	f7ff ff6b 	bl	34028a5c <__ssputs_r>
34028b86:	3001      	adds	r0, #1
34028b88:	f000 80a7 	beq.w	34028cda <_svfiprintf_r+0x1c6>
34028b8c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34028b8e:	445a      	add	r2, fp
34028b90:	9209      	str	r2, [sp, #36]	@ 0x24
34028b92:	f89a 3000 	ldrb.w	r3, [sl]
34028b96:	2b00      	cmp	r3, #0
34028b98:	f000 809f 	beq.w	34028cda <_svfiprintf_r+0x1c6>
34028b9c:	2300      	movs	r3, #0
34028b9e:	f04f 32ff 	mov.w	r2, #4294967295
34028ba2:	f10a 0a01 	add.w	sl, sl, #1
34028ba6:	9304      	str	r3, [sp, #16]
34028ba8:	9307      	str	r3, [sp, #28]
34028baa:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
34028bae:	931a      	str	r3, [sp, #104]	@ 0x68
34028bb0:	e9cd 2305 	strd	r2, r3, [sp, #20]
34028bb4:	4654      	mov	r4, sl
34028bb6:	2205      	movs	r2, #5
34028bb8:	484f      	ldr	r0, [pc, #316]	@ (34028cf8 <_svfiprintf_r+0x1e4>)
34028bba:	f814 1b01 	ldrb.w	r1, [r4], #1
34028bbe:	f7fe fd6a 	bl	34027696 <memchr>
34028bc2:	9a04      	ldr	r2, [sp, #16]
34028bc4:	b9d8      	cbnz	r0, 34028bfe <_svfiprintf_r+0xea>
34028bc6:	06d0      	lsls	r0, r2, #27
34028bc8:	bf44      	itt	mi
34028bca:	2320      	movmi	r3, #32
34028bcc:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34028bd0:	0711      	lsls	r1, r2, #28
34028bd2:	bf44      	itt	mi
34028bd4:	232b      	movmi	r3, #43	@ 0x2b
34028bd6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34028bda:	f89a 3000 	ldrb.w	r3, [sl]
34028bde:	2b2a      	cmp	r3, #42	@ 0x2a
34028be0:	d015      	beq.n	34028c0e <_svfiprintf_r+0xfa>
34028be2:	9a07      	ldr	r2, [sp, #28]
34028be4:	4654      	mov	r4, sl
34028be6:	2000      	movs	r0, #0
34028be8:	f04f 0c0a 	mov.w	ip, #10
34028bec:	4621      	mov	r1, r4
34028bee:	f811 3b01 	ldrb.w	r3, [r1], #1
34028bf2:	3b30      	subs	r3, #48	@ 0x30
34028bf4:	2b09      	cmp	r3, #9
34028bf6:	d94b      	bls.n	34028c90 <_svfiprintf_r+0x17c>
34028bf8:	b1b0      	cbz	r0, 34028c28 <_svfiprintf_r+0x114>
34028bfa:	9207      	str	r2, [sp, #28]
34028bfc:	e014      	b.n	34028c28 <_svfiprintf_r+0x114>
34028bfe:	eba0 0308 	sub.w	r3, r0, r8
34028c02:	46a2      	mov	sl, r4
34028c04:	fa09 f303 	lsl.w	r3, r9, r3
34028c08:	4313      	orrs	r3, r2
34028c0a:	9304      	str	r3, [sp, #16]
34028c0c:	e7d2      	b.n	34028bb4 <_svfiprintf_r+0xa0>
34028c0e:	9b03      	ldr	r3, [sp, #12]
34028c10:	1d19      	adds	r1, r3, #4
34028c12:	681b      	ldr	r3, [r3, #0]
34028c14:	2b00      	cmp	r3, #0
34028c16:	9103      	str	r1, [sp, #12]
34028c18:	bfbb      	ittet	lt
34028c1a:	425b      	neglt	r3, r3
34028c1c:	f042 0202 	orrlt.w	r2, r2, #2
34028c20:	9307      	strge	r3, [sp, #28]
34028c22:	9307      	strlt	r3, [sp, #28]
34028c24:	bfb8      	it	lt
34028c26:	9204      	strlt	r2, [sp, #16]
34028c28:	7823      	ldrb	r3, [r4, #0]
34028c2a:	2b2e      	cmp	r3, #46	@ 0x2e
34028c2c:	d10a      	bne.n	34028c44 <_svfiprintf_r+0x130>
34028c2e:	7863      	ldrb	r3, [r4, #1]
34028c30:	2b2a      	cmp	r3, #42	@ 0x2a
34028c32:	d132      	bne.n	34028c9a <_svfiprintf_r+0x186>
34028c34:	9b03      	ldr	r3, [sp, #12]
34028c36:	3402      	adds	r4, #2
34028c38:	1d1a      	adds	r2, r3, #4
34028c3a:	681b      	ldr	r3, [r3, #0]
34028c3c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
34028c40:	9203      	str	r2, [sp, #12]
34028c42:	9305      	str	r3, [sp, #20]
34028c44:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 34028d08 <_svfiprintf_r+0x1f4>
34028c48:	2203      	movs	r2, #3
34028c4a:	7821      	ldrb	r1, [r4, #0]
34028c4c:	4650      	mov	r0, sl
34028c4e:	f7fe fd22 	bl	34027696 <memchr>
34028c52:	b138      	cbz	r0, 34028c64 <_svfiprintf_r+0x150>
34028c54:	eba0 000a 	sub.w	r0, r0, sl
34028c58:	2240      	movs	r2, #64	@ 0x40
34028c5a:	9b04      	ldr	r3, [sp, #16]
34028c5c:	3401      	adds	r4, #1
34028c5e:	4082      	lsls	r2, r0
34028c60:	4313      	orrs	r3, r2
34028c62:	9304      	str	r3, [sp, #16]
34028c64:	f814 1b01 	ldrb.w	r1, [r4], #1
34028c68:	2206      	movs	r2, #6
34028c6a:	4824      	ldr	r0, [pc, #144]	@ (34028cfc <_svfiprintf_r+0x1e8>)
34028c6c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
34028c70:	f7fe fd11 	bl	34027696 <memchr>
34028c74:	2800      	cmp	r0, #0
34028c76:	d036      	beq.n	34028ce6 <_svfiprintf_r+0x1d2>
34028c78:	4b21      	ldr	r3, [pc, #132]	@ (34028d00 <_svfiprintf_r+0x1ec>)
34028c7a:	bb1b      	cbnz	r3, 34028cc4 <_svfiprintf_r+0x1b0>
34028c7c:	9b03      	ldr	r3, [sp, #12]
34028c7e:	3307      	adds	r3, #7
34028c80:	f023 0307 	bic.w	r3, r3, #7
34028c84:	3308      	adds	r3, #8
34028c86:	9303      	str	r3, [sp, #12]
34028c88:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34028c8a:	4433      	add	r3, r6
34028c8c:	9309      	str	r3, [sp, #36]	@ 0x24
34028c8e:	e76a      	b.n	34028b66 <_svfiprintf_r+0x52>
34028c90:	fb0c 3202 	mla	r2, ip, r2, r3
34028c94:	460c      	mov	r4, r1
34028c96:	2001      	movs	r0, #1
34028c98:	e7a8      	b.n	34028bec <_svfiprintf_r+0xd8>
34028c9a:	2300      	movs	r3, #0
34028c9c:	3401      	adds	r4, #1
34028c9e:	f04f 0c0a 	mov.w	ip, #10
34028ca2:	4619      	mov	r1, r3
34028ca4:	9305      	str	r3, [sp, #20]
34028ca6:	4620      	mov	r0, r4
34028ca8:	f810 2b01 	ldrb.w	r2, [r0], #1
34028cac:	3a30      	subs	r2, #48	@ 0x30
34028cae:	2a09      	cmp	r2, #9
34028cb0:	d903      	bls.n	34028cba <_svfiprintf_r+0x1a6>
34028cb2:	2b00      	cmp	r3, #0
34028cb4:	d0c6      	beq.n	34028c44 <_svfiprintf_r+0x130>
34028cb6:	9105      	str	r1, [sp, #20]
34028cb8:	e7c4      	b.n	34028c44 <_svfiprintf_r+0x130>
34028cba:	fb0c 2101 	mla	r1, ip, r1, r2
34028cbe:	4604      	mov	r4, r0
34028cc0:	2301      	movs	r3, #1
34028cc2:	e7f0      	b.n	34028ca6 <_svfiprintf_r+0x192>
34028cc4:	ab03      	add	r3, sp, #12
34028cc6:	462a      	mov	r2, r5
34028cc8:	a904      	add	r1, sp, #16
34028cca:	4638      	mov	r0, r7
34028ccc:	9300      	str	r3, [sp, #0]
34028cce:	4b0d      	ldr	r3, [pc, #52]	@ (34028d04 <_svfiprintf_r+0x1f0>)
34028cd0:	f7fd fb5a 	bl	34026388 <_printf_float>
34028cd4:	1c42      	adds	r2, r0, #1
34028cd6:	4606      	mov	r6, r0
34028cd8:	d1d6      	bne.n	34028c88 <_svfiprintf_r+0x174>
34028cda:	89ab      	ldrh	r3, [r5, #12]
34028cdc:	065b      	lsls	r3, r3, #25
34028cde:	f53f af2d 	bmi.w	34028b3c <_svfiprintf_r+0x28>
34028ce2:	9809      	ldr	r0, [sp, #36]	@ 0x24
34028ce4:	e72c      	b.n	34028b40 <_svfiprintf_r+0x2c>
34028ce6:	ab03      	add	r3, sp, #12
34028ce8:	462a      	mov	r2, r5
34028cea:	a904      	add	r1, sp, #16
34028cec:	4638      	mov	r0, r7
34028cee:	9300      	str	r3, [sp, #0]
34028cf0:	4b04      	ldr	r3, [pc, #16]	@ (34028d04 <_svfiprintf_r+0x1f0>)
34028cf2:	f7fd fdd5 	bl	340268a0 <_printf_i>
34028cf6:	e7ed      	b.n	34028cd4 <_svfiprintf_r+0x1c0>
34028cf8:	3403ed91 	.word	0x3403ed91
34028cfc:	3403ed9b 	.word	0x3403ed9b
34028d00:	34026389 	.word	0x34026389
34028d04:	34028a5d 	.word	0x34028a5d
34028d08:	3403ed97 	.word	0x3403ed97

34028d0c <__sfputc_r>:
34028d0c:	6893      	ldr	r3, [r2, #8]
34028d0e:	3b01      	subs	r3, #1
34028d10:	2b00      	cmp	r3, #0
34028d12:	b410      	push	{r4}
34028d14:	6093      	str	r3, [r2, #8]
34028d16:	da08      	bge.n	34028d2a <__sfputc_r+0x1e>
34028d18:	6994      	ldr	r4, [r2, #24]
34028d1a:	42a3      	cmp	r3, r4
34028d1c:	db01      	blt.n	34028d22 <__sfputc_r+0x16>
34028d1e:	290a      	cmp	r1, #10
34028d20:	d103      	bne.n	34028d2a <__sfputc_r+0x1e>
34028d22:	f85d 4b04 	ldr.w	r4, [sp], #4
34028d26:	f7fe b987 	b.w	34027038 <__swbuf_r>
34028d2a:	6813      	ldr	r3, [r2, #0]
34028d2c:	1c58      	adds	r0, r3, #1
34028d2e:	6010      	str	r0, [r2, #0]
34028d30:	4608      	mov	r0, r1
34028d32:	7019      	strb	r1, [r3, #0]
34028d34:	f85d 4b04 	ldr.w	r4, [sp], #4
34028d38:	4770      	bx	lr

34028d3a <__sfputs_r>:
34028d3a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
34028d3c:	4606      	mov	r6, r0
34028d3e:	460f      	mov	r7, r1
34028d40:	4614      	mov	r4, r2
34028d42:	18d5      	adds	r5, r2, r3
34028d44:	42ac      	cmp	r4, r5
34028d46:	d101      	bne.n	34028d4c <__sfputs_r+0x12>
34028d48:	2000      	movs	r0, #0
34028d4a:	e007      	b.n	34028d5c <__sfputs_r+0x22>
34028d4c:	463a      	mov	r2, r7
34028d4e:	f814 1b01 	ldrb.w	r1, [r4], #1
34028d52:	4630      	mov	r0, r6
34028d54:	f7ff ffda 	bl	34028d0c <__sfputc_r>
34028d58:	1c43      	adds	r3, r0, #1
34028d5a:	d1f3      	bne.n	34028d44 <__sfputs_r+0xa>
34028d5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

34028d60 <_vfiprintf_r>:
34028d60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34028d64:	460d      	mov	r5, r1
34028d66:	b09d      	sub	sp, #116	@ 0x74
34028d68:	4614      	mov	r4, r2
34028d6a:	4698      	mov	r8, r3
34028d6c:	4606      	mov	r6, r0
34028d6e:	b118      	cbz	r0, 34028d78 <_vfiprintf_r+0x18>
34028d70:	6a03      	ldr	r3, [r0, #32]
34028d72:	b90b      	cbnz	r3, 34028d78 <_vfiprintf_r+0x18>
34028d74:	f7fd ff3e 	bl	34026bf4 <__sinit>
34028d78:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
34028d7a:	07d9      	lsls	r1, r3, #31
34028d7c:	d405      	bmi.n	34028d8a <_vfiprintf_r+0x2a>
34028d7e:	89ab      	ldrh	r3, [r5, #12]
34028d80:	059a      	lsls	r2, r3, #22
34028d82:	d402      	bmi.n	34028d8a <_vfiprintf_r+0x2a>
34028d84:	6da8      	ldr	r0, [r5, #88]	@ 0x58
34028d86:	f7fe fc84 	bl	34027692 <__retarget_lock_acquire_recursive>
34028d8a:	89ab      	ldrh	r3, [r5, #12]
34028d8c:	071b      	lsls	r3, r3, #28
34028d8e:	d501      	bpl.n	34028d94 <_vfiprintf_r+0x34>
34028d90:	692b      	ldr	r3, [r5, #16]
34028d92:	b99b      	cbnz	r3, 34028dbc <_vfiprintf_r+0x5c>
34028d94:	4629      	mov	r1, r5
34028d96:	4630      	mov	r0, r6
34028d98:	f7fe f98c 	bl	340270b4 <__swsetup_r>
34028d9c:	b170      	cbz	r0, 34028dbc <_vfiprintf_r+0x5c>
34028d9e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
34028da0:	07dc      	lsls	r4, r3, #31
34028da2:	d504      	bpl.n	34028dae <_vfiprintf_r+0x4e>
34028da4:	f04f 30ff 	mov.w	r0, #4294967295
34028da8:	b01d      	add	sp, #116	@ 0x74
34028daa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
34028dae:	89ab      	ldrh	r3, [r5, #12]
34028db0:	0598      	lsls	r0, r3, #22
34028db2:	d4f7      	bmi.n	34028da4 <_vfiprintf_r+0x44>
34028db4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
34028db6:	f7fe fc6d 	bl	34027694 <__retarget_lock_release_recursive>
34028dba:	e7f3      	b.n	34028da4 <_vfiprintf_r+0x44>
34028dbc:	2300      	movs	r3, #0
34028dbe:	f8cd 800c 	str.w	r8, [sp, #12]
34028dc2:	f04f 0901 	mov.w	r9, #1
34028dc6:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 34028f7c <_vfiprintf_r+0x21c>
34028dca:	9309      	str	r3, [sp, #36]	@ 0x24
34028dcc:	2320      	movs	r3, #32
34028dce:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
34028dd2:	2330      	movs	r3, #48	@ 0x30
34028dd4:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
34028dd8:	4623      	mov	r3, r4
34028dda:	469a      	mov	sl, r3
34028ddc:	f813 2b01 	ldrb.w	r2, [r3], #1
34028de0:	b10a      	cbz	r2, 34028de6 <_vfiprintf_r+0x86>
34028de2:	2a25      	cmp	r2, #37	@ 0x25
34028de4:	d1f9      	bne.n	34028dda <_vfiprintf_r+0x7a>
34028de6:	ebba 0b04 	subs.w	fp, sl, r4
34028dea:	d00b      	beq.n	34028e04 <_vfiprintf_r+0xa4>
34028dec:	465b      	mov	r3, fp
34028dee:	4622      	mov	r2, r4
34028df0:	4629      	mov	r1, r5
34028df2:	4630      	mov	r0, r6
34028df4:	f7ff ffa1 	bl	34028d3a <__sfputs_r>
34028df8:	3001      	adds	r0, #1
34028dfa:	f000 80a7 	beq.w	34028f4c <_vfiprintf_r+0x1ec>
34028dfe:	9a09      	ldr	r2, [sp, #36]	@ 0x24
34028e00:	445a      	add	r2, fp
34028e02:	9209      	str	r2, [sp, #36]	@ 0x24
34028e04:	f89a 3000 	ldrb.w	r3, [sl]
34028e08:	2b00      	cmp	r3, #0
34028e0a:	f000 809f 	beq.w	34028f4c <_vfiprintf_r+0x1ec>
34028e0e:	2300      	movs	r3, #0
34028e10:	f04f 32ff 	mov.w	r2, #4294967295
34028e14:	f10a 0a01 	add.w	sl, sl, #1
34028e18:	9304      	str	r3, [sp, #16]
34028e1a:	9307      	str	r3, [sp, #28]
34028e1c:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
34028e20:	931a      	str	r3, [sp, #104]	@ 0x68
34028e22:	e9cd 2305 	strd	r2, r3, [sp, #20]
34028e26:	4654      	mov	r4, sl
34028e28:	2205      	movs	r2, #5
34028e2a:	4854      	ldr	r0, [pc, #336]	@ (34028f7c <_vfiprintf_r+0x21c>)
34028e2c:	f814 1b01 	ldrb.w	r1, [r4], #1
34028e30:	f7fe fc31 	bl	34027696 <memchr>
34028e34:	9a04      	ldr	r2, [sp, #16]
34028e36:	b9d8      	cbnz	r0, 34028e70 <_vfiprintf_r+0x110>
34028e38:	06d1      	lsls	r1, r2, #27
34028e3a:	bf44      	itt	mi
34028e3c:	2320      	movmi	r3, #32
34028e3e:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34028e42:	0713      	lsls	r3, r2, #28
34028e44:	bf44      	itt	mi
34028e46:	232b      	movmi	r3, #43	@ 0x2b
34028e48:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
34028e4c:	f89a 3000 	ldrb.w	r3, [sl]
34028e50:	2b2a      	cmp	r3, #42	@ 0x2a
34028e52:	d015      	beq.n	34028e80 <_vfiprintf_r+0x120>
34028e54:	9a07      	ldr	r2, [sp, #28]
34028e56:	4654      	mov	r4, sl
34028e58:	2000      	movs	r0, #0
34028e5a:	f04f 0c0a 	mov.w	ip, #10
34028e5e:	4621      	mov	r1, r4
34028e60:	f811 3b01 	ldrb.w	r3, [r1], #1
34028e64:	3b30      	subs	r3, #48	@ 0x30
34028e66:	2b09      	cmp	r3, #9
34028e68:	d94b      	bls.n	34028f02 <_vfiprintf_r+0x1a2>
34028e6a:	b1b0      	cbz	r0, 34028e9a <_vfiprintf_r+0x13a>
34028e6c:	9207      	str	r2, [sp, #28]
34028e6e:	e014      	b.n	34028e9a <_vfiprintf_r+0x13a>
34028e70:	eba0 0308 	sub.w	r3, r0, r8
34028e74:	46a2      	mov	sl, r4
34028e76:	fa09 f303 	lsl.w	r3, r9, r3
34028e7a:	4313      	orrs	r3, r2
34028e7c:	9304      	str	r3, [sp, #16]
34028e7e:	e7d2      	b.n	34028e26 <_vfiprintf_r+0xc6>
34028e80:	9b03      	ldr	r3, [sp, #12]
34028e82:	1d19      	adds	r1, r3, #4
34028e84:	681b      	ldr	r3, [r3, #0]
34028e86:	2b00      	cmp	r3, #0
34028e88:	9103      	str	r1, [sp, #12]
34028e8a:	bfbb      	ittet	lt
34028e8c:	425b      	neglt	r3, r3
34028e8e:	f042 0202 	orrlt.w	r2, r2, #2
34028e92:	9307      	strge	r3, [sp, #28]
34028e94:	9307      	strlt	r3, [sp, #28]
34028e96:	bfb8      	it	lt
34028e98:	9204      	strlt	r2, [sp, #16]
34028e9a:	7823      	ldrb	r3, [r4, #0]
34028e9c:	2b2e      	cmp	r3, #46	@ 0x2e
34028e9e:	d10a      	bne.n	34028eb6 <_vfiprintf_r+0x156>
34028ea0:	7863      	ldrb	r3, [r4, #1]
34028ea2:	2b2a      	cmp	r3, #42	@ 0x2a
34028ea4:	d132      	bne.n	34028f0c <_vfiprintf_r+0x1ac>
34028ea6:	9b03      	ldr	r3, [sp, #12]
34028ea8:	3402      	adds	r4, #2
34028eaa:	1d1a      	adds	r2, r3, #4
34028eac:	681b      	ldr	r3, [r3, #0]
34028eae:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
34028eb2:	9203      	str	r2, [sp, #12]
34028eb4:	9305      	str	r3, [sp, #20]
34028eb6:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 34028f8c <_vfiprintf_r+0x22c>
34028eba:	2203      	movs	r2, #3
34028ebc:	7821      	ldrb	r1, [r4, #0]
34028ebe:	4650      	mov	r0, sl
34028ec0:	f7fe fbe9 	bl	34027696 <memchr>
34028ec4:	b138      	cbz	r0, 34028ed6 <_vfiprintf_r+0x176>
34028ec6:	eba0 000a 	sub.w	r0, r0, sl
34028eca:	2240      	movs	r2, #64	@ 0x40
34028ecc:	9b04      	ldr	r3, [sp, #16]
34028ece:	3401      	adds	r4, #1
34028ed0:	4082      	lsls	r2, r0
34028ed2:	4313      	orrs	r3, r2
34028ed4:	9304      	str	r3, [sp, #16]
34028ed6:	f814 1b01 	ldrb.w	r1, [r4], #1
34028eda:	2206      	movs	r2, #6
34028edc:	4828      	ldr	r0, [pc, #160]	@ (34028f80 <_vfiprintf_r+0x220>)
34028ede:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
34028ee2:	f7fe fbd8 	bl	34027696 <memchr>
34028ee6:	2800      	cmp	r0, #0
34028ee8:	d03f      	beq.n	34028f6a <_vfiprintf_r+0x20a>
34028eea:	4b26      	ldr	r3, [pc, #152]	@ (34028f84 <_vfiprintf_r+0x224>)
34028eec:	bb1b      	cbnz	r3, 34028f36 <_vfiprintf_r+0x1d6>
34028eee:	9b03      	ldr	r3, [sp, #12]
34028ef0:	3307      	adds	r3, #7
34028ef2:	f023 0307 	bic.w	r3, r3, #7
34028ef6:	3308      	adds	r3, #8
34028ef8:	9303      	str	r3, [sp, #12]
34028efa:	9b09      	ldr	r3, [sp, #36]	@ 0x24
34028efc:	443b      	add	r3, r7
34028efe:	9309      	str	r3, [sp, #36]	@ 0x24
34028f00:	e76a      	b.n	34028dd8 <_vfiprintf_r+0x78>
34028f02:	fb0c 3202 	mla	r2, ip, r2, r3
34028f06:	460c      	mov	r4, r1
34028f08:	2001      	movs	r0, #1
34028f0a:	e7a8      	b.n	34028e5e <_vfiprintf_r+0xfe>
34028f0c:	2300      	movs	r3, #0
34028f0e:	3401      	adds	r4, #1
34028f10:	f04f 0c0a 	mov.w	ip, #10
34028f14:	4619      	mov	r1, r3
34028f16:	9305      	str	r3, [sp, #20]
34028f18:	4620      	mov	r0, r4
34028f1a:	f810 2b01 	ldrb.w	r2, [r0], #1
34028f1e:	3a30      	subs	r2, #48	@ 0x30
34028f20:	2a09      	cmp	r2, #9
34028f22:	d903      	bls.n	34028f2c <_vfiprintf_r+0x1cc>
34028f24:	2b00      	cmp	r3, #0
34028f26:	d0c6      	beq.n	34028eb6 <_vfiprintf_r+0x156>
34028f28:	9105      	str	r1, [sp, #20]
34028f2a:	e7c4      	b.n	34028eb6 <_vfiprintf_r+0x156>
34028f2c:	fb0c 2101 	mla	r1, ip, r1, r2
34028f30:	4604      	mov	r4, r0
34028f32:	2301      	movs	r3, #1
34028f34:	e7f0      	b.n	34028f18 <_vfiprintf_r+0x1b8>
34028f36:	ab03      	add	r3, sp, #12
34028f38:	462a      	mov	r2, r5
34028f3a:	a904      	add	r1, sp, #16
34028f3c:	4630      	mov	r0, r6
34028f3e:	9300      	str	r3, [sp, #0]
34028f40:	4b11      	ldr	r3, [pc, #68]	@ (34028f88 <_vfiprintf_r+0x228>)
34028f42:	f7fd fa21 	bl	34026388 <_printf_float>
34028f46:	4607      	mov	r7, r0
34028f48:	1c78      	adds	r0, r7, #1
34028f4a:	d1d6      	bne.n	34028efa <_vfiprintf_r+0x19a>
34028f4c:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
34028f4e:	07d9      	lsls	r1, r3, #31
34028f50:	d405      	bmi.n	34028f5e <_vfiprintf_r+0x1fe>
34028f52:	89ab      	ldrh	r3, [r5, #12]
34028f54:	059a      	lsls	r2, r3, #22
34028f56:	d402      	bmi.n	34028f5e <_vfiprintf_r+0x1fe>
34028f58:	6da8      	ldr	r0, [r5, #88]	@ 0x58
34028f5a:	f7fe fb9b 	bl	34027694 <__retarget_lock_release_recursive>
34028f5e:	89ab      	ldrh	r3, [r5, #12]
34028f60:	065b      	lsls	r3, r3, #25
34028f62:	f53f af1f 	bmi.w	34028da4 <_vfiprintf_r+0x44>
34028f66:	9809      	ldr	r0, [sp, #36]	@ 0x24
34028f68:	e71e      	b.n	34028da8 <_vfiprintf_r+0x48>
34028f6a:	ab03      	add	r3, sp, #12
34028f6c:	462a      	mov	r2, r5
34028f6e:	a904      	add	r1, sp, #16
34028f70:	4630      	mov	r0, r6
34028f72:	9300      	str	r3, [sp, #0]
34028f74:	4b04      	ldr	r3, [pc, #16]	@ (34028f88 <_vfiprintf_r+0x228>)
34028f76:	f7fd fc93 	bl	340268a0 <_printf_i>
34028f7a:	e7e4      	b.n	34028f46 <_vfiprintf_r+0x1e6>
34028f7c:	3403ed91 	.word	0x3403ed91
34028f80:	3403ed9b 	.word	0x3403ed9b
34028f84:	34026389 	.word	0x34026389
34028f88:	34028d3b 	.word	0x34028d3b
34028f8c:	3403ed97 	.word	0x3403ed97

34028f90 <__sflush_r>:
34028f90:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
34028f94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
34028f98:	0716      	lsls	r6, r2, #28
34028f9a:	4605      	mov	r5, r0
34028f9c:	460c      	mov	r4, r1
34028f9e:	d454      	bmi.n	3402904a <__sflush_r+0xba>
34028fa0:	684b      	ldr	r3, [r1, #4]
34028fa2:	2b00      	cmp	r3, #0
34028fa4:	dc02      	bgt.n	34028fac <__sflush_r+0x1c>
34028fa6:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
34028fa8:	2b00      	cmp	r3, #0
34028faa:	dd48      	ble.n	3402903e <__sflush_r+0xae>
34028fac:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
34028fae:	2e00      	cmp	r6, #0
34028fb0:	d045      	beq.n	3402903e <__sflush_r+0xae>
34028fb2:	2300      	movs	r3, #0
34028fb4:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
34028fb8:	682f      	ldr	r7, [r5, #0]
34028fba:	6a21      	ldr	r1, [r4, #32]
34028fbc:	602b      	str	r3, [r5, #0]
34028fbe:	d030      	beq.n	34029022 <__sflush_r+0x92>
34028fc0:	6d62      	ldr	r2, [r4, #84]	@ 0x54
34028fc2:	89a3      	ldrh	r3, [r4, #12]
34028fc4:	0759      	lsls	r1, r3, #29
34028fc6:	d505      	bpl.n	34028fd4 <__sflush_r+0x44>
34028fc8:	6863      	ldr	r3, [r4, #4]
34028fca:	1ad2      	subs	r2, r2, r3
34028fcc:	6b63      	ldr	r3, [r4, #52]	@ 0x34
34028fce:	b10b      	cbz	r3, 34028fd4 <__sflush_r+0x44>
34028fd0:	6c23      	ldr	r3, [r4, #64]	@ 0x40
34028fd2:	1ad2      	subs	r2, r2, r3
34028fd4:	2300      	movs	r3, #0
34028fd6:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
34028fd8:	6a21      	ldr	r1, [r4, #32]
34028fda:	4628      	mov	r0, r5
34028fdc:	47b0      	blx	r6
34028fde:	1c43      	adds	r3, r0, #1
34028fe0:	89a3      	ldrh	r3, [r4, #12]
34028fe2:	d106      	bne.n	34028ff2 <__sflush_r+0x62>
34028fe4:	6829      	ldr	r1, [r5, #0]
34028fe6:	291d      	cmp	r1, #29
34028fe8:	d82b      	bhi.n	34029042 <__sflush_r+0xb2>
34028fea:	4a2a      	ldr	r2, [pc, #168]	@ (34029094 <__sflush_r+0x104>)
34028fec:	40ca      	lsrs	r2, r1
34028fee:	07d6      	lsls	r6, r2, #31
34028ff0:	d527      	bpl.n	34029042 <__sflush_r+0xb2>
34028ff2:	2200      	movs	r2, #0
34028ff4:	04d9      	lsls	r1, r3, #19
34028ff6:	6062      	str	r2, [r4, #4]
34028ff8:	6922      	ldr	r2, [r4, #16]
34028ffa:	6022      	str	r2, [r4, #0]
34028ffc:	d504      	bpl.n	34029008 <__sflush_r+0x78>
34028ffe:	1c42      	adds	r2, r0, #1
34029000:	d101      	bne.n	34029006 <__sflush_r+0x76>
34029002:	682b      	ldr	r3, [r5, #0]
34029004:	b903      	cbnz	r3, 34029008 <__sflush_r+0x78>
34029006:	6560      	str	r0, [r4, #84]	@ 0x54
34029008:	6b61      	ldr	r1, [r4, #52]	@ 0x34
3402900a:	602f      	str	r7, [r5, #0]
3402900c:	b1b9      	cbz	r1, 3402903e <__sflush_r+0xae>
3402900e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
34029012:	4299      	cmp	r1, r3
34029014:	d002      	beq.n	3402901c <__sflush_r+0x8c>
34029016:	4628      	mov	r0, r5
34029018:	f7ff f94c 	bl	340282b4 <_free_r>
3402901c:	2300      	movs	r3, #0
3402901e:	6363      	str	r3, [r4, #52]	@ 0x34
34029020:	e00d      	b.n	3402903e <__sflush_r+0xae>
34029022:	2301      	movs	r3, #1
34029024:	4628      	mov	r0, r5
34029026:	47b0      	blx	r6
34029028:	4602      	mov	r2, r0
3402902a:	1c50      	adds	r0, r2, #1
3402902c:	d1c9      	bne.n	34028fc2 <__sflush_r+0x32>
3402902e:	682b      	ldr	r3, [r5, #0]
34029030:	2b00      	cmp	r3, #0
34029032:	d0c6      	beq.n	34028fc2 <__sflush_r+0x32>
34029034:	2b1d      	cmp	r3, #29
34029036:	d001      	beq.n	3402903c <__sflush_r+0xac>
34029038:	2b16      	cmp	r3, #22
3402903a:	d11d      	bne.n	34029078 <__sflush_r+0xe8>
3402903c:	602f      	str	r7, [r5, #0]
3402903e:	2000      	movs	r0, #0
34029040:	e021      	b.n	34029086 <__sflush_r+0xf6>
34029042:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34029046:	b21b      	sxth	r3, r3
34029048:	e01a      	b.n	34029080 <__sflush_r+0xf0>
3402904a:	690f      	ldr	r7, [r1, #16]
3402904c:	2f00      	cmp	r7, #0
3402904e:	d0f6      	beq.n	3402903e <__sflush_r+0xae>
34029050:	0793      	lsls	r3, r2, #30
34029052:	680e      	ldr	r6, [r1, #0]
34029054:	600f      	str	r7, [r1, #0]
34029056:	bf0c      	ite	eq
34029058:	694b      	ldreq	r3, [r1, #20]
3402905a:	2300      	movne	r3, #0
3402905c:	eba6 0807 	sub.w	r8, r6, r7
34029060:	608b      	str	r3, [r1, #8]
34029062:	f1b8 0f00 	cmp.w	r8, #0
34029066:	ddea      	ble.n	3402903e <__sflush_r+0xae>
34029068:	4643      	mov	r3, r8
3402906a:	463a      	mov	r2, r7
3402906c:	6a21      	ldr	r1, [r4, #32]
3402906e:	4628      	mov	r0, r5
34029070:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
34029072:	47b0      	blx	r6
34029074:	2800      	cmp	r0, #0
34029076:	dc08      	bgt.n	3402908a <__sflush_r+0xfa>
34029078:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
3402907c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34029080:	f04f 30ff 	mov.w	r0, #4294967295
34029084:	81a3      	strh	r3, [r4, #12]
34029086:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
3402908a:	4407      	add	r7, r0
3402908c:	eba8 0800 	sub.w	r8, r8, r0
34029090:	e7e7      	b.n	34029062 <__sflush_r+0xd2>
34029092:	bf00      	nop
34029094:	20400001 	.word	0x20400001

34029098 <_fflush_r>:
34029098:	b538      	push	{r3, r4, r5, lr}
3402909a:	690b      	ldr	r3, [r1, #16]
3402909c:	4605      	mov	r5, r0
3402909e:	460c      	mov	r4, r1
340290a0:	b913      	cbnz	r3, 340290a8 <_fflush_r+0x10>
340290a2:	2500      	movs	r5, #0
340290a4:	4628      	mov	r0, r5
340290a6:	bd38      	pop	{r3, r4, r5, pc}
340290a8:	b118      	cbz	r0, 340290b2 <_fflush_r+0x1a>
340290aa:	6a03      	ldr	r3, [r0, #32]
340290ac:	b90b      	cbnz	r3, 340290b2 <_fflush_r+0x1a>
340290ae:	f7fd fda1 	bl	34026bf4 <__sinit>
340290b2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
340290b6:	2b00      	cmp	r3, #0
340290b8:	d0f3      	beq.n	340290a2 <_fflush_r+0xa>
340290ba:	6e62      	ldr	r2, [r4, #100]	@ 0x64
340290bc:	07d0      	lsls	r0, r2, #31
340290be:	d404      	bmi.n	340290ca <_fflush_r+0x32>
340290c0:	0599      	lsls	r1, r3, #22
340290c2:	d402      	bmi.n	340290ca <_fflush_r+0x32>
340290c4:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340290c6:	f7fe fae4 	bl	34027692 <__retarget_lock_acquire_recursive>
340290ca:	4628      	mov	r0, r5
340290cc:	4621      	mov	r1, r4
340290ce:	f7ff ff5f 	bl	34028f90 <__sflush_r>
340290d2:	6e63      	ldr	r3, [r4, #100]	@ 0x64
340290d4:	4605      	mov	r5, r0
340290d6:	07da      	lsls	r2, r3, #31
340290d8:	d4e4      	bmi.n	340290a4 <_fflush_r+0xc>
340290da:	89a3      	ldrh	r3, [r4, #12]
340290dc:	059b      	lsls	r3, r3, #22
340290de:	d4e1      	bmi.n	340290a4 <_fflush_r+0xc>
340290e0:	6da0      	ldr	r0, [r4, #88]	@ 0x58
340290e2:	f7fe fad7 	bl	34027694 <__retarget_lock_release_recursive>
340290e6:	e7dd      	b.n	340290a4 <_fflush_r+0xc>

340290e8 <__swhatbuf_r>:
340290e8:	b570      	push	{r4, r5, r6, lr}
340290ea:	460c      	mov	r4, r1
340290ec:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
340290f0:	b096      	sub	sp, #88	@ 0x58
340290f2:	4615      	mov	r5, r2
340290f4:	2900      	cmp	r1, #0
340290f6:	461e      	mov	r6, r3
340290f8:	da0c      	bge.n	34029114 <__swhatbuf_r+0x2c>
340290fa:	89a3      	ldrh	r3, [r4, #12]
340290fc:	2100      	movs	r1, #0
340290fe:	f013 0f80 	tst.w	r3, #128	@ 0x80
34029102:	bf14      	ite	ne
34029104:	2340      	movne	r3, #64	@ 0x40
34029106:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
3402910a:	2000      	movs	r0, #0
3402910c:	6031      	str	r1, [r6, #0]
3402910e:	602b      	str	r3, [r5, #0]
34029110:	b016      	add	sp, #88	@ 0x58
34029112:	bd70      	pop	{r4, r5, r6, pc}
34029114:	466a      	mov	r2, sp
34029116:	f000 f879 	bl	3402920c <_fstat_r>
3402911a:	2800      	cmp	r0, #0
3402911c:	dbed      	blt.n	340290fa <__swhatbuf_r+0x12>
3402911e:	9901      	ldr	r1, [sp, #4]
34029120:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
34029124:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
34029128:	4259      	negs	r1, r3
3402912a:	4159      	adcs	r1, r3
3402912c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34029130:	e7eb      	b.n	3402910a <__swhatbuf_r+0x22>

34029132 <__smakebuf_r>:
34029132:	898b      	ldrh	r3, [r1, #12]
34029134:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34029136:	079d      	lsls	r5, r3, #30
34029138:	4606      	mov	r6, r0
3402913a:	460c      	mov	r4, r1
3402913c:	d507      	bpl.n	3402914e <__smakebuf_r+0x1c>
3402913e:	f104 0347 	add.w	r3, r4, #71	@ 0x47
34029142:	6023      	str	r3, [r4, #0]
34029144:	6123      	str	r3, [r4, #16]
34029146:	2301      	movs	r3, #1
34029148:	6163      	str	r3, [r4, #20]
3402914a:	b003      	add	sp, #12
3402914c:	bdf0      	pop	{r4, r5, r6, r7, pc}
3402914e:	ab01      	add	r3, sp, #4
34029150:	466a      	mov	r2, sp
34029152:	f7ff ffc9 	bl	340290e8 <__swhatbuf_r>
34029156:	9f00      	ldr	r7, [sp, #0]
34029158:	4605      	mov	r5, r0
3402915a:	4630      	mov	r0, r6
3402915c:	4639      	mov	r1, r7
3402915e:	f7fc fe4b 	bl	34025df8 <_malloc_r>
34029162:	b948      	cbnz	r0, 34029178 <__smakebuf_r+0x46>
34029164:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
34029168:	059a      	lsls	r2, r3, #22
3402916a:	d4ee      	bmi.n	3402914a <__smakebuf_r+0x18>
3402916c:	f023 0303 	bic.w	r3, r3, #3
34029170:	f043 0302 	orr.w	r3, r3, #2
34029174:	81a3      	strh	r3, [r4, #12]
34029176:	e7e2      	b.n	3402913e <__smakebuf_r+0xc>
34029178:	89a3      	ldrh	r3, [r4, #12]
3402917a:	6020      	str	r0, [r4, #0]
3402917c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
34029180:	81a3      	strh	r3, [r4, #12]
34029182:	9b01      	ldr	r3, [sp, #4]
34029184:	e9c4 0704 	strd	r0, r7, [r4, #16]
34029188:	b15b      	cbz	r3, 340291a2 <__smakebuf_r+0x70>
3402918a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
3402918e:	4630      	mov	r0, r6
34029190:	f000 f84e 	bl	34029230 <_isatty_r>
34029194:	b128      	cbz	r0, 340291a2 <__smakebuf_r+0x70>
34029196:	89a3      	ldrh	r3, [r4, #12]
34029198:	f023 0303 	bic.w	r3, r3, #3
3402919c:	f043 0301 	orr.w	r3, r3, #1
340291a0:	81a3      	strh	r3, [r4, #12]
340291a2:	89a3      	ldrh	r3, [r4, #12]
340291a4:	431d      	orrs	r5, r3
340291a6:	81a5      	strh	r5, [r4, #12]
340291a8:	e7cf      	b.n	3402914a <__smakebuf_r+0x18>

340291aa <_raise_r>:
340291aa:	291f      	cmp	r1, #31
340291ac:	b538      	push	{r3, r4, r5, lr}
340291ae:	4605      	mov	r5, r0
340291b0:	460c      	mov	r4, r1
340291b2:	d904      	bls.n	340291be <_raise_r+0x14>
340291b4:	2316      	movs	r3, #22
340291b6:	6003      	str	r3, [r0, #0]
340291b8:	f04f 30ff 	mov.w	r0, #4294967295
340291bc:	bd38      	pop	{r3, r4, r5, pc}
340291be:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
340291c0:	b112      	cbz	r2, 340291c8 <_raise_r+0x1e>
340291c2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
340291c6:	b94b      	cbnz	r3, 340291dc <_raise_r+0x32>
340291c8:	4628      	mov	r0, r5
340291ca:	f000 f853 	bl	34029274 <_getpid_r>
340291ce:	4622      	mov	r2, r4
340291d0:	4601      	mov	r1, r0
340291d2:	4628      	mov	r0, r5
340291d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
340291d8:	f000 b83a 	b.w	34029250 <_kill_r>
340291dc:	2b01      	cmp	r3, #1
340291de:	d00a      	beq.n	340291f6 <_raise_r+0x4c>
340291e0:	1c59      	adds	r1, r3, #1
340291e2:	d103      	bne.n	340291ec <_raise_r+0x42>
340291e4:	2316      	movs	r3, #22
340291e6:	6003      	str	r3, [r0, #0]
340291e8:	2001      	movs	r0, #1
340291ea:	e7e7      	b.n	340291bc <_raise_r+0x12>
340291ec:	2100      	movs	r1, #0
340291ee:	4620      	mov	r0, r4
340291f0:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
340291f4:	4798      	blx	r3
340291f6:	2000      	movs	r0, #0
340291f8:	e7e0      	b.n	340291bc <_raise_r+0x12>
	...

340291fc <raise>:
340291fc:	4b02      	ldr	r3, [pc, #8]	@ (34029208 <raise+0xc>)
340291fe:	4601      	mov	r1, r0
34029200:	6818      	ldr	r0, [r3, #0]
34029202:	f7ff bfd2 	b.w	340291aa <_raise_r>
34029206:	bf00      	nop
34029208:	340414a4 	.word	0x340414a4

3402920c <_fstat_r>:
3402920c:	b538      	push	{r3, r4, r5, lr}
3402920e:	2300      	movs	r3, #0
34029210:	4d06      	ldr	r5, [pc, #24]	@ (3402922c <_fstat_r+0x20>)
34029212:	4604      	mov	r4, r0
34029214:	4608      	mov	r0, r1
34029216:	4611      	mov	r1, r2
34029218:	602b      	str	r3, [r5, #0]
3402921a:	f7db fdbc 	bl	34004d96 <_fstat>
3402921e:	1c43      	adds	r3, r0, #1
34029220:	d102      	bne.n	34029228 <_fstat_r+0x1c>
34029222:	682b      	ldr	r3, [r5, #0]
34029224:	b103      	cbz	r3, 34029228 <_fstat_r+0x1c>
34029226:	6023      	str	r3, [r4, #0]
34029228:	bd38      	pop	{r3, r4, r5, pc}
3402922a:	bf00      	nop
3402922c:	340567f0 	.word	0x340567f0

34029230 <_isatty_r>:
34029230:	b538      	push	{r3, r4, r5, lr}
34029232:	2300      	movs	r3, #0
34029234:	4d05      	ldr	r5, [pc, #20]	@ (3402924c <_isatty_r+0x1c>)
34029236:	4604      	mov	r4, r0
34029238:	4608      	mov	r0, r1
3402923a:	602b      	str	r3, [r5, #0]
3402923c:	f7db fdbb 	bl	34004db6 <_isatty>
34029240:	1c43      	adds	r3, r0, #1
34029242:	d102      	bne.n	3402924a <_isatty_r+0x1a>
34029244:	682b      	ldr	r3, [r5, #0]
34029246:	b103      	cbz	r3, 3402924a <_isatty_r+0x1a>
34029248:	6023      	str	r3, [r4, #0]
3402924a:	bd38      	pop	{r3, r4, r5, pc}
3402924c:	340567f0 	.word	0x340567f0

34029250 <_kill_r>:
34029250:	b538      	push	{r3, r4, r5, lr}
34029252:	2300      	movs	r3, #0
34029254:	4d06      	ldr	r5, [pc, #24]	@ (34029270 <_kill_r+0x20>)
34029256:	4604      	mov	r4, r0
34029258:	4608      	mov	r0, r1
3402925a:	4611      	mov	r1, r2
3402925c:	602b      	str	r3, [r5, #0]
3402925e:	f7db fd3a 	bl	34004cd6 <_kill>
34029262:	1c43      	adds	r3, r0, #1
34029264:	d102      	bne.n	3402926c <_kill_r+0x1c>
34029266:	682b      	ldr	r3, [r5, #0]
34029268:	b103      	cbz	r3, 3402926c <_kill_r+0x1c>
3402926a:	6023      	str	r3, [r4, #0]
3402926c:	bd38      	pop	{r3, r4, r5, pc}
3402926e:	bf00      	nop
34029270:	340567f0 	.word	0x340567f0

34029274 <_getpid_r>:
34029274:	f7db bd27 	b.w	34004cc6 <_getpid>

34029278 <_calloc_r>:
34029278:	b570      	push	{r4, r5, r6, lr}
3402927a:	fba1 5402 	umull	r5, r4, r1, r2
3402927e:	b934      	cbnz	r4, 3402928e <_calloc_r+0x16>
34029280:	4629      	mov	r1, r5
34029282:	f7fc fdb9 	bl	34025df8 <_malloc_r>
34029286:	4606      	mov	r6, r0
34029288:	b928      	cbnz	r0, 34029296 <_calloc_r+0x1e>
3402928a:	4630      	mov	r0, r6
3402928c:	bd70      	pop	{r4, r5, r6, pc}
3402928e:	220c      	movs	r2, #12
34029290:	2600      	movs	r6, #0
34029292:	6002      	str	r2, [r0, #0]
34029294:	e7f9      	b.n	3402928a <_calloc_r+0x12>
34029296:	462a      	mov	r2, r5
34029298:	4621      	mov	r1, r4
3402929a:	f7fd ff7b 	bl	34027194 <memset>
3402929e:	e7f4      	b.n	3402928a <_calloc_r+0x12>

340292a0 <__ascii_mbtowc>:
340292a0:	b082      	sub	sp, #8
340292a2:	b901      	cbnz	r1, 340292a6 <__ascii_mbtowc+0x6>
340292a4:	a901      	add	r1, sp, #4
340292a6:	b142      	cbz	r2, 340292ba <__ascii_mbtowc+0x1a>
340292a8:	b14b      	cbz	r3, 340292be <__ascii_mbtowc+0x1e>
340292aa:	7813      	ldrb	r3, [r2, #0]
340292ac:	600b      	str	r3, [r1, #0]
340292ae:	7812      	ldrb	r2, [r2, #0]
340292b0:	1e10      	subs	r0, r2, #0
340292b2:	bf18      	it	ne
340292b4:	2001      	movne	r0, #1
340292b6:	b002      	add	sp, #8
340292b8:	4770      	bx	lr
340292ba:	4610      	mov	r0, r2
340292bc:	e7fb      	b.n	340292b6 <__ascii_mbtowc+0x16>
340292be:	f06f 0001 	mvn.w	r0, #1
340292c2:	e7f8      	b.n	340292b6 <__ascii_mbtowc+0x16>

340292c4 <__ascii_wctomb>:
340292c4:	4603      	mov	r3, r0
340292c6:	4608      	mov	r0, r1
340292c8:	b141      	cbz	r1, 340292dc <__ascii_wctomb+0x18>
340292ca:	2aff      	cmp	r2, #255	@ 0xff
340292cc:	d904      	bls.n	340292d8 <__ascii_wctomb+0x14>
340292ce:	228a      	movs	r2, #138	@ 0x8a
340292d0:	f04f 30ff 	mov.w	r0, #4294967295
340292d4:	601a      	str	r2, [r3, #0]
340292d6:	4770      	bx	lr
340292d8:	2001      	movs	r0, #1
340292da:	700a      	strb	r2, [r1, #0]
340292dc:	4770      	bx	lr
	...

340292e0 <log10>:
340292e0:	b508      	push	{r3, lr}
340292e2:	ed2d 8b02 	vpush	{d8}
340292e6:	eeb0 8b40 	vmov.f64	d8, d0
340292ea:	f000 fe85 	bl	34029ff8 <__ieee754_log10>
340292ee:	eeb4 8b48 	vcmp.f64	d8, d8
340292f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
340292f6:	d60f      	bvs.n	34029318 <log10+0x38>
340292f8:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
340292fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029300:	d80a      	bhi.n	34029318 <log10+0x38>
34029302:	eeb5 8b40 	vcmp.f64	d8, #0.0
34029306:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402930a:	d108      	bne.n	3402931e <log10+0x3e>
3402930c:	f7fe f996 	bl	3402763c <__errno>
34029310:	2322      	movs	r3, #34	@ 0x22
34029312:	ed9f 0b09 	vldr	d0, [pc, #36]	@ 34029338 <log10+0x58>
34029316:	6003      	str	r3, [r0, #0]
34029318:	ecbd 8b02 	vpop	{d8}
3402931c:	bd08      	pop	{r3, pc}
3402931e:	f7fe f98d 	bl	3402763c <__errno>
34029322:	2321      	movs	r3, #33	@ 0x21
34029324:	ecbd 8b02 	vpop	{d8}
34029328:	6003      	str	r3, [r0, #0]
3402932a:	4805      	ldr	r0, [pc, #20]	@ (34029340 <log10+0x60>)
3402932c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
34029330:	f000 b82a 	b.w	34029388 <nan>
34029334:	f3af 8000 	nop.w
34029338:	00000000 	.word	0x00000000
3402933c:	fff00000 	.word	0xfff00000
34029340:	3403e15d 	.word	0x3403e15d
34029344:	00000000 	.word	0x00000000

34029348 <sqrt>:
34029348:	b508      	push	{r3, lr}
3402934a:	ed2d 8b04 	vpush	{d8-d9}
3402934e:	eeb0 8b40 	vmov.f64	d8, d0
34029352:	f000 fe4e 	bl	34029ff2 <__ieee754_sqrt>
34029356:	eeb4 8b48 	vcmp.f64	d8, d8
3402935a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402935e:	d60c      	bvs.n	3402937a <sqrt+0x32>
34029360:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 34029380 <sqrt+0x38>
34029364:	eeb4 8bc9 	vcmpe.f64	d8, d9
34029368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
3402936c:	d505      	bpl.n	3402937a <sqrt+0x32>
3402936e:	f7fe f965 	bl	3402763c <__errno>
34029372:	ee89 0b09 	vdiv.f64	d0, d9, d9
34029376:	2321      	movs	r3, #33	@ 0x21
34029378:	6003      	str	r3, [r0, #0]
3402937a:	ecbd 8b04 	vpop	{d8-d9}
3402937e:	bd08      	pop	{r3, pc}
	...

34029388 <nan>:
34029388:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 34029390 <nan+0x8>
3402938c:	4770      	bx	lr
3402938e:	bf00      	nop
34029390:	00000000 	.word	0x00000000
34029394:	7ff80000 	.word	0x7ff80000

34029398 <with_errno>:
34029398:	b510      	push	{r4, lr}
3402939a:	ed2d 8b02 	vpush	{d8}
3402939e:	eeb0 8b40 	vmov.f64	d8, d0
340293a2:	4604      	mov	r4, r0
340293a4:	f7fe f94a 	bl	3402763c <__errno>
340293a8:	6004      	str	r4, [r0, #0]
340293aa:	eeb0 0b48 	vmov.f64	d0, d8
340293ae:	ecbd 8b02 	vpop	{d8}
340293b2:	bd10      	pop	{r4, pc}

340293b4 <xflow>:
340293b4:	b082      	sub	sp, #8
340293b6:	b158      	cbz	r0, 340293d0 <xflow+0x1c>
340293b8:	eeb1 7b40 	vneg.f64	d7, d0
340293bc:	2022      	movs	r0, #34	@ 0x22
340293be:	ed8d 7b00 	vstr	d7, [sp]
340293c2:	ed9d 7b00 	vldr	d7, [sp]
340293c6:	ee20 0b07 	vmul.f64	d0, d0, d7
340293ca:	b002      	add	sp, #8
340293cc:	f7ff bfe4 	b.w	34029398 <with_errno>
340293d0:	eeb0 7b40 	vmov.f64	d7, d0
340293d4:	e7f2      	b.n	340293bc <xflow+0x8>
	...

340293d8 <__math_uflow>:
340293d8:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 340293e0 <__math_uflow+0x8>
340293dc:	f7ff bfea 	b.w	340293b4 <xflow>
340293e0:	00000000 	.word	0x00000000
340293e4:	10000000 	.word	0x10000000

340293e8 <__math_oflow>:
340293e8:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 340293f0 <__math_oflow+0x8>
340293ec:	f7ff bfe2 	b.w	340293b4 <xflow>
340293f0:	00000000 	.word	0x00000000
340293f4:	70000000 	.word	0x70000000

340293f8 <__math_divzero>:
340293f8:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
340293fc:	b082      	sub	sp, #8
340293fe:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
34029402:	2800      	cmp	r0, #0
34029404:	f04f 0022 	mov.w	r0, #34	@ 0x22
34029408:	fe07 7b06 	vseleq.f64	d7, d7, d6
3402940c:	ed8d 7b00 	vstr	d7, [sp]
34029410:	ed9d 0b00 	vldr	d0, [sp]
34029414:	ed9f 7b04 	vldr	d7, [pc, #16]	@ 34029428 <__math_divzero+0x30>
34029418:	ee80 0b07 	vdiv.f64	d0, d0, d7
3402941c:	b002      	add	sp, #8
3402941e:	f7ff bfbb 	b.w	34029398 <with_errno>
34029422:	bf00      	nop
34029424:	f3af 8000 	nop.w
	...

34029430 <__math_invalid>:
34029430:	eeb0 7b40 	vmov.f64	d7, d0
34029434:	ee30 6b40 	vsub.f64	d6, d0, d0
34029438:	eeb4 7b47 	vcmp.f64	d7, d7
3402943c:	ee86 0b06 	vdiv.f64	d0, d6, d6
34029440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029444:	d602      	bvs.n	3402944c <__math_invalid+0x1c>
34029446:	2021      	movs	r0, #33	@ 0x21
34029448:	f7ff bfa6 	b.w	34029398 <with_errno>
3402944c:	4770      	bx	lr

3402944e <__math_check_uflow>:
3402944e:	eeb5 0b40 	vcmp.f64	d0, #0.0
34029452:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029456:	d102      	bne.n	3402945e <__math_check_uflow+0x10>
34029458:	2022      	movs	r0, #34	@ 0x22
3402945a:	f7ff bf9d 	b.w	34029398 <with_errno>
3402945e:	4770      	bx	lr

34029460 <__math_check_oflow>:
34029460:	eeb0 7bc0 	vabs.f64	d7, d0
34029464:	ed9f 6b06 	vldr	d6, [pc, #24]	@ 34029480 <__math_check_oflow+0x20>
34029468:	eeb4 7b46 	vcmp.f64	d7, d6
3402946c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029470:	dd02      	ble.n	34029478 <__math_check_oflow+0x18>
34029472:	2022      	movs	r0, #34	@ 0x22
34029474:	f7ff bf90 	b.w	34029398 <with_errno>
34029478:	4770      	bx	lr
3402947a:	bf00      	nop
3402947c:	f3af 8000 	nop.w
34029480:	ffffffff 	.word	0xffffffff
34029484:	7fefffff 	.word	0x7fefffff

34029488 <log>:
34029488:	ee10 0a90 	vmov	r0, s1
3402948c:	ee10 3a10 	vmov	r3, s0
34029490:	b4f0      	push	{r4, r5, r6, r7}
34029492:	f100 4140 	add.w	r1, r0, #3221225472	@ 0xc0000000
34029496:	f04f 34ff 	mov.w	r4, #4294967295
3402949a:	0c02      	lsrs	r2, r0, #16
3402949c:	429c      	cmp	r4, r3
3402949e:	f501 1190 	add.w	r1, r1, #1179648	@ 0x120000
340294a2:	4c71      	ldr	r4, [pc, #452]	@ (34029668 <log+0x1e0>)
340294a4:	418c      	sbcs	r4, r1
340294a6:	ed2d 8b02 	vpush	{d8}
340294aa:	d35a      	bcc.n	34029562 <log+0xda>
340294ac:	4a6f      	ldr	r2, [pc, #444]	@ (3402966c <log+0x1e4>)
340294ae:	4290      	cmp	r0, r2
340294b0:	bf08      	it	eq
340294b2:	2b00      	cmpeq	r3, #0
340294b4:	f000 80c7 	beq.w	34029646 <log+0x1be>
340294b8:	eeb7 7b00 	vmov.f64	d7, #112	@ 0x3f800000  1.0
340294bc:	4b6c      	ldr	r3, [pc, #432]	@ (34029670 <log+0x1e8>)
340294be:	ed93 6b12 	vldr	d6, [r3, #72]	@ 0x48
340294c2:	ee30 0b47 	vsub.f64	d0, d0, d7
340294c6:	ed93 7b10 	vldr	d7, [r3, #64]	@ 0x40
340294ca:	ee20 2b00 	vmul.f64	d2, d0, d0
340294ce:	eea6 7b00 	vfma.f64	d7, d6, d0
340294d2:	ee20 4b02 	vmul.f64	d4, d0, d2
340294d6:	ed93 6b14 	vldr	d6, [r3, #80]	@ 0x50
340294da:	ed93 5b18 	vldr	d5, [r3, #96]	@ 0x60
340294de:	ed93 3b1e 	vldr	d3, [r3, #120]	@ 0x78
340294e2:	eea6 7b02 	vfma.f64	d7, d6, d2
340294e6:	ed93 6b16 	vldr	d6, [r3, #88]	@ 0x58
340294ea:	eea5 6b00 	vfma.f64	d6, d5, d0
340294ee:	ed93 5b1a 	vldr	d5, [r3, #104]	@ 0x68
340294f2:	eea5 6b02 	vfma.f64	d6, d5, d2
340294f6:	ed93 5b1c 	vldr	d5, [r3, #112]	@ 0x70
340294fa:	eea3 5b00 	vfma.f64	d5, d3, d0
340294fe:	ed93 3b20 	vldr	d3, [r3, #128]	@ 0x80
34029502:	eea3 5b02 	vfma.f64	d5, d3, d2
34029506:	ed93 3b22 	vldr	d3, [r3, #136]	@ 0x88
3402950a:	eea3 5b04 	vfma.f64	d5, d3, d4
3402950e:	eeb0 3b40 	vmov.f64	d3, d0
34029512:	eea5 6b04 	vfma.f64	d6, d5, d4
34029516:	ed93 5b0e 	vldr	d5, [r3, #56]	@ 0x38
3402951a:	eea6 7b04 	vfma.f64	d7, d6, d4
3402951e:	eeb0 6b40 	vmov.f64	d6, d0
34029522:	eeb0 2b47 	vmov.f64	d2, d7
34029526:	ed9f 7b4a 	vldr	d7, [pc, #296]	@ 34029650 <log+0x1c8>
3402952a:	eea0 6b07 	vfma.f64	d6, d0, d7
3402952e:	eea0 6b47 	vfms.f64	d6, d0, d7
34029532:	ee26 1b06 	vmul.f64	d1, d6, d6
34029536:	ee30 8b46 	vsub.f64	d8, d0, d6
3402953a:	eea1 3b05 	vfma.f64	d3, d1, d5
3402953e:	ee30 7b43 	vsub.f64	d7, d0, d3
34029542:	ee30 0b06 	vadd.f64	d0, d0, d6
34029546:	eea1 7b05 	vfma.f64	d7, d1, d5
3402954a:	ee25 5b08 	vmul.f64	d5, d5, d8
3402954e:	eea5 7b00 	vfma.f64	d7, d5, d0
34029552:	eea2 7b04 	vfma.f64	d7, d2, d4
34029556:	ee33 0b07 	vadd.f64	d0, d3, d7
3402955a:	ecbd 8b02 	vpop	{d8}
3402955e:	bcf0      	pop	{r4, r5, r6, r7}
34029560:	4770      	bx	lr
34029562:	f1a2 0410 	sub.w	r4, r2, #16
34029566:	f647 71df 	movw	r1, #32735	@ 0x7fdf
3402956a:	428c      	cmp	r4, r1
3402956c:	d923      	bls.n	340295b6 <log+0x12e>
3402956e:	18d9      	adds	r1, r3, r3
34029570:	eb40 0400 	adc.w	r4, r0, r0
34029574:	4321      	orrs	r1, r4
34029576:	d105      	bne.n	34029584 <log+0xfc>
34029578:	2001      	movs	r0, #1
3402957a:	ecbd 8b02 	vpop	{d8}
3402957e:	bcf0      	pop	{r4, r5, r6, r7}
34029580:	f7ff bf3a 	b.w	340293f8 <__math_divzero>
34029584:	493b      	ldr	r1, [pc, #236]	@ (34029674 <log+0x1ec>)
34029586:	4288      	cmp	r0, r1
34029588:	bf08      	it	eq
3402958a:	2b00      	cmpeq	r3, #0
3402958c:	d0e5      	beq.n	3402955a <log+0xd2>
3402958e:	0413      	lsls	r3, r2, #16
34029590:	d403      	bmi.n	3402959a <log+0x112>
34029592:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
34029596:	4393      	bics	r3, r2
34029598:	d104      	bne.n	340295a4 <log+0x11c>
3402959a:	ecbd 8b02 	vpop	{d8}
3402959e:	bcf0      	pop	{r4, r5, r6, r7}
340295a0:	f7ff bf46 	b.w	34029430 <__math_invalid>
340295a4:	ed9f 7b2c 	vldr	d7, [pc, #176]	@ 34029658 <log+0x1d0>
340295a8:	ee20 7b07 	vmul.f64	d7, d0, d7
340295ac:	ec53 2b17 	vmov	r2, r3, d7
340295b0:	f1a3 7050 	sub.w	r0, r3, #54525952	@ 0x3400000
340295b4:	4613      	mov	r3, r2
340295b6:	f100 4240 	add.w	r2, r0, #3221225472	@ 0xc0000000
340295ba:	492d      	ldr	r1, [pc, #180]	@ (34029670 <log+0x1e8>)
340295bc:	eebf 5b00 	vmov.f64	d5, #240	@ 0xbf800000 -1.0
340295c0:	1e1e      	subs	r6, r3, #0
340295c2:	f502 12d0 	add.w	r2, r2, #1703936	@ 0x1a0000
340295c6:	f3c2 3446 	ubfx	r4, r2, #13, #7
340295ca:	ea4f 5c12 	mov.w	ip, r2, lsr #20
340295ce:	1512      	asrs	r2, r2, #20
340295d0:	eb01 1504 	add.w	r5, r1, r4, lsl #4
340295d4:	ea4f 5c0c 	mov.w	ip, ip, lsl #20
340295d8:	ed95 7b24 	vldr	d7, [r5, #144]	@ 0x90
340295dc:	eba0 070c 	sub.w	r7, r0, ip
340295e0:	ec47 6b16 	vmov	d6, r6, r7
340295e4:	eea7 5b06 	vfma.f64	d5, d7, d6
340295e8:	ee07 2a90 	vmov	s15, r2
340295ec:	eeb8 6be7 	vcvt.f64.s32	d6, s15
340295f0:	ed91 4b00 	vldr	d4, [r1]
340295f4:	ed95 7b26 	vldr	d7, [r5, #152]	@ 0x98
340295f8:	ed91 3b0c 	vldr	d3, [r1, #48]	@ 0x30
340295fc:	eea4 7b06 	vfma.f64	d7, d4, d6
34029600:	ee25 2b05 	vmul.f64	d2, d5, d5
34029604:	ee35 4b07 	vadd.f64	d4, d5, d7
34029608:	ee25 1b02 	vmul.f64	d1, d5, d2
3402960c:	ee37 0b44 	vsub.f64	d0, d7, d4
34029610:	ed91 7b02 	vldr	d7, [r1, #8]
34029614:	ee30 0b05 	vadd.f64	d0, d0, d5
34029618:	eea7 0b06 	vfma.f64	d0, d7, d6
3402961c:	ed91 7b04 	vldr	d7, [r1, #16]
34029620:	ed91 6b08 	vldr	d6, [r1, #32]
34029624:	eea7 0b02 	vfma.f64	d0, d7, d2
34029628:	ed91 7b06 	vldr	d7, [r1, #24]
3402962c:	eea6 7b05 	vfma.f64	d7, d6, d5
34029630:	ed91 6b0a 	vldr	d6, [r1, #40]	@ 0x28
34029634:	eea3 6b05 	vfma.f64	d6, d3, d5
34029638:	eea6 7b02 	vfma.f64	d7, d6, d2
3402963c:	eea1 0b07 	vfma.f64	d0, d1, d7
34029640:	ee30 0b04 	vadd.f64	d0, d0, d4
34029644:	e789      	b.n	3402955a <log+0xd2>
34029646:	ed9f 0b06 	vldr	d0, [pc, #24]	@ 34029660 <log+0x1d8>
3402964a:	e786      	b.n	3402955a <log+0xd2>
3402964c:	f3af 8000 	nop.w
34029650:	00000000 	.word	0x00000000
34029654:	41a00000 	.word	0x41a00000
34029658:	00000000 	.word	0x00000000
3402965c:	43300000 	.word	0x43300000
	...
34029668:	000308ff 	.word	0x000308ff
3402966c:	3ff00000 	.word	0x3ff00000
34029670:	3403f820 	.word	0x3403f820
34029674:	7ff00000 	.word	0x7ff00000

34029678 <checkint>:
34029678:	f3c1 520a 	ubfx	r2, r1, #20, #11
3402967c:	f240 33fe 	movw	r3, #1022	@ 0x3fe
34029680:	429a      	cmp	r2, r3
34029682:	b570      	push	{r4, r5, r6, lr}
34029684:	dd2a      	ble.n	340296dc <checkint+0x64>
34029686:	f240 4333 	movw	r3, #1075	@ 0x433
3402968a:	429a      	cmp	r2, r3
3402968c:	dc24      	bgt.n	340296d8 <checkint+0x60>
3402968e:	1a9b      	subs	r3, r3, r2
34029690:	f04f 32ff 	mov.w	r2, #4294967295
34029694:	f1a3 0620 	sub.w	r6, r3, #32
34029698:	fa02 f403 	lsl.w	r4, r2, r3
3402969c:	f1c3 0520 	rsb	r5, r3, #32
340296a0:	fa02 f606 	lsl.w	r6, r2, r6
340296a4:	fa22 f505 	lsr.w	r5, r2, r5
340296a8:	409a      	lsls	r2, r3
340296aa:	4334      	orrs	r4, r6
340296ac:	ea20 0202 	bic.w	r2, r0, r2
340296b0:	432c      	orrs	r4, r5
340296b2:	ea21 0404 	bic.w	r4, r1, r4
340296b6:	4322      	orrs	r2, r4
340296b8:	f1a3 0420 	sub.w	r4, r3, #32
340296bc:	f1c3 0220 	rsb	r2, r3, #32
340296c0:	d10c      	bne.n	340296dc <checkint+0x64>
340296c2:	40d8      	lsrs	r0, r3
340296c4:	fa01 f302 	lsl.w	r3, r1, r2
340296c8:	40e1      	lsrs	r1, r4
340296ca:	4318      	orrs	r0, r3
340296cc:	4308      	orrs	r0, r1
340296ce:	f000 0001 	and.w	r0, r0, #1
340296d2:	f1d0 0002 	rsbs	r0, r0, #2
340296d6:	bd70      	pop	{r4, r5, r6, pc}
340296d8:	2002      	movs	r0, #2
340296da:	e7fc      	b.n	340296d6 <checkint+0x5e>
340296dc:	2000      	movs	r0, #0
340296de:	e7fa      	b.n	340296d6 <checkint+0x5e>

340296e0 <pow>:
340296e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340296e4:	ee10 4a90 	vmov	r4, s1
340296e8:	f240 73fd 	movw	r3, #2045	@ 0x7fd
340296ec:	ee11 aa90 	vmov	sl, s3
340296f0:	ee10 5a10 	vmov	r5, s0
340296f4:	ea4f 5814 	mov.w	r8, r4, lsr #20
340296f8:	ee11 0a10 	vmov	r0, s2
340296fc:	ea4f 561a 	mov.w	r6, sl, lsr #20
34029700:	f108 32ff 	add.w	r2, r8, #4294967295
34029704:	46c4      	mov	ip, r8
34029706:	429a      	cmp	r2, r3
34029708:	ed2d 8b0a 	vpush	{d8-d12}
3402970c:	b087      	sub	sp, #28
3402970e:	d806      	bhi.n	3402971e <pow+0x3e>
34029710:	f3c6 030a 	ubfx	r3, r6, #0, #11
34029714:	f2a3 33be 	subw	r3, r3, #958	@ 0x3be
34029718:	2b7f      	cmp	r3, #127	@ 0x7f
3402971a:	f240 8157 	bls.w	340299cc <pow+0x2ec>
3402971e:	1802      	adds	r2, r0, r0
34029720:	f06f 0b01 	mvn.w	fp, #1
34029724:	f46f 1e00 	mvn.w	lr, #2097152	@ 0x200000
34029728:	eb4a 010a 	adc.w	r1, sl, sl
3402972c:	1e57      	subs	r7, r2, #1
3402972e:	f141 33ff 	adc.w	r3, r1, #4294967295
34029732:	45bb      	cmp	fp, r7
34029734:	eb7e 0303 	sbcs.w	r3, lr, r3
34029738:	d242      	bcs.n	340297c0 <pow+0xe0>
3402973a:	ea52 0301 	orrs.w	r3, r2, r1
3402973e:	f04f 0300 	mov.w	r3, #0
34029742:	d10c      	bne.n	3402975e <pow+0x7e>
34029744:	196d      	adds	r5, r5, r5
34029746:	f484 2400 	eor.w	r4, r4, #524288	@ 0x80000
3402974a:	4164      	adcs	r4, r4
3402974c:	42ab      	cmp	r3, r5
3402974e:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
34029752:	41a3      	sbcs	r3, r4
34029754:	f0c0 808f 	bcc.w	34029876 <pow+0x196>
34029758:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
3402975c:	e02b      	b.n	340297b6 <pow+0xd6>
3402975e:	4ed4      	ldr	r6, [pc, #848]	@ (34029ab0 <pow+0x3d0>)
34029760:	42b4      	cmp	r4, r6
34029762:	bf08      	it	eq
34029764:	429d      	cmpeq	r5, r3
34029766:	d109      	bne.n	3402977c <pow+0x9c>
34029768:	1800      	adds	r0, r0, r0
3402976a:	f48a 2a00 	eor.w	sl, sl, #524288	@ 0x80000
3402976e:	eb4a 0a0a 	adc.w	sl, sl, sl
34029772:	4283      	cmp	r3, r0
34029774:	4bcf      	ldr	r3, [pc, #828]	@ (34029ab4 <pow+0x3d4>)
34029776:	eb73 030a 	sbcs.w	r3, r3, sl
3402977a:	e7eb      	b.n	34029754 <pow+0x74>
3402977c:	196d      	adds	r5, r5, r5
3402977e:	48ce      	ldr	r0, [pc, #824]	@ (34029ab8 <pow+0x3d8>)
34029780:	4164      	adcs	r4, r4
34029782:	42ab      	cmp	r3, r5
34029784:	eb70 0604 	sbcs.w	r6, r0, r4
34029788:	d375      	bcc.n	34029876 <pow+0x196>
3402978a:	4281      	cmp	r1, r0
3402978c:	bf08      	it	eq
3402978e:	429a      	cmpeq	r2, r3
34029790:	d171      	bne.n	34029876 <pow+0x196>
34029792:	4aca      	ldr	r2, [pc, #808]	@ (34029abc <pow+0x3dc>)
34029794:	4294      	cmp	r4, r2
34029796:	bf08      	it	eq
34029798:	429d      	cmpeq	r5, r3
3402979a:	d0dd      	beq.n	34029758 <pow+0x78>
3402979c:	4294      	cmp	r4, r2
3402979e:	ea6f 0a0a 	mvn.w	sl, sl
340297a2:	bf34      	ite	cc
340297a4:	2400      	movcc	r4, #0
340297a6:	2401      	movcs	r4, #1
340297a8:	ea4f 7ada 	mov.w	sl, sl, lsr #31
340297ac:	4554      	cmp	r4, sl
340297ae:	f040 81dc 	bne.w	34029b6a <pow+0x48a>
340297b2:	ee21 0b01 	vmul.f64	d0, d1, d1
340297b6:	b007      	add	sp, #28
340297b8:	ecbd 8b0a 	vpop	{d8-d12}
340297bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
340297c0:	196f      	adds	r7, r5, r5
340297c2:	eb44 0904 	adc.w	r9, r4, r4
340297c6:	1e7a      	subs	r2, r7, #1
340297c8:	f169 0300 	sbc.w	r3, r9, #0
340297cc:	4593      	cmp	fp, r2
340297ce:	eb7e 0303 	sbcs.w	r3, lr, r3
340297d2:	d225      	bcs.n	34029820 <pow+0x140>
340297d4:	2c00      	cmp	r4, #0
340297d6:	ee20 0b00 	vmul.f64	d0, d0, d0
340297da:	da13      	bge.n	34029804 <pow+0x124>
340297dc:	4651      	mov	r1, sl
340297de:	f7ff ff4b 	bl	34029678 <checkint>
340297e2:	2801      	cmp	r0, #1
340297e4:	d10e      	bne.n	34029804 <pow+0x124>
340297e6:	eeb1 0b40 	vneg.f64	d0, d0
340297ea:	ea57 0909 	orrs.w	r9, r7, r9
340297ee:	d10b      	bne.n	34029808 <pow+0x128>
340297f0:	f1ba 0f00 	cmp.w	sl, #0
340297f4:	dadf      	bge.n	340297b6 <pow+0xd6>
340297f6:	b007      	add	sp, #28
340297f8:	ecbd 8b0a 	vpop	{d8-d12}
340297fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34029800:	f7ff bdfa 	b.w	340293f8 <__math_divzero>
34029804:	2000      	movs	r0, #0
34029806:	e7f0      	b.n	340297ea <pow+0x10a>
34029808:	f1ba 0f00 	cmp.w	sl, #0
3402980c:	dad3      	bge.n	340297b6 <pow+0xd6>
3402980e:	eeb7 6b00 	vmov.f64	d6, #112	@ 0x3f800000  1.0
34029812:	ee86 7b00 	vdiv.f64	d7, d6, d0
34029816:	ed8d 7b00 	vstr	d7, [sp]
3402981a:	ed9d 0b00 	vldr	d0, [sp]
3402981e:	e7ca      	b.n	340297b6 <pow+0xd6>
34029820:	2c00      	cmp	r4, #0
34029822:	da2b      	bge.n	3402987c <pow+0x19c>
34029824:	4651      	mov	r1, sl
34029826:	f7ff ff27 	bl	34029678 <checkint>
3402982a:	b930      	cbnz	r0, 3402983a <pow+0x15a>
3402982c:	b007      	add	sp, #28
3402982e:	ecbd 8b0a 	vpop	{d8-d12}
34029832:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34029836:	f7ff bdfb 	b.w	34029430 <__math_invalid>
3402983a:	1e41      	subs	r1, r0, #1
3402983c:	f024 4400 	bic.w	r4, r4, #2147483648	@ 0x80000000
34029840:	f3c8 0c0a 	ubfx	ip, r8, #0, #11
34029844:	4248      	negs	r0, r1
34029846:	4148      	adcs	r0, r1
34029848:	0480      	lsls	r0, r0, #18
3402984a:	f3c6 020a 	ubfx	r2, r6, #0, #11
3402984e:	f2a2 33be 	subw	r3, r2, #958	@ 0x3be
34029852:	2b7f      	cmp	r3, #127	@ 0x7f
34029854:	d92d      	bls.n	340298b2 <pow+0x1d2>
34029856:	2000      	movs	r0, #0
34029858:	4b95      	ldr	r3, [pc, #596]	@ (34029ab0 <pow+0x3d0>)
3402985a:	429c      	cmp	r4, r3
3402985c:	bf08      	it	eq
3402985e:	4285      	cmpeq	r5, r0
34029860:	f43f af7a 	beq.w	34029758 <pow+0x78>
34029864:	f240 31bd 	movw	r1, #957	@ 0x3bd
34029868:	428a      	cmp	r2, r1
3402986a:	d80c      	bhi.n	34029886 <pow+0x1a6>
3402986c:	42a8      	cmp	r0, r5
3402986e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
34029872:	41a3      	sbcs	r3, r4
34029874:	d204      	bcs.n	34029880 <pow+0x1a0>
34029876:	ee31 0b00 	vadd.f64	d0, d1, d0
3402987a:	e79c      	b.n	340297b6 <pow+0xd6>
3402987c:	2000      	movs	r0, #0
3402987e:	e7e4      	b.n	3402984a <pow+0x16a>
34029880:	ee30 0b41 	vsub.f64	d0, d0, d1
34029884:	e797      	b.n	340297b6 <pow+0xd6>
34029886:	2d01      	cmp	r5, #1
34029888:	f240 72ff 	movw	r2, #2047	@ 0x7ff
3402988c:	eb74 0303 	sbcs.w	r3, r4, r3
34029890:	bf34      	ite	cc
34029892:	2301      	movcc	r3, #1
34029894:	2300      	movcs	r3, #0
34029896:	4296      	cmp	r6, r2
34029898:	bf8c      	ite	hi
3402989a:	2600      	movhi	r6, #0
3402989c:	2601      	movls	r6, #1
3402989e:	42b3      	cmp	r3, r6
340298a0:	f000 809c 	beq.w	340299dc <pow+0x2fc>
340298a4:	b007      	add	sp, #28
340298a6:	ecbd 8b0a 	vpop	{d8-d12}
340298aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340298ae:	f7ff bd9b 	b.w	340293e8 <__math_oflow>
340298b2:	f1bc 0f00 	cmp.w	ip, #0
340298b6:	d10a      	bne.n	340298ce <pow+0x1ee>
340298b8:	ed9f 7b79 	vldr	d7, [pc, #484]	@ 34029aa0 <pow+0x3c0>
340298bc:	ee20 7b07 	vmul.f64	d7, d0, d7
340298c0:	ec53 2b17 	vmov	r2, r3, d7
340298c4:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
340298c8:	4615      	mov	r5, r2
340298ca:	f1a4 7450 	sub.w	r4, r4, #54525952	@ 0x3400000
340298ce:	4a7c      	ldr	r2, [pc, #496]	@ (34029ac0 <pow+0x3e0>)
340298d0:	eebf 6b00 	vmov.f64	d6, #240	@ 0xbf800000 -1.0
340298d4:	4422      	add	r2, r4
340298d6:	1513      	asrs	r3, r2, #20
340298d8:	f3c2 3146 	ubfx	r1, r2, #13, #7
340298dc:	f36f 0213 	bfc	r2, #0, #20
340298e0:	ee03 3a10 	vmov	s6, r3
340298e4:	4b77      	ldr	r3, [pc, #476]	@ (34029ac4 <pow+0x3e4>)
340298e6:	1aa7      	subs	r7, r4, r2
340298e8:	eb03 1641 	add.w	r6, r3, r1, lsl #5
340298ec:	eeb8 3bc3 	vcvt.f64.s32	d3, s6
340298f0:	eb03 1241 	add.w	r2, r3, r1, lsl #5
340298f4:	ed96 7b18 	vldr	d7, [r6, #96]	@ 0x60
340298f8:	ed92 5b12 	vldr	d5, [r2, #72]	@ 0x48
340298fc:	1e2e      	subs	r6, r5, #0
340298fe:	ec47 6b14 	vmov	d4, r6, r7
34029902:	eea4 6b05 	vfma.f64	d6, d4, d5
34029906:	ed92 2b16 	vldr	d2, [r2, #88]	@ 0x58
3402990a:	ed93 5b00 	vldr	d5, [r3]
3402990e:	ed93 cb10 	vldr	d12, [r3, #64]	@ 0x40
34029912:	f46f 7272 	mvn.w	r2, #968	@ 0x3c8
34029916:	eea3 2b05 	vfma.f64	d2, d3, d5
3402991a:	ed93 5b02 	vldr	d5, [r3, #8]
3402991e:	eea3 7b05 	vfma.f64	d7, d3, d5
34029922:	ee36 4b02 	vadd.f64	d4, d6, d2
34029926:	ed93 5b04 	vldr	d5, [r3, #16]
3402992a:	ee32 2b44 	vsub.f64	d2, d2, d4
3402992e:	ee26 5b05 	vmul.f64	d5, d6, d5
34029932:	ee32 2b06 	vadd.f64	d2, d2, d6
34029936:	ed93 3b0c 	vldr	d3, [r3, #48]	@ 0x30
3402993a:	ee26 0b05 	vmul.f64	d0, d6, d5
3402993e:	ee37 7b02 	vadd.f64	d7, d7, d2
34029942:	ee34 8b00 	vadd.f64	d8, d4, d0
34029946:	eeb0 9b40 	vmov.f64	d9, d0
3402994a:	ee26 bb00 	vmul.f64	d11, d6, d0
3402994e:	ee34 4b48 	vsub.f64	d4, d4, d8
34029952:	ee96 9b05 	vfnms.f64	d9, d6, d5
34029956:	ee34 ab00 	vadd.f64	d10, d4, d0
3402995a:	ed93 5b06 	vldr	d5, [r3, #24]
3402995e:	ed93 4b08 	vldr	d4, [r3, #32]
34029962:	eea6 5b04 	vfma.f64	d5, d6, d4
34029966:	ee37 7b09 	vadd.f64	d7, d7, d9
3402996a:	ed93 4b0a 	vldr	d4, [r3, #40]	@ 0x28
3402996e:	ee37 7b0a 	vadd.f64	d7, d7, d10
34029972:	eea6 4b03 	vfma.f64	d4, d6, d3
34029976:	ed93 3b0e 	vldr	d3, [r3, #56]	@ 0x38
3402997a:	eea6 3b0c 	vfma.f64	d3, d6, d12
3402997e:	eea0 4b03 	vfma.f64	d4, d0, d3
34029982:	eea0 5b04 	vfma.f64	d5, d0, d4
34029986:	eeab 7b05 	vfma.f64	d7, d11, d5
3402998a:	ee38 4b07 	vadd.f64	d4, d8, d7
3402998e:	ee21 6b04 	vmul.f64	d6, d1, d4
34029992:	ee38 8b44 	vsub.f64	d8, d8, d4
34029996:	eeb0 5b46 	vmov.f64	d5, d6
3402999a:	ee16 3a90 	vmov	r3, s13
3402999e:	ee38 8b07 	vadd.f64	d8, d8, d7
340299a2:	f3c3 560a 	ubfx	r6, r3, #20, #11
340299a6:	ee91 5b04 	vfnms.f64	d5, d1, d4
340299aa:	18b2      	adds	r2, r6, r2
340299ac:	2a3e      	cmp	r2, #62	@ 0x3e
340299ae:	eea1 5b08 	vfma.f64	d5, d1, d8
340299b2:	d91b      	bls.n	340299ec <pow+0x30c>
340299b4:	2a00      	cmp	r2, #0
340299b6:	da0b      	bge.n	340299d0 <pow+0x2f0>
340299b8:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
340299bc:	ee36 0b00 	vadd.f64	d0, d6, d0
340299c0:	2800      	cmp	r0, #0
340299c2:	f43f aef8 	beq.w	340297b6 <pow+0xd6>
340299c6:	eeb1 0b40 	vneg.f64	d0, d0
340299ca:	e6f4      	b.n	340297b6 <pow+0xd6>
340299cc:	2000      	movs	r0, #0
340299ce:	e77e      	b.n	340298ce <pow+0x1ee>
340299d0:	f5b6 6f81 	cmp.w	r6, #1032	@ 0x408
340299d4:	d909      	bls.n	340299ea <pow+0x30a>
340299d6:	2b00      	cmp	r3, #0
340299d8:	f6bf af64 	bge.w	340298a4 <pow+0x1c4>
340299dc:	b007      	add	sp, #28
340299de:	ecbd 8b0a 	vpop	{d8-d12}
340299e2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
340299e6:	f7ff bcf7 	b.w	340293d8 <__math_uflow>
340299ea:	2600      	movs	r6, #0
340299ec:	4936      	ldr	r1, [pc, #216]	@ (34029ac8 <pow+0x3e8>)
340299ee:	2700      	movs	r7, #0
340299f0:	ed91 4b02 	vldr	d4, [r1, #8]
340299f4:	ed91 3b00 	vldr	d3, [r1]
340299f8:	eeb0 7b44 	vmov.f64	d7, d4
340299fc:	eea6 7b03 	vfma.f64	d7, d6, d3
34029a00:	ed91 3b0a 	vldr	d3, [r1, #40]	@ 0x28
34029a04:	ee17 5a10 	vmov	r5, s14
34029a08:	ee37 7b44 	vsub.f64	d7, d7, d4
34029a0c:	ed91 4b04 	vldr	d4, [r1, #16]
34029a10:	f005 037f 	and.w	r3, r5, #127	@ 0x7f
34029a14:	eea7 6b04 	vfma.f64	d6, d7, d4
34029a18:	18dc      	adds	r4, r3, r3
34029a1a:	1940      	adds	r0, r0, r5
34029a1c:	f104 030f 	add.w	r3, r4, #15
34029a20:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
34029a24:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
34029a28:	f851 c033 	ldr.w	ip, [r1, r3, lsl #3]
34029a2c:	ed91 4b06 	vldr	d4, [r1, #24]
34029a30:	f8d2 e004 	ldr.w	lr, [r2, #4]
34029a34:	eb17 020c 	adds.w	r2, r7, ip
34029a38:	eb0e 3340 	add.w	r3, lr, r0, lsl #13
34029a3c:	eea7 6b04 	vfma.f64	d6, d7, d4
34029a40:	ed91 4b08 	vldr	d4, [r1, #32]
34029a44:	ed94 7b1c 	vldr	d7, [r4, #112]	@ 0x70
34029a48:	ee35 5b06 	vadd.f64	d5, d5, d6
34029a4c:	eea5 4b03 	vfma.f64	d4, d5, d3
34029a50:	ee25 6b05 	vmul.f64	d6, d5, d5
34029a54:	ee35 7b07 	vadd.f64	d7, d5, d7
34029a58:	ed91 3b0e 	vldr	d3, [r1, #56]	@ 0x38
34029a5c:	eea6 7b04 	vfma.f64	d7, d6, d4
34029a60:	ee26 6b06 	vmul.f64	d6, d6, d6
34029a64:	ed91 4b0c 	vldr	d4, [r1, #48]	@ 0x30
34029a68:	eea5 4b03 	vfma.f64	d4, d5, d3
34029a6c:	eea6 7b04 	vfma.f64	d7, d6, d4
34029a70:	2e00      	cmp	r6, #0
34029a72:	d175      	bne.n	34029b60 <pow+0x480>
34029a74:	42bd      	cmp	r5, r7
34029a76:	db29      	blt.n	34029acc <pow+0x3ec>
34029a78:	f103 4140 	add.w	r1, r3, #3221225472	@ 0xc0000000
34029a7c:	4610      	mov	r0, r2
34029a7e:	f501 0170 	add.w	r1, r1, #15728640	@ 0xf00000
34029a82:	ec41 0b10 	vmov	d0, r0, r1
34029a86:	eea7 0b00 	vfma.f64	d0, d7, d0
34029a8a:	ed9f 7b07 	vldr	d7, [pc, #28]	@ 34029aa8 <pow+0x3c8>
34029a8e:	ee20 0b07 	vmul.f64	d0, d0, d7
34029a92:	b007      	add	sp, #28
34029a94:	ecbd 8b0a 	vpop	{d8-d12}
34029a98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34029a9c:	f7ff bce0 	b.w	34029460 <__math_check_oflow>
34029aa0:	00000000 	.word	0x00000000
34029aa4:	43300000 	.word	0x43300000
34029aa8:	00000000 	.word	0x00000000
34029aac:	7f000000 	.word	0x7f000000
34029ab0:	3ff00000 	.word	0x3ff00000
34029ab4:	fff00000 	.word	0xfff00000
34029ab8:	ffe00000 	.word	0xffe00000
34029abc:	7fe00000 	.word	0x7fe00000
34029ac0:	c0196aab 	.word	0xc0196aab
34029ac4:	340400b0 	.word	0x340400b0
34029ac8:	3403efb0 	.word	0x3403efb0
34029acc:	f103 517f 	add.w	r1, r3, #1069547520	@ 0x3fc00000
34029ad0:	4610      	mov	r0, r2
34029ad2:	eeb7 3b00 	vmov.f64	d3, #112	@ 0x3f800000  1.0
34029ad6:	f501 1100 	add.w	r1, r1, #2097152	@ 0x200000
34029ada:	ec41 0b15 	vmov	d5, r0, r1
34029ade:	ee27 6b05 	vmul.f64	d6, d7, d5
34029ae2:	ed9f 0b23 	vldr	d0, [pc, #140]	@ 34029b70 <pow+0x490>
34029ae6:	ee35 7b06 	vadd.f64	d7, d5, d6
34029aea:	eeb0 4bc7 	vabs.f64	d4, d7
34029aee:	eeb4 4bc3 	vcmpe.f64	d4, d3
34029af2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029af6:	d52a      	bpl.n	34029b4e <pow+0x46e>
34029af8:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
34029afc:	eebf 4b00 	vmov.f64	d4, #240	@ 0xbf800000 -1.0
34029b00:	ee35 5b47 	vsub.f64	d5, d5, d7
34029b04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029b08:	ee35 5b06 	vadd.f64	d5, d5, d6
34029b0c:	bf58      	it	pl
34029b0e:	eeb0 4b43 	vmovpl.f64	d4, d3
34029b12:	ee37 3b04 	vadd.f64	d3, d7, d4
34029b16:	ee34 6b43 	vsub.f64	d6, d4, d3
34029b1a:	ee36 6b07 	vadd.f64	d6, d6, d7
34029b1e:	ee36 6b05 	vadd.f64	d6, d6, d5
34029b22:	ee36 6b03 	vadd.f64	d6, d6, d3
34029b26:	ee36 7b44 	vsub.f64	d7, d6, d4
34029b2a:	eeb5 7b40 	vcmp.f64	d7, #0.0
34029b2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029b32:	d104      	bne.n	34029b3e <pow+0x45e>
34029b34:	4632      	mov	r2, r6
34029b36:	f001 4300 	and.w	r3, r1, #2147483648	@ 0x80000000
34029b3a:	ec43 2b17 	vmov	d7, r2, r3
34029b3e:	ed8d 0b02 	vstr	d0, [sp, #8]
34029b42:	ed9d 6b02 	vldr	d6, [sp, #8]
34029b46:	ee26 6b00 	vmul.f64	d6, d6, d0
34029b4a:	ed8d 6b04 	vstr	d6, [sp, #16]
34029b4e:	ee27 0b00 	vmul.f64	d0, d7, d0
34029b52:	b007      	add	sp, #28
34029b54:	ecbd 8b0a 	vpop	{d8-d12}
34029b58:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
34029b5c:	f7ff bc77 	b.w	3402944e <__math_check_uflow>
34029b60:	ec43 2b10 	vmov	d0, r2, r3
34029b64:	eea7 0b00 	vfma.f64	d0, d7, d0
34029b68:	e625      	b.n	340297b6 <pow+0xd6>
34029b6a:	ed9f 0b03 	vldr	d0, [pc, #12]	@ 34029b78 <pow+0x498>
34029b6e:	e622      	b.n	340297b6 <pow+0xd6>
34029b70:	00000000 	.word	0x00000000
34029b74:	00100000 	.word	0x00100000
	...

34029b80 <expf>:
34029b80:	ee10 2a10 	vmov	r2, s0
34029b84:	f240 412a 	movw	r1, #1066	@ 0x42a
34029b88:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
34029b8c:	f3c2 530a 	ubfx	r3, r2, #20, #11
34029b90:	428b      	cmp	r3, r1
34029b92:	b430      	push	{r4, r5}
34029b94:	d92a      	bls.n	34029bec <expf+0x6c>
34029b96:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
34029b9a:	d058      	beq.n	34029c4e <expf+0xce>
34029b9c:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
34029ba0:	d303      	bcc.n	34029baa <expf+0x2a>
34029ba2:	ee30 0a00 	vadd.f32	s0, s0, s0
34029ba6:	bc30      	pop	{r4, r5}
34029ba8:	4770      	bx	lr
34029baa:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 34029c54 <expf+0xd4>
34029bae:	eeb4 0ae7 	vcmpe.f32	s0, s15
34029bb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029bb6:	dd03      	ble.n	34029bc0 <expf+0x40>
34029bb8:	2000      	movs	r0, #0
34029bba:	bc30      	pop	{r4, r5}
34029bbc:	f000 b9f2 	b.w	34029fa4 <__math_oflowf>
34029bc0:	eddf 7a25 	vldr	s15, [pc, #148]	@ 34029c58 <expf+0xd8>
34029bc4:	eeb4 0ae7 	vcmpe.f32	s0, s15
34029bc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029bcc:	d503      	bpl.n	34029bd6 <expf+0x56>
34029bce:	2000      	movs	r0, #0
34029bd0:	bc30      	pop	{r4, r5}
34029bd2:	f000 b9db 	b.w	34029f8c <__math_uflowf>
34029bd6:	eddf 7a21 	vldr	s15, [pc, #132]	@ 34029c5c <expf+0xdc>
34029bda:	eeb4 0ae7 	vcmpe.f32	s0, s15
34029bde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029be2:	d503      	bpl.n	34029bec <expf+0x6c>
34029be4:	2000      	movs	r0, #0
34029be6:	bc30      	pop	{r4, r5}
34029be8:	f000 b9d6 	b.w	34029f98 <__math_may_uflowf>
34029bec:	4b1c      	ldr	r3, [pc, #112]	@ (34029c60 <expf+0xe0>)
34029bee:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
34029bf2:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
34029bf6:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
34029bfa:	eeb0 7b44 	vmov.f64	d7, d4
34029bfe:	eea5 7b06 	vfma.f64	d7, d5, d6
34029c02:	ee17 0a10 	vmov	r0, s14
34029c06:	ee37 7b44 	vsub.f64	d7, d7, d4
34029c0a:	f000 021f 	and.w	r2, r0, #31
34029c0e:	ee95 7b06 	vfnms.f64	d7, d5, d6
34029c12:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
34029c16:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
34029c1a:	684d      	ldr	r5, [r1, #4]
34029c1c:	2100      	movs	r1, #0
34029c1e:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
34029c22:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
34029c26:	190a      	adds	r2, r1, r4
34029c28:	eea5 6b07 	vfma.f64	d6, d5, d7
34029c2c:	ee27 4b07 	vmul.f64	d4, d7, d7
34029c30:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
34029c34:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
34029c38:	eea5 0b07 	vfma.f64	d0, d5, d7
34029c3c:	ec43 2b17 	vmov	d7, r2, r3
34029c40:	eea6 0b04 	vfma.f64	d0, d6, d4
34029c44:	ee20 0b07 	vmul.f64	d0, d0, d7
34029c48:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34029c4c:	e7ab      	b.n	34029ba6 <expf+0x26>
34029c4e:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 34029c64 <expf+0xe4>
34029c52:	e7a8      	b.n	34029ba6 <expf+0x26>
34029c54:	42b17217 	.word	0x42b17217
34029c58:	c2cff1b4 	.word	0xc2cff1b4
34029c5c:	c2ce8ecf 	.word	0xc2ce8ecf
34029c60:	340410f8 	.word	0x340410f8
34029c64:	00000000 	.word	0x00000000

34029c68 <checkint>:
34029c68:	f3c0 53c7 	ubfx	r3, r0, #23, #8
34029c6c:	2b7e      	cmp	r3, #126	@ 0x7e
34029c6e:	d910      	bls.n	34029c92 <checkint+0x2a>
34029c70:	2b96      	cmp	r3, #150	@ 0x96
34029c72:	d80c      	bhi.n	34029c8e <checkint+0x26>
34029c74:	2201      	movs	r2, #1
34029c76:	f1c3 0396 	rsb	r3, r3, #150	@ 0x96
34029c7a:	fa02 f303 	lsl.w	r3, r2, r3
34029c7e:	1e5a      	subs	r2, r3, #1
34029c80:	4202      	tst	r2, r0
34029c82:	d106      	bne.n	34029c92 <checkint+0x2a>
34029c84:	4203      	tst	r3, r0
34029c86:	bf14      	ite	ne
34029c88:	2001      	movne	r0, #1
34029c8a:	2002      	moveq	r0, #2
34029c8c:	4770      	bx	lr
34029c8e:	2002      	movs	r0, #2
34029c90:	4770      	bx	lr
34029c92:	2000      	movs	r0, #0
34029c94:	4770      	bx	lr
	...

34029c98 <powf>:
34029c98:	b537      	push	{r0, r1, r2, r4, r5, lr}
34029c9a:	ee10 1a10 	vmov	r1, s0
34029c9e:	ee10 4a90 	vmov	r4, s1
34029ca2:	eef0 7a40 	vmov.f32	s15, s0
34029ca6:	f5a1 0200 	sub.w	r2, r1, #8388608	@ 0x800000
34029caa:	0063      	lsls	r3, r4, #1
34029cac:	eeb0 7a60 	vmov.f32	s14, s1
34029cb0:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
34029cb4:	f103 30ff 	add.w	r0, r3, #4294967295
34029cb8:	f06f 7280 	mvn.w	r2, #16777216	@ 0x1000000
34029cbc:	d252      	bcs.n	34029d64 <powf+0xcc>
34029cbe:	4290      	cmp	r0, r2
34029cc0:	d258      	bcs.n	34029d74 <powf+0xdc>
34029cc2:	2000      	movs	r0, #0
34029cc4:	f101 4340 	add.w	r3, r1, #3221225472	@ 0xc0000000
34029cc8:	4a9f      	ldr	r2, [pc, #636]	@ (34029f48 <powf+0x2b0>)
34029cca:	eebf 2b00 	vmov.f64	d2, #240	@ 0xbf800000 -1.0
34029cce:	f503 034d 	add.w	r3, r3, #13434880	@ 0xcd0000
34029cd2:	f3c3 44c3 	ubfx	r4, r3, #19, #4
34029cd6:	f36f 0316 	bfc	r3, #0, #23
34029cda:	1ac9      	subs	r1, r1, r3
34029cdc:	eb02 1404 	add.w	r4, r2, r4, lsl #4
34029ce0:	15db      	asrs	r3, r3, #23
34029ce2:	ee07 1a90 	vmov	s15, r1
34029ce6:	ed94 4b00 	vldr	d4, [r4]
34029cea:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
34029cee:	ee07 3a90 	vmov	s15, r3
34029cf2:	ed94 5b02 	vldr	d5, [r4, #8]
34029cf6:	eea4 2b06 	vfma.f64	d2, d4, d6
34029cfa:	eeb8 6be7 	vcvt.f64.s32	d6, s15
34029cfe:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
34029d02:	ee36 6b05 	vadd.f64	d6, d6, d5
34029d06:	ed92 1b42 	vldr	d1, [r2, #264]	@ 0x108
34029d0a:	ed92 5b40 	vldr	d5, [r2, #256]	@ 0x100
34029d0e:	ed92 3b44 	vldr	d3, [r2, #272]	@ 0x110
34029d12:	ee22 4b02 	vmul.f64	d4, d2, d2
34029d16:	eea2 1b05 	vfma.f64	d1, d2, d5
34029d1a:	ee24 0b04 	vmul.f64	d0, d4, d4
34029d1e:	ed92 5b46 	vldr	d5, [r2, #280]	@ 0x118
34029d22:	eea2 5b03 	vfma.f64	d5, d2, d3
34029d26:	ed92 3b48 	vldr	d3, [r2, #288]	@ 0x120
34029d2a:	eea2 6b03 	vfma.f64	d6, d2, d3
34029d2e:	eea4 6b05 	vfma.f64	d6, d4, d5
34029d32:	eea1 6b00 	vfma.f64	d6, d1, d0
34029d36:	ee27 7b06 	vmul.f64	d7, d7, d6
34029d3a:	ee17 3a90 	vmov	r3, s15
34029d3e:	f3c3 32cf 	ubfx	r2, r3, #15, #16
34029d42:	f248 03bf 	movw	r3, #32959	@ 0x80bf
34029d46:	429a      	cmp	r2, r3
34029d48:	f0c0 8098 	bcc.w	34029e7c <powf+0x1e4>
34029d4c:	ed9f 6b76 	vldr	d6, [pc, #472]	@ 34029f28 <powf+0x290>
34029d50:	eeb4 7bc6 	vcmpe.f64	d7, d6
34029d54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029d58:	dd79      	ble.n	34029e4e <powf+0x1b6>
34029d5a:	b003      	add	sp, #12
34029d5c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34029d60:	f000 b920 	b.w	34029fa4 <__math_oflowf>
34029d64:	4290      	cmp	r0, r2
34029d66:	d330      	bcc.n	34029dca <powf+0x132>
34029d68:	b12b      	cbz	r3, 34029d76 <powf+0xde>
34029d6a:	0049      	lsls	r1, r1, #1
34029d6c:	f1b1 4f7f 	cmp.w	r1, #4278190080	@ 0xff000000
34029d70:	d808      	bhi.n	34029d84 <powf+0xec>
34029d72:	e015      	b.n	34029da0 <powf+0x108>
34029d74:	b953      	cbnz	r3, 34029d8c <powf+0xf4>
34029d76:	f481 0180 	eor.w	r1, r1, #4194304	@ 0x400000
34029d7a:	0049      	lsls	r1, r1, #1
34029d7c:	f511 0f00 	cmn.w	r1, #8388608	@ 0x800000
34029d80:	f240 80ca 	bls.w	34029f18 <powf+0x280>
34029d84:	ee37 0a87 	vadd.f32	s0, s15, s14
34029d88:	b003      	add	sp, #12
34029d8a:	bd30      	pop	{r4, r5, pc}
34029d8c:	f1b1 5f7e 	cmp.w	r1, #1065353216	@ 0x3f800000
34029d90:	d105      	bne.n	34029d9e <powf+0x106>
34029d92:	f484 0480 	eor.w	r4, r4, #4194304	@ 0x400000
34029d96:	0064      	lsls	r4, r4, #1
34029d98:	f514 0f00 	cmn.w	r4, #8388608	@ 0x800000
34029d9c:	e7f0      	b.n	34029d80 <powf+0xe8>
34029d9e:	0049      	lsls	r1, r1, #1
34029da0:	f1b3 4f7f 	cmp.w	r3, #4278190080	@ 0xff000000
34029da4:	d1ee      	bne.n	34029d84 <powf+0xec>
34029da6:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
34029daa:	f000 80b5 	beq.w	34029f18 <powf+0x280>
34029dae:	f1b1 4ffe 	cmp.w	r1, #2130706432	@ 0x7f000000
34029db2:	ea6f 0404 	mvn.w	r4, r4
34029db6:	bf34      	ite	cc
34029db8:	2100      	movcc	r1, #0
34029dba:	2101      	movcs	r1, #1
34029dbc:	0fe4      	lsrs	r4, r4, #31
34029dbe:	42a1      	cmp	r1, r4
34029dc0:	f040 80ad 	bne.w	34029f1e <powf+0x286>
34029dc4:	ee27 0a07 	vmul.f32	s0, s14, s14
34029dc8:	e7de      	b.n	34029d88 <powf+0xf0>
34029dca:	004d      	lsls	r5, r1, #1
34029dcc:	1e6b      	subs	r3, r5, #1
34029dce:	4293      	cmp	r3, r2
34029dd0:	d31b      	bcc.n	34029e0a <powf+0x172>
34029dd2:	2900      	cmp	r1, #0
34029dd4:	ee20 0a00 	vmul.f32	s0, s0, s0
34029dd8:	da0e      	bge.n	34029df8 <powf+0x160>
34029dda:	4620      	mov	r0, r4
34029ddc:	f7ff ff44 	bl	34029c68 <checkint>
34029de0:	2801      	cmp	r0, #1
34029de2:	d109      	bne.n	34029df8 <powf+0x160>
34029de4:	eeb1 0a40 	vneg.f32	s0, s0
34029de8:	b945      	cbnz	r5, 34029dfc <powf+0x164>
34029dea:	2c00      	cmp	r4, #0
34029dec:	dacc      	bge.n	34029d88 <powf+0xf0>
34029dee:	b003      	add	sp, #12
34029df0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34029df4:	f000 b8dc 	b.w	34029fb0 <__math_divzerof>
34029df8:	2000      	movs	r0, #0
34029dfa:	e7f5      	b.n	34029de8 <powf+0x150>
34029dfc:	2c00      	cmp	r4, #0
34029dfe:	dac3      	bge.n	34029d88 <powf+0xf0>
34029e00:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34029e04:	ee87 0a80 	vdiv.f32	s0, s15, s0
34029e08:	e7be      	b.n	34029d88 <powf+0xf0>
34029e0a:	2900      	cmp	r1, #0
34029e0c:	da1d      	bge.n	34029e4a <powf+0x1b2>
34029e0e:	4620      	mov	r0, r4
34029e10:	f7ff ff2a 	bl	34029c68 <checkint>
34029e14:	b920      	cbnz	r0, 34029e20 <powf+0x188>
34029e16:	b003      	add	sp, #12
34029e18:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34029e1c:	f000 b8da 	b.w	34029fd4 <__math_invalidf>
34029e20:	1e43      	subs	r3, r0, #1
34029e22:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
34029e26:	4258      	negs	r0, r3
34029e28:	4158      	adcs	r0, r3
34029e2a:	0400      	lsls	r0, r0, #16
34029e2c:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
34029e30:	f4bf af48 	bcs.w	34029cc4 <powf+0x2c>
34029e34:	eddf 6a45 	vldr	s13, [pc, #276]	@ 34029f4c <powf+0x2b4>
34029e38:	ee27 0aa6 	vmul.f32	s0, s15, s13
34029e3c:	ee10 3a10 	vmov	r3, s0
34029e40:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34029e44:	f1a3 6138 	sub.w	r1, r3, #192937984	@ 0xb800000
34029e48:	e73c      	b.n	34029cc4 <powf+0x2c>
34029e4a:	2000      	movs	r0, #0
34029e4c:	e7ee      	b.n	34029e2c <powf+0x194>
34029e4e:	ed9f 6b38 	vldr	d6, [pc, #224]	@ 34029f30 <powf+0x298>
34029e52:	eeb4 7bc6 	vcmpe.f64	d7, d6
34029e56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029e5a:	dd45      	ble.n	34029ee8 <powf+0x250>
34029e5c:	f04f 534c 	mov.w	r3, #855638016	@ 0x33000000
34029e60:	b3d0      	cbz	r0, 34029ed8 <powf+0x240>
34029e62:	eebf 6a00 	vmov.f32	s12, #240	@ 0xbf800000 -1.0
34029e66:	9301      	str	r3, [sp, #4]
34029e68:	eddd 6a01 	vldr	s13, [sp, #4]
34029e6c:	ee76 6a66 	vsub.f32	s13, s12, s13
34029e70:	eef4 6a46 	vcmp.f32	s13, s12
34029e74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029e78:	f47f af6f 	bne.w	34029d5a <powf+0xc2>
34029e7c:	4b34      	ldr	r3, [pc, #208]	@ (34029f50 <powf+0x2b8>)
34029e7e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
34029e82:	ed93 5b40 	vldr	d5, [r3, #256]	@ 0x100
34029e86:	ee37 6b05 	vadd.f64	d6, d7, d5
34029e8a:	ee16 2a10 	vmov	r2, s12
34029e8e:	ee36 6b45 	vsub.f64	d6, d6, d5
34029e92:	ed93 5b42 	vldr	d5, [r3, #264]	@ 0x108
34029e96:	ee37 7b46 	vsub.f64	d7, d7, d6
34029e9a:	f002 011f 	and.w	r1, r2, #31
34029e9e:	1880      	adds	r0, r0, r2
34029ea0:	eb03 05c1 	add.w	r5, r3, r1, lsl #3
34029ea4:	f853 4031 	ldr.w	r4, [r3, r1, lsl #3]
34029ea8:	ee27 4b07 	vmul.f64	d4, d7, d7
34029eac:	2100      	movs	r1, #0
34029eae:	686d      	ldr	r5, [r5, #4]
34029eb0:	190a      	adds	r2, r1, r4
34029eb2:	ed93 6b44 	vldr	d6, [r3, #272]	@ 0x110
34029eb6:	eea7 6b05 	vfma.f64	d6, d7, d5
34029eba:	ed93 5b46 	vldr	d5, [r3, #280]	@ 0x118
34029ebe:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
34029ec2:	eea7 0b05 	vfma.f64	d0, d7, d5
34029ec6:	ec43 2b17 	vmov	d7, r2, r3
34029eca:	eea6 0b04 	vfma.f64	d0, d6, d4
34029ece:	ee20 0b07 	vmul.f64	d0, d0, d7
34029ed2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
34029ed6:	e757      	b.n	34029d88 <powf+0xf0>
34029ed8:	eeb7 6a00 	vmov.f32	s12, #112	@ 0x3f800000  1.0
34029edc:	9300      	str	r3, [sp, #0]
34029ede:	eddd 6a00 	vldr	s13, [sp]
34029ee2:	ee76 6a86 	vadd.f32	s13, s13, s12
34029ee6:	e7c3      	b.n	34029e70 <powf+0x1d8>
34029ee8:	ed9f 6b13 	vldr	d6, [pc, #76]	@ 34029f38 <powf+0x2a0>
34029eec:	eeb4 7bc6 	vcmpe.f64	d7, d6
34029ef0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029ef4:	d804      	bhi.n	34029f00 <powf+0x268>
34029ef6:	b003      	add	sp, #12
34029ef8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34029efc:	f000 b846 	b.w	34029f8c <__math_uflowf>
34029f00:	ed9f 6b0f 	vldr	d6, [pc, #60]	@ 34029f40 <powf+0x2a8>
34029f04:	eeb4 7bc6 	vcmpe.f64	d7, d6
34029f08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029f0c:	d5b6      	bpl.n	34029e7c <powf+0x1e4>
34029f0e:	b003      	add	sp, #12
34029f10:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
34029f14:	f000 b840 	b.w	34029f98 <__math_may_uflowf>
34029f18:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
34029f1c:	e734      	b.n	34029d88 <powf+0xf0>
34029f1e:	ed9f 0a0d 	vldr	s0, [pc, #52]	@ 34029f54 <powf+0x2bc>
34029f22:	e731      	b.n	34029d88 <powf+0xf0>
34029f24:	f3af 8000 	nop.w
34029f28:	ffd1d571 	.word	0xffd1d571
34029f2c:	405fffff 	.word	0x405fffff
34029f30:	ffa3aae2 	.word	0xffa3aae2
34029f34:	405fffff 	.word	0x405fffff
34029f38:	00000000 	.word	0x00000000
34029f3c:	c062c000 	.word	0xc062c000
34029f40:	00000000 	.word	0x00000000
34029f44:	c062a000 	.word	0xc062a000
34029f48:	34041240 	.word	0x34041240
34029f4c:	4b000000 	.word	0x4b000000
34029f50:	340410f8 	.word	0x340410f8
34029f54:	00000000 	.word	0x00000000

34029f58 <with_errnof>:
34029f58:	b510      	push	{r4, lr}
34029f5a:	ed2d 8b02 	vpush	{d8}
34029f5e:	eeb0 8a40 	vmov.f32	s16, s0
34029f62:	4604      	mov	r4, r0
34029f64:	f7fd fb6a 	bl	3402763c <__errno>
34029f68:	6004      	str	r4, [r0, #0]
34029f6a:	eeb0 0a48 	vmov.f32	s0, s16
34029f6e:	ecbd 8b02 	vpop	{d8}
34029f72:	bd10      	pop	{r4, pc}

34029f74 <xflowf>:
34029f74:	b130      	cbz	r0, 34029f84 <xflowf+0x10>
34029f76:	eef1 7a40 	vneg.f32	s15, s0
34029f7a:	ee27 0a80 	vmul.f32	s0, s15, s0
34029f7e:	2022      	movs	r0, #34	@ 0x22
34029f80:	f7ff bfea 	b.w	34029f58 <with_errnof>
34029f84:	eef0 7a40 	vmov.f32	s15, s0
34029f88:	e7f7      	b.n	34029f7a <xflowf+0x6>
	...

34029f8c <__math_uflowf>:
34029f8c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34029f94 <__math_uflowf+0x8>
34029f90:	f7ff bff0 	b.w	34029f74 <xflowf>
34029f94:	10000000 	.word	0x10000000

34029f98 <__math_may_uflowf>:
34029f98:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34029fa0 <__math_may_uflowf+0x8>
34029f9c:	f7ff bfea 	b.w	34029f74 <xflowf>
34029fa0:	1a200000 	.word	0x1a200000

34029fa4 <__math_oflowf>:
34029fa4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 34029fac <__math_oflowf+0x8>
34029fa8:	f7ff bfe4 	b.w	34029f74 <xflowf>
34029fac:	70000000 	.word	0x70000000

34029fb0 <__math_divzerof>:
34029fb0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
34029fb4:	2800      	cmp	r0, #0
34029fb6:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
34029fba:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 34029fd0 <__math_divzerof+0x20>
34029fbe:	f04f 0022 	mov.w	r0, #34	@ 0x22
34029fc2:	fe47 7a87 	vseleq.f32	s15, s15, s14
34029fc6:	ee87 0a80 	vdiv.f32	s0, s15, s0
34029fca:	f7ff bfc5 	b.w	34029f58 <with_errnof>
34029fce:	bf00      	nop
34029fd0:	00000000 	.word	0x00000000

34029fd4 <__math_invalidf>:
34029fd4:	eef0 7a40 	vmov.f32	s15, s0
34029fd8:	ee30 7a40 	vsub.f32	s14, s0, s0
34029fdc:	eef4 7a67 	vcmp.f32	s15, s15
34029fe0:	ee87 0a07 	vdiv.f32	s0, s14, s14
34029fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
34029fe8:	d602      	bvs.n	34029ff0 <__math_invalidf+0x1c>
34029fea:	2021      	movs	r0, #33	@ 0x21
34029fec:	f7ff bfb4 	b.w	34029f58 <with_errnof>
34029ff0:	4770      	bx	lr

34029ff2 <__ieee754_sqrt>:
34029ff2:	eeb1 0bc0 	vsqrt.f64	d0, d0
34029ff6:	4770      	bx	lr

34029ff8 <__ieee754_log10>:
34029ff8:	ee10 3a90 	vmov	r3, s1
34029ffc:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
3402a000:	b510      	push	{r4, lr}
3402a002:	ed2d 8b02 	vpush	{d8}
3402a006:	da21      	bge.n	3402a04c <__ieee754_log10+0x54>
3402a008:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
3402a00c:	ee10 1a10 	vmov	r1, s0
3402a010:	430a      	orrs	r2, r1
3402a012:	d108      	bne.n	3402a026 <__ieee754_log10+0x2e>
3402a014:	ed9f 6b22 	vldr	d6, [pc, #136]	@ 3402a0a0 <__ieee754_log10+0xa8>
3402a018:	ed9f 7b23 	vldr	d7, [pc, #140]	@ 3402a0a8 <__ieee754_log10+0xb0>
3402a01c:	ee86 0b07 	vdiv.f64	d0, d6, d7
3402a020:	ecbd 8b02 	vpop	{d8}
3402a024:	bd10      	pop	{r4, pc}
3402a026:	2b00      	cmp	r3, #0
3402a028:	da02      	bge.n	3402a030 <__ieee754_log10+0x38>
3402a02a:	ee30 6b40 	vsub.f64	d6, d0, d0
3402a02e:	e7f3      	b.n	3402a018 <__ieee754_log10+0x20>
3402a030:	ed9f 7b1f 	vldr	d7, [pc, #124]	@ 3402a0b0 <__ieee754_log10+0xb8>
3402a034:	f06f 0235 	mvn.w	r2, #53	@ 0x35
3402a038:	ee20 0b07 	vmul.f64	d0, d0, d7
3402a03c:	ee10 3a90 	vmov	r3, s1
3402a040:	4923      	ldr	r1, [pc, #140]	@ (3402a0d0 <__ieee754_log10+0xd8>)
3402a042:	428b      	cmp	r3, r1
3402a044:	dd04      	ble.n	3402a050 <__ieee754_log10+0x58>
3402a046:	ee30 0b00 	vadd.f64	d0, d0, d0
3402a04a:	e7e9      	b.n	3402a020 <__ieee754_log10+0x28>
3402a04c:	2200      	movs	r2, #0
3402a04e:	e7f7      	b.n	3402a040 <__ieee754_log10+0x48>
3402a050:	1518      	asrs	r0, r3, #20
3402a052:	f240 34ff 	movw	r4, #1023	@ 0x3ff
3402a056:	f3c3 0113 	ubfx	r1, r3, #0, #20
3402a05a:	f2a0 30ff 	subw	r0, r0, #1023	@ 0x3ff
3402a05e:	4410      	add	r0, r2
3402a060:	eb00 73d0 	add.w	r3, r0, r0, lsr #31
3402a064:	eba4 70d0 	sub.w	r0, r4, r0, lsr #31
3402a068:	ee08 3a10 	vmov	s16, r3
3402a06c:	ec53 2b10 	vmov	r2, r3, d0
3402a070:	ea41 5300 	orr.w	r3, r1, r0, lsl #20
3402a074:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
3402a078:	ec43 2b10 	vmov	d0, r2, r3
3402a07c:	f7ff fa04 	bl	34029488 <log>
3402a080:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3402a0b8 <__ieee754_log10+0xc0>
3402a084:	ee20 0b07 	vmul.f64	d0, d0, d7
3402a088:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3402a0c0 <__ieee754_log10+0xc8>
3402a08c:	eea8 0b07 	vfma.f64	d0, d8, d7
3402a090:	ed9f 7b0d 	vldr	d7, [pc, #52]	@ 3402a0c8 <__ieee754_log10+0xd0>
3402a094:	eea8 0b07 	vfma.f64	d0, d8, d7
3402a098:	e7c2      	b.n	3402a020 <__ieee754_log10+0x28>
3402a09a:	bf00      	nop
3402a09c:	f3af 8000 	nop.w
3402a0a0:	00000000 	.word	0x00000000
3402a0a4:	c3500000 	.word	0xc3500000
	...
3402a0b4:	43500000 	.word	0x43500000
3402a0b8:	1526e50e 	.word	0x1526e50e
3402a0bc:	3fdbcb7b 	.word	0x3fdbcb7b
3402a0c0:	11f12b36 	.word	0x11f12b36
3402a0c4:	3d59fef3 	.word	0x3d59fef3
3402a0c8:	509f6000 	.word	0x509f6000
3402a0cc:	3fd34413 	.word	0x3fd34413
3402a0d0:	7fefffff 	.word	0x7fefffff

3402a0d4 <_init>:
3402a0d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3402a0d6:	bf00      	nop
3402a0d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
3402a0da:	bc08      	pop	{r3}
3402a0dc:	469e      	mov	lr, r3
3402a0de:	4770      	bx	lr

3402a0e0 <_fini>:
3402a0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3402a0e2:	bf00      	nop
3402a0e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
3402a0e6:	bc08      	pop	{r3}
3402a0e8:	469e      	mov	lr, r3
3402a0ea:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34041660 <SECURE_SystemCoreClockUpdate>:
34041660:	e97f e97f 	sg
34041664:	f7c5 bbaa 	b.w	34006dbc <__acle_se_SECURE_SystemCoreClockUpdate>

34041668 <SECURE_RegisterCallback>:
34041668:	e97f e97f 	sg
3404166c:	f7c2 be90 	b.w	34004390 <__acle_se_SECURE_RegisterCallback>
	...
